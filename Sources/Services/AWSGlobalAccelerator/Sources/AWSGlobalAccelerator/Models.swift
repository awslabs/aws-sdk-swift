//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox


public struct AllowCustomRoutingTrafficOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteAcceleratorOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteCrossAccountAttachmentOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteCustomRoutingAcceleratorOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteCustomRoutingEndpointGroupOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteCustomRoutingListenerOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteEndpointGroupOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteListenerOutput: Swift.Sendable {

    public init() { }
}

public struct DenyCustomRoutingTrafficOutput: Swift.Sendable {

    public init() { }
}

public struct RemoveCustomRoutingEndpointsOutput: Swift.Sendable {

    public init() { }
}

public struct RemoveEndpointsOutput: Swift.Sendable {

    public init() { }
}

extension GlobalAcceleratorClientTypes {

    /// A complex type that contains a Timestamp value and Message for changes that you make to an accelerator in Global Accelerator. Messages stored here provide progress or error information when you update an accelerator from IPv4 to dual-stack, or from dual-stack to IPv4. Global Accelerator stores a maximum of ten event messages.
    public struct AcceleratorEvent: Swift.Sendable {
        /// A string that contains an Event message describing changes or errors when you update an accelerator in Global Accelerator from IPv4 to dual-stack, or dual-stack to IPv4.
        public var message: Swift.String?
        /// A timestamp for when you update an accelerator in Global Accelerator from IPv4 to dual-stack, or dual-stack to IPv4.
        public var timestamp: Foundation.Date?

        public init(
            message: Swift.String? = nil,
            timestamp: Foundation.Date? = nil
        )
        {
            self.message = message
            self.timestamp = timestamp
        }
    }
}

extension GlobalAcceleratorClientTypes {

    public enum IpAddressType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dualStack
        case ipv4
        case sdkUnknown(Swift.String)

        public static var allCases: [IpAddressType] {
            return [
                .dualStack,
                .ipv4
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dualStack: return "DUAL_STACK"
            case .ipv4: return "IPV4"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlobalAcceleratorClientTypes {

    public enum IpAddressFamily: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ipv4
        case ipv6
        case sdkUnknown(Swift.String)

        public static var allCases: [IpAddressFamily] {
            return [
                .ipv4,
                .ipv6
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ipv4: return "IPv4"
            case .ipv6: return "IPv6"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlobalAcceleratorClientTypes {

    /// A complex type for the set of IP addresses for an accelerator.
    public struct IpSet: Swift.Sendable {
        /// The types of IP addresses included in this IP set.
        public var ipAddressFamily: GlobalAcceleratorClientTypes.IpAddressFamily?
        /// The array of IP addresses in the IP address set. An IP address set can have a maximum of two IP addresses.
        public var ipAddresses: [Swift.String]?
        /// IpFamily is deprecated and has been replaced by IpAddressFamily.
        @available(*, deprecated, message: "IpFamily has been replaced by IpAddressFamily")
        public var ipFamily: Swift.String?

        public init(
            ipAddressFamily: GlobalAcceleratorClientTypes.IpAddressFamily? = nil,
            ipAddresses: [Swift.String]? = nil,
            ipFamily: Swift.String? = nil
        )
        {
            self.ipAddressFamily = ipAddressFamily
            self.ipAddresses = ipAddresses
            self.ipFamily = ipFamily
        }
    }
}

extension GlobalAcceleratorClientTypes {

    public enum AcceleratorStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deployed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [AcceleratorStatus] {
            return [
                .deployed,
                .inProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deployed: return "DEPLOYED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlobalAcceleratorClientTypes {

    /// An accelerator is a complex type that includes one or more listeners that process inbound connections and then direct traffic to one or more endpoint groups, each of which includes endpoints, such as load balancers.
    public struct Accelerator: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the accelerator.
        public var acceleratorArn: Swift.String?
        /// The date and time that the accelerator was created.
        public var createdTime: Foundation.Date?
        /// The Domain Name System (DNS) name that Global Accelerator creates that points to an accelerator's static IPv4 addresses. The naming convention for the DNS name for an accelerator is the following: A lowercase letter a, followed by a 16-bit random hex string, followed by .awsglobalaccelerator.com. For example: a1234567890abcdef.awsglobalaccelerator.com. If you have a dual-stack accelerator, you also have a second DNS name, DualStackDnsName, that points to both the A record and the AAAA record for all four static addresses for the accelerator: two IPv4 addresses and two IPv6 addresses. For more information about the default DNS name, see [ Support for DNS addressing in Global Accelerator](https://docs.aws.amazon.com/global-accelerator/latest/dg/dns-addressing-custom-domains.dns-addressing.html) in the Global Accelerator Developer Guide.
        public var dnsName: Swift.String?
        /// The Domain Name System (DNS) name that Global Accelerator creates that points to a dual-stack accelerator's four static IP addresses: two IPv4 addresses and two IPv6 addresses. The naming convention for the dual-stack DNS name is the following: A lowercase letter a, followed by a 16-bit random hex string, followed by .dualstack.awsglobalaccelerator.com. For example: a1234567890abcdef.dualstack.awsglobalaccelerator.com. Note: Global Accelerator also assigns a default DNS name, DnsName, to your accelerator that points just to the static IPv4 addresses. For more information, see [ Support for DNS addressing in Global Accelerator](https://docs.aws.amazon.com/global-accelerator/latest/dg/about-accelerators.html#about-accelerators.dns-addressing) in the Global Accelerator Developer Guide.
        public var dualStackDnsName: Swift.String?
        /// Indicates whether the accelerator is enabled. The value is true or false. The default value is true. If the value is set to true, the accelerator cannot be deleted. If set to false, accelerator can be deleted.
        public var enabled: Swift.Bool?
        /// A history of changes that you make to an accelerator in Global Accelerator.
        public var events: [GlobalAcceleratorClientTypes.AcceleratorEvent]?
        /// The IP address type that an accelerator supports. For a standard accelerator, the value can be IPV4 or DUAL_STACK.
        public var ipAddressType: GlobalAcceleratorClientTypes.IpAddressType?
        /// The static IP addresses that Global Accelerator associates with the accelerator.
        public var ipSets: [GlobalAcceleratorClientTypes.IpSet]?
        /// The date and time that the accelerator was last modified.
        public var lastModifiedTime: Foundation.Date?
        /// The name of the accelerator. The name must contain only alphanumeric characters or hyphens (-), and must not begin or end with a hyphen.
        public var name: Swift.String?
        /// Describes the deployment status of the accelerator.
        public var status: GlobalAcceleratorClientTypes.AcceleratorStatus?

        public init(
            acceleratorArn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            dnsName: Swift.String? = nil,
            dualStackDnsName: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            events: [GlobalAcceleratorClientTypes.AcceleratorEvent]? = nil,
            ipAddressType: GlobalAcceleratorClientTypes.IpAddressType? = nil,
            ipSets: [GlobalAcceleratorClientTypes.IpSet]? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            status: GlobalAcceleratorClientTypes.AcceleratorStatus? = nil
        )
        {
            self.acceleratorArn = acceleratorArn
            self.createdTime = createdTime
            self.dnsName = dnsName
            self.dualStackDnsName = dualStackDnsName
            self.enabled = enabled
            self.events = events
            self.ipAddressType = ipAddressType
            self.ipSets = ipSets
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.status = status
        }
    }
}

extension GlobalAcceleratorClientTypes {

    /// Attributes of an accelerator.
    public struct AcceleratorAttributes: Swift.Sendable {
        /// Indicates whether flow logs are enabled. The default value is false. If the value is true, FlowLogsS3Bucket and FlowLogsS3Prefix must be specified. For more information, see [Flow logs](https://docs.aws.amazon.com/global-accelerator/latest/dg/monitoring-global-accelerator.flow-logs.html) in the Global Accelerator Developer Guide.
        public var flowLogsEnabled: Swift.Bool?
        /// The name of the Amazon S3 bucket for the flow logs. Attribute is required if FlowLogsEnabled is true. The bucket must exist and have a bucket policy that grants Global Accelerator permission to write to the bucket.
        public var flowLogsS3Bucket: Swift.String?
        /// The prefix for the location in the Amazon S3 bucket for the flow logs. Attribute is required if FlowLogsEnabled is true. If you specify slash (/) for the S3 bucket prefix, the log file bucket folder structure will include a double slash (//), like the following: s3-bucket_name//AWSLogs/aws_account_id
        public var flowLogsS3Prefix: Swift.String?

        public init(
            flowLogsEnabled: Swift.Bool? = nil,
            flowLogsS3Bucket: Swift.String? = nil,
            flowLogsS3Prefix: Swift.String? = nil
        )
        {
            self.flowLogsEnabled = flowLogsEnabled
            self.flowLogsS3Bucket = flowLogsS3Bucket
            self.flowLogsS3Prefix = flowLogsS3Prefix
        }
    }
}

/// The accelerator that you specified could not be disabled.
public struct AcceleratorNotDisabledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AcceleratorNotDisabledException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The accelerator that you specified doesn't exist.
public struct AcceleratorNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AcceleratorNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You don't have access permission.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You can't use both of those options.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The endpoint that you specified doesn't exist.
public struct EndpointAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EndpointAlreadyExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The endpoint group that you specified doesn't exist.
public struct EndpointGroupNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EndpointGroupNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// There was an internal error for Global Accelerator.
public struct InternalServiceErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServiceErrorException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An argument that you specified is invalid.
public struct InvalidArgumentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidArgumentException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Processing your request would cause you to exceed an Global Accelerator limit.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension GlobalAcceleratorClientTypes {

    /// The list of endpoint objects. For custom routing, this is a list of virtual private cloud (VPC) subnet IDs.
    public struct CustomRoutingEndpointConfiguration: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the cross-account attachment that specifies the endpoints (resources) that can be added to accelerators and principals that have permission to add the endpoints.
        public var attachmentArn: Swift.String?
        /// An ID for the endpoint. For custom routing accelerators, this is the virtual private cloud (VPC) subnet ID.
        public var endpointId: Swift.String?

        public init(
            attachmentArn: Swift.String? = nil,
            endpointId: Swift.String? = nil
        )
        {
            self.attachmentArn = attachmentArn
            self.endpointId = endpointId
        }
    }
}

public struct AddCustomRoutingEndpointsInput: Swift.Sendable {
    /// The list of endpoint objects to add to a custom routing accelerator.
    /// This member is required.
    public var endpointConfigurations: [GlobalAcceleratorClientTypes.CustomRoutingEndpointConfiguration]?
    /// The Amazon Resource Name (ARN) of the endpoint group for the custom routing endpoint.
    /// This member is required.
    public var endpointGroupArn: Swift.String?

    public init(
        endpointConfigurations: [GlobalAcceleratorClientTypes.CustomRoutingEndpointConfiguration]? = nil,
        endpointGroupArn: Swift.String? = nil
    )
    {
        self.endpointConfigurations = endpointConfigurations
        self.endpointGroupArn = endpointGroupArn
    }
}

extension GlobalAcceleratorClientTypes {

    /// A complex type for an endpoint for a custom routing accelerator. Each endpoint group can include one or more endpoints, which are virtual private cloud (VPC) subnets.
    public struct CustomRoutingEndpointDescription: Swift.Sendable {
        /// An ID for the endpoint. For custom routing accelerators, this is the virtual private cloud (VPC) subnet ID.
        public var endpointId: Swift.String?

        public init(
            endpointId: Swift.String? = nil
        )
        {
            self.endpointId = endpointId
        }
    }
}

public struct AddCustomRoutingEndpointsOutput: Swift.Sendable {
    /// The endpoint objects added to the custom routing accelerator.
    public var endpointDescriptions: [GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription]?
    /// The Amazon Resource Name (ARN) of the endpoint group for the custom routing endpoint.
    public var endpointGroupArn: Swift.String?

    public init(
        endpointDescriptions: [GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription]? = nil,
        endpointGroupArn: Swift.String? = nil
    )
    {
        self.endpointDescriptions = endpointDescriptions
        self.endpointGroupArn = endpointGroupArn
    }
}

/// There's already a transaction in progress. Another transaction can't be processed.
public struct TransactionInProgressException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TransactionInProgressException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension GlobalAcceleratorClientTypes {

    /// A complex type for endpoints. A resource must be valid and active when you add it as an endpoint.
    public struct EndpointConfiguration: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the cross-account attachment that specifies the endpoints (resources) that can be added to accelerators and principals that have permission to add the endpoints.
        public var attachmentArn: Swift.String?
        /// Indicates whether client IP address preservation is enabled for an endpoint. The value is true or false. The default value is true for Application Load Balancer endpoints. If the value is set to true, the client's IP address is preserved in the X-Forwarded-For request header as traffic travels to applications on the endpoint fronted by the accelerator. Client IP address preservation is supported, in specific Amazon Web Services Regions, for endpoints that are Application Load Balancers, Amazon EC2 instances, and Network Load Balancers with security groups. IMPORTANT: You cannot use client IP address preservation with Network Load Balancers with TLS listeners. For more information, see [ Preserve client IP addresses in Global Accelerator](https://docs.aws.amazon.com/global-accelerator/latest/dg/preserve-client-ip-address.html) in the Global Accelerator Developer Guide.
        public var clientIPPreservationEnabled: Swift.Bool?
        /// An ID for the endpoint. If the endpoint is a Network Load Balancer or Application Load Balancer, this is the Amazon Resource Name (ARN) of the resource. If the endpoint is an Elastic IP address, this is the Elastic IP address allocation ID. For Amazon EC2 instances, this is the EC2 instance ID. A resource must be valid and active when you add it as an endpoint. For cross-account endpoints, this must be the ARN of the resource.
        public var endpointId: Swift.String?
        /// The weight associated with the endpoint. When you add weights to endpoints, you configure Global Accelerator to route traffic based on proportions that you specify. For example, you might specify endpoint weights of 4, 5, 5, and 6 (sum=20). The result is that 4/20 of your traffic, on average, is routed to the first endpoint, 5/20 is routed both to the second and third endpoints, and 6/20 is routed to the last endpoint. For more information, see [Endpoint weights](https://docs.aws.amazon.com/global-accelerator/latest/dg/about-endpoints-endpoint-weights.html) in the Global Accelerator Developer Guide.
        public var weight: Swift.Int?

        public init(
            attachmentArn: Swift.String? = nil,
            clientIPPreservationEnabled: Swift.Bool? = nil,
            endpointId: Swift.String? = nil,
            weight: Swift.Int? = nil
        )
        {
            self.attachmentArn = attachmentArn
            self.clientIPPreservationEnabled = clientIPPreservationEnabled
            self.endpointId = endpointId
            self.weight = weight
        }
    }
}

public struct AddEndpointsInput: Swift.Sendable {
    /// The list of endpoint objects.
    /// This member is required.
    public var endpointConfigurations: [GlobalAcceleratorClientTypes.EndpointConfiguration]?
    /// The Amazon Resource Name (ARN) of the endpoint group.
    /// This member is required.
    public var endpointGroupArn: Swift.String?

    public init(
        endpointConfigurations: [GlobalAcceleratorClientTypes.EndpointConfiguration]? = nil,
        endpointGroupArn: Swift.String? = nil
    )
    {
        self.endpointConfigurations = endpointConfigurations
        self.endpointGroupArn = endpointGroupArn
    }
}

extension GlobalAcceleratorClientTypes {

    public enum HealthState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case healthy
        case initial
        case unhealthy
        case sdkUnknown(Swift.String)

        public static var allCases: [HealthState] {
            return [
                .healthy,
                .initial,
                .unhealthy
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .healthy: return "HEALTHY"
            case .initial: return "INITIAL"
            case .unhealthy: return "UNHEALTHY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlobalAcceleratorClientTypes {

    /// A complex type for an endpoint. Each endpoint group can include one or more endpoints, such as load balancers.
    public struct EndpointDescription: Swift.Sendable {
        /// Indicates whether client IP address preservation is enabled for an endpoint. The value is true or false. The default value is true for Application Load Balancers endpoints. If the value is set to true, the client's IP address is preserved in the X-Forwarded-For request header as traffic travels to applications on the endpoint fronted by the accelerator. Client IP address preservation is supported, in specific Amazon Web Services Regions, for endpoints that are Application Load Balancers, Amazon EC2 instances, and Network Load Balancers with security groups. IMPORTANT: You cannot use client IP address preservation with Network Load Balancers with TLS listeners. For more information, see [ Preserve client IP addresses in Global Accelerator](https://docs.aws.amazon.com/global-accelerator/latest/dg/preserve-client-ip-address.html) in the Global Accelerator Developer Guide.
        public var clientIPPreservationEnabled: Swift.Bool?
        /// An ID for the endpoint. If the endpoint is a Network Load Balancer or Application Load Balancer, this is the Amazon Resource Name (ARN) of the resource. If the endpoint is an Elastic IP address, this is the Elastic IP address allocation ID. For Amazon EC2 instances, this is the EC2 instance ID. An Application Load Balancer can be either internal or internet-facing.
        public var endpointId: Swift.String?
        /// Returns a null result.
        public var healthReason: Swift.String?
        /// The health status of the endpoint.
        public var healthState: GlobalAcceleratorClientTypes.HealthState?
        /// The weight associated with the endpoint. When you add weights to endpoints, you configure Global Accelerator to route traffic based on proportions that you specify. For example, you might specify endpoint weights of 4, 5, 5, and 6 (sum=20). The result is that 4/20 of your traffic, on average, is routed to the first endpoint, 5/20 is routed both to the second and third endpoints, and 6/20 is routed to the last endpoint. For more information, see [Endpoint weights](https://docs.aws.amazon.com/global-accelerator/latest/dg/about-endpoints-endpoint-weights.html) in the Global Accelerator Developer Guide.
        public var weight: Swift.Int?

        public init(
            clientIPPreservationEnabled: Swift.Bool? = nil,
            endpointId: Swift.String? = nil,
            healthReason: Swift.String? = nil,
            healthState: GlobalAcceleratorClientTypes.HealthState? = nil,
            weight: Swift.Int? = nil
        )
        {
            self.clientIPPreservationEnabled = clientIPPreservationEnabled
            self.endpointId = endpointId
            self.healthReason = healthReason
            self.healthState = healthState
            self.weight = weight
        }
    }
}

public struct AddEndpointsOutput: Swift.Sendable {
    /// The list of endpoint objects.
    public var endpointDescriptions: [GlobalAcceleratorClientTypes.EndpointDescription]?
    /// The Amazon Resource Name (ARN) of the endpoint group.
    public var endpointGroupArn: Swift.String?

    public init(
        endpointDescriptions: [GlobalAcceleratorClientTypes.EndpointDescription]? = nil,
        endpointGroupArn: Swift.String? = nil
    )
    {
        self.endpointDescriptions = endpointDescriptions
        self.endpointGroupArn = endpointGroupArn
    }
}

/// The CIDR that you specified was not found or is incorrect.
public struct ByoipCidrNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ByoipCidrNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The CIDR that you specified is not valid for this action. For example, the state of the CIDR might be incorrect for this action.
public struct IncorrectCidrStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IncorrectCidrStateException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct AdvertiseByoipCidrInput: Swift.Sendable {
    /// The address range, in CIDR notation. This must be the exact range that you provisioned. You can't advertise only a portion of the provisioned range. For more information, see [Bring your own IP addresses (BYOIP)](https://docs.aws.amazon.com/global-accelerator/latest/dg/using-byoip.html) in the Global Accelerator Developer Guide.
    /// This member is required.
    public var cidr: Swift.String?

    public init(
        cidr: Swift.String? = nil
    )
    {
        self.cidr = cidr
    }
}

extension GlobalAcceleratorClientTypes {

    /// A complex type that contains a Message and a Timestamp value for changes that you make in the status of an IP address range that you bring to Global Accelerator through bring your own IP address (BYOIP).
    public struct ByoipCidrEvent: Swift.Sendable {
        /// A string that contains an Event message describing changes that you make in the status of an IP address range that you bring to Global Accelerator through bring your own IP address (BYOIP).
        public var message: Swift.String?
        /// A timestamp for when you make a status change for an IP address range that you bring to Global Accelerator through bring your own IP address (BYOIP).
        public var timestamp: Foundation.Date?

        public init(
            message: Swift.String? = nil,
            timestamp: Foundation.Date? = nil
        )
        {
            self.message = message
            self.timestamp = timestamp
        }
    }
}

extension GlobalAcceleratorClientTypes {

    public enum ByoipCidrState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case advertising
        case deprovisioned
        case failedAdvertising
        case failedDeprovision
        case failedProvision
        case failedWithdraw
        case pendingAdvertising
        case pendingDeprovisioning
        case pendingProvisioning
        case pendingWithdrawing
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [ByoipCidrState] {
            return [
                .advertising,
                .deprovisioned,
                .failedAdvertising,
                .failedDeprovision,
                .failedProvision,
                .failedWithdraw,
                .pendingAdvertising,
                .pendingDeprovisioning,
                .pendingProvisioning,
                .pendingWithdrawing,
                .ready
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .advertising: return "ADVERTISING"
            case .deprovisioned: return "DEPROVISIONED"
            case .failedAdvertising: return "FAILED_ADVERTISING"
            case .failedDeprovision: return "FAILED_DEPROVISION"
            case .failedProvision: return "FAILED_PROVISION"
            case .failedWithdraw: return "FAILED_WITHDRAW"
            case .pendingAdvertising: return "PENDING_ADVERTISING"
            case .pendingDeprovisioning: return "PENDING_DEPROVISIONING"
            case .pendingProvisioning: return "PENDING_PROVISIONING"
            case .pendingWithdrawing: return "PENDING_WITHDRAWING"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlobalAcceleratorClientTypes {

    /// Information about an IP address range that is provisioned for use with your Amazon Web Services resources through bring your own IP address (BYOIP). The following describes each BYOIP State that your IP address range can be in.
    ///
    /// * PENDING_PROVISIONING — You’ve submitted a request to provision an IP address range but it is not yet provisioned with Global Accelerator.
    ///
    /// * READY — The address range is provisioned with Global Accelerator and can be advertised.
    ///
    /// * PENDING_ADVERTISING — You’ve submitted a request for Global Accelerator to advertise an address range but it is not yet being advertised.
    ///
    /// * ADVERTISING — The address range is being advertised by Global Accelerator.
    ///
    /// * PENDING_WITHDRAWING — You’ve submitted a request to withdraw an address range from being advertised but it is still being advertised by Global Accelerator.
    ///
    /// * PENDING_DEPROVISIONING — You’ve submitted a request to deprovision an address range from Global Accelerator but it is still provisioned.
    ///
    /// * DEPROVISIONED — The address range is deprovisioned from Global Accelerator.
    ///
    /// * FAILED_PROVISION — The request to provision the address range from Global Accelerator was not successful. Please make sure that you provide all of the correct information, and try again. If the request fails a second time, contact Amazon Web Services support.
    ///
    /// * FAILED_ADVERTISING — The request for Global Accelerator to advertise the address range was not successful. Please make sure that you provide all of the correct information, and try again. If the request fails a second time, contact Amazon Web Services support.
    ///
    /// * FAILED_WITHDRAW — The request to withdraw the address range from advertising by Global Accelerator was not successful. Please make sure that you provide all of the correct information, and try again. If the request fails a second time, contact Amazon Web Services support.
    ///
    /// * FAILED_DEPROVISION — The request to deprovision the address range from Global Accelerator was not successful. Please make sure that you provide all of the correct information, and try again. If the request fails a second time, contact Amazon Web Services support.
    public struct ByoipCidr: Swift.Sendable {
        /// The address range, in CIDR notation. For more information, see [Bring your own IP addresses (BYOIP)](https://docs.aws.amazon.com/global-accelerator/latest/dg/using-byoip.html) in the Global Accelerator Developer Guide.
        public var cidr: Swift.String?
        /// A history of status changes for an IP address range that you bring to Global Accelerator through bring your own IP address (BYOIP).
        public var events: [GlobalAcceleratorClientTypes.ByoipCidrEvent]?
        /// The state of the address pool.
        public var state: GlobalAcceleratorClientTypes.ByoipCidrState?

        public init(
            cidr: Swift.String? = nil,
            events: [GlobalAcceleratorClientTypes.ByoipCidrEvent]? = nil,
            state: GlobalAcceleratorClientTypes.ByoipCidrState? = nil
        )
        {
            self.cidr = cidr
            self.events = events
            self.state = state
        }
    }
}

public struct AdvertiseByoipCidrOutput: Swift.Sendable {
    /// Information about the address range.
    public var byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr?

    public init(
        byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr? = nil
    )
    {
        self.byoipCidr = byoipCidr
    }
}

public struct AllowCustomRoutingTrafficInput: Swift.Sendable {
    /// Indicates whether all destination IP addresses and ports for a specified VPC subnet endpoint can receive traffic from a custom routing accelerator. The value is TRUE or FALSE. When set to TRUE, all destinations in the custom routing VPC subnet can receive traffic. Note that you cannot specify destination IP addresses and ports when the value is set to TRUE. When set to FALSE (or not specified), you must specify a list of destination IP addresses that are allowed to receive traffic. A list of ports is optional. If you don't specify a list of ports, the ports that can accept traffic is the same as the ports configured for the endpoint group. The default value is FALSE.
    public var allowAllTrafficToEndpoint: Swift.Bool?
    /// A list of specific Amazon EC2 instance IP addresses (destination addresses) in a subnet that you want to allow to receive traffic. The IP addresses must be a subset of the IP addresses that you specified for the endpoint group. DestinationAddresses is required if AllowAllTrafficToEndpoint is FALSE or is not specified.
    public var destinationAddresses: [Swift.String]?
    /// A list of specific Amazon EC2 instance ports (destination ports) that you want to allow to receive traffic.
    public var destinationPorts: [Swift.Int]?
    /// The Amazon Resource Name (ARN) of the endpoint group.
    /// This member is required.
    public var endpointGroupArn: Swift.String?
    /// An ID for the endpoint. For custom routing accelerators, this is the virtual private cloud (VPC) subnet ID.
    /// This member is required.
    public var endpointId: Swift.String?

    public init(
        allowAllTrafficToEndpoint: Swift.Bool? = nil,
        destinationAddresses: [Swift.String]? = nil,
        destinationPorts: [Swift.Int]? = nil,
        endpointGroupArn: Swift.String? = nil,
        endpointId: Swift.String? = nil
    )
    {
        self.allowAllTrafficToEndpoint = allowAllTrafficToEndpoint
        self.destinationAddresses = destinationAddresses
        self.destinationPorts = destinationPorts
        self.endpointGroupArn = endpointGroupArn
        self.endpointId = endpointId
    }
}

/// The listener that you specified has an endpoint group associated with it. You must remove all dependent resources from a listener before you can delete it.
public struct AssociatedEndpointGroupFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AssociatedEndpointGroupFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The accelerator that you specified has a listener associated with it. You must remove all dependent resources from an accelerator before you can delete it.
public struct AssociatedListenerFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AssociatedListenerFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension GlobalAcceleratorClientTypes {

    /// A resource is one of the following: the ARN for an Amazon Web Services resource that is supported by Global Accelerator to be added as an endpoint, or a CIDR range that specifies a bring your own IP (BYOIP) address pool.
    public struct Resource: Swift.Sendable {
        /// An IP address range, in CIDR format, that is specified as resource. The address must be provisioned and advertised in Global Accelerator by following the bring your own IP address (BYOIP) process for Global Accelerator For more information, see [Bring your own IP addresses (BYOIP)](https://docs.aws.amazon.com/global-accelerator/latest/dg/using-byoip.html) in the Global Accelerator Developer Guide.
        public var cidr: Swift.String?
        /// The endpoint ID for the endpoint that is specified as a Amazon Web Services resource. An endpoint ID for the cross-account feature is the ARN of an Amazon Web Services resource, such as a Network Load Balancer, that Global Accelerator supports as an endpoint for an accelerator.
        public var endpointId: Swift.String?
        /// The Amazon Web Services Region where a shared endpoint resource is located.
        public var region: Swift.String?

        public init(
            cidr: Swift.String? = nil,
            endpointId: Swift.String? = "",
            region: Swift.String? = nil
        )
        {
            self.cidr = cidr
            self.endpointId = endpointId
            self.region = region
        }
    }
}

extension GlobalAcceleratorClientTypes {

    /// A cross-account attachment in Global Accelerator. A cross-account attachment specifies the principals who have permission to work with resources in your account, which you also list in the attachment.
    public struct Attachment: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the cross-account attachment.
        public var attachmentArn: Swift.String?
        /// The date and time that the cross-account attachment was created.
        public var createdTime: Foundation.Date?
        /// The date and time that the cross-account attachment was last modified.
        public var lastModifiedTime: Foundation.Date?
        /// The name of the cross-account attachment.
        public var name: Swift.String?
        /// The principals included in the cross-account attachment.
        public var principals: [Swift.String]?
        /// The resources included in the cross-account attachment.
        public var resources: [GlobalAcceleratorClientTypes.Resource]?

        public init(
            attachmentArn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            principals: [Swift.String]? = nil,
            resources: [GlobalAcceleratorClientTypes.Resource]? = nil
        )
        {
            self.attachmentArn = attachmentArn
            self.createdTime = createdTime
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.principals = principals
            self.resources = resources
        }
    }
}

/// No cross-account attachment was found.
public struct AttachmentNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AttachmentNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension GlobalAcceleratorClientTypes {

    /// Provides authorization for Amazon to bring a specific IP address range to a specific Amazon Web Services account using bring your own IP addresses (BYOIP). For more information, see [Bring your own IP addresses (BYOIP)](https://docs.aws.amazon.com/global-accelerator/latest/dg/using-byoip.html) in the Global Accelerator Developer Guide.
    public struct CidrAuthorizationContext: Swift.Sendable {
        /// The plain-text authorization message for the prefix and account.
        /// This member is required.
        public var message: Swift.String?
        /// The signed authorization message for the prefix and account.
        /// This member is required.
        public var signature: Swift.String?

        public init(
            message: Swift.String? = nil,
            signature: Swift.String? = nil
        )
        {
            self.message = message
            self.signature = signature
        }
    }
}

extension GlobalAcceleratorClientTypes {

    public enum ClientAffinity: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `none`
        case sourceIp
        case sdkUnknown(Swift.String)

        public static var allCases: [ClientAffinity] {
            return [
                .none,
                .sourceIp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .sourceIp: return "SOURCE_IP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlobalAcceleratorClientTypes {

    /// A complex type that contains a Tag key and Tag value.
    public struct Tag: Swift.Sendable {
        /// A string that contains a Tag key.
        /// This member is required.
        public var key: Swift.String?
        /// A string that contains a Tag value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

public struct CreateAcceleratorInput: Swift.Sendable {
    /// Indicates whether an accelerator is enabled. The value is true or false. The default value is true. If the value is set to true, an accelerator cannot be deleted. If set to false, the accelerator can be deleted.
    public var enabled: Swift.Bool?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency—that is, the uniqueness—of an accelerator.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The IP address type that an accelerator supports. For a standard accelerator, the value can be IPV4 or DUAL_STACK.
    public var ipAddressType: GlobalAcceleratorClientTypes.IpAddressType?
    /// Optionally, if you've added your own IP address pool to Global Accelerator (BYOIP), you can choose an IPv4 address from your own pool to use for the accelerator's static IPv4 address when you create an accelerator. After you bring an address range to Amazon Web Services, it appears in your account as an address pool. When you create an accelerator, you can assign one IPv4 address from your range to it. Global Accelerator assigns you a second static IPv4 address from an Amazon IP address range. If you bring two IPv4 address ranges to Amazon Web Services, you can assign one IPv4 address from each range to your accelerator. This restriction is because Global Accelerator assigns each address range to a different network zone, for high availability. You can specify one or two addresses, separated by a space. Do not include the /32 suffix. Note that you can't update IP addresses for an existing accelerator. To change them, you must create a new accelerator with the new addresses. For more information, see [Bring your own IP addresses (BYOIP)](https://docs.aws.amazon.com/global-accelerator/latest/dg/using-byoip.html) in the Global Accelerator Developer Guide.
    public var ipAddresses: [Swift.String]?
    /// The name of the accelerator. The name can have a maximum of 64 characters, must contain only alphanumeric characters, periods (.), or hyphens (-), and must not begin or end with a hyphen or period.
    /// This member is required.
    public var name: Swift.String?
    /// Create tags for an accelerator. For more information, see [Tagging in Global Accelerator](https://docs.aws.amazon.com/global-accelerator/latest/dg/tagging-in-global-accelerator.html) in the Global Accelerator Developer Guide.
    public var tags: [GlobalAcceleratorClientTypes.Tag]?

    public init(
        enabled: Swift.Bool? = nil,
        idempotencyToken: Swift.String? = nil,
        ipAddressType: GlobalAcceleratorClientTypes.IpAddressType? = nil,
        ipAddresses: [Swift.String]? = nil,
        name: Swift.String? = nil,
        tags: [GlobalAcceleratorClientTypes.Tag]? = nil
    )
    {
        self.enabled = enabled
        self.idempotencyToken = idempotencyToken
        self.ipAddressType = ipAddressType
        self.ipAddresses = ipAddresses
        self.name = name
        self.tags = tags
    }
}

public struct CreateAcceleratorOutput: Swift.Sendable {
    /// The accelerator that is created by specifying a listener and the supported IP address types.
    public var accelerator: GlobalAcceleratorClientTypes.Accelerator?

    public init(
        accelerator: GlobalAcceleratorClientTypes.Accelerator? = nil
    )
    {
        self.accelerator = accelerator
    }
}

public struct CreateCrossAccountAttachmentInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency—that is, the uniqueness—of the request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The name of the cross-account attachment.
    /// This member is required.
    public var name: Swift.String?
    /// The principals to include in the cross-account attachment. A principal can be an Amazon Web Services account number or the Amazon Resource Name (ARN) for an accelerator.
    public var principals: [Swift.String]?
    /// The Amazon Resource Names (ARNs) for the resources to include in the cross-account attachment. A resource can be any supported Amazon Web Services resource type for Global Accelerator or a CIDR range for a bring your own IP address (BYOIP) address pool.
    public var resources: [GlobalAcceleratorClientTypes.Resource]?
    /// Add tags for a cross-account attachment. For more information, see [Tagging in Global Accelerator](https://docs.aws.amazon.com/global-accelerator/latest/dg/tagging-in-global-accelerator.html) in the Global Accelerator Developer Guide.
    public var tags: [GlobalAcceleratorClientTypes.Tag]?

    public init(
        idempotencyToken: Swift.String? = nil,
        name: Swift.String? = nil,
        principals: [Swift.String]? = nil,
        resources: [GlobalAcceleratorClientTypes.Resource]? = nil,
        tags: [GlobalAcceleratorClientTypes.Tag]? = nil
    )
    {
        self.idempotencyToken = idempotencyToken
        self.name = name
        self.principals = principals
        self.resources = resources
        self.tags = tags
    }
}

public struct CreateCrossAccountAttachmentOutput: Swift.Sendable {
    /// Information about the cross-account attachment.
    public var crossAccountAttachment: GlobalAcceleratorClientTypes.Attachment?

    public init(
        crossAccountAttachment: GlobalAcceleratorClientTypes.Attachment? = nil
    )
    {
        self.crossAccountAttachment = crossAccountAttachment
    }
}

public struct CreateCustomRoutingAcceleratorInput: Swift.Sendable {
    /// Indicates whether an accelerator is enabled. The value is true or false. The default value is true. If the value is set to true, an accelerator cannot be deleted. If set to false, the accelerator can be deleted.
    public var enabled: Swift.Bool?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency—that is, the uniqueness—of the request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The IP address type that an accelerator supports. For a custom routing accelerator, the value must be IPV4.
    public var ipAddressType: GlobalAcceleratorClientTypes.IpAddressType?
    /// Optionally, if you've added your own IP address pool to Global Accelerator (BYOIP), you can choose an IPv4 address from your own pool to use for the accelerator's static IPv4 address when you create an accelerator. After you bring an address range to Amazon Web Services, it appears in your account as an address pool. When you create an accelerator, you can assign one IPv4 address from your range to it. Global Accelerator assigns you a second static IPv4 address from an Amazon IP address range. If you bring two IPv4 address ranges to Amazon Web Services, you can assign one IPv4 address from each range to your accelerator. This restriction is because Global Accelerator assigns each address range to a different network zone, for high availability. You can specify one or two addresses, separated by a space. Do not include the /32 suffix. Note that you can't update IP addresses for an existing accelerator. To change them, you must create a new accelerator with the new addresses. For more information, see [Bring your own IP addresses (BYOIP)](https://docs.aws.amazon.com/global-accelerator/latest/dg/using-byoip.html) in the Global Accelerator Developer Guide.
    public var ipAddresses: [Swift.String]?
    /// The name of a custom routing accelerator. The name can have a maximum of 64 characters, must contain only alphanumeric characters or hyphens (-), and must not begin or end with a hyphen.
    /// This member is required.
    public var name: Swift.String?
    /// Create tags for an accelerator. For more information, see [Tagging in Global Accelerator](https://docs.aws.amazon.com/global-accelerator/latest/dg/tagging-in-global-accelerator.html) in the Global Accelerator Developer Guide.
    public var tags: [GlobalAcceleratorClientTypes.Tag]?

    public init(
        enabled: Swift.Bool? = nil,
        idempotencyToken: Swift.String? = nil,
        ipAddressType: GlobalAcceleratorClientTypes.IpAddressType? = nil,
        ipAddresses: [Swift.String]? = nil,
        name: Swift.String? = nil,
        tags: [GlobalAcceleratorClientTypes.Tag]? = nil
    )
    {
        self.enabled = enabled
        self.idempotencyToken = idempotencyToken
        self.ipAddressType = ipAddressType
        self.ipAddresses = ipAddresses
        self.name = name
        self.tags = tags
    }
}

extension GlobalAcceleratorClientTypes {

    public enum CustomRoutingAcceleratorStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deployed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomRoutingAcceleratorStatus] {
            return [
                .deployed,
                .inProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deployed: return "DEPLOYED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlobalAcceleratorClientTypes {

    /// Attributes of a custom routing accelerator.
    public struct CustomRoutingAccelerator: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the custom routing accelerator.
        public var acceleratorArn: Swift.String?
        /// The date and time that the accelerator was created.
        public var createdTime: Foundation.Date?
        /// The Domain Name System (DNS) name that Global Accelerator creates that points to an accelerator's static IPv4 addresses. The naming convention for the DNS name is the following: A lowercase letter a, followed by a 16-bit random hex string, followed by .awsglobalaccelerator.com. For example: a1234567890abcdef.awsglobalaccelerator.com. If you have a dual-stack accelerator, you also have a second DNS name, DualStackDnsName, that points to both the A record and the AAAA record for all four static addresses for the accelerator: two IPv4 addresses and two IPv6 addresses. For more information about the default DNS name, see [ Support for DNS addressing in Global Accelerator](https://docs.aws.amazon.com/global-accelerator/latest/dg/dns-addressing-custom-domains.dns-addressing.html) in the Global Accelerator Developer Guide.
        public var dnsName: Swift.String?
        /// Indicates whether the accelerator is enabled. The value is true or false. The default value is true. If the value is set to true, the accelerator cannot be deleted. If set to false, accelerator can be deleted.
        public var enabled: Swift.Bool?
        /// The IP address type that an accelerator supports. For a custom routing accelerator, the value must be IPV4.
        public var ipAddressType: GlobalAcceleratorClientTypes.IpAddressType?
        /// The static IP addresses that Global Accelerator associates with the accelerator.
        public var ipSets: [GlobalAcceleratorClientTypes.IpSet]?
        /// The date and time that the accelerator was last modified.
        public var lastModifiedTime: Foundation.Date?
        /// The name of the accelerator. The name must contain only alphanumeric characters or hyphens (-), and must not begin or end with a hyphen.
        public var name: Swift.String?
        /// Describes the deployment status of the accelerator.
        public var status: GlobalAcceleratorClientTypes.CustomRoutingAcceleratorStatus?

        public init(
            acceleratorArn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            dnsName: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            ipAddressType: GlobalAcceleratorClientTypes.IpAddressType? = nil,
            ipSets: [GlobalAcceleratorClientTypes.IpSet]? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            status: GlobalAcceleratorClientTypes.CustomRoutingAcceleratorStatus? = nil
        )
        {
            self.acceleratorArn = acceleratorArn
            self.createdTime = createdTime
            self.dnsName = dnsName
            self.enabled = enabled
            self.ipAddressType = ipAddressType
            self.ipSets = ipSets
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.status = status
        }
    }
}

public struct CreateCustomRoutingAcceleratorOutput: Swift.Sendable {
    /// The accelerator that is created.
    public var accelerator: GlobalAcceleratorClientTypes.CustomRoutingAccelerator?

    public init(
        accelerator: GlobalAcceleratorClientTypes.CustomRoutingAccelerator? = nil
    )
    {
        self.accelerator = accelerator
    }
}

/// The endpoint group that you specified already exists.
public struct EndpointGroupAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EndpointGroupAlreadyExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The port numbers that you specified are not valid numbers or are not unique for this accelerator.
public struct InvalidPortRangeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPortRangeException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The listener that you specified doesn't exist.
public struct ListenerNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ListenerNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension GlobalAcceleratorClientTypes {

    public enum CustomRoutingProtocol: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case tcp
        case udp
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomRoutingProtocol] {
            return [
                .tcp,
                .udp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .tcp: return "TCP"
            case .udp: return "UDP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlobalAcceleratorClientTypes {

    /// For a custom routing accelerator, sets the port range and protocol for all endpoints (virtual private cloud subnets) in an endpoint group to accept client traffic on.
    public struct CustomRoutingDestinationConfiguration: Swift.Sendable {
        /// The first port, inclusive, in the range of ports for the endpoint group that is associated with a custom routing accelerator.
        /// This member is required.
        public var fromPort: Swift.Int?
        /// The protocol for the endpoint group that is associated with a custom routing accelerator. The protocol can be either TCP or UDP.
        /// This member is required.
        public var protocols: [GlobalAcceleratorClientTypes.CustomRoutingProtocol]?
        /// The last port, inclusive, in the range of ports for the endpoint group that is associated with a custom routing accelerator.
        /// This member is required.
        public var toPort: Swift.Int?

        public init(
            fromPort: Swift.Int? = nil,
            protocols: [GlobalAcceleratorClientTypes.CustomRoutingProtocol]? = nil,
            toPort: Swift.Int? = nil
        )
        {
            self.fromPort = fromPort
            self.protocols = protocols
            self.toPort = toPort
        }
    }
}

public struct CreateCustomRoutingEndpointGroupInput: Swift.Sendable {
    /// Sets the port range and protocol for all endpoints (virtual private cloud subnets) in a custom routing endpoint group to accept client traffic on.
    /// This member is required.
    public var destinationConfigurations: [GlobalAcceleratorClientTypes.CustomRoutingDestinationConfiguration]?
    /// The Amazon Web Services Region where the endpoint group is located. A listener can have only one endpoint group in a specific Region.
    /// This member is required.
    public var endpointGroupRegion: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency—that is, the uniqueness—of the request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the listener for a custom routing endpoint.
    /// This member is required.
    public var listenerArn: Swift.String?

    public init(
        destinationConfigurations: [GlobalAcceleratorClientTypes.CustomRoutingDestinationConfiguration]? = nil,
        endpointGroupRegion: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        listenerArn: Swift.String? = nil
    )
    {
        self.destinationConfigurations = destinationConfigurations
        self.endpointGroupRegion = endpointGroupRegion
        self.idempotencyToken = idempotencyToken
        self.listenerArn = listenerArn
    }
}

extension GlobalAcceleratorClientTypes {

    public enum ModelProtocol: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case tcp
        case udp
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelProtocol] {
            return [
                .tcp,
                .udp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .tcp: return "TCP"
            case .udp: return "UDP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlobalAcceleratorClientTypes {

    /// For a custom routing accelerator, describes the port range and protocol for all endpoints (virtual private cloud subnets) in an endpoint group to accept client traffic on.
    public struct CustomRoutingDestinationDescription: Swift.Sendable {
        /// The first port, inclusive, in the range of ports for the endpoint group that is associated with a custom routing accelerator.
        public var fromPort: Swift.Int?
        /// The protocol for the endpoint group that is associated with a custom routing accelerator. The protocol can be either TCP or UDP.
        public var protocols: [GlobalAcceleratorClientTypes.ModelProtocol]?
        /// The last port, inclusive, in the range of ports for the endpoint group that is associated with a custom routing accelerator.
        public var toPort: Swift.Int?

        public init(
            fromPort: Swift.Int? = nil,
            protocols: [GlobalAcceleratorClientTypes.ModelProtocol]? = nil,
            toPort: Swift.Int? = nil
        )
        {
            self.fromPort = fromPort
            self.protocols = protocols
            self.toPort = toPort
        }
    }
}

extension GlobalAcceleratorClientTypes {

    /// A complex type for the endpoint group for a custom routing accelerator. An Amazon Web Services Region can have only one endpoint group for a specific listener.
    public struct CustomRoutingEndpointGroup: Swift.Sendable {
        /// For a custom routing accelerator, describes the port range and protocol for all endpoints (virtual private cloud subnets) in an endpoint group to accept client traffic on.
        public var destinationDescriptions: [GlobalAcceleratorClientTypes.CustomRoutingDestinationDescription]?
        /// For a custom routing accelerator, describes the endpoints (virtual private cloud subnets) in an endpoint group to accept client traffic on.
        public var endpointDescriptions: [GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription]?
        /// The Amazon Resource Name (ARN) of the endpoint group.
        public var endpointGroupArn: Swift.String?
        /// The Amazon Web Services Region where the endpoint group is located.
        public var endpointGroupRegion: Swift.String?

        public init(
            destinationDescriptions: [GlobalAcceleratorClientTypes.CustomRoutingDestinationDescription]? = nil,
            endpointDescriptions: [GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription]? = nil,
            endpointGroupArn: Swift.String? = nil,
            endpointGroupRegion: Swift.String? = nil
        )
        {
            self.destinationDescriptions = destinationDescriptions
            self.endpointDescriptions = endpointDescriptions
            self.endpointGroupArn = endpointGroupArn
            self.endpointGroupRegion = endpointGroupRegion
        }
    }
}

public struct CreateCustomRoutingEndpointGroupOutput: Swift.Sendable {
    /// The information about the endpoint group created for a custom routing accelerator.
    public var endpointGroup: GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup?

    public init(
        endpointGroup: GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup? = nil
    )
    {
        self.endpointGroup = endpointGroup
    }
}

extension GlobalAcceleratorClientTypes {

    /// A complex type for a range of ports for a listener.
    public struct PortRange: Swift.Sendable {
        /// The first port in the range of ports, inclusive.
        public var fromPort: Swift.Int?
        /// The last port in the range of ports, inclusive.
        public var toPort: Swift.Int?

        public init(
            fromPort: Swift.Int? = nil,
            toPort: Swift.Int? = nil
        )
        {
            self.fromPort = fromPort
            self.toPort = toPort
        }
    }
}

public struct CreateCustomRoutingListenerInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the accelerator for a custom routing listener.
    /// This member is required.
    public var acceleratorArn: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency—that is, the uniqueness—of the request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The port range to support for connections from clients to your accelerator. Separately, you set port ranges for endpoints. For more information, see [About endpoints for custom routing accelerators](https://docs.aws.amazon.com/global-accelerator/latest/dg/about-custom-routing-endpoints.html).
    /// This member is required.
    public var portRanges: [GlobalAcceleratorClientTypes.PortRange]?

    public init(
        acceleratorArn: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        portRanges: [GlobalAcceleratorClientTypes.PortRange]? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.idempotencyToken = idempotencyToken
        self.portRanges = portRanges
    }
}

extension GlobalAcceleratorClientTypes {

    /// A complex type for a listener for a custom routing accelerator.
    public struct CustomRoutingListener: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the listener.
        public var listenerArn: Swift.String?
        /// The port range to support for connections from clients to your accelerator. Separately, you set port ranges for endpoints. For more information, see [About endpoints for custom routing accelerators](https://docs.aws.amazon.com/global-accelerator/latest/dg/about-custom-routing-endpoints.html).
        public var portRanges: [GlobalAcceleratorClientTypes.PortRange]?

        public init(
            listenerArn: Swift.String? = nil,
            portRanges: [GlobalAcceleratorClientTypes.PortRange]? = nil
        )
        {
            self.listenerArn = listenerArn
            self.portRanges = portRanges
        }
    }
}

public struct CreateCustomRoutingListenerOutput: Swift.Sendable {
    /// The listener that you've created for a custom routing accelerator.
    public var listener: GlobalAcceleratorClientTypes.CustomRoutingListener?

    public init(
        listener: GlobalAcceleratorClientTypes.CustomRoutingListener? = nil
    )
    {
        self.listener = listener
    }
}

extension GlobalAcceleratorClientTypes {

    public enum HealthCheckProtocol: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case http
        case https
        case tcp
        case sdkUnknown(Swift.String)

        public static var allCases: [HealthCheckProtocol] {
            return [
                .http,
                .https,
                .tcp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .http: return "HTTP"
            case .https: return "HTTPS"
            case .tcp: return "TCP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GlobalAcceleratorClientTypes {

    /// Override specific listener ports used to route traffic to endpoints that are part of an endpoint group. For example, you can create a port override in which the listener receives user traffic on ports 80 and 443, but your accelerator routes that traffic to ports 1080 and 1443, respectively, on the endpoints. For more information, see [ Overriding listener ports](https://docs.aws.amazon.com/global-accelerator/latest/dg/about-endpoint-groups-port-override.html) in the Global Accelerator Developer Guide.
    public struct PortOverride: Swift.Sendable {
        /// The endpoint port that you want a listener port to be mapped to. This is the port on the endpoint, such as the Application Load Balancer or Amazon EC2 instance.
        public var endpointPort: Swift.Int?
        /// The listener port that you want to map to a specific endpoint port. This is the port that user traffic arrives to the Global Accelerator on.
        public var listenerPort: Swift.Int?

        public init(
            endpointPort: Swift.Int? = nil,
            listenerPort: Swift.Int? = nil
        )
        {
            self.endpointPort = endpointPort
            self.listenerPort = listenerPort
        }
    }
}

public struct CreateEndpointGroupInput: Swift.Sendable {
    /// The list of endpoint objects.
    public var endpointConfigurations: [GlobalAcceleratorClientTypes.EndpointConfiguration]?
    /// The Amazon Web Services Region where the endpoint group is located. A listener can have only one endpoint group in a specific Region.
    /// This member is required.
    public var endpointGroupRegion: Swift.String?
    /// The time—10 seconds or 30 seconds—between each health check for an endpoint. The default value is 30.
    public var healthCheckIntervalSeconds: Swift.Int?
    /// If the protocol is HTTP/S, then this specifies the path that is the destination for health check targets. The default value is slash (/).
    public var healthCheckPath: Swift.String?
    /// The port that Global Accelerator uses to check the health of endpoints that are part of this endpoint group. The default port is the listener port that this endpoint group is associated with. If listener port is a list of ports, Global Accelerator uses the first port in the list.
    public var healthCheckPort: Swift.Int?
    /// The protocol that Global Accelerator uses to check the health of endpoints that are part of this endpoint group. The default value is TCP.
    public var healthCheckProtocol: GlobalAcceleratorClientTypes.HealthCheckProtocol?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency—that is, the uniqueness—of the request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerArn: Swift.String?
    /// Override specific listener ports used to route traffic to endpoints that are part of this endpoint group. For example, you can create a port override in which the listener receives user traffic on ports 80 and 443, but your accelerator routes that traffic to ports 1080 and 1443, respectively, on the endpoints. For more information, see [ Overriding listener ports](https://docs.aws.amazon.com/global-accelerator/latest/dg/about-endpoint-groups-port-override.html) in the Global Accelerator Developer Guide.
    public var portOverrides: [GlobalAcceleratorClientTypes.PortOverride]?
    /// The number of consecutive health checks required to set the state of a healthy endpoint to unhealthy, or to set an unhealthy endpoint to healthy. The default value is 3.
    public var thresholdCount: Swift.Int?
    /// The percentage of traffic to send to an Amazon Web Services Region. Additional traffic is distributed to other endpoint groups for this listener. Use this action to increase (dial up) or decrease (dial down) traffic to a specific Region. The percentage is applied to the traffic that would otherwise have been routed to the Region based on optimal routing. The default value is 100.
    public var trafficDialPercentage: Swift.Float?

    public init(
        endpointConfigurations: [GlobalAcceleratorClientTypes.EndpointConfiguration]? = nil,
        endpointGroupRegion: Swift.String? = nil,
        healthCheckIntervalSeconds: Swift.Int? = nil,
        healthCheckPath: Swift.String? = nil,
        healthCheckPort: Swift.Int? = nil,
        healthCheckProtocol: GlobalAcceleratorClientTypes.HealthCheckProtocol? = nil,
        idempotencyToken: Swift.String? = nil,
        listenerArn: Swift.String? = nil,
        portOverrides: [GlobalAcceleratorClientTypes.PortOverride]? = nil,
        thresholdCount: Swift.Int? = nil,
        trafficDialPercentage: Swift.Float? = nil
    )
    {
        self.endpointConfigurations = endpointConfigurations
        self.endpointGroupRegion = endpointGroupRegion
        self.healthCheckIntervalSeconds = healthCheckIntervalSeconds
        self.healthCheckPath = healthCheckPath
        self.healthCheckPort = healthCheckPort
        self.healthCheckProtocol = healthCheckProtocol
        self.idempotencyToken = idempotencyToken
        self.listenerArn = listenerArn
        self.portOverrides = portOverrides
        self.thresholdCount = thresholdCount
        self.trafficDialPercentage = trafficDialPercentage
    }
}

extension GlobalAcceleratorClientTypes {

    /// A complex type for the endpoint group. An Amazon Web Services Region can have only one endpoint group for a specific listener.
    public struct EndpointGroup: Swift.Sendable {
        /// The list of endpoint objects.
        public var endpointDescriptions: [GlobalAcceleratorClientTypes.EndpointDescription]?
        /// The Amazon Resource Name (ARN) of the endpoint group.
        public var endpointGroupArn: Swift.String?
        /// The Amazon Web Services Region where the endpoint group is located.
        public var endpointGroupRegion: Swift.String?
        /// The time—10 seconds or 30 seconds—between health checks for each endpoint. The default value is 30.
        public var healthCheckIntervalSeconds: Swift.Int?
        /// If the protocol is HTTP/S, then this value provides the ping path that Global Accelerator uses for the destination on the endpoints for health checks. The default is slash (/).
        public var healthCheckPath: Swift.String?
        /// The port that Global Accelerator uses to perform health checks on endpoints that are part of this endpoint group. The default port is the port for the listener that this endpoint group is associated with. If the listener port is a list, Global Accelerator uses the first specified port in the list of ports.
        public var healthCheckPort: Swift.Int?
        /// The protocol that Global Accelerator uses to perform health checks on endpoints that are part of this endpoint group. The default value is TCP.
        public var healthCheckProtocol: GlobalAcceleratorClientTypes.HealthCheckProtocol?
        /// Allows you to override the destination ports used to route traffic to an endpoint. Using a port override lets you map a list of external destination ports (that your users send traffic to) to a list of internal destination ports that you want an application endpoint to receive traffic on.
        public var portOverrides: [GlobalAcceleratorClientTypes.PortOverride]?
        /// The number of consecutive health checks required to set the state of a healthy endpoint to unhealthy, or to set an unhealthy endpoint to healthy. The default value is 3.
        public var thresholdCount: Swift.Int?
        /// The percentage of traffic to send to an Amazon Web Services Region. Additional traffic is distributed to other endpoint groups for this listener. Use this action to increase (dial up) or decrease (dial down) traffic to a specific Region. The percentage is applied to the traffic that would otherwise have been routed to the Region based on optimal routing. The default value is 100.
        public var trafficDialPercentage: Swift.Float?

        public init(
            endpointDescriptions: [GlobalAcceleratorClientTypes.EndpointDescription]? = nil,
            endpointGroupArn: Swift.String? = nil,
            endpointGroupRegion: Swift.String? = nil,
            healthCheckIntervalSeconds: Swift.Int? = nil,
            healthCheckPath: Swift.String? = nil,
            healthCheckPort: Swift.Int? = nil,
            healthCheckProtocol: GlobalAcceleratorClientTypes.HealthCheckProtocol? = nil,
            portOverrides: [GlobalAcceleratorClientTypes.PortOverride]? = nil,
            thresholdCount: Swift.Int? = nil,
            trafficDialPercentage: Swift.Float? = nil
        )
        {
            self.endpointDescriptions = endpointDescriptions
            self.endpointGroupArn = endpointGroupArn
            self.endpointGroupRegion = endpointGroupRegion
            self.healthCheckIntervalSeconds = healthCheckIntervalSeconds
            self.healthCheckPath = healthCheckPath
            self.healthCheckPort = healthCheckPort
            self.healthCheckProtocol = healthCheckProtocol
            self.portOverrides = portOverrides
            self.thresholdCount = thresholdCount
            self.trafficDialPercentage = trafficDialPercentage
        }
    }
}

public struct CreateEndpointGroupOutput: Swift.Sendable {
    /// The information about the endpoint group that was created.
    public var endpointGroup: GlobalAcceleratorClientTypes.EndpointGroup?

    public init(
        endpointGroup: GlobalAcceleratorClientTypes.EndpointGroup? = nil
    )
    {
        self.endpointGroup = endpointGroup
    }
}

public struct CreateListenerInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of your accelerator.
    /// This member is required.
    public var acceleratorArn: Swift.String?
    /// Client affinity lets you direct all requests from a user to the same endpoint, if you have stateful applications, regardless of the port and protocol of the client request. Client affinity gives you control over whether to always route each client to the same specific endpoint. Global Accelerator uses a consistent-flow hashing algorithm to choose the optimal endpoint for a connection. If client affinity is NONE, Global Accelerator uses the "five-tuple" (5-tuple) properties—source IP address, source port, destination IP address, destination port, and protocol—to select the hash value, and then chooses the best endpoint. However, with this setting, if someone uses different ports to connect to Global Accelerator, their connections might not be always routed to the same endpoint because the hash value changes. If you want a given client to always be routed to the same endpoint, set client affinity to SOURCE_IP instead. When you use the SOURCE_IP setting, Global Accelerator uses the "two-tuple" (2-tuple) properties— source (client) IP address and destination IP address—to select the hash value. The default value is NONE.
    public var clientAffinity: GlobalAcceleratorClientTypes.ClientAffinity?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency—that is, the uniqueness—of the request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The list of port ranges to support for connections from clients to your accelerator.
    /// This member is required.
    public var portRanges: [GlobalAcceleratorClientTypes.PortRange]?
    /// The protocol for connections from clients to your accelerator.
    /// This member is required.
    public var `protocol`: GlobalAcceleratorClientTypes.ModelProtocol?

    public init(
        acceleratorArn: Swift.String? = nil,
        clientAffinity: GlobalAcceleratorClientTypes.ClientAffinity? = nil,
        idempotencyToken: Swift.String? = nil,
        portRanges: [GlobalAcceleratorClientTypes.PortRange]? = nil,
        `protocol`: GlobalAcceleratorClientTypes.ModelProtocol? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.clientAffinity = clientAffinity
        self.idempotencyToken = idempotencyToken
        self.portRanges = portRanges
        self.`protocol` = `protocol`
    }
}

extension GlobalAcceleratorClientTypes {

    /// A complex type for a listener.
    public struct Listener: Swift.Sendable {
        /// Client affinity lets you direct all requests from a user to the same endpoint, if you have stateful applications, regardless of the port and protocol of the client request. Client affinity gives you control over whether to always route each client to the same specific endpoint. Global Accelerator uses a consistent-flow hashing algorithm to choose the optimal endpoint for a connection. If client affinity is NONE, Global Accelerator uses the "five-tuple" (5-tuple) properties—source IP address, source port, destination IP address, destination port, and protocol—to select the hash value, and then chooses the best endpoint. However, with this setting, if someone uses different ports to connect to Global Accelerator, their connections might not be always routed to the same endpoint because the hash value changes. If you want a given client to always be routed to the same endpoint, set client affinity to SOURCE_IP instead. When you use the SOURCE_IP setting, Global Accelerator uses the "two-tuple" (2-tuple) properties— source (client) IP address and destination IP address—to select the hash value. The default value is NONE.
        public var clientAffinity: GlobalAcceleratorClientTypes.ClientAffinity?
        /// The Amazon Resource Name (ARN) of the listener.
        public var listenerArn: Swift.String?
        /// The list of port ranges for the connections from clients to the accelerator.
        public var portRanges: [GlobalAcceleratorClientTypes.PortRange]?
        /// The protocol for the connections from clients to the accelerator.
        public var `protocol`: GlobalAcceleratorClientTypes.ModelProtocol?

        public init(
            clientAffinity: GlobalAcceleratorClientTypes.ClientAffinity? = nil,
            listenerArn: Swift.String? = nil,
            portRanges: [GlobalAcceleratorClientTypes.PortRange]? = nil,
            `protocol`: GlobalAcceleratorClientTypes.ModelProtocol? = nil
        )
        {
            self.clientAffinity = clientAffinity
            self.listenerArn = listenerArn
            self.portRanges = portRanges
            self.`protocol` = `protocol`
        }
    }
}

public struct CreateListenerOutput: Swift.Sendable {
    /// The listener that you've created.
    public var listener: GlobalAcceleratorClientTypes.Listener?

    public init(
        listener: GlobalAcceleratorClientTypes.Listener? = nil
    )
    {
        self.listener = listener
    }
}

extension GlobalAcceleratorClientTypes {

    /// An endpoint (Amazon Web Services resource) or an IP address range, in CIDR format, that is listed in a cross-account attachment. A cross-account resource can be added to an accelerator by specified principals, which are also listed in the attachment. For more information, see [ Working with cross-account attachments and resources in Global Accelerator](https://docs.aws.amazon.com/global-accelerator/latest/dg/cross-account-resources.html) in the Global Accelerator Developer Guide.
    public struct CrossAccountResource: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the cross-account attachment that specifies the resources (endpoints or CIDR range) that can be added to accelerators and principals that have permission to add them.
        public var attachmentArn: Swift.String?
        /// An IP address range, in CIDR format, that is specified as an Amazon Web Services resource. The address must be provisioned and advertised in Global Accelerator by following the bring your own IP address (BYOIP) process for Global Accelerator. For more information, see [Bring your own IP addresses (BYOIP)](https://docs.aws.amazon.com/global-accelerator/latest/dg/using-byoip.html) in the Global Accelerator Developer Guide.
        public var cidr: Swift.String?
        /// The endpoint ID for the endpoint that is listed in a cross-account attachment and can be added to an accelerator by specified principals.
        public var endpointId: Swift.String?

        public init(
            attachmentArn: Swift.String? = nil,
            cidr: Swift.String? = nil,
            endpointId: Swift.String? = nil
        )
        {
            self.attachmentArn = attachmentArn
            self.cidr = cidr
            self.endpointId = endpointId
        }
    }
}

extension GlobalAcceleratorClientTypes {

    /// Attributes of a custom routing accelerator.
    public struct CustomRoutingAcceleratorAttributes: Swift.Sendable {
        /// Indicates whether flow logs are enabled. The default value is false. If the value is true, FlowLogsS3Bucket and FlowLogsS3Prefix must be specified. For more information, see [Flow logs](https://docs.aws.amazon.com/global-accelerator/latest/dg/monitoring-global-accelerator.flow-logs.html) in the Global Accelerator Developer Guide.
        public var flowLogsEnabled: Swift.Bool?
        /// The name of the Amazon S3 bucket for the flow logs. Attribute is required if FlowLogsEnabled is true. The bucket must exist and have a bucket policy that grants Global Accelerator permission to write to the bucket.
        public var flowLogsS3Bucket: Swift.String?
        /// The prefix for the location in the Amazon S3 bucket for the flow logs. Attribute is required if FlowLogsEnabled is true. If you don’t specify a prefix, the flow logs are stored in the root of the bucket. If you specify slash (/) for the S3 bucket prefix, the log file bucket folder structure will include a double slash (//), like the following: DOC-EXAMPLE-BUCKET//AWSLogs/aws_account_id
        public var flowLogsS3Prefix: Swift.String?

        public init(
            flowLogsEnabled: Swift.Bool? = nil,
            flowLogsS3Bucket: Swift.String? = nil,
            flowLogsS3Prefix: Swift.String? = nil
        )
        {
            self.flowLogsEnabled = flowLogsEnabled
            self.flowLogsS3Bucket = flowLogsS3Bucket
            self.flowLogsS3Prefix = flowLogsS3Prefix
        }
    }
}

extension GlobalAcceleratorClientTypes {

    public enum CustomRoutingDestinationTrafficState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomRoutingDestinationTrafficState] {
            return [
                .allow,
                .deny
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allow: return "ALLOW"
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DeleteAcceleratorInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of an accelerator.
    /// This member is required.
    public var acceleratorArn: Swift.String?

    public init(
        acceleratorArn: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
    }
}

public struct DeleteCrossAccountAttachmentInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the cross-account attachment to delete.
    /// This member is required.
    public var attachmentArn: Swift.String?

    public init(
        attachmentArn: Swift.String? = nil
    )
    {
        self.attachmentArn = attachmentArn
    }
}

public struct DeleteCustomRoutingAcceleratorInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the custom routing accelerator to delete.
    /// This member is required.
    public var acceleratorArn: Swift.String?

    public init(
        acceleratorArn: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
    }
}

public struct DeleteCustomRoutingEndpointGroupInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the endpoint group to delete.
    /// This member is required.
    public var endpointGroupArn: Swift.String?

    public init(
        endpointGroupArn: Swift.String? = nil
    )
    {
        self.endpointGroupArn = endpointGroupArn
    }
}

public struct DeleteCustomRoutingListenerInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the listener to delete.
    /// This member is required.
    public var listenerArn: Swift.String?

    public init(
        listenerArn: Swift.String? = nil
    )
    {
        self.listenerArn = listenerArn
    }
}

public struct DeleteEndpointGroupInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the endpoint group to delete.
    /// This member is required.
    public var endpointGroupArn: Swift.String?

    public init(
        endpointGroupArn: Swift.String? = nil
    )
    {
        self.endpointGroupArn = endpointGroupArn
    }
}

public struct DeleteListenerInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerArn: Swift.String?

    public init(
        listenerArn: Swift.String? = nil
    )
    {
        self.listenerArn = listenerArn
    }
}

public struct DenyCustomRoutingTrafficInput: Swift.Sendable {
    /// Indicates whether all destination IP addresses and ports for a specified VPC subnet endpoint cannot receive traffic from a custom routing accelerator. The value is TRUE or FALSE. When set to TRUE, no destinations in the custom routing VPC subnet can receive traffic. Note that you cannot specify destination IP addresses and ports when the value is set to TRUE. When set to FALSE (or not specified), you must specify a list of destination IP addresses that cannot receive traffic. A list of ports is optional. If you don't specify a list of ports, the ports that can accept traffic is the same as the ports configured for the endpoint group. The default value is FALSE.
    public var denyAllTrafficToEndpoint: Swift.Bool?
    /// A list of specific Amazon EC2 instance IP addresses (destination addresses) in a subnet that you want to prevent from receiving traffic. The IP addresses must be a subset of the IP addresses allowed for the VPC subnet associated with the endpoint group.
    public var destinationAddresses: [Swift.String]?
    /// A list of specific Amazon EC2 instance ports (destination ports) in a subnet endpoint that you want to prevent from receiving traffic.
    public var destinationPorts: [Swift.Int]?
    /// The Amazon Resource Name (ARN) of the endpoint group.
    /// This member is required.
    public var endpointGroupArn: Swift.String?
    /// An ID for the endpoint. For custom routing accelerators, this is the virtual private cloud (VPC) subnet ID.
    /// This member is required.
    public var endpointId: Swift.String?

    public init(
        denyAllTrafficToEndpoint: Swift.Bool? = nil,
        destinationAddresses: [Swift.String]? = nil,
        destinationPorts: [Swift.Int]? = nil,
        endpointGroupArn: Swift.String? = nil,
        endpointId: Swift.String? = nil
    )
    {
        self.denyAllTrafficToEndpoint = denyAllTrafficToEndpoint
        self.destinationAddresses = destinationAddresses
        self.destinationPorts = destinationPorts
        self.endpointGroupArn = endpointGroupArn
        self.endpointId = endpointId
    }
}

public struct DeprovisionByoipCidrInput: Swift.Sendable {
    /// The address range, in CIDR notation. The prefix must be the same prefix that you specified when you provisioned the address range. For more information, see [Bring your own IP addresses (BYOIP)](https://docs.aws.amazon.com/global-accelerator/latest/dg/using-byoip.html) in the Global Accelerator Developer Guide.
    /// This member is required.
    public var cidr: Swift.String?

    public init(
        cidr: Swift.String? = nil
    )
    {
        self.cidr = cidr
    }
}

public struct DeprovisionByoipCidrOutput: Swift.Sendable {
    /// Information about the address range.
    public var byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr?

    public init(
        byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr? = nil
    )
    {
        self.byoipCidr = byoipCidr
    }
}

public struct DescribeAcceleratorInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the accelerator to describe.
    /// This member is required.
    public var acceleratorArn: Swift.String?

    public init(
        acceleratorArn: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
    }
}

public struct DescribeAcceleratorOutput: Swift.Sendable {
    /// The description of the accelerator.
    public var accelerator: GlobalAcceleratorClientTypes.Accelerator?

    public init(
        accelerator: GlobalAcceleratorClientTypes.Accelerator? = nil
    )
    {
        self.accelerator = accelerator
    }
}

public struct DescribeAcceleratorAttributesInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the accelerator with the attributes that you want to describe.
    /// This member is required.
    public var acceleratorArn: Swift.String?

    public init(
        acceleratorArn: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
    }
}

public struct DescribeAcceleratorAttributesOutput: Swift.Sendable {
    /// The attributes of the accelerator.
    public var acceleratorAttributes: GlobalAcceleratorClientTypes.AcceleratorAttributes?

    public init(
        acceleratorAttributes: GlobalAcceleratorClientTypes.AcceleratorAttributes? = nil
    )
    {
        self.acceleratorAttributes = acceleratorAttributes
    }
}

public struct DescribeCrossAccountAttachmentInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the cross-account attachment to describe.
    /// This member is required.
    public var attachmentArn: Swift.String?

    public init(
        attachmentArn: Swift.String? = nil
    )
    {
        self.attachmentArn = attachmentArn
    }
}

public struct DescribeCrossAccountAttachmentOutput: Swift.Sendable {
    /// Information about the cross-account attachment.
    public var crossAccountAttachment: GlobalAcceleratorClientTypes.Attachment?

    public init(
        crossAccountAttachment: GlobalAcceleratorClientTypes.Attachment? = nil
    )
    {
        self.crossAccountAttachment = crossAccountAttachment
    }
}

public struct DescribeCustomRoutingAcceleratorInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the accelerator to describe.
    /// This member is required.
    public var acceleratorArn: Swift.String?

    public init(
        acceleratorArn: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
    }
}

public struct DescribeCustomRoutingAcceleratorOutput: Swift.Sendable {
    /// The description of the custom routing accelerator.
    public var accelerator: GlobalAcceleratorClientTypes.CustomRoutingAccelerator?

    public init(
        accelerator: GlobalAcceleratorClientTypes.CustomRoutingAccelerator? = nil
    )
    {
        self.accelerator = accelerator
    }
}

public struct DescribeCustomRoutingAcceleratorAttributesInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the custom routing accelerator to describe the attributes for.
    /// This member is required.
    public var acceleratorArn: Swift.String?

    public init(
        acceleratorArn: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
    }
}

public struct DescribeCustomRoutingAcceleratorAttributesOutput: Swift.Sendable {
    /// The attributes of the custom routing accelerator.
    public var acceleratorAttributes: GlobalAcceleratorClientTypes.CustomRoutingAcceleratorAttributes?

    public init(
        acceleratorAttributes: GlobalAcceleratorClientTypes.CustomRoutingAcceleratorAttributes? = nil
    )
    {
        self.acceleratorAttributes = acceleratorAttributes
    }
}

public struct DescribeCustomRoutingEndpointGroupInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the endpoint group to describe.
    /// This member is required.
    public var endpointGroupArn: Swift.String?

    public init(
        endpointGroupArn: Swift.String? = nil
    )
    {
        self.endpointGroupArn = endpointGroupArn
    }
}

public struct DescribeCustomRoutingEndpointGroupOutput: Swift.Sendable {
    /// The description of an endpoint group for a custom routing accelerator.
    public var endpointGroup: GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup?

    public init(
        endpointGroup: GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup? = nil
    )
    {
        self.endpointGroup = endpointGroup
    }
}

public struct DescribeCustomRoutingListenerInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the listener to describe.
    /// This member is required.
    public var listenerArn: Swift.String?

    public init(
        listenerArn: Swift.String? = nil
    )
    {
        self.listenerArn = listenerArn
    }
}

public struct DescribeCustomRoutingListenerOutput: Swift.Sendable {
    /// The description of a listener for a custom routing accelerator.
    public var listener: GlobalAcceleratorClientTypes.CustomRoutingListener?

    public init(
        listener: GlobalAcceleratorClientTypes.CustomRoutingListener? = nil
    )
    {
        self.listener = listener
    }
}

public struct DescribeEndpointGroupInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the endpoint group to describe.
    /// This member is required.
    public var endpointGroupArn: Swift.String?

    public init(
        endpointGroupArn: Swift.String? = nil
    )
    {
        self.endpointGroupArn = endpointGroupArn
    }
}

public struct DescribeEndpointGroupOutput: Swift.Sendable {
    /// The description of an endpoint group.
    public var endpointGroup: GlobalAcceleratorClientTypes.EndpointGroup?

    public init(
        endpointGroup: GlobalAcceleratorClientTypes.EndpointGroup? = nil
    )
    {
        self.endpointGroup = endpointGroup
    }
}

public struct DescribeListenerInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the listener to describe.
    /// This member is required.
    public var listenerArn: Swift.String?

    public init(
        listenerArn: Swift.String? = nil
    )
    {
        self.listenerArn = listenerArn
    }
}

public struct DescribeListenerOutput: Swift.Sendable {
    /// The description of a listener.
    public var listener: GlobalAcceleratorClientTypes.Listener?

    public init(
        listener: GlobalAcceleratorClientTypes.Listener? = nil
    )
    {
        self.listener = listener
    }
}

extension GlobalAcceleratorClientTypes {

    /// An IP address/port combination.
    public struct SocketAddress: Swift.Sendable {
        /// The IP address for the socket address.
        public var ipAddress: Swift.String?
        /// The port for the socket address.
        public var port: Swift.Int?

        public init(
            ipAddress: Swift.String? = nil,
            port: Swift.Int? = nil
        )
        {
            self.ipAddress = ipAddress
            self.port = port
        }
    }
}

extension GlobalAcceleratorClientTypes {

    /// The port mappings for a specified endpoint IP address (destination).
    public struct DestinationPortMapping: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the custom routing accelerator that you have port mappings for.
        public var acceleratorArn: Swift.String?
        /// The IP address/port combinations (sockets) that map to a given destination socket address.
        public var acceleratorSocketAddresses: [GlobalAcceleratorClientTypes.SocketAddress]?
        /// The endpoint IP address/port combination for traffic received on the accelerator socket address.
        public var destinationSocketAddress: GlobalAcceleratorClientTypes.SocketAddress?
        /// Indicates whether or not a port mapping destination can receive traffic. The value is either ALLOW, if traffic is allowed to the destination, or DENY, if traffic is not allowed to the destination.
        public var destinationTrafficState: GlobalAcceleratorClientTypes.CustomRoutingDestinationTrafficState?
        /// The Amazon Resource Name (ARN) of the endpoint group.
        public var endpointGroupArn: Swift.String?
        /// The Amazon Web Services Region for the endpoint group.
        public var endpointGroupRegion: Swift.String?
        /// The ID for the virtual private cloud (VPC) subnet.
        public var endpointId: Swift.String?
        /// The IP address type that an accelerator supports. For a custom routing accelerator, the value must be IPV4.
        public var ipAddressType: GlobalAcceleratorClientTypes.IpAddressType?

        public init(
            acceleratorArn: Swift.String? = nil,
            acceleratorSocketAddresses: [GlobalAcceleratorClientTypes.SocketAddress]? = nil,
            destinationSocketAddress: GlobalAcceleratorClientTypes.SocketAddress? = nil,
            destinationTrafficState: GlobalAcceleratorClientTypes.CustomRoutingDestinationTrafficState? = nil,
            endpointGroupArn: Swift.String? = nil,
            endpointGroupRegion: Swift.String? = nil,
            endpointId: Swift.String? = nil,
            ipAddressType: GlobalAcceleratorClientTypes.IpAddressType? = nil
        )
        {
            self.acceleratorArn = acceleratorArn
            self.acceleratorSocketAddresses = acceleratorSocketAddresses
            self.destinationSocketAddress = destinationSocketAddress
            self.destinationTrafficState = destinationTrafficState
            self.endpointGroupArn = endpointGroupArn
            self.endpointGroupRegion = endpointGroupRegion
            self.endpointId = endpointId
            self.ipAddressType = ipAddressType
        }
    }
}

extension GlobalAcceleratorClientTypes {

    /// A complex type for an endpoint. Specifies information about the endpoint to remove from the endpoint group.
    public struct EndpointIdentifier: Swift.Sendable {
        /// Indicates whether client IP address preservation is enabled for an endpoint. The value is true or false. If the value is set to true, the client's IP address is preserved in the X-Forwarded-For request header as traffic travels to applications on the endpoint fronted by the accelerator.
        public var clientIPPreservationEnabled: Swift.Bool?
        /// An ID for the endpoint. If the endpoint is a Network Load Balancer or Application Load Balancer, this is the Amazon Resource Name (ARN) of the resource. If the endpoint is an Elastic IP address, this is the Elastic IP address allocation ID. For Amazon EC2 instances, this is the EC2 instance ID. An Application Load Balancer can be either internal or internet-facing.
        /// This member is required.
        public var endpointId: Swift.String?

        public init(
            clientIPPreservationEnabled: Swift.Bool? = nil,
            endpointId: Swift.String? = nil
        )
        {
            self.clientIPPreservationEnabled = clientIPPreservationEnabled
            self.endpointId = endpointId
        }
    }
}

/// The endpoint that you specified doesn't exist.
public struct EndpointNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EndpointNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// There isn't another item to return.
public struct InvalidNextTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNextTokenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct ListAcceleratorsInput: Swift.Sendable {
    /// The number of Global Accelerator objects that you want to return with this call. The default value is 10.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAcceleratorsOutput: Swift.Sendable {
    /// The list of accelerators for a customer account.
    public var accelerators: [GlobalAcceleratorClientTypes.Accelerator]?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        accelerators: [GlobalAcceleratorClientTypes.Accelerator]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accelerators = accelerators
        self.nextToken = nextToken
    }
}

public struct ListByoipCidrsInput: Swift.Sendable {
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListByoipCidrsOutput: Swift.Sendable {
    /// Information about your address ranges.
    public var byoipCidrs: [GlobalAcceleratorClientTypes.ByoipCidr]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        byoipCidrs: [GlobalAcceleratorClientTypes.ByoipCidr]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.byoipCidrs = byoipCidrs
        self.nextToken = nextToken
    }
}

public struct ListCrossAccountAttachmentsInput: Swift.Sendable {
    /// The number of cross-account attachment objects that you want to return with this call. The default value is 10.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListCrossAccountAttachmentsOutput: Swift.Sendable {
    /// Information about the cross-account attachments.
    public var crossAccountAttachments: [GlobalAcceleratorClientTypes.Attachment]?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        crossAccountAttachments: [GlobalAcceleratorClientTypes.Attachment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.crossAccountAttachments = crossAccountAttachments
        self.nextToken = nextToken
    }
}

public struct ListCrossAccountResourceAccountsInput: Swift.Sendable {

    public init() { }
}

public struct ListCrossAccountResourceAccountsOutput: Swift.Sendable {
    /// The account IDs of principals (resource owners) in a cross-account attachment who can work with resources listed in the same attachment.
    public var resourceOwnerAwsAccountIds: [Swift.String]?

    public init(
        resourceOwnerAwsAccountIds: [Swift.String]? = nil
    )
    {
        self.resourceOwnerAwsAccountIds = resourceOwnerAwsAccountIds
    }
}

public struct ListCrossAccountResourcesInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of an accelerator in a cross-account attachment.
    public var acceleratorArn: Swift.String?
    /// The number of cross-account resource objects that you want to return with this call. The default value is 10.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?
    /// The account ID of a resource owner in a cross-account attachment.
    /// This member is required.
    public var resourceOwnerAwsAccountId: Swift.String?

    public init(
        acceleratorArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceOwnerAwsAccountId: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceOwnerAwsAccountId = resourceOwnerAwsAccountId
    }
}

public struct ListCrossAccountResourcesOutput: Swift.Sendable {
    /// The cross-account resources used with an accelerator.
    public var crossAccountResources: [GlobalAcceleratorClientTypes.CrossAccountResource]?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        crossAccountResources: [GlobalAcceleratorClientTypes.CrossAccountResource]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.crossAccountResources = crossAccountResources
        self.nextToken = nextToken
    }
}

public struct ListCustomRoutingAcceleratorsInput: Swift.Sendable {
    /// The number of custom routing Global Accelerator objects that you want to return with this call. The default value is 10.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListCustomRoutingAcceleratorsOutput: Swift.Sendable {
    /// The list of custom routing accelerators for a customer account.
    public var accelerators: [GlobalAcceleratorClientTypes.CustomRoutingAccelerator]?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        accelerators: [GlobalAcceleratorClientTypes.CustomRoutingAccelerator]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accelerators = accelerators
        self.nextToken = nextToken
    }
}

public struct ListCustomRoutingEndpointGroupsInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the listener to list endpoint groups for.
    /// This member is required.
    public var listenerArn: Swift.String?
    /// The number of endpoint group objects that you want to return with this call. The default value is 10.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        listenerArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.listenerArn = listenerArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListCustomRoutingEndpointGroupsOutput: Swift.Sendable {
    /// The list of the endpoint groups associated with a listener for a custom routing accelerator.
    public var endpointGroups: [GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup]?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        endpointGroups: [GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.endpointGroups = endpointGroups
        self.nextToken = nextToken
    }
}

public struct ListCustomRoutingListenersInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the accelerator to list listeners for.
    /// This member is required.
    public var acceleratorArn: Swift.String?
    /// The number of listener objects that you want to return with this call. The default value is 10.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        acceleratorArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListCustomRoutingListenersOutput: Swift.Sendable {
    /// The list of listeners for a custom routing accelerator.
    public var listeners: [GlobalAcceleratorClientTypes.CustomRoutingListener]?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        listeners: [GlobalAcceleratorClientTypes.CustomRoutingListener]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.listeners = listeners
        self.nextToken = nextToken
    }
}

public struct ListCustomRoutingPortMappingsInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the accelerator to list the custom routing port mappings for.
    /// This member is required.
    public var acceleratorArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the endpoint group to list the custom routing port mappings for.
    public var endpointGroupArn: Swift.String?
    /// The number of destination port mappings that you want to return with this call. The default value is 10.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        acceleratorArn: Swift.String? = nil,
        endpointGroupArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.endpointGroupArn = endpointGroupArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension GlobalAcceleratorClientTypes {

    /// Returns the ports and associated IP addresses and ports of Amazon EC2 instances in your virtual private cloud (VPC) subnets. Custom routing is a port mapping protocol in Global Accelerator that statically associates port ranges with VPC subnets, which allows Global Accelerator to route to specific instances and ports within one or more subnets.
    public struct PortMapping: Swift.Sendable {
        /// The accelerator port.
        public var acceleratorPort: Swift.Int?
        /// The EC2 instance IP address and port number in the virtual private cloud (VPC) subnet.
        public var destinationSocketAddress: GlobalAcceleratorClientTypes.SocketAddress?
        /// Indicates whether or not a port mapping destination can receive traffic. The value is either ALLOW, if traffic is allowed to the destination, or DENY, if traffic is not allowed to the destination.
        public var destinationTrafficState: GlobalAcceleratorClientTypes.CustomRoutingDestinationTrafficState?
        /// The Amazon Resource Name (ARN) of the endpoint group.
        public var endpointGroupArn: Swift.String?
        /// The IP address of the VPC subnet (the subnet ID).
        public var endpointId: Swift.String?
        /// The protocols supported by the endpoint group.
        public var protocols: [GlobalAcceleratorClientTypes.CustomRoutingProtocol]?

        public init(
            acceleratorPort: Swift.Int? = nil,
            destinationSocketAddress: GlobalAcceleratorClientTypes.SocketAddress? = nil,
            destinationTrafficState: GlobalAcceleratorClientTypes.CustomRoutingDestinationTrafficState? = nil,
            endpointGroupArn: Swift.String? = nil,
            endpointId: Swift.String? = nil,
            protocols: [GlobalAcceleratorClientTypes.CustomRoutingProtocol]? = nil
        )
        {
            self.acceleratorPort = acceleratorPort
            self.destinationSocketAddress = destinationSocketAddress
            self.destinationTrafficState = destinationTrafficState
            self.endpointGroupArn = endpointGroupArn
            self.endpointId = endpointId
            self.protocols = protocols
        }
    }
}

public struct ListCustomRoutingPortMappingsOutput: Swift.Sendable {
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?
    /// The port mappings for a custom routing accelerator.
    public var portMappings: [GlobalAcceleratorClientTypes.PortMapping]?

    public init(
        nextToken: Swift.String? = nil,
        portMappings: [GlobalAcceleratorClientTypes.PortMapping]? = nil
    )
    {
        self.nextToken = nextToken
        self.portMappings = portMappings
    }
}

public struct ListCustomRoutingPortMappingsByDestinationInput: Swift.Sendable {
    /// The endpoint IP address in a virtual private cloud (VPC) subnet for which you want to receive back port mappings.
    /// This member is required.
    public var destinationAddress: Swift.String?
    /// The ID for the virtual private cloud (VPC) subnet.
    /// This member is required.
    public var endpointId: Swift.String?
    /// The number of destination port mappings that you want to return with this call. The default value is 10.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        destinationAddress: Swift.String? = nil,
        endpointId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.destinationAddress = destinationAddress
        self.endpointId = endpointId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListCustomRoutingPortMappingsByDestinationOutput: Swift.Sendable {
    /// The port mappings for the endpoint IP address that you specified in the request.
    public var destinationPortMappings: [GlobalAcceleratorClientTypes.DestinationPortMapping]?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        destinationPortMappings: [GlobalAcceleratorClientTypes.DestinationPortMapping]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.destinationPortMappings = destinationPortMappings
        self.nextToken = nextToken
    }
}

public struct ListEndpointGroupsInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerArn: Swift.String?
    /// The number of endpoint group objects that you want to return with this call. The default value is 10.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        listenerArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.listenerArn = listenerArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListEndpointGroupsOutput: Swift.Sendable {
    /// The list of the endpoint groups associated with a listener.
    public var endpointGroups: [GlobalAcceleratorClientTypes.EndpointGroup]?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        endpointGroups: [GlobalAcceleratorClientTypes.EndpointGroup]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.endpointGroups = endpointGroups
        self.nextToken = nextToken
    }
}

public struct ListListenersInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the accelerator for which you want to list listener objects.
    /// This member is required.
    public var acceleratorArn: Swift.String?
    /// The number of listener objects that you want to return with this call. The default value is 10.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        acceleratorArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListListenersOutput: Swift.Sendable {
    /// The list of listeners for an accelerator.
    public var listeners: [GlobalAcceleratorClientTypes.Listener]?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        listeners: [GlobalAcceleratorClientTypes.Listener]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.listeners = listeners
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the accelerator to list tags for. An ARN uniquely identifies an accelerator.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// Root level tag for the Tags parameters.
    public var tags: [GlobalAcceleratorClientTypes.Tag]?

    public init(
        tags: [GlobalAcceleratorClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

public struct ProvisionByoipCidrInput: Swift.Sendable {
    /// The public IPv4 address range, in CIDR notation. The most specific IP prefix that you can specify is /24. The address range cannot overlap with another address range that you've brought to this Amazon Web Services Region or another Region. For more information, see [Bring your own IP addresses (BYOIP)](https://docs.aws.amazon.com/global-accelerator/latest/dg/using-byoip.html) in the Global Accelerator Developer Guide.
    /// This member is required.
    public var cidr: Swift.String?
    /// A signed document that proves that you are authorized to bring the specified IP address range to Amazon using BYOIP.
    /// This member is required.
    public var cidrAuthorizationContext: GlobalAcceleratorClientTypes.CidrAuthorizationContext?

    public init(
        cidr: Swift.String? = nil,
        cidrAuthorizationContext: GlobalAcceleratorClientTypes.CidrAuthorizationContext? = nil
    )
    {
        self.cidr = cidr
        self.cidrAuthorizationContext = cidrAuthorizationContext
    }
}

public struct ProvisionByoipCidrOutput: Swift.Sendable {
    /// Information about the address range.
    public var byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr?

    public init(
        byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr? = nil
    )
    {
        self.byoipCidr = byoipCidr
    }
}

public struct RemoveCustomRoutingEndpointsInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the endpoint group to remove endpoints from.
    /// This member is required.
    public var endpointGroupArn: Swift.String?
    /// The IDs for the endpoints. For custom routing accelerators, endpoint IDs are the virtual private cloud (VPC) subnet IDs.
    /// This member is required.
    public var endpointIds: [Swift.String]?

    public init(
        endpointGroupArn: Swift.String? = nil,
        endpointIds: [Swift.String]? = nil
    )
    {
        self.endpointGroupArn = endpointGroupArn
        self.endpointIds = endpointIds
    }
}

public struct RemoveEndpointsInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the endpoint group.
    /// This member is required.
    public var endpointGroupArn: Swift.String?
    /// The identifiers of the endpoints that you want to remove.
    /// This member is required.
    public var endpointIdentifiers: [GlobalAcceleratorClientTypes.EndpointIdentifier]?

    public init(
        endpointGroupArn: Swift.String? = nil,
        endpointIdentifiers: [GlobalAcceleratorClientTypes.EndpointIdentifier]? = nil
    )
    {
        self.endpointGroupArn = endpointGroupArn
        self.endpointIdentifiers = endpointIdentifiers
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the Global Accelerator resource to add tags to. An ARN uniquely identifies a resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to a resource. A tag consists of a key and a value that you define.
    /// This member is required.
    public var tags: [GlobalAcceleratorClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [GlobalAcceleratorClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the Global Accelerator resource to remove tags from. An ARN uniquely identifies a resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag key pairs that you want to remove from the specified resources.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateAcceleratorInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the accelerator to update.
    /// This member is required.
    public var acceleratorArn: Swift.String?
    /// Indicates whether an accelerator is enabled. The value is true or false. The default value is true. If the value is set to true, the accelerator cannot be deleted. If set to false, the accelerator can be deleted.
    public var enabled: Swift.Bool?
    /// The IP address type that an accelerator supports. For a standard accelerator, the value can be IPV4 or DUAL_STACK.
    public var ipAddressType: GlobalAcceleratorClientTypes.IpAddressType?
    /// The IP addresses for an accelerator.
    public var ipAddresses: [Swift.String]?
    /// The name of the accelerator. The name can have a maximum of 64 characters, must contain only alphanumeric characters, periods (.), or hyphens (-), and must not begin or end with a hyphen or period.
    public var name: Swift.String?

    public init(
        acceleratorArn: Swift.String? = nil,
        enabled: Swift.Bool? = nil,
        ipAddressType: GlobalAcceleratorClientTypes.IpAddressType? = nil,
        ipAddresses: [Swift.String]? = nil,
        name: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.enabled = enabled
        self.ipAddressType = ipAddressType
        self.ipAddresses = ipAddresses
        self.name = name
    }
}

public struct UpdateAcceleratorOutput: Swift.Sendable {
    /// Information about the updated accelerator.
    public var accelerator: GlobalAcceleratorClientTypes.Accelerator?

    public init(
        accelerator: GlobalAcceleratorClientTypes.Accelerator? = nil
    )
    {
        self.accelerator = accelerator
    }
}

public struct UpdateAcceleratorAttributesInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the accelerator that you want to update.
    /// This member is required.
    public var acceleratorArn: Swift.String?
    /// Update whether flow logs are enabled. The default value is false. If the value is true, FlowLogsS3Bucket and FlowLogsS3Prefix must be specified. For more information, see [Flow Logs](https://docs.aws.amazon.com/global-accelerator/latest/dg/monitoring-global-accelerator.flow-logs.html) in the Global Accelerator Developer Guide.
    public var flowLogsEnabled: Swift.Bool?
    /// The name of the Amazon S3 bucket for the flow logs. Attribute is required if FlowLogsEnabled is true. The bucket must exist and have a bucket policy that grants Global Accelerator permission to write to the bucket.
    public var flowLogsS3Bucket: Swift.String?
    /// Update the prefix for the location in the Amazon S3 bucket for the flow logs. Attribute is required if FlowLogsEnabled is true. If you specify slash (/) for the S3 bucket prefix, the log file bucket folder structure will include a double slash (//), like the following: s3-bucket_name//AWSLogs/aws_account_id
    public var flowLogsS3Prefix: Swift.String?

    public init(
        acceleratorArn: Swift.String? = nil,
        flowLogsEnabled: Swift.Bool? = nil,
        flowLogsS3Bucket: Swift.String? = nil,
        flowLogsS3Prefix: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.flowLogsEnabled = flowLogsEnabled
        self.flowLogsS3Bucket = flowLogsS3Bucket
        self.flowLogsS3Prefix = flowLogsS3Prefix
    }
}

public struct UpdateAcceleratorAttributesOutput: Swift.Sendable {
    /// Updated attributes for the accelerator.
    public var acceleratorAttributes: GlobalAcceleratorClientTypes.AcceleratorAttributes?

    public init(
        acceleratorAttributes: GlobalAcceleratorClientTypes.AcceleratorAttributes? = nil
    )
    {
        self.acceleratorAttributes = acceleratorAttributes
    }
}

public struct UpdateCrossAccountAttachmentInput: Swift.Sendable {
    /// The principals to add to the cross-account attachment. A principal is an account or the Amazon Resource Name (ARN) of an accelerator that the attachment gives permission to work with resources from another account. The resources are also listed in the attachment. To add more than one principal, separate the account numbers or accelerator ARNs, or both, with commas.
    public var addPrincipals: [Swift.String]?
    /// The resources to add to the cross-account attachment. A resource listed in a cross-account attachment can be used with an accelerator by the principals that are listed in the attachment. To add more than one resource, separate the resource ARNs with commas.
    public var addResources: [GlobalAcceleratorClientTypes.Resource]?
    /// The Amazon Resource Name (ARN) of the cross-account attachment to update.
    /// This member is required.
    public var attachmentArn: Swift.String?
    /// The name of the cross-account attachment.
    public var name: Swift.String?
    /// The principals to remove from the cross-account attachment. A principal is an account or the Amazon Resource Name (ARN) of an accelerator that the attachment gives permission to work with resources from another account. The resources are also listed in the attachment. To remove more than one principal, separate the account numbers or accelerator ARNs, or both, with commas.
    public var removePrincipals: [Swift.String]?
    /// The resources to remove from the cross-account attachment. A resource listed in a cross-account attachment can be used with an accelerator by the principals that are listed in the attachment. To remove more than one resource, separate the resource ARNs with commas.
    public var removeResources: [GlobalAcceleratorClientTypes.Resource]?

    public init(
        addPrincipals: [Swift.String]? = nil,
        addResources: [GlobalAcceleratorClientTypes.Resource]? = nil,
        attachmentArn: Swift.String? = nil,
        name: Swift.String? = nil,
        removePrincipals: [Swift.String]? = nil,
        removeResources: [GlobalAcceleratorClientTypes.Resource]? = nil
    )
    {
        self.addPrincipals = addPrincipals
        self.addResources = addResources
        self.attachmentArn = attachmentArn
        self.name = name
        self.removePrincipals = removePrincipals
        self.removeResources = removeResources
    }
}

public struct UpdateCrossAccountAttachmentOutput: Swift.Sendable {
    /// Information about the updated cross-account attachment.
    public var crossAccountAttachment: GlobalAcceleratorClientTypes.Attachment?

    public init(
        crossAccountAttachment: GlobalAcceleratorClientTypes.Attachment? = nil
    )
    {
        self.crossAccountAttachment = crossAccountAttachment
    }
}

public struct UpdateCustomRoutingAcceleratorInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the accelerator to update.
    /// This member is required.
    public var acceleratorArn: Swift.String?
    /// Indicates whether an accelerator is enabled. The value is true or false. The default value is true. If the value is set to true, the accelerator cannot be deleted. If set to false, the accelerator can be deleted.
    public var enabled: Swift.Bool?
    /// The IP address type that an accelerator supports. For a custom routing accelerator, the value must be IPV4.
    public var ipAddressType: GlobalAcceleratorClientTypes.IpAddressType?
    /// The IP addresses for an accelerator.
    public var ipAddresses: [Swift.String]?
    /// The name of the accelerator. The name can have a maximum of 64 characters, must contain only alphanumeric characters, periods (.), or hyphens (-), and must not begin or end with a hyphen or period.
    public var name: Swift.String?

    public init(
        acceleratorArn: Swift.String? = nil,
        enabled: Swift.Bool? = nil,
        ipAddressType: GlobalAcceleratorClientTypes.IpAddressType? = nil,
        ipAddresses: [Swift.String]? = nil,
        name: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.enabled = enabled
        self.ipAddressType = ipAddressType
        self.ipAddresses = ipAddresses
        self.name = name
    }
}

public struct UpdateCustomRoutingAcceleratorOutput: Swift.Sendable {
    /// Information about the updated custom routing accelerator.
    public var accelerator: GlobalAcceleratorClientTypes.CustomRoutingAccelerator?

    public init(
        accelerator: GlobalAcceleratorClientTypes.CustomRoutingAccelerator? = nil
    )
    {
        self.accelerator = accelerator
    }
}

public struct UpdateCustomRoutingAcceleratorAttributesInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the custom routing accelerator to update attributes for.
    /// This member is required.
    public var acceleratorArn: Swift.String?
    /// Update whether flow logs are enabled. The default value is false. If the value is true, FlowLogsS3Bucket and FlowLogsS3Prefix must be specified. For more information, see [Flow logs](https://docs.aws.amazon.com/global-accelerator/latest/dg/monitoring-global-accelerator.flow-logs.html) in the Global Accelerator Developer Guide.
    public var flowLogsEnabled: Swift.Bool?
    /// The name of the Amazon S3 bucket for the flow logs. Attribute is required if FlowLogsEnabled is true. The bucket must exist and have a bucket policy that grants Global Accelerator permission to write to the bucket.
    public var flowLogsS3Bucket: Swift.String?
    /// Update the prefix for the location in the Amazon S3 bucket for the flow logs. Attribute is required if FlowLogsEnabled is true. If you don’t specify a prefix, the flow logs are stored in the root of the bucket. If you specify slash (/) for the S3 bucket prefix, the log file bucket folder structure will include a double slash (//), like the following: DOC-EXAMPLE-BUCKET//AWSLogs/aws_account_id
    public var flowLogsS3Prefix: Swift.String?

    public init(
        acceleratorArn: Swift.String? = nil,
        flowLogsEnabled: Swift.Bool? = nil,
        flowLogsS3Bucket: Swift.String? = nil,
        flowLogsS3Prefix: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.flowLogsEnabled = flowLogsEnabled
        self.flowLogsS3Bucket = flowLogsS3Bucket
        self.flowLogsS3Prefix = flowLogsS3Prefix
    }
}

public struct UpdateCustomRoutingAcceleratorAttributesOutput: Swift.Sendable {
    /// Updated custom routing accelerator.
    public var acceleratorAttributes: GlobalAcceleratorClientTypes.CustomRoutingAcceleratorAttributes?

    public init(
        acceleratorAttributes: GlobalAcceleratorClientTypes.CustomRoutingAcceleratorAttributes? = nil
    )
    {
        self.acceleratorAttributes = acceleratorAttributes
    }
}

public struct UpdateCustomRoutingListenerInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the listener to update.
    /// This member is required.
    public var listenerArn: Swift.String?
    /// The updated port range to support for connections from clients to your accelerator. If you remove ports that are currently being used by a subnet endpoint, the call fails. Separately, you set port ranges for endpoints. For more information, see [About endpoints for custom routing accelerators](https://docs.aws.amazon.com/global-accelerator/latest/dg/about-custom-routing-endpoints.html).
    /// This member is required.
    public var portRanges: [GlobalAcceleratorClientTypes.PortRange]?

    public init(
        listenerArn: Swift.String? = nil,
        portRanges: [GlobalAcceleratorClientTypes.PortRange]? = nil
    )
    {
        self.listenerArn = listenerArn
        self.portRanges = portRanges
    }
}

public struct UpdateCustomRoutingListenerOutput: Swift.Sendable {
    /// Information for the updated listener for a custom routing accelerator.
    public var listener: GlobalAcceleratorClientTypes.CustomRoutingListener?

    public init(
        listener: GlobalAcceleratorClientTypes.CustomRoutingListener? = nil
    )
    {
        self.listener = listener
    }
}

public struct UpdateEndpointGroupInput: Swift.Sendable {
    /// The list of endpoint objects. A resource must be valid and active when you add it as an endpoint.
    public var endpointConfigurations: [GlobalAcceleratorClientTypes.EndpointConfiguration]?
    /// The Amazon Resource Name (ARN) of the endpoint group.
    /// This member is required.
    public var endpointGroupArn: Swift.String?
    /// The time—10 seconds or 30 seconds—between each health check for an endpoint. The default value is 30.
    public var healthCheckIntervalSeconds: Swift.Int?
    /// If the protocol is HTTP/S, then this specifies the path that is the destination for health check targets. The default value is slash (/).
    public var healthCheckPath: Swift.String?
    /// The port that Global Accelerator uses to check the health of endpoints that are part of this endpoint group. The default port is the listener port that this endpoint group is associated with. If the listener port is a list of ports, Global Accelerator uses the first port in the list.
    public var healthCheckPort: Swift.Int?
    /// The protocol that Global Accelerator uses to check the health of endpoints that are part of this endpoint group. The default value is TCP.
    public var healthCheckProtocol: GlobalAcceleratorClientTypes.HealthCheckProtocol?
    /// Override specific listener ports used to route traffic to endpoints that are part of this endpoint group. For example, you can create a port override in which the listener receives user traffic on ports 80 and 443, but your accelerator routes that traffic to ports 1080 and 1443, respectively, on the endpoints. For more information, see [ Overriding listener ports](https://docs.aws.amazon.com/global-accelerator/latest/dg/about-endpoint-groups-port-override.html) in the Global Accelerator Developer Guide.
    public var portOverrides: [GlobalAcceleratorClientTypes.PortOverride]?
    /// The number of consecutive health checks required to set the state of a healthy endpoint to unhealthy, or to set an unhealthy endpoint to healthy. The default value is 3.
    public var thresholdCount: Swift.Int?
    /// The percentage of traffic to send to an Amazon Web Services Region. Additional traffic is distributed to other endpoint groups for this listener. Use this action to increase (dial up) or decrease (dial down) traffic to a specific Region. The percentage is applied to the traffic that would otherwise have been routed to the Region based on optimal routing. The default value is 100.
    public var trafficDialPercentage: Swift.Float?

    public init(
        endpointConfigurations: [GlobalAcceleratorClientTypes.EndpointConfiguration]? = nil,
        endpointGroupArn: Swift.String? = nil,
        healthCheckIntervalSeconds: Swift.Int? = nil,
        healthCheckPath: Swift.String? = nil,
        healthCheckPort: Swift.Int? = nil,
        healthCheckProtocol: GlobalAcceleratorClientTypes.HealthCheckProtocol? = nil,
        portOverrides: [GlobalAcceleratorClientTypes.PortOverride]? = nil,
        thresholdCount: Swift.Int? = nil,
        trafficDialPercentage: Swift.Float? = nil
    )
    {
        self.endpointConfigurations = endpointConfigurations
        self.endpointGroupArn = endpointGroupArn
        self.healthCheckIntervalSeconds = healthCheckIntervalSeconds
        self.healthCheckPath = healthCheckPath
        self.healthCheckPort = healthCheckPort
        self.healthCheckProtocol = healthCheckProtocol
        self.portOverrides = portOverrides
        self.thresholdCount = thresholdCount
        self.trafficDialPercentage = trafficDialPercentage
    }
}

public struct UpdateEndpointGroupOutput: Swift.Sendable {
    /// The information about the endpoint group that was updated.
    public var endpointGroup: GlobalAcceleratorClientTypes.EndpointGroup?

    public init(
        endpointGroup: GlobalAcceleratorClientTypes.EndpointGroup? = nil
    )
    {
        self.endpointGroup = endpointGroup
    }
}

public struct UpdateListenerInput: Swift.Sendable {
    /// Client affinity lets you direct all requests from a user to the same endpoint, if you have stateful applications, regardless of the port and protocol of the client request. Client affinity gives you control over whether to always route each client to the same specific endpoint. Global Accelerator uses a consistent-flow hashing algorithm to choose the optimal endpoint for a connection. If client affinity is NONE, Global Accelerator uses the "five-tuple" (5-tuple) properties—source IP address, source port, destination IP address, destination port, and protocol—to select the hash value, and then chooses the best endpoint. However, with this setting, if someone uses different ports to connect to Global Accelerator, their connections might not be always routed to the same endpoint because the hash value changes. If you want a given client to always be routed to the same endpoint, set client affinity to SOURCE_IP instead. When you use the SOURCE_IP setting, Global Accelerator uses the "two-tuple" (2-tuple) properties— source (client) IP address and destination IP address—to select the hash value. The default value is NONE.
    public var clientAffinity: GlobalAcceleratorClientTypes.ClientAffinity?
    /// The Amazon Resource Name (ARN) of the listener to update.
    /// This member is required.
    public var listenerArn: Swift.String?
    /// The updated list of port ranges for the connections from clients to the accelerator.
    public var portRanges: [GlobalAcceleratorClientTypes.PortRange]?
    /// The updated protocol for the connections from clients to the accelerator.
    public var `protocol`: GlobalAcceleratorClientTypes.ModelProtocol?

    public init(
        clientAffinity: GlobalAcceleratorClientTypes.ClientAffinity? = nil,
        listenerArn: Swift.String? = nil,
        portRanges: [GlobalAcceleratorClientTypes.PortRange]? = nil,
        `protocol`: GlobalAcceleratorClientTypes.ModelProtocol? = nil
    )
    {
        self.clientAffinity = clientAffinity
        self.listenerArn = listenerArn
        self.portRanges = portRanges
        self.`protocol` = `protocol`
    }
}

public struct UpdateListenerOutput: Swift.Sendable {
    /// Information for the updated listener.
    public var listener: GlobalAcceleratorClientTypes.Listener?

    public init(
        listener: GlobalAcceleratorClientTypes.Listener? = nil
    )
    {
        self.listener = listener
    }
}

public struct WithdrawByoipCidrInput: Swift.Sendable {
    /// The address range, in CIDR notation. For more information, see [Bring your own IP addresses (BYOIP)](https://docs.aws.amazon.com/global-accelerator/latest/dg/using-byoip.html) in the Global Accelerator Developer Guide.
    /// This member is required.
    public var cidr: Swift.String?

    public init(
        cidr: Swift.String? = nil
    )
    {
        self.cidr = cidr
    }
}

public struct WithdrawByoipCidrOutput: Swift.Sendable {
    /// Information about the BYOIP address pool.
    public var byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr?

    public init(
        byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr? = nil
    )
    {
        self.byoipCidr = byoipCidr
    }
}

extension AddCustomRoutingEndpointsInput {

    static func urlPathProvider(_ value: AddCustomRoutingEndpointsInput) -> Swift.String? {
        return "/"
    }
}

extension AddEndpointsInput {

    static func urlPathProvider(_ value: AddEndpointsInput) -> Swift.String? {
        return "/"
    }
}

extension AdvertiseByoipCidrInput {

    static func urlPathProvider(_ value: AdvertiseByoipCidrInput) -> Swift.String? {
        return "/"
    }
}

extension AllowCustomRoutingTrafficInput {

    static func urlPathProvider(_ value: AllowCustomRoutingTrafficInput) -> Swift.String? {
        return "/"
    }
}

extension CreateAcceleratorInput {

    static func urlPathProvider(_ value: CreateAcceleratorInput) -> Swift.String? {
        return "/"
    }
}

extension CreateCrossAccountAttachmentInput {

    static func urlPathProvider(_ value: CreateCrossAccountAttachmentInput) -> Swift.String? {
        return "/"
    }
}

extension CreateCustomRoutingAcceleratorInput {

    static func urlPathProvider(_ value: CreateCustomRoutingAcceleratorInput) -> Swift.String? {
        return "/"
    }
}

extension CreateCustomRoutingEndpointGroupInput {

    static func urlPathProvider(_ value: CreateCustomRoutingEndpointGroupInput) -> Swift.String? {
        return "/"
    }
}

extension CreateCustomRoutingListenerInput {

    static func urlPathProvider(_ value: CreateCustomRoutingListenerInput) -> Swift.String? {
        return "/"
    }
}

extension CreateEndpointGroupInput {

    static func urlPathProvider(_ value: CreateEndpointGroupInput) -> Swift.String? {
        return "/"
    }
}

extension CreateListenerInput {

    static func urlPathProvider(_ value: CreateListenerInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteAcceleratorInput {

    static func urlPathProvider(_ value: DeleteAcceleratorInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteCrossAccountAttachmentInput {

    static func urlPathProvider(_ value: DeleteCrossAccountAttachmentInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteCustomRoutingAcceleratorInput {

    static func urlPathProvider(_ value: DeleteCustomRoutingAcceleratorInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteCustomRoutingEndpointGroupInput {

    static func urlPathProvider(_ value: DeleteCustomRoutingEndpointGroupInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteCustomRoutingListenerInput {

    static func urlPathProvider(_ value: DeleteCustomRoutingListenerInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteEndpointGroupInput {

    static func urlPathProvider(_ value: DeleteEndpointGroupInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteListenerInput {

    static func urlPathProvider(_ value: DeleteListenerInput) -> Swift.String? {
        return "/"
    }
}

extension DenyCustomRoutingTrafficInput {

    static func urlPathProvider(_ value: DenyCustomRoutingTrafficInput) -> Swift.String? {
        return "/"
    }
}

extension DeprovisionByoipCidrInput {

    static func urlPathProvider(_ value: DeprovisionByoipCidrInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAcceleratorInput {

    static func urlPathProvider(_ value: DescribeAcceleratorInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAcceleratorAttributesInput {

    static func urlPathProvider(_ value: DescribeAcceleratorAttributesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeCrossAccountAttachmentInput {

    static func urlPathProvider(_ value: DescribeCrossAccountAttachmentInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeCustomRoutingAcceleratorInput {

    static func urlPathProvider(_ value: DescribeCustomRoutingAcceleratorInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeCustomRoutingAcceleratorAttributesInput {

    static func urlPathProvider(_ value: DescribeCustomRoutingAcceleratorAttributesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeCustomRoutingEndpointGroupInput {

    static func urlPathProvider(_ value: DescribeCustomRoutingEndpointGroupInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeCustomRoutingListenerInput {

    static func urlPathProvider(_ value: DescribeCustomRoutingListenerInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeEndpointGroupInput {

    static func urlPathProvider(_ value: DescribeEndpointGroupInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeListenerInput {

    static func urlPathProvider(_ value: DescribeListenerInput) -> Swift.String? {
        return "/"
    }
}

extension ListAcceleratorsInput {

    static func urlPathProvider(_ value: ListAcceleratorsInput) -> Swift.String? {
        return "/"
    }
}

extension ListByoipCidrsInput {

    static func urlPathProvider(_ value: ListByoipCidrsInput) -> Swift.String? {
        return "/"
    }
}

extension ListCrossAccountAttachmentsInput {

    static func urlPathProvider(_ value: ListCrossAccountAttachmentsInput) -> Swift.String? {
        return "/"
    }
}

extension ListCrossAccountResourceAccountsInput {

    static func urlPathProvider(_ value: ListCrossAccountResourceAccountsInput) -> Swift.String? {
        return "/"
    }
}

extension ListCrossAccountResourcesInput {

    static func urlPathProvider(_ value: ListCrossAccountResourcesInput) -> Swift.String? {
        return "/"
    }
}

extension ListCustomRoutingAcceleratorsInput {

    static func urlPathProvider(_ value: ListCustomRoutingAcceleratorsInput) -> Swift.String? {
        return "/"
    }
}

extension ListCustomRoutingEndpointGroupsInput {

    static func urlPathProvider(_ value: ListCustomRoutingEndpointGroupsInput) -> Swift.String? {
        return "/"
    }
}

extension ListCustomRoutingListenersInput {

    static func urlPathProvider(_ value: ListCustomRoutingListenersInput) -> Swift.String? {
        return "/"
    }
}

extension ListCustomRoutingPortMappingsInput {

    static func urlPathProvider(_ value: ListCustomRoutingPortMappingsInput) -> Swift.String? {
        return "/"
    }
}

extension ListCustomRoutingPortMappingsByDestinationInput {

    static func urlPathProvider(_ value: ListCustomRoutingPortMappingsByDestinationInput) -> Swift.String? {
        return "/"
    }
}

extension ListEndpointGroupsInput {

    static func urlPathProvider(_ value: ListEndpointGroupsInput) -> Swift.String? {
        return "/"
    }
}

extension ListListenersInput {

    static func urlPathProvider(_ value: ListListenersInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension ProvisionByoipCidrInput {

    static func urlPathProvider(_ value: ProvisionByoipCidrInput) -> Swift.String? {
        return "/"
    }
}

extension RemoveCustomRoutingEndpointsInput {

    static func urlPathProvider(_ value: RemoveCustomRoutingEndpointsInput) -> Swift.String? {
        return "/"
    }
}

extension RemoveEndpointsInput {

    static func urlPathProvider(_ value: RemoveEndpointsInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateAcceleratorInput {

    static func urlPathProvider(_ value: UpdateAcceleratorInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateAcceleratorAttributesInput {

    static func urlPathProvider(_ value: UpdateAcceleratorAttributesInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateCrossAccountAttachmentInput {

    static func urlPathProvider(_ value: UpdateCrossAccountAttachmentInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateCustomRoutingAcceleratorInput {

    static func urlPathProvider(_ value: UpdateCustomRoutingAcceleratorInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateCustomRoutingAcceleratorAttributesInput {

    static func urlPathProvider(_ value: UpdateCustomRoutingAcceleratorAttributesInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateCustomRoutingListenerInput {

    static func urlPathProvider(_ value: UpdateCustomRoutingListenerInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateEndpointGroupInput {

    static func urlPathProvider(_ value: UpdateEndpointGroupInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateListenerInput {

    static func urlPathProvider(_ value: UpdateListenerInput) -> Swift.String? {
        return "/"
    }
}

extension WithdrawByoipCidrInput {

    static func urlPathProvider(_ value: WithdrawByoipCidrInput) -> Swift.String? {
        return "/"
    }
}

extension AddCustomRoutingEndpointsInput {

    static func write(value: AddCustomRoutingEndpointsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndpointConfigurations"].writeList(value.endpointConfigurations, memberWritingClosure: GlobalAcceleratorClientTypes.CustomRoutingEndpointConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EndpointGroupArn"].write(value.endpointGroupArn)
    }
}

extension AddEndpointsInput {

    static func write(value: AddEndpointsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndpointConfigurations"].writeList(value.endpointConfigurations, memberWritingClosure: GlobalAcceleratorClientTypes.EndpointConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EndpointGroupArn"].write(value.endpointGroupArn)
    }
}

extension AdvertiseByoipCidrInput {

    static func write(value: AdvertiseByoipCidrInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Cidr"].write(value.cidr)
    }
}

extension AllowCustomRoutingTrafficInput {

    static func write(value: AllowCustomRoutingTrafficInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowAllTrafficToEndpoint"].write(value.allowAllTrafficToEndpoint)
        try writer["DestinationAddresses"].writeList(value.destinationAddresses, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DestinationPorts"].writeList(value.destinationPorts, memberWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EndpointGroupArn"].write(value.endpointGroupArn)
        try writer["EndpointId"].write(value.endpointId)
    }
}

extension CreateAcceleratorInput {

    static func write(value: CreateAcceleratorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
        try writer["IdempotencyToken"].write(value.idempotencyToken)
        try writer["IpAddressType"].write(value.ipAddressType)
        try writer["IpAddresses"].writeList(value.ipAddresses, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: GlobalAcceleratorClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateCrossAccountAttachmentInput {

    static func write(value: CreateCrossAccountAttachmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IdempotencyToken"].write(value.idempotencyToken)
        try writer["Name"].write(value.name)
        try writer["Principals"].writeList(value.principals, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Resources"].writeList(value.resources, memberWritingClosure: GlobalAcceleratorClientTypes.Resource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: GlobalAcceleratorClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateCustomRoutingAcceleratorInput {

    static func write(value: CreateCustomRoutingAcceleratorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
        try writer["IdempotencyToken"].write(value.idempotencyToken)
        try writer["IpAddressType"].write(value.ipAddressType)
        try writer["IpAddresses"].writeList(value.ipAddresses, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: GlobalAcceleratorClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateCustomRoutingEndpointGroupInput {

    static func write(value: CreateCustomRoutingEndpointGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationConfigurations"].writeList(value.destinationConfigurations, memberWritingClosure: GlobalAcceleratorClientTypes.CustomRoutingDestinationConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EndpointGroupRegion"].write(value.endpointGroupRegion)
        try writer["IdempotencyToken"].write(value.idempotencyToken)
        try writer["ListenerArn"].write(value.listenerArn)
    }
}

extension CreateCustomRoutingListenerInput {

    static func write(value: CreateCustomRoutingListenerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceleratorArn"].write(value.acceleratorArn)
        try writer["IdempotencyToken"].write(value.idempotencyToken)
        try writer["PortRanges"].writeList(value.portRanges, memberWritingClosure: GlobalAcceleratorClientTypes.PortRange.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateEndpointGroupInput {

    static func write(value: CreateEndpointGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndpointConfigurations"].writeList(value.endpointConfigurations, memberWritingClosure: GlobalAcceleratorClientTypes.EndpointConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EndpointGroupRegion"].write(value.endpointGroupRegion)
        try writer["HealthCheckIntervalSeconds"].write(value.healthCheckIntervalSeconds)
        try writer["HealthCheckPath"].write(value.healthCheckPath)
        try writer["HealthCheckPort"].write(value.healthCheckPort)
        try writer["HealthCheckProtocol"].write(value.healthCheckProtocol)
        try writer["IdempotencyToken"].write(value.idempotencyToken)
        try writer["ListenerArn"].write(value.listenerArn)
        try writer["PortOverrides"].writeList(value.portOverrides, memberWritingClosure: GlobalAcceleratorClientTypes.PortOverride.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ThresholdCount"].write(value.thresholdCount)
        try writer["TrafficDialPercentage"].write(value.trafficDialPercentage)
    }
}

extension CreateListenerInput {

    static func write(value: CreateListenerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceleratorArn"].write(value.acceleratorArn)
        try writer["ClientAffinity"].write(value.clientAffinity)
        try writer["IdempotencyToken"].write(value.idempotencyToken)
        try writer["PortRanges"].writeList(value.portRanges, memberWritingClosure: GlobalAcceleratorClientTypes.PortRange.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Protocol"].write(value.`protocol`)
    }
}

extension DeleteAcceleratorInput {

    static func write(value: DeleteAcceleratorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceleratorArn"].write(value.acceleratorArn)
    }
}

extension DeleteCrossAccountAttachmentInput {

    static func write(value: DeleteCrossAccountAttachmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttachmentArn"].write(value.attachmentArn)
    }
}

extension DeleteCustomRoutingAcceleratorInput {

    static func write(value: DeleteCustomRoutingAcceleratorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceleratorArn"].write(value.acceleratorArn)
    }
}

extension DeleteCustomRoutingEndpointGroupInput {

    static func write(value: DeleteCustomRoutingEndpointGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndpointGroupArn"].write(value.endpointGroupArn)
    }
}

extension DeleteCustomRoutingListenerInput {

    static func write(value: DeleteCustomRoutingListenerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ListenerArn"].write(value.listenerArn)
    }
}

extension DeleteEndpointGroupInput {

    static func write(value: DeleteEndpointGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndpointGroupArn"].write(value.endpointGroupArn)
    }
}

extension DeleteListenerInput {

    static func write(value: DeleteListenerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ListenerArn"].write(value.listenerArn)
    }
}

extension DenyCustomRoutingTrafficInput {

    static func write(value: DenyCustomRoutingTrafficInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DenyAllTrafficToEndpoint"].write(value.denyAllTrafficToEndpoint)
        try writer["DestinationAddresses"].writeList(value.destinationAddresses, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DestinationPorts"].writeList(value.destinationPorts, memberWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EndpointGroupArn"].write(value.endpointGroupArn)
        try writer["EndpointId"].write(value.endpointId)
    }
}

extension DeprovisionByoipCidrInput {

    static func write(value: DeprovisionByoipCidrInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Cidr"].write(value.cidr)
    }
}

extension DescribeAcceleratorInput {

    static func write(value: DescribeAcceleratorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceleratorArn"].write(value.acceleratorArn)
    }
}

extension DescribeAcceleratorAttributesInput {

    static func write(value: DescribeAcceleratorAttributesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceleratorArn"].write(value.acceleratorArn)
    }
}

extension DescribeCrossAccountAttachmentInput {

    static func write(value: DescribeCrossAccountAttachmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttachmentArn"].write(value.attachmentArn)
    }
}

extension DescribeCustomRoutingAcceleratorInput {

    static func write(value: DescribeCustomRoutingAcceleratorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceleratorArn"].write(value.acceleratorArn)
    }
}

extension DescribeCustomRoutingAcceleratorAttributesInput {

    static func write(value: DescribeCustomRoutingAcceleratorAttributesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceleratorArn"].write(value.acceleratorArn)
    }
}

extension DescribeCustomRoutingEndpointGroupInput {

    static func write(value: DescribeCustomRoutingEndpointGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndpointGroupArn"].write(value.endpointGroupArn)
    }
}

extension DescribeCustomRoutingListenerInput {

    static func write(value: DescribeCustomRoutingListenerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ListenerArn"].write(value.listenerArn)
    }
}

extension DescribeEndpointGroupInput {

    static func write(value: DescribeEndpointGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndpointGroupArn"].write(value.endpointGroupArn)
    }
}

extension DescribeListenerInput {

    static func write(value: DescribeListenerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ListenerArn"].write(value.listenerArn)
    }
}

extension ListAcceleratorsInput {

    static func write(value: ListAcceleratorsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListByoipCidrsInput {

    static func write(value: ListByoipCidrsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListCrossAccountAttachmentsInput {

    static func write(value: ListCrossAccountAttachmentsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListCrossAccountResourceAccountsInput {

    static func write(value: ListCrossAccountResourceAccountsInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListCrossAccountResourcesInput {

    static func write(value: ListCrossAccountResourcesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceleratorArn"].write(value.acceleratorArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceOwnerAwsAccountId"].write(value.resourceOwnerAwsAccountId)
    }
}

extension ListCustomRoutingAcceleratorsInput {

    static func write(value: ListCustomRoutingAcceleratorsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListCustomRoutingEndpointGroupsInput {

    static func write(value: ListCustomRoutingEndpointGroupsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ListenerArn"].write(value.listenerArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListCustomRoutingListenersInput {

    static func write(value: ListCustomRoutingListenersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceleratorArn"].write(value.acceleratorArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListCustomRoutingPortMappingsInput {

    static func write(value: ListCustomRoutingPortMappingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceleratorArn"].write(value.acceleratorArn)
        try writer["EndpointGroupArn"].write(value.endpointGroupArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListCustomRoutingPortMappingsByDestinationInput {

    static func write(value: ListCustomRoutingPortMappingsByDestinationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationAddress"].write(value.destinationAddress)
        try writer["EndpointId"].write(value.endpointId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListEndpointGroupsInput {

    static func write(value: ListEndpointGroupsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ListenerArn"].write(value.listenerArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListListenersInput {

    static func write(value: ListListenersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceleratorArn"].write(value.acceleratorArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension ProvisionByoipCidrInput {

    static func write(value: ProvisionByoipCidrInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Cidr"].write(value.cidr)
        try writer["CidrAuthorizationContext"].write(value.cidrAuthorizationContext, with: GlobalAcceleratorClientTypes.CidrAuthorizationContext.write(value:to:))
    }
}

extension RemoveCustomRoutingEndpointsInput {

    static func write(value: RemoveCustomRoutingEndpointsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndpointGroupArn"].write(value.endpointGroupArn)
        try writer["EndpointIds"].writeList(value.endpointIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension RemoveEndpointsInput {

    static func write(value: RemoveEndpointsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndpointGroupArn"].write(value.endpointGroupArn)
        try writer["EndpointIdentifiers"].writeList(value.endpointIdentifiers, memberWritingClosure: GlobalAcceleratorClientTypes.EndpointIdentifier.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: GlobalAcceleratorClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateAcceleratorInput {

    static func write(value: UpdateAcceleratorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceleratorArn"].write(value.acceleratorArn)
        try writer["Enabled"].write(value.enabled)
        try writer["IpAddressType"].write(value.ipAddressType)
        try writer["IpAddresses"].writeList(value.ipAddresses, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
    }
}

extension UpdateAcceleratorAttributesInput {

    static func write(value: UpdateAcceleratorAttributesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceleratorArn"].write(value.acceleratorArn)
        try writer["FlowLogsEnabled"].write(value.flowLogsEnabled)
        try writer["FlowLogsS3Bucket"].write(value.flowLogsS3Bucket)
        try writer["FlowLogsS3Prefix"].write(value.flowLogsS3Prefix)
    }
}

extension UpdateCrossAccountAttachmentInput {

    static func write(value: UpdateCrossAccountAttachmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AddPrincipals"].writeList(value.addPrincipals, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AddResources"].writeList(value.addResources, memberWritingClosure: GlobalAcceleratorClientTypes.Resource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AttachmentArn"].write(value.attachmentArn)
        try writer["Name"].write(value.name)
        try writer["RemovePrincipals"].writeList(value.removePrincipals, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RemoveResources"].writeList(value.removeResources, memberWritingClosure: GlobalAcceleratorClientTypes.Resource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateCustomRoutingAcceleratorInput {

    static func write(value: UpdateCustomRoutingAcceleratorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceleratorArn"].write(value.acceleratorArn)
        try writer["Enabled"].write(value.enabled)
        try writer["IpAddressType"].write(value.ipAddressType)
        try writer["IpAddresses"].writeList(value.ipAddresses, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
    }
}

extension UpdateCustomRoutingAcceleratorAttributesInput {

    static func write(value: UpdateCustomRoutingAcceleratorAttributesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceleratorArn"].write(value.acceleratorArn)
        try writer["FlowLogsEnabled"].write(value.flowLogsEnabled)
        try writer["FlowLogsS3Bucket"].write(value.flowLogsS3Bucket)
        try writer["FlowLogsS3Prefix"].write(value.flowLogsS3Prefix)
    }
}

extension UpdateCustomRoutingListenerInput {

    static func write(value: UpdateCustomRoutingListenerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ListenerArn"].write(value.listenerArn)
        try writer["PortRanges"].writeList(value.portRanges, memberWritingClosure: GlobalAcceleratorClientTypes.PortRange.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateEndpointGroupInput {

    static func write(value: UpdateEndpointGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndpointConfigurations"].writeList(value.endpointConfigurations, memberWritingClosure: GlobalAcceleratorClientTypes.EndpointConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EndpointGroupArn"].write(value.endpointGroupArn)
        try writer["HealthCheckIntervalSeconds"].write(value.healthCheckIntervalSeconds)
        try writer["HealthCheckPath"].write(value.healthCheckPath)
        try writer["HealthCheckPort"].write(value.healthCheckPort)
        try writer["HealthCheckProtocol"].write(value.healthCheckProtocol)
        try writer["PortOverrides"].writeList(value.portOverrides, memberWritingClosure: GlobalAcceleratorClientTypes.PortOverride.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ThresholdCount"].write(value.thresholdCount)
        try writer["TrafficDialPercentage"].write(value.trafficDialPercentage)
    }
}

extension UpdateListenerInput {

    static func write(value: UpdateListenerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientAffinity"].write(value.clientAffinity)
        try writer["ListenerArn"].write(value.listenerArn)
        try writer["PortRanges"].writeList(value.portRanges, memberWritingClosure: GlobalAcceleratorClientTypes.PortRange.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Protocol"].write(value.`protocol`)
    }
}

extension WithdrawByoipCidrInput {

    static func write(value: WithdrawByoipCidrInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Cidr"].write(value.cidr)
    }
}

extension AddCustomRoutingEndpointsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddCustomRoutingEndpointsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AddCustomRoutingEndpointsOutput()
        value.endpointDescriptions = try reader["EndpointDescriptions"].readListIfPresent(memberReadingClosure: GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.endpointGroupArn = try reader["EndpointGroupArn"].readIfPresent()
        return value
    }
}

extension AddEndpointsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddEndpointsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AddEndpointsOutput()
        value.endpointDescriptions = try reader["EndpointDescriptions"].readListIfPresent(memberReadingClosure: GlobalAcceleratorClientTypes.EndpointDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.endpointGroupArn = try reader["EndpointGroupArn"].readIfPresent()
        return value
    }
}

extension AdvertiseByoipCidrOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AdvertiseByoipCidrOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AdvertiseByoipCidrOutput()
        value.byoipCidr = try reader["ByoipCidr"].readIfPresent(with: GlobalAcceleratorClientTypes.ByoipCidr.read(from:))
        return value
    }
}

extension AllowCustomRoutingTrafficOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AllowCustomRoutingTrafficOutput {
        return AllowCustomRoutingTrafficOutput()
    }
}

extension CreateAcceleratorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAcceleratorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAcceleratorOutput()
        value.accelerator = try reader["Accelerator"].readIfPresent(with: GlobalAcceleratorClientTypes.Accelerator.read(from:))
        return value
    }
}

extension CreateCrossAccountAttachmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCrossAccountAttachmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCrossAccountAttachmentOutput()
        value.crossAccountAttachment = try reader["CrossAccountAttachment"].readIfPresent(with: GlobalAcceleratorClientTypes.Attachment.read(from:))
        return value
    }
}

extension CreateCustomRoutingAcceleratorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCustomRoutingAcceleratorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCustomRoutingAcceleratorOutput()
        value.accelerator = try reader["Accelerator"].readIfPresent(with: GlobalAcceleratorClientTypes.CustomRoutingAccelerator.read(from:))
        return value
    }
}

extension CreateCustomRoutingEndpointGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCustomRoutingEndpointGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCustomRoutingEndpointGroupOutput()
        value.endpointGroup = try reader["EndpointGroup"].readIfPresent(with: GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup.read(from:))
        return value
    }
}

extension CreateCustomRoutingListenerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCustomRoutingListenerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCustomRoutingListenerOutput()
        value.listener = try reader["Listener"].readIfPresent(with: GlobalAcceleratorClientTypes.CustomRoutingListener.read(from:))
        return value
    }
}

extension CreateEndpointGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateEndpointGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEndpointGroupOutput()
        value.endpointGroup = try reader["EndpointGroup"].readIfPresent(with: GlobalAcceleratorClientTypes.EndpointGroup.read(from:))
        return value
    }
}

extension CreateListenerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateListenerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateListenerOutput()
        value.listener = try reader["Listener"].readIfPresent(with: GlobalAcceleratorClientTypes.Listener.read(from:))
        return value
    }
}

extension DeleteAcceleratorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAcceleratorOutput {
        return DeleteAcceleratorOutput()
    }
}

extension DeleteCrossAccountAttachmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCrossAccountAttachmentOutput {
        return DeleteCrossAccountAttachmentOutput()
    }
}

extension DeleteCustomRoutingAcceleratorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCustomRoutingAcceleratorOutput {
        return DeleteCustomRoutingAcceleratorOutput()
    }
}

extension DeleteCustomRoutingEndpointGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCustomRoutingEndpointGroupOutput {
        return DeleteCustomRoutingEndpointGroupOutput()
    }
}

extension DeleteCustomRoutingListenerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCustomRoutingListenerOutput {
        return DeleteCustomRoutingListenerOutput()
    }
}

extension DeleteEndpointGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEndpointGroupOutput {
        return DeleteEndpointGroupOutput()
    }
}

extension DeleteListenerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteListenerOutput {
        return DeleteListenerOutput()
    }
}

extension DenyCustomRoutingTrafficOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DenyCustomRoutingTrafficOutput {
        return DenyCustomRoutingTrafficOutput()
    }
}

extension DeprovisionByoipCidrOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeprovisionByoipCidrOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeprovisionByoipCidrOutput()
        value.byoipCidr = try reader["ByoipCidr"].readIfPresent(with: GlobalAcceleratorClientTypes.ByoipCidr.read(from:))
        return value
    }
}

extension DescribeAcceleratorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAcceleratorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAcceleratorOutput()
        value.accelerator = try reader["Accelerator"].readIfPresent(with: GlobalAcceleratorClientTypes.Accelerator.read(from:))
        return value
    }
}

extension DescribeAcceleratorAttributesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAcceleratorAttributesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAcceleratorAttributesOutput()
        value.acceleratorAttributes = try reader["AcceleratorAttributes"].readIfPresent(with: GlobalAcceleratorClientTypes.AcceleratorAttributes.read(from:))
        return value
    }
}

extension DescribeCrossAccountAttachmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeCrossAccountAttachmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeCrossAccountAttachmentOutput()
        value.crossAccountAttachment = try reader["CrossAccountAttachment"].readIfPresent(with: GlobalAcceleratorClientTypes.Attachment.read(from:))
        return value
    }
}

extension DescribeCustomRoutingAcceleratorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeCustomRoutingAcceleratorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeCustomRoutingAcceleratorOutput()
        value.accelerator = try reader["Accelerator"].readIfPresent(with: GlobalAcceleratorClientTypes.CustomRoutingAccelerator.read(from:))
        return value
    }
}

extension DescribeCustomRoutingAcceleratorAttributesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeCustomRoutingAcceleratorAttributesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeCustomRoutingAcceleratorAttributesOutput()
        value.acceleratorAttributes = try reader["AcceleratorAttributes"].readIfPresent(with: GlobalAcceleratorClientTypes.CustomRoutingAcceleratorAttributes.read(from:))
        return value
    }
}

extension DescribeCustomRoutingEndpointGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeCustomRoutingEndpointGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeCustomRoutingEndpointGroupOutput()
        value.endpointGroup = try reader["EndpointGroup"].readIfPresent(with: GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup.read(from:))
        return value
    }
}

extension DescribeCustomRoutingListenerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeCustomRoutingListenerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeCustomRoutingListenerOutput()
        value.listener = try reader["Listener"].readIfPresent(with: GlobalAcceleratorClientTypes.CustomRoutingListener.read(from:))
        return value
    }
}

extension DescribeEndpointGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeEndpointGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeEndpointGroupOutput()
        value.endpointGroup = try reader["EndpointGroup"].readIfPresent(with: GlobalAcceleratorClientTypes.EndpointGroup.read(from:))
        return value
    }
}

extension DescribeListenerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeListenerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeListenerOutput()
        value.listener = try reader["Listener"].readIfPresent(with: GlobalAcceleratorClientTypes.Listener.read(from:))
        return value
    }
}

extension ListAcceleratorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAcceleratorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAcceleratorsOutput()
        value.accelerators = try reader["Accelerators"].readListIfPresent(memberReadingClosure: GlobalAcceleratorClientTypes.Accelerator.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListByoipCidrsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListByoipCidrsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListByoipCidrsOutput()
        value.byoipCidrs = try reader["ByoipCidrs"].readListIfPresent(memberReadingClosure: GlobalAcceleratorClientTypes.ByoipCidr.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListCrossAccountAttachmentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCrossAccountAttachmentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCrossAccountAttachmentsOutput()
        value.crossAccountAttachments = try reader["CrossAccountAttachments"].readListIfPresent(memberReadingClosure: GlobalAcceleratorClientTypes.Attachment.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListCrossAccountResourceAccountsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCrossAccountResourceAccountsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCrossAccountResourceAccountsOutput()
        value.resourceOwnerAwsAccountIds = try reader["ResourceOwnerAwsAccountIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListCrossAccountResourcesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCrossAccountResourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCrossAccountResourcesOutput()
        value.crossAccountResources = try reader["CrossAccountResources"].readListIfPresent(memberReadingClosure: GlobalAcceleratorClientTypes.CrossAccountResource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListCustomRoutingAcceleratorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCustomRoutingAcceleratorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCustomRoutingAcceleratorsOutput()
        value.accelerators = try reader["Accelerators"].readListIfPresent(memberReadingClosure: GlobalAcceleratorClientTypes.CustomRoutingAccelerator.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListCustomRoutingEndpointGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCustomRoutingEndpointGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCustomRoutingEndpointGroupsOutput()
        value.endpointGroups = try reader["EndpointGroups"].readListIfPresent(memberReadingClosure: GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListCustomRoutingListenersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCustomRoutingListenersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCustomRoutingListenersOutput()
        value.listeners = try reader["Listeners"].readListIfPresent(memberReadingClosure: GlobalAcceleratorClientTypes.CustomRoutingListener.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListCustomRoutingPortMappingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCustomRoutingPortMappingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCustomRoutingPortMappingsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.portMappings = try reader["PortMappings"].readListIfPresent(memberReadingClosure: GlobalAcceleratorClientTypes.PortMapping.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListCustomRoutingPortMappingsByDestinationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCustomRoutingPortMappingsByDestinationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCustomRoutingPortMappingsByDestinationOutput()
        value.destinationPortMappings = try reader["DestinationPortMappings"].readListIfPresent(memberReadingClosure: GlobalAcceleratorClientTypes.DestinationPortMapping.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListEndpointGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEndpointGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEndpointGroupsOutput()
        value.endpointGroups = try reader["EndpointGroups"].readListIfPresent(memberReadingClosure: GlobalAcceleratorClientTypes.EndpointGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListListenersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListListenersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListListenersOutput()
        value.listeners = try reader["Listeners"].readListIfPresent(memberReadingClosure: GlobalAcceleratorClientTypes.Listener.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: GlobalAcceleratorClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ProvisionByoipCidrOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ProvisionByoipCidrOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ProvisionByoipCidrOutput()
        value.byoipCidr = try reader["ByoipCidr"].readIfPresent(with: GlobalAcceleratorClientTypes.ByoipCidr.read(from:))
        return value
    }
}

extension RemoveCustomRoutingEndpointsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveCustomRoutingEndpointsOutput {
        return RemoveCustomRoutingEndpointsOutput()
    }
}

extension RemoveEndpointsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveEndpointsOutput {
        return RemoveEndpointsOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateAcceleratorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAcceleratorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAcceleratorOutput()
        value.accelerator = try reader["Accelerator"].readIfPresent(with: GlobalAcceleratorClientTypes.Accelerator.read(from:))
        return value
    }
}

extension UpdateAcceleratorAttributesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAcceleratorAttributesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAcceleratorAttributesOutput()
        value.acceleratorAttributes = try reader["AcceleratorAttributes"].readIfPresent(with: GlobalAcceleratorClientTypes.AcceleratorAttributes.read(from:))
        return value
    }
}

extension UpdateCrossAccountAttachmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCrossAccountAttachmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateCrossAccountAttachmentOutput()
        value.crossAccountAttachment = try reader["CrossAccountAttachment"].readIfPresent(with: GlobalAcceleratorClientTypes.Attachment.read(from:))
        return value
    }
}

extension UpdateCustomRoutingAcceleratorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCustomRoutingAcceleratorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateCustomRoutingAcceleratorOutput()
        value.accelerator = try reader["Accelerator"].readIfPresent(with: GlobalAcceleratorClientTypes.CustomRoutingAccelerator.read(from:))
        return value
    }
}

extension UpdateCustomRoutingAcceleratorAttributesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCustomRoutingAcceleratorAttributesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateCustomRoutingAcceleratorAttributesOutput()
        value.acceleratorAttributes = try reader["AcceleratorAttributes"].readIfPresent(with: GlobalAcceleratorClientTypes.CustomRoutingAcceleratorAttributes.read(from:))
        return value
    }
}

extension UpdateCustomRoutingListenerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCustomRoutingListenerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateCustomRoutingListenerOutput()
        value.listener = try reader["Listener"].readIfPresent(with: GlobalAcceleratorClientTypes.CustomRoutingListener.read(from:))
        return value
    }
}

extension UpdateEndpointGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateEndpointGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateEndpointGroupOutput()
        value.endpointGroup = try reader["EndpointGroup"].readIfPresent(with: GlobalAcceleratorClientTypes.EndpointGroup.read(from:))
        return value
    }
}

extension UpdateListenerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateListenerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateListenerOutput()
        value.listener = try reader["Listener"].readIfPresent(with: GlobalAcceleratorClientTypes.Listener.read(from:))
        return value
    }
}

extension WithdrawByoipCidrOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> WithdrawByoipCidrOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = WithdrawByoipCidrOutput()
        value.byoipCidr = try reader["ByoipCidr"].readIfPresent(with: GlobalAcceleratorClientTypes.ByoipCidr.read(from:))
        return value
    }
}

enum AddCustomRoutingEndpointsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "EndpointAlreadyExistsException": return try EndpointAlreadyExistsException.makeError(baseError: baseError)
            case "EndpointGroupNotFoundException": return try EndpointGroupNotFoundException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AddEndpointsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EndpointGroupNotFoundException": return try EndpointGroupNotFoundException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "TransactionInProgressException": return try TransactionInProgressException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AdvertiseByoipCidrOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ByoipCidrNotFoundException": return try ByoipCidrNotFoundException.makeError(baseError: baseError)
            case "IncorrectCidrStateException": return try IncorrectCidrStateException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AllowCustomRoutingTrafficOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EndpointGroupNotFoundException": return try EndpointGroupNotFoundException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAcceleratorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "TransactionInProgressException": return try TransactionInProgressException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCrossAccountAttachmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "TransactionInProgressException": return try TransactionInProgressException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCustomRoutingAcceleratorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "TransactionInProgressException": return try TransactionInProgressException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCustomRoutingEndpointGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AcceleratorNotFoundException": return try AcceleratorNotFoundException.makeError(baseError: baseError)
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EndpointGroupAlreadyExistsException": return try EndpointGroupAlreadyExistsException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidPortRangeException": return try InvalidPortRangeException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ListenerNotFoundException": return try ListenerNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCustomRoutingListenerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AcceleratorNotFoundException": return try AcceleratorNotFoundException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidPortRangeException": return try InvalidPortRangeException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateEndpointGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AcceleratorNotFoundException": return try AcceleratorNotFoundException.makeError(baseError: baseError)
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EndpointGroupAlreadyExistsException": return try EndpointGroupAlreadyExistsException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ListenerNotFoundException": return try ListenerNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateListenerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AcceleratorNotFoundException": return try AcceleratorNotFoundException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidPortRangeException": return try InvalidPortRangeException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAcceleratorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AcceleratorNotDisabledException": return try AcceleratorNotDisabledException.makeError(baseError: baseError)
            case "AcceleratorNotFoundException": return try AcceleratorNotFoundException.makeError(baseError: baseError)
            case "AssociatedListenerFoundException": return try AssociatedListenerFoundException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "TransactionInProgressException": return try TransactionInProgressException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCrossAccountAttachmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "AttachmentNotFoundException": return try AttachmentNotFoundException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "TransactionInProgressException": return try TransactionInProgressException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCustomRoutingAcceleratorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AcceleratorNotDisabledException": return try AcceleratorNotDisabledException.makeError(baseError: baseError)
            case "AcceleratorNotFoundException": return try AcceleratorNotFoundException.makeError(baseError: baseError)
            case "AssociatedListenerFoundException": return try AssociatedListenerFoundException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "TransactionInProgressException": return try TransactionInProgressException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCustomRoutingEndpointGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EndpointGroupNotFoundException": return try EndpointGroupNotFoundException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCustomRoutingListenerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AssociatedEndpointGroupFoundException": return try AssociatedEndpointGroupFoundException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ListenerNotFoundException": return try ListenerNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEndpointGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EndpointGroupNotFoundException": return try EndpointGroupNotFoundException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteListenerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AssociatedEndpointGroupFoundException": return try AssociatedEndpointGroupFoundException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ListenerNotFoundException": return try ListenerNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DenyCustomRoutingTrafficOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EndpointGroupNotFoundException": return try EndpointGroupNotFoundException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeprovisionByoipCidrOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ByoipCidrNotFoundException": return try ByoipCidrNotFoundException.makeError(baseError: baseError)
            case "IncorrectCidrStateException": return try IncorrectCidrStateException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAcceleratorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AcceleratorNotFoundException": return try AcceleratorNotFoundException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAcceleratorAttributesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AcceleratorNotFoundException": return try AcceleratorNotFoundException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeCrossAccountAttachmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "AttachmentNotFoundException": return try AttachmentNotFoundException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeCustomRoutingAcceleratorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AcceleratorNotFoundException": return try AcceleratorNotFoundException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeCustomRoutingAcceleratorAttributesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AcceleratorNotFoundException": return try AcceleratorNotFoundException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeCustomRoutingEndpointGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EndpointGroupNotFoundException": return try EndpointGroupNotFoundException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeCustomRoutingListenerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ListenerNotFoundException": return try ListenerNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeEndpointGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EndpointGroupNotFoundException": return try EndpointGroupNotFoundException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeListenerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ListenerNotFoundException": return try ListenerNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAcceleratorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListByoipCidrsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCrossAccountAttachmentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCrossAccountResourceAccountsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCrossAccountResourcesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AcceleratorNotFoundException": return try AcceleratorNotFoundException.makeError(baseError: baseError)
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCustomRoutingAcceleratorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCustomRoutingEndpointGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "ListenerNotFoundException": return try ListenerNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCustomRoutingListenersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AcceleratorNotFoundException": return try AcceleratorNotFoundException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCustomRoutingPortMappingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AcceleratorNotFoundException": return try AcceleratorNotFoundException.makeError(baseError: baseError)
            case "EndpointGroupNotFoundException": return try EndpointGroupNotFoundException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCustomRoutingPortMappingsByDestinationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EndpointNotFoundException": return try EndpointNotFoundException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEndpointGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "ListenerNotFoundException": return try ListenerNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListListenersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AcceleratorNotFoundException": return try AcceleratorNotFoundException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AcceleratorNotFoundException": return try AcceleratorNotFoundException.makeError(baseError: baseError)
            case "AttachmentNotFoundException": return try AttachmentNotFoundException.makeError(baseError: baseError)
            case "EndpointGroupNotFoundException": return try EndpointGroupNotFoundException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ListenerNotFoundException": return try ListenerNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ProvisionByoipCidrOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IncorrectCidrStateException": return try IncorrectCidrStateException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveCustomRoutingEndpointsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "EndpointGroupNotFoundException": return try EndpointGroupNotFoundException.makeError(baseError: baseError)
            case "EndpointNotFoundException": return try EndpointNotFoundException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveEndpointsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EndpointGroupNotFoundException": return try EndpointGroupNotFoundException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "TransactionInProgressException": return try TransactionInProgressException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AcceleratorNotFoundException": return try AcceleratorNotFoundException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AcceleratorNotFoundException": return try AcceleratorNotFoundException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAcceleratorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AcceleratorNotFoundException": return try AcceleratorNotFoundException.makeError(baseError: baseError)
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "TransactionInProgressException": return try TransactionInProgressException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAcceleratorAttributesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AcceleratorNotFoundException": return try AcceleratorNotFoundException.makeError(baseError: baseError)
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "TransactionInProgressException": return try TransactionInProgressException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCrossAccountAttachmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "AttachmentNotFoundException": return try AttachmentNotFoundException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "TransactionInProgressException": return try TransactionInProgressException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCustomRoutingAcceleratorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AcceleratorNotFoundException": return try AcceleratorNotFoundException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "TransactionInProgressException": return try TransactionInProgressException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCustomRoutingAcceleratorAttributesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AcceleratorNotFoundException": return try AcceleratorNotFoundException.makeError(baseError: baseError)
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "TransactionInProgressException": return try TransactionInProgressException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCustomRoutingListenerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidPortRangeException": return try InvalidPortRangeException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ListenerNotFoundException": return try ListenerNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateEndpointGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EndpointGroupNotFoundException": return try EndpointGroupNotFoundException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateListenerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidPortRangeException": return try InvalidPortRangeException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ListenerNotFoundException": return try ListenerNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum WithdrawByoipCidrOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ByoipCidrNotFoundException": return try ByoipCidrNotFoundException.makeError(baseError: baseError)
            case "IncorrectCidrStateException": return try IncorrectCidrStateException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InvalidArgumentException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidArgumentException {
        let reader = baseError.errorBodyReader
        var value = InvalidArgumentException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServiceErrorException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServiceErrorException {
        let reader = baseError.errorBodyReader
        var value = InternalServiceErrorException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EndpointGroupNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> EndpointGroupNotFoundException {
        let reader = baseError.errorBodyReader
        var value = EndpointGroupNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EndpointAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> EndpointAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = EndpointAlreadyExistsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TransactionInProgressException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TransactionInProgressException {
        let reader = baseError.errorBodyReader
        var value = TransactionInProgressException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ByoipCidrNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ByoipCidrNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ByoipCidrNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IncorrectCidrStateException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> IncorrectCidrStateException {
        let reader = baseError.errorBodyReader
        var value = IncorrectCidrStateException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidPortRangeException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidPortRangeException {
        let reader = baseError.errorBodyReader
        var value = InvalidPortRangeException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AcceleratorNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AcceleratorNotFoundException {
        let reader = baseError.errorBodyReader
        var value = AcceleratorNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EndpointGroupAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> EndpointGroupAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = EndpointGroupAlreadyExistsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ListenerNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ListenerNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ListenerNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AcceleratorNotDisabledException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AcceleratorNotDisabledException {
        let reader = baseError.errorBodyReader
        var value = AcceleratorNotDisabledException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AssociatedListenerFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AssociatedListenerFoundException {
        let reader = baseError.errorBodyReader
        var value = AssociatedListenerFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AttachmentNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AttachmentNotFoundException {
        let reader = baseError.errorBodyReader
        var value = AttachmentNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AssociatedEndpointGroupFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AssociatedEndpointGroupFoundException {
        let reader = baseError.errorBodyReader
        var value = AssociatedEndpointGroupFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidNextTokenException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidNextTokenException {
        let reader = baseError.errorBodyReader
        var value = InvalidNextTokenException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EndpointNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> EndpointNotFoundException {
        let reader = baseError.errorBodyReader
        var value = EndpointNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription()
        value.endpointId = try reader["EndpointId"].readIfPresent()
        return value
    }
}

extension GlobalAcceleratorClientTypes.EndpointDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> GlobalAcceleratorClientTypes.EndpointDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlobalAcceleratorClientTypes.EndpointDescription()
        value.endpointId = try reader["EndpointId"].readIfPresent()
        value.weight = try reader["Weight"].readIfPresent()
        value.healthState = try reader["HealthState"].readIfPresent()
        value.healthReason = try reader["HealthReason"].readIfPresent()
        value.clientIPPreservationEnabled = try reader["ClientIPPreservationEnabled"].readIfPresent()
        return value
    }
}

extension GlobalAcceleratorClientTypes.ByoipCidr {

    static func read(from reader: SmithyJSON.Reader) throws -> GlobalAcceleratorClientTypes.ByoipCidr {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlobalAcceleratorClientTypes.ByoipCidr()
        value.cidr = try reader["Cidr"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.events = try reader["Events"].readListIfPresent(memberReadingClosure: GlobalAcceleratorClientTypes.ByoipCidrEvent.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlobalAcceleratorClientTypes.ByoipCidrEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> GlobalAcceleratorClientTypes.ByoipCidrEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlobalAcceleratorClientTypes.ByoipCidrEvent()
        value.message = try reader["Message"].readIfPresent()
        value.timestamp = try reader["Timestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GlobalAcceleratorClientTypes.Accelerator {

    static func read(from reader: SmithyJSON.Reader) throws -> GlobalAcceleratorClientTypes.Accelerator {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlobalAcceleratorClientTypes.Accelerator()
        value.acceleratorArn = try reader["AcceleratorArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.ipAddressType = try reader["IpAddressType"].readIfPresent()
        value.enabled = try reader["Enabled"].readIfPresent()
        value.ipSets = try reader["IpSets"].readListIfPresent(memberReadingClosure: GlobalAcceleratorClientTypes.IpSet.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dnsName = try reader["DnsName"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.dualStackDnsName = try reader["DualStackDnsName"].readIfPresent()
        value.events = try reader["Events"].readListIfPresent(memberReadingClosure: GlobalAcceleratorClientTypes.AcceleratorEvent.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlobalAcceleratorClientTypes.AcceleratorEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> GlobalAcceleratorClientTypes.AcceleratorEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlobalAcceleratorClientTypes.AcceleratorEvent()
        value.message = try reader["Message"].readIfPresent()
        value.timestamp = try reader["Timestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GlobalAcceleratorClientTypes.IpSet {

    static func read(from reader: SmithyJSON.Reader) throws -> GlobalAcceleratorClientTypes.IpSet {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlobalAcceleratorClientTypes.IpSet()
        value.ipFamily = try reader["IpFamily"].readIfPresent()
        value.ipAddresses = try reader["IpAddresses"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.ipAddressFamily = try reader["IpAddressFamily"].readIfPresent()
        return value
    }
}

extension GlobalAcceleratorClientTypes.Attachment {

    static func read(from reader: SmithyJSON.Reader) throws -> GlobalAcceleratorClientTypes.Attachment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlobalAcceleratorClientTypes.Attachment()
        value.attachmentArn = try reader["AttachmentArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.principals = try reader["Principals"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.resources = try reader["Resources"].readListIfPresent(memberReadingClosure: GlobalAcceleratorClientTypes.Resource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GlobalAcceleratorClientTypes.Resource {

    static func write(value: GlobalAcceleratorClientTypes.Resource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Cidr"].write(value.cidr)
        try writer["EndpointId"].write(value.endpointId)
        try writer["Region"].write(value.region)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlobalAcceleratorClientTypes.Resource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlobalAcceleratorClientTypes.Resource()
        value.endpointId = try reader["EndpointId"].readIfPresent() ?? ""
        value.cidr = try reader["Cidr"].readIfPresent()
        value.region = try reader["Region"].readIfPresent()
        return value
    }
}

extension GlobalAcceleratorClientTypes.CustomRoutingAccelerator {

    static func read(from reader: SmithyJSON.Reader) throws -> GlobalAcceleratorClientTypes.CustomRoutingAccelerator {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlobalAcceleratorClientTypes.CustomRoutingAccelerator()
        value.acceleratorArn = try reader["AcceleratorArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.ipAddressType = try reader["IpAddressType"].readIfPresent()
        value.enabled = try reader["Enabled"].readIfPresent()
        value.ipSets = try reader["IpSets"].readListIfPresent(memberReadingClosure: GlobalAcceleratorClientTypes.IpSet.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dnsName = try reader["DnsName"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup {

    static func read(from reader: SmithyJSON.Reader) throws -> GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup()
        value.endpointGroupArn = try reader["EndpointGroupArn"].readIfPresent()
        value.endpointGroupRegion = try reader["EndpointGroupRegion"].readIfPresent()
        value.destinationDescriptions = try reader["DestinationDescriptions"].readListIfPresent(memberReadingClosure: GlobalAcceleratorClientTypes.CustomRoutingDestinationDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.endpointDescriptions = try reader["EndpointDescriptions"].readListIfPresent(memberReadingClosure: GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlobalAcceleratorClientTypes.CustomRoutingDestinationDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> GlobalAcceleratorClientTypes.CustomRoutingDestinationDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlobalAcceleratorClientTypes.CustomRoutingDestinationDescription()
        value.fromPort = try reader["FromPort"].readIfPresent()
        value.toPort = try reader["ToPort"].readIfPresent()
        value.protocols = try reader["Protocols"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<GlobalAcceleratorClientTypes.ModelProtocol>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlobalAcceleratorClientTypes.CustomRoutingListener {

    static func read(from reader: SmithyJSON.Reader) throws -> GlobalAcceleratorClientTypes.CustomRoutingListener {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlobalAcceleratorClientTypes.CustomRoutingListener()
        value.listenerArn = try reader["ListenerArn"].readIfPresent()
        value.portRanges = try reader["PortRanges"].readListIfPresent(memberReadingClosure: GlobalAcceleratorClientTypes.PortRange.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlobalAcceleratorClientTypes.PortRange {

    static func write(value: GlobalAcceleratorClientTypes.PortRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FromPort"].write(value.fromPort)
        try writer["ToPort"].write(value.toPort)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlobalAcceleratorClientTypes.PortRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlobalAcceleratorClientTypes.PortRange()
        value.fromPort = try reader["FromPort"].readIfPresent()
        value.toPort = try reader["ToPort"].readIfPresent()
        return value
    }
}

extension GlobalAcceleratorClientTypes.EndpointGroup {

    static func read(from reader: SmithyJSON.Reader) throws -> GlobalAcceleratorClientTypes.EndpointGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlobalAcceleratorClientTypes.EndpointGroup()
        value.endpointGroupArn = try reader["EndpointGroupArn"].readIfPresent()
        value.endpointGroupRegion = try reader["EndpointGroupRegion"].readIfPresent()
        value.endpointDescriptions = try reader["EndpointDescriptions"].readListIfPresent(memberReadingClosure: GlobalAcceleratorClientTypes.EndpointDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.trafficDialPercentage = try reader["TrafficDialPercentage"].readIfPresent()
        value.healthCheckPort = try reader["HealthCheckPort"].readIfPresent()
        value.healthCheckProtocol = try reader["HealthCheckProtocol"].readIfPresent()
        value.healthCheckPath = try reader["HealthCheckPath"].readIfPresent()
        value.healthCheckIntervalSeconds = try reader["HealthCheckIntervalSeconds"].readIfPresent()
        value.thresholdCount = try reader["ThresholdCount"].readIfPresent()
        value.portOverrides = try reader["PortOverrides"].readListIfPresent(memberReadingClosure: GlobalAcceleratorClientTypes.PortOverride.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GlobalAcceleratorClientTypes.PortOverride {

    static func write(value: GlobalAcceleratorClientTypes.PortOverride?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndpointPort"].write(value.endpointPort)
        try writer["ListenerPort"].write(value.listenerPort)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlobalAcceleratorClientTypes.PortOverride {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlobalAcceleratorClientTypes.PortOverride()
        value.listenerPort = try reader["ListenerPort"].readIfPresent()
        value.endpointPort = try reader["EndpointPort"].readIfPresent()
        return value
    }
}

extension GlobalAcceleratorClientTypes.Listener {

    static func read(from reader: SmithyJSON.Reader) throws -> GlobalAcceleratorClientTypes.Listener {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlobalAcceleratorClientTypes.Listener()
        value.listenerArn = try reader["ListenerArn"].readIfPresent()
        value.portRanges = try reader["PortRanges"].readListIfPresent(memberReadingClosure: GlobalAcceleratorClientTypes.PortRange.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.`protocol` = try reader["Protocol"].readIfPresent()
        value.clientAffinity = try reader["ClientAffinity"].readIfPresent()
        return value
    }
}

extension GlobalAcceleratorClientTypes.AcceleratorAttributes {

    static func read(from reader: SmithyJSON.Reader) throws -> GlobalAcceleratorClientTypes.AcceleratorAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlobalAcceleratorClientTypes.AcceleratorAttributes()
        value.flowLogsEnabled = try reader["FlowLogsEnabled"].readIfPresent()
        value.flowLogsS3Bucket = try reader["FlowLogsS3Bucket"].readIfPresent()
        value.flowLogsS3Prefix = try reader["FlowLogsS3Prefix"].readIfPresent()
        return value
    }
}

extension GlobalAcceleratorClientTypes.CustomRoutingAcceleratorAttributes {

    static func read(from reader: SmithyJSON.Reader) throws -> GlobalAcceleratorClientTypes.CustomRoutingAcceleratorAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlobalAcceleratorClientTypes.CustomRoutingAcceleratorAttributes()
        value.flowLogsEnabled = try reader["FlowLogsEnabled"].readIfPresent()
        value.flowLogsS3Bucket = try reader["FlowLogsS3Bucket"].readIfPresent()
        value.flowLogsS3Prefix = try reader["FlowLogsS3Prefix"].readIfPresent()
        return value
    }
}

extension GlobalAcceleratorClientTypes.CrossAccountResource {

    static func read(from reader: SmithyJSON.Reader) throws -> GlobalAcceleratorClientTypes.CrossAccountResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlobalAcceleratorClientTypes.CrossAccountResource()
        value.endpointId = try reader["EndpointId"].readIfPresent()
        value.cidr = try reader["Cidr"].readIfPresent()
        value.attachmentArn = try reader["AttachmentArn"].readIfPresent()
        return value
    }
}

extension GlobalAcceleratorClientTypes.PortMapping {

    static func read(from reader: SmithyJSON.Reader) throws -> GlobalAcceleratorClientTypes.PortMapping {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlobalAcceleratorClientTypes.PortMapping()
        value.acceleratorPort = try reader["AcceleratorPort"].readIfPresent()
        value.endpointGroupArn = try reader["EndpointGroupArn"].readIfPresent()
        value.endpointId = try reader["EndpointId"].readIfPresent()
        value.destinationSocketAddress = try reader["DestinationSocketAddress"].readIfPresent(with: GlobalAcceleratorClientTypes.SocketAddress.read(from:))
        value.protocols = try reader["Protocols"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<GlobalAcceleratorClientTypes.CustomRoutingProtocol>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.destinationTrafficState = try reader["DestinationTrafficState"].readIfPresent()
        return value
    }
}

extension GlobalAcceleratorClientTypes.SocketAddress {

    static func read(from reader: SmithyJSON.Reader) throws -> GlobalAcceleratorClientTypes.SocketAddress {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlobalAcceleratorClientTypes.SocketAddress()
        value.ipAddress = try reader["IpAddress"].readIfPresent()
        value.port = try reader["Port"].readIfPresent()
        return value
    }
}

extension GlobalAcceleratorClientTypes.DestinationPortMapping {

    static func read(from reader: SmithyJSON.Reader) throws -> GlobalAcceleratorClientTypes.DestinationPortMapping {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlobalAcceleratorClientTypes.DestinationPortMapping()
        value.acceleratorArn = try reader["AcceleratorArn"].readIfPresent()
        value.acceleratorSocketAddresses = try reader["AcceleratorSocketAddresses"].readListIfPresent(memberReadingClosure: GlobalAcceleratorClientTypes.SocketAddress.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.endpointGroupArn = try reader["EndpointGroupArn"].readIfPresent()
        value.endpointId = try reader["EndpointId"].readIfPresent()
        value.endpointGroupRegion = try reader["EndpointGroupRegion"].readIfPresent()
        value.destinationSocketAddress = try reader["DestinationSocketAddress"].readIfPresent(with: GlobalAcceleratorClientTypes.SocketAddress.read(from:))
        value.ipAddressType = try reader["IpAddressType"].readIfPresent()
        value.destinationTrafficState = try reader["DestinationTrafficState"].readIfPresent()
        return value
    }
}

extension GlobalAcceleratorClientTypes.Tag {

    static func write(value: GlobalAcceleratorClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GlobalAcceleratorClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GlobalAcceleratorClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension GlobalAcceleratorClientTypes.CustomRoutingEndpointConfiguration {

    static func write(value: GlobalAcceleratorClientTypes.CustomRoutingEndpointConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttachmentArn"].write(value.attachmentArn)
        try writer["EndpointId"].write(value.endpointId)
    }
}

extension GlobalAcceleratorClientTypes.EndpointConfiguration {

    static func write(value: GlobalAcceleratorClientTypes.EndpointConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttachmentArn"].write(value.attachmentArn)
        try writer["ClientIPPreservationEnabled"].write(value.clientIPPreservationEnabled)
        try writer["EndpointId"].write(value.endpointId)
        try writer["Weight"].write(value.weight)
    }
}

extension GlobalAcceleratorClientTypes.CustomRoutingDestinationConfiguration {

    static func write(value: GlobalAcceleratorClientTypes.CustomRoutingDestinationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FromPort"].write(value.fromPort)
        try writer["Protocols"].writeList(value.protocols, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GlobalAcceleratorClientTypes.CustomRoutingProtocol>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ToPort"].write(value.toPort)
    }
}

extension GlobalAcceleratorClientTypes.CidrAuthorizationContext {

    static func write(value: GlobalAcceleratorClientTypes.CidrAuthorizationContext?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Message"].write(value.message)
        try writer["Signature"].write(value.signature)
    }
}

extension GlobalAcceleratorClientTypes.EndpointIdentifier {

    static func write(value: GlobalAcceleratorClientTypes.EndpointIdentifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientIPPreservationEnabled"].write(value.clientIPPreservationEnabled)
        try writer["EndpointId"].write(value.endpointId)
    }
}

public enum GlobalAcceleratorClientTypes {}
