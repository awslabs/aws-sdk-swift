// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension GlobalAcceleratorClientTypes.Accelerator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case createdTime = "CreatedTime"
        case dnsName = "DnsName"
        case dualStackDnsName = "DualStackDnsName"
        case enabled = "Enabled"
        case events = "Events"
        case ipAddressType = "IpAddressType"
        case ipSets = "IpSets"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = self.acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let dnsName = self.dnsName {
            try encodeContainer.encode(dnsName, forKey: .dnsName)
        }
        if let dualStackDnsName = self.dualStackDnsName {
            try encodeContainer.encode(dualStackDnsName, forKey: .dualStackDnsName)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for acceleratorevent0 in events {
                try eventsContainer.encode(acceleratorevent0)
            }
        }
        if let ipAddressType = self.ipAddressType {
            try encodeContainer.encode(ipAddressType.rawValue, forKey: .ipAddressType)
        }
        if let ipSets = ipSets {
            var ipSetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipSets)
            for ipset0 in ipSets {
                try ipSetsContainer.encode(ipset0)
            }
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.IpAddressType.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let ipSetsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.IpSet?].self, forKey: .ipSets)
        var ipSetsDecoded0:[GlobalAcceleratorClientTypes.IpSet]? = nil
        if let ipSetsContainer = ipSetsContainer {
            ipSetsDecoded0 = [GlobalAcceleratorClientTypes.IpSet]()
            for structure0 in ipSetsContainer {
                if let structure0 = structure0 {
                    ipSetsDecoded0?.append(structure0)
                }
            }
        }
        ipSets = ipSetsDecoded0
        let dnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dnsName)
        dnsName = dnsNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.AcceleratorStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let dualStackDnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dualStackDnsName)
        dualStackDnsName = dualStackDnsNameDecoded
        let eventsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.AcceleratorEvent?].self, forKey: .events)
        var eventsDecoded0:[GlobalAcceleratorClientTypes.AcceleratorEvent]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [GlobalAcceleratorClientTypes.AcceleratorEvent]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
    }
}

extension GlobalAcceleratorClientTypes {
    /// An accelerator is a complex type that includes one or more listeners that process inbound connections and then direct traffic to one or more endpoint groups, each of which includes endpoints, such as load balancers.
    public struct Accelerator: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the accelerator.
        public var acceleratorArn: Swift.String?
        /// The date and time that the accelerator was created.
        public var createdTime: ClientRuntime.Date?
        /// The Domain Name System (DNS) name that Global Accelerator creates that points to an accelerator's static IPv4 addresses. The naming convention for the DNS name for an accelerator is the following: A lowercase letter a, followed by a 16-bit random hex string, followed by .awsglobalaccelerator.com. For example: a1234567890abcdef.awsglobalaccelerator.com. If you have a dual-stack accelerator, you also have a second DNS name, DualStackDnsName, that points to both the A record and the AAAA record for all four static addresses for the accelerator: two IPv4 addresses and two IPv6 addresses. For more information about the default DNS name, see [ Support for DNS addressing in Global Accelerator](https://docs.aws.amazon.com/global-accelerator/latest/dg/dns-addressing-custom-domains.dns-addressing.html) in the Global Accelerator Developer Guide.
        public var dnsName: Swift.String?
        /// The Domain Name System (DNS) name that Global Accelerator creates that points to a dual-stack accelerator's four static IP addresses: two IPv4 addresses and two IPv6 addresses. The naming convention for the dual-stack DNS name is the following: A lowercase letter a, followed by a 16-bit random hex string, followed by .dualstack.awsglobalaccelerator.com. For example: a1234567890abcdef.dualstack.awsglobalaccelerator.com. Note: Global Accelerator also assigns a default DNS name, DnsName, to your accelerator that points just to the static IPv4 addresses. For more information, see [ Support for DNS addressing in Global Accelerator](https://docs.aws.amazon.com/global-accelerator/latest/dg/about-accelerators.html#about-accelerators.dns-addressing) in the Global Accelerator Developer Guide.
        public var dualStackDnsName: Swift.String?
        /// Indicates whether the accelerator is enabled. The value is true or false. The default value is true. If the value is set to true, the accelerator cannot be deleted. If set to false, accelerator can be deleted.
        public var enabled: Swift.Bool?
        /// A history of changes that you make to an accelerator in Global Accelerator.
        public var events: [GlobalAcceleratorClientTypes.AcceleratorEvent]?
        /// The IP address type that an accelerator supports. For a standard accelerator, the value can be IPV4 or DUAL_STACK.
        public var ipAddressType: GlobalAcceleratorClientTypes.IpAddressType?
        /// The static IP addresses that Global Accelerator associates with the accelerator.
        public var ipSets: [GlobalAcceleratorClientTypes.IpSet]?
        /// The date and time that the accelerator was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The name of the accelerator. The name must contain only alphanumeric characters or hyphens (-), and must not begin or end with a hyphen.
        public var name: Swift.String?
        /// Describes the deployment status of the accelerator.
        public var status: GlobalAcceleratorClientTypes.AcceleratorStatus?

        public init (
            acceleratorArn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            dnsName: Swift.String? = nil,
            dualStackDnsName: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            events: [GlobalAcceleratorClientTypes.AcceleratorEvent]? = nil,
            ipAddressType: GlobalAcceleratorClientTypes.IpAddressType? = nil,
            ipSets: [GlobalAcceleratorClientTypes.IpSet]? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: GlobalAcceleratorClientTypes.AcceleratorStatus? = nil
        )
        {
            self.acceleratorArn = acceleratorArn
            self.createdTime = createdTime
            self.dnsName = dnsName
            self.dualStackDnsName = dualStackDnsName
            self.enabled = enabled
            self.events = events
            self.ipAddressType = ipAddressType
            self.ipSets = ipSets
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.status = status
        }
    }

}

extension GlobalAcceleratorClientTypes.AcceleratorAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowLogsEnabled = "FlowLogsEnabled"
        case flowLogsS3Bucket = "FlowLogsS3Bucket"
        case flowLogsS3Prefix = "FlowLogsS3Prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowLogsEnabled = self.flowLogsEnabled {
            try encodeContainer.encode(flowLogsEnabled, forKey: .flowLogsEnabled)
        }
        if let flowLogsS3Bucket = self.flowLogsS3Bucket {
            try encodeContainer.encode(flowLogsS3Bucket, forKey: .flowLogsS3Bucket)
        }
        if let flowLogsS3Prefix = self.flowLogsS3Prefix {
            try encodeContainer.encode(flowLogsS3Prefix, forKey: .flowLogsS3Prefix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowLogsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .flowLogsEnabled)
        flowLogsEnabled = flowLogsEnabledDecoded
        let flowLogsS3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowLogsS3Bucket)
        flowLogsS3Bucket = flowLogsS3BucketDecoded
        let flowLogsS3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowLogsS3Prefix)
        flowLogsS3Prefix = flowLogsS3PrefixDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    /// Attributes of an accelerator.
    public struct AcceleratorAttributes: Swift.Equatable {
        /// Indicates whether flow logs are enabled. The default value is false. If the value is true, FlowLogsS3Bucket and FlowLogsS3Prefix must be specified. For more information, see [Flow logs](https://docs.aws.amazon.com/global-accelerator/latest/dg/monitoring-global-accelerator.flow-logs.html) in the Global Accelerator Developer Guide.
        public var flowLogsEnabled: Swift.Bool?
        /// The name of the Amazon S3 bucket for the flow logs. Attribute is required if FlowLogsEnabled is true. The bucket must exist and have a bucket policy that grants Global Accelerator permission to write to the bucket.
        public var flowLogsS3Bucket: Swift.String?
        /// The prefix for the location in the Amazon S3 bucket for the flow logs. Attribute is required if FlowLogsEnabled is true. If you specify slash (/) for the S3 bucket prefix, the log file bucket folder structure will include a double slash (//), like the following: s3-bucket_name//AWSLogs/aws_account_id
        public var flowLogsS3Prefix: Swift.String?

        public init (
            flowLogsEnabled: Swift.Bool? = nil,
            flowLogsS3Bucket: Swift.String? = nil,
            flowLogsS3Prefix: Swift.String? = nil
        )
        {
            self.flowLogsEnabled = flowLogsEnabled
            self.flowLogsS3Bucket = flowLogsS3Bucket
            self.flowLogsS3Prefix = flowLogsS3Prefix
        }
    }

}

extension GlobalAcceleratorClientTypes.AcceleratorEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .epochSeconds, forKey: .timestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timestamp)
        timestamp = timestampDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    /// A complex type that contains a Timestamp value and Message for changes that you make to an accelerator in Global Accelerator. Messages stored here provide progress or error information when you update an accelerator from IPv4 to dual-stack, or from dual-stack to IPv4. Global Accelerator stores a maximum of ten event messages.
    public struct AcceleratorEvent: Swift.Equatable {
        /// A string that contains an Event message describing changes or errors when you update an accelerator in Global Accelerator from IPv4 to dual-stack, or dual-stack to IPv4.
        public var message: Swift.String?
        /// A timestamp for when you update an accelerator in Global Accelerator from IPv4 to dual-stack, or dual-stack to IPv4.
        public var timestamp: ClientRuntime.Date?

        public init (
            message: Swift.String? = nil,
            timestamp: ClientRuntime.Date? = nil
        )
        {
            self.message = message
            self.timestamp = timestamp
        }
    }

}

extension AcceleratorNotDisabledException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AcceleratorNotDisabledExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The accelerator that you specified could not be disabled.
public struct AcceleratorNotDisabledException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AcceleratorNotDisabledExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AcceleratorNotDisabledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AcceleratorNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AcceleratorNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The accelerator that you specified doesn't exist.
public struct AcceleratorNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AcceleratorNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AcceleratorNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    public enum AcceleratorStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deployed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [AcceleratorStatus] {
            return [
                .deployed,
                .inProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deployed: return "DEPLOYED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AcceleratorStatus(rawValue: rawValue) ?? AcceleratorStatus.sdkUnknown(rawValue)
        }
    }
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You don't have access permission.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AddCustomRoutingEndpointsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointConfigurations = "EndpointConfigurations"
        case endpointGroupArn = "EndpointGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointConfigurations = endpointConfigurations {
            var endpointConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpointConfigurations)
            for customroutingendpointconfiguration0 in endpointConfigurations {
                try endpointConfigurationsContainer.encode(customroutingendpointconfiguration0)
            }
        }
        if let endpointGroupArn = self.endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
    }
}

extension AddCustomRoutingEndpointsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AddCustomRoutingEndpointsInput: Swift.Equatable {
    /// The list of endpoint objects to add to a custom routing accelerator.
    /// This member is required.
    public var endpointConfigurations: [GlobalAcceleratorClientTypes.CustomRoutingEndpointConfiguration]?
    /// The Amazon Resource Name (ARN) of the endpoint group for the custom routing endpoint.
    /// This member is required.
    public var endpointGroupArn: Swift.String?

    public init (
        endpointConfigurations: [GlobalAcceleratorClientTypes.CustomRoutingEndpointConfiguration]? = nil,
        endpointGroupArn: Swift.String? = nil
    )
    {
        self.endpointConfigurations = endpointConfigurations
        self.endpointGroupArn = endpointGroupArn
    }
}

struct AddCustomRoutingEndpointsInputBody: Swift.Equatable {
    let endpointConfigurations: [GlobalAcceleratorClientTypes.CustomRoutingEndpointConfiguration]?
    let endpointGroupArn: Swift.String?
}

extension AddCustomRoutingEndpointsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointConfigurations = "EndpointConfigurations"
        case endpointGroupArn = "EndpointGroupArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointConfigurationsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.CustomRoutingEndpointConfiguration?].self, forKey: .endpointConfigurations)
        var endpointConfigurationsDecoded0:[GlobalAcceleratorClientTypes.CustomRoutingEndpointConfiguration]? = nil
        if let endpointConfigurationsContainer = endpointConfigurationsContainer {
            endpointConfigurationsDecoded0 = [GlobalAcceleratorClientTypes.CustomRoutingEndpointConfiguration]()
            for structure0 in endpointConfigurationsContainer {
                if let structure0 = structure0 {
                    endpointConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        endpointConfigurations = endpointConfigurationsDecoded0
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
    }
}

extension AddCustomRoutingEndpointsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddCustomRoutingEndpointsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointAlreadyExistsException" : self = .endpointAlreadyExistsException(try EndpointAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointGroupNotFoundException" : self = .endpointGroupNotFoundException(try EndpointGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AddCustomRoutingEndpointsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case endpointAlreadyExistsException(EndpointAlreadyExistsException)
    case endpointGroupNotFoundException(EndpointGroupNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddCustomRoutingEndpointsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AddCustomRoutingEndpointsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpointDescriptions = output.endpointDescriptions
            self.endpointGroupArn = output.endpointGroupArn
        } else {
            self.endpointDescriptions = nil
            self.endpointGroupArn = nil
        }
    }
}

public struct AddCustomRoutingEndpointsOutputResponse: Swift.Equatable {
    /// The endpoint objects added to the custom routing accelerator.
    public var endpointDescriptions: [GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription]?
    /// The Amazon Resource Name (ARN) of the endpoint group for the custom routing endpoint.
    public var endpointGroupArn: Swift.String?

    public init (
        endpointDescriptions: [GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription]? = nil,
        endpointGroupArn: Swift.String? = nil
    )
    {
        self.endpointDescriptions = endpointDescriptions
        self.endpointGroupArn = endpointGroupArn
    }
}

struct AddCustomRoutingEndpointsOutputResponseBody: Swift.Equatable {
    let endpointDescriptions: [GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription]?
    let endpointGroupArn: Swift.String?
}

extension AddCustomRoutingEndpointsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointDescriptions = "EndpointDescriptions"
        case endpointGroupArn = "EndpointGroupArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDescriptionsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription?].self, forKey: .endpointDescriptions)
        var endpointDescriptionsDecoded0:[GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription]? = nil
        if let endpointDescriptionsContainer = endpointDescriptionsContainer {
            endpointDescriptionsDecoded0 = [GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription]()
            for structure0 in endpointDescriptionsContainer {
                if let structure0 = structure0 {
                    endpointDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        endpointDescriptions = endpointDescriptionsDecoded0
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
    }
}

extension AddEndpointsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointConfigurations = "EndpointConfigurations"
        case endpointGroupArn = "EndpointGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointConfigurations = endpointConfigurations {
            var endpointConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpointConfigurations)
            for endpointconfiguration0 in endpointConfigurations {
                try endpointConfigurationsContainer.encode(endpointconfiguration0)
            }
        }
        if let endpointGroupArn = self.endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
    }
}

extension AddEndpointsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AddEndpointsInput: Swift.Equatable {
    /// The list of endpoint objects.
    /// This member is required.
    public var endpointConfigurations: [GlobalAcceleratorClientTypes.EndpointConfiguration]?
    /// The Amazon Resource Name (ARN) of the endpoint group.
    /// This member is required.
    public var endpointGroupArn: Swift.String?

    public init (
        endpointConfigurations: [GlobalAcceleratorClientTypes.EndpointConfiguration]? = nil,
        endpointGroupArn: Swift.String? = nil
    )
    {
        self.endpointConfigurations = endpointConfigurations
        self.endpointGroupArn = endpointGroupArn
    }
}

struct AddEndpointsInputBody: Swift.Equatable {
    let endpointConfigurations: [GlobalAcceleratorClientTypes.EndpointConfiguration]?
    let endpointGroupArn: Swift.String?
}

extension AddEndpointsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointConfigurations = "EndpointConfigurations"
        case endpointGroupArn = "EndpointGroupArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointConfigurationsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.EndpointConfiguration?].self, forKey: .endpointConfigurations)
        var endpointConfigurationsDecoded0:[GlobalAcceleratorClientTypes.EndpointConfiguration]? = nil
        if let endpointConfigurationsContainer = endpointConfigurationsContainer {
            endpointConfigurationsDecoded0 = [GlobalAcceleratorClientTypes.EndpointConfiguration]()
            for structure0 in endpointConfigurationsContainer {
                if let structure0 = structure0 {
                    endpointConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        endpointConfigurations = endpointConfigurationsDecoded0
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
    }
}

extension AddEndpointsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddEndpointsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointGroupNotFoundException" : self = .endpointGroupNotFoundException(try EndpointGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TransactionInProgressException" : self = .transactionInProgressException(try TransactionInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AddEndpointsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case endpointGroupNotFoundException(EndpointGroupNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case transactionInProgressException(TransactionInProgressException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddEndpointsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AddEndpointsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpointDescriptions = output.endpointDescriptions
            self.endpointGroupArn = output.endpointGroupArn
        } else {
            self.endpointDescriptions = nil
            self.endpointGroupArn = nil
        }
    }
}

public struct AddEndpointsOutputResponse: Swift.Equatable {
    /// The list of endpoint objects.
    public var endpointDescriptions: [GlobalAcceleratorClientTypes.EndpointDescription]?
    /// The Amazon Resource Name (ARN) of the endpoint group.
    public var endpointGroupArn: Swift.String?

    public init (
        endpointDescriptions: [GlobalAcceleratorClientTypes.EndpointDescription]? = nil,
        endpointGroupArn: Swift.String? = nil
    )
    {
        self.endpointDescriptions = endpointDescriptions
        self.endpointGroupArn = endpointGroupArn
    }
}

struct AddEndpointsOutputResponseBody: Swift.Equatable {
    let endpointDescriptions: [GlobalAcceleratorClientTypes.EndpointDescription]?
    let endpointGroupArn: Swift.String?
}

extension AddEndpointsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointDescriptions = "EndpointDescriptions"
        case endpointGroupArn = "EndpointGroupArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDescriptionsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.EndpointDescription?].self, forKey: .endpointDescriptions)
        var endpointDescriptionsDecoded0:[GlobalAcceleratorClientTypes.EndpointDescription]? = nil
        if let endpointDescriptionsContainer = endpointDescriptionsContainer {
            endpointDescriptionsDecoded0 = [GlobalAcceleratorClientTypes.EndpointDescription]()
            for structure0 in endpointDescriptionsContainer {
                if let structure0 = structure0 {
                    endpointDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        endpointDescriptions = endpointDescriptionsDecoded0
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
    }
}

extension AdvertiseByoipCidrInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidr = "Cidr"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidr = self.cidr {
            try encodeContainer.encode(cidr, forKey: .cidr)
        }
    }
}

extension AdvertiseByoipCidrInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AdvertiseByoipCidrInput: Swift.Equatable {
    /// The address range, in CIDR notation. This must be the exact range that you provisioned. You can't advertise only a portion of the provisioned range.
    /// This member is required.
    public var cidr: Swift.String?

    public init (
        cidr: Swift.String? = nil
    )
    {
        self.cidr = cidr
    }
}

struct AdvertiseByoipCidrInputBody: Swift.Equatable {
    let cidr: Swift.String?
}

extension AdvertiseByoipCidrInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidr = "Cidr"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cidr)
        cidr = cidrDecoded
    }
}

extension AdvertiseByoipCidrOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AdvertiseByoipCidrOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ByoipCidrNotFoundException" : self = .byoipCidrNotFoundException(try ByoipCidrNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncorrectCidrStateException" : self = .incorrectCidrStateException(try IncorrectCidrStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AdvertiseByoipCidrOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case byoipCidrNotFoundException(ByoipCidrNotFoundException)
    case incorrectCidrStateException(IncorrectCidrStateException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AdvertiseByoipCidrOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AdvertiseByoipCidrOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.byoipCidr = output.byoipCidr
        } else {
            self.byoipCidr = nil
        }
    }
}

public struct AdvertiseByoipCidrOutputResponse: Swift.Equatable {
    /// Information about the address range.
    public var byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr?

    public init (
        byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr? = nil
    )
    {
        self.byoipCidr = byoipCidr
    }
}

struct AdvertiseByoipCidrOutputResponseBody: Swift.Equatable {
    let byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr?
}

extension AdvertiseByoipCidrOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case byoipCidr = "ByoipCidr"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let byoipCidrDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.ByoipCidr.self, forKey: .byoipCidr)
        byoipCidr = byoipCidrDecoded
    }
}

extension AllowCustomRoutingTrafficInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowAllTrafficToEndpoint = "AllowAllTrafficToEndpoint"
        case destinationAddresses = "DestinationAddresses"
        case destinationPorts = "DestinationPorts"
        case endpointGroupArn = "EndpointGroupArn"
        case endpointId = "EndpointId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowAllTrafficToEndpoint = self.allowAllTrafficToEndpoint {
            try encodeContainer.encode(allowAllTrafficToEndpoint, forKey: .allowAllTrafficToEndpoint)
        }
        if let destinationAddresses = destinationAddresses {
            var destinationAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationAddresses)
            for ipaddress0 in destinationAddresses {
                try destinationAddressesContainer.encode(ipaddress0)
            }
        }
        if let destinationPorts = destinationPorts {
            var destinationPortsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationPorts)
            for portnumber0 in destinationPorts {
                try destinationPortsContainer.encode(portnumber0)
            }
        }
        if let endpointGroupArn = self.endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
        if let endpointId = self.endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
    }
}

extension AllowCustomRoutingTrafficInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AllowCustomRoutingTrafficInput: Swift.Equatable {
    /// Indicates whether all destination IP addresses and ports for a specified VPC subnet endpoint can receive traffic from a custom routing accelerator. The value is TRUE or FALSE. When set to TRUE, all destinations in the custom routing VPC subnet can receive traffic. Note that you cannot specify destination IP addresses and ports when the value is set to TRUE. When set to FALSE (or not specified), you must specify a list of destination IP addresses that are allowed to receive traffic. A list of ports is optional. If you don't specify a list of ports, the ports that can accept traffic is the same as the ports configured for the endpoint group. The default value is FALSE.
    public var allowAllTrafficToEndpoint: Swift.Bool?
    /// A list of specific Amazon EC2 instance IP addresses (destination addresses) in a subnet that you want to allow to receive traffic. The IP addresses must be a subset of the IP addresses that you specified for the endpoint group. DestinationAddresses is required if AllowAllTrafficToEndpoint is FALSE or is not specified.
    public var destinationAddresses: [Swift.String]?
    /// A list of specific Amazon EC2 instance ports (destination ports) that you want to allow to receive traffic.
    public var destinationPorts: [Swift.Int]?
    /// The Amazon Resource Name (ARN) of the endpoint group.
    /// This member is required.
    public var endpointGroupArn: Swift.String?
    /// An ID for the endpoint. For custom routing accelerators, this is the virtual private cloud (VPC) subnet ID.
    /// This member is required.
    public var endpointId: Swift.String?

    public init (
        allowAllTrafficToEndpoint: Swift.Bool? = nil,
        destinationAddresses: [Swift.String]? = nil,
        destinationPorts: [Swift.Int]? = nil,
        endpointGroupArn: Swift.String? = nil,
        endpointId: Swift.String? = nil
    )
    {
        self.allowAllTrafficToEndpoint = allowAllTrafficToEndpoint
        self.destinationAddresses = destinationAddresses
        self.destinationPorts = destinationPorts
        self.endpointGroupArn = endpointGroupArn
        self.endpointId = endpointId
    }
}

struct AllowCustomRoutingTrafficInputBody: Swift.Equatable {
    let endpointGroupArn: Swift.String?
    let endpointId: Swift.String?
    let destinationAddresses: [Swift.String]?
    let destinationPorts: [Swift.Int]?
    let allowAllTrafficToEndpoint: Swift.Bool?
}

extension AllowCustomRoutingTrafficInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowAllTrafficToEndpoint = "AllowAllTrafficToEndpoint"
        case destinationAddresses = "DestinationAddresses"
        case destinationPorts = "DestinationPorts"
        case endpointGroupArn = "EndpointGroupArn"
        case endpointId = "EndpointId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
        let destinationAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .destinationAddresses)
        var destinationAddressesDecoded0:[Swift.String]? = nil
        if let destinationAddressesContainer = destinationAddressesContainer {
            destinationAddressesDecoded0 = [Swift.String]()
            for string0 in destinationAddressesContainer {
                if let string0 = string0 {
                    destinationAddressesDecoded0?.append(string0)
                }
            }
        }
        destinationAddresses = destinationAddressesDecoded0
        let destinationPortsContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .destinationPorts)
        var destinationPortsDecoded0:[Swift.Int]? = nil
        if let destinationPortsContainer = destinationPortsContainer {
            destinationPortsDecoded0 = [Swift.Int]()
            for integer0 in destinationPortsContainer {
                if let integer0 = integer0 {
                    destinationPortsDecoded0?.append(integer0)
                }
            }
        }
        destinationPorts = destinationPortsDecoded0
        let allowAllTrafficToEndpointDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowAllTrafficToEndpoint)
        allowAllTrafficToEndpoint = allowAllTrafficToEndpointDecoded
    }
}

extension AllowCustomRoutingTrafficOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AllowCustomRoutingTrafficOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EndpointGroupNotFoundException" : self = .endpointGroupNotFoundException(try EndpointGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AllowCustomRoutingTrafficOutputError: Swift.Error, Swift.Equatable {
    case endpointGroupNotFoundException(EndpointGroupNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AllowCustomRoutingTrafficOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AllowCustomRoutingTrafficOutputResponse: Swift.Equatable {

    public init () { }
}

extension AssociatedEndpointGroupFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AssociatedEndpointGroupFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The listener that you specified has an endpoint group associated with it. You must remove all dependent resources from a listener before you can delete it.
public struct AssociatedEndpointGroupFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AssociatedEndpointGroupFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AssociatedEndpointGroupFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AssociatedListenerFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AssociatedListenerFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The accelerator that you specified has a listener associated with it. You must remove all dependent resources from an accelerator before you can delete it.
public struct AssociatedListenerFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AssociatedListenerFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AssociatedListenerFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GlobalAcceleratorClientTypes.ByoipCidr: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidr = "Cidr"
        case events = "Events"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidr = self.cidr {
            try encodeContainer.encode(cidr, forKey: .cidr)
        }
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for byoipcidrevent0 in events {
                try eventsContainer.encode(byoipcidrevent0)
            }
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cidr)
        cidr = cidrDecoded
        let stateDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.ByoipCidrState.self, forKey: .state)
        state = stateDecoded
        let eventsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.ByoipCidrEvent?].self, forKey: .events)
        var eventsDecoded0:[GlobalAcceleratorClientTypes.ByoipCidrEvent]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [GlobalAcceleratorClientTypes.ByoipCidrEvent]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
    }
}

extension GlobalAcceleratorClientTypes {
    /// Information about an IP address range that is provisioned for use with your Amazon Web Services resources through bring your own IP address (BYOIP). The following describes each BYOIP State that your IP address range can be in.
    ///
    /// * PENDING_PROVISIONING — You’ve submitted a request to provision an IP address range but it is not yet provisioned with Global Accelerator.
    ///
    /// * READY — The address range is provisioned with Global Accelerator and can be advertised.
    ///
    /// * PENDING_ADVERTISING — You’ve submitted a request for Global Accelerator to advertise an address range but it is not yet being advertised.
    ///
    /// * ADVERTISING — The address range is being advertised by Global Accelerator.
    ///
    /// * PENDING_WITHDRAWING — You’ve submitted a request to withdraw an address range from being advertised but it is still being advertised by Global Accelerator.
    ///
    /// * PENDING_DEPROVISIONING — You’ve submitted a request to deprovision an address range from Global Accelerator but it is still provisioned.
    ///
    /// * DEPROVISIONED — The address range is deprovisioned from Global Accelerator.
    ///
    /// * FAILED_PROVISION — The request to provision the address range from Global Accelerator was not successful. Please make sure that you provide all of the correct information, and try again. If the request fails a second time, contact Amazon Web Services support.
    ///
    /// * FAILED_ADVERTISING — The request for Global Accelerator to advertise the address range was not successful. Please make sure that you provide all of the correct information, and try again. If the request fails a second time, contact Amazon Web Services support.
    ///
    /// * FAILED_WITHDRAW — The request to withdraw the address range from advertising by Global Accelerator was not successful. Please make sure that you provide all of the correct information, and try again. If the request fails a second time, contact Amazon Web Services support.
    ///
    /// * FAILED_DEPROVISION — The request to deprovision the address range from Global Accelerator was not successful. Please make sure that you provide all of the correct information, and try again. If the request fails a second time, contact Amazon Web Services support.
    public struct ByoipCidr: Swift.Equatable {
        /// The address range, in CIDR notation.
        public var cidr: Swift.String?
        /// A history of status changes for an IP address range that you bring to Global Accelerator through bring your own IP address (BYOIP).
        public var events: [GlobalAcceleratorClientTypes.ByoipCidrEvent]?
        /// The state of the address pool.
        public var state: GlobalAcceleratorClientTypes.ByoipCidrState?

        public init (
            cidr: Swift.String? = nil,
            events: [GlobalAcceleratorClientTypes.ByoipCidrEvent]? = nil,
            state: GlobalAcceleratorClientTypes.ByoipCidrState? = nil
        )
        {
            self.cidr = cidr
            self.events = events
            self.state = state
        }
    }

}

extension GlobalAcceleratorClientTypes.ByoipCidrEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .epochSeconds, forKey: .timestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timestamp)
        timestamp = timestampDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    /// A complex type that contains a Message and a Timestamp value for changes that you make in the status of an IP address range that you bring to Global Accelerator through bring your own IP address (BYOIP).
    public struct ByoipCidrEvent: Swift.Equatable {
        /// A string that contains an Event message describing changes that you make in the status of an IP address range that you bring to Global Accelerator through bring your own IP address (BYOIP).
        public var message: Swift.String?
        /// A timestamp for when you make a status change for an IP address range that you bring to Global Accelerator through bring your own IP address (BYOIP).
        public var timestamp: ClientRuntime.Date?

        public init (
            message: Swift.String? = nil,
            timestamp: ClientRuntime.Date? = nil
        )
        {
            self.message = message
            self.timestamp = timestamp
        }
    }

}

extension ByoipCidrNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ByoipCidrNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The CIDR that you specified was not found or is incorrect.
public struct ByoipCidrNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ByoipCidrNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ByoipCidrNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    public enum ByoipCidrState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case advertising
        case deprovisioned
        case failedAdvertising
        case failedDeprovision
        case failedProvision
        case failedWithdraw
        case pendingAdvertising
        case pendingDeprovisioning
        case pendingProvisioning
        case pendingWithdrawing
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [ByoipCidrState] {
            return [
                .advertising,
                .deprovisioned,
                .failedAdvertising,
                .failedDeprovision,
                .failedProvision,
                .failedWithdraw,
                .pendingAdvertising,
                .pendingDeprovisioning,
                .pendingProvisioning,
                .pendingWithdrawing,
                .ready,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .advertising: return "ADVERTISING"
            case .deprovisioned: return "DEPROVISIONED"
            case .failedAdvertising: return "FAILED_ADVERTISING"
            case .failedDeprovision: return "FAILED_DEPROVISION"
            case .failedProvision: return "FAILED_PROVISION"
            case .failedWithdraw: return "FAILED_WITHDRAW"
            case .pendingAdvertising: return "PENDING_ADVERTISING"
            case .pendingDeprovisioning: return "PENDING_DEPROVISIONING"
            case .pendingProvisioning: return "PENDING_PROVISIONING"
            case .pendingWithdrawing: return "PENDING_WITHDRAWING"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ByoipCidrState(rawValue: rawValue) ?? ByoipCidrState.sdkUnknown(rawValue)
        }
    }
}

extension GlobalAcceleratorClientTypes.CidrAuthorizationContext: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case signature = "Signature"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let signature = self.signature {
            try encodeContainer.encode(signature, forKey: .signature)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let signatureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signature)
        signature = signatureDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    /// Provides authorization for Amazon to bring a specific IP address range to a specific Amazon Web Services account using bring your own IP addresses (BYOIP). For more information, see [Bring your own IP addresses (BYOIP)](https://docs.aws.amazon.com/global-accelerator/latest/dg/using-byoip.html) in the Global Accelerator Developer Guide.
    public struct CidrAuthorizationContext: Swift.Equatable {
        /// The plain-text authorization message for the prefix and account.
        /// This member is required.
        public var message: Swift.String?
        /// The signed authorization message for the prefix and account.
        /// This member is required.
        public var signature: Swift.String?

        public init (
            message: Swift.String? = nil,
            signature: Swift.String? = nil
        )
        {
            self.message = message
            self.signature = signature
        }
    }

}

extension GlobalAcceleratorClientTypes {
    public enum ClientAffinity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case sourceIp
        case sdkUnknown(Swift.String)

        public static var allCases: [ClientAffinity] {
            return [
                .none,
                .sourceIp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .sourceIp: return "SOURCE_IP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ClientAffinity(rawValue: rawValue) ?? ClientAffinity.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You can't use both of those options.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateAcceleratorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case idempotencyToken = "IdempotencyToken"
        case ipAddressType = "IpAddressType"
        case ipAddresses = "IpAddresses"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let ipAddressType = self.ipAddressType {
            try encodeContainer.encode(ipAddressType.rawValue, forKey: .ipAddressType)
        }
        if let ipAddresses = ipAddresses {
            var ipAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipAddresses)
            for ipaddress0 in ipAddresses {
                try ipAddressesContainer.encode(ipaddress0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateAcceleratorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateAcceleratorInput: Swift.Equatable {
    /// Indicates whether an accelerator is enabled. The value is true or false. The default value is true. If the value is set to true, an accelerator cannot be deleted. If set to false, the accelerator can be deleted.
    public var enabled: Swift.Bool?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency—that is, the uniqueness—of an accelerator.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The IP address type that an accelerator supports. For a standard accelerator, the value can be IPV4 or DUAL_STACK.
    public var ipAddressType: GlobalAcceleratorClientTypes.IpAddressType?
    /// Optionally, if you've added your own IP address pool to Global Accelerator (BYOIP), you can choose an IPv4 address from your own pool to use for the accelerator's static IPv4 address when you create an accelerator. After you bring an address range to Amazon Web Services, it appears in your account as an address pool. When you create an accelerator, you can assign one IPv4 address from your range to it. Global Accelerator assigns you a second static IPv4 address from an Amazon IP address range. If you bring two IPv4 address ranges to Amazon Web Services, you can assign one IPv4 address from each range to your accelerator. This restriction is because Global Accelerator assigns each address range to a different network zone, for high availability. You can specify one or two addresses, separated by a space. Do not include the /32 suffix. Note that you can't update IP addresses for an existing accelerator. To change them, you must create a new accelerator with the new addresses. For more information, see [Bring your own IP addresses (BYOIP)](https://docs.aws.amazon.com/global-accelerator/latest/dg/using-byoip.html) in the Global Accelerator Developer Guide.
    public var ipAddresses: [Swift.String]?
    /// The name of the accelerator. The name can have a maximum of 64 characters, must contain only alphanumeric characters, periods (.), or hyphens (-), and must not begin or end with a hyphen or period.
    /// This member is required.
    public var name: Swift.String?
    /// Create tags for an accelerator. For more information, see [Tagging in Global Accelerator](https://docs.aws.amazon.com/global-accelerator/latest/dg/tagging-in-global-accelerator.html) in the Global Accelerator Developer Guide.
    public var tags: [GlobalAcceleratorClientTypes.Tag]?

    public init (
        enabled: Swift.Bool? = nil,
        idempotencyToken: Swift.String? = nil,
        ipAddressType: GlobalAcceleratorClientTypes.IpAddressType? = nil,
        ipAddresses: [Swift.String]? = nil,
        name: Swift.String? = nil,
        tags: [GlobalAcceleratorClientTypes.Tag]? = nil
    )
    {
        self.enabled = enabled
        self.idempotencyToken = idempotencyToken
        self.ipAddressType = ipAddressType
        self.ipAddresses = ipAddresses
        self.name = name
        self.tags = tags
    }
}

struct CreateAcceleratorInputBody: Swift.Equatable {
    let name: Swift.String?
    let ipAddressType: GlobalAcceleratorClientTypes.IpAddressType?
    let ipAddresses: [Swift.String]?
    let enabled: Swift.Bool?
    let idempotencyToken: Swift.String?
    let tags: [GlobalAcceleratorClientTypes.Tag]?
}

extension CreateAcceleratorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case idempotencyToken = "IdempotencyToken"
        case ipAddressType = "IpAddressType"
        case ipAddresses = "IpAddresses"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.IpAddressType.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
        let ipAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ipAddresses)
        var ipAddressesDecoded0:[Swift.String]? = nil
        if let ipAddressesContainer = ipAddressesContainer {
            ipAddressesDecoded0 = [Swift.String]()
            for string0 in ipAddressesContainer {
                if let string0 = string0 {
                    ipAddressesDecoded0?.append(string0)
                }
            }
        }
        ipAddresses = ipAddressesDecoded0
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[GlobalAcceleratorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [GlobalAcceleratorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAcceleratorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAcceleratorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateAcceleratorOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAcceleratorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateAcceleratorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accelerator = output.accelerator
        } else {
            self.accelerator = nil
        }
    }
}

public struct CreateAcceleratorOutputResponse: Swift.Equatable {
    /// The accelerator that is created by specifying a listener and the supported IP address types.
    public var accelerator: GlobalAcceleratorClientTypes.Accelerator?

    public init (
        accelerator: GlobalAcceleratorClientTypes.Accelerator? = nil
    )
    {
        self.accelerator = accelerator
    }
}

struct CreateAcceleratorOutputResponseBody: Swift.Equatable {
    let accelerator: GlobalAcceleratorClientTypes.Accelerator?
}

extension CreateAcceleratorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accelerator = "Accelerator"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.Accelerator.self, forKey: .accelerator)
        accelerator = acceleratorDecoded
    }
}

extension CreateCustomRoutingAcceleratorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case idempotencyToken = "IdempotencyToken"
        case ipAddressType = "IpAddressType"
        case ipAddresses = "IpAddresses"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let ipAddressType = self.ipAddressType {
            try encodeContainer.encode(ipAddressType.rawValue, forKey: .ipAddressType)
        }
        if let ipAddresses = ipAddresses {
            var ipAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipAddresses)
            for ipaddress0 in ipAddresses {
                try ipAddressesContainer.encode(ipaddress0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateCustomRoutingAcceleratorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateCustomRoutingAcceleratorInput: Swift.Equatable {
    /// Indicates whether an accelerator is enabled. The value is true or false. The default value is true. If the value is set to true, an accelerator cannot be deleted. If set to false, the accelerator can be deleted.
    public var enabled: Swift.Bool?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency—that is, the uniqueness—of the request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The IP address type that an accelerator supports. For a custom routing accelerator, the value must be IPV4.
    public var ipAddressType: GlobalAcceleratorClientTypes.IpAddressType?
    /// Optionally, if you've added your own IP address pool to Global Accelerator (BYOIP), you can choose an IPv4 address from your own pool to use for the accelerator's static IPv4 address when you create an accelerator. After you bring an address range to Amazon Web Services, it appears in your account as an address pool. When you create an accelerator, you can assign one IPv4 address from your range to it. Global Accelerator assigns you a second static IPv4 address from an Amazon IP address range. If you bring two IPv4 address ranges to Amazon Web Services, you can assign one IPv4 address from each range to your accelerator. This restriction is because Global Accelerator assigns each address range to a different network zone, for high availability. You can specify one or two addresses, separated by a space. Do not include the /32 suffix. Note that you can't update IP addresses for an existing accelerator. To change them, you must create a new accelerator with the new addresses. For more information, see [Bring your own IP addresses (BYOIP)](https://docs.aws.amazon.com/global-accelerator/latest/dg/using-byoip.html) in the Global Accelerator Developer Guide.
    public var ipAddresses: [Swift.String]?
    /// The name of a custom routing accelerator. The name can have a maximum of 64 characters, must contain only alphanumeric characters or hyphens (-), and must not begin or end with a hyphen.
    /// This member is required.
    public var name: Swift.String?
    /// Create tags for an accelerator. For more information, see [Tagging in Global Accelerator](https://docs.aws.amazon.com/global-accelerator/latest/dg/tagging-in-global-accelerator.html) in the Global Accelerator Developer Guide.
    public var tags: [GlobalAcceleratorClientTypes.Tag]?

    public init (
        enabled: Swift.Bool? = nil,
        idempotencyToken: Swift.String? = nil,
        ipAddressType: GlobalAcceleratorClientTypes.IpAddressType? = nil,
        ipAddresses: [Swift.String]? = nil,
        name: Swift.String? = nil,
        tags: [GlobalAcceleratorClientTypes.Tag]? = nil
    )
    {
        self.enabled = enabled
        self.idempotencyToken = idempotencyToken
        self.ipAddressType = ipAddressType
        self.ipAddresses = ipAddresses
        self.name = name
        self.tags = tags
    }
}

struct CreateCustomRoutingAcceleratorInputBody: Swift.Equatable {
    let name: Swift.String?
    let ipAddressType: GlobalAcceleratorClientTypes.IpAddressType?
    let ipAddresses: [Swift.String]?
    let enabled: Swift.Bool?
    let idempotencyToken: Swift.String?
    let tags: [GlobalAcceleratorClientTypes.Tag]?
}

extension CreateCustomRoutingAcceleratorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case idempotencyToken = "IdempotencyToken"
        case ipAddressType = "IpAddressType"
        case ipAddresses = "IpAddresses"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.IpAddressType.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
        let ipAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ipAddresses)
        var ipAddressesDecoded0:[Swift.String]? = nil
        if let ipAddressesContainer = ipAddressesContainer {
            ipAddressesDecoded0 = [Swift.String]()
            for string0 in ipAddressesContainer {
                if let string0 = string0 {
                    ipAddressesDecoded0?.append(string0)
                }
            }
        }
        ipAddresses = ipAddressesDecoded0
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[GlobalAcceleratorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [GlobalAcceleratorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateCustomRoutingAcceleratorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCustomRoutingAcceleratorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateCustomRoutingAcceleratorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCustomRoutingAcceleratorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateCustomRoutingAcceleratorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accelerator = output.accelerator
        } else {
            self.accelerator = nil
        }
    }
}

public struct CreateCustomRoutingAcceleratorOutputResponse: Swift.Equatable {
    /// The accelerator that is created.
    public var accelerator: GlobalAcceleratorClientTypes.CustomRoutingAccelerator?

    public init (
        accelerator: GlobalAcceleratorClientTypes.CustomRoutingAccelerator? = nil
    )
    {
        self.accelerator = accelerator
    }
}

struct CreateCustomRoutingAcceleratorOutputResponseBody: Swift.Equatable {
    let accelerator: GlobalAcceleratorClientTypes.CustomRoutingAccelerator?
}

extension CreateCustomRoutingAcceleratorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accelerator = "Accelerator"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CustomRoutingAccelerator.self, forKey: .accelerator)
        accelerator = acceleratorDecoded
    }
}

extension CreateCustomRoutingEndpointGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfigurations = "DestinationConfigurations"
        case endpointGroupRegion = "EndpointGroupRegion"
        case idempotencyToken = "IdempotencyToken"
        case listenerArn = "ListenerArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationConfigurations = destinationConfigurations {
            var destinationConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationConfigurations)
            for customroutingdestinationconfiguration0 in destinationConfigurations {
                try destinationConfigurationsContainer.encode(customroutingdestinationconfiguration0)
            }
        }
        if let endpointGroupRegion = self.endpointGroupRegion {
            try encodeContainer.encode(endpointGroupRegion, forKey: .endpointGroupRegion)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let listenerArn = self.listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
    }
}

extension CreateCustomRoutingEndpointGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateCustomRoutingEndpointGroupInput: Swift.Equatable {
    /// Sets the port range and protocol for all endpoints (virtual private cloud subnets) in a custom routing endpoint group to accept client traffic on.
    /// This member is required.
    public var destinationConfigurations: [GlobalAcceleratorClientTypes.CustomRoutingDestinationConfiguration]?
    /// The Amazon Web Services Region where the endpoint group is located. A listener can have only one endpoint group in a specific Region.
    /// This member is required.
    public var endpointGroupRegion: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency—that is, the uniqueness—of the request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the listener for a custom routing endpoint.
    /// This member is required.
    public var listenerArn: Swift.String?

    public init (
        destinationConfigurations: [GlobalAcceleratorClientTypes.CustomRoutingDestinationConfiguration]? = nil,
        endpointGroupRegion: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        listenerArn: Swift.String? = nil
    )
    {
        self.destinationConfigurations = destinationConfigurations
        self.endpointGroupRegion = endpointGroupRegion
        self.idempotencyToken = idempotencyToken
        self.listenerArn = listenerArn
    }
}

struct CreateCustomRoutingEndpointGroupInputBody: Swift.Equatable {
    let listenerArn: Swift.String?
    let endpointGroupRegion: Swift.String?
    let destinationConfigurations: [GlobalAcceleratorClientTypes.CustomRoutingDestinationConfiguration]?
    let idempotencyToken: Swift.String?
}

extension CreateCustomRoutingEndpointGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfigurations = "DestinationConfigurations"
        case endpointGroupRegion = "EndpointGroupRegion"
        case idempotencyToken = "IdempotencyToken"
        case listenerArn = "ListenerArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
        let endpointGroupRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupRegion)
        endpointGroupRegion = endpointGroupRegionDecoded
        let destinationConfigurationsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.CustomRoutingDestinationConfiguration?].self, forKey: .destinationConfigurations)
        var destinationConfigurationsDecoded0:[GlobalAcceleratorClientTypes.CustomRoutingDestinationConfiguration]? = nil
        if let destinationConfigurationsContainer = destinationConfigurationsContainer {
            destinationConfigurationsDecoded0 = [GlobalAcceleratorClientTypes.CustomRoutingDestinationConfiguration]()
            for structure0 in destinationConfigurationsContainer {
                if let structure0 = structure0 {
                    destinationConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        destinationConfigurations = destinationConfigurationsDecoded0
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CreateCustomRoutingEndpointGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCustomRoutingEndpointGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointGroupAlreadyExistsException" : self = .endpointGroupAlreadyExistsException(try EndpointGroupAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPortRangeException" : self = .invalidPortRangeException(try InvalidPortRangeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateCustomRoutingEndpointGroupOutputError: Swift.Error, Swift.Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case accessDeniedException(AccessDeniedException)
    case endpointGroupAlreadyExistsException(EndpointGroupAlreadyExistsException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidPortRangeException(InvalidPortRangeException)
    case limitExceededException(LimitExceededException)
    case listenerNotFoundException(ListenerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCustomRoutingEndpointGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateCustomRoutingEndpointGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpointGroup = output.endpointGroup
        } else {
            self.endpointGroup = nil
        }
    }
}

public struct CreateCustomRoutingEndpointGroupOutputResponse: Swift.Equatable {
    /// The information about the endpoint group created for a custom routing accelerator.
    public var endpointGroup: GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup?

    public init (
        endpointGroup: GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup? = nil
    )
    {
        self.endpointGroup = endpointGroup
    }
}

struct CreateCustomRoutingEndpointGroupOutputResponseBody: Swift.Equatable {
    let endpointGroup: GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup?
}

extension CreateCustomRoutingEndpointGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroup = "EndpointGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup.self, forKey: .endpointGroup)
        endpointGroup = endpointGroupDecoded
    }
}

extension CreateCustomRoutingListenerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case idempotencyToken = "IdempotencyToken"
        case portRanges = "PortRanges"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = self.acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let portRanges = portRanges {
            var portRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portRanges)
            for portrange0 in portRanges {
                try portRangesContainer.encode(portrange0)
            }
        }
    }
}

extension CreateCustomRoutingListenerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateCustomRoutingListenerInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the accelerator for a custom routing listener.
    /// This member is required.
    public var acceleratorArn: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency—that is, the uniqueness—of the request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The port range to support for connections from clients to your accelerator. Separately, you set port ranges for endpoints. For more information, see [About endpoints for custom routing accelerators](https://docs.aws.amazon.com/global-accelerator/latest/dg/about-custom-routing-endpoints.html).
    /// This member is required.
    public var portRanges: [GlobalAcceleratorClientTypes.PortRange]?

    public init (
        acceleratorArn: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        portRanges: [GlobalAcceleratorClientTypes.PortRange]? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.idempotencyToken = idempotencyToken
        self.portRanges = portRanges
    }
}

struct CreateCustomRoutingListenerInputBody: Swift.Equatable {
    let acceleratorArn: Swift.String?
    let portRanges: [GlobalAcceleratorClientTypes.PortRange]?
    let idempotencyToken: Swift.String?
}

extension CreateCustomRoutingListenerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case idempotencyToken = "IdempotencyToken"
        case portRanges = "PortRanges"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let portRangesContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.PortRange?].self, forKey: .portRanges)
        var portRangesDecoded0:[GlobalAcceleratorClientTypes.PortRange]? = nil
        if let portRangesContainer = portRangesContainer {
            portRangesDecoded0 = [GlobalAcceleratorClientTypes.PortRange]()
            for structure0 in portRangesContainer {
                if let structure0 = structure0 {
                    portRangesDecoded0?.append(structure0)
                }
            }
        }
        portRanges = portRangesDecoded0
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CreateCustomRoutingListenerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCustomRoutingListenerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPortRangeException" : self = .invalidPortRangeException(try InvalidPortRangeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateCustomRoutingListenerOutputError: Swift.Error, Swift.Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidPortRangeException(InvalidPortRangeException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCustomRoutingListenerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateCustomRoutingListenerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.listener = output.listener
        } else {
            self.listener = nil
        }
    }
}

public struct CreateCustomRoutingListenerOutputResponse: Swift.Equatable {
    /// The listener that you've created for a custom routing accelerator.
    public var listener: GlobalAcceleratorClientTypes.CustomRoutingListener?

    public init (
        listener: GlobalAcceleratorClientTypes.CustomRoutingListener? = nil
    )
    {
        self.listener = listener
    }
}

struct CreateCustomRoutingListenerOutputResponseBody: Swift.Equatable {
    let listener: GlobalAcceleratorClientTypes.CustomRoutingListener?
}

extension CreateCustomRoutingListenerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listener = "Listener"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CustomRoutingListener.self, forKey: .listener)
        listener = listenerDecoded
    }
}

extension CreateEndpointGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointConfigurations = "EndpointConfigurations"
        case endpointGroupRegion = "EndpointGroupRegion"
        case healthCheckIntervalSeconds = "HealthCheckIntervalSeconds"
        case healthCheckPath = "HealthCheckPath"
        case healthCheckPort = "HealthCheckPort"
        case healthCheckProtocol = "HealthCheckProtocol"
        case idempotencyToken = "IdempotencyToken"
        case listenerArn = "ListenerArn"
        case portOverrides = "PortOverrides"
        case thresholdCount = "ThresholdCount"
        case trafficDialPercentage = "TrafficDialPercentage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointConfigurations = endpointConfigurations {
            var endpointConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpointConfigurations)
            for endpointconfiguration0 in endpointConfigurations {
                try endpointConfigurationsContainer.encode(endpointconfiguration0)
            }
        }
        if let endpointGroupRegion = self.endpointGroupRegion {
            try encodeContainer.encode(endpointGroupRegion, forKey: .endpointGroupRegion)
        }
        if let healthCheckIntervalSeconds = self.healthCheckIntervalSeconds {
            try encodeContainer.encode(healthCheckIntervalSeconds, forKey: .healthCheckIntervalSeconds)
        }
        if let healthCheckPath = self.healthCheckPath {
            try encodeContainer.encode(healthCheckPath, forKey: .healthCheckPath)
        }
        if let healthCheckPort = self.healthCheckPort {
            try encodeContainer.encode(healthCheckPort, forKey: .healthCheckPort)
        }
        if let healthCheckProtocol = self.healthCheckProtocol {
            try encodeContainer.encode(healthCheckProtocol.rawValue, forKey: .healthCheckProtocol)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let listenerArn = self.listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
        if let portOverrides = portOverrides {
            var portOverridesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portOverrides)
            for portoverride0 in portOverrides {
                try portOverridesContainer.encode(portoverride0)
            }
        }
        if let thresholdCount = self.thresholdCount {
            try encodeContainer.encode(thresholdCount, forKey: .thresholdCount)
        }
        if let trafficDialPercentage = self.trafficDialPercentage {
            try encodeContainer.encode(trafficDialPercentage, forKey: .trafficDialPercentage)
        }
    }
}

extension CreateEndpointGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateEndpointGroupInput: Swift.Equatable {
    /// The list of endpoint objects.
    public var endpointConfigurations: [GlobalAcceleratorClientTypes.EndpointConfiguration]?
    /// The Amazon Web Services Region where the endpoint group is located. A listener can have only one endpoint group in a specific Region.
    /// This member is required.
    public var endpointGroupRegion: Swift.String?
    /// The time—10 seconds or 30 seconds—between each health check for an endpoint. The default value is 30.
    public var healthCheckIntervalSeconds: Swift.Int?
    /// If the protocol is HTTP/S, then this specifies the path that is the destination for health check targets. The default value is slash (/).
    public var healthCheckPath: Swift.String?
    /// The port that Global Accelerator uses to check the health of endpoints that are part of this endpoint group. The default port is the listener port that this endpoint group is associated with. If listener port is a list of ports, Global Accelerator uses the first port in the list.
    public var healthCheckPort: Swift.Int?
    /// The protocol that Global Accelerator uses to check the health of endpoints that are part of this endpoint group. The default value is TCP.
    public var healthCheckProtocol: GlobalAcceleratorClientTypes.HealthCheckProtocol?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency—that is, the uniqueness—of the request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerArn: Swift.String?
    /// Override specific listener ports used to route traffic to endpoints that are part of this endpoint group. For example, you can create a port override in which the listener receives user traffic on ports 80 and 443, but your accelerator routes that traffic to ports 1080 and 1443, respectively, on the endpoints. For more information, see [ Overriding listener ports](https://docs.aws.amazon.com/global-accelerator/latest/dg/about-endpoint-groups-port-override.html) in the Global Accelerator Developer Guide.
    public var portOverrides: [GlobalAcceleratorClientTypes.PortOverride]?
    /// The number of consecutive health checks required to set the state of a healthy endpoint to unhealthy, or to set an unhealthy endpoint to healthy. The default value is 3.
    public var thresholdCount: Swift.Int?
    /// The percentage of traffic to send to an Amazon Web Services Region. Additional traffic is distributed to other endpoint groups for this listener. Use this action to increase (dial up) or decrease (dial down) traffic to a specific Region. The percentage is applied to the traffic that would otherwise have been routed to the Region based on optimal routing. The default value is 100.
    public var trafficDialPercentage: Swift.Float?

    public init (
        endpointConfigurations: [GlobalAcceleratorClientTypes.EndpointConfiguration]? = nil,
        endpointGroupRegion: Swift.String? = nil,
        healthCheckIntervalSeconds: Swift.Int? = nil,
        healthCheckPath: Swift.String? = nil,
        healthCheckPort: Swift.Int? = nil,
        healthCheckProtocol: GlobalAcceleratorClientTypes.HealthCheckProtocol? = nil,
        idempotencyToken: Swift.String? = nil,
        listenerArn: Swift.String? = nil,
        portOverrides: [GlobalAcceleratorClientTypes.PortOverride]? = nil,
        thresholdCount: Swift.Int? = nil,
        trafficDialPercentage: Swift.Float? = nil
    )
    {
        self.endpointConfigurations = endpointConfigurations
        self.endpointGroupRegion = endpointGroupRegion
        self.healthCheckIntervalSeconds = healthCheckIntervalSeconds
        self.healthCheckPath = healthCheckPath
        self.healthCheckPort = healthCheckPort
        self.healthCheckProtocol = healthCheckProtocol
        self.idempotencyToken = idempotencyToken
        self.listenerArn = listenerArn
        self.portOverrides = portOverrides
        self.thresholdCount = thresholdCount
        self.trafficDialPercentage = trafficDialPercentage
    }
}

struct CreateEndpointGroupInputBody: Swift.Equatable {
    let listenerArn: Swift.String?
    let endpointGroupRegion: Swift.String?
    let endpointConfigurations: [GlobalAcceleratorClientTypes.EndpointConfiguration]?
    let trafficDialPercentage: Swift.Float?
    let healthCheckPort: Swift.Int?
    let healthCheckProtocol: GlobalAcceleratorClientTypes.HealthCheckProtocol?
    let healthCheckPath: Swift.String?
    let healthCheckIntervalSeconds: Swift.Int?
    let thresholdCount: Swift.Int?
    let idempotencyToken: Swift.String?
    let portOverrides: [GlobalAcceleratorClientTypes.PortOverride]?
}

extension CreateEndpointGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointConfigurations = "EndpointConfigurations"
        case endpointGroupRegion = "EndpointGroupRegion"
        case healthCheckIntervalSeconds = "HealthCheckIntervalSeconds"
        case healthCheckPath = "HealthCheckPath"
        case healthCheckPort = "HealthCheckPort"
        case healthCheckProtocol = "HealthCheckProtocol"
        case idempotencyToken = "IdempotencyToken"
        case listenerArn = "ListenerArn"
        case portOverrides = "PortOverrides"
        case thresholdCount = "ThresholdCount"
        case trafficDialPercentage = "TrafficDialPercentage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
        let endpointGroupRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupRegion)
        endpointGroupRegion = endpointGroupRegionDecoded
        let endpointConfigurationsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.EndpointConfiguration?].self, forKey: .endpointConfigurations)
        var endpointConfigurationsDecoded0:[GlobalAcceleratorClientTypes.EndpointConfiguration]? = nil
        if let endpointConfigurationsContainer = endpointConfigurationsContainer {
            endpointConfigurationsDecoded0 = [GlobalAcceleratorClientTypes.EndpointConfiguration]()
            for structure0 in endpointConfigurationsContainer {
                if let structure0 = structure0 {
                    endpointConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        endpointConfigurations = endpointConfigurationsDecoded0
        let trafficDialPercentageDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .trafficDialPercentage)
        trafficDialPercentage = trafficDialPercentageDecoded
        let healthCheckPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthCheckPort)
        healthCheckPort = healthCheckPortDecoded
        let healthCheckProtocolDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.HealthCheckProtocol.self, forKey: .healthCheckProtocol)
        healthCheckProtocol = healthCheckProtocolDecoded
        let healthCheckPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .healthCheckPath)
        healthCheckPath = healthCheckPathDecoded
        let healthCheckIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthCheckIntervalSeconds)
        healthCheckIntervalSeconds = healthCheckIntervalSecondsDecoded
        let thresholdCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .thresholdCount)
        thresholdCount = thresholdCountDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let portOverridesContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.PortOverride?].self, forKey: .portOverrides)
        var portOverridesDecoded0:[GlobalAcceleratorClientTypes.PortOverride]? = nil
        if let portOverridesContainer = portOverridesContainer {
            portOverridesDecoded0 = [GlobalAcceleratorClientTypes.PortOverride]()
            for structure0 in portOverridesContainer {
                if let structure0 = structure0 {
                    portOverridesDecoded0?.append(structure0)
                }
            }
        }
        portOverrides = portOverridesDecoded0
    }
}

extension CreateEndpointGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEndpointGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointGroupAlreadyExistsException" : self = .endpointGroupAlreadyExistsException(try EndpointGroupAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateEndpointGroupOutputError: Swift.Error, Swift.Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case accessDeniedException(AccessDeniedException)
    case endpointGroupAlreadyExistsException(EndpointGroupAlreadyExistsException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case listenerNotFoundException(ListenerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEndpointGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateEndpointGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpointGroup = output.endpointGroup
        } else {
            self.endpointGroup = nil
        }
    }
}

public struct CreateEndpointGroupOutputResponse: Swift.Equatable {
    /// The information about the endpoint group that was created.
    public var endpointGroup: GlobalAcceleratorClientTypes.EndpointGroup?

    public init (
        endpointGroup: GlobalAcceleratorClientTypes.EndpointGroup? = nil
    )
    {
        self.endpointGroup = endpointGroup
    }
}

struct CreateEndpointGroupOutputResponseBody: Swift.Equatable {
    let endpointGroup: GlobalAcceleratorClientTypes.EndpointGroup?
}

extension CreateEndpointGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroup = "EndpointGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.EndpointGroup.self, forKey: .endpointGroup)
        endpointGroup = endpointGroupDecoded
    }
}

extension CreateListenerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case clientAffinity = "ClientAffinity"
        case idempotencyToken = "IdempotencyToken"
        case portRanges = "PortRanges"
        case `protocol` = "Protocol"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = self.acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let clientAffinity = self.clientAffinity {
            try encodeContainer.encode(clientAffinity.rawValue, forKey: .clientAffinity)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let portRanges = portRanges {
            var portRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portRanges)
            for portrange0 in portRanges {
                try portRangesContainer.encode(portrange0)
            }
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
    }
}

extension CreateListenerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateListenerInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of your accelerator.
    /// This member is required.
    public var acceleratorArn: Swift.String?
    /// Client affinity lets you direct all requests from a user to the same endpoint, if you have stateful applications, regardless of the port and protocol of the client request. Client affinity gives you control over whether to always route each client to the same specific endpoint. Global Accelerator uses a consistent-flow hashing algorithm to choose the optimal endpoint for a connection. If client affinity is NONE, Global Accelerator uses the "five-tuple" (5-tuple) properties—source IP address, source port, destination IP address, destination port, and protocol—to select the hash value, and then chooses the best endpoint. However, with this setting, if someone uses different ports to connect to Global Accelerator, their connections might not be always routed to the same endpoint because the hash value changes. If you want a given client to always be routed to the same endpoint, set client affinity to SOURCE_IP instead. When you use the SOURCE_IP setting, Global Accelerator uses the "two-tuple" (2-tuple) properties— source (client) IP address and destination IP address—to select the hash value. The default value is NONE.
    public var clientAffinity: GlobalAcceleratorClientTypes.ClientAffinity?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency—that is, the uniqueness—of the request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The list of port ranges to support for connections from clients to your accelerator.
    /// This member is required.
    public var portRanges: [GlobalAcceleratorClientTypes.PortRange]?
    /// The protocol for connections from clients to your accelerator.
    /// This member is required.
    public var `protocol`: GlobalAcceleratorClientTypes.ModelProtocol?

    public init (
        acceleratorArn: Swift.String? = nil,
        clientAffinity: GlobalAcceleratorClientTypes.ClientAffinity? = nil,
        idempotencyToken: Swift.String? = nil,
        portRanges: [GlobalAcceleratorClientTypes.PortRange]? = nil,
        `protocol`: GlobalAcceleratorClientTypes.ModelProtocol? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.clientAffinity = clientAffinity
        self.idempotencyToken = idempotencyToken
        self.portRanges = portRanges
        self.`protocol` = `protocol`
    }
}

struct CreateListenerInputBody: Swift.Equatable {
    let acceleratorArn: Swift.String?
    let portRanges: [GlobalAcceleratorClientTypes.PortRange]?
    let `protocol`: GlobalAcceleratorClientTypes.ModelProtocol?
    let clientAffinity: GlobalAcceleratorClientTypes.ClientAffinity?
    let idempotencyToken: Swift.String?
}

extension CreateListenerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case clientAffinity = "ClientAffinity"
        case idempotencyToken = "IdempotencyToken"
        case portRanges = "PortRanges"
        case `protocol` = "Protocol"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let portRangesContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.PortRange?].self, forKey: .portRanges)
        var portRangesDecoded0:[GlobalAcceleratorClientTypes.PortRange]? = nil
        if let portRangesContainer = portRangesContainer {
            portRangesDecoded0 = [GlobalAcceleratorClientTypes.PortRange]()
            for structure0 in portRangesContainer {
                if let structure0 = structure0 {
                    portRangesDecoded0?.append(structure0)
                }
            }
        }
        portRanges = portRangesDecoded0
        let protocolDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.ModelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let clientAffinityDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.ClientAffinity.self, forKey: .clientAffinity)
        clientAffinity = clientAffinityDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CreateListenerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateListenerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPortRangeException" : self = .invalidPortRangeException(try InvalidPortRangeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateListenerOutputError: Swift.Error, Swift.Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidPortRangeException(InvalidPortRangeException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateListenerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateListenerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.listener = output.listener
        } else {
            self.listener = nil
        }
    }
}

public struct CreateListenerOutputResponse: Swift.Equatable {
    /// The listener that you've created.
    public var listener: GlobalAcceleratorClientTypes.Listener?

    public init (
        listener: GlobalAcceleratorClientTypes.Listener? = nil
    )
    {
        self.listener = listener
    }
}

struct CreateListenerOutputResponseBody: Swift.Equatable {
    let listener: GlobalAcceleratorClientTypes.Listener?
}

extension CreateListenerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listener = "Listener"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.Listener.self, forKey: .listener)
        listener = listenerDecoded
    }
}

extension GlobalAcceleratorClientTypes.CustomRoutingAccelerator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case createdTime = "CreatedTime"
        case dnsName = "DnsName"
        case enabled = "Enabled"
        case ipAddressType = "IpAddressType"
        case ipSets = "IpSets"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = self.acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let dnsName = self.dnsName {
            try encodeContainer.encode(dnsName, forKey: .dnsName)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let ipAddressType = self.ipAddressType {
            try encodeContainer.encode(ipAddressType.rawValue, forKey: .ipAddressType)
        }
        if let ipSets = ipSets {
            var ipSetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipSets)
            for ipset0 in ipSets {
                try ipSetsContainer.encode(ipset0)
            }
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.IpAddressType.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let ipSetsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.IpSet?].self, forKey: .ipSets)
        var ipSetsDecoded0:[GlobalAcceleratorClientTypes.IpSet]? = nil
        if let ipSetsContainer = ipSetsContainer {
            ipSetsDecoded0 = [GlobalAcceleratorClientTypes.IpSet]()
            for structure0 in ipSetsContainer {
                if let structure0 = structure0 {
                    ipSetsDecoded0?.append(structure0)
                }
            }
        }
        ipSets = ipSetsDecoded0
        let dnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dnsName)
        dnsName = dnsNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CustomRoutingAcceleratorStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    /// Attributes of a custom routing accelerator.
    public struct CustomRoutingAccelerator: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the custom routing accelerator.
        public var acceleratorArn: Swift.String?
        /// The date and time that the accelerator was created.
        public var createdTime: ClientRuntime.Date?
        /// The Domain Name System (DNS) name that Global Accelerator creates that points to an accelerator's static IPv4 addresses. The naming convention for the DNS name is the following: A lowercase letter a, followed by a 16-bit random hex string, followed by .awsglobalaccelerator.com. For example: a1234567890abcdef.awsglobalaccelerator.com. If you have a dual-stack accelerator, you also have a second DNS name, DualStackDnsName, that points to both the A record and the AAAA record for all four static addresses for the accelerator: two IPv4 addresses and two IPv6 addresses. For more information about the default DNS name, see [ Support for DNS addressing in Global Accelerator](https://docs.aws.amazon.com/global-accelerator/latest/dg/dns-addressing-custom-domains.dns-addressing.html) in the Global Accelerator Developer Guide.
        public var dnsName: Swift.String?
        /// Indicates whether the accelerator is enabled. The value is true or false. The default value is true. If the value is set to true, the accelerator cannot be deleted. If set to false, accelerator can be deleted.
        public var enabled: Swift.Bool?
        /// The IP address type that an accelerator supports. For a custom routing accelerator, the value must be IPV4.
        public var ipAddressType: GlobalAcceleratorClientTypes.IpAddressType?
        /// The static IP addresses that Global Accelerator associates with the accelerator.
        public var ipSets: [GlobalAcceleratorClientTypes.IpSet]?
        /// The date and time that the accelerator was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The name of the accelerator. The name must contain only alphanumeric characters or hyphens (-), and must not begin or end with a hyphen.
        public var name: Swift.String?
        /// Describes the deployment status of the accelerator.
        public var status: GlobalAcceleratorClientTypes.CustomRoutingAcceleratorStatus?

        public init (
            acceleratorArn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            dnsName: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            ipAddressType: GlobalAcceleratorClientTypes.IpAddressType? = nil,
            ipSets: [GlobalAcceleratorClientTypes.IpSet]? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: GlobalAcceleratorClientTypes.CustomRoutingAcceleratorStatus? = nil
        )
        {
            self.acceleratorArn = acceleratorArn
            self.createdTime = createdTime
            self.dnsName = dnsName
            self.enabled = enabled
            self.ipAddressType = ipAddressType
            self.ipSets = ipSets
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.status = status
        }
    }

}

extension GlobalAcceleratorClientTypes.CustomRoutingAcceleratorAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowLogsEnabled = "FlowLogsEnabled"
        case flowLogsS3Bucket = "FlowLogsS3Bucket"
        case flowLogsS3Prefix = "FlowLogsS3Prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowLogsEnabled = self.flowLogsEnabled {
            try encodeContainer.encode(flowLogsEnabled, forKey: .flowLogsEnabled)
        }
        if let flowLogsS3Bucket = self.flowLogsS3Bucket {
            try encodeContainer.encode(flowLogsS3Bucket, forKey: .flowLogsS3Bucket)
        }
        if let flowLogsS3Prefix = self.flowLogsS3Prefix {
            try encodeContainer.encode(flowLogsS3Prefix, forKey: .flowLogsS3Prefix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowLogsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .flowLogsEnabled)
        flowLogsEnabled = flowLogsEnabledDecoded
        let flowLogsS3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowLogsS3Bucket)
        flowLogsS3Bucket = flowLogsS3BucketDecoded
        let flowLogsS3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowLogsS3Prefix)
        flowLogsS3Prefix = flowLogsS3PrefixDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    /// Attributes of a custom routing accelerator.
    public struct CustomRoutingAcceleratorAttributes: Swift.Equatable {
        /// Indicates whether flow logs are enabled. The default value is false. If the value is true, FlowLogsS3Bucket and FlowLogsS3Prefix must be specified. For more information, see [Flow logs](https://docs.aws.amazon.com/global-accelerator/latest/dg/monitoring-global-accelerator.flow-logs.html) in the Global Accelerator Developer Guide.
        public var flowLogsEnabled: Swift.Bool?
        /// The name of the Amazon S3 bucket for the flow logs. Attribute is required if FlowLogsEnabled is true. The bucket must exist and have a bucket policy that grants Global Accelerator permission to write to the bucket.
        public var flowLogsS3Bucket: Swift.String?
        /// The prefix for the location in the Amazon S3 bucket for the flow logs. Attribute is required if FlowLogsEnabled is true. If you don’t specify a prefix, the flow logs are stored in the root of the bucket. If you specify slash (/) for the S3 bucket prefix, the log file bucket folder structure will include a double slash (//), like the following: DOC-EXAMPLE-BUCKET//AWSLogs/aws_account_id
        public var flowLogsS3Prefix: Swift.String?

        public init (
            flowLogsEnabled: Swift.Bool? = nil,
            flowLogsS3Bucket: Swift.String? = nil,
            flowLogsS3Prefix: Swift.String? = nil
        )
        {
            self.flowLogsEnabled = flowLogsEnabled
            self.flowLogsS3Bucket = flowLogsS3Bucket
            self.flowLogsS3Prefix = flowLogsS3Prefix
        }
    }

}

extension GlobalAcceleratorClientTypes {
    public enum CustomRoutingAcceleratorStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deployed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomRoutingAcceleratorStatus] {
            return [
                .deployed,
                .inProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deployed: return "DEPLOYED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CustomRoutingAcceleratorStatus(rawValue: rawValue) ?? CustomRoutingAcceleratorStatus.sdkUnknown(rawValue)
        }
    }
}

extension GlobalAcceleratorClientTypes.CustomRoutingDestinationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromPort = "FromPort"
        case protocols = "Protocols"
        case toPort = "ToPort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromPort = self.fromPort {
            try encodeContainer.encode(fromPort, forKey: .fromPort)
        }
        if let protocols = protocols {
            var protocolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocols)
            for customroutingprotocol0 in protocols {
                try protocolsContainer.encode(customroutingprotocol0.rawValue)
            }
        }
        if let toPort = self.toPort {
            try encodeContainer.encode(toPort, forKey: .toPort)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fromPort)
        fromPort = fromPortDecoded
        let toPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .toPort)
        toPort = toPortDecoded
        let protocolsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.CustomRoutingProtocol?].self, forKey: .protocols)
        var protocolsDecoded0:[GlobalAcceleratorClientTypes.CustomRoutingProtocol]? = nil
        if let protocolsContainer = protocolsContainer {
            protocolsDecoded0 = [GlobalAcceleratorClientTypes.CustomRoutingProtocol]()
            for enum0 in protocolsContainer {
                if let enum0 = enum0 {
                    protocolsDecoded0?.append(enum0)
                }
            }
        }
        protocols = protocolsDecoded0
    }
}

extension GlobalAcceleratorClientTypes {
    /// For a custom routing accelerator, sets the port range and protocol for all endpoints (virtual private cloud subnets) in an endpoint group to accept client traffic on.
    public struct CustomRoutingDestinationConfiguration: Swift.Equatable {
        /// The first port, inclusive, in the range of ports for the endpoint group that is associated with a custom routing accelerator.
        /// This member is required.
        public var fromPort: Swift.Int?
        /// The protocol for the endpoint group that is associated with a custom routing accelerator. The protocol can be either TCP or UDP.
        /// This member is required.
        public var protocols: [GlobalAcceleratorClientTypes.CustomRoutingProtocol]?
        /// The last port, inclusive, in the range of ports for the endpoint group that is associated with a custom routing accelerator.
        /// This member is required.
        public var toPort: Swift.Int?

        public init (
            fromPort: Swift.Int? = nil,
            protocols: [GlobalAcceleratorClientTypes.CustomRoutingProtocol]? = nil,
            toPort: Swift.Int? = nil
        )
        {
            self.fromPort = fromPort
            self.protocols = protocols
            self.toPort = toPort
        }
    }

}

extension GlobalAcceleratorClientTypes.CustomRoutingDestinationDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromPort = "FromPort"
        case protocols = "Protocols"
        case toPort = "ToPort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromPort = self.fromPort {
            try encodeContainer.encode(fromPort, forKey: .fromPort)
        }
        if let protocols = protocols {
            var protocolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocols)
            for protocol0 in protocols {
                try protocolsContainer.encode(protocol0.rawValue)
            }
        }
        if let toPort = self.toPort {
            try encodeContainer.encode(toPort, forKey: .toPort)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fromPort)
        fromPort = fromPortDecoded
        let toPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .toPort)
        toPort = toPortDecoded
        let protocolsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.ModelProtocol?].self, forKey: .protocols)
        var protocolsDecoded0:[GlobalAcceleratorClientTypes.ModelProtocol]? = nil
        if let protocolsContainer = protocolsContainer {
            protocolsDecoded0 = [GlobalAcceleratorClientTypes.ModelProtocol]()
            for enum0 in protocolsContainer {
                if let enum0 = enum0 {
                    protocolsDecoded0?.append(enum0)
                }
            }
        }
        protocols = protocolsDecoded0
    }
}

extension GlobalAcceleratorClientTypes {
    /// For a custom routing accelerator, describes the port range and protocol for all endpoints (virtual private cloud subnets) in an endpoint group to accept client traffic on.
    public struct CustomRoutingDestinationDescription: Swift.Equatable {
        /// The first port, inclusive, in the range of ports for the endpoint group that is associated with a custom routing accelerator.
        public var fromPort: Swift.Int?
        /// The protocol for the endpoint group that is associated with a custom routing accelerator. The protocol can be either TCP or UDP.
        public var protocols: [GlobalAcceleratorClientTypes.ModelProtocol]?
        /// The last port, inclusive, in the range of ports for the endpoint group that is associated with a custom routing accelerator.
        public var toPort: Swift.Int?

        public init (
            fromPort: Swift.Int? = nil,
            protocols: [GlobalAcceleratorClientTypes.ModelProtocol]? = nil,
            toPort: Swift.Int? = nil
        )
        {
            self.fromPort = fromPort
            self.protocols = protocols
            self.toPort = toPort
        }
    }

}

extension GlobalAcceleratorClientTypes {
    public enum CustomRoutingDestinationTrafficState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomRoutingDestinationTrafficState] {
            return [
                .allow,
                .deny,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allow: return "ALLOW"
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CustomRoutingDestinationTrafficState(rawValue: rawValue) ?? CustomRoutingDestinationTrafficState.sdkUnknown(rawValue)
        }
    }
}

extension GlobalAcceleratorClientTypes.CustomRoutingEndpointConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointId = "EndpointId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointId = self.endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    /// The list of endpoint objects. For custom routing, this is a list of virtual private cloud (VPC) subnet IDs.
    public struct CustomRoutingEndpointConfiguration: Swift.Equatable {
        /// An ID for the endpoint. For custom routing accelerators, this is the virtual private cloud (VPC) subnet ID.
        public var endpointId: Swift.String?

        public init (
            endpointId: Swift.String? = nil
        )
        {
            self.endpointId = endpointId
        }
    }

}

extension GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointId = "EndpointId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointId = self.endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    /// A complex type for an endpoint for a custom routing accelerator. Each endpoint group can include one or more endpoints, which are virtual private cloud (VPC) subnets.
    public struct CustomRoutingEndpointDescription: Swift.Equatable {
        /// An ID for the endpoint. For custom routing accelerators, this is the virtual private cloud (VPC) subnet ID.
        public var endpointId: Swift.String?

        public init (
            endpointId: Swift.String? = nil
        )
        {
            self.endpointId = endpointId
        }
    }

}

extension GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationDescriptions = "DestinationDescriptions"
        case endpointDescriptions = "EndpointDescriptions"
        case endpointGroupArn = "EndpointGroupArn"
        case endpointGroupRegion = "EndpointGroupRegion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationDescriptions = destinationDescriptions {
            var destinationDescriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationDescriptions)
            for customroutingdestinationdescription0 in destinationDescriptions {
                try destinationDescriptionsContainer.encode(customroutingdestinationdescription0)
            }
        }
        if let endpointDescriptions = endpointDescriptions {
            var endpointDescriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpointDescriptions)
            for customroutingendpointdescription0 in endpointDescriptions {
                try endpointDescriptionsContainer.encode(customroutingendpointdescription0)
            }
        }
        if let endpointGroupArn = self.endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
        if let endpointGroupRegion = self.endpointGroupRegion {
            try encodeContainer.encode(endpointGroupRegion, forKey: .endpointGroupRegion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
        let endpointGroupRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupRegion)
        endpointGroupRegion = endpointGroupRegionDecoded
        let destinationDescriptionsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.CustomRoutingDestinationDescription?].self, forKey: .destinationDescriptions)
        var destinationDescriptionsDecoded0:[GlobalAcceleratorClientTypes.CustomRoutingDestinationDescription]? = nil
        if let destinationDescriptionsContainer = destinationDescriptionsContainer {
            destinationDescriptionsDecoded0 = [GlobalAcceleratorClientTypes.CustomRoutingDestinationDescription]()
            for structure0 in destinationDescriptionsContainer {
                if let structure0 = structure0 {
                    destinationDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        destinationDescriptions = destinationDescriptionsDecoded0
        let endpointDescriptionsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription?].self, forKey: .endpointDescriptions)
        var endpointDescriptionsDecoded0:[GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription]? = nil
        if let endpointDescriptionsContainer = endpointDescriptionsContainer {
            endpointDescriptionsDecoded0 = [GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription]()
            for structure0 in endpointDescriptionsContainer {
                if let structure0 = structure0 {
                    endpointDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        endpointDescriptions = endpointDescriptionsDecoded0
    }
}

extension GlobalAcceleratorClientTypes {
    /// A complex type for the endpoint group for a custom routing accelerator. An Amazon Web Services Region can have only one endpoint group for a specific listener.
    public struct CustomRoutingEndpointGroup: Swift.Equatable {
        /// For a custom routing accelerator, describes the port range and protocol for all endpoints (virtual private cloud subnets) in an endpoint group to accept client traffic on.
        public var destinationDescriptions: [GlobalAcceleratorClientTypes.CustomRoutingDestinationDescription]?
        /// For a custom routing accelerator, describes the endpoints (virtual private cloud subnets) in an endpoint group to accept client traffic on.
        public var endpointDescriptions: [GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription]?
        /// The Amazon Resource Name (ARN) of the endpoint group.
        public var endpointGroupArn: Swift.String?
        /// The Amazon Web Services Region where the endpoint group is located.
        public var endpointGroupRegion: Swift.String?

        public init (
            destinationDescriptions: [GlobalAcceleratorClientTypes.CustomRoutingDestinationDescription]? = nil,
            endpointDescriptions: [GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription]? = nil,
            endpointGroupArn: Swift.String? = nil,
            endpointGroupRegion: Swift.String? = nil
        )
        {
            self.destinationDescriptions = destinationDescriptions
            self.endpointDescriptions = endpointDescriptions
            self.endpointGroupArn = endpointGroupArn
            self.endpointGroupRegion = endpointGroupRegion
        }
    }

}

extension GlobalAcceleratorClientTypes.CustomRoutingListener: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
        case portRanges = "PortRanges"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listenerArn = self.listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
        if let portRanges = portRanges {
            var portRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portRanges)
            for portrange0 in portRanges {
                try portRangesContainer.encode(portrange0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
        let portRangesContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.PortRange?].self, forKey: .portRanges)
        var portRangesDecoded0:[GlobalAcceleratorClientTypes.PortRange]? = nil
        if let portRangesContainer = portRangesContainer {
            portRangesDecoded0 = [GlobalAcceleratorClientTypes.PortRange]()
            for structure0 in portRangesContainer {
                if let structure0 = structure0 {
                    portRangesDecoded0?.append(structure0)
                }
            }
        }
        portRanges = portRangesDecoded0
    }
}

extension GlobalAcceleratorClientTypes {
    /// A complex type for a listener for a custom routing accelerator.
    public struct CustomRoutingListener: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the listener.
        public var listenerArn: Swift.String?
        /// The port range to support for connections from clients to your accelerator. Separately, you set port ranges for endpoints. For more information, see [About endpoints for custom routing accelerators](https://docs.aws.amazon.com/global-accelerator/latest/dg/about-custom-routing-endpoints.html).
        public var portRanges: [GlobalAcceleratorClientTypes.PortRange]?

        public init (
            listenerArn: Swift.String? = nil,
            portRanges: [GlobalAcceleratorClientTypes.PortRange]? = nil
        )
        {
            self.listenerArn = listenerArn
            self.portRanges = portRanges
        }
    }

}

extension GlobalAcceleratorClientTypes {
    public enum CustomRoutingProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case tcp
        case udp
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomRoutingProtocol] {
            return [
                .tcp,
                .udp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .tcp: return "TCP"
            case .udp: return "UDP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CustomRoutingProtocol(rawValue: rawValue) ?? CustomRoutingProtocol.sdkUnknown(rawValue)
        }
    }
}

extension DeleteAcceleratorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = self.acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
    }
}

extension DeleteAcceleratorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAcceleratorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of an accelerator.
    /// This member is required.
    public var acceleratorArn: Swift.String?

    public init (
        acceleratorArn: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
    }
}

struct DeleteAcceleratorInputBody: Swift.Equatable {
    let acceleratorArn: Swift.String?
}

extension DeleteAcceleratorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
    }
}

extension DeleteAcceleratorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAcceleratorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AcceleratorNotDisabledException" : self = .acceleratorNotDisabledException(try AcceleratorNotDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AssociatedListenerFoundException" : self = .associatedListenerFoundException(try AssociatedListenerFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteAcceleratorOutputError: Swift.Error, Swift.Equatable {
    case acceleratorNotDisabledException(AcceleratorNotDisabledException)
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case associatedListenerFoundException(AssociatedListenerFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAcceleratorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAcceleratorOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteCustomRoutingAcceleratorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = self.acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
    }
}

extension DeleteCustomRoutingAcceleratorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteCustomRoutingAcceleratorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the custom routing accelerator to delete.
    /// This member is required.
    public var acceleratorArn: Swift.String?

    public init (
        acceleratorArn: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
    }
}

struct DeleteCustomRoutingAcceleratorInputBody: Swift.Equatable {
    let acceleratorArn: Swift.String?
}

extension DeleteCustomRoutingAcceleratorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
    }
}

extension DeleteCustomRoutingAcceleratorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCustomRoutingAcceleratorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AcceleratorNotDisabledException" : self = .acceleratorNotDisabledException(try AcceleratorNotDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AssociatedListenerFoundException" : self = .associatedListenerFoundException(try AssociatedListenerFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteCustomRoutingAcceleratorOutputError: Swift.Error, Swift.Equatable {
    case acceleratorNotDisabledException(AcceleratorNotDisabledException)
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case associatedListenerFoundException(AssociatedListenerFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCustomRoutingAcceleratorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCustomRoutingAcceleratorOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteCustomRoutingEndpointGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointGroupArn = self.endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
    }
}

extension DeleteCustomRoutingEndpointGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteCustomRoutingEndpointGroupInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the endpoint group to delete.
    /// This member is required.
    public var endpointGroupArn: Swift.String?

    public init (
        endpointGroupArn: Swift.String? = nil
    )
    {
        self.endpointGroupArn = endpointGroupArn
    }
}

struct DeleteCustomRoutingEndpointGroupInputBody: Swift.Equatable {
    let endpointGroupArn: Swift.String?
}

extension DeleteCustomRoutingEndpointGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
    }
}

extension DeleteCustomRoutingEndpointGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCustomRoutingEndpointGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EndpointGroupNotFoundException" : self = .endpointGroupNotFoundException(try EndpointGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteCustomRoutingEndpointGroupOutputError: Swift.Error, Swift.Equatable {
    case endpointGroupNotFoundException(EndpointGroupNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCustomRoutingEndpointGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCustomRoutingEndpointGroupOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteCustomRoutingListenerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listenerArn = self.listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
    }
}

extension DeleteCustomRoutingListenerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteCustomRoutingListenerInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the listener to delete.
    /// This member is required.
    public var listenerArn: Swift.String?

    public init (
        listenerArn: Swift.String? = nil
    )
    {
        self.listenerArn = listenerArn
    }
}

struct DeleteCustomRoutingListenerInputBody: Swift.Equatable {
    let listenerArn: Swift.String?
}

extension DeleteCustomRoutingListenerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
    }
}

extension DeleteCustomRoutingListenerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCustomRoutingListenerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AssociatedEndpointGroupFoundException" : self = .associatedEndpointGroupFoundException(try AssociatedEndpointGroupFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteCustomRoutingListenerOutputError: Swift.Error, Swift.Equatable {
    case associatedEndpointGroupFoundException(AssociatedEndpointGroupFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case listenerNotFoundException(ListenerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCustomRoutingListenerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCustomRoutingListenerOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteEndpointGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointGroupArn = self.endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
    }
}

extension DeleteEndpointGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteEndpointGroupInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the endpoint group to delete.
    /// This member is required.
    public var endpointGroupArn: Swift.String?

    public init (
        endpointGroupArn: Swift.String? = nil
    )
    {
        self.endpointGroupArn = endpointGroupArn
    }
}

struct DeleteEndpointGroupInputBody: Swift.Equatable {
    let endpointGroupArn: Swift.String?
}

extension DeleteEndpointGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
    }
}

extension DeleteEndpointGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEndpointGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EndpointGroupNotFoundException" : self = .endpointGroupNotFoundException(try EndpointGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteEndpointGroupOutputError: Swift.Error, Swift.Equatable {
    case endpointGroupNotFoundException(EndpointGroupNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEndpointGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteEndpointGroupOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteListenerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listenerArn = self.listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
    }
}

extension DeleteListenerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteListenerInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerArn: Swift.String?

    public init (
        listenerArn: Swift.String? = nil
    )
    {
        self.listenerArn = listenerArn
    }
}

struct DeleteListenerInputBody: Swift.Equatable {
    let listenerArn: Swift.String?
}

extension DeleteListenerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
    }
}

extension DeleteListenerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteListenerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AssociatedEndpointGroupFoundException" : self = .associatedEndpointGroupFoundException(try AssociatedEndpointGroupFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteListenerOutputError: Swift.Error, Swift.Equatable {
    case associatedEndpointGroupFoundException(AssociatedEndpointGroupFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case listenerNotFoundException(ListenerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteListenerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteListenerOutputResponse: Swift.Equatable {

    public init () { }
}

extension DenyCustomRoutingTrafficInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case denyAllTrafficToEndpoint = "DenyAllTrafficToEndpoint"
        case destinationAddresses = "DestinationAddresses"
        case destinationPorts = "DestinationPorts"
        case endpointGroupArn = "EndpointGroupArn"
        case endpointId = "EndpointId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let denyAllTrafficToEndpoint = self.denyAllTrafficToEndpoint {
            try encodeContainer.encode(denyAllTrafficToEndpoint, forKey: .denyAllTrafficToEndpoint)
        }
        if let destinationAddresses = destinationAddresses {
            var destinationAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationAddresses)
            for ipaddress0 in destinationAddresses {
                try destinationAddressesContainer.encode(ipaddress0)
            }
        }
        if let destinationPorts = destinationPorts {
            var destinationPortsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationPorts)
            for portnumber0 in destinationPorts {
                try destinationPortsContainer.encode(portnumber0)
            }
        }
        if let endpointGroupArn = self.endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
        if let endpointId = self.endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
    }
}

extension DenyCustomRoutingTrafficInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DenyCustomRoutingTrafficInput: Swift.Equatable {
    /// Indicates whether all destination IP addresses and ports for a specified VPC subnet endpoint cannot receive traffic from a custom routing accelerator. The value is TRUE or FALSE. When set to TRUE, no destinations in the custom routing VPC subnet can receive traffic. Note that you cannot specify destination IP addresses and ports when the value is set to TRUE. When set to FALSE (or not specified), you must specify a list of destination IP addresses that cannot receive traffic. A list of ports is optional. If you don't specify a list of ports, the ports that can accept traffic is the same as the ports configured for the endpoint group. The default value is FALSE.
    public var denyAllTrafficToEndpoint: Swift.Bool?
    /// A list of specific Amazon EC2 instance IP addresses (destination addresses) in a subnet that you want to prevent from receiving traffic. The IP addresses must be a subset of the IP addresses allowed for the VPC subnet associated with the endpoint group.
    public var destinationAddresses: [Swift.String]?
    /// A list of specific Amazon EC2 instance ports (destination ports) in a subnet endpoint that you want to prevent from receiving traffic.
    public var destinationPorts: [Swift.Int]?
    /// The Amazon Resource Name (ARN) of the endpoint group.
    /// This member is required.
    public var endpointGroupArn: Swift.String?
    /// An ID for the endpoint. For custom routing accelerators, this is the virtual private cloud (VPC) subnet ID.
    /// This member is required.
    public var endpointId: Swift.String?

    public init (
        denyAllTrafficToEndpoint: Swift.Bool? = nil,
        destinationAddresses: [Swift.String]? = nil,
        destinationPorts: [Swift.Int]? = nil,
        endpointGroupArn: Swift.String? = nil,
        endpointId: Swift.String? = nil
    )
    {
        self.denyAllTrafficToEndpoint = denyAllTrafficToEndpoint
        self.destinationAddresses = destinationAddresses
        self.destinationPorts = destinationPorts
        self.endpointGroupArn = endpointGroupArn
        self.endpointId = endpointId
    }
}

struct DenyCustomRoutingTrafficInputBody: Swift.Equatable {
    let endpointGroupArn: Swift.String?
    let endpointId: Swift.String?
    let destinationAddresses: [Swift.String]?
    let destinationPorts: [Swift.Int]?
    let denyAllTrafficToEndpoint: Swift.Bool?
}

extension DenyCustomRoutingTrafficInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case denyAllTrafficToEndpoint = "DenyAllTrafficToEndpoint"
        case destinationAddresses = "DestinationAddresses"
        case destinationPorts = "DestinationPorts"
        case endpointGroupArn = "EndpointGroupArn"
        case endpointId = "EndpointId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
        let destinationAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .destinationAddresses)
        var destinationAddressesDecoded0:[Swift.String]? = nil
        if let destinationAddressesContainer = destinationAddressesContainer {
            destinationAddressesDecoded0 = [Swift.String]()
            for string0 in destinationAddressesContainer {
                if let string0 = string0 {
                    destinationAddressesDecoded0?.append(string0)
                }
            }
        }
        destinationAddresses = destinationAddressesDecoded0
        let destinationPortsContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .destinationPorts)
        var destinationPortsDecoded0:[Swift.Int]? = nil
        if let destinationPortsContainer = destinationPortsContainer {
            destinationPortsDecoded0 = [Swift.Int]()
            for integer0 in destinationPortsContainer {
                if let integer0 = integer0 {
                    destinationPortsDecoded0?.append(integer0)
                }
            }
        }
        destinationPorts = destinationPortsDecoded0
        let denyAllTrafficToEndpointDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .denyAllTrafficToEndpoint)
        denyAllTrafficToEndpoint = denyAllTrafficToEndpointDecoded
    }
}

extension DenyCustomRoutingTrafficOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DenyCustomRoutingTrafficOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EndpointGroupNotFoundException" : self = .endpointGroupNotFoundException(try EndpointGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DenyCustomRoutingTrafficOutputError: Swift.Error, Swift.Equatable {
    case endpointGroupNotFoundException(EndpointGroupNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DenyCustomRoutingTrafficOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DenyCustomRoutingTrafficOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeprovisionByoipCidrInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidr = "Cidr"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidr = self.cidr {
            try encodeContainer.encode(cidr, forKey: .cidr)
        }
    }
}

extension DeprovisionByoipCidrInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeprovisionByoipCidrInput: Swift.Equatable {
    /// The address range, in CIDR notation. The prefix must be the same prefix that you specified when you provisioned the address range.
    /// This member is required.
    public var cidr: Swift.String?

    public init (
        cidr: Swift.String? = nil
    )
    {
        self.cidr = cidr
    }
}

struct DeprovisionByoipCidrInputBody: Swift.Equatable {
    let cidr: Swift.String?
}

extension DeprovisionByoipCidrInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidr = "Cidr"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cidr)
        cidr = cidrDecoded
    }
}

extension DeprovisionByoipCidrOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeprovisionByoipCidrOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ByoipCidrNotFoundException" : self = .byoipCidrNotFoundException(try ByoipCidrNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncorrectCidrStateException" : self = .incorrectCidrStateException(try IncorrectCidrStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeprovisionByoipCidrOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case byoipCidrNotFoundException(ByoipCidrNotFoundException)
    case incorrectCidrStateException(IncorrectCidrStateException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeprovisionByoipCidrOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeprovisionByoipCidrOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.byoipCidr = output.byoipCidr
        } else {
            self.byoipCidr = nil
        }
    }
}

public struct DeprovisionByoipCidrOutputResponse: Swift.Equatable {
    /// Information about the address range.
    public var byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr?

    public init (
        byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr? = nil
    )
    {
        self.byoipCidr = byoipCidr
    }
}

struct DeprovisionByoipCidrOutputResponseBody: Swift.Equatable {
    let byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr?
}

extension DeprovisionByoipCidrOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case byoipCidr = "ByoipCidr"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let byoipCidrDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.ByoipCidr.self, forKey: .byoipCidr)
        byoipCidr = byoipCidrDecoded
    }
}

extension DescribeAcceleratorAttributesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = self.acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
    }
}

extension DescribeAcceleratorAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAcceleratorAttributesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the accelerator with the attributes that you want to describe.
    /// This member is required.
    public var acceleratorArn: Swift.String?

    public init (
        acceleratorArn: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
    }
}

struct DescribeAcceleratorAttributesInputBody: Swift.Equatable {
    let acceleratorArn: Swift.String?
}

extension DescribeAcceleratorAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
    }
}

extension DescribeAcceleratorAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAcceleratorAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeAcceleratorAttributesOutputError: Swift.Error, Swift.Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAcceleratorAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeAcceleratorAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.acceleratorAttributes = output.acceleratorAttributes
        } else {
            self.acceleratorAttributes = nil
        }
    }
}

public struct DescribeAcceleratorAttributesOutputResponse: Swift.Equatable {
    /// The attributes of the accelerator.
    public var acceleratorAttributes: GlobalAcceleratorClientTypes.AcceleratorAttributes?

    public init (
        acceleratorAttributes: GlobalAcceleratorClientTypes.AcceleratorAttributes? = nil
    )
    {
        self.acceleratorAttributes = acceleratorAttributes
    }
}

struct DescribeAcceleratorAttributesOutputResponseBody: Swift.Equatable {
    let acceleratorAttributes: GlobalAcceleratorClientTypes.AcceleratorAttributes?
}

extension DescribeAcceleratorAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorAttributes = "AcceleratorAttributes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorAttributesDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.AcceleratorAttributes.self, forKey: .acceleratorAttributes)
        acceleratorAttributes = acceleratorAttributesDecoded
    }
}

extension DescribeAcceleratorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = self.acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
    }
}

extension DescribeAcceleratorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAcceleratorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the accelerator to describe.
    /// This member is required.
    public var acceleratorArn: Swift.String?

    public init (
        acceleratorArn: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
    }
}

struct DescribeAcceleratorInputBody: Swift.Equatable {
    let acceleratorArn: Swift.String?
}

extension DescribeAcceleratorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
    }
}

extension DescribeAcceleratorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAcceleratorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeAcceleratorOutputError: Swift.Error, Swift.Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAcceleratorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeAcceleratorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accelerator = output.accelerator
        } else {
            self.accelerator = nil
        }
    }
}

public struct DescribeAcceleratorOutputResponse: Swift.Equatable {
    /// The description of the accelerator.
    public var accelerator: GlobalAcceleratorClientTypes.Accelerator?

    public init (
        accelerator: GlobalAcceleratorClientTypes.Accelerator? = nil
    )
    {
        self.accelerator = accelerator
    }
}

struct DescribeAcceleratorOutputResponseBody: Swift.Equatable {
    let accelerator: GlobalAcceleratorClientTypes.Accelerator?
}

extension DescribeAcceleratorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accelerator = "Accelerator"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.Accelerator.self, forKey: .accelerator)
        accelerator = acceleratorDecoded
    }
}

extension DescribeCustomRoutingAcceleratorAttributesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = self.acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
    }
}

extension DescribeCustomRoutingAcceleratorAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeCustomRoutingAcceleratorAttributesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the custom routing accelerator to describe the attributes for.
    /// This member is required.
    public var acceleratorArn: Swift.String?

    public init (
        acceleratorArn: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
    }
}

struct DescribeCustomRoutingAcceleratorAttributesInputBody: Swift.Equatable {
    let acceleratorArn: Swift.String?
}

extension DescribeCustomRoutingAcceleratorAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
    }
}

extension DescribeCustomRoutingAcceleratorAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCustomRoutingAcceleratorAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeCustomRoutingAcceleratorAttributesOutputError: Swift.Error, Swift.Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCustomRoutingAcceleratorAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeCustomRoutingAcceleratorAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.acceleratorAttributes = output.acceleratorAttributes
        } else {
            self.acceleratorAttributes = nil
        }
    }
}

public struct DescribeCustomRoutingAcceleratorAttributesOutputResponse: Swift.Equatable {
    /// The attributes of the custom routing accelerator.
    public var acceleratorAttributes: GlobalAcceleratorClientTypes.CustomRoutingAcceleratorAttributes?

    public init (
        acceleratorAttributes: GlobalAcceleratorClientTypes.CustomRoutingAcceleratorAttributes? = nil
    )
    {
        self.acceleratorAttributes = acceleratorAttributes
    }
}

struct DescribeCustomRoutingAcceleratorAttributesOutputResponseBody: Swift.Equatable {
    let acceleratorAttributes: GlobalAcceleratorClientTypes.CustomRoutingAcceleratorAttributes?
}

extension DescribeCustomRoutingAcceleratorAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorAttributes = "AcceleratorAttributes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorAttributesDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CustomRoutingAcceleratorAttributes.self, forKey: .acceleratorAttributes)
        acceleratorAttributes = acceleratorAttributesDecoded
    }
}

extension DescribeCustomRoutingAcceleratorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = self.acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
    }
}

extension DescribeCustomRoutingAcceleratorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeCustomRoutingAcceleratorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the accelerator to describe.
    /// This member is required.
    public var acceleratorArn: Swift.String?

    public init (
        acceleratorArn: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
    }
}

struct DescribeCustomRoutingAcceleratorInputBody: Swift.Equatable {
    let acceleratorArn: Swift.String?
}

extension DescribeCustomRoutingAcceleratorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
    }
}

extension DescribeCustomRoutingAcceleratorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCustomRoutingAcceleratorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeCustomRoutingAcceleratorOutputError: Swift.Error, Swift.Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCustomRoutingAcceleratorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeCustomRoutingAcceleratorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accelerator = output.accelerator
        } else {
            self.accelerator = nil
        }
    }
}

public struct DescribeCustomRoutingAcceleratorOutputResponse: Swift.Equatable {
    /// The description of the custom routing accelerator.
    public var accelerator: GlobalAcceleratorClientTypes.CustomRoutingAccelerator?

    public init (
        accelerator: GlobalAcceleratorClientTypes.CustomRoutingAccelerator? = nil
    )
    {
        self.accelerator = accelerator
    }
}

struct DescribeCustomRoutingAcceleratorOutputResponseBody: Swift.Equatable {
    let accelerator: GlobalAcceleratorClientTypes.CustomRoutingAccelerator?
}

extension DescribeCustomRoutingAcceleratorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accelerator = "Accelerator"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CustomRoutingAccelerator.self, forKey: .accelerator)
        accelerator = acceleratorDecoded
    }
}

extension DescribeCustomRoutingEndpointGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointGroupArn = self.endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
    }
}

extension DescribeCustomRoutingEndpointGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeCustomRoutingEndpointGroupInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the endpoint group to describe.
    /// This member is required.
    public var endpointGroupArn: Swift.String?

    public init (
        endpointGroupArn: Swift.String? = nil
    )
    {
        self.endpointGroupArn = endpointGroupArn
    }
}

struct DescribeCustomRoutingEndpointGroupInputBody: Swift.Equatable {
    let endpointGroupArn: Swift.String?
}

extension DescribeCustomRoutingEndpointGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
    }
}

extension DescribeCustomRoutingEndpointGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCustomRoutingEndpointGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EndpointGroupNotFoundException" : self = .endpointGroupNotFoundException(try EndpointGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeCustomRoutingEndpointGroupOutputError: Swift.Error, Swift.Equatable {
    case endpointGroupNotFoundException(EndpointGroupNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCustomRoutingEndpointGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeCustomRoutingEndpointGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpointGroup = output.endpointGroup
        } else {
            self.endpointGroup = nil
        }
    }
}

public struct DescribeCustomRoutingEndpointGroupOutputResponse: Swift.Equatable {
    /// The description of an endpoint group for a custom routing accelerator.
    public var endpointGroup: GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup?

    public init (
        endpointGroup: GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup? = nil
    )
    {
        self.endpointGroup = endpointGroup
    }
}

struct DescribeCustomRoutingEndpointGroupOutputResponseBody: Swift.Equatable {
    let endpointGroup: GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup?
}

extension DescribeCustomRoutingEndpointGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroup = "EndpointGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup.self, forKey: .endpointGroup)
        endpointGroup = endpointGroupDecoded
    }
}

extension DescribeCustomRoutingListenerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listenerArn = self.listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
    }
}

extension DescribeCustomRoutingListenerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeCustomRoutingListenerInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the listener to describe.
    /// This member is required.
    public var listenerArn: Swift.String?

    public init (
        listenerArn: Swift.String? = nil
    )
    {
        self.listenerArn = listenerArn
    }
}

struct DescribeCustomRoutingListenerInputBody: Swift.Equatable {
    let listenerArn: Swift.String?
}

extension DescribeCustomRoutingListenerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
    }
}

extension DescribeCustomRoutingListenerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCustomRoutingListenerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeCustomRoutingListenerOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case listenerNotFoundException(ListenerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCustomRoutingListenerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeCustomRoutingListenerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.listener = output.listener
        } else {
            self.listener = nil
        }
    }
}

public struct DescribeCustomRoutingListenerOutputResponse: Swift.Equatable {
    /// The description of a listener for a custom routing accelerator.
    public var listener: GlobalAcceleratorClientTypes.CustomRoutingListener?

    public init (
        listener: GlobalAcceleratorClientTypes.CustomRoutingListener? = nil
    )
    {
        self.listener = listener
    }
}

struct DescribeCustomRoutingListenerOutputResponseBody: Swift.Equatable {
    let listener: GlobalAcceleratorClientTypes.CustomRoutingListener?
}

extension DescribeCustomRoutingListenerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listener = "Listener"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CustomRoutingListener.self, forKey: .listener)
        listener = listenerDecoded
    }
}

extension DescribeEndpointGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointGroupArn = self.endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
    }
}

extension DescribeEndpointGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEndpointGroupInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the endpoint group to describe.
    /// This member is required.
    public var endpointGroupArn: Swift.String?

    public init (
        endpointGroupArn: Swift.String? = nil
    )
    {
        self.endpointGroupArn = endpointGroupArn
    }
}

struct DescribeEndpointGroupInputBody: Swift.Equatable {
    let endpointGroupArn: Swift.String?
}

extension DescribeEndpointGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
    }
}

extension DescribeEndpointGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEndpointGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EndpointGroupNotFoundException" : self = .endpointGroupNotFoundException(try EndpointGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeEndpointGroupOutputError: Swift.Error, Swift.Equatable {
    case endpointGroupNotFoundException(EndpointGroupNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEndpointGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeEndpointGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpointGroup = output.endpointGroup
        } else {
            self.endpointGroup = nil
        }
    }
}

public struct DescribeEndpointGroupOutputResponse: Swift.Equatable {
    /// The description of an endpoint group.
    public var endpointGroup: GlobalAcceleratorClientTypes.EndpointGroup?

    public init (
        endpointGroup: GlobalAcceleratorClientTypes.EndpointGroup? = nil
    )
    {
        self.endpointGroup = endpointGroup
    }
}

struct DescribeEndpointGroupOutputResponseBody: Swift.Equatable {
    let endpointGroup: GlobalAcceleratorClientTypes.EndpointGroup?
}

extension DescribeEndpointGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroup = "EndpointGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.EndpointGroup.self, forKey: .endpointGroup)
        endpointGroup = endpointGroupDecoded
    }
}

extension DescribeListenerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listenerArn = self.listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
    }
}

extension DescribeListenerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeListenerInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the listener to describe.
    /// This member is required.
    public var listenerArn: Swift.String?

    public init (
        listenerArn: Swift.String? = nil
    )
    {
        self.listenerArn = listenerArn
    }
}

struct DescribeListenerInputBody: Swift.Equatable {
    let listenerArn: Swift.String?
}

extension DescribeListenerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
    }
}

extension DescribeListenerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeListenerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeListenerOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case listenerNotFoundException(ListenerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeListenerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeListenerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.listener = output.listener
        } else {
            self.listener = nil
        }
    }
}

public struct DescribeListenerOutputResponse: Swift.Equatable {
    /// The description of a listener.
    public var listener: GlobalAcceleratorClientTypes.Listener?

    public init (
        listener: GlobalAcceleratorClientTypes.Listener? = nil
    )
    {
        self.listener = listener
    }
}

struct DescribeListenerOutputResponseBody: Swift.Equatable {
    let listener: GlobalAcceleratorClientTypes.Listener?
}

extension DescribeListenerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listener = "Listener"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.Listener.self, forKey: .listener)
        listener = listenerDecoded
    }
}

extension GlobalAcceleratorClientTypes.DestinationPortMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case acceleratorSocketAddresses = "AcceleratorSocketAddresses"
        case destinationSocketAddress = "DestinationSocketAddress"
        case destinationTrafficState = "DestinationTrafficState"
        case endpointGroupArn = "EndpointGroupArn"
        case endpointGroupRegion = "EndpointGroupRegion"
        case endpointId = "EndpointId"
        case ipAddressType = "IpAddressType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = self.acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let acceleratorSocketAddresses = acceleratorSocketAddresses {
            var acceleratorSocketAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .acceleratorSocketAddresses)
            for socketaddress0 in acceleratorSocketAddresses {
                try acceleratorSocketAddressesContainer.encode(socketaddress0)
            }
        }
        if let destinationSocketAddress = self.destinationSocketAddress {
            try encodeContainer.encode(destinationSocketAddress, forKey: .destinationSocketAddress)
        }
        if let destinationTrafficState = self.destinationTrafficState {
            try encodeContainer.encode(destinationTrafficState.rawValue, forKey: .destinationTrafficState)
        }
        if let endpointGroupArn = self.endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
        if let endpointGroupRegion = self.endpointGroupRegion {
            try encodeContainer.encode(endpointGroupRegion, forKey: .endpointGroupRegion)
        }
        if let endpointId = self.endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
        if let ipAddressType = self.ipAddressType {
            try encodeContainer.encode(ipAddressType.rawValue, forKey: .ipAddressType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let acceleratorSocketAddressesContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.SocketAddress?].self, forKey: .acceleratorSocketAddresses)
        var acceleratorSocketAddressesDecoded0:[GlobalAcceleratorClientTypes.SocketAddress]? = nil
        if let acceleratorSocketAddressesContainer = acceleratorSocketAddressesContainer {
            acceleratorSocketAddressesDecoded0 = [GlobalAcceleratorClientTypes.SocketAddress]()
            for structure0 in acceleratorSocketAddressesContainer {
                if let structure0 = structure0 {
                    acceleratorSocketAddressesDecoded0?.append(structure0)
                }
            }
        }
        acceleratorSocketAddresses = acceleratorSocketAddressesDecoded0
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
        let endpointGroupRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupRegion)
        endpointGroupRegion = endpointGroupRegionDecoded
        let destinationSocketAddressDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.SocketAddress.self, forKey: .destinationSocketAddress)
        destinationSocketAddress = destinationSocketAddressDecoded
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.IpAddressType.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
        let destinationTrafficStateDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CustomRoutingDestinationTrafficState.self, forKey: .destinationTrafficState)
        destinationTrafficState = destinationTrafficStateDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    /// The port mappings for a specified endpoint IP address (destination).
    public struct DestinationPortMapping: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the custom routing accelerator that you have port mappings for.
        public var acceleratorArn: Swift.String?
        /// The IP address/port combinations (sockets) that map to a given destination socket address.
        public var acceleratorSocketAddresses: [GlobalAcceleratorClientTypes.SocketAddress]?
        /// The endpoint IP address/port combination for traffic received on the accelerator socket address.
        public var destinationSocketAddress: GlobalAcceleratorClientTypes.SocketAddress?
        /// Indicates whether or not a port mapping destination can receive traffic. The value is either ALLOW, if traffic is allowed to the destination, or DENY, if traffic is not allowed to the destination.
        public var destinationTrafficState: GlobalAcceleratorClientTypes.CustomRoutingDestinationTrafficState?
        /// The Amazon Resource Name (ARN) of the endpoint group.
        public var endpointGroupArn: Swift.String?
        /// The Amazon Web Services Region for the endpoint group.
        public var endpointGroupRegion: Swift.String?
        /// The ID for the virtual private cloud (VPC) subnet.
        public var endpointId: Swift.String?
        /// The IP address type that an accelerator supports. For a custom routing accelerator, the value must be IPV4.
        public var ipAddressType: GlobalAcceleratorClientTypes.IpAddressType?

        public init (
            acceleratorArn: Swift.String? = nil,
            acceleratorSocketAddresses: [GlobalAcceleratorClientTypes.SocketAddress]? = nil,
            destinationSocketAddress: GlobalAcceleratorClientTypes.SocketAddress? = nil,
            destinationTrafficState: GlobalAcceleratorClientTypes.CustomRoutingDestinationTrafficState? = nil,
            endpointGroupArn: Swift.String? = nil,
            endpointGroupRegion: Swift.String? = nil,
            endpointId: Swift.String? = nil,
            ipAddressType: GlobalAcceleratorClientTypes.IpAddressType? = nil
        )
        {
            self.acceleratorArn = acceleratorArn
            self.acceleratorSocketAddresses = acceleratorSocketAddresses
            self.destinationSocketAddress = destinationSocketAddress
            self.destinationTrafficState = destinationTrafficState
            self.endpointGroupArn = endpointGroupArn
            self.endpointGroupRegion = endpointGroupRegion
            self.endpointId = endpointId
            self.ipAddressType = ipAddressType
        }
    }

}

extension EndpointAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: EndpointAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The endpoint that you specified doesn't exist.
public struct EndpointAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EndpointAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EndpointAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GlobalAcceleratorClientTypes.EndpointConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientIPPreservationEnabled = "ClientIPPreservationEnabled"
        case endpointId = "EndpointId"
        case weight = "Weight"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientIPPreservationEnabled = self.clientIPPreservationEnabled {
            try encodeContainer.encode(clientIPPreservationEnabled, forKey: .clientIPPreservationEnabled)
        }
        if let endpointId = self.endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
        if let weight = self.weight {
            try encodeContainer.encode(weight, forKey: .weight)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
        let weightDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .weight)
        weight = weightDecoded
        let clientIPPreservationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .clientIPPreservationEnabled)
        clientIPPreservationEnabled = clientIPPreservationEnabledDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    /// A complex type for endpoints. A resource must be valid and active when you add it as an endpoint.
    public struct EndpointConfiguration: Swift.Equatable {
        /// Indicates whether client IP address preservation is enabled for an endpoint. The value is true or false. The default value is true for new accelerators. If the value is set to true, the client's IP address is preserved in the X-Forwarded-For request header as traffic travels to applications on the endpoint fronted by the accelerator. Client IP address preservation is supported, in specific Amazon Web Services Regions, for endpoints that are Application Load Balancers and Amazon EC2 instances. For more information, see [ Preserve client IP addresses in Global Accelerator](https://docs.aws.amazon.com/global-accelerator/latest/dg/preserve-client-ip-address.html) in the Global Accelerator Developer Guide.
        public var clientIPPreservationEnabled: Swift.Bool?
        /// An ID for the endpoint. If the endpoint is a Network Load Balancer or Application Load Balancer, this is the Amazon Resource Name (ARN) of the resource. If the endpoint is an Elastic IP address, this is the Elastic IP address allocation ID. For Amazon EC2 instances, this is the EC2 instance ID. A resource must be valid and active when you add it as an endpoint. An Application Load Balancer can be either internal or internet-facing.
        public var endpointId: Swift.String?
        /// The weight associated with the endpoint. When you add weights to endpoints, you configure Global Accelerator to route traffic based on proportions that you specify. For example, you might specify endpoint weights of 4, 5, 5, and 6 (sum=20). The result is that 4/20 of your traffic, on average, is routed to the first endpoint, 5/20 is routed both to the second and third endpoints, and 6/20 is routed to the last endpoint. For more information, see [Endpoint weights](https://docs.aws.amazon.com/global-accelerator/latest/dg/about-endpoints-endpoint-weights.html) in the Global Accelerator Developer Guide.
        public var weight: Swift.Int?

        public init (
            clientIPPreservationEnabled: Swift.Bool? = nil,
            endpointId: Swift.String? = nil,
            weight: Swift.Int? = nil
        )
        {
            self.clientIPPreservationEnabled = clientIPPreservationEnabled
            self.endpointId = endpointId
            self.weight = weight
        }
    }

}

extension GlobalAcceleratorClientTypes.EndpointDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientIPPreservationEnabled = "ClientIPPreservationEnabled"
        case endpointId = "EndpointId"
        case healthReason = "HealthReason"
        case healthState = "HealthState"
        case weight = "Weight"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientIPPreservationEnabled = self.clientIPPreservationEnabled {
            try encodeContainer.encode(clientIPPreservationEnabled, forKey: .clientIPPreservationEnabled)
        }
        if let endpointId = self.endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
        if let healthReason = self.healthReason {
            try encodeContainer.encode(healthReason, forKey: .healthReason)
        }
        if let healthState = self.healthState {
            try encodeContainer.encode(healthState.rawValue, forKey: .healthState)
        }
        if let weight = self.weight {
            try encodeContainer.encode(weight, forKey: .weight)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
        let weightDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .weight)
        weight = weightDecoded
        let healthStateDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.HealthState.self, forKey: .healthState)
        healthState = healthStateDecoded
        let healthReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .healthReason)
        healthReason = healthReasonDecoded
        let clientIPPreservationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .clientIPPreservationEnabled)
        clientIPPreservationEnabled = clientIPPreservationEnabledDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    /// A complex type for an endpoint. Each endpoint group can include one or more endpoints, such as load balancers.
    public struct EndpointDescription: Swift.Equatable {
        /// Indicates whether client IP address preservation is enabled for an endpoint. The value is true or false. The default value is true for new accelerators. If the value is set to true, the client's IP address is preserved in the X-Forwarded-For request header as traffic travels to applications on the endpoint fronted by the accelerator. Client IP address preservation is supported, in specific Amazon Web Services Regions, for endpoints that are Application Load Balancers and Amazon EC2 instances. For more information, see [ Preserve client IP addresses in Global Accelerator](https://docs.aws.amazon.com/global-accelerator/latest/dg/preserve-client-ip-address.html) in the Global Accelerator Developer Guide.
        public var clientIPPreservationEnabled: Swift.Bool?
        /// An ID for the endpoint. If the endpoint is a Network Load Balancer or Application Load Balancer, this is the Amazon Resource Name (ARN) of the resource. If the endpoint is an Elastic IP address, this is the Elastic IP address allocation ID. For Amazon EC2 instances, this is the EC2 instance ID. An Application Load Balancer can be either internal or internet-facing.
        public var endpointId: Swift.String?
        /// Returns a null result.
        public var healthReason: Swift.String?
        /// The health status of the endpoint.
        public var healthState: GlobalAcceleratorClientTypes.HealthState?
        /// The weight associated with the endpoint. When you add weights to endpoints, you configure Global Accelerator to route traffic based on proportions that you specify. For example, you might specify endpoint weights of 4, 5, 5, and 6 (sum=20). The result is that 4/20 of your traffic, on average, is routed to the first endpoint, 5/20 is routed both to the second and third endpoints, and 6/20 is routed to the last endpoint. For more information, see [Endpoint weights](https://docs.aws.amazon.com/global-accelerator/latest/dg/about-endpoints-endpoint-weights.html) in the Global Accelerator Developer Guide.
        public var weight: Swift.Int?

        public init (
            clientIPPreservationEnabled: Swift.Bool? = nil,
            endpointId: Swift.String? = nil,
            healthReason: Swift.String? = nil,
            healthState: GlobalAcceleratorClientTypes.HealthState? = nil,
            weight: Swift.Int? = nil
        )
        {
            self.clientIPPreservationEnabled = clientIPPreservationEnabled
            self.endpointId = endpointId
            self.healthReason = healthReason
            self.healthState = healthState
            self.weight = weight
        }
    }

}

extension GlobalAcceleratorClientTypes.EndpointGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointDescriptions = "EndpointDescriptions"
        case endpointGroupArn = "EndpointGroupArn"
        case endpointGroupRegion = "EndpointGroupRegion"
        case healthCheckIntervalSeconds = "HealthCheckIntervalSeconds"
        case healthCheckPath = "HealthCheckPath"
        case healthCheckPort = "HealthCheckPort"
        case healthCheckProtocol = "HealthCheckProtocol"
        case portOverrides = "PortOverrides"
        case thresholdCount = "ThresholdCount"
        case trafficDialPercentage = "TrafficDialPercentage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointDescriptions = endpointDescriptions {
            var endpointDescriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpointDescriptions)
            for endpointdescription0 in endpointDescriptions {
                try endpointDescriptionsContainer.encode(endpointdescription0)
            }
        }
        if let endpointGroupArn = self.endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
        if let endpointGroupRegion = self.endpointGroupRegion {
            try encodeContainer.encode(endpointGroupRegion, forKey: .endpointGroupRegion)
        }
        if let healthCheckIntervalSeconds = self.healthCheckIntervalSeconds {
            try encodeContainer.encode(healthCheckIntervalSeconds, forKey: .healthCheckIntervalSeconds)
        }
        if let healthCheckPath = self.healthCheckPath {
            try encodeContainer.encode(healthCheckPath, forKey: .healthCheckPath)
        }
        if let healthCheckPort = self.healthCheckPort {
            try encodeContainer.encode(healthCheckPort, forKey: .healthCheckPort)
        }
        if let healthCheckProtocol = self.healthCheckProtocol {
            try encodeContainer.encode(healthCheckProtocol.rawValue, forKey: .healthCheckProtocol)
        }
        if let portOverrides = portOverrides {
            var portOverridesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portOverrides)
            for portoverride0 in portOverrides {
                try portOverridesContainer.encode(portoverride0)
            }
        }
        if let thresholdCount = self.thresholdCount {
            try encodeContainer.encode(thresholdCount, forKey: .thresholdCount)
        }
        if let trafficDialPercentage = self.trafficDialPercentage {
            try encodeContainer.encode(trafficDialPercentage, forKey: .trafficDialPercentage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
        let endpointGroupRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupRegion)
        endpointGroupRegion = endpointGroupRegionDecoded
        let endpointDescriptionsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.EndpointDescription?].self, forKey: .endpointDescriptions)
        var endpointDescriptionsDecoded0:[GlobalAcceleratorClientTypes.EndpointDescription]? = nil
        if let endpointDescriptionsContainer = endpointDescriptionsContainer {
            endpointDescriptionsDecoded0 = [GlobalAcceleratorClientTypes.EndpointDescription]()
            for structure0 in endpointDescriptionsContainer {
                if let structure0 = structure0 {
                    endpointDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        endpointDescriptions = endpointDescriptionsDecoded0
        let trafficDialPercentageDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .trafficDialPercentage)
        trafficDialPercentage = trafficDialPercentageDecoded
        let healthCheckPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthCheckPort)
        healthCheckPort = healthCheckPortDecoded
        let healthCheckProtocolDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.HealthCheckProtocol.self, forKey: .healthCheckProtocol)
        healthCheckProtocol = healthCheckProtocolDecoded
        let healthCheckPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .healthCheckPath)
        healthCheckPath = healthCheckPathDecoded
        let healthCheckIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthCheckIntervalSeconds)
        healthCheckIntervalSeconds = healthCheckIntervalSecondsDecoded
        let thresholdCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .thresholdCount)
        thresholdCount = thresholdCountDecoded
        let portOverridesContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.PortOverride?].self, forKey: .portOverrides)
        var portOverridesDecoded0:[GlobalAcceleratorClientTypes.PortOverride]? = nil
        if let portOverridesContainer = portOverridesContainer {
            portOverridesDecoded0 = [GlobalAcceleratorClientTypes.PortOverride]()
            for structure0 in portOverridesContainer {
                if let structure0 = structure0 {
                    portOverridesDecoded0?.append(structure0)
                }
            }
        }
        portOverrides = portOverridesDecoded0
    }
}

extension GlobalAcceleratorClientTypes {
    /// A complex type for the endpoint group. An Amazon Web Services Region can have only one endpoint group for a specific listener.
    public struct EndpointGroup: Swift.Equatable {
        /// The list of endpoint objects.
        public var endpointDescriptions: [GlobalAcceleratorClientTypes.EndpointDescription]?
        /// The Amazon Resource Name (ARN) of the endpoint group.
        public var endpointGroupArn: Swift.String?
        /// The Amazon Web Services Region where the endpoint group is located.
        public var endpointGroupRegion: Swift.String?
        /// The time—10 seconds or 30 seconds—between health checks for each endpoint. The default value is 30.
        public var healthCheckIntervalSeconds: Swift.Int?
        /// If the protocol is HTTP/S, then this value provides the ping path that Global Accelerator uses for the destination on the endpoints for health checks. The default is slash (/).
        public var healthCheckPath: Swift.String?
        /// The port that Global Accelerator uses to perform health checks on endpoints that are part of this endpoint group. The default port is the port for the listener that this endpoint group is associated with. If the listener port is a list, Global Accelerator uses the first specified port in the list of ports.
        public var healthCheckPort: Swift.Int?
        /// The protocol that Global Accelerator uses to perform health checks on endpoints that are part of this endpoint group. The default value is TCP.
        public var healthCheckProtocol: GlobalAcceleratorClientTypes.HealthCheckProtocol?
        /// Allows you to override the destination ports used to route traffic to an endpoint. Using a port override lets you map a list of external destination ports (that your users send traffic to) to a list of internal destination ports that you want an application endpoint to receive traffic on.
        public var portOverrides: [GlobalAcceleratorClientTypes.PortOverride]?
        /// The number of consecutive health checks required to set the state of a healthy endpoint to unhealthy, or to set an unhealthy endpoint to healthy. The default value is 3.
        public var thresholdCount: Swift.Int?
        /// The percentage of traffic to send to an Amazon Web Services Region. Additional traffic is distributed to other endpoint groups for this listener. Use this action to increase (dial up) or decrease (dial down) traffic to a specific Region. The percentage is applied to the traffic that would otherwise have been routed to the Region based on optimal routing. The default value is 100.
        public var trafficDialPercentage: Swift.Float?

        public init (
            endpointDescriptions: [GlobalAcceleratorClientTypes.EndpointDescription]? = nil,
            endpointGroupArn: Swift.String? = nil,
            endpointGroupRegion: Swift.String? = nil,
            healthCheckIntervalSeconds: Swift.Int? = nil,
            healthCheckPath: Swift.String? = nil,
            healthCheckPort: Swift.Int? = nil,
            healthCheckProtocol: GlobalAcceleratorClientTypes.HealthCheckProtocol? = nil,
            portOverrides: [GlobalAcceleratorClientTypes.PortOverride]? = nil,
            thresholdCount: Swift.Int? = nil,
            trafficDialPercentage: Swift.Float? = nil
        )
        {
            self.endpointDescriptions = endpointDescriptions
            self.endpointGroupArn = endpointGroupArn
            self.endpointGroupRegion = endpointGroupRegion
            self.healthCheckIntervalSeconds = healthCheckIntervalSeconds
            self.healthCheckPath = healthCheckPath
            self.healthCheckPort = healthCheckPort
            self.healthCheckProtocol = healthCheckProtocol
            self.portOverrides = portOverrides
            self.thresholdCount = thresholdCount
            self.trafficDialPercentage = trafficDialPercentage
        }
    }

}

extension EndpointGroupAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: EndpointGroupAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The endpoint group that you specified already exists.
public struct EndpointGroupAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EndpointGroupAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EndpointGroupAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EndpointGroupNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: EndpointGroupNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The endpoint group that you specified doesn't exist.
public struct EndpointGroupNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EndpointGroupNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EndpointGroupNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GlobalAcceleratorClientTypes.EndpointIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientIPPreservationEnabled = "ClientIPPreservationEnabled"
        case endpointId = "EndpointId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientIPPreservationEnabled = self.clientIPPreservationEnabled {
            try encodeContainer.encode(clientIPPreservationEnabled, forKey: .clientIPPreservationEnabled)
        }
        if let endpointId = self.endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
        let clientIPPreservationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .clientIPPreservationEnabled)
        clientIPPreservationEnabled = clientIPPreservationEnabledDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    /// A complex type for an endpoint. Specifies information about the endpoint to remove from the endpoint group.
    public struct EndpointIdentifier: Swift.Equatable {
        /// Indicates whether client IP address preservation is enabled for an endpoint. The value is true or false. If the value is set to true, the client's IP address is preserved in the X-Forwarded-For request header as traffic travels to applications on the endpoint fronted by the accelerator.
        public var clientIPPreservationEnabled: Swift.Bool?
        /// An ID for the endpoint. If the endpoint is a Network Load Balancer or Application Load Balancer, this is the Amazon Resource Name (ARN) of the resource. If the endpoint is an Elastic IP address, this is the Elastic IP address allocation ID. For Amazon EC2 instances, this is the EC2 instance ID. An Application Load Balancer can be either internal or internet-facing.
        /// This member is required.
        public var endpointId: Swift.String?

        public init (
            clientIPPreservationEnabled: Swift.Bool? = nil,
            endpointId: Swift.String? = nil
        )
        {
            self.clientIPPreservationEnabled = clientIPPreservationEnabled
            self.endpointId = endpointId
        }
    }

}

extension EndpointNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: EndpointNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The endpoint that you specified doesn't exist.
public struct EndpointNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EndpointNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EndpointNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    public enum HealthCheckProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case http
        case https
        case tcp
        case sdkUnknown(Swift.String)

        public static var allCases: [HealthCheckProtocol] {
            return [
                .http,
                .https,
                .tcp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .http: return "HTTP"
            case .https: return "HTTPS"
            case .tcp: return "TCP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HealthCheckProtocol(rawValue: rawValue) ?? HealthCheckProtocol.sdkUnknown(rawValue)
        }
    }
}

extension GlobalAcceleratorClientTypes {
    public enum HealthState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case healthy
        case initial
        case unhealthy
        case sdkUnknown(Swift.String)

        public static var allCases: [HealthState] {
            return [
                .healthy,
                .initial,
                .unhealthy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .healthy: return "HEALTHY"
            case .initial: return "INITIAL"
            case .unhealthy: return "UNHEALTHY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HealthState(rawValue: rawValue) ?? HealthState.sdkUnknown(rawValue)
        }
    }
}

extension IncorrectCidrStateException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: IncorrectCidrStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The CIDR that you specified is not valid for this action. For example, the state of the CIDR might be incorrect for this action.
public struct IncorrectCidrStateException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IncorrectCidrStateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension IncorrectCidrStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalServiceErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServiceErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There was an internal error for Global Accelerator.
public struct InternalServiceErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServiceErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidArgumentException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidArgumentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An argument that you specified is invalid.
public struct InvalidArgumentException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidArgumentExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidArgumentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There isn't another item to return.
public struct InvalidNextTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPortRangeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidPortRangeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The port numbers that you specified are not valid numbers or are not unique for this accelerator.
public struct InvalidPortRangeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPortRangeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidPortRangeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    public enum IpAddressFamily: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ipv4
        case ipv6
        case sdkUnknown(Swift.String)

        public static var allCases: [IpAddressFamily] {
            return [
                .ipv4,
                .ipv6,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ipv4: return "IPv4"
            case .ipv6: return "IPv6"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IpAddressFamily(rawValue: rawValue) ?? IpAddressFamily.sdkUnknown(rawValue)
        }
    }
}

extension GlobalAcceleratorClientTypes {
    public enum IpAddressType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dualStack
        case ipv4
        case sdkUnknown(Swift.String)

        public static var allCases: [IpAddressType] {
            return [
                .dualStack,
                .ipv4,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dualStack: return "DUAL_STACK"
            case .ipv4: return "IPV4"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IpAddressType(rawValue: rawValue) ?? IpAddressType.sdkUnknown(rawValue)
        }
    }
}

extension GlobalAcceleratorClientTypes.IpSet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAddressFamily = "IpAddressFamily"
        case ipAddresses = "IpAddresses"
        case ipFamily = "IpFamily"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipAddressFamily = self.ipAddressFamily {
            try encodeContainer.encode(ipAddressFamily.rawValue, forKey: .ipAddressFamily)
        }
        if let ipAddresses = ipAddresses {
            var ipAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipAddresses)
            for ipaddress0 in ipAddresses {
                try ipAddressesContainer.encode(ipaddress0)
            }
        }
        if let ipFamily = self.ipFamily {
            try encodeContainer.encode(ipFamily, forKey: .ipFamily)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipFamily)
        ipFamily = ipFamilyDecoded
        let ipAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ipAddresses)
        var ipAddressesDecoded0:[Swift.String]? = nil
        if let ipAddressesContainer = ipAddressesContainer {
            ipAddressesDecoded0 = [Swift.String]()
            for string0 in ipAddressesContainer {
                if let string0 = string0 {
                    ipAddressesDecoded0?.append(string0)
                }
            }
        }
        ipAddresses = ipAddressesDecoded0
        let ipAddressFamilyDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.IpAddressFamily.self, forKey: .ipAddressFamily)
        ipAddressFamily = ipAddressFamilyDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    /// A complex type for the set of IP addresses for an accelerator.
    public struct IpSet: Swift.Equatable {
        /// The types of IP addresses included in this IP set.
        public var ipAddressFamily: GlobalAcceleratorClientTypes.IpAddressFamily?
        /// The array of IP addresses in the IP address set. An IP address set can have a maximum of two IP addresses.
        public var ipAddresses: [Swift.String]?
        /// IpFamily is deprecated and has been replaced by IpAddressFamily.
        @available(*, deprecated, message: "IpFamily has been replaced by IpAddressFamily")
        public var ipFamily: Swift.String?

        public init (
            ipAddressFamily: GlobalAcceleratorClientTypes.IpAddressFamily? = nil,
            ipAddresses: [Swift.String]? = nil,
            ipFamily: Swift.String? = nil
        )
        {
            self.ipAddressFamily = ipAddressFamily
            self.ipAddresses = ipAddresses
            self.ipFamily = ipFamily
        }
    }

}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Processing your request would cause you to exceed an Global Accelerator limit.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAcceleratorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAcceleratorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAcceleratorsInput: Swift.Equatable {
    /// The number of Global Accelerator objects that you want to return with this call. The default value is 10.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAcceleratorsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListAcceleratorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAcceleratorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAcceleratorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAcceleratorsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAcceleratorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAcceleratorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accelerators = output.accelerators
            self.nextToken = output.nextToken
        } else {
            self.accelerators = nil
            self.nextToken = nil
        }
    }
}

public struct ListAcceleratorsOutputResponse: Swift.Equatable {
    /// The list of accelerators for a customer account.
    public var accelerators: [GlobalAcceleratorClientTypes.Accelerator]?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init (
        accelerators: [GlobalAcceleratorClientTypes.Accelerator]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accelerators = accelerators
        self.nextToken = nextToken
    }
}

struct ListAcceleratorsOutputResponseBody: Swift.Equatable {
    let accelerators: [GlobalAcceleratorClientTypes.Accelerator]?
    let nextToken: Swift.String?
}

extension ListAcceleratorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accelerators = "Accelerators"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.Accelerator?].self, forKey: .accelerators)
        var acceleratorsDecoded0:[GlobalAcceleratorClientTypes.Accelerator]? = nil
        if let acceleratorsContainer = acceleratorsContainer {
            acceleratorsDecoded0 = [GlobalAcceleratorClientTypes.Accelerator]()
            for structure0 in acceleratorsContainer {
                if let structure0 = structure0 {
                    acceleratorsDecoded0?.append(structure0)
                }
            }
        }
        accelerators = acceleratorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListByoipCidrsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListByoipCidrsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListByoipCidrsInput: Swift.Equatable {
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListByoipCidrsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListByoipCidrsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListByoipCidrsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListByoipCidrsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListByoipCidrsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListByoipCidrsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListByoipCidrsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.byoipCidrs = output.byoipCidrs
            self.nextToken = output.nextToken
        } else {
            self.byoipCidrs = nil
            self.nextToken = nil
        }
    }
}

public struct ListByoipCidrsOutputResponse: Swift.Equatable {
    /// Information about your address ranges.
    public var byoipCidrs: [GlobalAcceleratorClientTypes.ByoipCidr]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        byoipCidrs: [GlobalAcceleratorClientTypes.ByoipCidr]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.byoipCidrs = byoipCidrs
        self.nextToken = nextToken
    }
}

struct ListByoipCidrsOutputResponseBody: Swift.Equatable {
    let byoipCidrs: [GlobalAcceleratorClientTypes.ByoipCidr]?
    let nextToken: Swift.String?
}

extension ListByoipCidrsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case byoipCidrs = "ByoipCidrs"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let byoipCidrsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.ByoipCidr?].self, forKey: .byoipCidrs)
        var byoipCidrsDecoded0:[GlobalAcceleratorClientTypes.ByoipCidr]? = nil
        if let byoipCidrsContainer = byoipCidrsContainer {
            byoipCidrsDecoded0 = [GlobalAcceleratorClientTypes.ByoipCidr]()
            for structure0 in byoipCidrsContainer {
                if let structure0 = structure0 {
                    byoipCidrsDecoded0?.append(structure0)
                }
            }
        }
        byoipCidrs = byoipCidrsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCustomRoutingAcceleratorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListCustomRoutingAcceleratorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListCustomRoutingAcceleratorsInput: Swift.Equatable {
    /// The number of custom routing Global Accelerator objects that you want to return with this call. The default value is 10.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCustomRoutingAcceleratorsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListCustomRoutingAcceleratorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCustomRoutingAcceleratorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCustomRoutingAcceleratorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListCustomRoutingAcceleratorsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCustomRoutingAcceleratorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListCustomRoutingAcceleratorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accelerators = output.accelerators
            self.nextToken = output.nextToken
        } else {
            self.accelerators = nil
            self.nextToken = nil
        }
    }
}

public struct ListCustomRoutingAcceleratorsOutputResponse: Swift.Equatable {
    /// The list of custom routing accelerators for a customer account.
    public var accelerators: [GlobalAcceleratorClientTypes.CustomRoutingAccelerator]?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init (
        accelerators: [GlobalAcceleratorClientTypes.CustomRoutingAccelerator]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accelerators = accelerators
        self.nextToken = nextToken
    }
}

struct ListCustomRoutingAcceleratorsOutputResponseBody: Swift.Equatable {
    let accelerators: [GlobalAcceleratorClientTypes.CustomRoutingAccelerator]?
    let nextToken: Swift.String?
}

extension ListCustomRoutingAcceleratorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accelerators = "Accelerators"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.CustomRoutingAccelerator?].self, forKey: .accelerators)
        var acceleratorsDecoded0:[GlobalAcceleratorClientTypes.CustomRoutingAccelerator]? = nil
        if let acceleratorsContainer = acceleratorsContainer {
            acceleratorsDecoded0 = [GlobalAcceleratorClientTypes.CustomRoutingAccelerator]()
            for structure0 in acceleratorsContainer {
                if let structure0 = structure0 {
                    acceleratorsDecoded0?.append(structure0)
                }
            }
        }
        accelerators = acceleratorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCustomRoutingEndpointGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listenerArn = self.listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListCustomRoutingEndpointGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListCustomRoutingEndpointGroupsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the listener to list endpoint groups for.
    /// This member is required.
    public var listenerArn: Swift.String?
    /// The number of endpoint group objects that you want to return with this call. The default value is 10.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init (
        listenerArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.listenerArn = listenerArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCustomRoutingEndpointGroupsInputBody: Swift.Equatable {
    let listenerArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListCustomRoutingEndpointGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCustomRoutingEndpointGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCustomRoutingEndpointGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListCustomRoutingEndpointGroupsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidNextTokenException(InvalidNextTokenException)
    case listenerNotFoundException(ListenerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCustomRoutingEndpointGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListCustomRoutingEndpointGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpointGroups = output.endpointGroups
            self.nextToken = output.nextToken
        } else {
            self.endpointGroups = nil
            self.nextToken = nil
        }
    }
}

public struct ListCustomRoutingEndpointGroupsOutputResponse: Swift.Equatable {
    /// The list of the endpoint groups associated with a listener for a custom routing accelerator.
    public var endpointGroups: [GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup]?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init (
        endpointGroups: [GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.endpointGroups = endpointGroups
        self.nextToken = nextToken
    }
}

struct ListCustomRoutingEndpointGroupsOutputResponseBody: Swift.Equatable {
    let endpointGroups: [GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup]?
    let nextToken: Swift.String?
}

extension ListCustomRoutingEndpointGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroups = "EndpointGroups"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup?].self, forKey: .endpointGroups)
        var endpointGroupsDecoded0:[GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup]? = nil
        if let endpointGroupsContainer = endpointGroupsContainer {
            endpointGroupsDecoded0 = [GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup]()
            for structure0 in endpointGroupsContainer {
                if let structure0 = structure0 {
                    endpointGroupsDecoded0?.append(structure0)
                }
            }
        }
        endpointGroups = endpointGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCustomRoutingListenersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = self.acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListCustomRoutingListenersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListCustomRoutingListenersInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the accelerator to list listeners for.
    /// This member is required.
    public var acceleratorArn: Swift.String?
    /// The number of listener objects that you want to return with this call. The default value is 10.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init (
        acceleratorArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCustomRoutingListenersInputBody: Swift.Equatable {
    let acceleratorArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListCustomRoutingListenersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCustomRoutingListenersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCustomRoutingListenersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListCustomRoutingListenersOutputError: Swift.Error, Swift.Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCustomRoutingListenersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListCustomRoutingListenersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.listeners = output.listeners
            self.nextToken = output.nextToken
        } else {
            self.listeners = nil
            self.nextToken = nil
        }
    }
}

public struct ListCustomRoutingListenersOutputResponse: Swift.Equatable {
    /// The list of listeners for a custom routing accelerator.
    public var listeners: [GlobalAcceleratorClientTypes.CustomRoutingListener]?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init (
        listeners: [GlobalAcceleratorClientTypes.CustomRoutingListener]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.listeners = listeners
        self.nextToken = nextToken
    }
}

struct ListCustomRoutingListenersOutputResponseBody: Swift.Equatable {
    let listeners: [GlobalAcceleratorClientTypes.CustomRoutingListener]?
    let nextToken: Swift.String?
}

extension ListCustomRoutingListenersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listeners = "Listeners"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenersContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.CustomRoutingListener?].self, forKey: .listeners)
        var listenersDecoded0:[GlobalAcceleratorClientTypes.CustomRoutingListener]? = nil
        if let listenersContainer = listenersContainer {
            listenersDecoded0 = [GlobalAcceleratorClientTypes.CustomRoutingListener]()
            for structure0 in listenersContainer {
                if let structure0 = structure0 {
                    listenersDecoded0?.append(structure0)
                }
            }
        }
        listeners = listenersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCustomRoutingPortMappingsByDestinationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationAddress = "DestinationAddress"
        case endpointId = "EndpointId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationAddress = self.destinationAddress {
            try encodeContainer.encode(destinationAddress, forKey: .destinationAddress)
        }
        if let endpointId = self.endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListCustomRoutingPortMappingsByDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListCustomRoutingPortMappingsByDestinationInput: Swift.Equatable {
    /// The endpoint IP address in a virtual private cloud (VPC) subnet for which you want to receive back port mappings.
    /// This member is required.
    public var destinationAddress: Swift.String?
    /// The ID for the virtual private cloud (VPC) subnet.
    /// This member is required.
    public var endpointId: Swift.String?
    /// The number of destination port mappings that you want to return with this call. The default value is 10.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init (
        destinationAddress: Swift.String? = nil,
        endpointId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.destinationAddress = destinationAddress
        self.endpointId = endpointId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCustomRoutingPortMappingsByDestinationInputBody: Swift.Equatable {
    let endpointId: Swift.String?
    let destinationAddress: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListCustomRoutingPortMappingsByDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationAddress = "DestinationAddress"
        case endpointId = "EndpointId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
        let destinationAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationAddress)
        destinationAddress = destinationAddressDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCustomRoutingPortMappingsByDestinationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCustomRoutingPortMappingsByDestinationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EndpointNotFoundException" : self = .endpointNotFoundException(try EndpointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListCustomRoutingPortMappingsByDestinationOutputError: Swift.Error, Swift.Equatable {
    case endpointNotFoundException(EndpointNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCustomRoutingPortMappingsByDestinationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListCustomRoutingPortMappingsByDestinationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.destinationPortMappings = output.destinationPortMappings
            self.nextToken = output.nextToken
        } else {
            self.destinationPortMappings = nil
            self.nextToken = nil
        }
    }
}

public struct ListCustomRoutingPortMappingsByDestinationOutputResponse: Swift.Equatable {
    /// The port mappings for the endpoint IP address that you specified in the request.
    public var destinationPortMappings: [GlobalAcceleratorClientTypes.DestinationPortMapping]?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init (
        destinationPortMappings: [GlobalAcceleratorClientTypes.DestinationPortMapping]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.destinationPortMappings = destinationPortMappings
        self.nextToken = nextToken
    }
}

struct ListCustomRoutingPortMappingsByDestinationOutputResponseBody: Swift.Equatable {
    let destinationPortMappings: [GlobalAcceleratorClientTypes.DestinationPortMapping]?
    let nextToken: Swift.String?
}

extension ListCustomRoutingPortMappingsByDestinationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationPortMappings = "DestinationPortMappings"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationPortMappingsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.DestinationPortMapping?].self, forKey: .destinationPortMappings)
        var destinationPortMappingsDecoded0:[GlobalAcceleratorClientTypes.DestinationPortMapping]? = nil
        if let destinationPortMappingsContainer = destinationPortMappingsContainer {
            destinationPortMappingsDecoded0 = [GlobalAcceleratorClientTypes.DestinationPortMapping]()
            for structure0 in destinationPortMappingsContainer {
                if let structure0 = structure0 {
                    destinationPortMappingsDecoded0?.append(structure0)
                }
            }
        }
        destinationPortMappings = destinationPortMappingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCustomRoutingPortMappingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case endpointGroupArn = "EndpointGroupArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = self.acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let endpointGroupArn = self.endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListCustomRoutingPortMappingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListCustomRoutingPortMappingsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the accelerator to list the custom routing port mappings for.
    /// This member is required.
    public var acceleratorArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the endpoint group to list the custom routing port mappings for.
    public var endpointGroupArn: Swift.String?
    /// The number of destination port mappings that you want to return with this call. The default value is 10.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init (
        acceleratorArn: Swift.String? = nil,
        endpointGroupArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.endpointGroupArn = endpointGroupArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCustomRoutingPortMappingsInputBody: Swift.Equatable {
    let acceleratorArn: Swift.String?
    let endpointGroupArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListCustomRoutingPortMappingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case endpointGroupArn = "EndpointGroupArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCustomRoutingPortMappingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCustomRoutingPortMappingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointGroupNotFoundException" : self = .endpointGroupNotFoundException(try EndpointGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListCustomRoutingPortMappingsOutputError: Swift.Error, Swift.Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case endpointGroupNotFoundException(EndpointGroupNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCustomRoutingPortMappingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListCustomRoutingPortMappingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.portMappings = output.portMappings
        } else {
            self.nextToken = nil
            self.portMappings = nil
        }
    }
}

public struct ListCustomRoutingPortMappingsOutputResponse: Swift.Equatable {
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?
    /// The port mappings for a custom routing accelerator.
    public var portMappings: [GlobalAcceleratorClientTypes.PortMapping]?

    public init (
        nextToken: Swift.String? = nil,
        portMappings: [GlobalAcceleratorClientTypes.PortMapping]? = nil
    )
    {
        self.nextToken = nextToken
        self.portMappings = portMappings
    }
}

struct ListCustomRoutingPortMappingsOutputResponseBody: Swift.Equatable {
    let portMappings: [GlobalAcceleratorClientTypes.PortMapping]?
    let nextToken: Swift.String?
}

extension ListCustomRoutingPortMappingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case portMappings = "PortMappings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portMappingsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.PortMapping?].self, forKey: .portMappings)
        var portMappingsDecoded0:[GlobalAcceleratorClientTypes.PortMapping]? = nil
        if let portMappingsContainer = portMappingsContainer {
            portMappingsDecoded0 = [GlobalAcceleratorClientTypes.PortMapping]()
            for structure0 in portMappingsContainer {
                if let structure0 = structure0 {
                    portMappingsDecoded0?.append(structure0)
                }
            }
        }
        portMappings = portMappingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListEndpointGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listenerArn = self.listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListEndpointGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListEndpointGroupsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerArn: Swift.String?
    /// The number of endpoint group objects that you want to return with this call. The default value is 10.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init (
        listenerArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.listenerArn = listenerArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEndpointGroupsInputBody: Swift.Equatable {
    let listenerArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListEndpointGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListEndpointGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEndpointGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListEndpointGroupsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidNextTokenException(InvalidNextTokenException)
    case listenerNotFoundException(ListenerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEndpointGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListEndpointGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpointGroups = output.endpointGroups
            self.nextToken = output.nextToken
        } else {
            self.endpointGroups = nil
            self.nextToken = nil
        }
    }
}

public struct ListEndpointGroupsOutputResponse: Swift.Equatable {
    /// The list of the endpoint groups associated with a listener.
    public var endpointGroups: [GlobalAcceleratorClientTypes.EndpointGroup]?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init (
        endpointGroups: [GlobalAcceleratorClientTypes.EndpointGroup]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.endpointGroups = endpointGroups
        self.nextToken = nextToken
    }
}

struct ListEndpointGroupsOutputResponseBody: Swift.Equatable {
    let endpointGroups: [GlobalAcceleratorClientTypes.EndpointGroup]?
    let nextToken: Swift.String?
}

extension ListEndpointGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroups = "EndpointGroups"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.EndpointGroup?].self, forKey: .endpointGroups)
        var endpointGroupsDecoded0:[GlobalAcceleratorClientTypes.EndpointGroup]? = nil
        if let endpointGroupsContainer = endpointGroupsContainer {
            endpointGroupsDecoded0 = [GlobalAcceleratorClientTypes.EndpointGroup]()
            for structure0 in endpointGroupsContainer {
                if let structure0 = structure0 {
                    endpointGroupsDecoded0?.append(structure0)
                }
            }
        }
        endpointGroups = endpointGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListListenersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = self.acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListListenersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListListenersInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the accelerator for which you want to list listener objects.
    /// This member is required.
    public var acceleratorArn: Swift.String?
    /// The number of listener objects that you want to return with this call. The default value is 10.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init (
        acceleratorArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListListenersInputBody: Swift.Equatable {
    let acceleratorArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListListenersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListListenersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListListenersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListListenersOutputError: Swift.Error, Swift.Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListListenersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListListenersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.listeners = output.listeners
            self.nextToken = output.nextToken
        } else {
            self.listeners = nil
            self.nextToken = nil
        }
    }
}

public struct ListListenersOutputResponse: Swift.Equatable {
    /// The list of listeners for an accelerator.
    public var listeners: [GlobalAcceleratorClientTypes.Listener]?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init (
        listeners: [GlobalAcceleratorClientTypes.Listener]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.listeners = listeners
        self.nextToken = nextToken
    }
}

struct ListListenersOutputResponseBody: Swift.Equatable {
    let listeners: [GlobalAcceleratorClientTypes.Listener]?
    let nextToken: Swift.String?
}

extension ListListenersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listeners = "Listeners"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenersContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.Listener?].self, forKey: .listeners)
        var listenersDecoded0:[GlobalAcceleratorClientTypes.Listener]? = nil
        if let listenersContainer = listenersContainer {
            listenersDecoded0 = [GlobalAcceleratorClientTypes.Listener]()
            for structure0 in listenersContainer {
                if let structure0 = structure0 {
                    listenersDecoded0?.append(structure0)
                }
            }
        }
        listeners = listenersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the accelerator to list tags for. An ARN uniquely identifies an accelerator.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// Root level tag for the Tags parameters.
    public var tags: [GlobalAcceleratorClientTypes.Tag]?

    public init (
        tags: [GlobalAcceleratorClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [GlobalAcceleratorClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[GlobalAcceleratorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [GlobalAcceleratorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GlobalAcceleratorClientTypes.Listener: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientAffinity = "ClientAffinity"
        case listenerArn = "ListenerArn"
        case portRanges = "PortRanges"
        case `protocol` = "Protocol"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientAffinity = self.clientAffinity {
            try encodeContainer.encode(clientAffinity.rawValue, forKey: .clientAffinity)
        }
        if let listenerArn = self.listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
        if let portRanges = portRanges {
            var portRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portRanges)
            for portrange0 in portRanges {
                try portRangesContainer.encode(portrange0)
            }
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
        let portRangesContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.PortRange?].self, forKey: .portRanges)
        var portRangesDecoded0:[GlobalAcceleratorClientTypes.PortRange]? = nil
        if let portRangesContainer = portRangesContainer {
            portRangesDecoded0 = [GlobalAcceleratorClientTypes.PortRange]()
            for structure0 in portRangesContainer {
                if let structure0 = structure0 {
                    portRangesDecoded0?.append(structure0)
                }
            }
        }
        portRanges = portRangesDecoded0
        let protocolDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.ModelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let clientAffinityDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.ClientAffinity.self, forKey: .clientAffinity)
        clientAffinity = clientAffinityDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    /// A complex type for a listener.
    public struct Listener: Swift.Equatable {
        /// Client affinity lets you direct all requests from a user to the same endpoint, if you have stateful applications, regardless of the port and protocol of the client request. Client affinity gives you control over whether to always route each client to the same specific endpoint. Global Accelerator uses a consistent-flow hashing algorithm to choose the optimal endpoint for a connection. If client affinity is NONE, Global Accelerator uses the "five-tuple" (5-tuple) properties—source IP address, source port, destination IP address, destination port, and protocol—to select the hash value, and then chooses the best endpoint. However, with this setting, if someone uses different ports to connect to Global Accelerator, their connections might not be always routed to the same endpoint because the hash value changes. If you want a given client to always be routed to the same endpoint, set client affinity to SOURCE_IP instead. When you use the SOURCE_IP setting, Global Accelerator uses the "two-tuple" (2-tuple) properties— source (client) IP address and destination IP address—to select the hash value. The default value is NONE.
        public var clientAffinity: GlobalAcceleratorClientTypes.ClientAffinity?
        /// The Amazon Resource Name (ARN) of the listener.
        public var listenerArn: Swift.String?
        /// The list of port ranges for the connections from clients to the accelerator.
        public var portRanges: [GlobalAcceleratorClientTypes.PortRange]?
        /// The protocol for the connections from clients to the accelerator.
        public var `protocol`: GlobalAcceleratorClientTypes.ModelProtocol?

        public init (
            clientAffinity: GlobalAcceleratorClientTypes.ClientAffinity? = nil,
            listenerArn: Swift.String? = nil,
            portRanges: [GlobalAcceleratorClientTypes.PortRange]? = nil,
            `protocol`: GlobalAcceleratorClientTypes.ModelProtocol? = nil
        )
        {
            self.clientAffinity = clientAffinity
            self.listenerArn = listenerArn
            self.portRanges = portRanges
            self.`protocol` = `protocol`
        }
    }

}

extension ListenerNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListenerNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The listener that you specified doesn't exist.
public struct ListenerNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ListenerNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ListenerNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GlobalAcceleratorClientTypes.PortMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorPort = "AcceleratorPort"
        case destinationSocketAddress = "DestinationSocketAddress"
        case destinationTrafficState = "DestinationTrafficState"
        case endpointGroupArn = "EndpointGroupArn"
        case endpointId = "EndpointId"
        case protocols = "Protocols"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorPort = self.acceleratorPort {
            try encodeContainer.encode(acceleratorPort, forKey: .acceleratorPort)
        }
        if let destinationSocketAddress = self.destinationSocketAddress {
            try encodeContainer.encode(destinationSocketAddress, forKey: .destinationSocketAddress)
        }
        if let destinationTrafficState = self.destinationTrafficState {
            try encodeContainer.encode(destinationTrafficState.rawValue, forKey: .destinationTrafficState)
        }
        if let endpointGroupArn = self.endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
        if let endpointId = self.endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
        if let protocols = protocols {
            var protocolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocols)
            for customroutingprotocol0 in protocols {
                try protocolsContainer.encode(customroutingprotocol0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .acceleratorPort)
        acceleratorPort = acceleratorPortDecoded
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
        let destinationSocketAddressDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.SocketAddress.self, forKey: .destinationSocketAddress)
        destinationSocketAddress = destinationSocketAddressDecoded
        let protocolsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.CustomRoutingProtocol?].self, forKey: .protocols)
        var protocolsDecoded0:[GlobalAcceleratorClientTypes.CustomRoutingProtocol]? = nil
        if let protocolsContainer = protocolsContainer {
            protocolsDecoded0 = [GlobalAcceleratorClientTypes.CustomRoutingProtocol]()
            for enum0 in protocolsContainer {
                if let enum0 = enum0 {
                    protocolsDecoded0?.append(enum0)
                }
            }
        }
        protocols = protocolsDecoded0
        let destinationTrafficStateDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CustomRoutingDestinationTrafficState.self, forKey: .destinationTrafficState)
        destinationTrafficState = destinationTrafficStateDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    /// Returns the ports and associated IP addresses and ports of Amazon EC2 instances in your virtual private cloud (VPC) subnets. Custom routing is a port mapping protocol in Global Accelerator that statically associates port ranges with VPC subnets, which allows Global Accelerator to route to specific instances and ports within one or more subnets.
    public struct PortMapping: Swift.Equatable {
        /// The accelerator port.
        public var acceleratorPort: Swift.Int?
        /// The EC2 instance IP address and port number in the virtual private cloud (VPC) subnet.
        public var destinationSocketAddress: GlobalAcceleratorClientTypes.SocketAddress?
        /// Indicates whether or not a port mapping destination can receive traffic. The value is either ALLOW, if traffic is allowed to the destination, or DENY, if traffic is not allowed to the destination.
        public var destinationTrafficState: GlobalAcceleratorClientTypes.CustomRoutingDestinationTrafficState?
        /// The Amazon Resource Name (ARN) of the endpoint group.
        public var endpointGroupArn: Swift.String?
        /// The IP address of the VPC subnet (the subnet ID).
        public var endpointId: Swift.String?
        /// The protocols supported by the endpoint group.
        public var protocols: [GlobalAcceleratorClientTypes.CustomRoutingProtocol]?

        public init (
            acceleratorPort: Swift.Int? = nil,
            destinationSocketAddress: GlobalAcceleratorClientTypes.SocketAddress? = nil,
            destinationTrafficState: GlobalAcceleratorClientTypes.CustomRoutingDestinationTrafficState? = nil,
            endpointGroupArn: Swift.String? = nil,
            endpointId: Swift.String? = nil,
            protocols: [GlobalAcceleratorClientTypes.CustomRoutingProtocol]? = nil
        )
        {
            self.acceleratorPort = acceleratorPort
            self.destinationSocketAddress = destinationSocketAddress
            self.destinationTrafficState = destinationTrafficState
            self.endpointGroupArn = endpointGroupArn
            self.endpointId = endpointId
            self.protocols = protocols
        }
    }

}

extension GlobalAcceleratorClientTypes.PortOverride: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointPort = "EndpointPort"
        case listenerPort = "ListenerPort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointPort = self.endpointPort {
            try encodeContainer.encode(endpointPort, forKey: .endpointPort)
        }
        if let listenerPort = self.listenerPort {
            try encodeContainer.encode(listenerPort, forKey: .listenerPort)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .listenerPort)
        listenerPort = listenerPortDecoded
        let endpointPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endpointPort)
        endpointPort = endpointPortDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    /// Override specific listener ports used to route traffic to endpoints that are part of an endpoint group. For example, you can create a port override in which the listener receives user traffic on ports 80 and 443, but your accelerator routes that traffic to ports 1080 and 1443, respectively, on the endpoints. For more information, see [ Overriding listener ports](https://docs.aws.amazon.com/global-accelerator/latest/dg/about-endpoint-groups-port-override.html) in the Global Accelerator Developer Guide.
    public struct PortOverride: Swift.Equatable {
        /// The endpoint port that you want a listener port to be mapped to. This is the port on the endpoint, such as the Application Load Balancer or Amazon EC2 instance.
        public var endpointPort: Swift.Int?
        /// The listener port that you want to map to a specific endpoint port. This is the port that user traffic arrives to the Global Accelerator on.
        public var listenerPort: Swift.Int?

        public init (
            endpointPort: Swift.Int? = nil,
            listenerPort: Swift.Int? = nil
        )
        {
            self.endpointPort = endpointPort
            self.listenerPort = listenerPort
        }
    }

}

extension GlobalAcceleratorClientTypes.PortRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromPort = "FromPort"
        case toPort = "ToPort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromPort = self.fromPort {
            try encodeContainer.encode(fromPort, forKey: .fromPort)
        }
        if let toPort = self.toPort {
            try encodeContainer.encode(toPort, forKey: .toPort)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fromPort)
        fromPort = fromPortDecoded
        let toPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .toPort)
        toPort = toPortDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    /// A complex type for a range of ports for a listener.
    public struct PortRange: Swift.Equatable {
        /// The first port in the range of ports, inclusive.
        public var fromPort: Swift.Int?
        /// The last port in the range of ports, inclusive.
        public var toPort: Swift.Int?

        public init (
            fromPort: Swift.Int? = nil,
            toPort: Swift.Int? = nil
        )
        {
            self.fromPort = fromPort
            self.toPort = toPort
        }
    }

}

extension GlobalAcceleratorClientTypes {
    public enum ModelProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case tcp
        case udp
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelProtocol] {
            return [
                .tcp,
                .udp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .tcp: return "TCP"
            case .udp: return "UDP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelProtocol(rawValue: rawValue) ?? ModelProtocol.sdkUnknown(rawValue)
        }
    }
}

extension ProvisionByoipCidrInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidr = "Cidr"
        case cidrAuthorizationContext = "CidrAuthorizationContext"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidr = self.cidr {
            try encodeContainer.encode(cidr, forKey: .cidr)
        }
        if let cidrAuthorizationContext = self.cidrAuthorizationContext {
            try encodeContainer.encode(cidrAuthorizationContext, forKey: .cidrAuthorizationContext)
        }
    }
}

extension ProvisionByoipCidrInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ProvisionByoipCidrInput: Swift.Equatable {
    /// The public IPv4 address range, in CIDR notation. The most specific IP prefix that you can specify is /24. The address range cannot overlap with another address range that you've brought to this or another Region.
    /// This member is required.
    public var cidr: Swift.String?
    /// A signed document that proves that you are authorized to bring the specified IP address range to Amazon using BYOIP.
    /// This member is required.
    public var cidrAuthorizationContext: GlobalAcceleratorClientTypes.CidrAuthorizationContext?

    public init (
        cidr: Swift.String? = nil,
        cidrAuthorizationContext: GlobalAcceleratorClientTypes.CidrAuthorizationContext? = nil
    )
    {
        self.cidr = cidr
        self.cidrAuthorizationContext = cidrAuthorizationContext
    }
}

struct ProvisionByoipCidrInputBody: Swift.Equatable {
    let cidr: Swift.String?
    let cidrAuthorizationContext: GlobalAcceleratorClientTypes.CidrAuthorizationContext?
}

extension ProvisionByoipCidrInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidr = "Cidr"
        case cidrAuthorizationContext = "CidrAuthorizationContext"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cidr)
        cidr = cidrDecoded
        let cidrAuthorizationContextDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CidrAuthorizationContext.self, forKey: .cidrAuthorizationContext)
        cidrAuthorizationContext = cidrAuthorizationContextDecoded
    }
}

extension ProvisionByoipCidrOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ProvisionByoipCidrOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncorrectCidrStateException" : self = .incorrectCidrStateException(try IncorrectCidrStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ProvisionByoipCidrOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case incorrectCidrStateException(IncorrectCidrStateException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ProvisionByoipCidrOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ProvisionByoipCidrOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.byoipCidr = output.byoipCidr
        } else {
            self.byoipCidr = nil
        }
    }
}

public struct ProvisionByoipCidrOutputResponse: Swift.Equatable {
    /// Information about the address range.
    public var byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr?

    public init (
        byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr? = nil
    )
    {
        self.byoipCidr = byoipCidr
    }
}

struct ProvisionByoipCidrOutputResponseBody: Swift.Equatable {
    let byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr?
}

extension ProvisionByoipCidrOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case byoipCidr = "ByoipCidr"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let byoipCidrDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.ByoipCidr.self, forKey: .byoipCidr)
        byoipCidr = byoipCidrDecoded
    }
}

extension RemoveCustomRoutingEndpointsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
        case endpointIds = "EndpointIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointGroupArn = self.endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
        if let endpointIds = endpointIds {
            var endpointIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpointIds)
            for genericstring0 in endpointIds {
                try endpointIdsContainer.encode(genericstring0)
            }
        }
    }
}

extension RemoveCustomRoutingEndpointsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RemoveCustomRoutingEndpointsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the endpoint group to remove endpoints from.
    /// This member is required.
    public var endpointGroupArn: Swift.String?
    /// The IDs for the endpoints. For custom routing accelerators, endpoint IDs are the virtual private cloud (VPC) subnet IDs.
    /// This member is required.
    public var endpointIds: [Swift.String]?

    public init (
        endpointGroupArn: Swift.String? = nil,
        endpointIds: [Swift.String]? = nil
    )
    {
        self.endpointGroupArn = endpointGroupArn
        self.endpointIds = endpointIds
    }
}

struct RemoveCustomRoutingEndpointsInputBody: Swift.Equatable {
    let endpointIds: [Swift.String]?
    let endpointGroupArn: Swift.String?
}

extension RemoveCustomRoutingEndpointsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
        case endpointIds = "EndpointIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .endpointIds)
        var endpointIdsDecoded0:[Swift.String]? = nil
        if let endpointIdsContainer = endpointIdsContainer {
            endpointIdsDecoded0 = [Swift.String]()
            for string0 in endpointIdsContainer {
                if let string0 = string0 {
                    endpointIdsDecoded0?.append(string0)
                }
            }
        }
        endpointIds = endpointIdsDecoded0
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
    }
}

extension RemoveCustomRoutingEndpointsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveCustomRoutingEndpointsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointGroupNotFoundException" : self = .endpointGroupNotFoundException(try EndpointGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointNotFoundException" : self = .endpointNotFoundException(try EndpointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RemoveCustomRoutingEndpointsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case endpointGroupNotFoundException(EndpointGroupNotFoundException)
    case endpointNotFoundException(EndpointNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveCustomRoutingEndpointsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RemoveCustomRoutingEndpointsOutputResponse: Swift.Equatable {

    public init () { }
}

extension RemoveEndpointsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
        case endpointIdentifiers = "EndpointIdentifiers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointGroupArn = self.endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
        if let endpointIdentifiers = endpointIdentifiers {
            var endpointIdentifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpointIdentifiers)
            for endpointidentifier0 in endpointIdentifiers {
                try endpointIdentifiersContainer.encode(endpointidentifier0)
            }
        }
    }
}

extension RemoveEndpointsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RemoveEndpointsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the endpoint group.
    /// This member is required.
    public var endpointGroupArn: Swift.String?
    /// The identifiers of the endpoints that you want to remove.
    /// This member is required.
    public var endpointIdentifiers: [GlobalAcceleratorClientTypes.EndpointIdentifier]?

    public init (
        endpointGroupArn: Swift.String? = nil,
        endpointIdentifiers: [GlobalAcceleratorClientTypes.EndpointIdentifier]? = nil
    )
    {
        self.endpointGroupArn = endpointGroupArn
        self.endpointIdentifiers = endpointIdentifiers
    }
}

struct RemoveEndpointsInputBody: Swift.Equatable {
    let endpointIdentifiers: [GlobalAcceleratorClientTypes.EndpointIdentifier]?
    let endpointGroupArn: Swift.String?
}

extension RemoveEndpointsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
        case endpointIdentifiers = "EndpointIdentifiers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointIdentifiersContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.EndpointIdentifier?].self, forKey: .endpointIdentifiers)
        var endpointIdentifiersDecoded0:[GlobalAcceleratorClientTypes.EndpointIdentifier]? = nil
        if let endpointIdentifiersContainer = endpointIdentifiersContainer {
            endpointIdentifiersDecoded0 = [GlobalAcceleratorClientTypes.EndpointIdentifier]()
            for structure0 in endpointIdentifiersContainer {
                if let structure0 = structure0 {
                    endpointIdentifiersDecoded0?.append(structure0)
                }
            }
        }
        endpointIdentifiers = endpointIdentifiersDecoded0
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
    }
}

extension RemoveEndpointsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveEndpointsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointGroupNotFoundException" : self = .endpointGroupNotFoundException(try EndpointGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TransactionInProgressException" : self = .transactionInProgressException(try TransactionInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RemoveEndpointsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case endpointGroupNotFoundException(EndpointGroupNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case transactionInProgressException(TransactionInProgressException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveEndpointsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RemoveEndpointsOutputResponse: Swift.Equatable {

    public init () { }
}

extension GlobalAcceleratorClientTypes.SocketAddress: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAddress = "IpAddress"
        case port = "Port"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipAddress = self.ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    /// An IP address/port combination.
    public struct SocketAddress: Swift.Equatable {
        /// The IP address for the socket address.
        public var ipAddress: Swift.String?
        /// The port for the socket address.
        public var port: Swift.Int?

        public init (
            ipAddress: Swift.String? = nil,
            port: Swift.Int? = nil
        )
        {
            self.ipAddress = ipAddress
            self.port = port
        }
    }

}

extension GlobalAcceleratorClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    /// A complex type that contains a Tag key and Tag value.
    public struct Tag: Swift.Equatable {
        /// A string that contains a Tag key.
        /// This member is required.
        public var key: Swift.String?
        /// A string that contains a Tag value.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Global Accelerator resource to add tags to. An ARN uniquely identifies a resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to a resource. A tag consists of a key and a value that you define.
    /// This member is required.
    public var tags: [GlobalAcceleratorClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [GlobalAcceleratorClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [GlobalAcceleratorClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[GlobalAcceleratorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [GlobalAcceleratorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension TransactionInProgressException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TransactionInProgressExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There's already a transaction in progress. Another transaction can't be processed.
public struct TransactionInProgressException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TransactionInProgressExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TransactionInProgressExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Global Accelerator resource to remove tags from. An ARN uniquely identifies a resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag key pairs that you want to remove from the specified resources.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateAcceleratorAttributesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case flowLogsEnabled = "FlowLogsEnabled"
        case flowLogsS3Bucket = "FlowLogsS3Bucket"
        case flowLogsS3Prefix = "FlowLogsS3Prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = self.acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let flowLogsEnabled = self.flowLogsEnabled {
            try encodeContainer.encode(flowLogsEnabled, forKey: .flowLogsEnabled)
        }
        if let flowLogsS3Bucket = self.flowLogsS3Bucket {
            try encodeContainer.encode(flowLogsS3Bucket, forKey: .flowLogsS3Bucket)
        }
        if let flowLogsS3Prefix = self.flowLogsS3Prefix {
            try encodeContainer.encode(flowLogsS3Prefix, forKey: .flowLogsS3Prefix)
        }
    }
}

extension UpdateAcceleratorAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateAcceleratorAttributesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the accelerator that you want to update.
    /// This member is required.
    public var acceleratorArn: Swift.String?
    /// Update whether flow logs are enabled. The default value is false. If the value is true, FlowLogsS3Bucket and FlowLogsS3Prefix must be specified. For more information, see [Flow Logs](https://docs.aws.amazon.com/global-accelerator/latest/dg/monitoring-global-accelerator.flow-logs.html) in the Global Accelerator Developer Guide.
    public var flowLogsEnabled: Swift.Bool?
    /// The name of the Amazon S3 bucket for the flow logs. Attribute is required if FlowLogsEnabled is true. The bucket must exist and have a bucket policy that grants Global Accelerator permission to write to the bucket.
    public var flowLogsS3Bucket: Swift.String?
    /// Update the prefix for the location in the Amazon S3 bucket for the flow logs. Attribute is required if FlowLogsEnabled is true. If you specify slash (/) for the S3 bucket prefix, the log file bucket folder structure will include a double slash (//), like the following: s3-bucket_name//AWSLogs/aws_account_id
    public var flowLogsS3Prefix: Swift.String?

    public init (
        acceleratorArn: Swift.String? = nil,
        flowLogsEnabled: Swift.Bool? = nil,
        flowLogsS3Bucket: Swift.String? = nil,
        flowLogsS3Prefix: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.flowLogsEnabled = flowLogsEnabled
        self.flowLogsS3Bucket = flowLogsS3Bucket
        self.flowLogsS3Prefix = flowLogsS3Prefix
    }
}

struct UpdateAcceleratorAttributesInputBody: Swift.Equatable {
    let acceleratorArn: Swift.String?
    let flowLogsEnabled: Swift.Bool?
    let flowLogsS3Bucket: Swift.String?
    let flowLogsS3Prefix: Swift.String?
}

extension UpdateAcceleratorAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case flowLogsEnabled = "FlowLogsEnabled"
        case flowLogsS3Bucket = "FlowLogsS3Bucket"
        case flowLogsS3Prefix = "FlowLogsS3Prefix"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let flowLogsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .flowLogsEnabled)
        flowLogsEnabled = flowLogsEnabledDecoded
        let flowLogsS3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowLogsS3Bucket)
        flowLogsS3Bucket = flowLogsS3BucketDecoded
        let flowLogsS3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowLogsS3Prefix)
        flowLogsS3Prefix = flowLogsS3PrefixDecoded
    }
}

extension UpdateAcceleratorAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAcceleratorAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateAcceleratorAttributesOutputError: Swift.Error, Swift.Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAcceleratorAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateAcceleratorAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.acceleratorAttributes = output.acceleratorAttributes
        } else {
            self.acceleratorAttributes = nil
        }
    }
}

public struct UpdateAcceleratorAttributesOutputResponse: Swift.Equatable {
    /// Updated attributes for the accelerator.
    public var acceleratorAttributes: GlobalAcceleratorClientTypes.AcceleratorAttributes?

    public init (
        acceleratorAttributes: GlobalAcceleratorClientTypes.AcceleratorAttributes? = nil
    )
    {
        self.acceleratorAttributes = acceleratorAttributes
    }
}

struct UpdateAcceleratorAttributesOutputResponseBody: Swift.Equatable {
    let acceleratorAttributes: GlobalAcceleratorClientTypes.AcceleratorAttributes?
}

extension UpdateAcceleratorAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorAttributes = "AcceleratorAttributes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorAttributesDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.AcceleratorAttributes.self, forKey: .acceleratorAttributes)
        acceleratorAttributes = acceleratorAttributesDecoded
    }
}

extension UpdateAcceleratorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case enabled = "Enabled"
        case ipAddressType = "IpAddressType"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = self.acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let ipAddressType = self.ipAddressType {
            try encodeContainer.encode(ipAddressType.rawValue, forKey: .ipAddressType)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateAcceleratorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateAcceleratorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the accelerator to update.
    /// This member is required.
    public var acceleratorArn: Swift.String?
    /// Indicates whether an accelerator is enabled. The value is true or false. The default value is true. If the value is set to true, the accelerator cannot be deleted. If set to false, the accelerator can be deleted.
    public var enabled: Swift.Bool?
    /// The IP address type that an accelerator supports. For a standard accelerator, the value can be IPV4 or DUAL_STACK.
    public var ipAddressType: GlobalAcceleratorClientTypes.IpAddressType?
    /// The name of the accelerator. The name can have a maximum of 64 characters, must contain only alphanumeric characters, periods (.), or hyphens (-), and must not begin or end with a hyphen or period.
    public var name: Swift.String?

    public init (
        acceleratorArn: Swift.String? = nil,
        enabled: Swift.Bool? = nil,
        ipAddressType: GlobalAcceleratorClientTypes.IpAddressType? = nil,
        name: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.enabled = enabled
        self.ipAddressType = ipAddressType
        self.name = name
    }
}

struct UpdateAcceleratorInputBody: Swift.Equatable {
    let acceleratorArn: Swift.String?
    let name: Swift.String?
    let ipAddressType: GlobalAcceleratorClientTypes.IpAddressType?
    let enabled: Swift.Bool?
}

extension UpdateAcceleratorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case enabled = "Enabled"
        case ipAddressType = "IpAddressType"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.IpAddressType.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension UpdateAcceleratorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAcceleratorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateAcceleratorOutputError: Swift.Error, Swift.Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAcceleratorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateAcceleratorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accelerator = output.accelerator
        } else {
            self.accelerator = nil
        }
    }
}

public struct UpdateAcceleratorOutputResponse: Swift.Equatable {
    /// Information about the updated accelerator.
    public var accelerator: GlobalAcceleratorClientTypes.Accelerator?

    public init (
        accelerator: GlobalAcceleratorClientTypes.Accelerator? = nil
    )
    {
        self.accelerator = accelerator
    }
}

struct UpdateAcceleratorOutputResponseBody: Swift.Equatable {
    let accelerator: GlobalAcceleratorClientTypes.Accelerator?
}

extension UpdateAcceleratorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accelerator = "Accelerator"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.Accelerator.self, forKey: .accelerator)
        accelerator = acceleratorDecoded
    }
}

extension UpdateCustomRoutingAcceleratorAttributesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case flowLogsEnabled = "FlowLogsEnabled"
        case flowLogsS3Bucket = "FlowLogsS3Bucket"
        case flowLogsS3Prefix = "FlowLogsS3Prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = self.acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let flowLogsEnabled = self.flowLogsEnabled {
            try encodeContainer.encode(flowLogsEnabled, forKey: .flowLogsEnabled)
        }
        if let flowLogsS3Bucket = self.flowLogsS3Bucket {
            try encodeContainer.encode(flowLogsS3Bucket, forKey: .flowLogsS3Bucket)
        }
        if let flowLogsS3Prefix = self.flowLogsS3Prefix {
            try encodeContainer.encode(flowLogsS3Prefix, forKey: .flowLogsS3Prefix)
        }
    }
}

extension UpdateCustomRoutingAcceleratorAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateCustomRoutingAcceleratorAttributesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the custom routing accelerator to update attributes for.
    /// This member is required.
    public var acceleratorArn: Swift.String?
    /// Update whether flow logs are enabled. The default value is false. If the value is true, FlowLogsS3Bucket and FlowLogsS3Prefix must be specified. For more information, see [Flow logs](https://docs.aws.amazon.com/global-accelerator/latest/dg/monitoring-global-accelerator.flow-logs.html) in the Global Accelerator Developer Guide.
    public var flowLogsEnabled: Swift.Bool?
    /// The name of the Amazon S3 bucket for the flow logs. Attribute is required if FlowLogsEnabled is true. The bucket must exist and have a bucket policy that grants Global Accelerator permission to write to the bucket.
    public var flowLogsS3Bucket: Swift.String?
    /// Update the prefix for the location in the Amazon S3 bucket for the flow logs. Attribute is required if FlowLogsEnabled is true. If you don’t specify a prefix, the flow logs are stored in the root of the bucket. If you specify slash (/) for the S3 bucket prefix, the log file bucket folder structure will include a double slash (//), like the following: DOC-EXAMPLE-BUCKET//AWSLogs/aws_account_id
    public var flowLogsS3Prefix: Swift.String?

    public init (
        acceleratorArn: Swift.String? = nil,
        flowLogsEnabled: Swift.Bool? = nil,
        flowLogsS3Bucket: Swift.String? = nil,
        flowLogsS3Prefix: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.flowLogsEnabled = flowLogsEnabled
        self.flowLogsS3Bucket = flowLogsS3Bucket
        self.flowLogsS3Prefix = flowLogsS3Prefix
    }
}

struct UpdateCustomRoutingAcceleratorAttributesInputBody: Swift.Equatable {
    let acceleratorArn: Swift.String?
    let flowLogsEnabled: Swift.Bool?
    let flowLogsS3Bucket: Swift.String?
    let flowLogsS3Prefix: Swift.String?
}

extension UpdateCustomRoutingAcceleratorAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case flowLogsEnabled = "FlowLogsEnabled"
        case flowLogsS3Bucket = "FlowLogsS3Bucket"
        case flowLogsS3Prefix = "FlowLogsS3Prefix"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let flowLogsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .flowLogsEnabled)
        flowLogsEnabled = flowLogsEnabledDecoded
        let flowLogsS3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowLogsS3Bucket)
        flowLogsS3Bucket = flowLogsS3BucketDecoded
        let flowLogsS3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowLogsS3Prefix)
        flowLogsS3Prefix = flowLogsS3PrefixDecoded
    }
}

extension UpdateCustomRoutingAcceleratorAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCustomRoutingAcceleratorAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateCustomRoutingAcceleratorAttributesOutputError: Swift.Error, Swift.Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCustomRoutingAcceleratorAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateCustomRoutingAcceleratorAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.acceleratorAttributes = output.acceleratorAttributes
        } else {
            self.acceleratorAttributes = nil
        }
    }
}

public struct UpdateCustomRoutingAcceleratorAttributesOutputResponse: Swift.Equatable {
    /// Updated custom routing accelerator.
    public var acceleratorAttributes: GlobalAcceleratorClientTypes.CustomRoutingAcceleratorAttributes?

    public init (
        acceleratorAttributes: GlobalAcceleratorClientTypes.CustomRoutingAcceleratorAttributes? = nil
    )
    {
        self.acceleratorAttributes = acceleratorAttributes
    }
}

struct UpdateCustomRoutingAcceleratorAttributesOutputResponseBody: Swift.Equatable {
    let acceleratorAttributes: GlobalAcceleratorClientTypes.CustomRoutingAcceleratorAttributes?
}

extension UpdateCustomRoutingAcceleratorAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorAttributes = "AcceleratorAttributes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorAttributesDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CustomRoutingAcceleratorAttributes.self, forKey: .acceleratorAttributes)
        acceleratorAttributes = acceleratorAttributesDecoded
    }
}

extension UpdateCustomRoutingAcceleratorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case enabled = "Enabled"
        case ipAddressType = "IpAddressType"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = self.acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let ipAddressType = self.ipAddressType {
            try encodeContainer.encode(ipAddressType.rawValue, forKey: .ipAddressType)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateCustomRoutingAcceleratorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateCustomRoutingAcceleratorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the accelerator to update.
    /// This member is required.
    public var acceleratorArn: Swift.String?
    /// Indicates whether an accelerator is enabled. The value is true or false. The default value is true. If the value is set to true, the accelerator cannot be deleted. If set to false, the accelerator can be deleted.
    public var enabled: Swift.Bool?
    /// The IP address type that an accelerator supports. For a custom routing accelerator, the value must be IPV4.
    public var ipAddressType: GlobalAcceleratorClientTypes.IpAddressType?
    /// The name of the accelerator. The name can have a maximum of 64 characters, must contain only alphanumeric characters, periods (.), or hyphens (-), and must not begin or end with a hyphen or period.
    public var name: Swift.String?

    public init (
        acceleratorArn: Swift.String? = nil,
        enabled: Swift.Bool? = nil,
        ipAddressType: GlobalAcceleratorClientTypes.IpAddressType? = nil,
        name: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.enabled = enabled
        self.ipAddressType = ipAddressType
        self.name = name
    }
}

struct UpdateCustomRoutingAcceleratorInputBody: Swift.Equatable {
    let acceleratorArn: Swift.String?
    let name: Swift.String?
    let ipAddressType: GlobalAcceleratorClientTypes.IpAddressType?
    let enabled: Swift.Bool?
}

extension UpdateCustomRoutingAcceleratorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case enabled = "Enabled"
        case ipAddressType = "IpAddressType"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.IpAddressType.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension UpdateCustomRoutingAcceleratorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCustomRoutingAcceleratorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateCustomRoutingAcceleratorOutputError: Swift.Error, Swift.Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCustomRoutingAcceleratorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateCustomRoutingAcceleratorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accelerator = output.accelerator
        } else {
            self.accelerator = nil
        }
    }
}

public struct UpdateCustomRoutingAcceleratorOutputResponse: Swift.Equatable {
    /// Information about the updated custom routing accelerator.
    public var accelerator: GlobalAcceleratorClientTypes.CustomRoutingAccelerator?

    public init (
        accelerator: GlobalAcceleratorClientTypes.CustomRoutingAccelerator? = nil
    )
    {
        self.accelerator = accelerator
    }
}

struct UpdateCustomRoutingAcceleratorOutputResponseBody: Swift.Equatable {
    let accelerator: GlobalAcceleratorClientTypes.CustomRoutingAccelerator?
}

extension UpdateCustomRoutingAcceleratorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accelerator = "Accelerator"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CustomRoutingAccelerator.self, forKey: .accelerator)
        accelerator = acceleratorDecoded
    }
}

extension UpdateCustomRoutingListenerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
        case portRanges = "PortRanges"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listenerArn = self.listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
        if let portRanges = portRanges {
            var portRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portRanges)
            for portrange0 in portRanges {
                try portRangesContainer.encode(portrange0)
            }
        }
    }
}

extension UpdateCustomRoutingListenerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateCustomRoutingListenerInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the listener to update.
    /// This member is required.
    public var listenerArn: Swift.String?
    /// The updated port range to support for connections from clients to your accelerator. If you remove ports that are currently being used by a subnet endpoint, the call fails. Separately, you set port ranges for endpoints. For more information, see [About endpoints for custom routing accelerators](https://docs.aws.amazon.com/global-accelerator/latest/dg/about-custom-routing-endpoints.html).
    /// This member is required.
    public var portRanges: [GlobalAcceleratorClientTypes.PortRange]?

    public init (
        listenerArn: Swift.String? = nil,
        portRanges: [GlobalAcceleratorClientTypes.PortRange]? = nil
    )
    {
        self.listenerArn = listenerArn
        self.portRanges = portRanges
    }
}

struct UpdateCustomRoutingListenerInputBody: Swift.Equatable {
    let listenerArn: Swift.String?
    let portRanges: [GlobalAcceleratorClientTypes.PortRange]?
}

extension UpdateCustomRoutingListenerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
        case portRanges = "PortRanges"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
        let portRangesContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.PortRange?].self, forKey: .portRanges)
        var portRangesDecoded0:[GlobalAcceleratorClientTypes.PortRange]? = nil
        if let portRangesContainer = portRangesContainer {
            portRangesDecoded0 = [GlobalAcceleratorClientTypes.PortRange]()
            for structure0 in portRangesContainer {
                if let structure0 = structure0 {
                    portRangesDecoded0?.append(structure0)
                }
            }
        }
        portRanges = portRangesDecoded0
    }
}

extension UpdateCustomRoutingListenerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCustomRoutingListenerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPortRangeException" : self = .invalidPortRangeException(try InvalidPortRangeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateCustomRoutingListenerOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidPortRangeException(InvalidPortRangeException)
    case limitExceededException(LimitExceededException)
    case listenerNotFoundException(ListenerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCustomRoutingListenerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateCustomRoutingListenerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.listener = output.listener
        } else {
            self.listener = nil
        }
    }
}

public struct UpdateCustomRoutingListenerOutputResponse: Swift.Equatable {
    /// Information for the updated listener for a custom routing accelerator.
    public var listener: GlobalAcceleratorClientTypes.CustomRoutingListener?

    public init (
        listener: GlobalAcceleratorClientTypes.CustomRoutingListener? = nil
    )
    {
        self.listener = listener
    }
}

struct UpdateCustomRoutingListenerOutputResponseBody: Swift.Equatable {
    let listener: GlobalAcceleratorClientTypes.CustomRoutingListener?
}

extension UpdateCustomRoutingListenerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listener = "Listener"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CustomRoutingListener.self, forKey: .listener)
        listener = listenerDecoded
    }
}

extension UpdateEndpointGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointConfigurations = "EndpointConfigurations"
        case endpointGroupArn = "EndpointGroupArn"
        case healthCheckIntervalSeconds = "HealthCheckIntervalSeconds"
        case healthCheckPath = "HealthCheckPath"
        case healthCheckPort = "HealthCheckPort"
        case healthCheckProtocol = "HealthCheckProtocol"
        case portOverrides = "PortOverrides"
        case thresholdCount = "ThresholdCount"
        case trafficDialPercentage = "TrafficDialPercentage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointConfigurations = endpointConfigurations {
            var endpointConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpointConfigurations)
            for endpointconfiguration0 in endpointConfigurations {
                try endpointConfigurationsContainer.encode(endpointconfiguration0)
            }
        }
        if let endpointGroupArn = self.endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
        if let healthCheckIntervalSeconds = self.healthCheckIntervalSeconds {
            try encodeContainer.encode(healthCheckIntervalSeconds, forKey: .healthCheckIntervalSeconds)
        }
        if let healthCheckPath = self.healthCheckPath {
            try encodeContainer.encode(healthCheckPath, forKey: .healthCheckPath)
        }
        if let healthCheckPort = self.healthCheckPort {
            try encodeContainer.encode(healthCheckPort, forKey: .healthCheckPort)
        }
        if let healthCheckProtocol = self.healthCheckProtocol {
            try encodeContainer.encode(healthCheckProtocol.rawValue, forKey: .healthCheckProtocol)
        }
        if let portOverrides = portOverrides {
            var portOverridesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portOverrides)
            for portoverride0 in portOverrides {
                try portOverridesContainer.encode(portoverride0)
            }
        }
        if let thresholdCount = self.thresholdCount {
            try encodeContainer.encode(thresholdCount, forKey: .thresholdCount)
        }
        if let trafficDialPercentage = self.trafficDialPercentage {
            try encodeContainer.encode(trafficDialPercentage, forKey: .trafficDialPercentage)
        }
    }
}

extension UpdateEndpointGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateEndpointGroupInput: Swift.Equatable {
    /// The list of endpoint objects. A resource must be valid and active when you add it as an endpoint.
    public var endpointConfigurations: [GlobalAcceleratorClientTypes.EndpointConfiguration]?
    /// The Amazon Resource Name (ARN) of the endpoint group.
    /// This member is required.
    public var endpointGroupArn: Swift.String?
    /// The time—10 seconds or 30 seconds—between each health check for an endpoint. The default value is 30.
    public var healthCheckIntervalSeconds: Swift.Int?
    /// If the protocol is HTTP/S, then this specifies the path that is the destination for health check targets. The default value is slash (/).
    public var healthCheckPath: Swift.String?
    /// The port that Global Accelerator uses to check the health of endpoints that are part of this endpoint group. The default port is the listener port that this endpoint group is associated with. If the listener port is a list of ports, Global Accelerator uses the first port in the list.
    public var healthCheckPort: Swift.Int?
    /// The protocol that Global Accelerator uses to check the health of endpoints that are part of this endpoint group. The default value is TCP.
    public var healthCheckProtocol: GlobalAcceleratorClientTypes.HealthCheckProtocol?
    /// Override specific listener ports used to route traffic to endpoints that are part of this endpoint group. For example, you can create a port override in which the listener receives user traffic on ports 80 and 443, but your accelerator routes that traffic to ports 1080 and 1443, respectively, on the endpoints. For more information, see [ Overriding listener ports](https://docs.aws.amazon.com/global-accelerator/latest/dg/about-endpoint-groups-port-override.html) in the Global Accelerator Developer Guide.
    public var portOverrides: [GlobalAcceleratorClientTypes.PortOverride]?
    /// The number of consecutive health checks required to set the state of a healthy endpoint to unhealthy, or to set an unhealthy endpoint to healthy. The default value is 3.
    public var thresholdCount: Swift.Int?
    /// The percentage of traffic to send to an Amazon Web Services Region. Additional traffic is distributed to other endpoint groups for this listener. Use this action to increase (dial up) or decrease (dial down) traffic to a specific Region. The percentage is applied to the traffic that would otherwise have been routed to the Region based on optimal routing. The default value is 100.
    public var trafficDialPercentage: Swift.Float?

    public init (
        endpointConfigurations: [GlobalAcceleratorClientTypes.EndpointConfiguration]? = nil,
        endpointGroupArn: Swift.String? = nil,
        healthCheckIntervalSeconds: Swift.Int? = nil,
        healthCheckPath: Swift.String? = nil,
        healthCheckPort: Swift.Int? = nil,
        healthCheckProtocol: GlobalAcceleratorClientTypes.HealthCheckProtocol? = nil,
        portOverrides: [GlobalAcceleratorClientTypes.PortOverride]? = nil,
        thresholdCount: Swift.Int? = nil,
        trafficDialPercentage: Swift.Float? = nil
    )
    {
        self.endpointConfigurations = endpointConfigurations
        self.endpointGroupArn = endpointGroupArn
        self.healthCheckIntervalSeconds = healthCheckIntervalSeconds
        self.healthCheckPath = healthCheckPath
        self.healthCheckPort = healthCheckPort
        self.healthCheckProtocol = healthCheckProtocol
        self.portOverrides = portOverrides
        self.thresholdCount = thresholdCount
        self.trafficDialPercentage = trafficDialPercentage
    }
}

struct UpdateEndpointGroupInputBody: Swift.Equatable {
    let endpointGroupArn: Swift.String?
    let endpointConfigurations: [GlobalAcceleratorClientTypes.EndpointConfiguration]?
    let trafficDialPercentage: Swift.Float?
    let healthCheckPort: Swift.Int?
    let healthCheckProtocol: GlobalAcceleratorClientTypes.HealthCheckProtocol?
    let healthCheckPath: Swift.String?
    let healthCheckIntervalSeconds: Swift.Int?
    let thresholdCount: Swift.Int?
    let portOverrides: [GlobalAcceleratorClientTypes.PortOverride]?
}

extension UpdateEndpointGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointConfigurations = "EndpointConfigurations"
        case endpointGroupArn = "EndpointGroupArn"
        case healthCheckIntervalSeconds = "HealthCheckIntervalSeconds"
        case healthCheckPath = "HealthCheckPath"
        case healthCheckPort = "HealthCheckPort"
        case healthCheckProtocol = "HealthCheckProtocol"
        case portOverrides = "PortOverrides"
        case thresholdCount = "ThresholdCount"
        case trafficDialPercentage = "TrafficDialPercentage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
        let endpointConfigurationsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.EndpointConfiguration?].self, forKey: .endpointConfigurations)
        var endpointConfigurationsDecoded0:[GlobalAcceleratorClientTypes.EndpointConfiguration]? = nil
        if let endpointConfigurationsContainer = endpointConfigurationsContainer {
            endpointConfigurationsDecoded0 = [GlobalAcceleratorClientTypes.EndpointConfiguration]()
            for structure0 in endpointConfigurationsContainer {
                if let structure0 = structure0 {
                    endpointConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        endpointConfigurations = endpointConfigurationsDecoded0
        let trafficDialPercentageDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .trafficDialPercentage)
        trafficDialPercentage = trafficDialPercentageDecoded
        let healthCheckPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthCheckPort)
        healthCheckPort = healthCheckPortDecoded
        let healthCheckProtocolDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.HealthCheckProtocol.self, forKey: .healthCheckProtocol)
        healthCheckProtocol = healthCheckProtocolDecoded
        let healthCheckPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .healthCheckPath)
        healthCheckPath = healthCheckPathDecoded
        let healthCheckIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthCheckIntervalSeconds)
        healthCheckIntervalSeconds = healthCheckIntervalSecondsDecoded
        let thresholdCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .thresholdCount)
        thresholdCount = thresholdCountDecoded
        let portOverridesContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.PortOverride?].self, forKey: .portOverrides)
        var portOverridesDecoded0:[GlobalAcceleratorClientTypes.PortOverride]? = nil
        if let portOverridesContainer = portOverridesContainer {
            portOverridesDecoded0 = [GlobalAcceleratorClientTypes.PortOverride]()
            for structure0 in portOverridesContainer {
                if let structure0 = structure0 {
                    portOverridesDecoded0?.append(structure0)
                }
            }
        }
        portOverrides = portOverridesDecoded0
    }
}

extension UpdateEndpointGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateEndpointGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointGroupNotFoundException" : self = .endpointGroupNotFoundException(try EndpointGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateEndpointGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case endpointGroupNotFoundException(EndpointGroupNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateEndpointGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateEndpointGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpointGroup = output.endpointGroup
        } else {
            self.endpointGroup = nil
        }
    }
}

public struct UpdateEndpointGroupOutputResponse: Swift.Equatable {
    /// The information about the endpoint group that was updated.
    public var endpointGroup: GlobalAcceleratorClientTypes.EndpointGroup?

    public init (
        endpointGroup: GlobalAcceleratorClientTypes.EndpointGroup? = nil
    )
    {
        self.endpointGroup = endpointGroup
    }
}

struct UpdateEndpointGroupOutputResponseBody: Swift.Equatable {
    let endpointGroup: GlobalAcceleratorClientTypes.EndpointGroup?
}

extension UpdateEndpointGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroup = "EndpointGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.EndpointGroup.self, forKey: .endpointGroup)
        endpointGroup = endpointGroupDecoded
    }
}

extension UpdateListenerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientAffinity = "ClientAffinity"
        case listenerArn = "ListenerArn"
        case portRanges = "PortRanges"
        case `protocol` = "Protocol"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientAffinity = self.clientAffinity {
            try encodeContainer.encode(clientAffinity.rawValue, forKey: .clientAffinity)
        }
        if let listenerArn = self.listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
        if let portRanges = portRanges {
            var portRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portRanges)
            for portrange0 in portRanges {
                try portRangesContainer.encode(portrange0)
            }
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
    }
}

extension UpdateListenerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateListenerInput: Swift.Equatable {
    /// Client affinity lets you direct all requests from a user to the same endpoint, if you have stateful applications, regardless of the port and protocol of the client request. Client affinity gives you control over whether to always route each client to the same specific endpoint. Global Accelerator uses a consistent-flow hashing algorithm to choose the optimal endpoint for a connection. If client affinity is NONE, Global Accelerator uses the "five-tuple" (5-tuple) properties—source IP address, source port, destination IP address, destination port, and protocol—to select the hash value, and then chooses the best endpoint. However, with this setting, if someone uses different ports to connect to Global Accelerator, their connections might not be always routed to the same endpoint because the hash value changes. If you want a given client to always be routed to the same endpoint, set client affinity to SOURCE_IP instead. When you use the SOURCE_IP setting, Global Accelerator uses the "two-tuple" (2-tuple) properties— source (client) IP address and destination IP address—to select the hash value. The default value is NONE.
    public var clientAffinity: GlobalAcceleratorClientTypes.ClientAffinity?
    /// The Amazon Resource Name (ARN) of the listener to update.
    /// This member is required.
    public var listenerArn: Swift.String?
    /// The updated list of port ranges for the connections from clients to the accelerator.
    public var portRanges: [GlobalAcceleratorClientTypes.PortRange]?
    /// The updated protocol for the connections from clients to the accelerator.
    public var `protocol`: GlobalAcceleratorClientTypes.ModelProtocol?

    public init (
        clientAffinity: GlobalAcceleratorClientTypes.ClientAffinity? = nil,
        listenerArn: Swift.String? = nil,
        portRanges: [GlobalAcceleratorClientTypes.PortRange]? = nil,
        `protocol`: GlobalAcceleratorClientTypes.ModelProtocol? = nil
    )
    {
        self.clientAffinity = clientAffinity
        self.listenerArn = listenerArn
        self.portRanges = portRanges
        self.`protocol` = `protocol`
    }
}

struct UpdateListenerInputBody: Swift.Equatable {
    let listenerArn: Swift.String?
    let portRanges: [GlobalAcceleratorClientTypes.PortRange]?
    let `protocol`: GlobalAcceleratorClientTypes.ModelProtocol?
    let clientAffinity: GlobalAcceleratorClientTypes.ClientAffinity?
}

extension UpdateListenerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientAffinity = "ClientAffinity"
        case listenerArn = "ListenerArn"
        case portRanges = "PortRanges"
        case `protocol` = "Protocol"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
        let portRangesContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.PortRange?].self, forKey: .portRanges)
        var portRangesDecoded0:[GlobalAcceleratorClientTypes.PortRange]? = nil
        if let portRangesContainer = portRangesContainer {
            portRangesDecoded0 = [GlobalAcceleratorClientTypes.PortRange]()
            for structure0 in portRangesContainer {
                if let structure0 = structure0 {
                    portRangesDecoded0?.append(structure0)
                }
            }
        }
        portRanges = portRangesDecoded0
        let protocolDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.ModelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let clientAffinityDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.ClientAffinity.self, forKey: .clientAffinity)
        clientAffinity = clientAffinityDecoded
    }
}

extension UpdateListenerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateListenerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPortRangeException" : self = .invalidPortRangeException(try InvalidPortRangeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateListenerOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidPortRangeException(InvalidPortRangeException)
    case limitExceededException(LimitExceededException)
    case listenerNotFoundException(ListenerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateListenerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateListenerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.listener = output.listener
        } else {
            self.listener = nil
        }
    }
}

public struct UpdateListenerOutputResponse: Swift.Equatable {
    /// Information for the updated listener.
    public var listener: GlobalAcceleratorClientTypes.Listener?

    public init (
        listener: GlobalAcceleratorClientTypes.Listener? = nil
    )
    {
        self.listener = listener
    }
}

struct UpdateListenerOutputResponseBody: Swift.Equatable {
    let listener: GlobalAcceleratorClientTypes.Listener?
}

extension UpdateListenerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listener = "Listener"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.Listener.self, forKey: .listener)
        listener = listenerDecoded
    }
}

extension WithdrawByoipCidrInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidr = "Cidr"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidr = self.cidr {
            try encodeContainer.encode(cidr, forKey: .cidr)
        }
    }
}

extension WithdrawByoipCidrInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct WithdrawByoipCidrInput: Swift.Equatable {
    /// The address range, in CIDR notation.
    /// This member is required.
    public var cidr: Swift.String?

    public init (
        cidr: Swift.String? = nil
    )
    {
        self.cidr = cidr
    }
}

struct WithdrawByoipCidrInputBody: Swift.Equatable {
    let cidr: Swift.String?
}

extension WithdrawByoipCidrInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidr = "Cidr"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cidr)
        cidr = cidrDecoded
    }
}

extension WithdrawByoipCidrOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension WithdrawByoipCidrOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ByoipCidrNotFoundException" : self = .byoipCidrNotFoundException(try ByoipCidrNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncorrectCidrStateException" : self = .incorrectCidrStateException(try IncorrectCidrStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum WithdrawByoipCidrOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case byoipCidrNotFoundException(ByoipCidrNotFoundException)
    case incorrectCidrStateException(IncorrectCidrStateException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension WithdrawByoipCidrOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: WithdrawByoipCidrOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.byoipCidr = output.byoipCidr
        } else {
            self.byoipCidr = nil
        }
    }
}

public struct WithdrawByoipCidrOutputResponse: Swift.Equatable {
    /// Information about the address pool.
    public var byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr?

    public init (
        byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr? = nil
    )
    {
        self.byoipCidr = byoipCidr
    }
}

struct WithdrawByoipCidrOutputResponseBody: Swift.Equatable {
    let byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr?
}

extension WithdrawByoipCidrOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case byoipCidr = "ByoipCidr"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let byoipCidrDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.ByoipCidr.self, forKey: .byoipCidr)
        byoipCidr = byoipCidrDecoded
    }
}
