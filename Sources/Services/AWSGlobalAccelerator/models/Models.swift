// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension GlobalAcceleratorClientTypes.Accelerator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case createdTime = "CreatedTime"
        case dnsName = "DnsName"
        case dualStackDnsName = "DualStackDnsName"
        case enabled = "Enabled"
        case events = "Events"
        case ipAddressType = "IpAddressType"
        case ipSets = "IpSets"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = self.acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let dnsName = self.dnsName {
            try encodeContainer.encode(dnsName, forKey: .dnsName)
        }
        if let dualStackDnsName = self.dualStackDnsName {
            try encodeContainer.encode(dualStackDnsName, forKey: .dualStackDnsName)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for acceleratorevent0 in events {
                try eventsContainer.encode(acceleratorevent0)
            }
        }
        if let ipAddressType = self.ipAddressType {
            try encodeContainer.encode(ipAddressType.rawValue, forKey: .ipAddressType)
        }
        if let ipSets = ipSets {
            var ipSetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipSets)
            for ipset0 in ipSets {
                try ipSetsContainer.encode(ipset0)
            }
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.IpAddressType.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let ipSetsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.IpSet?].self, forKey: .ipSets)
        var ipSetsDecoded0:[GlobalAcceleratorClientTypes.IpSet]? = nil
        if let ipSetsContainer = ipSetsContainer {
            ipSetsDecoded0 = [GlobalAcceleratorClientTypes.IpSet]()
            for structure0 in ipSetsContainer {
                if let structure0 = structure0 {
                    ipSetsDecoded0?.append(structure0)
                }
            }
        }
        ipSets = ipSetsDecoded0
        let dnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dnsName)
        dnsName = dnsNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.AcceleratorStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let dualStackDnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dualStackDnsName)
        dualStackDnsName = dualStackDnsNameDecoded
        let eventsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.AcceleratorEvent?].self, forKey: .events)
        var eventsDecoded0:[GlobalAcceleratorClientTypes.AcceleratorEvent]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [GlobalAcceleratorClientTypes.AcceleratorEvent]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
    }
}

extension GlobalAcceleratorClientTypes {
    /// An accelerator is a complex type that includes one or more listeners that process inbound connections and then direct traffic to one or more endpoint groups, each of which includes endpoints, such as load balancers.
    public struct Accelerator: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the accelerator.
        public var acceleratorArn: Swift.String?
        /// The date and time that the accelerator was created.
        public var createdTime: ClientRuntime.Date?
        /// The Domain Name System (DNS) name that Global Accelerator creates that points to an accelerator's static IPv4 addresses. The naming convention for the DNS name for an accelerator is the following: A lowercase letter a, followed by a 16-bit random hex string, followed by .awsglobalaccelerator.com. For example: a1234567890abcdef.awsglobalaccelerator.com. If you have a dual-stack accelerator, you also have a second DNS name, DualStackDnsName, that points to both the A record and the AAAA record for all four static addresses for the accelerator: two IPv4 addresses and two IPv6 addresses. For more information about the default DNS name, see [ Support for DNS addressing in Global Accelerator](https://docs.aws.amazon.com/global-accelerator/latest/dg/dns-addressing-custom-domains.dns-addressing.html) in the Global Accelerator Developer Guide.
        public var dnsName: Swift.String?
        /// The Domain Name System (DNS) name that Global Accelerator creates that points to a dual-stack accelerator's four static IP addresses: two IPv4 addresses and two IPv6 addresses. The naming convention for the dual-stack DNS name is the following: A lowercase letter a, followed by a 16-bit random hex string, followed by .dualstack.awsglobalaccelerator.com. For example: a1234567890abcdef.dualstack.awsglobalaccelerator.com. Note: Global Accelerator also assigns a default DNS name, DnsName, to your accelerator that points just to the static IPv4 addresses. For more information, see [ Support for DNS addressing in Global Accelerator](https://docs.aws.amazon.com/global-accelerator/latest/dg/about-accelerators.html#about-accelerators.dns-addressing) in the Global Accelerator Developer Guide.
        public var dualStackDnsName: Swift.String?
        /// Indicates whether the accelerator is enabled. The value is true or false. The default value is true. If the value is set to true, the accelerator cannot be deleted. If set to false, accelerator can be deleted.
        public var enabled: Swift.Bool?
        /// A history of changes that you make to an accelerator in Global Accelerator.
        public var events: [GlobalAcceleratorClientTypes.AcceleratorEvent]?
        /// The IP address type that an accelerator supports. For a standard accelerator, the value can be IPV4 or DUAL_STACK.
        public var ipAddressType: GlobalAcceleratorClientTypes.IpAddressType?
        /// The static IP addresses that Global Accelerator associates with the accelerator.
        public var ipSets: [GlobalAcceleratorClientTypes.IpSet]?
        /// The date and time that the accelerator was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The name of the accelerator. The name must contain only alphanumeric characters or hyphens (-), and must not begin or end with a hyphen.
        public var name: Swift.String?
        /// Describes the deployment status of the accelerator.
        public var status: GlobalAcceleratorClientTypes.AcceleratorStatus?

        public init(
            acceleratorArn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            dnsName: Swift.String? = nil,
            dualStackDnsName: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            events: [GlobalAcceleratorClientTypes.AcceleratorEvent]? = nil,
            ipAddressType: GlobalAcceleratorClientTypes.IpAddressType? = nil,
            ipSets: [GlobalAcceleratorClientTypes.IpSet]? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: GlobalAcceleratorClientTypes.AcceleratorStatus? = nil
        )
        {
            self.acceleratorArn = acceleratorArn
            self.createdTime = createdTime
            self.dnsName = dnsName
            self.dualStackDnsName = dualStackDnsName
            self.enabled = enabled
            self.events = events
            self.ipAddressType = ipAddressType
            self.ipSets = ipSets
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.status = status
        }
    }

}

extension GlobalAcceleratorClientTypes.AcceleratorAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowLogsEnabled = "FlowLogsEnabled"
        case flowLogsS3Bucket = "FlowLogsS3Bucket"
        case flowLogsS3Prefix = "FlowLogsS3Prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowLogsEnabled = self.flowLogsEnabled {
            try encodeContainer.encode(flowLogsEnabled, forKey: .flowLogsEnabled)
        }
        if let flowLogsS3Bucket = self.flowLogsS3Bucket {
            try encodeContainer.encode(flowLogsS3Bucket, forKey: .flowLogsS3Bucket)
        }
        if let flowLogsS3Prefix = self.flowLogsS3Prefix {
            try encodeContainer.encode(flowLogsS3Prefix, forKey: .flowLogsS3Prefix)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowLogsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .flowLogsEnabled)
        flowLogsEnabled = flowLogsEnabledDecoded
        let flowLogsS3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowLogsS3Bucket)
        flowLogsS3Bucket = flowLogsS3BucketDecoded
        let flowLogsS3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowLogsS3Prefix)
        flowLogsS3Prefix = flowLogsS3PrefixDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    /// Attributes of an accelerator.
    public struct AcceleratorAttributes: Swift.Equatable {
        /// Indicates whether flow logs are enabled. The default value is false. If the value is true, FlowLogsS3Bucket and FlowLogsS3Prefix must be specified. For more information, see [Flow logs](https://docs.aws.amazon.com/global-accelerator/latest/dg/monitoring-global-accelerator.flow-logs.html) in the Global Accelerator Developer Guide.
        public var flowLogsEnabled: Swift.Bool?
        /// The name of the Amazon S3 bucket for the flow logs. Attribute is required if FlowLogsEnabled is true. The bucket must exist and have a bucket policy that grants Global Accelerator permission to write to the bucket.
        public var flowLogsS3Bucket: Swift.String?
        /// The prefix for the location in the Amazon S3 bucket for the flow logs. Attribute is required if FlowLogsEnabled is true. If you specify slash (/) for the S3 bucket prefix, the log file bucket folder structure will include a double slash (//), like the following: s3-bucket_name//AWSLogs/aws_account_id
        public var flowLogsS3Prefix: Swift.String?

        public init(
            flowLogsEnabled: Swift.Bool? = nil,
            flowLogsS3Bucket: Swift.String? = nil,
            flowLogsS3Prefix: Swift.String? = nil
        )
        {
            self.flowLogsEnabled = flowLogsEnabled
            self.flowLogsS3Bucket = flowLogsS3Bucket
            self.flowLogsS3Prefix = flowLogsS3Prefix
        }
    }

}

extension GlobalAcceleratorClientTypes.AcceleratorEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .epochSeconds, forKey: .timestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timestamp)
        timestamp = timestampDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    /// A complex type that contains a Timestamp value and Message for changes that you make to an accelerator in Global Accelerator. Messages stored here provide progress or error information when you update an accelerator from IPv4 to dual-stack, or from dual-stack to IPv4. Global Accelerator stores a maximum of ten event messages.
    public struct AcceleratorEvent: Swift.Equatable {
        /// A string that contains an Event message describing changes or errors when you update an accelerator in Global Accelerator from IPv4 to dual-stack, or dual-stack to IPv4.
        public var message: Swift.String?
        /// A timestamp for when you update an accelerator in Global Accelerator from IPv4 to dual-stack, or dual-stack to IPv4.
        public var timestamp: ClientRuntime.Date?

        public init(
            message: Swift.String? = nil,
            timestamp: ClientRuntime.Date? = nil
        )
        {
            self.message = message
            self.timestamp = timestamp
        }
    }

}

extension AcceleratorNotDisabledException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AcceleratorNotDisabledExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The accelerator that you specified could not be disabled.
public struct AcceleratorNotDisabledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AcceleratorNotDisabledException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AcceleratorNotDisabledExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AcceleratorNotDisabledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AcceleratorNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AcceleratorNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The accelerator that you specified doesn't exist.
public struct AcceleratorNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AcceleratorNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AcceleratorNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AcceleratorNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    public enum AcceleratorStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deployed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [AcceleratorStatus] {
            return [
                .deployed,
                .inProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deployed: return "DEPLOYED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AcceleratorStatus(rawValue: rawValue) ?? AcceleratorStatus.sdkUnknown(rawValue)
        }
    }
}

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You don't have access permission.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AddCustomRoutingEndpointsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointConfigurations = "EndpointConfigurations"
        case endpointGroupArn = "EndpointGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointConfigurations = endpointConfigurations {
            var endpointConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpointConfigurations)
            for customroutingendpointconfiguration0 in endpointConfigurations {
                try endpointConfigurationsContainer.encode(customroutingendpointconfiguration0)
            }
        }
        if let endpointGroupArn = self.endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
    }
}

extension AddCustomRoutingEndpointsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AddCustomRoutingEndpointsInput: Swift.Equatable {
    /// The list of endpoint objects to add to a custom routing accelerator.
    /// This member is required.
    public var endpointConfigurations: [GlobalAcceleratorClientTypes.CustomRoutingEndpointConfiguration]?
    /// The Amazon Resource Name (ARN) of the endpoint group for the custom routing endpoint.
    /// This member is required.
    public var endpointGroupArn: Swift.String?

    public init(
        endpointConfigurations: [GlobalAcceleratorClientTypes.CustomRoutingEndpointConfiguration]? = nil,
        endpointGroupArn: Swift.String? = nil
    )
    {
        self.endpointConfigurations = endpointConfigurations
        self.endpointGroupArn = endpointGroupArn
    }
}

struct AddCustomRoutingEndpointsInputBody: Swift.Equatable {
    let endpointConfigurations: [GlobalAcceleratorClientTypes.CustomRoutingEndpointConfiguration]?
    let endpointGroupArn: Swift.String?
}

extension AddCustomRoutingEndpointsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointConfigurations = "EndpointConfigurations"
        case endpointGroupArn = "EndpointGroupArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointConfigurationsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.CustomRoutingEndpointConfiguration?].self, forKey: .endpointConfigurations)
        var endpointConfigurationsDecoded0:[GlobalAcceleratorClientTypes.CustomRoutingEndpointConfiguration]? = nil
        if let endpointConfigurationsContainer = endpointConfigurationsContainer {
            endpointConfigurationsDecoded0 = [GlobalAcceleratorClientTypes.CustomRoutingEndpointConfiguration]()
            for structure0 in endpointConfigurationsContainer {
                if let structure0 = structure0 {
                    endpointConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        endpointConfigurations = endpointConfigurationsDecoded0
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
    }
}

extension AddCustomRoutingEndpointsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AddCustomRoutingEndpointsOutputBody = try responseDecoder.decode(responseBody: data)
            self.endpointDescriptions = output.endpointDescriptions
            self.endpointGroupArn = output.endpointGroupArn
        } else {
            self.endpointDescriptions = nil
            self.endpointGroupArn = nil
        }
    }
}

public struct AddCustomRoutingEndpointsOutput: Swift.Equatable {
    /// The endpoint objects added to the custom routing accelerator.
    public var endpointDescriptions: [GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription]?
    /// The Amazon Resource Name (ARN) of the endpoint group for the custom routing endpoint.
    public var endpointGroupArn: Swift.String?

    public init(
        endpointDescriptions: [GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription]? = nil,
        endpointGroupArn: Swift.String? = nil
    )
    {
        self.endpointDescriptions = endpointDescriptions
        self.endpointGroupArn = endpointGroupArn
    }
}

struct AddCustomRoutingEndpointsOutputBody: Swift.Equatable {
    let endpointDescriptions: [GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription]?
    let endpointGroupArn: Swift.String?
}

extension AddCustomRoutingEndpointsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointDescriptions = "EndpointDescriptions"
        case endpointGroupArn = "EndpointGroupArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDescriptionsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription?].self, forKey: .endpointDescriptions)
        var endpointDescriptionsDecoded0:[GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription]? = nil
        if let endpointDescriptionsContainer = endpointDescriptionsContainer {
            endpointDescriptionsDecoded0 = [GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription]()
            for structure0 in endpointDescriptionsContainer {
                if let structure0 = structure0 {
                    endpointDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        endpointDescriptions = endpointDescriptionsDecoded0
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
    }
}

enum AddCustomRoutingEndpointsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EndpointAlreadyExistsException": return try await EndpointAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EndpointGroupNotFoundException": return try await EndpointGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AddEndpointsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointConfigurations = "EndpointConfigurations"
        case endpointGroupArn = "EndpointGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointConfigurations = endpointConfigurations {
            var endpointConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpointConfigurations)
            for endpointconfiguration0 in endpointConfigurations {
                try endpointConfigurationsContainer.encode(endpointconfiguration0)
            }
        }
        if let endpointGroupArn = self.endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
    }
}

extension AddEndpointsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AddEndpointsInput: Swift.Equatable {
    /// The list of endpoint objects.
    /// This member is required.
    public var endpointConfigurations: [GlobalAcceleratorClientTypes.EndpointConfiguration]?
    /// The Amazon Resource Name (ARN) of the endpoint group.
    /// This member is required.
    public var endpointGroupArn: Swift.String?

    public init(
        endpointConfigurations: [GlobalAcceleratorClientTypes.EndpointConfiguration]? = nil,
        endpointGroupArn: Swift.String? = nil
    )
    {
        self.endpointConfigurations = endpointConfigurations
        self.endpointGroupArn = endpointGroupArn
    }
}

struct AddEndpointsInputBody: Swift.Equatable {
    let endpointConfigurations: [GlobalAcceleratorClientTypes.EndpointConfiguration]?
    let endpointGroupArn: Swift.String?
}

extension AddEndpointsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointConfigurations = "EndpointConfigurations"
        case endpointGroupArn = "EndpointGroupArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointConfigurationsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.EndpointConfiguration?].self, forKey: .endpointConfigurations)
        var endpointConfigurationsDecoded0:[GlobalAcceleratorClientTypes.EndpointConfiguration]? = nil
        if let endpointConfigurationsContainer = endpointConfigurationsContainer {
            endpointConfigurationsDecoded0 = [GlobalAcceleratorClientTypes.EndpointConfiguration]()
            for structure0 in endpointConfigurationsContainer {
                if let structure0 = structure0 {
                    endpointConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        endpointConfigurations = endpointConfigurationsDecoded0
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
    }
}

extension AddEndpointsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AddEndpointsOutputBody = try responseDecoder.decode(responseBody: data)
            self.endpointDescriptions = output.endpointDescriptions
            self.endpointGroupArn = output.endpointGroupArn
        } else {
            self.endpointDescriptions = nil
            self.endpointGroupArn = nil
        }
    }
}

public struct AddEndpointsOutput: Swift.Equatable {
    /// The list of endpoint objects.
    public var endpointDescriptions: [GlobalAcceleratorClientTypes.EndpointDescription]?
    /// The Amazon Resource Name (ARN) of the endpoint group.
    public var endpointGroupArn: Swift.String?

    public init(
        endpointDescriptions: [GlobalAcceleratorClientTypes.EndpointDescription]? = nil,
        endpointGroupArn: Swift.String? = nil
    )
    {
        self.endpointDescriptions = endpointDescriptions
        self.endpointGroupArn = endpointGroupArn
    }
}

struct AddEndpointsOutputBody: Swift.Equatable {
    let endpointDescriptions: [GlobalAcceleratorClientTypes.EndpointDescription]?
    let endpointGroupArn: Swift.String?
}

extension AddEndpointsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointDescriptions = "EndpointDescriptions"
        case endpointGroupArn = "EndpointGroupArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDescriptionsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.EndpointDescription?].self, forKey: .endpointDescriptions)
        var endpointDescriptionsDecoded0:[GlobalAcceleratorClientTypes.EndpointDescription]? = nil
        if let endpointDescriptionsContainer = endpointDescriptionsContainer {
            endpointDescriptionsDecoded0 = [GlobalAcceleratorClientTypes.EndpointDescription]()
            for structure0 in endpointDescriptionsContainer {
                if let structure0 = structure0 {
                    endpointDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        endpointDescriptions = endpointDescriptionsDecoded0
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
    }
}

enum AddEndpointsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EndpointGroupNotFoundException": return try await EndpointGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TransactionInProgressException": return try await TransactionInProgressException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AdvertiseByoipCidrInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidr = "Cidr"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidr = self.cidr {
            try encodeContainer.encode(cidr, forKey: .cidr)
        }
    }
}

extension AdvertiseByoipCidrInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AdvertiseByoipCidrInput: Swift.Equatable {
    /// The address range, in CIDR notation. This must be the exact range that you provisioned. You can't advertise only a portion of the provisioned range.
    /// This member is required.
    public var cidr: Swift.String?

    public init(
        cidr: Swift.String? = nil
    )
    {
        self.cidr = cidr
    }
}

struct AdvertiseByoipCidrInputBody: Swift.Equatable {
    let cidr: Swift.String?
}

extension AdvertiseByoipCidrInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidr = "Cidr"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cidr)
        cidr = cidrDecoded
    }
}

extension AdvertiseByoipCidrOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AdvertiseByoipCidrOutputBody = try responseDecoder.decode(responseBody: data)
            self.byoipCidr = output.byoipCidr
        } else {
            self.byoipCidr = nil
        }
    }
}

public struct AdvertiseByoipCidrOutput: Swift.Equatable {
    /// Information about the address range.
    public var byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr?

    public init(
        byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr? = nil
    )
    {
        self.byoipCidr = byoipCidr
    }
}

struct AdvertiseByoipCidrOutputBody: Swift.Equatable {
    let byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr?
}

extension AdvertiseByoipCidrOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case byoipCidr = "ByoipCidr"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let byoipCidrDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.ByoipCidr.self, forKey: .byoipCidr)
        byoipCidr = byoipCidrDecoded
    }
}

enum AdvertiseByoipCidrOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ByoipCidrNotFoundException": return try await ByoipCidrNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IncorrectCidrStateException": return try await IncorrectCidrStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AllowCustomRoutingTrafficInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowAllTrafficToEndpoint = "AllowAllTrafficToEndpoint"
        case destinationAddresses = "DestinationAddresses"
        case destinationPorts = "DestinationPorts"
        case endpointGroupArn = "EndpointGroupArn"
        case endpointId = "EndpointId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowAllTrafficToEndpoint = self.allowAllTrafficToEndpoint {
            try encodeContainer.encode(allowAllTrafficToEndpoint, forKey: .allowAllTrafficToEndpoint)
        }
        if let destinationAddresses = destinationAddresses {
            var destinationAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationAddresses)
            for ipaddress0 in destinationAddresses {
                try destinationAddressesContainer.encode(ipaddress0)
            }
        }
        if let destinationPorts = destinationPorts {
            var destinationPortsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationPorts)
            for portnumber0 in destinationPorts {
                try destinationPortsContainer.encode(portnumber0)
            }
        }
        if let endpointGroupArn = self.endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
        if let endpointId = self.endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
    }
}

extension AllowCustomRoutingTrafficInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AllowCustomRoutingTrafficInput: Swift.Equatable {
    /// Indicates whether all destination IP addresses and ports for a specified VPC subnet endpoint can receive traffic from a custom routing accelerator. The value is TRUE or FALSE. When set to TRUE, all destinations in the custom routing VPC subnet can receive traffic. Note that you cannot specify destination IP addresses and ports when the value is set to TRUE. When set to FALSE (or not specified), you must specify a list of destination IP addresses that are allowed to receive traffic. A list of ports is optional. If you don't specify a list of ports, the ports that can accept traffic is the same as the ports configured for the endpoint group. The default value is FALSE.
    public var allowAllTrafficToEndpoint: Swift.Bool?
    /// A list of specific Amazon EC2 instance IP addresses (destination addresses) in a subnet that you want to allow to receive traffic. The IP addresses must be a subset of the IP addresses that you specified for the endpoint group. DestinationAddresses is required if AllowAllTrafficToEndpoint is FALSE or is not specified.
    public var destinationAddresses: [Swift.String]?
    /// A list of specific Amazon EC2 instance ports (destination ports) that you want to allow to receive traffic.
    public var destinationPorts: [Swift.Int]?
    /// The Amazon Resource Name (ARN) of the endpoint group.
    /// This member is required.
    public var endpointGroupArn: Swift.String?
    /// An ID for the endpoint. For custom routing accelerators, this is the virtual private cloud (VPC) subnet ID.
    /// This member is required.
    public var endpointId: Swift.String?

    public init(
        allowAllTrafficToEndpoint: Swift.Bool? = nil,
        destinationAddresses: [Swift.String]? = nil,
        destinationPorts: [Swift.Int]? = nil,
        endpointGroupArn: Swift.String? = nil,
        endpointId: Swift.String? = nil
    )
    {
        self.allowAllTrafficToEndpoint = allowAllTrafficToEndpoint
        self.destinationAddresses = destinationAddresses
        self.destinationPorts = destinationPorts
        self.endpointGroupArn = endpointGroupArn
        self.endpointId = endpointId
    }
}

struct AllowCustomRoutingTrafficInputBody: Swift.Equatable {
    let endpointGroupArn: Swift.String?
    let endpointId: Swift.String?
    let destinationAddresses: [Swift.String]?
    let destinationPorts: [Swift.Int]?
    let allowAllTrafficToEndpoint: Swift.Bool?
}

extension AllowCustomRoutingTrafficInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowAllTrafficToEndpoint = "AllowAllTrafficToEndpoint"
        case destinationAddresses = "DestinationAddresses"
        case destinationPorts = "DestinationPorts"
        case endpointGroupArn = "EndpointGroupArn"
        case endpointId = "EndpointId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
        let destinationAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .destinationAddresses)
        var destinationAddressesDecoded0:[Swift.String]? = nil
        if let destinationAddressesContainer = destinationAddressesContainer {
            destinationAddressesDecoded0 = [Swift.String]()
            for string0 in destinationAddressesContainer {
                if let string0 = string0 {
                    destinationAddressesDecoded0?.append(string0)
                }
            }
        }
        destinationAddresses = destinationAddressesDecoded0
        let destinationPortsContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .destinationPorts)
        var destinationPortsDecoded0:[Swift.Int]? = nil
        if let destinationPortsContainer = destinationPortsContainer {
            destinationPortsDecoded0 = [Swift.Int]()
            for integer0 in destinationPortsContainer {
                if let integer0 = integer0 {
                    destinationPortsDecoded0?.append(integer0)
                }
            }
        }
        destinationPorts = destinationPortsDecoded0
        let allowAllTrafficToEndpointDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowAllTrafficToEndpoint)
        allowAllTrafficToEndpoint = allowAllTrafficToEndpointDecoded
    }
}

extension AllowCustomRoutingTrafficOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AllowCustomRoutingTrafficOutput: Swift.Equatable {

    public init() { }
}

enum AllowCustomRoutingTrafficOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EndpointGroupNotFoundException": return try await EndpointGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociatedEndpointGroupFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociatedEndpointGroupFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The listener that you specified has an endpoint group associated with it. You must remove all dependent resources from a listener before you can delete it.
public struct AssociatedEndpointGroupFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AssociatedEndpointGroupFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AssociatedEndpointGroupFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AssociatedEndpointGroupFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AssociatedListenerFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociatedListenerFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The accelerator that you specified has a listener associated with it. You must remove all dependent resources from an accelerator before you can delete it.
public struct AssociatedListenerFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AssociatedListenerFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AssociatedListenerFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AssociatedListenerFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GlobalAcceleratorClientTypes.ByoipCidr: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidr = "Cidr"
        case events = "Events"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidr = self.cidr {
            try encodeContainer.encode(cidr, forKey: .cidr)
        }
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for byoipcidrevent0 in events {
                try eventsContainer.encode(byoipcidrevent0)
            }
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cidr)
        cidr = cidrDecoded
        let stateDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.ByoipCidrState.self, forKey: .state)
        state = stateDecoded
        let eventsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.ByoipCidrEvent?].self, forKey: .events)
        var eventsDecoded0:[GlobalAcceleratorClientTypes.ByoipCidrEvent]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [GlobalAcceleratorClientTypes.ByoipCidrEvent]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
    }
}

extension GlobalAcceleratorClientTypes {
    /// Information about an IP address range that is provisioned for use with your Amazon Web Services resources through bring your own IP address (BYOIP). The following describes each BYOIP State that your IP address range can be in.
    ///
    /// * PENDING_PROVISIONING  Youve submitted a request to provision an IP address range but it is not yet provisioned with Global Accelerator.
    ///
    /// * READY  The address range is provisioned with Global Accelerator and can be advertised.
    ///
    /// * PENDING_ADVERTISING  Youve submitted a request for Global Accelerator to advertise an address range but it is not yet being advertised.
    ///
    /// * ADVERTISING  The address range is being advertised by Global Accelerator.
    ///
    /// * PENDING_WITHDRAWING  Youve submitted a request to withdraw an address range from being advertised but it is still being advertised by Global Accelerator.
    ///
    /// * PENDING_DEPROVISIONING  Youve submitted a request to deprovision an address range from Global Accelerator but it is still provisioned.
    ///
    /// * DEPROVISIONED  The address range is deprovisioned from Global Accelerator.
    ///
    /// * FAILED_PROVISION  The request to provision the address range from Global Accelerator was not successful. Please make sure that you provide all of the correct information, and try again. If the request fails a second time, contact Amazon Web Services support.
    ///
    /// * FAILED_ADVERTISING  The request for Global Accelerator to advertise the address range was not successful. Please make sure that you provide all of the correct information, and try again. If the request fails a second time, contact Amazon Web Services support.
    ///
    /// * FAILED_WITHDRAW  The request to withdraw the address range from advertising by Global Accelerator was not successful. Please make sure that you provide all of the correct information, and try again. If the request fails a second time, contact Amazon Web Services support.
    ///
    /// * FAILED_DEPROVISION  The request to deprovision the address range from Global Accelerator was not successful. Please make sure that you provide all of the correct information, and try again. If the request fails a second time, contact Amazon Web Services support.
    public struct ByoipCidr: Swift.Equatable {
        /// The address range, in CIDR notation.
        public var cidr: Swift.String?
        /// A history of status changes for an IP address range that you bring to Global Accelerator through bring your own IP address (BYOIP).
        public var events: [GlobalAcceleratorClientTypes.ByoipCidrEvent]?
        /// The state of the address pool.
        public var state: GlobalAcceleratorClientTypes.ByoipCidrState?

        public init(
            cidr: Swift.String? = nil,
            events: [GlobalAcceleratorClientTypes.ByoipCidrEvent]? = nil,
            state: GlobalAcceleratorClientTypes.ByoipCidrState? = nil
        )
        {
            self.cidr = cidr
            self.events = events
            self.state = state
        }
    }

}

extension GlobalAcceleratorClientTypes.ByoipCidrEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .epochSeconds, forKey: .timestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timestamp)
        timestamp = timestampDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    /// A complex type that contains a Message and a Timestamp value for changes that you make in the status of an IP address range that you bring to Global Accelerator through bring your own IP address (BYOIP).
    public struct ByoipCidrEvent: Swift.Equatable {
        /// A string that contains an Event message describing changes that you make in the status of an IP address range that you bring to Global Accelerator through bring your own IP address (BYOIP).
        public var message: Swift.String?
        /// A timestamp for when you make a status change for an IP address range that you bring to Global Accelerator through bring your own IP address (BYOIP).
        public var timestamp: ClientRuntime.Date?

        public init(
            message: Swift.String? = nil,
            timestamp: ClientRuntime.Date? = nil
        )
        {
            self.message = message
            self.timestamp = timestamp
        }
    }

}

extension ByoipCidrNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ByoipCidrNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The CIDR that you specified was not found or is incorrect.
public struct ByoipCidrNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ByoipCidrNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ByoipCidrNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ByoipCidrNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    public enum ByoipCidrState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case advertising
        case deprovisioned
        case failedAdvertising
        case failedDeprovision
        case failedProvision
        case failedWithdraw
        case pendingAdvertising
        case pendingDeprovisioning
        case pendingProvisioning
        case pendingWithdrawing
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [ByoipCidrState] {
            return [
                .advertising,
                .deprovisioned,
                .failedAdvertising,
                .failedDeprovision,
                .failedProvision,
                .failedWithdraw,
                .pendingAdvertising,
                .pendingDeprovisioning,
                .pendingProvisioning,
                .pendingWithdrawing,
                .ready,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .advertising: return "ADVERTISING"
            case .deprovisioned: return "DEPROVISIONED"
            case .failedAdvertising: return "FAILED_ADVERTISING"
            case .failedDeprovision: return "FAILED_DEPROVISION"
            case .failedProvision: return "FAILED_PROVISION"
            case .failedWithdraw: return "FAILED_WITHDRAW"
            case .pendingAdvertising: return "PENDING_ADVERTISING"
            case .pendingDeprovisioning: return "PENDING_DEPROVISIONING"
            case .pendingProvisioning: return "PENDING_PROVISIONING"
            case .pendingWithdrawing: return "PENDING_WITHDRAWING"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ByoipCidrState(rawValue: rawValue) ?? ByoipCidrState.sdkUnknown(rawValue)
        }
    }
}

extension GlobalAcceleratorClientTypes.CidrAuthorizationContext: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case signature = "Signature"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let signature = self.signature {
            try encodeContainer.encode(signature, forKey: .signature)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let signatureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signature)
        signature = signatureDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    /// Provides authorization for Amazon to bring a specific IP address range to a specific Amazon Web Services account using bring your own IP addresses (BYOIP). For more information, see [Bring your own IP addresses (BYOIP)](https://docs.aws.amazon.com/global-accelerator/latest/dg/using-byoip.html) in the Global Accelerator Developer Guide.
    public struct CidrAuthorizationContext: Swift.Equatable {
        /// The plain-text authorization message for the prefix and account.
        /// This member is required.
        public var message: Swift.String?
        /// The signed authorization message for the prefix and account.
        /// This member is required.
        public var signature: Swift.String?

        public init(
            message: Swift.String? = nil,
            signature: Swift.String? = nil
        )
        {
            self.message = message
            self.signature = signature
        }
    }

}

extension GlobalAcceleratorClientTypes {
    public enum ClientAffinity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case sourceIp
        case sdkUnknown(Swift.String)

        public static var allCases: [ClientAffinity] {
            return [
                .none,
                .sourceIp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .sourceIp: return "SOURCE_IP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ClientAffinity(rawValue: rawValue) ?? ClientAffinity.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You can't use both of those options.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateAcceleratorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case idempotencyToken = "IdempotencyToken"
        case ipAddressType = "IpAddressType"
        case ipAddresses = "IpAddresses"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let ipAddressType = self.ipAddressType {
            try encodeContainer.encode(ipAddressType.rawValue, forKey: .ipAddressType)
        }
        if let ipAddresses = ipAddresses {
            var ipAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipAddresses)
            for ipaddress0 in ipAddresses {
                try ipAddressesContainer.encode(ipaddress0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateAcceleratorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateAcceleratorInput: Swift.Equatable {
    /// Indicates whether an accelerator is enabled. The value is true or false. The default value is true. If the value is set to true, an accelerator cannot be deleted. If set to false, the accelerator can be deleted.
    public var enabled: Swift.Bool?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotencythat is, the uniquenessof an accelerator.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The IP address type that an accelerator supports. For a standard accelerator, the value can be IPV4 or DUAL_STACK.
    public var ipAddressType: GlobalAcceleratorClientTypes.IpAddressType?
    /// Optionally, if you've added your own IP address pool to Global Accelerator (BYOIP), you can choose an IPv4 address from your own pool to use for the accelerator's static IPv4 address when you create an accelerator. After you bring an address range to Amazon Web Services, it appears in your account as an address pool. When you create an accelerator, you can assign one IPv4 address from your range to it. Global Accelerator assigns you a second static IPv4 address from an Amazon IP address range. If you bring two IPv4 address ranges to Amazon Web Services, you can assign one IPv4 address from each range to your accelerator. This restriction is because Global Accelerator assigns each address range to a different network zone, for high availability. You can specify one or two addresses, separated by a space. Do not include the /32 suffix. Note that you can't update IP addresses for an existing accelerator. To change them, you must create a new accelerator with the new addresses. For more information, see [Bring your own IP addresses (BYOIP)](https://docs.aws.amazon.com/global-accelerator/latest/dg/using-byoip.html) in the Global Accelerator Developer Guide.
    public var ipAddresses: [Swift.String]?
    /// The name of the accelerator. The name can have a maximum of 64 characters, must contain only alphanumeric characters, periods (.), or hyphens (-), and must not begin or end with a hyphen or period.
    /// This member is required.
    public var name: Swift.String?
    /// Create tags for an accelerator. For more information, see [Tagging in Global Accelerator](https://docs.aws.amazon.com/global-accelerator/latest/dg/tagging-in-global-accelerator.html) in the Global Accelerator Developer Guide.
    public var tags: [GlobalAcceleratorClientTypes.Tag]?

    public init(
        enabled: Swift.Bool? = nil,
        idempotencyToken: Swift.String? = nil,
        ipAddressType: GlobalAcceleratorClientTypes.IpAddressType? = nil,
        ipAddresses: [Swift.String]? = nil,
        name: Swift.String? = nil,
        tags: [GlobalAcceleratorClientTypes.Tag]? = nil
    )
    {
        self.enabled = enabled
        self.idempotencyToken = idempotencyToken
        self.ipAddressType = ipAddressType
        self.ipAddresses = ipAddresses
        self.name = name
        self.tags = tags
    }
}

struct CreateAcceleratorInputBody: Swift.Equatable {
    let name: Swift.String?
    let ipAddressType: GlobalAcceleratorClientTypes.IpAddressType?
    let ipAddresses: [Swift.String]?
    let enabled: Swift.Bool?
    let idempotencyToken: Swift.String?
    let tags: [GlobalAcceleratorClientTypes.Tag]?
}

extension CreateAcceleratorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case idempotencyToken = "IdempotencyToken"
        case ipAddressType = "IpAddressType"
        case ipAddresses = "IpAddresses"
        case name = "Name"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.IpAddressType.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
        let ipAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ipAddresses)
        var ipAddressesDecoded0:[Swift.String]? = nil
        if let ipAddressesContainer = ipAddressesContainer {
            ipAddressesDecoded0 = [Swift.String]()
            for string0 in ipAddressesContainer {
                if let string0 = string0 {
                    ipAddressesDecoded0?.append(string0)
                }
            }
        }
        ipAddresses = ipAddressesDecoded0
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[GlobalAcceleratorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [GlobalAcceleratorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAcceleratorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAcceleratorOutputBody = try responseDecoder.decode(responseBody: data)
            self.accelerator = output.accelerator
        } else {
            self.accelerator = nil
        }
    }
}

public struct CreateAcceleratorOutput: Swift.Equatable {
    /// The accelerator that is created by specifying a listener and the supported IP address types.
    public var accelerator: GlobalAcceleratorClientTypes.Accelerator?

    public init(
        accelerator: GlobalAcceleratorClientTypes.Accelerator? = nil
    )
    {
        self.accelerator = accelerator
    }
}

struct CreateAcceleratorOutputBody: Swift.Equatable {
    let accelerator: GlobalAcceleratorClientTypes.Accelerator?
}

extension CreateAcceleratorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accelerator = "Accelerator"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.Accelerator.self, forKey: .accelerator)
        accelerator = acceleratorDecoded
    }
}

enum CreateAcceleratorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateCustomRoutingAcceleratorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case idempotencyToken = "IdempotencyToken"
        case ipAddressType = "IpAddressType"
        case ipAddresses = "IpAddresses"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let ipAddressType = self.ipAddressType {
            try encodeContainer.encode(ipAddressType.rawValue, forKey: .ipAddressType)
        }
        if let ipAddresses = ipAddresses {
            var ipAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipAddresses)
            for ipaddress0 in ipAddresses {
                try ipAddressesContainer.encode(ipaddress0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateCustomRoutingAcceleratorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateCustomRoutingAcceleratorInput: Swift.Equatable {
    /// Indicates whether an accelerator is enabled. The value is true or false. The default value is true. If the value is set to true, an accelerator cannot be deleted. If set to false, the accelerator can be deleted.
    public var enabled: Swift.Bool?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotencythat is, the uniquenessof the request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The IP address type that an accelerator supports. For a custom routing accelerator, the value must be IPV4.
    public var ipAddressType: GlobalAcceleratorClientTypes.IpAddressType?
    /// Optionally, if you've added your own IP address pool to Global Accelerator (BYOIP), you can choose an IPv4 address from your own pool to use for the accelerator's static IPv4 address when you create an accelerator. After you bring an address range to Amazon Web Services, it appears in your account as an address pool. When you create an accelerator, you can assign one IPv4 address from your range to it. Global Accelerator assigns you a second static IPv4 address from an Amazon IP address range. If you bring two IPv4 address ranges to Amazon Web Services, you can assign one IPv4 address from each range to your accelerator. This restriction is because Global Accelerator assigns each address range to a different network zone, for high availability. You can specify one or two addresses, separated by a space. Do not include the /32 suffix. Note that you can't update IP addresses for an existing accelerator. To change them, you must create a new accelerator with the new addresses. For more information, see [Bring your own IP addresses (BYOIP)](https://docs.aws.amazon.com/global-accelerator/latest/dg/using-byoip.html) in the Global Accelerator Developer Guide.
    public var ipAddresses: [Swift.String]?
    /// The name of a custom routing accelerator. The name can have a maximum of 64 characters, must contain only alphanumeric characters or hyphens (-), and must not begin or end with a hyphen.
    /// This member is required.
    public var name: Swift.String?
    /// Create tags for an accelerator. For more information, see [Tagging in Global Accelerator](https://docs.aws.amazon.com/global-accelerator/latest/dg/tagging-in-global-accelerator.html) in the Global Accelerator Developer Guide.
    public var tags: [GlobalAcceleratorClientTypes.Tag]?

    public init(
        enabled: Swift.Bool? = nil,
        idempotencyToken: Swift.String? = nil,
        ipAddressType: GlobalAcceleratorClientTypes.IpAddressType? = nil,
        ipAddresses: [Swift.String]? = nil,
        name: Swift.String? = nil,
        tags: [GlobalAcceleratorClientTypes.Tag]? = nil
    )
    {
        self.enabled = enabled
        self.idempotencyToken = idempotencyToken
        self.ipAddressType = ipAddressType
        self.ipAddresses = ipAddresses
        self.name = name
        self.tags = tags
    }
}

struct CreateCustomRoutingAcceleratorInputBody: Swift.Equatable {
    let name: Swift.String?
    let ipAddressType: GlobalAcceleratorClientTypes.IpAddressType?
    let ipAddresses: [Swift.String]?
    let enabled: Swift.Bool?
    let idempotencyToken: Swift.String?
    let tags: [GlobalAcceleratorClientTypes.Tag]?
}

extension CreateCustomRoutingAcceleratorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case idempotencyToken = "IdempotencyToken"
        case ipAddressType = "IpAddressType"
        case ipAddresses = "IpAddresses"
        case name = "Name"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.IpAddressType.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
        let ipAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ipAddresses)
        var ipAddressesDecoded0:[Swift.String]? = nil
        if let ipAddressesContainer = ipAddressesContainer {
            ipAddressesDecoded0 = [Swift.String]()
            for string0 in ipAddressesContainer {
                if let string0 = string0 {
                    ipAddressesDecoded0?.append(string0)
                }
            }
        }
        ipAddresses = ipAddressesDecoded0
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[GlobalAcceleratorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [GlobalAcceleratorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateCustomRoutingAcceleratorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateCustomRoutingAcceleratorOutputBody = try responseDecoder.decode(responseBody: data)
            self.accelerator = output.accelerator
        } else {
            self.accelerator = nil
        }
    }
}

public struct CreateCustomRoutingAcceleratorOutput: Swift.Equatable {
    /// The accelerator that is created.
    public var accelerator: GlobalAcceleratorClientTypes.CustomRoutingAccelerator?

    public init(
        accelerator: GlobalAcceleratorClientTypes.CustomRoutingAccelerator? = nil
    )
    {
        self.accelerator = accelerator
    }
}

struct CreateCustomRoutingAcceleratorOutputBody: Swift.Equatable {
    let accelerator: GlobalAcceleratorClientTypes.CustomRoutingAccelerator?
}

extension CreateCustomRoutingAcceleratorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accelerator = "Accelerator"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CustomRoutingAccelerator.self, forKey: .accelerator)
        accelerator = acceleratorDecoded
    }
}

enum CreateCustomRoutingAcceleratorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateCustomRoutingEndpointGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfigurations = "DestinationConfigurations"
        case endpointGroupRegion = "EndpointGroupRegion"
        case idempotencyToken = "IdempotencyToken"
        case listenerArn = "ListenerArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationConfigurations = destinationConfigurations {
            var destinationConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationConfigurations)
            for customroutingdestinationconfiguration0 in destinationConfigurations {
                try destinationConfigurationsContainer.encode(customroutingdestinationconfiguration0)
            }
        }
        if let endpointGroupRegion = self.endpointGroupRegion {
            try encodeContainer.encode(endpointGroupRegion, forKey: .endpointGroupRegion)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let listenerArn = self.listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
    }
}

extension CreateCustomRoutingEndpointGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateCustomRoutingEndpointGroupInput: Swift.Equatable {
    /// Sets the port range and protocol for all endpoints (virtual private cloud subnets) in a custom routing endpoint group to accept client traffic on.
    /// This member is required.
    public var destinationConfigurations: [GlobalAcceleratorClientTypes.CustomRoutingDestinationConfiguration]?
    /// The Amazon Web Services Region where the endpoint group is located. A listener can have only one endpoint group in a specific Region.
    /// This member is required.
    public var endpointGroupRegion: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotencythat is, the uniquenessof the request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the listener for a custom routing endpoint.
    /// This member is required.
    public var listenerArn: Swift.String?

    public init(
        destinationConfigurations: [GlobalAcceleratorClientTypes.CustomRoutingDestinationConfiguration]? = nil,
        endpointGroupRegion: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        listenerArn: Swift.String? = nil
    )
    {
        self.destinationConfigurations = destinationConfigurations
        self.endpointGroupRegion = endpointGroupRegion
        self.idempotencyToken = idempotencyToken
        self.listenerArn = listenerArn
    }
}

struct CreateCustomRoutingEndpointGroupInputBody: Swift.Equatable {
    let listenerArn: Swift.String?
    let endpointGroupRegion: Swift.String?
    let destinationConfigurations: [GlobalAcceleratorClientTypes.CustomRoutingDestinationConfiguration]?
    let idempotencyToken: Swift.String?
}

extension CreateCustomRoutingEndpointGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfigurations = "DestinationConfigurations"
        case endpointGroupRegion = "EndpointGroupRegion"
        case idempotencyToken = "IdempotencyToken"
        case listenerArn = "ListenerArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
        let endpointGroupRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupRegion)
        endpointGroupRegion = endpointGroupRegionDecoded
        let destinationConfigurationsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.CustomRoutingDestinationConfiguration?].self, forKey: .destinationConfigurations)
        var destinationConfigurationsDecoded0:[GlobalAcceleratorClientTypes.CustomRoutingDestinationConfiguration]? = nil
        if let destinationConfigurationsContainer = destinationConfigurationsContainer {
            destinationConfigurationsDecoded0 = [GlobalAcceleratorClientTypes.CustomRoutingDestinationConfiguration]()
            for structure0 in destinationConfigurationsContainer {
                if let structure0 = structure0 {
                    destinationConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        destinationConfigurations = destinationConfigurationsDecoded0
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CreateCustomRoutingEndpointGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateCustomRoutingEndpointGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.endpointGroup = output.endpointGroup
        } else {
            self.endpointGroup = nil
        }
    }
}

public struct CreateCustomRoutingEndpointGroupOutput: Swift.Equatable {
    /// The information about the endpoint group created for a custom routing accelerator.
    public var endpointGroup: GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup?

    public init(
        endpointGroup: GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup? = nil
    )
    {
        self.endpointGroup = endpointGroup
    }
}

struct CreateCustomRoutingEndpointGroupOutputBody: Swift.Equatable {
    let endpointGroup: GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup?
}

extension CreateCustomRoutingEndpointGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroup = "EndpointGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup.self, forKey: .endpointGroup)
        endpointGroup = endpointGroupDecoded
    }
}

enum CreateCustomRoutingEndpointGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AcceleratorNotFoundException": return try await AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EndpointGroupAlreadyExistsException": return try await EndpointGroupAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPortRangeException": return try await InvalidPortRangeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ListenerNotFoundException": return try await ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateCustomRoutingListenerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case idempotencyToken = "IdempotencyToken"
        case portRanges = "PortRanges"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = self.acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let portRanges = portRanges {
            var portRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portRanges)
            for portrange0 in portRanges {
                try portRangesContainer.encode(portrange0)
            }
        }
    }
}

extension CreateCustomRoutingListenerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateCustomRoutingListenerInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the accelerator for a custom routing listener.
    /// This member is required.
    public var acceleratorArn: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotencythat is, the uniquenessof the request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The port range to support for connections from clients to your accelerator. Separately, you set port ranges for endpoints. For more information, see [About endpoints for custom routing accelerators](https://docs.aws.amazon.com/global-accelerator/latest/dg/about-custom-routing-endpoints.html).
    /// This member is required.
    public var portRanges: [GlobalAcceleratorClientTypes.PortRange]?

    public init(
        acceleratorArn: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        portRanges: [GlobalAcceleratorClientTypes.PortRange]? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.idempotencyToken = idempotencyToken
        self.portRanges = portRanges
    }
}

struct CreateCustomRoutingListenerInputBody: Swift.Equatable {
    let acceleratorArn: Swift.String?
    let portRanges: [GlobalAcceleratorClientTypes.PortRange]?
    let idempotencyToken: Swift.String?
}

extension CreateCustomRoutingListenerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case idempotencyToken = "IdempotencyToken"
        case portRanges = "PortRanges"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let portRangesContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.PortRange?].self, forKey: .portRanges)
        var portRangesDecoded0:[GlobalAcceleratorClientTypes.PortRange]? = nil
        if let portRangesContainer = portRangesContainer {
            portRangesDecoded0 = [GlobalAcceleratorClientTypes.PortRange]()
            for structure0 in portRangesContainer {
                if let structure0 = structure0 {
                    portRangesDecoded0?.append(structure0)
                }
            }
        }
        portRanges = portRangesDecoded0
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CreateCustomRoutingListenerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateCustomRoutingListenerOutputBody = try responseDecoder.decode(responseBody: data)
            self.listener = output.listener
        } else {
            self.listener = nil
        }
    }
}

public struct CreateCustomRoutingListenerOutput: Swift.Equatable {
    /// The listener that you've created for a custom routing accelerator.
    public var listener: GlobalAcceleratorClientTypes.CustomRoutingListener?

    public init(
        listener: GlobalAcceleratorClientTypes.CustomRoutingListener? = nil
    )
    {
        self.listener = listener
    }
}

struct CreateCustomRoutingListenerOutputBody: Swift.Equatable {
    let listener: GlobalAcceleratorClientTypes.CustomRoutingListener?
}

extension CreateCustomRoutingListenerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listener = "Listener"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CustomRoutingListener.self, forKey: .listener)
        listener = listenerDecoded
    }
}

enum CreateCustomRoutingListenerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AcceleratorNotFoundException": return try await AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPortRangeException": return try await InvalidPortRangeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateEndpointGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointConfigurations = "EndpointConfigurations"
        case endpointGroupRegion = "EndpointGroupRegion"
        case healthCheckIntervalSeconds = "HealthCheckIntervalSeconds"
        case healthCheckPath = "HealthCheckPath"
        case healthCheckPort = "HealthCheckPort"
        case healthCheckProtocol = "HealthCheckProtocol"
        case idempotencyToken = "IdempotencyToken"
        case listenerArn = "ListenerArn"
        case portOverrides = "PortOverrides"
        case thresholdCount = "ThresholdCount"
        case trafficDialPercentage = "TrafficDialPercentage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointConfigurations = endpointConfigurations {
            var endpointConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpointConfigurations)
            for endpointconfiguration0 in endpointConfigurations {
                try endpointConfigurationsContainer.encode(endpointconfiguration0)
            }
        }
        if let endpointGroupRegion = self.endpointGroupRegion {
            try encodeContainer.encode(endpointGroupRegion, forKey: .endpointGroupRegion)
        }
        if let healthCheckIntervalSeconds = self.healthCheckIntervalSeconds {
            try encodeContainer.encode(healthCheckIntervalSeconds, forKey: .healthCheckIntervalSeconds)
        }
        if let healthCheckPath = self.healthCheckPath {
            try encodeContainer.encode(healthCheckPath, forKey: .healthCheckPath)
        }
        if let healthCheckPort = self.healthCheckPort {
            try encodeContainer.encode(healthCheckPort, forKey: .healthCheckPort)
        }
        if let healthCheckProtocol = self.healthCheckProtocol {
            try encodeContainer.encode(healthCheckProtocol.rawValue, forKey: .healthCheckProtocol)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let listenerArn = self.listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
        if let portOverrides = portOverrides {
            var portOverridesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portOverrides)
            for portoverride0 in portOverrides {
                try portOverridesContainer.encode(portoverride0)
            }
        }
        if let thresholdCount = self.thresholdCount {
            try encodeContainer.encode(thresholdCount, forKey: .thresholdCount)
        }
        if let trafficDialPercentage = self.trafficDialPercentage {
            try encodeContainer.encode(trafficDialPercentage, forKey: .trafficDialPercentage)
        }
    }
}

extension CreateEndpointGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateEndpointGroupInput: Swift.Equatable {
    /// The list of endpoint objects.
    public var endpointConfigurations: [GlobalAcceleratorClientTypes.EndpointConfiguration]?
    /// The Amazon Web Services Region where the endpoint group is located. A listener can have only one endpoint group in a specific Region.
    /// This member is required.
    public var endpointGroupRegion: Swift.String?
    /// The time10 seconds or 30 secondsbetween each health check for an endpoint. The default value is 30.
    public var healthCheckIntervalSeconds: Swift.Int?
    /// If the protocol is HTTP/S, then this specifies the path that is the destination for health check targets. The default value is slash (/).
    public var healthCheckPath: Swift.String?
    /// The port that Global Accelerator uses to check the health of endpoints that are part of this endpoint group. The default port is the listener port that this endpoint group is associated with. If listener port is a list of ports, Global Accelerator uses the first port in the list.
    public var healthCheckPort: Swift.Int?
    /// The protocol that Global Accelerator uses to check the health of endpoints that are part of this endpoint group. The default value is TCP.
    public var healthCheckProtocol: GlobalAcceleratorClientTypes.HealthCheckProtocol?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotencythat is, the uniquenessof the request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerArn: Swift.String?
    /// Override specific listener ports used to route traffic to endpoints that are part of this endpoint group. For example, you can create a port override in which the listener receives user traffic on ports 80 and 443, but your accelerator routes that traffic to ports 1080 and 1443, respectively, on the endpoints. For more information, see [ Overriding listener ports](https://docs.aws.amazon.com/global-accelerator/latest/dg/about-endpoint-groups-port-override.html) in the Global Accelerator Developer Guide.
    public var portOverrides: [GlobalAcceleratorClientTypes.PortOverride]?
    /// The number of consecutive health checks required to set the state of a healthy endpoint to unhealthy, or to set an unhealthy endpoint to healthy. The default value is 3.
    public var thresholdCount: Swift.Int?
    /// The percentage of traffic to send to an Amazon Web Services Region. Additional traffic is distributed to other endpoint groups for this listener. Use this action to increase (dial up) or decrease (dial down) traffic to a specific Region. The percentage is applied to the traffic that would otherwise have been routed to the Region based on optimal routing. The default value is 100.
    public var trafficDialPercentage: Swift.Float?

    public init(
        endpointConfigurations: [GlobalAcceleratorClientTypes.EndpointConfiguration]? = nil,
        endpointGroupRegion: Swift.String? = nil,
        healthCheckIntervalSeconds: Swift.Int? = nil,
        healthCheckPath: Swift.String? = nil,
        healthCheckPort: Swift.Int? = nil,
        healthCheckProtocol: GlobalAcceleratorClientTypes.HealthCheckProtocol? = nil,
        idempotencyToken: Swift.String? = nil,
        listenerArn: Swift.String? = nil,
        portOverrides: [GlobalAcceleratorClientTypes.PortOverride]? = nil,
        thresholdCount: Swift.Int? = nil,
        trafficDialPercentage: Swift.Float? = nil
    )
    {
        self.endpointConfigurations = endpointConfigurations
        self.endpointGroupRegion = endpointGroupRegion
        self.healthCheckIntervalSeconds = healthCheckIntervalSeconds
        self.healthCheckPath = healthCheckPath
        self.healthCheckPort = healthCheckPort
        self.healthCheckProtocol = healthCheckProtocol
        self.idempotencyToken = idempotencyToken
        self.listenerArn = listenerArn
        self.portOverrides = portOverrides
        self.thresholdCount = thresholdCount
        self.trafficDialPercentage = trafficDialPercentage
    }
}

struct CreateEndpointGroupInputBody: Swift.Equatable {
    let listenerArn: Swift.String?
    let endpointGroupRegion: Swift.String?
    let endpointConfigurations: [GlobalAcceleratorClientTypes.EndpointConfiguration]?
    let trafficDialPercentage: Swift.Float?
    let healthCheckPort: Swift.Int?
    let healthCheckProtocol: GlobalAcceleratorClientTypes.HealthCheckProtocol?
    let healthCheckPath: Swift.String?
    let healthCheckIntervalSeconds: Swift.Int?
    let thresholdCount: Swift.Int?
    let idempotencyToken: Swift.String?
    let portOverrides: [GlobalAcceleratorClientTypes.PortOverride]?
}

extension CreateEndpointGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointConfigurations = "EndpointConfigurations"
        case endpointGroupRegion = "EndpointGroupRegion"
        case healthCheckIntervalSeconds = "HealthCheckIntervalSeconds"
        case healthCheckPath = "HealthCheckPath"
        case healthCheckPort = "HealthCheckPort"
        case healthCheckProtocol = "HealthCheckProtocol"
        case idempotencyToken = "IdempotencyToken"
        case listenerArn = "ListenerArn"
        case portOverrides = "PortOverrides"
        case thresholdCount = "ThresholdCount"
        case trafficDialPercentage = "TrafficDialPercentage"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
        let endpointGroupRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupRegion)
        endpointGroupRegion = endpointGroupRegionDecoded
        let endpointConfigurationsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.EndpointConfiguration?].self, forKey: .endpointConfigurations)
        var endpointConfigurationsDecoded0:[GlobalAcceleratorClientTypes.EndpointConfiguration]? = nil
        if let endpointConfigurationsContainer = endpointConfigurationsContainer {
            endpointConfigurationsDecoded0 = [GlobalAcceleratorClientTypes.EndpointConfiguration]()
            for structure0 in endpointConfigurationsContainer {
                if let structure0 = structure0 {
                    endpointConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        endpointConfigurations = endpointConfigurationsDecoded0
        let trafficDialPercentageDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .trafficDialPercentage)
        trafficDialPercentage = trafficDialPercentageDecoded
        let healthCheckPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthCheckPort)
        healthCheckPort = healthCheckPortDecoded
        let healthCheckProtocolDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.HealthCheckProtocol.self, forKey: .healthCheckProtocol)
        healthCheckProtocol = healthCheckProtocolDecoded
        let healthCheckPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .healthCheckPath)
        healthCheckPath = healthCheckPathDecoded
        let healthCheckIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthCheckIntervalSeconds)
        healthCheckIntervalSeconds = healthCheckIntervalSecondsDecoded
        let thresholdCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .thresholdCount)
        thresholdCount = thresholdCountDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let portOverridesContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.PortOverride?].self, forKey: .portOverrides)
        var portOverridesDecoded0:[GlobalAcceleratorClientTypes.PortOverride]? = nil
        if let portOverridesContainer = portOverridesContainer {
            portOverridesDecoded0 = [GlobalAcceleratorClientTypes.PortOverride]()
            for structure0 in portOverridesContainer {
                if let structure0 = structure0 {
                    portOverridesDecoded0?.append(structure0)
                }
            }
        }
        portOverrides = portOverridesDecoded0
    }
}

extension CreateEndpointGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateEndpointGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.endpointGroup = output.endpointGroup
        } else {
            self.endpointGroup = nil
        }
    }
}

public struct CreateEndpointGroupOutput: Swift.Equatable {
    /// The information about the endpoint group that was created.
    public var endpointGroup: GlobalAcceleratorClientTypes.EndpointGroup?

    public init(
        endpointGroup: GlobalAcceleratorClientTypes.EndpointGroup? = nil
    )
    {
        self.endpointGroup = endpointGroup
    }
}

struct CreateEndpointGroupOutputBody: Swift.Equatable {
    let endpointGroup: GlobalAcceleratorClientTypes.EndpointGroup?
}

extension CreateEndpointGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroup = "EndpointGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.EndpointGroup.self, forKey: .endpointGroup)
        endpointGroup = endpointGroupDecoded
    }
}

enum CreateEndpointGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AcceleratorNotFoundException": return try await AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EndpointGroupAlreadyExistsException": return try await EndpointGroupAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ListenerNotFoundException": return try await ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateListenerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case clientAffinity = "ClientAffinity"
        case idempotencyToken = "IdempotencyToken"
        case portRanges = "PortRanges"
        case `protocol` = "Protocol"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = self.acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let clientAffinity = self.clientAffinity {
            try encodeContainer.encode(clientAffinity.rawValue, forKey: .clientAffinity)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let portRanges = portRanges {
            var portRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portRanges)
            for portrange0 in portRanges {
                try portRangesContainer.encode(portrange0)
            }
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
    }
}

extension CreateListenerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateListenerInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of your accelerator.
    /// This member is required.
    public var acceleratorArn: Swift.String?
    /// Client affinity lets you direct all requests from a user to the same endpoint, if you have stateful applications, regardless of the port and protocol of the client request. Client affinity gives you control over whether to always route each client to the same specific endpoint. Global Accelerator uses a consistent-flow hashing algorithm to choose the optimal endpoint for a connection. If client affinity is NONE, Global Accelerator uses the "five-tuple" (5-tuple) propertiessource IP address, source port, destination IP address, destination port, and protocolto select the hash value, and then chooses the best endpoint. However, with this setting, if someone uses different ports to connect to Global Accelerator, their connections might not be always routed to the same endpoint because the hash value changes. If you want a given client to always be routed to the same endpoint, set client affinity to SOURCE_IP instead. When you use the SOURCE_IP setting, Global Accelerator uses the "two-tuple" (2-tuple) properties source (client) IP address and destination IP addressto select the hash value. The default value is NONE.
    public var clientAffinity: GlobalAcceleratorClientTypes.ClientAffinity?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotencythat is, the uniquenessof the request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The list of port ranges to support for connections from clients to your accelerator.
    /// This member is required.
    public var portRanges: [GlobalAcceleratorClientTypes.PortRange]?
    /// The protocol for connections from clients to your accelerator.
    /// This member is required.
    public var `protocol`: GlobalAcceleratorClientTypes.ModelProtocol?

    public init(
        acceleratorArn: Swift.String? = nil,
        clientAffinity: GlobalAcceleratorClientTypes.ClientAffinity? = nil,
        idempotencyToken: Swift.String? = nil,
        portRanges: [GlobalAcceleratorClientTypes.PortRange]? = nil,
        `protocol`: GlobalAcceleratorClientTypes.ModelProtocol? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.clientAffinity = clientAffinity
        self.idempotencyToken = idempotencyToken
        self.portRanges = portRanges
        self.`protocol` = `protocol`
    }
}

struct CreateListenerInputBody: Swift.Equatable {
    let acceleratorArn: Swift.String?
    let portRanges: [GlobalAcceleratorClientTypes.PortRange]?
    let `protocol`: GlobalAcceleratorClientTypes.ModelProtocol?
    let clientAffinity: GlobalAcceleratorClientTypes.ClientAffinity?
    let idempotencyToken: Swift.String?
}

extension CreateListenerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case clientAffinity = "ClientAffinity"
        case idempotencyToken = "IdempotencyToken"
        case portRanges = "PortRanges"
        case `protocol` = "Protocol"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let portRangesContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.PortRange?].self, forKey: .portRanges)
        var portRangesDecoded0:[GlobalAcceleratorClientTypes.PortRange]? = nil
        if let portRangesContainer = portRangesContainer {
            portRangesDecoded0 = [GlobalAcceleratorClientTypes.PortRange]()
            for structure0 in portRangesContainer {
                if let structure0 = structure0 {
                    portRangesDecoded0?.append(structure0)
                }
            }
        }
        portRanges = portRangesDecoded0
        let protocolDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.ModelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let clientAffinityDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.ClientAffinity.self, forKey: .clientAffinity)
        clientAffinity = clientAffinityDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CreateListenerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateListenerOutputBody = try responseDecoder.decode(responseBody: data)
            self.listener = output.listener
        } else {
            self.listener = nil
        }
    }
}

public struct CreateListenerOutput: Swift.Equatable {
    /// The listener that you've created.
    public var listener: GlobalAcceleratorClientTypes.Listener?

    public init(
        listener: GlobalAcceleratorClientTypes.Listener? = nil
    )
    {
        self.listener = listener
    }
}

struct CreateListenerOutputBody: Swift.Equatable {
    let listener: GlobalAcceleratorClientTypes.Listener?
}

extension CreateListenerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listener = "Listener"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.Listener.self, forKey: .listener)
        listener = listenerDecoded
    }
}

enum CreateListenerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AcceleratorNotFoundException": return try await AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPortRangeException": return try await InvalidPortRangeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GlobalAcceleratorClientTypes.CustomRoutingAccelerator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case createdTime = "CreatedTime"
        case dnsName = "DnsName"
        case enabled = "Enabled"
        case ipAddressType = "IpAddressType"
        case ipSets = "IpSets"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = self.acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let dnsName = self.dnsName {
            try encodeContainer.encode(dnsName, forKey: .dnsName)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let ipAddressType = self.ipAddressType {
            try encodeContainer.encode(ipAddressType.rawValue, forKey: .ipAddressType)
        }
        if let ipSets = ipSets {
            var ipSetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipSets)
            for ipset0 in ipSets {
                try ipSetsContainer.encode(ipset0)
            }
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.IpAddressType.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let ipSetsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.IpSet?].self, forKey: .ipSets)
        var ipSetsDecoded0:[GlobalAcceleratorClientTypes.IpSet]? = nil
        if let ipSetsContainer = ipSetsContainer {
            ipSetsDecoded0 = [GlobalAcceleratorClientTypes.IpSet]()
            for structure0 in ipSetsContainer {
                if let structure0 = structure0 {
                    ipSetsDecoded0?.append(structure0)
                }
            }
        }
        ipSets = ipSetsDecoded0
        let dnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dnsName)
        dnsName = dnsNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CustomRoutingAcceleratorStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    /// Attributes of a custom routing accelerator.
    public struct CustomRoutingAccelerator: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the custom routing accelerator.
        public var acceleratorArn: Swift.String?
        /// The date and time that the accelerator was created.
        public var createdTime: ClientRuntime.Date?
        /// The Domain Name System (DNS) name that Global Accelerator creates that points to an accelerator's static IPv4 addresses. The naming convention for the DNS name is the following: A lowercase letter a, followed by a 16-bit random hex string, followed by .awsglobalaccelerator.com. For example: a1234567890abcdef.awsglobalaccelerator.com. If you have a dual-stack accelerator, you also have a second DNS name, DualStackDnsName, that points to both the A record and the AAAA record for all four static addresses for the accelerator: two IPv4 addresses and two IPv6 addresses. For more information about the default DNS name, see [ Support for DNS addressing in Global Accelerator](https://docs.aws.amazon.com/global-accelerator/latest/dg/dns-addressing-custom-domains.dns-addressing.html) in the Global Accelerator Developer Guide.
        public var dnsName: Swift.String?
        /// Indicates whether the accelerator is enabled. The value is true or false. The default value is true. If the value is set to true, the accelerator cannot be deleted. If set to false, accelerator can be deleted.
        public var enabled: Swift.Bool?
        /// The IP address type that an accelerator supports. For a custom routing accelerator, the value must be IPV4.
        public var ipAddressType: GlobalAcceleratorClientTypes.IpAddressType?
        /// The static IP addresses that Global Accelerator associates with the accelerator.
        public var ipSets: [GlobalAcceleratorClientTypes.IpSet]?
        /// The date and time that the accelerator was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The name of the accelerator. The name must contain only alphanumeric characters or hyphens (-), and must not begin or end with a hyphen.
        public var name: Swift.String?
        /// Describes the deployment status of the accelerator.
        public var status: GlobalAcceleratorClientTypes.CustomRoutingAcceleratorStatus?

        public init(
            acceleratorArn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            dnsName: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            ipAddressType: GlobalAcceleratorClientTypes.IpAddressType? = nil,
            ipSets: [GlobalAcceleratorClientTypes.IpSet]? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: GlobalAcceleratorClientTypes.CustomRoutingAcceleratorStatus? = nil
        )
        {
            self.acceleratorArn = acceleratorArn
            self.createdTime = createdTime
            self.dnsName = dnsName
            self.enabled = enabled
            self.ipAddressType = ipAddressType
            self.ipSets = ipSets
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.status = status
        }
    }

}

extension GlobalAcceleratorClientTypes.CustomRoutingAcceleratorAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowLogsEnabled = "FlowLogsEnabled"
        case flowLogsS3Bucket = "FlowLogsS3Bucket"
        case flowLogsS3Prefix = "FlowLogsS3Prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowLogsEnabled = self.flowLogsEnabled {
            try encodeContainer.encode(flowLogsEnabled, forKey: .flowLogsEnabled)
        }
        if let flowLogsS3Bucket = self.flowLogsS3Bucket {
            try encodeContainer.encode(flowLogsS3Bucket, forKey: .flowLogsS3Bucket)
        }
        if let flowLogsS3Prefix = self.flowLogsS3Prefix {
            try encodeContainer.encode(flowLogsS3Prefix, forKey: .flowLogsS3Prefix)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowLogsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .flowLogsEnabled)
        flowLogsEnabled = flowLogsEnabledDecoded
        let flowLogsS3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowLogsS3Bucket)
        flowLogsS3Bucket = flowLogsS3BucketDecoded
        let flowLogsS3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowLogsS3Prefix)
        flowLogsS3Prefix = flowLogsS3PrefixDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    /// Attributes of a custom routing accelerator.
    public struct CustomRoutingAcceleratorAttributes: Swift.Equatable {
        /// Indicates whether flow logs are enabled. The default value is false. If the value is true, FlowLogsS3Bucket and FlowLogsS3Prefix must be specified. For more information, see [Flow logs](https://docs.aws.amazon.com/global-accelerator/latest/dg/monitoring-global-accelerator.flow-logs.html) in the Global Accelerator Developer Guide.
        public var flowLogsEnabled: Swift.Bool?
        /// The name of the Amazon S3 bucket for the flow logs. Attribute is required if FlowLogsEnabled is true. The bucket must exist and have a bucket policy that grants Global Accelerator permission to write to the bucket.
        public var flowLogsS3Bucket: Swift.String?
        /// The prefix for the location in the Amazon S3 bucket for the flow logs. Attribute is required if FlowLogsEnabled is true. If you dont specify a prefix, the flow logs are stored in the root of the bucket. If you specify slash (/) for the S3 bucket prefix, the log file bucket folder structure will include a double slash (//), like the following: DOC-EXAMPLE-BUCKET//AWSLogs/aws_account_id
        public var flowLogsS3Prefix: Swift.String?

        public init(
            flowLogsEnabled: Swift.Bool? = nil,
            flowLogsS3Bucket: Swift.String? = nil,
            flowLogsS3Prefix: Swift.String? = nil
        )
        {
            self.flowLogsEnabled = flowLogsEnabled
            self.flowLogsS3Bucket = flowLogsS3Bucket
            self.flowLogsS3Prefix = flowLogsS3Prefix
        }
    }

}

extension GlobalAcceleratorClientTypes {
    public enum CustomRoutingAcceleratorStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deployed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomRoutingAcceleratorStatus] {
            return [
                .deployed,
                .inProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deployed: return "DEPLOYED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CustomRoutingAcceleratorStatus(rawValue: rawValue) ?? CustomRoutingAcceleratorStatus.sdkUnknown(rawValue)
        }
    }
}

extension GlobalAcceleratorClientTypes.CustomRoutingDestinationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromPort = "FromPort"
        case protocols = "Protocols"
        case toPort = "ToPort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromPort = self.fromPort {
            try encodeContainer.encode(fromPort, forKey: .fromPort)
        }
        if let protocols = protocols {
            var protocolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocols)
            for customroutingprotocol0 in protocols {
                try protocolsContainer.encode(customroutingprotocol0.rawValue)
            }
        }
        if let toPort = self.toPort {
            try encodeContainer.encode(toPort, forKey: .toPort)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fromPort)
        fromPort = fromPortDecoded
        let toPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .toPort)
        toPort = toPortDecoded
        let protocolsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.CustomRoutingProtocol?].self, forKey: .protocols)
        var protocolsDecoded0:[GlobalAcceleratorClientTypes.CustomRoutingProtocol]? = nil
        if let protocolsContainer = protocolsContainer {
            protocolsDecoded0 = [GlobalAcceleratorClientTypes.CustomRoutingProtocol]()
            for enum0 in protocolsContainer {
                if let enum0 = enum0 {
                    protocolsDecoded0?.append(enum0)
                }
            }
        }
        protocols = protocolsDecoded0
    }
}

extension GlobalAcceleratorClientTypes {
    /// For a custom routing accelerator, sets the port range and protocol for all endpoints (virtual private cloud subnets) in an endpoint group to accept client traffic on.
    public struct CustomRoutingDestinationConfiguration: Swift.Equatable {
        /// The first port, inclusive, in the range of ports for the endpoint group that is associated with a custom routing accelerator.
        /// This member is required.
        public var fromPort: Swift.Int?
        /// The protocol for the endpoint group that is associated with a custom routing accelerator. The protocol can be either TCP or UDP.
        /// This member is required.
        public var protocols: [GlobalAcceleratorClientTypes.CustomRoutingProtocol]?
        /// The last port, inclusive, in the range of ports for the endpoint group that is associated with a custom routing accelerator.
        /// This member is required.
        public var toPort: Swift.Int?

        public init(
            fromPort: Swift.Int? = nil,
            protocols: [GlobalAcceleratorClientTypes.CustomRoutingProtocol]? = nil,
            toPort: Swift.Int? = nil
        )
        {
            self.fromPort = fromPort
            self.protocols = protocols
            self.toPort = toPort
        }
    }

}

extension GlobalAcceleratorClientTypes.CustomRoutingDestinationDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromPort = "FromPort"
        case protocols = "Protocols"
        case toPort = "ToPort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromPort = self.fromPort {
            try encodeContainer.encode(fromPort, forKey: .fromPort)
        }
        if let protocols = protocols {
            var protocolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocols)
            for protocol0 in protocols {
                try protocolsContainer.encode(protocol0.rawValue)
            }
        }
        if let toPort = self.toPort {
            try encodeContainer.encode(toPort, forKey: .toPort)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fromPort)
        fromPort = fromPortDecoded
        let toPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .toPort)
        toPort = toPortDecoded
        let protocolsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.ModelProtocol?].self, forKey: .protocols)
        var protocolsDecoded0:[GlobalAcceleratorClientTypes.ModelProtocol]? = nil
        if let protocolsContainer = protocolsContainer {
            protocolsDecoded0 = [GlobalAcceleratorClientTypes.ModelProtocol]()
            for enum0 in protocolsContainer {
                if let enum0 = enum0 {
                    protocolsDecoded0?.append(enum0)
                }
            }
        }
        protocols = protocolsDecoded0
    }
}

extension GlobalAcceleratorClientTypes {
    /// For a custom routing accelerator, describes the port range and protocol for all endpoints (virtual private cloud subnets) in an endpoint group to accept client traffic on.
    public struct CustomRoutingDestinationDescription: Swift.Equatable {
        /// The first port, inclusive, in the range of ports for the endpoint group that is associated with a custom routing accelerator.
        public var fromPort: Swift.Int?
        /// The protocol for the endpoint group that is associated with a custom routing accelerator. The protocol can be either TCP or UDP.
        public var protocols: [GlobalAcceleratorClientTypes.ModelProtocol]?
        /// The last port, inclusive, in the range of ports for the endpoint group that is associated with a custom routing accelerator.
        public var toPort: Swift.Int?

        public init(
            fromPort: Swift.Int? = nil,
            protocols: [GlobalAcceleratorClientTypes.ModelProtocol]? = nil,
            toPort: Swift.Int? = nil
        )
        {
            self.fromPort = fromPort
            self.protocols = protocols
            self.toPort = toPort
        }
    }

}

extension GlobalAcceleratorClientTypes {
    public enum CustomRoutingDestinationTrafficState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomRoutingDestinationTrafficState] {
            return [
                .allow,
                .deny,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allow: return "ALLOW"
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CustomRoutingDestinationTrafficState(rawValue: rawValue) ?? CustomRoutingDestinationTrafficState.sdkUnknown(rawValue)
        }
    }
}

extension GlobalAcceleratorClientTypes.CustomRoutingEndpointConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointId = "EndpointId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointId = self.endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    /// The list of endpoint objects. For custom routing, this is a list of virtual private cloud (VPC) subnet IDs.
    public struct CustomRoutingEndpointConfiguration: Swift.Equatable {
        /// An ID for the endpoint. For custom routing accelerators, this is the virtual private cloud (VPC) subnet ID.
        public var endpointId: Swift.String?

        public init(
            endpointId: Swift.String? = nil
        )
        {
            self.endpointId = endpointId
        }
    }

}

extension GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointId = "EndpointId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointId = self.endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    /// A complex type for an endpoint for a custom routing accelerator. Each endpoint group can include one or more endpoints, which are virtual private cloud (VPC) subnets.
    public struct CustomRoutingEndpointDescription: Swift.Equatable {
        /// An ID for the endpoint. For custom routing accelerators, this is the virtual private cloud (VPC) subnet ID.
        public var endpointId: Swift.String?

        public init(
            endpointId: Swift.String? = nil
        )
        {
            self.endpointId = endpointId
        }
    }

}

extension GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationDescriptions = "DestinationDescriptions"
        case endpointDescriptions = "EndpointDescriptions"
        case endpointGroupArn = "EndpointGroupArn"
        case endpointGroupRegion = "EndpointGroupRegion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationDescriptions = destinationDescriptions {
            var destinationDescriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationDescriptions)
            for customroutingdestinationdescription0 in destinationDescriptions {
                try destinationDescriptionsContainer.encode(customroutingdestinationdescription0)
            }
        }
        if let endpointDescriptions = endpointDescriptions {
            var endpointDescriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpointDescriptions)
            for customroutingendpointdescription0 in endpointDescriptions {
                try endpointDescriptionsContainer.encode(customroutingendpointdescription0)
            }
        }
        if let endpointGroupArn = self.endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
        if let endpointGroupRegion = self.endpointGroupRegion {
            try encodeContainer.encode(endpointGroupRegion, forKey: .endpointGroupRegion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
        let endpointGroupRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupRegion)
        endpointGroupRegion = endpointGroupRegionDecoded
        let destinationDescriptionsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.CustomRoutingDestinationDescription?].self, forKey: .destinationDescriptions)
        var destinationDescriptionsDecoded0:[GlobalAcceleratorClientTypes.CustomRoutingDestinationDescription]? = nil
        if let destinationDescriptionsContainer = destinationDescriptionsContainer {
            destinationDescriptionsDecoded0 = [GlobalAcceleratorClientTypes.CustomRoutingDestinationDescription]()
            for structure0 in destinationDescriptionsContainer {
                if let structure0 = structure0 {
                    destinationDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        destinationDescriptions = destinationDescriptionsDecoded0
        let endpointDescriptionsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription?].self, forKey: .endpointDescriptions)
        var endpointDescriptionsDecoded0:[GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription]? = nil
        if let endpointDescriptionsContainer = endpointDescriptionsContainer {
            endpointDescriptionsDecoded0 = [GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription]()
            for structure0 in endpointDescriptionsContainer {
                if let structure0 = structure0 {
                    endpointDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        endpointDescriptions = endpointDescriptionsDecoded0
    }
}

extension GlobalAcceleratorClientTypes {
    /// A complex type for the endpoint group for a custom routing accelerator. An Amazon Web Services Region can have only one endpoint group for a specific listener.
    public struct CustomRoutingEndpointGroup: Swift.Equatable {
        /// For a custom routing accelerator, describes the port range and protocol for all endpoints (virtual private cloud subnets) in an endpoint group to accept client traffic on.
        public var destinationDescriptions: [GlobalAcceleratorClientTypes.CustomRoutingDestinationDescription]?
        /// For a custom routing accelerator, describes the endpoints (virtual private cloud subnets) in an endpoint group to accept client traffic on.
        public var endpointDescriptions: [GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription]?
        /// The Amazon Resource Name (ARN) of the endpoint group.
        public var endpointGroupArn: Swift.String?
        /// The Amazon Web Services Region where the endpoint group is located.
        public var endpointGroupRegion: Swift.String?

        public init(
            destinationDescriptions: [GlobalAcceleratorClientTypes.CustomRoutingDestinationDescription]? = nil,
            endpointDescriptions: [GlobalAcceleratorClientTypes.CustomRoutingEndpointDescription]? = nil,
            endpointGroupArn: Swift.String? = nil,
            endpointGroupRegion: Swift.String? = nil
        )
        {
            self.destinationDescriptions = destinationDescriptions
            self.endpointDescriptions = endpointDescriptions
            self.endpointGroupArn = endpointGroupArn
            self.endpointGroupRegion = endpointGroupRegion
        }
    }

}

extension GlobalAcceleratorClientTypes.CustomRoutingListener: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
        case portRanges = "PortRanges"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listenerArn = self.listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
        if let portRanges = portRanges {
            var portRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portRanges)
            for portrange0 in portRanges {
                try portRangesContainer.encode(portrange0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
        let portRangesContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.PortRange?].self, forKey: .portRanges)
        var portRangesDecoded0:[GlobalAcceleratorClientTypes.PortRange]? = nil
        if let portRangesContainer = portRangesContainer {
            portRangesDecoded0 = [GlobalAcceleratorClientTypes.PortRange]()
            for structure0 in portRangesContainer {
                if let structure0 = structure0 {
                    portRangesDecoded0?.append(structure0)
                }
            }
        }
        portRanges = portRangesDecoded0
    }
}

extension GlobalAcceleratorClientTypes {
    /// A complex type for a listener for a custom routing accelerator.
    public struct CustomRoutingListener: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the listener.
        public var listenerArn: Swift.String?
        /// The port range to support for connections from clients to your accelerator. Separately, you set port ranges for endpoints. For more information, see [About endpoints for custom routing accelerators](https://docs.aws.amazon.com/global-accelerator/latest/dg/about-custom-routing-endpoints.html).
        public var portRanges: [GlobalAcceleratorClientTypes.PortRange]?

        public init(
            listenerArn: Swift.String? = nil,
            portRanges: [GlobalAcceleratorClientTypes.PortRange]? = nil
        )
        {
            self.listenerArn = listenerArn
            self.portRanges = portRanges
        }
    }

}

extension GlobalAcceleratorClientTypes {
    public enum CustomRoutingProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case tcp
        case udp
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomRoutingProtocol] {
            return [
                .tcp,
                .udp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .tcp: return "TCP"
            case .udp: return "UDP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CustomRoutingProtocol(rawValue: rawValue) ?? CustomRoutingProtocol.sdkUnknown(rawValue)
        }
    }
}

extension DeleteAcceleratorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = self.acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
    }
}

extension DeleteAcceleratorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAcceleratorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of an accelerator.
    /// This member is required.
    public var acceleratorArn: Swift.String?

    public init(
        acceleratorArn: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
    }
}

struct DeleteAcceleratorInputBody: Swift.Equatable {
    let acceleratorArn: Swift.String?
}

extension DeleteAcceleratorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
    }
}

extension DeleteAcceleratorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAcceleratorOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAcceleratorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AcceleratorNotDisabledException": return try await AcceleratorNotDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AcceleratorNotFoundException": return try await AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AssociatedListenerFoundException": return try await AssociatedListenerFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteCustomRoutingAcceleratorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = self.acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
    }
}

extension DeleteCustomRoutingAcceleratorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteCustomRoutingAcceleratorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the custom routing accelerator to delete.
    /// This member is required.
    public var acceleratorArn: Swift.String?

    public init(
        acceleratorArn: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
    }
}

struct DeleteCustomRoutingAcceleratorInputBody: Swift.Equatable {
    let acceleratorArn: Swift.String?
}

extension DeleteCustomRoutingAcceleratorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
    }
}

extension DeleteCustomRoutingAcceleratorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteCustomRoutingAcceleratorOutput: Swift.Equatable {

    public init() { }
}

enum DeleteCustomRoutingAcceleratorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AcceleratorNotDisabledException": return try await AcceleratorNotDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AcceleratorNotFoundException": return try await AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AssociatedListenerFoundException": return try await AssociatedListenerFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteCustomRoutingEndpointGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointGroupArn = self.endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
    }
}

extension DeleteCustomRoutingEndpointGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteCustomRoutingEndpointGroupInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the endpoint group to delete.
    /// This member is required.
    public var endpointGroupArn: Swift.String?

    public init(
        endpointGroupArn: Swift.String? = nil
    )
    {
        self.endpointGroupArn = endpointGroupArn
    }
}

struct DeleteCustomRoutingEndpointGroupInputBody: Swift.Equatable {
    let endpointGroupArn: Swift.String?
}

extension DeleteCustomRoutingEndpointGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
    }
}

extension DeleteCustomRoutingEndpointGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteCustomRoutingEndpointGroupOutput: Swift.Equatable {

    public init() { }
}

enum DeleteCustomRoutingEndpointGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EndpointGroupNotFoundException": return try await EndpointGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteCustomRoutingListenerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listenerArn = self.listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
    }
}

extension DeleteCustomRoutingListenerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteCustomRoutingListenerInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the listener to delete.
    /// This member is required.
    public var listenerArn: Swift.String?

    public init(
        listenerArn: Swift.String? = nil
    )
    {
        self.listenerArn = listenerArn
    }
}

struct DeleteCustomRoutingListenerInputBody: Swift.Equatable {
    let listenerArn: Swift.String?
}

extension DeleteCustomRoutingListenerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
    }
}

extension DeleteCustomRoutingListenerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteCustomRoutingListenerOutput: Swift.Equatable {

    public init() { }
}

enum DeleteCustomRoutingListenerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AssociatedEndpointGroupFoundException": return try await AssociatedEndpointGroupFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ListenerNotFoundException": return try await ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteEndpointGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointGroupArn = self.endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
    }
}

extension DeleteEndpointGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteEndpointGroupInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the endpoint group to delete.
    /// This member is required.
    public var endpointGroupArn: Swift.String?

    public init(
        endpointGroupArn: Swift.String? = nil
    )
    {
        self.endpointGroupArn = endpointGroupArn
    }
}

struct DeleteEndpointGroupInputBody: Swift.Equatable {
    let endpointGroupArn: Swift.String?
}

extension DeleteEndpointGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
    }
}

extension DeleteEndpointGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteEndpointGroupOutput: Swift.Equatable {

    public init() { }
}

enum DeleteEndpointGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EndpointGroupNotFoundException": return try await EndpointGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteListenerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listenerArn = self.listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
    }
}

extension DeleteListenerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteListenerInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerArn: Swift.String?

    public init(
        listenerArn: Swift.String? = nil
    )
    {
        self.listenerArn = listenerArn
    }
}

struct DeleteListenerInputBody: Swift.Equatable {
    let listenerArn: Swift.String?
}

extension DeleteListenerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
    }
}

extension DeleteListenerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteListenerOutput: Swift.Equatable {

    public init() { }
}

enum DeleteListenerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AssociatedEndpointGroupFoundException": return try await AssociatedEndpointGroupFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ListenerNotFoundException": return try await ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DenyCustomRoutingTrafficInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case denyAllTrafficToEndpoint = "DenyAllTrafficToEndpoint"
        case destinationAddresses = "DestinationAddresses"
        case destinationPorts = "DestinationPorts"
        case endpointGroupArn = "EndpointGroupArn"
        case endpointId = "EndpointId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let denyAllTrafficToEndpoint = self.denyAllTrafficToEndpoint {
            try encodeContainer.encode(denyAllTrafficToEndpoint, forKey: .denyAllTrafficToEndpoint)
        }
        if let destinationAddresses = destinationAddresses {
            var destinationAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationAddresses)
            for ipaddress0 in destinationAddresses {
                try destinationAddressesContainer.encode(ipaddress0)
            }
        }
        if let destinationPorts = destinationPorts {
            var destinationPortsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationPorts)
            for portnumber0 in destinationPorts {
                try destinationPortsContainer.encode(portnumber0)
            }
        }
        if let endpointGroupArn = self.endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
        if let endpointId = self.endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
    }
}

extension DenyCustomRoutingTrafficInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DenyCustomRoutingTrafficInput: Swift.Equatable {
    /// Indicates whether all destination IP addresses and ports for a specified VPC subnet endpoint cannot receive traffic from a custom routing accelerator. The value is TRUE or FALSE. When set to TRUE, no destinations in the custom routing VPC subnet can receive traffic. Note that you cannot specify destination IP addresses and ports when the value is set to TRUE. When set to FALSE (or not specified), you must specify a list of destination IP addresses that cannot receive traffic. A list of ports is optional. If you don't specify a list of ports, the ports that can accept traffic is the same as the ports configured for the endpoint group. The default value is FALSE.
    public var denyAllTrafficToEndpoint: Swift.Bool?
    /// A list of specific Amazon EC2 instance IP addresses (destination addresses) in a subnet that you want to prevent from receiving traffic. The IP addresses must be a subset of the IP addresses allowed for the VPC subnet associated with the endpoint group.
    public var destinationAddresses: [Swift.String]?
    /// A list of specific Amazon EC2 instance ports (destination ports) in a subnet endpoint that you want to prevent from receiving traffic.
    public var destinationPorts: [Swift.Int]?
    /// The Amazon Resource Name (ARN) of the endpoint group.
    /// This member is required.
    public var endpointGroupArn: Swift.String?
    /// An ID for the endpoint. For custom routing accelerators, this is the virtual private cloud (VPC) subnet ID.
    /// This member is required.
    public var endpointId: Swift.String?

    public init(
        denyAllTrafficToEndpoint: Swift.Bool? = nil,
        destinationAddresses: [Swift.String]? = nil,
        destinationPorts: [Swift.Int]? = nil,
        endpointGroupArn: Swift.String? = nil,
        endpointId: Swift.String? = nil
    )
    {
        self.denyAllTrafficToEndpoint = denyAllTrafficToEndpoint
        self.destinationAddresses = destinationAddresses
        self.destinationPorts = destinationPorts
        self.endpointGroupArn = endpointGroupArn
        self.endpointId = endpointId
    }
}

struct DenyCustomRoutingTrafficInputBody: Swift.Equatable {
    let endpointGroupArn: Swift.String?
    let endpointId: Swift.String?
    let destinationAddresses: [Swift.String]?
    let destinationPorts: [Swift.Int]?
    let denyAllTrafficToEndpoint: Swift.Bool?
}

extension DenyCustomRoutingTrafficInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case denyAllTrafficToEndpoint = "DenyAllTrafficToEndpoint"
        case destinationAddresses = "DestinationAddresses"
        case destinationPorts = "DestinationPorts"
        case endpointGroupArn = "EndpointGroupArn"
        case endpointId = "EndpointId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
        let destinationAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .destinationAddresses)
        var destinationAddressesDecoded0:[Swift.String]? = nil
        if let destinationAddressesContainer = destinationAddressesContainer {
            destinationAddressesDecoded0 = [Swift.String]()
            for string0 in destinationAddressesContainer {
                if let string0 = string0 {
                    destinationAddressesDecoded0?.append(string0)
                }
            }
        }
        destinationAddresses = destinationAddressesDecoded0
        let destinationPortsContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .destinationPorts)
        var destinationPortsDecoded0:[Swift.Int]? = nil
        if let destinationPortsContainer = destinationPortsContainer {
            destinationPortsDecoded0 = [Swift.Int]()
            for integer0 in destinationPortsContainer {
                if let integer0 = integer0 {
                    destinationPortsDecoded0?.append(integer0)
                }
            }
        }
        destinationPorts = destinationPortsDecoded0
        let denyAllTrafficToEndpointDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .denyAllTrafficToEndpoint)
        denyAllTrafficToEndpoint = denyAllTrafficToEndpointDecoded
    }
}

extension DenyCustomRoutingTrafficOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DenyCustomRoutingTrafficOutput: Swift.Equatable {

    public init() { }
}

enum DenyCustomRoutingTrafficOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EndpointGroupNotFoundException": return try await EndpointGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeprovisionByoipCidrInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidr = "Cidr"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidr = self.cidr {
            try encodeContainer.encode(cidr, forKey: .cidr)
        }
    }
}

extension DeprovisionByoipCidrInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeprovisionByoipCidrInput: Swift.Equatable {
    /// The address range, in CIDR notation. The prefix must be the same prefix that you specified when you provisioned the address range.
    /// This member is required.
    public var cidr: Swift.String?

    public init(
        cidr: Swift.String? = nil
    )
    {
        self.cidr = cidr
    }
}

struct DeprovisionByoipCidrInputBody: Swift.Equatable {
    let cidr: Swift.String?
}

extension DeprovisionByoipCidrInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidr = "Cidr"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cidr)
        cidr = cidrDecoded
    }
}

extension DeprovisionByoipCidrOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeprovisionByoipCidrOutputBody = try responseDecoder.decode(responseBody: data)
            self.byoipCidr = output.byoipCidr
        } else {
            self.byoipCidr = nil
        }
    }
}

public struct DeprovisionByoipCidrOutput: Swift.Equatable {
    /// Information about the address range.
    public var byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr?

    public init(
        byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr? = nil
    )
    {
        self.byoipCidr = byoipCidr
    }
}

struct DeprovisionByoipCidrOutputBody: Swift.Equatable {
    let byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr?
}

extension DeprovisionByoipCidrOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case byoipCidr = "ByoipCidr"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let byoipCidrDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.ByoipCidr.self, forKey: .byoipCidr)
        byoipCidr = byoipCidrDecoded
    }
}

enum DeprovisionByoipCidrOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ByoipCidrNotFoundException": return try await ByoipCidrNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IncorrectCidrStateException": return try await IncorrectCidrStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAcceleratorAttributesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = self.acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
    }
}

extension DescribeAcceleratorAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAcceleratorAttributesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the accelerator with the attributes that you want to describe.
    /// This member is required.
    public var acceleratorArn: Swift.String?

    public init(
        acceleratorArn: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
    }
}

struct DescribeAcceleratorAttributesInputBody: Swift.Equatable {
    let acceleratorArn: Swift.String?
}

extension DescribeAcceleratorAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
    }
}

extension DescribeAcceleratorAttributesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAcceleratorAttributesOutputBody = try responseDecoder.decode(responseBody: data)
            self.acceleratorAttributes = output.acceleratorAttributes
        } else {
            self.acceleratorAttributes = nil
        }
    }
}

public struct DescribeAcceleratorAttributesOutput: Swift.Equatable {
    /// The attributes of the accelerator.
    public var acceleratorAttributes: GlobalAcceleratorClientTypes.AcceleratorAttributes?

    public init(
        acceleratorAttributes: GlobalAcceleratorClientTypes.AcceleratorAttributes? = nil
    )
    {
        self.acceleratorAttributes = acceleratorAttributes
    }
}

struct DescribeAcceleratorAttributesOutputBody: Swift.Equatable {
    let acceleratorAttributes: GlobalAcceleratorClientTypes.AcceleratorAttributes?
}

extension DescribeAcceleratorAttributesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorAttributes = "AcceleratorAttributes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorAttributesDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.AcceleratorAttributes.self, forKey: .acceleratorAttributes)
        acceleratorAttributes = acceleratorAttributesDecoded
    }
}

enum DescribeAcceleratorAttributesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AcceleratorNotFoundException": return try await AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAcceleratorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = self.acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
    }
}

extension DescribeAcceleratorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAcceleratorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the accelerator to describe.
    /// This member is required.
    public var acceleratorArn: Swift.String?

    public init(
        acceleratorArn: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
    }
}

struct DescribeAcceleratorInputBody: Swift.Equatable {
    let acceleratorArn: Swift.String?
}

extension DescribeAcceleratorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
    }
}

extension DescribeAcceleratorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAcceleratorOutputBody = try responseDecoder.decode(responseBody: data)
            self.accelerator = output.accelerator
        } else {
            self.accelerator = nil
        }
    }
}

public struct DescribeAcceleratorOutput: Swift.Equatable {
    /// The description of the accelerator.
    public var accelerator: GlobalAcceleratorClientTypes.Accelerator?

    public init(
        accelerator: GlobalAcceleratorClientTypes.Accelerator? = nil
    )
    {
        self.accelerator = accelerator
    }
}

struct DescribeAcceleratorOutputBody: Swift.Equatable {
    let accelerator: GlobalAcceleratorClientTypes.Accelerator?
}

extension DescribeAcceleratorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accelerator = "Accelerator"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.Accelerator.self, forKey: .accelerator)
        accelerator = acceleratorDecoded
    }
}

enum DescribeAcceleratorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AcceleratorNotFoundException": return try await AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeCustomRoutingAcceleratorAttributesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = self.acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
    }
}

extension DescribeCustomRoutingAcceleratorAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeCustomRoutingAcceleratorAttributesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the custom routing accelerator to describe the attributes for.
    /// This member is required.
    public var acceleratorArn: Swift.String?

    public init(
        acceleratorArn: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
    }
}

struct DescribeCustomRoutingAcceleratorAttributesInputBody: Swift.Equatable {
    let acceleratorArn: Swift.String?
}

extension DescribeCustomRoutingAcceleratorAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
    }
}

extension DescribeCustomRoutingAcceleratorAttributesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeCustomRoutingAcceleratorAttributesOutputBody = try responseDecoder.decode(responseBody: data)
            self.acceleratorAttributes = output.acceleratorAttributes
        } else {
            self.acceleratorAttributes = nil
        }
    }
}

public struct DescribeCustomRoutingAcceleratorAttributesOutput: Swift.Equatable {
    /// The attributes of the custom routing accelerator.
    public var acceleratorAttributes: GlobalAcceleratorClientTypes.CustomRoutingAcceleratorAttributes?

    public init(
        acceleratorAttributes: GlobalAcceleratorClientTypes.CustomRoutingAcceleratorAttributes? = nil
    )
    {
        self.acceleratorAttributes = acceleratorAttributes
    }
}

struct DescribeCustomRoutingAcceleratorAttributesOutputBody: Swift.Equatable {
    let acceleratorAttributes: GlobalAcceleratorClientTypes.CustomRoutingAcceleratorAttributes?
}

extension DescribeCustomRoutingAcceleratorAttributesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorAttributes = "AcceleratorAttributes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorAttributesDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CustomRoutingAcceleratorAttributes.self, forKey: .acceleratorAttributes)
        acceleratorAttributes = acceleratorAttributesDecoded
    }
}

enum DescribeCustomRoutingAcceleratorAttributesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AcceleratorNotFoundException": return try await AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeCustomRoutingAcceleratorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = self.acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
    }
}

extension DescribeCustomRoutingAcceleratorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeCustomRoutingAcceleratorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the accelerator to describe.
    /// This member is required.
    public var acceleratorArn: Swift.String?

    public init(
        acceleratorArn: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
    }
}

struct DescribeCustomRoutingAcceleratorInputBody: Swift.Equatable {
    let acceleratorArn: Swift.String?
}

extension DescribeCustomRoutingAcceleratorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
    }
}

extension DescribeCustomRoutingAcceleratorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeCustomRoutingAcceleratorOutputBody = try responseDecoder.decode(responseBody: data)
            self.accelerator = output.accelerator
        } else {
            self.accelerator = nil
        }
    }
}

public struct DescribeCustomRoutingAcceleratorOutput: Swift.Equatable {
    /// The description of the custom routing accelerator.
    public var accelerator: GlobalAcceleratorClientTypes.CustomRoutingAccelerator?

    public init(
        accelerator: GlobalAcceleratorClientTypes.CustomRoutingAccelerator? = nil
    )
    {
        self.accelerator = accelerator
    }
}

struct DescribeCustomRoutingAcceleratorOutputBody: Swift.Equatable {
    let accelerator: GlobalAcceleratorClientTypes.CustomRoutingAccelerator?
}

extension DescribeCustomRoutingAcceleratorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accelerator = "Accelerator"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CustomRoutingAccelerator.self, forKey: .accelerator)
        accelerator = acceleratorDecoded
    }
}

enum DescribeCustomRoutingAcceleratorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AcceleratorNotFoundException": return try await AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeCustomRoutingEndpointGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointGroupArn = self.endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
    }
}

extension DescribeCustomRoutingEndpointGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeCustomRoutingEndpointGroupInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the endpoint group to describe.
    /// This member is required.
    public var endpointGroupArn: Swift.String?

    public init(
        endpointGroupArn: Swift.String? = nil
    )
    {
        self.endpointGroupArn = endpointGroupArn
    }
}

struct DescribeCustomRoutingEndpointGroupInputBody: Swift.Equatable {
    let endpointGroupArn: Swift.String?
}

extension DescribeCustomRoutingEndpointGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
    }
}

extension DescribeCustomRoutingEndpointGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeCustomRoutingEndpointGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.endpointGroup = output.endpointGroup
        } else {
            self.endpointGroup = nil
        }
    }
}

public struct DescribeCustomRoutingEndpointGroupOutput: Swift.Equatable {
    /// The description of an endpoint group for a custom routing accelerator.
    public var endpointGroup: GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup?

    public init(
        endpointGroup: GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup? = nil
    )
    {
        self.endpointGroup = endpointGroup
    }
}

struct DescribeCustomRoutingEndpointGroupOutputBody: Swift.Equatable {
    let endpointGroup: GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup?
}

extension DescribeCustomRoutingEndpointGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroup = "EndpointGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup.self, forKey: .endpointGroup)
        endpointGroup = endpointGroupDecoded
    }
}

enum DescribeCustomRoutingEndpointGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EndpointGroupNotFoundException": return try await EndpointGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeCustomRoutingListenerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listenerArn = self.listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
    }
}

extension DescribeCustomRoutingListenerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeCustomRoutingListenerInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the listener to describe.
    /// This member is required.
    public var listenerArn: Swift.String?

    public init(
        listenerArn: Swift.String? = nil
    )
    {
        self.listenerArn = listenerArn
    }
}

struct DescribeCustomRoutingListenerInputBody: Swift.Equatable {
    let listenerArn: Swift.String?
}

extension DescribeCustomRoutingListenerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
    }
}

extension DescribeCustomRoutingListenerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeCustomRoutingListenerOutputBody = try responseDecoder.decode(responseBody: data)
            self.listener = output.listener
        } else {
            self.listener = nil
        }
    }
}

public struct DescribeCustomRoutingListenerOutput: Swift.Equatable {
    /// The description of a listener for a custom routing accelerator.
    public var listener: GlobalAcceleratorClientTypes.CustomRoutingListener?

    public init(
        listener: GlobalAcceleratorClientTypes.CustomRoutingListener? = nil
    )
    {
        self.listener = listener
    }
}

struct DescribeCustomRoutingListenerOutputBody: Swift.Equatable {
    let listener: GlobalAcceleratorClientTypes.CustomRoutingListener?
}

extension DescribeCustomRoutingListenerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listener = "Listener"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CustomRoutingListener.self, forKey: .listener)
        listener = listenerDecoded
    }
}

enum DescribeCustomRoutingListenerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ListenerNotFoundException": return try await ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeEndpointGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointGroupArn = self.endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
    }
}

extension DescribeEndpointGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEndpointGroupInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the endpoint group to describe.
    /// This member is required.
    public var endpointGroupArn: Swift.String?

    public init(
        endpointGroupArn: Swift.String? = nil
    )
    {
        self.endpointGroupArn = endpointGroupArn
    }
}

struct DescribeEndpointGroupInputBody: Swift.Equatable {
    let endpointGroupArn: Swift.String?
}

extension DescribeEndpointGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
    }
}

extension DescribeEndpointGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeEndpointGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.endpointGroup = output.endpointGroup
        } else {
            self.endpointGroup = nil
        }
    }
}

public struct DescribeEndpointGroupOutput: Swift.Equatable {
    /// The description of an endpoint group.
    public var endpointGroup: GlobalAcceleratorClientTypes.EndpointGroup?

    public init(
        endpointGroup: GlobalAcceleratorClientTypes.EndpointGroup? = nil
    )
    {
        self.endpointGroup = endpointGroup
    }
}

struct DescribeEndpointGroupOutputBody: Swift.Equatable {
    let endpointGroup: GlobalAcceleratorClientTypes.EndpointGroup?
}

extension DescribeEndpointGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroup = "EndpointGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.EndpointGroup.self, forKey: .endpointGroup)
        endpointGroup = endpointGroupDecoded
    }
}

enum DescribeEndpointGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EndpointGroupNotFoundException": return try await EndpointGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeListenerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listenerArn = self.listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
    }
}

extension DescribeListenerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeListenerInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the listener to describe.
    /// This member is required.
    public var listenerArn: Swift.String?

    public init(
        listenerArn: Swift.String? = nil
    )
    {
        self.listenerArn = listenerArn
    }
}

struct DescribeListenerInputBody: Swift.Equatable {
    let listenerArn: Swift.String?
}

extension DescribeListenerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
    }
}

extension DescribeListenerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeListenerOutputBody = try responseDecoder.decode(responseBody: data)
            self.listener = output.listener
        } else {
            self.listener = nil
        }
    }
}

public struct DescribeListenerOutput: Swift.Equatable {
    /// The description of a listener.
    public var listener: GlobalAcceleratorClientTypes.Listener?

    public init(
        listener: GlobalAcceleratorClientTypes.Listener? = nil
    )
    {
        self.listener = listener
    }
}

struct DescribeListenerOutputBody: Swift.Equatable {
    let listener: GlobalAcceleratorClientTypes.Listener?
}

extension DescribeListenerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listener = "Listener"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.Listener.self, forKey: .listener)
        listener = listenerDecoded
    }
}

enum DescribeListenerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ListenerNotFoundException": return try await ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GlobalAcceleratorClientTypes.DestinationPortMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case acceleratorSocketAddresses = "AcceleratorSocketAddresses"
        case destinationSocketAddress = "DestinationSocketAddress"
        case destinationTrafficState = "DestinationTrafficState"
        case endpointGroupArn = "EndpointGroupArn"
        case endpointGroupRegion = "EndpointGroupRegion"
        case endpointId = "EndpointId"
        case ipAddressType = "IpAddressType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = self.acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let acceleratorSocketAddresses = acceleratorSocketAddresses {
            var acceleratorSocketAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .acceleratorSocketAddresses)
            for socketaddress0 in acceleratorSocketAddresses {
                try acceleratorSocketAddressesContainer.encode(socketaddress0)
            }
        }
        if let destinationSocketAddress = self.destinationSocketAddress {
            try encodeContainer.encode(destinationSocketAddress, forKey: .destinationSocketAddress)
        }
        if let destinationTrafficState = self.destinationTrafficState {
            try encodeContainer.encode(destinationTrafficState.rawValue, forKey: .destinationTrafficState)
        }
        if let endpointGroupArn = self.endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
        if let endpointGroupRegion = self.endpointGroupRegion {
            try encodeContainer.encode(endpointGroupRegion, forKey: .endpointGroupRegion)
        }
        if let endpointId = self.endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
        if let ipAddressType = self.ipAddressType {
            try encodeContainer.encode(ipAddressType.rawValue, forKey: .ipAddressType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let acceleratorSocketAddressesContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.SocketAddress?].self, forKey: .acceleratorSocketAddresses)
        var acceleratorSocketAddressesDecoded0:[GlobalAcceleratorClientTypes.SocketAddress]? = nil
        if let acceleratorSocketAddressesContainer = acceleratorSocketAddressesContainer {
            acceleratorSocketAddressesDecoded0 = [GlobalAcceleratorClientTypes.SocketAddress]()
            for structure0 in acceleratorSocketAddressesContainer {
                if let structure0 = structure0 {
                    acceleratorSocketAddressesDecoded0?.append(structure0)
                }
            }
        }
        acceleratorSocketAddresses = acceleratorSocketAddressesDecoded0
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
        let endpointGroupRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupRegion)
        endpointGroupRegion = endpointGroupRegionDecoded
        let destinationSocketAddressDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.SocketAddress.self, forKey: .destinationSocketAddress)
        destinationSocketAddress = destinationSocketAddressDecoded
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.IpAddressType.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
        let destinationTrafficStateDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CustomRoutingDestinationTrafficState.self, forKey: .destinationTrafficState)
        destinationTrafficState = destinationTrafficStateDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    /// The port mappings for a specified endpoint IP address (destination).
    public struct DestinationPortMapping: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the custom routing accelerator that you have port mappings for.
        public var acceleratorArn: Swift.String?
        /// The IP address/port combinations (sockets) that map to a given destination socket address.
        public var acceleratorSocketAddresses: [GlobalAcceleratorClientTypes.SocketAddress]?
        /// The endpoint IP address/port combination for traffic received on the accelerator socket address.
        public var destinationSocketAddress: GlobalAcceleratorClientTypes.SocketAddress?
        /// Indicates whether or not a port mapping destination can receive traffic. The value is either ALLOW, if traffic is allowed to the destination, or DENY, if traffic is not allowed to the destination.
        public var destinationTrafficState: GlobalAcceleratorClientTypes.CustomRoutingDestinationTrafficState?
        /// The Amazon Resource Name (ARN) of the endpoint group.
        public var endpointGroupArn: Swift.String?
        /// The Amazon Web Services Region for the endpoint group.
        public var endpointGroupRegion: Swift.String?
        /// The ID for the virtual private cloud (VPC) subnet.
        public var endpointId: Swift.String?
        /// The IP address type that an accelerator supports. For a custom routing accelerator, the value must be IPV4.
        public var ipAddressType: GlobalAcceleratorClientTypes.IpAddressType?

        public init(
            acceleratorArn: Swift.String? = nil,
            acceleratorSocketAddresses: [GlobalAcceleratorClientTypes.SocketAddress]? = nil,
            destinationSocketAddress: GlobalAcceleratorClientTypes.SocketAddress? = nil,
            destinationTrafficState: GlobalAcceleratorClientTypes.CustomRoutingDestinationTrafficState? = nil,
            endpointGroupArn: Swift.String? = nil,
            endpointGroupRegion: Swift.String? = nil,
            endpointId: Swift.String? = nil,
            ipAddressType: GlobalAcceleratorClientTypes.IpAddressType? = nil
        )
        {
            self.acceleratorArn = acceleratorArn
            self.acceleratorSocketAddresses = acceleratorSocketAddresses
            self.destinationSocketAddress = destinationSocketAddress
            self.destinationTrafficState = destinationTrafficState
            self.endpointGroupArn = endpointGroupArn
            self.endpointGroupRegion = endpointGroupRegion
            self.endpointId = endpointId
            self.ipAddressType = ipAddressType
        }
    }

}

extension EndpointAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EndpointAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The endpoint that you specified doesn't exist.
public struct EndpointAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EndpointAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct EndpointAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EndpointAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GlobalAcceleratorClientTypes.EndpointConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientIPPreservationEnabled = "ClientIPPreservationEnabled"
        case endpointId = "EndpointId"
        case weight = "Weight"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientIPPreservationEnabled = self.clientIPPreservationEnabled {
            try encodeContainer.encode(clientIPPreservationEnabled, forKey: .clientIPPreservationEnabled)
        }
        if let endpointId = self.endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
        if let weight = self.weight {
            try encodeContainer.encode(weight, forKey: .weight)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
        let weightDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .weight)
        weight = weightDecoded
        let clientIPPreservationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .clientIPPreservationEnabled)
        clientIPPreservationEnabled = clientIPPreservationEnabledDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    /// A complex type for endpoints. A resource must be valid and active when you add it as an endpoint.
    public struct EndpointConfiguration: Swift.Equatable {
        /// Indicates whether client IP address preservation is enabled for an endpoint. The value is true or false. The default value is true for new accelerators. If the value is set to true, the client's IP address is preserved in the X-Forwarded-For request header as traffic travels to applications on the endpoint fronted by the accelerator. Client IP address preservation is supported, in specific Amazon Web Services Regions, for endpoints that are Application Load Balancers, Amazon EC2 instances, and Network Load Balancers with Security Groups. IMPORTANT: You cannot use client IP address preservation with Network Load Balancers with TLS listeners. For more information, see [ Preserve client IP addresses in Global Accelerator](https://docs.aws.amazon.com/global-accelerator/latest/dg/preserve-client-ip-address.html) in the Global Accelerator Developer Guide.
        public var clientIPPreservationEnabled: Swift.Bool?
        /// An ID for the endpoint. If the endpoint is a Network Load Balancer or Application Load Balancer, this is the Amazon Resource Name (ARN) of the resource. If the endpoint is an Elastic IP address, this is the Elastic IP address allocation ID. For Amazon EC2 instances, this is the EC2 instance ID. A resource must be valid and active when you add it as an endpoint. An Application Load Balancer can be either internal or internet-facing.
        public var endpointId: Swift.String?
        /// The weight associated with the endpoint. When you add weights to endpoints, you configure Global Accelerator to route traffic based on proportions that you specify. For example, you might specify endpoint weights of 4, 5, 5, and 6 (sum=20). The result is that 4/20 of your traffic, on average, is routed to the first endpoint, 5/20 is routed both to the second and third endpoints, and 6/20 is routed to the last endpoint. For more information, see [Endpoint weights](https://docs.aws.amazon.com/global-accelerator/latest/dg/about-endpoints-endpoint-weights.html) in the Global Accelerator Developer Guide.
        public var weight: Swift.Int?

        public init(
            clientIPPreservationEnabled: Swift.Bool? = nil,
            endpointId: Swift.String? = nil,
            weight: Swift.Int? = nil
        )
        {
            self.clientIPPreservationEnabled = clientIPPreservationEnabled
            self.endpointId = endpointId
            self.weight = weight
        }
    }

}

extension GlobalAcceleratorClientTypes.EndpointDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientIPPreservationEnabled = "ClientIPPreservationEnabled"
        case endpointId = "EndpointId"
        case healthReason = "HealthReason"
        case healthState = "HealthState"
        case weight = "Weight"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientIPPreservationEnabled = self.clientIPPreservationEnabled {
            try encodeContainer.encode(clientIPPreservationEnabled, forKey: .clientIPPreservationEnabled)
        }
        if let endpointId = self.endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
        if let healthReason = self.healthReason {
            try encodeContainer.encode(healthReason, forKey: .healthReason)
        }
        if let healthState = self.healthState {
            try encodeContainer.encode(healthState.rawValue, forKey: .healthState)
        }
        if let weight = self.weight {
            try encodeContainer.encode(weight, forKey: .weight)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
        let weightDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .weight)
        weight = weightDecoded
        let healthStateDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.HealthState.self, forKey: .healthState)
        healthState = healthStateDecoded
        let healthReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .healthReason)
        healthReason = healthReasonDecoded
        let clientIPPreservationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .clientIPPreservationEnabled)
        clientIPPreservationEnabled = clientIPPreservationEnabledDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    /// A complex type for an endpoint. Each endpoint group can include one or more endpoints, such as load balancers.
    public struct EndpointDescription: Swift.Equatable {
        /// Indicates whether client IP address preservation is enabled for an endpoint. The value is true or false. The default value is true for new accelerators. If the value is set to true, the client's IP address is preserved in the X-Forwarded-For request header as traffic travels to applications on the endpoint fronted by the accelerator. Client IP address preservation is supported, in specific Amazon Web Services Regions, for endpoints that are Application Load Balancers, Amazon EC2 instances, and Network Load Balancers with Security Groups. IMPORTANT: You cannot use client IP address preservation with Network Load Balancers with TLS listeners. For more information, see [ Preserve client IP addresses in Global Accelerator](https://docs.aws.amazon.com/global-accelerator/latest/dg/preserve-client-ip-address.html) in the Global Accelerator Developer Guide.
        public var clientIPPreservationEnabled: Swift.Bool?
        /// An ID for the endpoint. If the endpoint is a Network Load Balancer or Application Load Balancer, this is the Amazon Resource Name (ARN) of the resource. If the endpoint is an Elastic IP address, this is the Elastic IP address allocation ID. For Amazon EC2 instances, this is the EC2 instance ID. An Application Load Balancer can be either internal or internet-facing.
        public var endpointId: Swift.String?
        /// Returns a null result.
        public var healthReason: Swift.String?
        /// The health status of the endpoint.
        public var healthState: GlobalAcceleratorClientTypes.HealthState?
        /// The weight associated with the endpoint. When you add weights to endpoints, you configure Global Accelerator to route traffic based on proportions that you specify. For example, you might specify endpoint weights of 4, 5, 5, and 6 (sum=20). The result is that 4/20 of your traffic, on average, is routed to the first endpoint, 5/20 is routed both to the second and third endpoints, and 6/20 is routed to the last endpoint. For more information, see [Endpoint weights](https://docs.aws.amazon.com/global-accelerator/latest/dg/about-endpoints-endpoint-weights.html) in the Global Accelerator Developer Guide.
        public var weight: Swift.Int?

        public init(
            clientIPPreservationEnabled: Swift.Bool? = nil,
            endpointId: Swift.String? = nil,
            healthReason: Swift.String? = nil,
            healthState: GlobalAcceleratorClientTypes.HealthState? = nil,
            weight: Swift.Int? = nil
        )
        {
            self.clientIPPreservationEnabled = clientIPPreservationEnabled
            self.endpointId = endpointId
            self.healthReason = healthReason
            self.healthState = healthState
            self.weight = weight
        }
    }

}

extension GlobalAcceleratorClientTypes.EndpointGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointDescriptions = "EndpointDescriptions"
        case endpointGroupArn = "EndpointGroupArn"
        case endpointGroupRegion = "EndpointGroupRegion"
        case healthCheckIntervalSeconds = "HealthCheckIntervalSeconds"
        case healthCheckPath = "HealthCheckPath"
        case healthCheckPort = "HealthCheckPort"
        case healthCheckProtocol = "HealthCheckProtocol"
        case portOverrides = "PortOverrides"
        case thresholdCount = "ThresholdCount"
        case trafficDialPercentage = "TrafficDialPercentage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointDescriptions = endpointDescriptions {
            var endpointDescriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpointDescriptions)
            for endpointdescription0 in endpointDescriptions {
                try endpointDescriptionsContainer.encode(endpointdescription0)
            }
        }
        if let endpointGroupArn = self.endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
        if let endpointGroupRegion = self.endpointGroupRegion {
            try encodeContainer.encode(endpointGroupRegion, forKey: .endpointGroupRegion)
        }
        if let healthCheckIntervalSeconds = self.healthCheckIntervalSeconds {
            try encodeContainer.encode(healthCheckIntervalSeconds, forKey: .healthCheckIntervalSeconds)
        }
        if let healthCheckPath = self.healthCheckPath {
            try encodeContainer.encode(healthCheckPath, forKey: .healthCheckPath)
        }
        if let healthCheckPort = self.healthCheckPort {
            try encodeContainer.encode(healthCheckPort, forKey: .healthCheckPort)
        }
        if let healthCheckProtocol = self.healthCheckProtocol {
            try encodeContainer.encode(healthCheckProtocol.rawValue, forKey: .healthCheckProtocol)
        }
        if let portOverrides = portOverrides {
            var portOverridesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portOverrides)
            for portoverride0 in portOverrides {
                try portOverridesContainer.encode(portoverride0)
            }
        }
        if let thresholdCount = self.thresholdCount {
            try encodeContainer.encode(thresholdCount, forKey: .thresholdCount)
        }
        if let trafficDialPercentage = self.trafficDialPercentage {
            try encodeContainer.encode(trafficDialPercentage, forKey: .trafficDialPercentage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
        let endpointGroupRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupRegion)
        endpointGroupRegion = endpointGroupRegionDecoded
        let endpointDescriptionsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.EndpointDescription?].self, forKey: .endpointDescriptions)
        var endpointDescriptionsDecoded0:[GlobalAcceleratorClientTypes.EndpointDescription]? = nil
        if let endpointDescriptionsContainer = endpointDescriptionsContainer {
            endpointDescriptionsDecoded0 = [GlobalAcceleratorClientTypes.EndpointDescription]()
            for structure0 in endpointDescriptionsContainer {
                if let structure0 = structure0 {
                    endpointDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        endpointDescriptions = endpointDescriptionsDecoded0
        let trafficDialPercentageDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .trafficDialPercentage)
        trafficDialPercentage = trafficDialPercentageDecoded
        let healthCheckPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthCheckPort)
        healthCheckPort = healthCheckPortDecoded
        let healthCheckProtocolDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.HealthCheckProtocol.self, forKey: .healthCheckProtocol)
        healthCheckProtocol = healthCheckProtocolDecoded
        let healthCheckPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .healthCheckPath)
        healthCheckPath = healthCheckPathDecoded
        let healthCheckIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthCheckIntervalSeconds)
        healthCheckIntervalSeconds = healthCheckIntervalSecondsDecoded
        let thresholdCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .thresholdCount)
        thresholdCount = thresholdCountDecoded
        let portOverridesContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.PortOverride?].self, forKey: .portOverrides)
        var portOverridesDecoded0:[GlobalAcceleratorClientTypes.PortOverride]? = nil
        if let portOverridesContainer = portOverridesContainer {
            portOverridesDecoded0 = [GlobalAcceleratorClientTypes.PortOverride]()
            for structure0 in portOverridesContainer {
                if let structure0 = structure0 {
                    portOverridesDecoded0?.append(structure0)
                }
            }
        }
        portOverrides = portOverridesDecoded0
    }
}

extension GlobalAcceleratorClientTypes {
    /// A complex type for the endpoint group. An Amazon Web Services Region can have only one endpoint group for a specific listener.
    public struct EndpointGroup: Swift.Equatable {
        /// The list of endpoint objects.
        public var endpointDescriptions: [GlobalAcceleratorClientTypes.EndpointDescription]?
        /// The Amazon Resource Name (ARN) of the endpoint group.
        public var endpointGroupArn: Swift.String?
        /// The Amazon Web Services Region where the endpoint group is located.
        public var endpointGroupRegion: Swift.String?
        /// The time10 seconds or 30 secondsbetween health checks for each endpoint. The default value is 30.
        public var healthCheckIntervalSeconds: Swift.Int?
        /// If the protocol is HTTP/S, then this value provides the ping path that Global Accelerator uses for the destination on the endpoints for health checks. The default is slash (/).
        public var healthCheckPath: Swift.String?
        /// The port that Global Accelerator uses to perform health checks on endpoints that are part of this endpoint group. The default port is the port for the listener that this endpoint group is associated with. If the listener port is a list, Global Accelerator uses the first specified port in the list of ports.
        public var healthCheckPort: Swift.Int?
        /// The protocol that Global Accelerator uses to perform health checks on endpoints that are part of this endpoint group. The default value is TCP.
        public var healthCheckProtocol: GlobalAcceleratorClientTypes.HealthCheckProtocol?
        /// Allows you to override the destination ports used to route traffic to an endpoint. Using a port override lets you map a list of external destination ports (that your users send traffic to) to a list of internal destination ports that you want an application endpoint to receive traffic on.
        public var portOverrides: [GlobalAcceleratorClientTypes.PortOverride]?
        /// The number of consecutive health checks required to set the state of a healthy endpoint to unhealthy, or to set an unhealthy endpoint to healthy. The default value is 3.
        public var thresholdCount: Swift.Int?
        /// The percentage of traffic to send to an Amazon Web Services Region. Additional traffic is distributed to other endpoint groups for this listener. Use this action to increase (dial up) or decrease (dial down) traffic to a specific Region. The percentage is applied to the traffic that would otherwise have been routed to the Region based on optimal routing. The default value is 100.
        public var trafficDialPercentage: Swift.Float?

        public init(
            endpointDescriptions: [GlobalAcceleratorClientTypes.EndpointDescription]? = nil,
            endpointGroupArn: Swift.String? = nil,
            endpointGroupRegion: Swift.String? = nil,
            healthCheckIntervalSeconds: Swift.Int? = nil,
            healthCheckPath: Swift.String? = nil,
            healthCheckPort: Swift.Int? = nil,
            healthCheckProtocol: GlobalAcceleratorClientTypes.HealthCheckProtocol? = nil,
            portOverrides: [GlobalAcceleratorClientTypes.PortOverride]? = nil,
            thresholdCount: Swift.Int? = nil,
            trafficDialPercentage: Swift.Float? = nil
        )
        {
            self.endpointDescriptions = endpointDescriptions
            self.endpointGroupArn = endpointGroupArn
            self.endpointGroupRegion = endpointGroupRegion
            self.healthCheckIntervalSeconds = healthCheckIntervalSeconds
            self.healthCheckPath = healthCheckPath
            self.healthCheckPort = healthCheckPort
            self.healthCheckProtocol = healthCheckProtocol
            self.portOverrides = portOverrides
            self.thresholdCount = thresholdCount
            self.trafficDialPercentage = trafficDialPercentage
        }
    }

}

extension EndpointGroupAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EndpointGroupAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The endpoint group that you specified already exists.
public struct EndpointGroupAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EndpointGroupAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct EndpointGroupAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EndpointGroupAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EndpointGroupNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EndpointGroupNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The endpoint group that you specified doesn't exist.
public struct EndpointGroupNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EndpointGroupNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct EndpointGroupNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EndpointGroupNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GlobalAcceleratorClientTypes.EndpointIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientIPPreservationEnabled = "ClientIPPreservationEnabled"
        case endpointId = "EndpointId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientIPPreservationEnabled = self.clientIPPreservationEnabled {
            try encodeContainer.encode(clientIPPreservationEnabled, forKey: .clientIPPreservationEnabled)
        }
        if let endpointId = self.endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
        let clientIPPreservationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .clientIPPreservationEnabled)
        clientIPPreservationEnabled = clientIPPreservationEnabledDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    /// A complex type for an endpoint. Specifies information about the endpoint to remove from the endpoint group.
    public struct EndpointIdentifier: Swift.Equatable {
        /// Indicates whether client IP address preservation is enabled for an endpoint. The value is true or false. If the value is set to true, the client's IP address is preserved in the X-Forwarded-For request header as traffic travels to applications on the endpoint fronted by the accelerator.
        public var clientIPPreservationEnabled: Swift.Bool?
        /// An ID for the endpoint. If the endpoint is a Network Load Balancer or Application Load Balancer, this is the Amazon Resource Name (ARN) of the resource. If the endpoint is an Elastic IP address, this is the Elastic IP address allocation ID. For Amazon EC2 instances, this is the EC2 instance ID. An Application Load Balancer can be either internal or internet-facing.
        /// This member is required.
        public var endpointId: Swift.String?

        public init(
            clientIPPreservationEnabled: Swift.Bool? = nil,
            endpointId: Swift.String? = nil
        )
        {
            self.clientIPPreservationEnabled = clientIPPreservationEnabled
            self.endpointId = endpointId
        }
    }

}

extension EndpointNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EndpointNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The endpoint that you specified doesn't exist.
public struct EndpointNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EndpointNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct EndpointNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EndpointNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    public enum HealthCheckProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case http
        case https
        case tcp
        case sdkUnknown(Swift.String)

        public static var allCases: [HealthCheckProtocol] {
            return [
                .http,
                .https,
                .tcp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .http: return "HTTP"
            case .https: return "HTTPS"
            case .tcp: return "TCP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HealthCheckProtocol(rawValue: rawValue) ?? HealthCheckProtocol.sdkUnknown(rawValue)
        }
    }
}

extension GlobalAcceleratorClientTypes {
    public enum HealthState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case healthy
        case initial
        case unhealthy
        case sdkUnknown(Swift.String)

        public static var allCases: [HealthState] {
            return [
                .healthy,
                .initial,
                .unhealthy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .healthy: return "HEALTHY"
            case .initial: return "INITIAL"
            case .unhealthy: return "UNHEALTHY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HealthState(rawValue: rawValue) ?? HealthState.sdkUnknown(rawValue)
        }
    }
}

extension IncorrectCidrStateException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: IncorrectCidrStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The CIDR that you specified is not valid for this action. For example, the state of the CIDR might be incorrect for this action.
public struct IncorrectCidrStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IncorrectCidrStateException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct IncorrectCidrStateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension IncorrectCidrStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalServiceErrorException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServiceErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There was an internal error for Global Accelerator.
public struct InternalServiceErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServiceErrorException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServiceErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServiceErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidArgumentException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidArgumentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An argument that you specified is invalid.
public struct InvalidArgumentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidArgumentException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidArgumentExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidArgumentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There isn't another item to return.
public struct InvalidNextTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNextTokenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPortRangeException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidPortRangeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The port numbers that you specified are not valid numbers or are not unique for this accelerator.
public struct InvalidPortRangeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPortRangeException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidPortRangeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidPortRangeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    public enum IpAddressFamily: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ipv4
        case ipv6
        case sdkUnknown(Swift.String)

        public static var allCases: [IpAddressFamily] {
            return [
                .ipv4,
                .ipv6,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ipv4: return "IPv4"
            case .ipv6: return "IPv6"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IpAddressFamily(rawValue: rawValue) ?? IpAddressFamily.sdkUnknown(rawValue)
        }
    }
}

extension GlobalAcceleratorClientTypes {
    public enum IpAddressType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dualStack
        case ipv4
        case sdkUnknown(Swift.String)

        public static var allCases: [IpAddressType] {
            return [
                .dualStack,
                .ipv4,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dualStack: return "DUAL_STACK"
            case .ipv4: return "IPV4"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IpAddressType(rawValue: rawValue) ?? IpAddressType.sdkUnknown(rawValue)
        }
    }
}

extension GlobalAcceleratorClientTypes.IpSet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAddressFamily = "IpAddressFamily"
        case ipAddresses = "IpAddresses"
        case ipFamily = "IpFamily"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipAddressFamily = self.ipAddressFamily {
            try encodeContainer.encode(ipAddressFamily.rawValue, forKey: .ipAddressFamily)
        }
        if let ipAddresses = ipAddresses {
            var ipAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipAddresses)
            for ipaddress0 in ipAddresses {
                try ipAddressesContainer.encode(ipaddress0)
            }
        }
        if let ipFamily = self.ipFamily {
            try encodeContainer.encode(ipFamily, forKey: .ipFamily)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipFamily)
        ipFamily = ipFamilyDecoded
        let ipAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ipAddresses)
        var ipAddressesDecoded0:[Swift.String]? = nil
        if let ipAddressesContainer = ipAddressesContainer {
            ipAddressesDecoded0 = [Swift.String]()
            for string0 in ipAddressesContainer {
                if let string0 = string0 {
                    ipAddressesDecoded0?.append(string0)
                }
            }
        }
        ipAddresses = ipAddressesDecoded0
        let ipAddressFamilyDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.IpAddressFamily.self, forKey: .ipAddressFamily)
        ipAddressFamily = ipAddressFamilyDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    /// A complex type for the set of IP addresses for an accelerator.
    public struct IpSet: Swift.Equatable {
        /// The types of IP addresses included in this IP set.
        public var ipAddressFamily: GlobalAcceleratorClientTypes.IpAddressFamily?
        /// The array of IP addresses in the IP address set. An IP address set can have a maximum of two IP addresses.
        public var ipAddresses: [Swift.String]?
        /// IpFamily is deprecated and has been replaced by IpAddressFamily.
        @available(*, deprecated, message: "IpFamily has been replaced by IpAddressFamily")
        public var ipFamily: Swift.String?

        public init(
            ipAddressFamily: GlobalAcceleratorClientTypes.IpAddressFamily? = nil,
            ipAddresses: [Swift.String]? = nil,
            ipFamily: Swift.String? = nil
        )
        {
            self.ipAddressFamily = ipAddressFamily
            self.ipAddresses = ipAddresses
            self.ipFamily = ipFamily
        }
    }

}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Processing your request would cause you to exceed an Global Accelerator limit.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAcceleratorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAcceleratorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAcceleratorsInput: Swift.Equatable {
    /// The number of Global Accelerator objects that you want to return with this call. The default value is 10.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAcceleratorsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListAcceleratorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAcceleratorsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAcceleratorsOutputBody = try responseDecoder.decode(responseBody: data)
            self.accelerators = output.accelerators
            self.nextToken = output.nextToken
        } else {
            self.accelerators = nil
            self.nextToken = nil
        }
    }
}

public struct ListAcceleratorsOutput: Swift.Equatable {
    /// The list of accelerators for a customer account.
    public var accelerators: [GlobalAcceleratorClientTypes.Accelerator]?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        accelerators: [GlobalAcceleratorClientTypes.Accelerator]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accelerators = accelerators
        self.nextToken = nextToken
    }
}

struct ListAcceleratorsOutputBody: Swift.Equatable {
    let accelerators: [GlobalAcceleratorClientTypes.Accelerator]?
    let nextToken: Swift.String?
}

extension ListAcceleratorsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accelerators = "Accelerators"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.Accelerator?].self, forKey: .accelerators)
        var acceleratorsDecoded0:[GlobalAcceleratorClientTypes.Accelerator]? = nil
        if let acceleratorsContainer = acceleratorsContainer {
            acceleratorsDecoded0 = [GlobalAcceleratorClientTypes.Accelerator]()
            for structure0 in acceleratorsContainer {
                if let structure0 = structure0 {
                    acceleratorsDecoded0?.append(structure0)
                }
            }
        }
        accelerators = acceleratorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAcceleratorsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListByoipCidrsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListByoipCidrsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListByoipCidrsInput: Swift.Equatable {
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListByoipCidrsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListByoipCidrsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListByoipCidrsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListByoipCidrsOutputBody = try responseDecoder.decode(responseBody: data)
            self.byoipCidrs = output.byoipCidrs
            self.nextToken = output.nextToken
        } else {
            self.byoipCidrs = nil
            self.nextToken = nil
        }
    }
}

public struct ListByoipCidrsOutput: Swift.Equatable {
    /// Information about your address ranges.
    public var byoipCidrs: [GlobalAcceleratorClientTypes.ByoipCidr]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        byoipCidrs: [GlobalAcceleratorClientTypes.ByoipCidr]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.byoipCidrs = byoipCidrs
        self.nextToken = nextToken
    }
}

struct ListByoipCidrsOutputBody: Swift.Equatable {
    let byoipCidrs: [GlobalAcceleratorClientTypes.ByoipCidr]?
    let nextToken: Swift.String?
}

extension ListByoipCidrsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case byoipCidrs = "ByoipCidrs"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let byoipCidrsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.ByoipCidr?].self, forKey: .byoipCidrs)
        var byoipCidrsDecoded0:[GlobalAcceleratorClientTypes.ByoipCidr]? = nil
        if let byoipCidrsContainer = byoipCidrsContainer {
            byoipCidrsDecoded0 = [GlobalAcceleratorClientTypes.ByoipCidr]()
            for structure0 in byoipCidrsContainer {
                if let structure0 = structure0 {
                    byoipCidrsDecoded0?.append(structure0)
                }
            }
        }
        byoipCidrs = byoipCidrsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListByoipCidrsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListCustomRoutingAcceleratorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListCustomRoutingAcceleratorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListCustomRoutingAcceleratorsInput: Swift.Equatable {
    /// The number of custom routing Global Accelerator objects that you want to return with this call. The default value is 10.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCustomRoutingAcceleratorsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListCustomRoutingAcceleratorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCustomRoutingAcceleratorsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCustomRoutingAcceleratorsOutputBody = try responseDecoder.decode(responseBody: data)
            self.accelerators = output.accelerators
            self.nextToken = output.nextToken
        } else {
            self.accelerators = nil
            self.nextToken = nil
        }
    }
}

public struct ListCustomRoutingAcceleratorsOutput: Swift.Equatable {
    /// The list of custom routing accelerators for a customer account.
    public var accelerators: [GlobalAcceleratorClientTypes.CustomRoutingAccelerator]?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        accelerators: [GlobalAcceleratorClientTypes.CustomRoutingAccelerator]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accelerators = accelerators
        self.nextToken = nextToken
    }
}

struct ListCustomRoutingAcceleratorsOutputBody: Swift.Equatable {
    let accelerators: [GlobalAcceleratorClientTypes.CustomRoutingAccelerator]?
    let nextToken: Swift.String?
}

extension ListCustomRoutingAcceleratorsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accelerators = "Accelerators"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.CustomRoutingAccelerator?].self, forKey: .accelerators)
        var acceleratorsDecoded0:[GlobalAcceleratorClientTypes.CustomRoutingAccelerator]? = nil
        if let acceleratorsContainer = acceleratorsContainer {
            acceleratorsDecoded0 = [GlobalAcceleratorClientTypes.CustomRoutingAccelerator]()
            for structure0 in acceleratorsContainer {
                if let structure0 = structure0 {
                    acceleratorsDecoded0?.append(structure0)
                }
            }
        }
        accelerators = acceleratorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListCustomRoutingAcceleratorsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListCustomRoutingEndpointGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listenerArn = self.listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListCustomRoutingEndpointGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListCustomRoutingEndpointGroupsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the listener to list endpoint groups for.
    /// This member is required.
    public var listenerArn: Swift.String?
    /// The number of endpoint group objects that you want to return with this call. The default value is 10.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        listenerArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.listenerArn = listenerArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCustomRoutingEndpointGroupsInputBody: Swift.Equatable {
    let listenerArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListCustomRoutingEndpointGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCustomRoutingEndpointGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCustomRoutingEndpointGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.endpointGroups = output.endpointGroups
            self.nextToken = output.nextToken
        } else {
            self.endpointGroups = nil
            self.nextToken = nil
        }
    }
}

public struct ListCustomRoutingEndpointGroupsOutput: Swift.Equatable {
    /// The list of the endpoint groups associated with a listener for a custom routing accelerator.
    public var endpointGroups: [GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup]?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        endpointGroups: [GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.endpointGroups = endpointGroups
        self.nextToken = nextToken
    }
}

struct ListCustomRoutingEndpointGroupsOutputBody: Swift.Equatable {
    let endpointGroups: [GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup]?
    let nextToken: Swift.String?
}

extension ListCustomRoutingEndpointGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroups = "EndpointGroups"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup?].self, forKey: .endpointGroups)
        var endpointGroupsDecoded0:[GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup]? = nil
        if let endpointGroupsContainer = endpointGroupsContainer {
            endpointGroupsDecoded0 = [GlobalAcceleratorClientTypes.CustomRoutingEndpointGroup]()
            for structure0 in endpointGroupsContainer {
                if let structure0 = structure0 {
                    endpointGroupsDecoded0?.append(structure0)
                }
            }
        }
        endpointGroups = endpointGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListCustomRoutingEndpointGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ListenerNotFoundException": return try await ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListCustomRoutingListenersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = self.acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListCustomRoutingListenersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListCustomRoutingListenersInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the accelerator to list listeners for.
    /// This member is required.
    public var acceleratorArn: Swift.String?
    /// The number of listener objects that you want to return with this call. The default value is 10.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        acceleratorArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCustomRoutingListenersInputBody: Swift.Equatable {
    let acceleratorArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListCustomRoutingListenersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCustomRoutingListenersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCustomRoutingListenersOutputBody = try responseDecoder.decode(responseBody: data)
            self.listeners = output.listeners
            self.nextToken = output.nextToken
        } else {
            self.listeners = nil
            self.nextToken = nil
        }
    }
}

public struct ListCustomRoutingListenersOutput: Swift.Equatable {
    /// The list of listeners for a custom routing accelerator.
    public var listeners: [GlobalAcceleratorClientTypes.CustomRoutingListener]?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        listeners: [GlobalAcceleratorClientTypes.CustomRoutingListener]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.listeners = listeners
        self.nextToken = nextToken
    }
}

struct ListCustomRoutingListenersOutputBody: Swift.Equatable {
    let listeners: [GlobalAcceleratorClientTypes.CustomRoutingListener]?
    let nextToken: Swift.String?
}

extension ListCustomRoutingListenersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listeners = "Listeners"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenersContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.CustomRoutingListener?].self, forKey: .listeners)
        var listenersDecoded0:[GlobalAcceleratorClientTypes.CustomRoutingListener]? = nil
        if let listenersContainer = listenersContainer {
            listenersDecoded0 = [GlobalAcceleratorClientTypes.CustomRoutingListener]()
            for structure0 in listenersContainer {
                if let structure0 = structure0 {
                    listenersDecoded0?.append(structure0)
                }
            }
        }
        listeners = listenersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListCustomRoutingListenersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AcceleratorNotFoundException": return try await AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListCustomRoutingPortMappingsByDestinationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationAddress = "DestinationAddress"
        case endpointId = "EndpointId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationAddress = self.destinationAddress {
            try encodeContainer.encode(destinationAddress, forKey: .destinationAddress)
        }
        if let endpointId = self.endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListCustomRoutingPortMappingsByDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListCustomRoutingPortMappingsByDestinationInput: Swift.Equatable {
    /// The endpoint IP address in a virtual private cloud (VPC) subnet for which you want to receive back port mappings.
    /// This member is required.
    public var destinationAddress: Swift.String?
    /// The ID for the virtual private cloud (VPC) subnet.
    /// This member is required.
    public var endpointId: Swift.String?
    /// The number of destination port mappings that you want to return with this call. The default value is 10.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        destinationAddress: Swift.String? = nil,
        endpointId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.destinationAddress = destinationAddress
        self.endpointId = endpointId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCustomRoutingPortMappingsByDestinationInputBody: Swift.Equatable {
    let endpointId: Swift.String?
    let destinationAddress: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListCustomRoutingPortMappingsByDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationAddress = "DestinationAddress"
        case endpointId = "EndpointId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
        let destinationAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationAddress)
        destinationAddress = destinationAddressDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCustomRoutingPortMappingsByDestinationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCustomRoutingPortMappingsByDestinationOutputBody = try responseDecoder.decode(responseBody: data)
            self.destinationPortMappings = output.destinationPortMappings
            self.nextToken = output.nextToken
        } else {
            self.destinationPortMappings = nil
            self.nextToken = nil
        }
    }
}

public struct ListCustomRoutingPortMappingsByDestinationOutput: Swift.Equatable {
    /// The port mappings for the endpoint IP address that you specified in the request.
    public var destinationPortMappings: [GlobalAcceleratorClientTypes.DestinationPortMapping]?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        destinationPortMappings: [GlobalAcceleratorClientTypes.DestinationPortMapping]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.destinationPortMappings = destinationPortMappings
        self.nextToken = nextToken
    }
}

struct ListCustomRoutingPortMappingsByDestinationOutputBody: Swift.Equatable {
    let destinationPortMappings: [GlobalAcceleratorClientTypes.DestinationPortMapping]?
    let nextToken: Swift.String?
}

extension ListCustomRoutingPortMappingsByDestinationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationPortMappings = "DestinationPortMappings"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationPortMappingsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.DestinationPortMapping?].self, forKey: .destinationPortMappings)
        var destinationPortMappingsDecoded0:[GlobalAcceleratorClientTypes.DestinationPortMapping]? = nil
        if let destinationPortMappingsContainer = destinationPortMappingsContainer {
            destinationPortMappingsDecoded0 = [GlobalAcceleratorClientTypes.DestinationPortMapping]()
            for structure0 in destinationPortMappingsContainer {
                if let structure0 = structure0 {
                    destinationPortMappingsDecoded0?.append(structure0)
                }
            }
        }
        destinationPortMappings = destinationPortMappingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListCustomRoutingPortMappingsByDestinationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EndpointNotFoundException": return try await EndpointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListCustomRoutingPortMappingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case endpointGroupArn = "EndpointGroupArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = self.acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let endpointGroupArn = self.endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListCustomRoutingPortMappingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListCustomRoutingPortMappingsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the accelerator to list the custom routing port mappings for.
    /// This member is required.
    public var acceleratorArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the endpoint group to list the custom routing port mappings for.
    public var endpointGroupArn: Swift.String?
    /// The number of destination port mappings that you want to return with this call. The default value is 10.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        acceleratorArn: Swift.String? = nil,
        endpointGroupArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.endpointGroupArn = endpointGroupArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCustomRoutingPortMappingsInputBody: Swift.Equatable {
    let acceleratorArn: Swift.String?
    let endpointGroupArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListCustomRoutingPortMappingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case endpointGroupArn = "EndpointGroupArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCustomRoutingPortMappingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCustomRoutingPortMappingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.portMappings = output.portMappings
        } else {
            self.nextToken = nil
            self.portMappings = nil
        }
    }
}

public struct ListCustomRoutingPortMappingsOutput: Swift.Equatable {
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?
    /// The port mappings for a custom routing accelerator.
    public var portMappings: [GlobalAcceleratorClientTypes.PortMapping]?

    public init(
        nextToken: Swift.String? = nil,
        portMappings: [GlobalAcceleratorClientTypes.PortMapping]? = nil
    )
    {
        self.nextToken = nextToken
        self.portMappings = portMappings
    }
}

struct ListCustomRoutingPortMappingsOutputBody: Swift.Equatable {
    let portMappings: [GlobalAcceleratorClientTypes.PortMapping]?
    let nextToken: Swift.String?
}

extension ListCustomRoutingPortMappingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case portMappings = "PortMappings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portMappingsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.PortMapping?].self, forKey: .portMappings)
        var portMappingsDecoded0:[GlobalAcceleratorClientTypes.PortMapping]? = nil
        if let portMappingsContainer = portMappingsContainer {
            portMappingsDecoded0 = [GlobalAcceleratorClientTypes.PortMapping]()
            for structure0 in portMappingsContainer {
                if let structure0 = structure0 {
                    portMappingsDecoded0?.append(structure0)
                }
            }
        }
        portMappings = portMappingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListCustomRoutingPortMappingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AcceleratorNotFoundException": return try await AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EndpointGroupNotFoundException": return try await EndpointGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListEndpointGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listenerArn = self.listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListEndpointGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListEndpointGroupsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerArn: Swift.String?
    /// The number of endpoint group objects that you want to return with this call. The default value is 10.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        listenerArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.listenerArn = listenerArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEndpointGroupsInputBody: Swift.Equatable {
    let listenerArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListEndpointGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListEndpointGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEndpointGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.endpointGroups = output.endpointGroups
            self.nextToken = output.nextToken
        } else {
            self.endpointGroups = nil
            self.nextToken = nil
        }
    }
}

public struct ListEndpointGroupsOutput: Swift.Equatable {
    /// The list of the endpoint groups associated with a listener.
    public var endpointGroups: [GlobalAcceleratorClientTypes.EndpointGroup]?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        endpointGroups: [GlobalAcceleratorClientTypes.EndpointGroup]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.endpointGroups = endpointGroups
        self.nextToken = nextToken
    }
}

struct ListEndpointGroupsOutputBody: Swift.Equatable {
    let endpointGroups: [GlobalAcceleratorClientTypes.EndpointGroup]?
    let nextToken: Swift.String?
}

extension ListEndpointGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroups = "EndpointGroups"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.EndpointGroup?].self, forKey: .endpointGroups)
        var endpointGroupsDecoded0:[GlobalAcceleratorClientTypes.EndpointGroup]? = nil
        if let endpointGroupsContainer = endpointGroupsContainer {
            endpointGroupsDecoded0 = [GlobalAcceleratorClientTypes.EndpointGroup]()
            for structure0 in endpointGroupsContainer {
                if let structure0 = structure0 {
                    endpointGroupsDecoded0?.append(structure0)
                }
            }
        }
        endpointGroups = endpointGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEndpointGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ListenerNotFoundException": return try await ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListListenersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = self.acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListListenersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListListenersInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the accelerator for which you want to list listener objects.
    /// This member is required.
    public var acceleratorArn: Swift.String?
    /// The number of listener objects that you want to return with this call. The default value is 10.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        acceleratorArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListListenersInputBody: Swift.Equatable {
    let acceleratorArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListListenersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListListenersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListListenersOutputBody = try responseDecoder.decode(responseBody: data)
            self.listeners = output.listeners
            self.nextToken = output.nextToken
        } else {
            self.listeners = nil
            self.nextToken = nil
        }
    }
}

public struct ListListenersOutput: Swift.Equatable {
    /// The list of listeners for an accelerator.
    public var listeners: [GlobalAcceleratorClientTypes.Listener]?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        listeners: [GlobalAcceleratorClientTypes.Listener]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.listeners = listeners
        self.nextToken = nextToken
    }
}

struct ListListenersOutputBody: Swift.Equatable {
    let listeners: [GlobalAcceleratorClientTypes.Listener]?
    let nextToken: Swift.String?
}

extension ListListenersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listeners = "Listeners"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenersContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.Listener?].self, forKey: .listeners)
        var listenersDecoded0:[GlobalAcceleratorClientTypes.Listener]? = nil
        if let listenersContainer = listenersContainer {
            listenersDecoded0 = [GlobalAcceleratorClientTypes.Listener]()
            for structure0 in listenersContainer {
                if let structure0 = structure0 {
                    listenersDecoded0?.append(structure0)
                }
            }
        }
        listeners = listenersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListListenersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AcceleratorNotFoundException": return try await AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the accelerator to list tags for. An ARN uniquely identifies an accelerator.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// Root level tag for the Tags parameters.
    public var tags: [GlobalAcceleratorClientTypes.Tag]?

    public init(
        tags: [GlobalAcceleratorClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [GlobalAcceleratorClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[GlobalAcceleratorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [GlobalAcceleratorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AcceleratorNotFoundException": return try await AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GlobalAcceleratorClientTypes.Listener: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientAffinity = "ClientAffinity"
        case listenerArn = "ListenerArn"
        case portRanges = "PortRanges"
        case `protocol` = "Protocol"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientAffinity = self.clientAffinity {
            try encodeContainer.encode(clientAffinity.rawValue, forKey: .clientAffinity)
        }
        if let listenerArn = self.listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
        if let portRanges = portRanges {
            var portRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portRanges)
            for portrange0 in portRanges {
                try portRangesContainer.encode(portrange0)
            }
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
        let portRangesContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.PortRange?].self, forKey: .portRanges)
        var portRangesDecoded0:[GlobalAcceleratorClientTypes.PortRange]? = nil
        if let portRangesContainer = portRangesContainer {
            portRangesDecoded0 = [GlobalAcceleratorClientTypes.PortRange]()
            for structure0 in portRangesContainer {
                if let structure0 = structure0 {
                    portRangesDecoded0?.append(structure0)
                }
            }
        }
        portRanges = portRangesDecoded0
        let protocolDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.ModelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let clientAffinityDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.ClientAffinity.self, forKey: .clientAffinity)
        clientAffinity = clientAffinityDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    /// A complex type for a listener.
    public struct Listener: Swift.Equatable {
        /// Client affinity lets you direct all requests from a user to the same endpoint, if you have stateful applications, regardless of the port and protocol of the client request. Client affinity gives you control over whether to always route each client to the same specific endpoint. Global Accelerator uses a consistent-flow hashing algorithm to choose the optimal endpoint for a connection. If client affinity is NONE, Global Accelerator uses the "five-tuple" (5-tuple) propertiessource IP address, source port, destination IP address, destination port, and protocolto select the hash value, and then chooses the best endpoint. However, with this setting, if someone uses different ports to connect to Global Accelerator, their connections might not be always routed to the same endpoint because the hash value changes. If you want a given client to always be routed to the same endpoint, set client affinity to SOURCE_IP instead. When you use the SOURCE_IP setting, Global Accelerator uses the "two-tuple" (2-tuple) properties source (client) IP address and destination IP addressto select the hash value. The default value is NONE.
        public var clientAffinity: GlobalAcceleratorClientTypes.ClientAffinity?
        /// The Amazon Resource Name (ARN) of the listener.
        public var listenerArn: Swift.String?
        /// The list of port ranges for the connections from clients to the accelerator.
        public var portRanges: [GlobalAcceleratorClientTypes.PortRange]?
        /// The protocol for the connections from clients to the accelerator.
        public var `protocol`: GlobalAcceleratorClientTypes.ModelProtocol?

        public init(
            clientAffinity: GlobalAcceleratorClientTypes.ClientAffinity? = nil,
            listenerArn: Swift.String? = nil,
            portRanges: [GlobalAcceleratorClientTypes.PortRange]? = nil,
            `protocol`: GlobalAcceleratorClientTypes.ModelProtocol? = nil
        )
        {
            self.clientAffinity = clientAffinity
            self.listenerArn = listenerArn
            self.portRanges = portRanges
            self.`protocol` = `protocol`
        }
    }

}

extension ListenerNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListenerNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The listener that you specified doesn't exist.
public struct ListenerNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ListenerNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ListenerNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ListenerNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GlobalAcceleratorClientTypes.PortMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorPort = "AcceleratorPort"
        case destinationSocketAddress = "DestinationSocketAddress"
        case destinationTrafficState = "DestinationTrafficState"
        case endpointGroupArn = "EndpointGroupArn"
        case endpointId = "EndpointId"
        case protocols = "Protocols"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorPort = self.acceleratorPort {
            try encodeContainer.encode(acceleratorPort, forKey: .acceleratorPort)
        }
        if let destinationSocketAddress = self.destinationSocketAddress {
            try encodeContainer.encode(destinationSocketAddress, forKey: .destinationSocketAddress)
        }
        if let destinationTrafficState = self.destinationTrafficState {
            try encodeContainer.encode(destinationTrafficState.rawValue, forKey: .destinationTrafficState)
        }
        if let endpointGroupArn = self.endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
        if let endpointId = self.endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
        if let protocols = protocols {
            var protocolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocols)
            for customroutingprotocol0 in protocols {
                try protocolsContainer.encode(customroutingprotocol0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .acceleratorPort)
        acceleratorPort = acceleratorPortDecoded
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
        let destinationSocketAddressDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.SocketAddress.self, forKey: .destinationSocketAddress)
        destinationSocketAddress = destinationSocketAddressDecoded
        let protocolsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.CustomRoutingProtocol?].self, forKey: .protocols)
        var protocolsDecoded0:[GlobalAcceleratorClientTypes.CustomRoutingProtocol]? = nil
        if let protocolsContainer = protocolsContainer {
            protocolsDecoded0 = [GlobalAcceleratorClientTypes.CustomRoutingProtocol]()
            for enum0 in protocolsContainer {
                if let enum0 = enum0 {
                    protocolsDecoded0?.append(enum0)
                }
            }
        }
        protocols = protocolsDecoded0
        let destinationTrafficStateDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CustomRoutingDestinationTrafficState.self, forKey: .destinationTrafficState)
        destinationTrafficState = destinationTrafficStateDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    /// Returns the ports and associated IP addresses and ports of Amazon EC2 instances in your virtual private cloud (VPC) subnets. Custom routing is a port mapping protocol in Global Accelerator that statically associates port ranges with VPC subnets, which allows Global Accelerator to route to specific instances and ports within one or more subnets.
    public struct PortMapping: Swift.Equatable {
        /// The accelerator port.
        public var acceleratorPort: Swift.Int?
        /// The EC2 instance IP address and port number in the virtual private cloud (VPC) subnet.
        public var destinationSocketAddress: GlobalAcceleratorClientTypes.SocketAddress?
        /// Indicates whether or not a port mapping destination can receive traffic. The value is either ALLOW, if traffic is allowed to the destination, or DENY, if traffic is not allowed to the destination.
        public var destinationTrafficState: GlobalAcceleratorClientTypes.CustomRoutingDestinationTrafficState?
        /// The Amazon Resource Name (ARN) of the endpoint group.
        public var endpointGroupArn: Swift.String?
        /// The IP address of the VPC subnet (the subnet ID).
        public var endpointId: Swift.String?
        /// The protocols supported by the endpoint group.
        public var protocols: [GlobalAcceleratorClientTypes.CustomRoutingProtocol]?

        public init(
            acceleratorPort: Swift.Int? = nil,
            destinationSocketAddress: GlobalAcceleratorClientTypes.SocketAddress? = nil,
            destinationTrafficState: GlobalAcceleratorClientTypes.CustomRoutingDestinationTrafficState? = nil,
            endpointGroupArn: Swift.String? = nil,
            endpointId: Swift.String? = nil,
            protocols: [GlobalAcceleratorClientTypes.CustomRoutingProtocol]? = nil
        )
        {
            self.acceleratorPort = acceleratorPort
            self.destinationSocketAddress = destinationSocketAddress
            self.destinationTrafficState = destinationTrafficState
            self.endpointGroupArn = endpointGroupArn
            self.endpointId = endpointId
            self.protocols = protocols
        }
    }

}

extension GlobalAcceleratorClientTypes.PortOverride: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointPort = "EndpointPort"
        case listenerPort = "ListenerPort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointPort = self.endpointPort {
            try encodeContainer.encode(endpointPort, forKey: .endpointPort)
        }
        if let listenerPort = self.listenerPort {
            try encodeContainer.encode(listenerPort, forKey: .listenerPort)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .listenerPort)
        listenerPort = listenerPortDecoded
        let endpointPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endpointPort)
        endpointPort = endpointPortDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    /// Override specific listener ports used to route traffic to endpoints that are part of an endpoint group. For example, you can create a port override in which the listener receives user traffic on ports 80 and 443, but your accelerator routes that traffic to ports 1080 and 1443, respectively, on the endpoints. For more information, see [ Overriding listener ports](https://docs.aws.amazon.com/global-accelerator/latest/dg/about-endpoint-groups-port-override.html) in the Global Accelerator Developer Guide.
    public struct PortOverride: Swift.Equatable {
        /// The endpoint port that you want a listener port to be mapped to. This is the port on the endpoint, such as the Application Load Balancer or Amazon EC2 instance.
        public var endpointPort: Swift.Int?
        /// The listener port that you want to map to a specific endpoint port. This is the port that user traffic arrives to the Global Accelerator on.
        public var listenerPort: Swift.Int?

        public init(
            endpointPort: Swift.Int? = nil,
            listenerPort: Swift.Int? = nil
        )
        {
            self.endpointPort = endpointPort
            self.listenerPort = listenerPort
        }
    }

}

extension GlobalAcceleratorClientTypes.PortRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromPort = "FromPort"
        case toPort = "ToPort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromPort = self.fromPort {
            try encodeContainer.encode(fromPort, forKey: .fromPort)
        }
        if let toPort = self.toPort {
            try encodeContainer.encode(toPort, forKey: .toPort)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fromPort)
        fromPort = fromPortDecoded
        let toPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .toPort)
        toPort = toPortDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    /// A complex type for a range of ports for a listener.
    public struct PortRange: Swift.Equatable {
        /// The first port in the range of ports, inclusive.
        public var fromPort: Swift.Int?
        /// The last port in the range of ports, inclusive.
        public var toPort: Swift.Int?

        public init(
            fromPort: Swift.Int? = nil,
            toPort: Swift.Int? = nil
        )
        {
            self.fromPort = fromPort
            self.toPort = toPort
        }
    }

}

extension GlobalAcceleratorClientTypes {
    public enum ModelProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case tcp
        case udp
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelProtocol] {
            return [
                .tcp,
                .udp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .tcp: return "TCP"
            case .udp: return "UDP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelProtocol(rawValue: rawValue) ?? ModelProtocol.sdkUnknown(rawValue)
        }
    }
}

extension ProvisionByoipCidrInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidr = "Cidr"
        case cidrAuthorizationContext = "CidrAuthorizationContext"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidr = self.cidr {
            try encodeContainer.encode(cidr, forKey: .cidr)
        }
        if let cidrAuthorizationContext = self.cidrAuthorizationContext {
            try encodeContainer.encode(cidrAuthorizationContext, forKey: .cidrAuthorizationContext)
        }
    }
}

extension ProvisionByoipCidrInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ProvisionByoipCidrInput: Swift.Equatable {
    /// The public IPv4 address range, in CIDR notation. The most specific IP prefix that you can specify is /24. The address range cannot overlap with another address range that you've brought to this or another Region.
    /// This member is required.
    public var cidr: Swift.String?
    /// A signed document that proves that you are authorized to bring the specified IP address range to Amazon using BYOIP.
    /// This member is required.
    public var cidrAuthorizationContext: GlobalAcceleratorClientTypes.CidrAuthorizationContext?

    public init(
        cidr: Swift.String? = nil,
        cidrAuthorizationContext: GlobalAcceleratorClientTypes.CidrAuthorizationContext? = nil
    )
    {
        self.cidr = cidr
        self.cidrAuthorizationContext = cidrAuthorizationContext
    }
}

struct ProvisionByoipCidrInputBody: Swift.Equatable {
    let cidr: Swift.String?
    let cidrAuthorizationContext: GlobalAcceleratorClientTypes.CidrAuthorizationContext?
}

extension ProvisionByoipCidrInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidr = "Cidr"
        case cidrAuthorizationContext = "CidrAuthorizationContext"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cidr)
        cidr = cidrDecoded
        let cidrAuthorizationContextDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CidrAuthorizationContext.self, forKey: .cidrAuthorizationContext)
        cidrAuthorizationContext = cidrAuthorizationContextDecoded
    }
}

extension ProvisionByoipCidrOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ProvisionByoipCidrOutputBody = try responseDecoder.decode(responseBody: data)
            self.byoipCidr = output.byoipCidr
        } else {
            self.byoipCidr = nil
        }
    }
}

public struct ProvisionByoipCidrOutput: Swift.Equatable {
    /// Information about the address range.
    public var byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr?

    public init(
        byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr? = nil
    )
    {
        self.byoipCidr = byoipCidr
    }
}

struct ProvisionByoipCidrOutputBody: Swift.Equatable {
    let byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr?
}

extension ProvisionByoipCidrOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case byoipCidr = "ByoipCidr"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let byoipCidrDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.ByoipCidr.self, forKey: .byoipCidr)
        byoipCidr = byoipCidrDecoded
    }
}

enum ProvisionByoipCidrOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IncorrectCidrStateException": return try await IncorrectCidrStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RemoveCustomRoutingEndpointsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
        case endpointIds = "EndpointIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointGroupArn = self.endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
        if let endpointIds = endpointIds {
            var endpointIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpointIds)
            for genericstring0 in endpointIds {
                try endpointIdsContainer.encode(genericstring0)
            }
        }
    }
}

extension RemoveCustomRoutingEndpointsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RemoveCustomRoutingEndpointsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the endpoint group to remove endpoints from.
    /// This member is required.
    public var endpointGroupArn: Swift.String?
    /// The IDs for the endpoints. For custom routing accelerators, endpoint IDs are the virtual private cloud (VPC) subnet IDs.
    /// This member is required.
    public var endpointIds: [Swift.String]?

    public init(
        endpointGroupArn: Swift.String? = nil,
        endpointIds: [Swift.String]? = nil
    )
    {
        self.endpointGroupArn = endpointGroupArn
        self.endpointIds = endpointIds
    }
}

struct RemoveCustomRoutingEndpointsInputBody: Swift.Equatable {
    let endpointIds: [Swift.String]?
    let endpointGroupArn: Swift.String?
}

extension RemoveCustomRoutingEndpointsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
        case endpointIds = "EndpointIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .endpointIds)
        var endpointIdsDecoded0:[Swift.String]? = nil
        if let endpointIdsContainer = endpointIdsContainer {
            endpointIdsDecoded0 = [Swift.String]()
            for string0 in endpointIdsContainer {
                if let string0 = string0 {
                    endpointIdsDecoded0?.append(string0)
                }
            }
        }
        endpointIds = endpointIdsDecoded0
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
    }
}

extension RemoveCustomRoutingEndpointsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RemoveCustomRoutingEndpointsOutput: Swift.Equatable {

    public init() { }
}

enum RemoveCustomRoutingEndpointsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EndpointGroupNotFoundException": return try await EndpointGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EndpointNotFoundException": return try await EndpointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RemoveEndpointsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
        case endpointIdentifiers = "EndpointIdentifiers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointGroupArn = self.endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
        if let endpointIdentifiers = endpointIdentifiers {
            var endpointIdentifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpointIdentifiers)
            for endpointidentifier0 in endpointIdentifiers {
                try endpointIdentifiersContainer.encode(endpointidentifier0)
            }
        }
    }
}

extension RemoveEndpointsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RemoveEndpointsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the endpoint group.
    /// This member is required.
    public var endpointGroupArn: Swift.String?
    /// The identifiers of the endpoints that you want to remove.
    /// This member is required.
    public var endpointIdentifiers: [GlobalAcceleratorClientTypes.EndpointIdentifier]?

    public init(
        endpointGroupArn: Swift.String? = nil,
        endpointIdentifiers: [GlobalAcceleratorClientTypes.EndpointIdentifier]? = nil
    )
    {
        self.endpointGroupArn = endpointGroupArn
        self.endpointIdentifiers = endpointIdentifiers
    }
}

struct RemoveEndpointsInputBody: Swift.Equatable {
    let endpointIdentifiers: [GlobalAcceleratorClientTypes.EndpointIdentifier]?
    let endpointGroupArn: Swift.String?
}

extension RemoveEndpointsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
        case endpointIdentifiers = "EndpointIdentifiers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointIdentifiersContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.EndpointIdentifier?].self, forKey: .endpointIdentifiers)
        var endpointIdentifiersDecoded0:[GlobalAcceleratorClientTypes.EndpointIdentifier]? = nil
        if let endpointIdentifiersContainer = endpointIdentifiersContainer {
            endpointIdentifiersDecoded0 = [GlobalAcceleratorClientTypes.EndpointIdentifier]()
            for structure0 in endpointIdentifiersContainer {
                if let structure0 = structure0 {
                    endpointIdentifiersDecoded0?.append(structure0)
                }
            }
        }
        endpointIdentifiers = endpointIdentifiersDecoded0
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
    }
}

extension RemoveEndpointsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RemoveEndpointsOutput: Swift.Equatable {

    public init() { }
}

enum RemoveEndpointsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EndpointGroupNotFoundException": return try await EndpointGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TransactionInProgressException": return try await TransactionInProgressException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GlobalAcceleratorClientTypes.SocketAddress: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAddress = "IpAddress"
        case port = "Port"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipAddress = self.ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    /// An IP address/port combination.
    public struct SocketAddress: Swift.Equatable {
        /// The IP address for the socket address.
        public var ipAddress: Swift.String?
        /// The port for the socket address.
        public var port: Swift.Int?

        public init(
            ipAddress: Swift.String? = nil,
            port: Swift.Int? = nil
        )
        {
            self.ipAddress = ipAddress
            self.port = port
        }
    }

}

extension GlobalAcceleratorClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension GlobalAcceleratorClientTypes {
    /// A complex type that contains a Tag key and Tag value.
    public struct Tag: Swift.Equatable {
        /// A string that contains a Tag key.
        /// This member is required.
        public var key: Swift.String?
        /// A string that contains a Tag value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Global Accelerator resource to add tags to. An ARN uniquely identifies a resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to a resource. A tag consists of a key and a value that you define.
    /// This member is required.
    public var tags: [GlobalAcceleratorClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [GlobalAcceleratorClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [GlobalAcceleratorClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[GlobalAcceleratorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [GlobalAcceleratorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AcceleratorNotFoundException": return try await AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TransactionInProgressException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TransactionInProgressExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There's already a transaction in progress. Another transaction can't be processed.
public struct TransactionInProgressException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TransactionInProgressException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TransactionInProgressExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TransactionInProgressExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Global Accelerator resource to remove tags from. An ARN uniquely identifies a resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag key pairs that you want to remove from the specified resources.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AcceleratorNotFoundException": return try await AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAcceleratorAttributesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case flowLogsEnabled = "FlowLogsEnabled"
        case flowLogsS3Bucket = "FlowLogsS3Bucket"
        case flowLogsS3Prefix = "FlowLogsS3Prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = self.acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let flowLogsEnabled = self.flowLogsEnabled {
            try encodeContainer.encode(flowLogsEnabled, forKey: .flowLogsEnabled)
        }
        if let flowLogsS3Bucket = self.flowLogsS3Bucket {
            try encodeContainer.encode(flowLogsS3Bucket, forKey: .flowLogsS3Bucket)
        }
        if let flowLogsS3Prefix = self.flowLogsS3Prefix {
            try encodeContainer.encode(flowLogsS3Prefix, forKey: .flowLogsS3Prefix)
        }
    }
}

extension UpdateAcceleratorAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateAcceleratorAttributesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the accelerator that you want to update.
    /// This member is required.
    public var acceleratorArn: Swift.String?
    /// Update whether flow logs are enabled. The default value is false. If the value is true, FlowLogsS3Bucket and FlowLogsS3Prefix must be specified. For more information, see [Flow Logs](https://docs.aws.amazon.com/global-accelerator/latest/dg/monitoring-global-accelerator.flow-logs.html) in the Global Accelerator Developer Guide.
    public var flowLogsEnabled: Swift.Bool?
    /// The name of the Amazon S3 bucket for the flow logs. Attribute is required if FlowLogsEnabled is true. The bucket must exist and have a bucket policy that grants Global Accelerator permission to write to the bucket.
    public var flowLogsS3Bucket: Swift.String?
    /// Update the prefix for the location in the Amazon S3 bucket for the flow logs. Attribute is required if FlowLogsEnabled is true. If you specify slash (/) for the S3 bucket prefix, the log file bucket folder structure will include a double slash (//), like the following: s3-bucket_name//AWSLogs/aws_account_id
    public var flowLogsS3Prefix: Swift.String?

    public init(
        acceleratorArn: Swift.String? = nil,
        flowLogsEnabled: Swift.Bool? = nil,
        flowLogsS3Bucket: Swift.String? = nil,
        flowLogsS3Prefix: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.flowLogsEnabled = flowLogsEnabled
        self.flowLogsS3Bucket = flowLogsS3Bucket
        self.flowLogsS3Prefix = flowLogsS3Prefix
    }
}

struct UpdateAcceleratorAttributesInputBody: Swift.Equatable {
    let acceleratorArn: Swift.String?
    let flowLogsEnabled: Swift.Bool?
    let flowLogsS3Bucket: Swift.String?
    let flowLogsS3Prefix: Swift.String?
}

extension UpdateAcceleratorAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case flowLogsEnabled = "FlowLogsEnabled"
        case flowLogsS3Bucket = "FlowLogsS3Bucket"
        case flowLogsS3Prefix = "FlowLogsS3Prefix"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let flowLogsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .flowLogsEnabled)
        flowLogsEnabled = flowLogsEnabledDecoded
        let flowLogsS3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowLogsS3Bucket)
        flowLogsS3Bucket = flowLogsS3BucketDecoded
        let flowLogsS3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowLogsS3Prefix)
        flowLogsS3Prefix = flowLogsS3PrefixDecoded
    }
}

extension UpdateAcceleratorAttributesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAcceleratorAttributesOutputBody = try responseDecoder.decode(responseBody: data)
            self.acceleratorAttributes = output.acceleratorAttributes
        } else {
            self.acceleratorAttributes = nil
        }
    }
}

public struct UpdateAcceleratorAttributesOutput: Swift.Equatable {
    /// Updated attributes for the accelerator.
    public var acceleratorAttributes: GlobalAcceleratorClientTypes.AcceleratorAttributes?

    public init(
        acceleratorAttributes: GlobalAcceleratorClientTypes.AcceleratorAttributes? = nil
    )
    {
        self.acceleratorAttributes = acceleratorAttributes
    }
}

struct UpdateAcceleratorAttributesOutputBody: Swift.Equatable {
    let acceleratorAttributes: GlobalAcceleratorClientTypes.AcceleratorAttributes?
}

extension UpdateAcceleratorAttributesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorAttributes = "AcceleratorAttributes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorAttributesDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.AcceleratorAttributes.self, forKey: .acceleratorAttributes)
        acceleratorAttributes = acceleratorAttributesDecoded
    }
}

enum UpdateAcceleratorAttributesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AcceleratorNotFoundException": return try await AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAcceleratorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case enabled = "Enabled"
        case ipAddressType = "IpAddressType"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = self.acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let ipAddressType = self.ipAddressType {
            try encodeContainer.encode(ipAddressType.rawValue, forKey: .ipAddressType)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateAcceleratorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateAcceleratorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the accelerator to update.
    /// This member is required.
    public var acceleratorArn: Swift.String?
    /// Indicates whether an accelerator is enabled. The value is true or false. The default value is true. If the value is set to true, the accelerator cannot be deleted. If set to false, the accelerator can be deleted.
    public var enabled: Swift.Bool?
    /// The IP address type that an accelerator supports. For a standard accelerator, the value can be IPV4 or DUAL_STACK.
    public var ipAddressType: GlobalAcceleratorClientTypes.IpAddressType?
    /// The name of the accelerator. The name can have a maximum of 64 characters, must contain only alphanumeric characters, periods (.), or hyphens (-), and must not begin or end with a hyphen or period.
    public var name: Swift.String?

    public init(
        acceleratorArn: Swift.String? = nil,
        enabled: Swift.Bool? = nil,
        ipAddressType: GlobalAcceleratorClientTypes.IpAddressType? = nil,
        name: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.enabled = enabled
        self.ipAddressType = ipAddressType
        self.name = name
    }
}

struct UpdateAcceleratorInputBody: Swift.Equatable {
    let acceleratorArn: Swift.String?
    let name: Swift.String?
    let ipAddressType: GlobalAcceleratorClientTypes.IpAddressType?
    let enabled: Swift.Bool?
}

extension UpdateAcceleratorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case enabled = "Enabled"
        case ipAddressType = "IpAddressType"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.IpAddressType.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension UpdateAcceleratorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAcceleratorOutputBody = try responseDecoder.decode(responseBody: data)
            self.accelerator = output.accelerator
        } else {
            self.accelerator = nil
        }
    }
}

public struct UpdateAcceleratorOutput: Swift.Equatable {
    /// Information about the updated accelerator.
    public var accelerator: GlobalAcceleratorClientTypes.Accelerator?

    public init(
        accelerator: GlobalAcceleratorClientTypes.Accelerator? = nil
    )
    {
        self.accelerator = accelerator
    }
}

struct UpdateAcceleratorOutputBody: Swift.Equatable {
    let accelerator: GlobalAcceleratorClientTypes.Accelerator?
}

extension UpdateAcceleratorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accelerator = "Accelerator"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.Accelerator.self, forKey: .accelerator)
        accelerator = acceleratorDecoded
    }
}

enum UpdateAcceleratorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AcceleratorNotFoundException": return try await AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateCustomRoutingAcceleratorAttributesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case flowLogsEnabled = "FlowLogsEnabled"
        case flowLogsS3Bucket = "FlowLogsS3Bucket"
        case flowLogsS3Prefix = "FlowLogsS3Prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = self.acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let flowLogsEnabled = self.flowLogsEnabled {
            try encodeContainer.encode(flowLogsEnabled, forKey: .flowLogsEnabled)
        }
        if let flowLogsS3Bucket = self.flowLogsS3Bucket {
            try encodeContainer.encode(flowLogsS3Bucket, forKey: .flowLogsS3Bucket)
        }
        if let flowLogsS3Prefix = self.flowLogsS3Prefix {
            try encodeContainer.encode(flowLogsS3Prefix, forKey: .flowLogsS3Prefix)
        }
    }
}

extension UpdateCustomRoutingAcceleratorAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateCustomRoutingAcceleratorAttributesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the custom routing accelerator to update attributes for.
    /// This member is required.
    public var acceleratorArn: Swift.String?
    /// Update whether flow logs are enabled. The default value is false. If the value is true, FlowLogsS3Bucket and FlowLogsS3Prefix must be specified. For more information, see [Flow logs](https://docs.aws.amazon.com/global-accelerator/latest/dg/monitoring-global-accelerator.flow-logs.html) in the Global Accelerator Developer Guide.
    public var flowLogsEnabled: Swift.Bool?
    /// The name of the Amazon S3 bucket for the flow logs. Attribute is required if FlowLogsEnabled is true. The bucket must exist and have a bucket policy that grants Global Accelerator permission to write to the bucket.
    public var flowLogsS3Bucket: Swift.String?
    /// Update the prefix for the location in the Amazon S3 bucket for the flow logs. Attribute is required if FlowLogsEnabled is true. If you dont specify a prefix, the flow logs are stored in the root of the bucket. If you specify slash (/) for the S3 bucket prefix, the log file bucket folder structure will include a double slash (//), like the following: DOC-EXAMPLE-BUCKET//AWSLogs/aws_account_id
    public var flowLogsS3Prefix: Swift.String?

    public init(
        acceleratorArn: Swift.String? = nil,
        flowLogsEnabled: Swift.Bool? = nil,
        flowLogsS3Bucket: Swift.String? = nil,
        flowLogsS3Prefix: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.flowLogsEnabled = flowLogsEnabled
        self.flowLogsS3Bucket = flowLogsS3Bucket
        self.flowLogsS3Prefix = flowLogsS3Prefix
    }
}

struct UpdateCustomRoutingAcceleratorAttributesInputBody: Swift.Equatable {
    let acceleratorArn: Swift.String?
    let flowLogsEnabled: Swift.Bool?
    let flowLogsS3Bucket: Swift.String?
    let flowLogsS3Prefix: Swift.String?
}

extension UpdateCustomRoutingAcceleratorAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case flowLogsEnabled = "FlowLogsEnabled"
        case flowLogsS3Bucket = "FlowLogsS3Bucket"
        case flowLogsS3Prefix = "FlowLogsS3Prefix"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let flowLogsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .flowLogsEnabled)
        flowLogsEnabled = flowLogsEnabledDecoded
        let flowLogsS3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowLogsS3Bucket)
        flowLogsS3Bucket = flowLogsS3BucketDecoded
        let flowLogsS3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowLogsS3Prefix)
        flowLogsS3Prefix = flowLogsS3PrefixDecoded
    }
}

extension UpdateCustomRoutingAcceleratorAttributesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateCustomRoutingAcceleratorAttributesOutputBody = try responseDecoder.decode(responseBody: data)
            self.acceleratorAttributes = output.acceleratorAttributes
        } else {
            self.acceleratorAttributes = nil
        }
    }
}

public struct UpdateCustomRoutingAcceleratorAttributesOutput: Swift.Equatable {
    /// Updated custom routing accelerator.
    public var acceleratorAttributes: GlobalAcceleratorClientTypes.CustomRoutingAcceleratorAttributes?

    public init(
        acceleratorAttributes: GlobalAcceleratorClientTypes.CustomRoutingAcceleratorAttributes? = nil
    )
    {
        self.acceleratorAttributes = acceleratorAttributes
    }
}

struct UpdateCustomRoutingAcceleratorAttributesOutputBody: Swift.Equatable {
    let acceleratorAttributes: GlobalAcceleratorClientTypes.CustomRoutingAcceleratorAttributes?
}

extension UpdateCustomRoutingAcceleratorAttributesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorAttributes = "AcceleratorAttributes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorAttributesDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CustomRoutingAcceleratorAttributes.self, forKey: .acceleratorAttributes)
        acceleratorAttributes = acceleratorAttributesDecoded
    }
}

enum UpdateCustomRoutingAcceleratorAttributesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AcceleratorNotFoundException": return try await AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateCustomRoutingAcceleratorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case enabled = "Enabled"
        case ipAddressType = "IpAddressType"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = self.acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let ipAddressType = self.ipAddressType {
            try encodeContainer.encode(ipAddressType.rawValue, forKey: .ipAddressType)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateCustomRoutingAcceleratorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateCustomRoutingAcceleratorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the accelerator to update.
    /// This member is required.
    public var acceleratorArn: Swift.String?
    /// Indicates whether an accelerator is enabled. The value is true or false. The default value is true. If the value is set to true, the accelerator cannot be deleted. If set to false, the accelerator can be deleted.
    public var enabled: Swift.Bool?
    /// The IP address type that an accelerator supports. For a custom routing accelerator, the value must be IPV4.
    public var ipAddressType: GlobalAcceleratorClientTypes.IpAddressType?
    /// The name of the accelerator. The name can have a maximum of 64 characters, must contain only alphanumeric characters, periods (.), or hyphens (-), and must not begin or end with a hyphen or period.
    public var name: Swift.String?

    public init(
        acceleratorArn: Swift.String? = nil,
        enabled: Swift.Bool? = nil,
        ipAddressType: GlobalAcceleratorClientTypes.IpAddressType? = nil,
        name: Swift.String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.enabled = enabled
        self.ipAddressType = ipAddressType
        self.name = name
    }
}

struct UpdateCustomRoutingAcceleratorInputBody: Swift.Equatable {
    let acceleratorArn: Swift.String?
    let name: Swift.String?
    let ipAddressType: GlobalAcceleratorClientTypes.IpAddressType?
    let enabled: Swift.Bool?
}

extension UpdateCustomRoutingAcceleratorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case enabled = "Enabled"
        case ipAddressType = "IpAddressType"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.IpAddressType.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension UpdateCustomRoutingAcceleratorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateCustomRoutingAcceleratorOutputBody = try responseDecoder.decode(responseBody: data)
            self.accelerator = output.accelerator
        } else {
            self.accelerator = nil
        }
    }
}

public struct UpdateCustomRoutingAcceleratorOutput: Swift.Equatable {
    /// Information about the updated custom routing accelerator.
    public var accelerator: GlobalAcceleratorClientTypes.CustomRoutingAccelerator?

    public init(
        accelerator: GlobalAcceleratorClientTypes.CustomRoutingAccelerator? = nil
    )
    {
        self.accelerator = accelerator
    }
}

struct UpdateCustomRoutingAcceleratorOutputBody: Swift.Equatable {
    let accelerator: GlobalAcceleratorClientTypes.CustomRoutingAccelerator?
}

extension UpdateCustomRoutingAcceleratorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accelerator = "Accelerator"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CustomRoutingAccelerator.self, forKey: .accelerator)
        accelerator = acceleratorDecoded
    }
}

enum UpdateCustomRoutingAcceleratorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AcceleratorNotFoundException": return try await AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateCustomRoutingListenerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
        case portRanges = "PortRanges"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listenerArn = self.listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
        if let portRanges = portRanges {
            var portRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portRanges)
            for portrange0 in portRanges {
                try portRangesContainer.encode(portrange0)
            }
        }
    }
}

extension UpdateCustomRoutingListenerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateCustomRoutingListenerInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the listener to update.
    /// This member is required.
    public var listenerArn: Swift.String?
    /// The updated port range to support for connections from clients to your accelerator. If you remove ports that are currently being used by a subnet endpoint, the call fails. Separately, you set port ranges for endpoints. For more information, see [About endpoints for custom routing accelerators](https://docs.aws.amazon.com/global-accelerator/latest/dg/about-custom-routing-endpoints.html).
    /// This member is required.
    public var portRanges: [GlobalAcceleratorClientTypes.PortRange]?

    public init(
        listenerArn: Swift.String? = nil,
        portRanges: [GlobalAcceleratorClientTypes.PortRange]? = nil
    )
    {
        self.listenerArn = listenerArn
        self.portRanges = portRanges
    }
}

struct UpdateCustomRoutingListenerInputBody: Swift.Equatable {
    let listenerArn: Swift.String?
    let portRanges: [GlobalAcceleratorClientTypes.PortRange]?
}

extension UpdateCustomRoutingListenerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listenerArn = "ListenerArn"
        case portRanges = "PortRanges"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
        let portRangesContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.PortRange?].self, forKey: .portRanges)
        var portRangesDecoded0:[GlobalAcceleratorClientTypes.PortRange]? = nil
        if let portRangesContainer = portRangesContainer {
            portRangesDecoded0 = [GlobalAcceleratorClientTypes.PortRange]()
            for structure0 in portRangesContainer {
                if let structure0 = structure0 {
                    portRangesDecoded0?.append(structure0)
                }
            }
        }
        portRanges = portRangesDecoded0
    }
}

extension UpdateCustomRoutingListenerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateCustomRoutingListenerOutputBody = try responseDecoder.decode(responseBody: data)
            self.listener = output.listener
        } else {
            self.listener = nil
        }
    }
}

public struct UpdateCustomRoutingListenerOutput: Swift.Equatable {
    /// Information for the updated listener for a custom routing accelerator.
    public var listener: GlobalAcceleratorClientTypes.CustomRoutingListener?

    public init(
        listener: GlobalAcceleratorClientTypes.CustomRoutingListener? = nil
    )
    {
        self.listener = listener
    }
}

struct UpdateCustomRoutingListenerOutputBody: Swift.Equatable {
    let listener: GlobalAcceleratorClientTypes.CustomRoutingListener?
}

extension UpdateCustomRoutingListenerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listener = "Listener"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.CustomRoutingListener.self, forKey: .listener)
        listener = listenerDecoded
    }
}

enum UpdateCustomRoutingListenerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPortRangeException": return try await InvalidPortRangeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ListenerNotFoundException": return try await ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateEndpointGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointConfigurations = "EndpointConfigurations"
        case endpointGroupArn = "EndpointGroupArn"
        case healthCheckIntervalSeconds = "HealthCheckIntervalSeconds"
        case healthCheckPath = "HealthCheckPath"
        case healthCheckPort = "HealthCheckPort"
        case healthCheckProtocol = "HealthCheckProtocol"
        case portOverrides = "PortOverrides"
        case thresholdCount = "ThresholdCount"
        case trafficDialPercentage = "TrafficDialPercentage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointConfigurations = endpointConfigurations {
            var endpointConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpointConfigurations)
            for endpointconfiguration0 in endpointConfigurations {
                try endpointConfigurationsContainer.encode(endpointconfiguration0)
            }
        }
        if let endpointGroupArn = self.endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
        if let healthCheckIntervalSeconds = self.healthCheckIntervalSeconds {
            try encodeContainer.encode(healthCheckIntervalSeconds, forKey: .healthCheckIntervalSeconds)
        }
        if let healthCheckPath = self.healthCheckPath {
            try encodeContainer.encode(healthCheckPath, forKey: .healthCheckPath)
        }
        if let healthCheckPort = self.healthCheckPort {
            try encodeContainer.encode(healthCheckPort, forKey: .healthCheckPort)
        }
        if let healthCheckProtocol = self.healthCheckProtocol {
            try encodeContainer.encode(healthCheckProtocol.rawValue, forKey: .healthCheckProtocol)
        }
        if let portOverrides = portOverrides {
            var portOverridesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portOverrides)
            for portoverride0 in portOverrides {
                try portOverridesContainer.encode(portoverride0)
            }
        }
        if let thresholdCount = self.thresholdCount {
            try encodeContainer.encode(thresholdCount, forKey: .thresholdCount)
        }
        if let trafficDialPercentage = self.trafficDialPercentage {
            try encodeContainer.encode(trafficDialPercentage, forKey: .trafficDialPercentage)
        }
    }
}

extension UpdateEndpointGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateEndpointGroupInput: Swift.Equatable {
    /// The list of endpoint objects. A resource must be valid and active when you add it as an endpoint.
    public var endpointConfigurations: [GlobalAcceleratorClientTypes.EndpointConfiguration]?
    /// The Amazon Resource Name (ARN) of the endpoint group.
    /// This member is required.
    public var endpointGroupArn: Swift.String?
    /// The time10 seconds or 30 secondsbetween each health check for an endpoint. The default value is 30.
    public var healthCheckIntervalSeconds: Swift.Int?
    /// If the protocol is HTTP/S, then this specifies the path that is the destination for health check targets. The default value is slash (/).
    public var healthCheckPath: Swift.String?
    /// The port that Global Accelerator uses to check the health of endpoints that are part of this endpoint group. The default port is the listener port that this endpoint group is associated with. If the listener port is a list of ports, Global Accelerator uses the first port in the list.
    public var healthCheckPort: Swift.Int?
    /// The protocol that Global Accelerator uses to check the health of endpoints that are part of this endpoint group. The default value is TCP.
    public var healthCheckProtocol: GlobalAcceleratorClientTypes.HealthCheckProtocol?
    /// Override specific listener ports used to route traffic to endpoints that are part of this endpoint group. For example, you can create a port override in which the listener receives user traffic on ports 80 and 443, but your accelerator routes that traffic to ports 1080 and 1443, respectively, on the endpoints. For more information, see [ Overriding listener ports](https://docs.aws.amazon.com/global-accelerator/latest/dg/about-endpoint-groups-port-override.html) in the Global Accelerator Developer Guide.
    public var portOverrides: [GlobalAcceleratorClientTypes.PortOverride]?
    /// The number of consecutive health checks required to set the state of a healthy endpoint to unhealthy, or to set an unhealthy endpoint to healthy. The default value is 3.
    public var thresholdCount: Swift.Int?
    /// The percentage of traffic to send to an Amazon Web Services Region. Additional traffic is distributed to other endpoint groups for this listener. Use this action to increase (dial up) or decrease (dial down) traffic to a specific Region. The percentage is applied to the traffic that would otherwise have been routed to the Region based on optimal routing. The default value is 100.
    public var trafficDialPercentage: Swift.Float?

    public init(
        endpointConfigurations: [GlobalAcceleratorClientTypes.EndpointConfiguration]? = nil,
        endpointGroupArn: Swift.String? = nil,
        healthCheckIntervalSeconds: Swift.Int? = nil,
        healthCheckPath: Swift.String? = nil,
        healthCheckPort: Swift.Int? = nil,
        healthCheckProtocol: GlobalAcceleratorClientTypes.HealthCheckProtocol? = nil,
        portOverrides: [GlobalAcceleratorClientTypes.PortOverride]? = nil,
        thresholdCount: Swift.Int? = nil,
        trafficDialPercentage: Swift.Float? = nil
    )
    {
        self.endpointConfigurations = endpointConfigurations
        self.endpointGroupArn = endpointGroupArn
        self.healthCheckIntervalSeconds = healthCheckIntervalSeconds
        self.healthCheckPath = healthCheckPath
        self.healthCheckPort = healthCheckPort
        self.healthCheckProtocol = healthCheckProtocol
        self.portOverrides = portOverrides
        self.thresholdCount = thresholdCount
        self.trafficDialPercentage = trafficDialPercentage
    }
}

struct UpdateEndpointGroupInputBody: Swift.Equatable {
    let endpointGroupArn: Swift.String?
    let endpointConfigurations: [GlobalAcceleratorClientTypes.EndpointConfiguration]?
    let trafficDialPercentage: Swift.Float?
    let healthCheckPort: Swift.Int?
    let healthCheckProtocol: GlobalAcceleratorClientTypes.HealthCheckProtocol?
    let healthCheckPath: Swift.String?
    let healthCheckIntervalSeconds: Swift.Int?
    let thresholdCount: Swift.Int?
    let portOverrides: [GlobalAcceleratorClientTypes.PortOverride]?
}

extension UpdateEndpointGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointConfigurations = "EndpointConfigurations"
        case endpointGroupArn = "EndpointGroupArn"
        case healthCheckIntervalSeconds = "HealthCheckIntervalSeconds"
        case healthCheckPath = "HealthCheckPath"
        case healthCheckPort = "HealthCheckPort"
        case healthCheckProtocol = "HealthCheckProtocol"
        case portOverrides = "PortOverrides"
        case thresholdCount = "ThresholdCount"
        case trafficDialPercentage = "TrafficDialPercentage"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
        let endpointConfigurationsContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.EndpointConfiguration?].self, forKey: .endpointConfigurations)
        var endpointConfigurationsDecoded0:[GlobalAcceleratorClientTypes.EndpointConfiguration]? = nil
        if let endpointConfigurationsContainer = endpointConfigurationsContainer {
            endpointConfigurationsDecoded0 = [GlobalAcceleratorClientTypes.EndpointConfiguration]()
            for structure0 in endpointConfigurationsContainer {
                if let structure0 = structure0 {
                    endpointConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        endpointConfigurations = endpointConfigurationsDecoded0
        let trafficDialPercentageDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .trafficDialPercentage)
        trafficDialPercentage = trafficDialPercentageDecoded
        let healthCheckPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthCheckPort)
        healthCheckPort = healthCheckPortDecoded
        let healthCheckProtocolDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.HealthCheckProtocol.self, forKey: .healthCheckProtocol)
        healthCheckProtocol = healthCheckProtocolDecoded
        let healthCheckPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .healthCheckPath)
        healthCheckPath = healthCheckPathDecoded
        let healthCheckIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthCheckIntervalSeconds)
        healthCheckIntervalSeconds = healthCheckIntervalSecondsDecoded
        let thresholdCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .thresholdCount)
        thresholdCount = thresholdCountDecoded
        let portOverridesContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.PortOverride?].self, forKey: .portOverrides)
        var portOverridesDecoded0:[GlobalAcceleratorClientTypes.PortOverride]? = nil
        if let portOverridesContainer = portOverridesContainer {
            portOverridesDecoded0 = [GlobalAcceleratorClientTypes.PortOverride]()
            for structure0 in portOverridesContainer {
                if let structure0 = structure0 {
                    portOverridesDecoded0?.append(structure0)
                }
            }
        }
        portOverrides = portOverridesDecoded0
    }
}

extension UpdateEndpointGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateEndpointGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.endpointGroup = output.endpointGroup
        } else {
            self.endpointGroup = nil
        }
    }
}

public struct UpdateEndpointGroupOutput: Swift.Equatable {
    /// The information about the endpoint group that was updated.
    public var endpointGroup: GlobalAcceleratorClientTypes.EndpointGroup?

    public init(
        endpointGroup: GlobalAcceleratorClientTypes.EndpointGroup? = nil
    )
    {
        self.endpointGroup = endpointGroup
    }
}

struct UpdateEndpointGroupOutputBody: Swift.Equatable {
    let endpointGroup: GlobalAcceleratorClientTypes.EndpointGroup?
}

extension UpdateEndpointGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointGroup = "EndpointGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.EndpointGroup.self, forKey: .endpointGroup)
        endpointGroup = endpointGroupDecoded
    }
}

enum UpdateEndpointGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EndpointGroupNotFoundException": return try await EndpointGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateListenerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientAffinity = "ClientAffinity"
        case listenerArn = "ListenerArn"
        case portRanges = "PortRanges"
        case `protocol` = "Protocol"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientAffinity = self.clientAffinity {
            try encodeContainer.encode(clientAffinity.rawValue, forKey: .clientAffinity)
        }
        if let listenerArn = self.listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
        if let portRanges = portRanges {
            var portRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portRanges)
            for portrange0 in portRanges {
                try portRangesContainer.encode(portrange0)
            }
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
    }
}

extension UpdateListenerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateListenerInput: Swift.Equatable {
    /// Client affinity lets you direct all requests from a user to the same endpoint, if you have stateful applications, regardless of the port and protocol of the client request. Client affinity gives you control over whether to always route each client to the same specific endpoint. Global Accelerator uses a consistent-flow hashing algorithm to choose the optimal endpoint for a connection. If client affinity is NONE, Global Accelerator uses the "five-tuple" (5-tuple) propertiessource IP address, source port, destination IP address, destination port, and protocolto select the hash value, and then chooses the best endpoint. However, with this setting, if someone uses different ports to connect to Global Accelerator, their connections might not be always routed to the same endpoint because the hash value changes. If you want a given client to always be routed to the same endpoint, set client affinity to SOURCE_IP instead. When you use the SOURCE_IP setting, Global Accelerator uses the "two-tuple" (2-tuple) properties source (client) IP address and destination IP addressto select the hash value. The default value is NONE.
    public var clientAffinity: GlobalAcceleratorClientTypes.ClientAffinity?
    /// The Amazon Resource Name (ARN) of the listener to update.
    /// This member is required.
    public var listenerArn: Swift.String?
    /// The updated list of port ranges for the connections from clients to the accelerator.
    public var portRanges: [GlobalAcceleratorClientTypes.PortRange]?
    /// The updated protocol for the connections from clients to the accelerator.
    public var `protocol`: GlobalAcceleratorClientTypes.ModelProtocol?

    public init(
        clientAffinity: GlobalAcceleratorClientTypes.ClientAffinity? = nil,
        listenerArn: Swift.String? = nil,
        portRanges: [GlobalAcceleratorClientTypes.PortRange]? = nil,
        `protocol`: GlobalAcceleratorClientTypes.ModelProtocol? = nil
    )
    {
        self.clientAffinity = clientAffinity
        self.listenerArn = listenerArn
        self.portRanges = portRanges
        self.`protocol` = `protocol`
    }
}

struct UpdateListenerInputBody: Swift.Equatable {
    let listenerArn: Swift.String?
    let portRanges: [GlobalAcceleratorClientTypes.PortRange]?
    let `protocol`: GlobalAcceleratorClientTypes.ModelProtocol?
    let clientAffinity: GlobalAcceleratorClientTypes.ClientAffinity?
}

extension UpdateListenerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientAffinity = "ClientAffinity"
        case listenerArn = "ListenerArn"
        case portRanges = "PortRanges"
        case `protocol` = "Protocol"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
        let portRangesContainer = try containerValues.decodeIfPresent([GlobalAcceleratorClientTypes.PortRange?].self, forKey: .portRanges)
        var portRangesDecoded0:[GlobalAcceleratorClientTypes.PortRange]? = nil
        if let portRangesContainer = portRangesContainer {
            portRangesDecoded0 = [GlobalAcceleratorClientTypes.PortRange]()
            for structure0 in portRangesContainer {
                if let structure0 = structure0 {
                    portRangesDecoded0?.append(structure0)
                }
            }
        }
        portRanges = portRangesDecoded0
        let protocolDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.ModelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let clientAffinityDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.ClientAffinity.self, forKey: .clientAffinity)
        clientAffinity = clientAffinityDecoded
    }
}

extension UpdateListenerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateListenerOutputBody = try responseDecoder.decode(responseBody: data)
            self.listener = output.listener
        } else {
            self.listener = nil
        }
    }
}

public struct UpdateListenerOutput: Swift.Equatable {
    /// Information for the updated listener.
    public var listener: GlobalAcceleratorClientTypes.Listener?

    public init(
        listener: GlobalAcceleratorClientTypes.Listener? = nil
    )
    {
        self.listener = listener
    }
}

struct UpdateListenerOutputBody: Swift.Equatable {
    let listener: GlobalAcceleratorClientTypes.Listener?
}

extension UpdateListenerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listener = "Listener"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.Listener.self, forKey: .listener)
        listener = listenerDecoded
    }
}

enum UpdateListenerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPortRangeException": return try await InvalidPortRangeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ListenerNotFoundException": return try await ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WithdrawByoipCidrInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidr = "Cidr"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidr = self.cidr {
            try encodeContainer.encode(cidr, forKey: .cidr)
        }
    }
}

extension WithdrawByoipCidrInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct WithdrawByoipCidrInput: Swift.Equatable {
    /// The address range, in CIDR notation.
    /// This member is required.
    public var cidr: Swift.String?

    public init(
        cidr: Swift.String? = nil
    )
    {
        self.cidr = cidr
    }
}

struct WithdrawByoipCidrInputBody: Swift.Equatable {
    let cidr: Swift.String?
}

extension WithdrawByoipCidrInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidr = "Cidr"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cidr)
        cidr = cidrDecoded
    }
}

extension WithdrawByoipCidrOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: WithdrawByoipCidrOutputBody = try responseDecoder.decode(responseBody: data)
            self.byoipCidr = output.byoipCidr
        } else {
            self.byoipCidr = nil
        }
    }
}

public struct WithdrawByoipCidrOutput: Swift.Equatable {
    /// Information about the address pool.
    public var byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr?

    public init(
        byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr? = nil
    )
    {
        self.byoipCidr = byoipCidr
    }
}

struct WithdrawByoipCidrOutputBody: Swift.Equatable {
    let byoipCidr: GlobalAcceleratorClientTypes.ByoipCidr?
}

extension WithdrawByoipCidrOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case byoipCidr = "ByoipCidr"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let byoipCidrDecoded = try containerValues.decodeIfPresent(GlobalAcceleratorClientTypes.ByoipCidr.self, forKey: .byoipCidr)
        byoipCidr = byoipCidrDecoded
    }
}

enum WithdrawByoipCidrOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ByoipCidrNotFoundException": return try await ByoipCidrNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IncorrectCidrStateException": return try await IncorrectCidrStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}
