// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AcceptSharedDirectoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sharedDirectoryId = "SharedDirectoryId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sharedDirectoryId = self.sharedDirectoryId {
            try encodeContainer.encode(sharedDirectoryId, forKey: .sharedDirectoryId)
        }
    }
}

extension AcceptSharedDirectoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AcceptSharedDirectoryInput: Swift.Equatable {
    /// Identifier of the shared directory in the directory consumer account. This identifier is different for each directory owner account.
    /// This member is required.
    public var sharedDirectoryId: Swift.String?

    public init(
        sharedDirectoryId: Swift.String? = nil
    )
    {
        self.sharedDirectoryId = sharedDirectoryId
    }
}

struct AcceptSharedDirectoryInputBody: Swift.Equatable {
    let sharedDirectoryId: Swift.String?
}

extension AcceptSharedDirectoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sharedDirectoryId = "SharedDirectoryId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sharedDirectoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedDirectoryId)
        sharedDirectoryId = sharedDirectoryIdDecoded
    }
}

extension AcceptSharedDirectoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AcceptSharedDirectoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.sharedDirectory = output.sharedDirectory
        } else {
            self.sharedDirectory = nil
        }
    }
}

public struct AcceptSharedDirectoryOutput: Swift.Equatable {
    /// The shared directory in the directory consumer account.
    public var sharedDirectory: DirectoryClientTypes.SharedDirectory?

    public init(
        sharedDirectory: DirectoryClientTypes.SharedDirectory? = nil
    )
    {
        self.sharedDirectory = sharedDirectory
    }
}

struct AcceptSharedDirectoryOutputBody: Swift.Equatable {
    let sharedDirectory: DirectoryClientTypes.SharedDirectory?
}

extension AcceptSharedDirectoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sharedDirectory = "SharedDirectory"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sharedDirectoryDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.SharedDirectory.self, forKey: .sharedDirectory)
        sharedDirectory = sharedDirectoryDecoded
    }
}

enum AcceptSharedDirectoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryAlreadySharedException": return try await DirectoryAlreadySharedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Client authentication is not available in this region at this time.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The descriptive message for the exception.
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request identifier.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension AddIpRoutesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case ipRoutes = "IpRoutes"
        case updateSecurityGroupForDirectoryControllers = "UpdateSecurityGroupForDirectoryControllers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let ipRoutes = ipRoutes {
            var ipRoutesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipRoutes)
            for iproute0 in ipRoutes {
                try ipRoutesContainer.encode(iproute0)
            }
        }
        if let updateSecurityGroupForDirectoryControllers = self.updateSecurityGroupForDirectoryControllers {
            try encodeContainer.encode(updateSecurityGroupForDirectoryControllers, forKey: .updateSecurityGroupForDirectoryControllers)
        }
    }
}

extension AddIpRoutesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AddIpRoutesInput: Swift.Equatable {
    /// Identifier (ID) of the directory to which to add the address block.
    /// This member is required.
    public var directoryId: Swift.String?
    /// IP address blocks, using CIDR format, of the traffic to route. This is often the IP address block of the DNS server used for your self-managed domain.
    /// This member is required.
    public var ipRoutes: [DirectoryClientTypes.IpRoute]?
    /// If set to true, updates the inbound and outbound rules of the security group that has the description: "Amazon Web Services created security group for directory ID directory controllers." Following are the new rules: Inbound:
    ///
    /// * Type: Custom UDP Rule, Protocol: UDP, Range: 88, Source: 0.0.0.0/0
    ///
    /// * Type: Custom UDP Rule, Protocol: UDP, Range: 123, Source: 0.0.0.0/0
    ///
    /// * Type: Custom UDP Rule, Protocol: UDP, Range: 138, Source: 0.0.0.0/0
    ///
    /// * Type: Custom UDP Rule, Protocol: UDP, Range: 389, Source: 0.0.0.0/0
    ///
    /// * Type: Custom UDP Rule, Protocol: UDP, Range: 464, Source: 0.0.0.0/0
    ///
    /// * Type: Custom UDP Rule, Protocol: UDP, Range: 445, Source: 0.0.0.0/0
    ///
    /// * Type: Custom TCP Rule, Protocol: TCP, Range: 88, Source: 0.0.0.0/0
    ///
    /// * Type: Custom TCP Rule, Protocol: TCP, Range: 135, Source: 0.0.0.0/0
    ///
    /// * Type: Custom TCP Rule, Protocol: TCP, Range: 445, Source: 0.0.0.0/0
    ///
    /// * Type: Custom TCP Rule, Protocol: TCP, Range: 464, Source: 0.0.0.0/0
    ///
    /// * Type: Custom TCP Rule, Protocol: TCP, Range: 636, Source: 0.0.0.0/0
    ///
    /// * Type: Custom TCP Rule, Protocol: TCP, Range: 1024-65535, Source: 0.0.0.0/0
    ///
    /// * Type: Custom TCP Rule, Protocol: TCP, Range: 3268-33269, Source: 0.0.0.0/0
    ///
    /// * Type: DNS (UDP), Protocol: UDP, Range: 53, Source: 0.0.0.0/0
    ///
    /// * Type: DNS (TCP), Protocol: TCP, Range: 53, Source: 0.0.0.0/0
    ///
    /// * Type: LDAP, Protocol: TCP, Range: 389, Source: 0.0.0.0/0
    ///
    /// * Type: All ICMP, Protocol: All, Range: N/A, Source: 0.0.0.0/0
    ///
    ///
    /// Outbound:
    ///
    /// * Type: All traffic, Protocol: All, Range: All, Destination: 0.0.0.0/0
    ///
    ///
    /// These security rules impact an internal network interface that is not exposed publicly.
    public var updateSecurityGroupForDirectoryControllers: Swift.Bool?

    public init(
        directoryId: Swift.String? = nil,
        ipRoutes: [DirectoryClientTypes.IpRoute]? = nil,
        updateSecurityGroupForDirectoryControllers: Swift.Bool? = nil
    )
    {
        self.directoryId = directoryId
        self.ipRoutes = ipRoutes
        self.updateSecurityGroupForDirectoryControllers = updateSecurityGroupForDirectoryControllers
    }
}

struct AddIpRoutesInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let ipRoutes: [DirectoryClientTypes.IpRoute]?
    let updateSecurityGroupForDirectoryControllers: Swift.Bool?
}

extension AddIpRoutesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case ipRoutes = "IpRoutes"
        case updateSecurityGroupForDirectoryControllers = "UpdateSecurityGroupForDirectoryControllers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let ipRoutesContainer = try containerValues.decodeIfPresent([DirectoryClientTypes.IpRoute?].self, forKey: .ipRoutes)
        var ipRoutesDecoded0:[DirectoryClientTypes.IpRoute]? = nil
        if let ipRoutesContainer = ipRoutesContainer {
            ipRoutesDecoded0 = [DirectoryClientTypes.IpRoute]()
            for structure0 in ipRoutesContainer {
                if let structure0 = structure0 {
                    ipRoutesDecoded0?.append(structure0)
                }
            }
        }
        ipRoutes = ipRoutesDecoded0
        let updateSecurityGroupForDirectoryControllersDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .updateSecurityGroupForDirectoryControllers)
        updateSecurityGroupForDirectoryControllers = updateSecurityGroupForDirectoryControllersDecoded
    }
}

extension AddIpRoutesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AddIpRoutesOutput: Swift.Equatable {

    public init() { }
}

enum AddIpRoutesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryUnavailableException": return try await DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityAlreadyExistsException": return try await EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IpRouteLimitExceededException": return try await IpRouteLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AddRegionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case regionName = "RegionName"
        case vpcSettings = "VPCSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let regionName = self.regionName {
            try encodeContainer.encode(regionName, forKey: .regionName)
        }
        if let vpcSettings = self.vpcSettings {
            try encodeContainer.encode(vpcSettings, forKey: .vpcSettings)
        }
    }
}

extension AddRegionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AddRegionInput: Swift.Equatable {
    /// The identifier of the directory to which you want to add Region replication.
    /// This member is required.
    public var directoryId: Swift.String?
    /// The name of the Region where you want to add domain controllers for replication. For example, us-east-1.
    /// This member is required.
    public var regionName: Swift.String?
    /// Contains VPC information for the [CreateDirectory] or [CreateMicrosoftAD] operation.
    /// This member is required.
    public var vpcSettings: DirectoryClientTypes.DirectoryVpcSettings?

    public init(
        directoryId: Swift.String? = nil,
        regionName: Swift.String? = nil,
        vpcSettings: DirectoryClientTypes.DirectoryVpcSettings? = nil
    )
    {
        self.directoryId = directoryId
        self.regionName = regionName
        self.vpcSettings = vpcSettings
    }
}

struct AddRegionInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let regionName: Swift.String?
    let vpcSettings: DirectoryClientTypes.DirectoryVpcSettings?
}

extension AddRegionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case regionName = "RegionName"
        case vpcSettings = "VPCSettings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let regionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionName)
        regionName = regionNameDecoded
        let vpcSettingsDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.DirectoryVpcSettings.self, forKey: .vpcSettings)
        vpcSettings = vpcSettingsDecoded
    }
}

extension AddRegionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AddRegionOutput: Swift.Equatable {

    public init() { }
}

enum AddRegionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryAlreadyInRegionException": return try await DirectoryAlreadyInRegionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryDoesNotExistException": return try await DirectoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryUnavailableException": return try await DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RegionLimitExceededException": return try await RegionLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AddTagsToResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension AddTagsToResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AddTagsToResourceInput: Swift.Equatable {
    /// Identifier (ID) for the directory to which to add the tag.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The tags to be assigned to the directory.
    /// This member is required.
    public var tags: [DirectoryClientTypes.Tag]?

    public init(
        resourceId: Swift.String? = nil,
        tags: [DirectoryClientTypes.Tag]? = nil
    )
    {
        self.resourceId = resourceId
        self.tags = tags
    }
}

struct AddTagsToResourceInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let tags: [DirectoryClientTypes.Tag]?
}

extension AddTagsToResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DirectoryClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DirectoryClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DirectoryClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AddTagsToResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AddTagsToResourceOutput: Swift.Equatable {

    public init() { }
}

enum AddTagsToResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagLimitExceededException": return try await TagLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DirectoryClientTypes.Attribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension DirectoryClientTypes {
    /// Represents a named directory attribute.
    public struct Attribute: Swift.Equatable {
        /// The name of the attribute.
        public var name: Swift.String?
        /// The value of the attribute.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension AuthenticationFailedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AuthenticationFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An authentication error occurred.
public struct AuthenticationFailedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The textual message for the exception.
        public internal(set) var message: Swift.String? = nil
        /// The identifier of the request that caused the exception.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AuthenticationFailedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct AuthenticationFailedExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension AuthenticationFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension CancelSchemaExtensionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case schemaExtensionId = "SchemaExtensionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let schemaExtensionId = self.schemaExtensionId {
            try encodeContainer.encode(schemaExtensionId, forKey: .schemaExtensionId)
        }
    }
}

extension CancelSchemaExtensionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CancelSchemaExtensionInput: Swift.Equatable {
    /// The identifier of the directory whose schema extension will be canceled.
    /// This member is required.
    public var directoryId: Swift.String?
    /// The identifier of the schema extension that will be canceled.
    /// This member is required.
    public var schemaExtensionId: Swift.String?

    public init(
        directoryId: Swift.String? = nil,
        schemaExtensionId: Swift.String? = nil
    )
    {
        self.directoryId = directoryId
        self.schemaExtensionId = schemaExtensionId
    }
}

struct CancelSchemaExtensionInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let schemaExtensionId: Swift.String?
}

extension CancelSchemaExtensionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case schemaExtensionId = "SchemaExtensionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let schemaExtensionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaExtensionId)
        schemaExtensionId = schemaExtensionIdDecoded
    }
}

extension CancelSchemaExtensionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CancelSchemaExtensionOutput: Swift.Equatable {

    public init() { }
}

enum CancelSchemaExtensionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DirectoryClientTypes.Certificate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateId = "CertificateId"
        case clientCertAuthSettings = "ClientCertAuthSettings"
        case commonName = "CommonName"
        case expiryDateTime = "ExpiryDateTime"
        case registeredDateTime = "RegisteredDateTime"
        case state = "State"
        case stateReason = "StateReason"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateId = self.certificateId {
            try encodeContainer.encode(certificateId, forKey: .certificateId)
        }
        if let clientCertAuthSettings = self.clientCertAuthSettings {
            try encodeContainer.encode(clientCertAuthSettings, forKey: .clientCertAuthSettings)
        }
        if let commonName = self.commonName {
            try encodeContainer.encode(commonName, forKey: .commonName)
        }
        if let expiryDateTime = self.expiryDateTime {
            try encodeContainer.encodeTimestamp(expiryDateTime, format: .epochSeconds, forKey: .expiryDateTime)
        }
        if let registeredDateTime = self.registeredDateTime {
            try encodeContainer.encodeTimestamp(registeredDateTime, format: .epochSeconds, forKey: .registeredDateTime)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateReason = self.stateReason {
            try encodeContainer.encode(stateReason, forKey: .stateReason)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.CertificateState.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let commonNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commonName)
        commonName = commonNameDecoded
        let registeredDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .registeredDateTime)
        registeredDateTime = registeredDateTimeDecoded
        let expiryDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expiryDateTime)
        expiryDateTime = expiryDateTimeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.CertificateType.self, forKey: .type)
        type = typeDecoded
        let clientCertAuthSettingsDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.ClientCertAuthSettings.self, forKey: .clientCertAuthSettings)
        clientCertAuthSettings = clientCertAuthSettingsDecoded
    }
}

extension DirectoryClientTypes {
    /// Information about the certificate.
    public struct Certificate: Swift.Equatable {
        /// The identifier of the certificate.
        public var certificateId: Swift.String?
        /// A ClientCertAuthSettings object that contains client certificate authentication settings.
        public var clientCertAuthSettings: DirectoryClientTypes.ClientCertAuthSettings?
        /// The common name for the certificate.
        public var commonName: Swift.String?
        /// The date and time when the certificate will expire.
        public var expiryDateTime: ClientRuntime.Date?
        /// The date and time that the certificate was registered.
        public var registeredDateTime: ClientRuntime.Date?
        /// The state of the certificate.
        public var state: DirectoryClientTypes.CertificateState?
        /// Describes a state change for the certificate.
        public var stateReason: Swift.String?
        /// The function that the registered certificate performs. Valid values include ClientLDAPS or ClientCertAuth. The default value is ClientLDAPS.
        public var type: DirectoryClientTypes.CertificateType?

        public init(
            certificateId: Swift.String? = nil,
            clientCertAuthSettings: DirectoryClientTypes.ClientCertAuthSettings? = nil,
            commonName: Swift.String? = nil,
            expiryDateTime: ClientRuntime.Date? = nil,
            registeredDateTime: ClientRuntime.Date? = nil,
            state: DirectoryClientTypes.CertificateState? = nil,
            stateReason: Swift.String? = nil,
            type: DirectoryClientTypes.CertificateType? = nil
        )
        {
            self.certificateId = certificateId
            self.clientCertAuthSettings = clientCertAuthSettings
            self.commonName = commonName
            self.expiryDateTime = expiryDateTime
            self.registeredDateTime = registeredDateTime
            self.state = state
            self.stateReason = stateReason
            self.type = type
        }
    }

}

extension CertificateAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CertificateAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The certificate has already been registered into the system.
public struct CertificateAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The descriptive message for the exception.
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request identifier.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CertificateAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct CertificateAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension CertificateAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension CertificateDoesNotExistException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CertificateDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The certificate is not present in the system for describe or deregister activities.
public struct CertificateDoesNotExistException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The descriptive message for the exception.
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request identifier.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CertificateDoesNotExistException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct CertificateDoesNotExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension CertificateDoesNotExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension CertificateInUseException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CertificateInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The certificate is being used for the LDAP security connection and cannot be removed without disabling LDAP security.
public struct CertificateInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The descriptive message for the exception.
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request identifier.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CertificateInUseException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct CertificateInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension CertificateInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DirectoryClientTypes.CertificateInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateId = "CertificateId"
        case commonName = "CommonName"
        case expiryDateTime = "ExpiryDateTime"
        case state = "State"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateId = self.certificateId {
            try encodeContainer.encode(certificateId, forKey: .certificateId)
        }
        if let commonName = self.commonName {
            try encodeContainer.encode(commonName, forKey: .commonName)
        }
        if let expiryDateTime = self.expiryDateTime {
            try encodeContainer.encodeTimestamp(expiryDateTime, format: .epochSeconds, forKey: .expiryDateTime)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
        let commonNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commonName)
        commonName = commonNameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.CertificateState.self, forKey: .state)
        state = stateDecoded
        let expiryDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expiryDateTime)
        expiryDateTime = expiryDateTimeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.CertificateType.self, forKey: .type)
        type = typeDecoded
    }
}

extension DirectoryClientTypes {
    /// Contains general information about a certificate.
    public struct CertificateInfo: Swift.Equatable {
        /// The identifier of the certificate.
        public var certificateId: Swift.String?
        /// The common name for the certificate.
        public var commonName: Swift.String?
        /// The date and time when the certificate will expire.
        public var expiryDateTime: ClientRuntime.Date?
        /// The state of the certificate.
        public var state: DirectoryClientTypes.CertificateState?
        /// The function that the registered certificate performs. Valid values include ClientLDAPS or ClientCertAuth. The default value is ClientLDAPS.
        public var type: DirectoryClientTypes.CertificateType?

        public init(
            certificateId: Swift.String? = nil,
            commonName: Swift.String? = nil,
            expiryDateTime: ClientRuntime.Date? = nil,
            state: DirectoryClientTypes.CertificateState? = nil,
            type: DirectoryClientTypes.CertificateType? = nil
        )
        {
            self.certificateId = certificateId
            self.commonName = commonName
            self.expiryDateTime = expiryDateTime
            self.state = state
            self.type = type
        }
    }

}

extension CertificateLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CertificateLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The certificate could not be added because the certificate limit has been reached.
public struct CertificateLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The descriptive message for the exception.
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request identifier.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CertificateLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct CertificateLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension CertificateLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DirectoryClientTypes {
    public enum CertificateState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deregistered
        case deregistering
        case deregisterFailed
        case registered
        case registering
        case registerFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [CertificateState] {
            return [
                .deregistered,
                .deregistering,
                .deregisterFailed,
                .registered,
                .registering,
                .registerFailed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deregistered: return "Deregistered"
            case .deregistering: return "Deregistering"
            case .deregisterFailed: return "DeregisterFailed"
            case .registered: return "Registered"
            case .registering: return "Registering"
            case .registerFailed: return "RegisterFailed"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CertificateState(rawValue: rawValue) ?? CertificateState.sdkUnknown(rawValue)
        }
    }
}

extension DirectoryClientTypes {
    public enum CertificateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case clientCertAuth
        case clientLdaps
        case sdkUnknown(Swift.String)

        public static var allCases: [CertificateType] {
            return [
                .clientCertAuth,
                .clientLdaps,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .clientCertAuth: return "ClientCertAuth"
            case .clientLdaps: return "ClientLDAPS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CertificateType(rawValue: rawValue) ?? CertificateType.sdkUnknown(rawValue)
        }
    }
}

extension DirectoryClientTypes.ClientAuthenticationSettingInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastUpdatedDateTime = "LastUpdatedDateTime"
        case status = "Status"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.ClientAuthenticationType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.ClientAuthenticationStatus.self, forKey: .status)
        status = statusDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension DirectoryClientTypes {
    /// Contains information about a client authentication method for a directory.
    public struct ClientAuthenticationSettingInfo: Swift.Equatable {
        /// The date and time when the status of the client authentication type was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// Whether the client authentication type is enabled or disabled for the specified directory.
        public var status: DirectoryClientTypes.ClientAuthenticationStatus?
        /// The type of client authentication for the specified directory. If no type is specified, a list of all client authentication types that are supported for the directory is retrieved.
        public var type: DirectoryClientTypes.ClientAuthenticationType?

        public init(
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            status: DirectoryClientTypes.ClientAuthenticationStatus? = nil,
            type: DirectoryClientTypes.ClientAuthenticationType? = nil
        )
        {
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.status = status
            self.type = type
        }
    }

}

extension DirectoryClientTypes {
    public enum ClientAuthenticationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ClientAuthenticationStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ClientAuthenticationStatus(rawValue: rawValue) ?? ClientAuthenticationStatus.sdkUnknown(rawValue)
        }
    }
}

extension DirectoryClientTypes {
    public enum ClientAuthenticationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case smartCard
        case smartCardOrPassword
        case sdkUnknown(Swift.String)

        public static var allCases: [ClientAuthenticationType] {
            return [
                .smartCard,
                .smartCardOrPassword,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .smartCard: return "SmartCard"
            case .smartCardOrPassword: return "SmartCardOrPassword"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ClientAuthenticationType(rawValue: rawValue) ?? ClientAuthenticationType.sdkUnknown(rawValue)
        }
    }
}

extension DirectoryClientTypes.ClientCertAuthSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ocspUrl = "OCSPUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ocspUrl = self.ocspUrl {
            try encodeContainer.encode(ocspUrl, forKey: .ocspUrl)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ocspUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ocspUrl)
        ocspUrl = ocspUrlDecoded
    }
}

extension DirectoryClientTypes {
    /// Contains information about the client certificate authentication settings for the RegisterCertificate and DescribeCertificate operations.
    public struct ClientCertAuthSettings: Swift.Equatable {
        /// Specifies the URL of the default OCSP server used to check for revocation status. A secondary value to any OCSP address found in the AIA extension of the user certificate.
        public var ocspUrl: Swift.String?

        public init(
            ocspUrl: Swift.String? = nil
        )
        {
            self.ocspUrl = ocspUrl
        }
    }

}

extension ClientException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A client exception has occurred.
public struct ClientException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The descriptive message for the exception.
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request identifier.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ClientException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct ClientExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension ClientExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DirectoryClientTypes.Computer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computerAttributes = "ComputerAttributes"
        case computerId = "ComputerId"
        case computerName = "ComputerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computerAttributes = computerAttributes {
            var computerAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .computerAttributes)
            for attribute0 in computerAttributes {
                try computerAttributesContainer.encode(attribute0)
            }
        }
        if let computerId = self.computerId {
            try encodeContainer.encode(computerId, forKey: .computerId)
        }
        if let computerName = self.computerName {
            try encodeContainer.encode(computerName, forKey: .computerName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let computerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .computerId)
        computerId = computerIdDecoded
        let computerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .computerName)
        computerName = computerNameDecoded
        let computerAttributesContainer = try containerValues.decodeIfPresent([DirectoryClientTypes.Attribute?].self, forKey: .computerAttributes)
        var computerAttributesDecoded0:[DirectoryClientTypes.Attribute]? = nil
        if let computerAttributesContainer = computerAttributesContainer {
            computerAttributesDecoded0 = [DirectoryClientTypes.Attribute]()
            for structure0 in computerAttributesContainer {
                if let structure0 = structure0 {
                    computerAttributesDecoded0?.append(structure0)
                }
            }
        }
        computerAttributes = computerAttributesDecoded0
    }
}

extension DirectoryClientTypes {
    /// Contains information about a computer account in a directory.
    public struct Computer: Swift.Equatable {
        /// An array of [Attribute] objects containing the LDAP attributes that belong to the computer account.
        public var computerAttributes: [DirectoryClientTypes.Attribute]?
        /// The identifier of the computer.
        public var computerId: Swift.String?
        /// The computer name.
        public var computerName: Swift.String?

        public init(
            computerAttributes: [DirectoryClientTypes.Attribute]? = nil,
            computerId: Swift.String? = nil,
            computerName: Swift.String? = nil
        )
        {
            self.computerAttributes = computerAttributes
            self.computerId = computerId
            self.computerName = computerName
        }
    }

}

extension DirectoryClientTypes.ConditionalForwarder: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dnsIpAddrs = "DnsIpAddrs"
        case remoteDomainName = "RemoteDomainName"
        case replicationScope = "ReplicationScope"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dnsIpAddrs = dnsIpAddrs {
            var dnsIpAddrsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dnsIpAddrs)
            for ipaddr0 in dnsIpAddrs {
                try dnsIpAddrsContainer.encode(ipaddr0)
            }
        }
        if let remoteDomainName = self.remoteDomainName {
            try encodeContainer.encode(remoteDomainName, forKey: .remoteDomainName)
        }
        if let replicationScope = self.replicationScope {
            try encodeContainer.encode(replicationScope.rawValue, forKey: .replicationScope)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let remoteDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .remoteDomainName)
        remoteDomainName = remoteDomainNameDecoded
        let dnsIpAddrsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dnsIpAddrs)
        var dnsIpAddrsDecoded0:[Swift.String]? = nil
        if let dnsIpAddrsContainer = dnsIpAddrsContainer {
            dnsIpAddrsDecoded0 = [Swift.String]()
            for string0 in dnsIpAddrsContainer {
                if let string0 = string0 {
                    dnsIpAddrsDecoded0?.append(string0)
                }
            }
        }
        dnsIpAddrs = dnsIpAddrsDecoded0
        let replicationScopeDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.ReplicationScope.self, forKey: .replicationScope)
        replicationScope = replicationScopeDecoded
    }
}

extension DirectoryClientTypes {
    /// Points to a remote domain with which you are setting up a trust relationship. Conditional forwarders are required in order to set up a trust relationship with another domain.
    public struct ConditionalForwarder: Swift.Equatable {
        /// The IP addresses of the remote DNS server associated with RemoteDomainName. This is the IP address of the DNS server that your conditional forwarder points to.
        public var dnsIpAddrs: [Swift.String]?
        /// The fully qualified domain name (FQDN) of the remote domains pointed to by the conditional forwarder.
        public var remoteDomainName: Swift.String?
        /// The replication scope of the conditional forwarder. The only allowed value is Domain, which will replicate the conditional forwarder to all of the domain controllers for your Amazon Web Services directory.
        public var replicationScope: DirectoryClientTypes.ReplicationScope?

        public init(
            dnsIpAddrs: [Swift.String]? = nil,
            remoteDomainName: Swift.String? = nil,
            replicationScope: DirectoryClientTypes.ReplicationScope? = nil
        )
        {
            self.dnsIpAddrs = dnsIpAddrs
            self.remoteDomainName = remoteDomainName
            self.replicationScope = replicationScope
        }
    }

}

extension ConnectDirectoryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConnectDirectoryInput(connectSettings: \(Swift.String(describing: connectSettings)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), shortName: \(Swift.String(describing: shortName)), size: \(Swift.String(describing: size)), tags: \(Swift.String(describing: tags)), password: \"CONTENT_REDACTED\")"}
}

extension ConnectDirectoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectSettings = "ConnectSettings"
        case description = "Description"
        case name = "Name"
        case password = "Password"
        case shortName = "ShortName"
        case size = "Size"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectSettings = self.connectSettings {
            try encodeContainer.encode(connectSettings, forKey: .connectSettings)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let shortName = self.shortName {
            try encodeContainer.encode(shortName, forKey: .shortName)
        }
        if let size = self.size {
            try encodeContainer.encode(size.rawValue, forKey: .size)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension ConnectDirectoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the inputs for the [ConnectDirectory] operation.
public struct ConnectDirectoryInput: Swift.Equatable {
    /// A [DirectoryConnectSettings] object that contains additional information for the operation.
    /// This member is required.
    public var connectSettings: DirectoryClientTypes.DirectoryConnectSettings?
    /// A description for the directory.
    public var description: Swift.String?
    /// The fully qualified name of your self-managed directory, such as corp.example.com.
    /// This member is required.
    public var name: Swift.String?
    /// The password for your self-managed user account.
    /// This member is required.
    public var password: Swift.String?
    /// The NetBIOS name of your self-managed directory, such as CORP.
    public var shortName: Swift.String?
    /// The size of the directory.
    /// This member is required.
    public var size: DirectoryClientTypes.DirectorySize?
    /// The tags to be assigned to AD Connector.
    public var tags: [DirectoryClientTypes.Tag]?

    public init(
        connectSettings: DirectoryClientTypes.DirectoryConnectSettings? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        password: Swift.String? = nil,
        shortName: Swift.String? = nil,
        size: DirectoryClientTypes.DirectorySize? = nil,
        tags: [DirectoryClientTypes.Tag]? = nil
    )
    {
        self.connectSettings = connectSettings
        self.description = description
        self.name = name
        self.password = password
        self.shortName = shortName
        self.size = size
        self.tags = tags
    }
}

struct ConnectDirectoryInputBody: Swift.Equatable {
    let name: Swift.String?
    let shortName: Swift.String?
    let password: Swift.String?
    let description: Swift.String?
    let size: DirectoryClientTypes.DirectorySize?
    let connectSettings: DirectoryClientTypes.DirectoryConnectSettings?
    let tags: [DirectoryClientTypes.Tag]?
}

extension ConnectDirectoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectSettings = "ConnectSettings"
        case description = "Description"
        case name = "Name"
        case password = "Password"
        case shortName = "ShortName"
        case size = "Size"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let shortNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shortName)
        shortName = shortNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.DirectorySize.self, forKey: .size)
        size = sizeDecoded
        let connectSettingsDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.DirectoryConnectSettings.self, forKey: .connectSettings)
        connectSettings = connectSettingsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DirectoryClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DirectoryClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DirectoryClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ConnectDirectoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConnectDirectoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.directoryId = output.directoryId
        } else {
            self.directoryId = nil
        }
    }
}

/// Contains the results of the [ConnectDirectory] operation.
public struct ConnectDirectoryOutput: Swift.Equatable {
    /// The identifier of the new directory.
    public var directoryId: Swift.String?

    public init(
        directoryId: Swift.String? = nil
    )
    {
        self.directoryId = directoryId
    }
}

struct ConnectDirectoryOutputBody: Swift.Equatable {
    let directoryId: Swift.String?
}

extension ConnectDirectoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
    }
}

enum ConnectDirectoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryLimitExceededException": return try await DirectoryLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case directoryId = "DirectoryId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
    }
}

extension CreateAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the inputs for the [CreateAlias] operation.
public struct CreateAliasInput: Swift.Equatable {
    /// The requested alias. The alias must be unique amongst all aliases in Amazon Web Services. This operation throws an EntityAlreadyExistsException error if the alias already exists.
    /// This member is required.
    public var alias: Swift.String?
    /// The identifier of the directory for which to create the alias.
    /// This member is required.
    public var directoryId: Swift.String?

    public init(
        alias: Swift.String? = nil,
        directoryId: Swift.String? = nil
    )
    {
        self.alias = alias
        self.directoryId = directoryId
    }
}

struct CreateAliasInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let alias: Swift.String?
}

extension CreateAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case directoryId = "DirectoryId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
    }
}

extension CreateAliasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAliasOutputBody = try responseDecoder.decode(responseBody: data)
            self.alias = output.alias
            self.directoryId = output.directoryId
        } else {
            self.alias = nil
            self.directoryId = nil
        }
    }
}

/// Contains the results of the [CreateAlias] operation.
public struct CreateAliasOutput: Swift.Equatable {
    /// The alias for the directory.
    public var alias: Swift.String?
    /// The identifier of the directory.
    public var directoryId: Swift.String?

    public init(
        alias: Swift.String? = nil,
        directoryId: Swift.String? = nil
    )
    {
        self.alias = alias
        self.directoryId = directoryId
    }
}

struct CreateAliasOutputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let alias: Swift.String?
}

extension CreateAliasOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case directoryId = "DirectoryId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
    }
}

enum CreateAliasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityAlreadyExistsException": return try await EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateComputerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateComputerInput(computerAttributes: \(Swift.String(describing: computerAttributes)), computerName: \(Swift.String(describing: computerName)), directoryId: \(Swift.String(describing: directoryId)), organizationalUnitDistinguishedName: \(Swift.String(describing: organizationalUnitDistinguishedName)), password: \"CONTENT_REDACTED\")"}
}

extension CreateComputerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computerAttributes = "ComputerAttributes"
        case computerName = "ComputerName"
        case directoryId = "DirectoryId"
        case organizationalUnitDistinguishedName = "OrganizationalUnitDistinguishedName"
        case password = "Password"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computerAttributes = computerAttributes {
            var computerAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .computerAttributes)
            for attribute0 in computerAttributes {
                try computerAttributesContainer.encode(attribute0)
            }
        }
        if let computerName = self.computerName {
            try encodeContainer.encode(computerName, forKey: .computerName)
        }
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let organizationalUnitDistinguishedName = self.organizationalUnitDistinguishedName {
            try encodeContainer.encode(organizationalUnitDistinguishedName, forKey: .organizationalUnitDistinguishedName)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
    }
}

extension CreateComputerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the inputs for the [CreateComputer] operation.
public struct CreateComputerInput: Swift.Equatable {
    /// An array of [Attribute] objects that contain any LDAP attributes to apply to the computer account.
    public var computerAttributes: [DirectoryClientTypes.Attribute]?
    /// The name of the computer account.
    /// This member is required.
    public var computerName: Swift.String?
    /// The identifier of the directory in which to create the computer account.
    /// This member is required.
    public var directoryId: Swift.String?
    /// The fully-qualified distinguished name of the organizational unit to place the computer account in.
    public var organizationalUnitDistinguishedName: Swift.String?
    /// A one-time password that is used to join the computer to the directory. You should generate a random, strong password to use for this parameter.
    /// This member is required.
    public var password: Swift.String?

    public init(
        computerAttributes: [DirectoryClientTypes.Attribute]? = nil,
        computerName: Swift.String? = nil,
        directoryId: Swift.String? = nil,
        organizationalUnitDistinguishedName: Swift.String? = nil,
        password: Swift.String? = nil
    )
    {
        self.computerAttributes = computerAttributes
        self.computerName = computerName
        self.directoryId = directoryId
        self.organizationalUnitDistinguishedName = organizationalUnitDistinguishedName
        self.password = password
    }
}

struct CreateComputerInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let computerName: Swift.String?
    let password: Swift.String?
    let organizationalUnitDistinguishedName: Swift.String?
    let computerAttributes: [DirectoryClientTypes.Attribute]?
}

extension CreateComputerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computerAttributes = "ComputerAttributes"
        case computerName = "ComputerName"
        case directoryId = "DirectoryId"
        case organizationalUnitDistinguishedName = "OrganizationalUnitDistinguishedName"
        case password = "Password"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let computerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .computerName)
        computerName = computerNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let organizationalUnitDistinguishedNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationalUnitDistinguishedName)
        organizationalUnitDistinguishedName = organizationalUnitDistinguishedNameDecoded
        let computerAttributesContainer = try containerValues.decodeIfPresent([DirectoryClientTypes.Attribute?].self, forKey: .computerAttributes)
        var computerAttributesDecoded0:[DirectoryClientTypes.Attribute]? = nil
        if let computerAttributesContainer = computerAttributesContainer {
            computerAttributesDecoded0 = [DirectoryClientTypes.Attribute]()
            for structure0 in computerAttributesContainer {
                if let structure0 = structure0 {
                    computerAttributesDecoded0?.append(structure0)
                }
            }
        }
        computerAttributes = computerAttributesDecoded0
    }
}

extension CreateComputerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateComputerOutputBody = try responseDecoder.decode(responseBody: data)
            self.computer = output.computer
        } else {
            self.computer = nil
        }
    }
}

/// Contains the results for the [CreateComputer] operation.
public struct CreateComputerOutput: Swift.Equatable {
    /// A [Computer] object that represents the computer account.
    public var computer: DirectoryClientTypes.Computer?

    public init(
        computer: DirectoryClientTypes.Computer? = nil
    )
    {
        self.computer = computer
    }
}

struct CreateComputerOutputBody: Swift.Equatable {
    let computer: DirectoryClientTypes.Computer?
}

extension CreateComputerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computer = "Computer"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let computerDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.Computer.self, forKey: .computer)
        computer = computerDecoded
    }
}

enum CreateComputerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AuthenticationFailedException": return try await AuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryUnavailableException": return try await DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityAlreadyExistsException": return try await EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateConditionalForwarderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case dnsIpAddrs = "DnsIpAddrs"
        case remoteDomainName = "RemoteDomainName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let dnsIpAddrs = dnsIpAddrs {
            var dnsIpAddrsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dnsIpAddrs)
            for ipaddr0 in dnsIpAddrs {
                try dnsIpAddrsContainer.encode(ipaddr0)
            }
        }
        if let remoteDomainName = self.remoteDomainName {
            try encodeContainer.encode(remoteDomainName, forKey: .remoteDomainName)
        }
    }
}

extension CreateConditionalForwarderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Initiates the creation of a conditional forwarder for your Directory Service for Microsoft Active Directory. Conditional forwarders are required in order to set up a trust relationship with another domain.
public struct CreateConditionalForwarderInput: Swift.Equatable {
    /// The directory ID of the Amazon Web Services directory for which you are creating the conditional forwarder.
    /// This member is required.
    public var directoryId: Swift.String?
    /// The IP addresses of the remote DNS server associated with RemoteDomainName.
    /// This member is required.
    public var dnsIpAddrs: [Swift.String]?
    /// The fully qualified domain name (FQDN) of the remote domain with which you will set up a trust relationship.
    /// This member is required.
    public var remoteDomainName: Swift.String?

    public init(
        directoryId: Swift.String? = nil,
        dnsIpAddrs: [Swift.String]? = nil,
        remoteDomainName: Swift.String? = nil
    )
    {
        self.directoryId = directoryId
        self.dnsIpAddrs = dnsIpAddrs
        self.remoteDomainName = remoteDomainName
    }
}

struct CreateConditionalForwarderInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let remoteDomainName: Swift.String?
    let dnsIpAddrs: [Swift.String]?
}

extension CreateConditionalForwarderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case dnsIpAddrs = "DnsIpAddrs"
        case remoteDomainName = "RemoteDomainName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let remoteDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .remoteDomainName)
        remoteDomainName = remoteDomainNameDecoded
        let dnsIpAddrsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dnsIpAddrs)
        var dnsIpAddrsDecoded0:[Swift.String]? = nil
        if let dnsIpAddrsContainer = dnsIpAddrsContainer {
            dnsIpAddrsDecoded0 = [Swift.String]()
            for string0 in dnsIpAddrsContainer {
                if let string0 = string0 {
                    dnsIpAddrsDecoded0?.append(string0)
                }
            }
        }
        dnsIpAddrs = dnsIpAddrsDecoded0
    }
}

extension CreateConditionalForwarderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// The result of a CreateConditinalForwarder request.
public struct CreateConditionalForwarderOutput: Swift.Equatable {

    public init() { }
}

enum CreateConditionalForwarderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryUnavailableException": return try await DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityAlreadyExistsException": return try await EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDirectoryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDirectoryInput(description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), shortName: \(Swift.String(describing: shortName)), size: \(Swift.String(describing: size)), tags: \(Swift.String(describing: tags)), vpcSettings: \(Swift.String(describing: vpcSettings)), password: \"CONTENT_REDACTED\")"}
}

extension CreateDirectoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case password = "Password"
        case shortName = "ShortName"
        case size = "Size"
        case tags = "Tags"
        case vpcSettings = "VpcSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let shortName = self.shortName {
            try encodeContainer.encode(shortName, forKey: .shortName)
        }
        if let size = self.size {
            try encodeContainer.encode(size.rawValue, forKey: .size)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let vpcSettings = self.vpcSettings {
            try encodeContainer.encode(vpcSettings, forKey: .vpcSettings)
        }
    }
}

extension CreateDirectoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the inputs for the [CreateDirectory] operation.
public struct CreateDirectoryInput: Swift.Equatable {
    /// A description for the directory.
    public var description: Swift.String?
    /// The fully qualified name for the directory, such as corp.example.com.
    /// This member is required.
    public var name: Swift.String?
    /// The password for the directory administrator. The directory creation process creates a directory administrator account with the user name Administrator and this password. If you need to change the password for the administrator account, you can use the [ResetUserPassword] API call. The regex pattern for this string is made up of the following conditions:
    ///
    /// * Length (?=^.{8,64}$)  Must be between 8 and 64 characters
    ///
    ///
    /// AND any 3 of the following password complexity rules required by Active Directory:
    ///
    /// * Numbers and upper case and lowercase (?=.*\d)(?=.*[A-Z])(?=.*[a-z])
    ///
    /// * Numbers and special characters and lower case (?=.*\d)(?=.*[^A-Za-z0-9\s])(?=.*[a-z])
    ///
    /// * Special characters and upper case and lower case (?=.*[^A-Za-z0-9\s])(?=.*[A-Z])(?=.*[a-z])
    ///
    /// * Numbers and upper case and special characters (?=.*\d)(?=.*[A-Z])(?=.*[^A-Za-z0-9\s])
    ///
    ///
    /// For additional information about how Active Directory passwords are enforced, see [Password must meet complexity requirements](https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/password-must-meet-complexity-requirements) on the Microsoft website.
    /// This member is required.
    public var password: Swift.String?
    /// The NetBIOS name of the directory, such as CORP.
    public var shortName: Swift.String?
    /// The size of the directory.
    /// This member is required.
    public var size: DirectoryClientTypes.DirectorySize?
    /// The tags to be assigned to the Simple AD directory.
    public var tags: [DirectoryClientTypes.Tag]?
    /// A [DirectoryVpcSettings] object that contains additional information for the operation.
    public var vpcSettings: DirectoryClientTypes.DirectoryVpcSettings?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        password: Swift.String? = nil,
        shortName: Swift.String? = nil,
        size: DirectoryClientTypes.DirectorySize? = nil,
        tags: [DirectoryClientTypes.Tag]? = nil,
        vpcSettings: DirectoryClientTypes.DirectoryVpcSettings? = nil
    )
    {
        self.description = description
        self.name = name
        self.password = password
        self.shortName = shortName
        self.size = size
        self.tags = tags
        self.vpcSettings = vpcSettings
    }
}

struct CreateDirectoryInputBody: Swift.Equatable {
    let name: Swift.String?
    let shortName: Swift.String?
    let password: Swift.String?
    let description: Swift.String?
    let size: DirectoryClientTypes.DirectorySize?
    let vpcSettings: DirectoryClientTypes.DirectoryVpcSettings?
    let tags: [DirectoryClientTypes.Tag]?
}

extension CreateDirectoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case password = "Password"
        case shortName = "ShortName"
        case size = "Size"
        case tags = "Tags"
        case vpcSettings = "VpcSettings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let shortNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shortName)
        shortName = shortNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.DirectorySize.self, forKey: .size)
        size = sizeDecoded
        let vpcSettingsDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.DirectoryVpcSettings.self, forKey: .vpcSettings)
        vpcSettings = vpcSettingsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DirectoryClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DirectoryClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DirectoryClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDirectoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDirectoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.directoryId = output.directoryId
        } else {
            self.directoryId = nil
        }
    }
}

/// Contains the results of the [CreateDirectory] operation.
public struct CreateDirectoryOutput: Swift.Equatable {
    /// The identifier of the directory that was created.
    public var directoryId: Swift.String?

    public init(
        directoryId: Swift.String? = nil
    )
    {
        self.directoryId = directoryId
    }
}

struct CreateDirectoryOutputBody: Swift.Equatable {
    let directoryId: Swift.String?
}

extension CreateDirectoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
    }
}

enum CreateDirectoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryLimitExceededException": return try await DirectoryLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateLogSubscriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case logGroupName = "LogGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let logGroupName = self.logGroupName {
            try encodeContainer.encode(logGroupName, forKey: .logGroupName)
        }
    }
}

extension CreateLogSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateLogSubscriptionInput: Swift.Equatable {
    /// Identifier of the directory to which you want to subscribe and receive real-time logs to your specified CloudWatch log group.
    /// This member is required.
    public var directoryId: Swift.String?
    /// The name of the CloudWatch log group where the real-time domain controller logs are forwarded.
    /// This member is required.
    public var logGroupName: Swift.String?

    public init(
        directoryId: Swift.String? = nil,
        logGroupName: Swift.String? = nil
    )
    {
        self.directoryId = directoryId
        self.logGroupName = logGroupName
    }
}

struct CreateLogSubscriptionInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let logGroupName: Swift.String?
}

extension CreateLogSubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case logGroupName = "LogGroupName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let logGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
    }
}

extension CreateLogSubscriptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateLogSubscriptionOutput: Swift.Equatable {

    public init() { }
}

enum CreateLogSubscriptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityAlreadyExistsException": return try await EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsufficientPermissionsException": return try await InsufficientPermissionsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateMicrosoftADInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMicrosoftADInput(description: \(Swift.String(describing: description)), edition: \(Swift.String(describing: edition)), name: \(Swift.String(describing: name)), shortName: \(Swift.String(describing: shortName)), tags: \(Swift.String(describing: tags)), vpcSettings: \(Swift.String(describing: vpcSettings)), password: \"CONTENT_REDACTED\")"}
}

extension CreateMicrosoftADInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case edition = "Edition"
        case name = "Name"
        case password = "Password"
        case shortName = "ShortName"
        case tags = "Tags"
        case vpcSettings = "VpcSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let edition = self.edition {
            try encodeContainer.encode(edition.rawValue, forKey: .edition)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let shortName = self.shortName {
            try encodeContainer.encode(shortName, forKey: .shortName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let vpcSettings = self.vpcSettings {
            try encodeContainer.encode(vpcSettings, forKey: .vpcSettings)
        }
    }
}

extension CreateMicrosoftADInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Creates an Managed Microsoft AD directory.
public struct CreateMicrosoftADInput: Swift.Equatable {
    /// A description for the directory. This label will appear on the Amazon Web Services console Directory Details page after the directory is created.
    public var description: Swift.String?
    /// Managed Microsoft AD is available in two editions: Standard and Enterprise. Enterprise is the default.
    public var edition: DirectoryClientTypes.DirectoryEdition?
    /// The fully qualified domain name for the Managed Microsoft AD directory, such as corp.example.com. This name will resolve inside your VPC only. It does not need to be publicly resolvable.
    /// This member is required.
    public var name: Swift.String?
    /// The password for the default administrative user named Admin. If you need to change the password for the administrator account, you can use the [ResetUserPassword] API call.
    /// This member is required.
    public var password: Swift.String?
    /// The NetBIOS name for your domain, such as CORP. If you don't specify a NetBIOS name, it will default to the first part of your directory DNS. For example, CORP for the directory DNS corp.example.com.
    public var shortName: Swift.String?
    /// The tags to be assigned to the Managed Microsoft AD directory.
    public var tags: [DirectoryClientTypes.Tag]?
    /// Contains VPC information for the [CreateDirectory] or [CreateMicrosoftAD] operation.
    /// This member is required.
    public var vpcSettings: DirectoryClientTypes.DirectoryVpcSettings?

    public init(
        description: Swift.String? = nil,
        edition: DirectoryClientTypes.DirectoryEdition? = nil,
        name: Swift.String? = nil,
        password: Swift.String? = nil,
        shortName: Swift.String? = nil,
        tags: [DirectoryClientTypes.Tag]? = nil,
        vpcSettings: DirectoryClientTypes.DirectoryVpcSettings? = nil
    )
    {
        self.description = description
        self.edition = edition
        self.name = name
        self.password = password
        self.shortName = shortName
        self.tags = tags
        self.vpcSettings = vpcSettings
    }
}

struct CreateMicrosoftADInputBody: Swift.Equatable {
    let name: Swift.String?
    let shortName: Swift.String?
    let password: Swift.String?
    let description: Swift.String?
    let vpcSettings: DirectoryClientTypes.DirectoryVpcSettings?
    let edition: DirectoryClientTypes.DirectoryEdition?
    let tags: [DirectoryClientTypes.Tag]?
}

extension CreateMicrosoftADInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case edition = "Edition"
        case name = "Name"
        case password = "Password"
        case shortName = "ShortName"
        case tags = "Tags"
        case vpcSettings = "VpcSettings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let shortNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shortName)
        shortName = shortNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let vpcSettingsDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.DirectoryVpcSettings.self, forKey: .vpcSettings)
        vpcSettings = vpcSettingsDecoded
        let editionDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.DirectoryEdition.self, forKey: .edition)
        edition = editionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DirectoryClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DirectoryClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DirectoryClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateMicrosoftADOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateMicrosoftADOutputBody = try responseDecoder.decode(responseBody: data)
            self.directoryId = output.directoryId
        } else {
            self.directoryId = nil
        }
    }
}

/// Result of a CreateMicrosoftAD request.
public struct CreateMicrosoftADOutput: Swift.Equatable {
    /// The identifier of the directory that was created.
    public var directoryId: Swift.String?

    public init(
        directoryId: Swift.String? = nil
    )
    {
        self.directoryId = directoryId
    }
}

struct CreateMicrosoftADOutputBody: Swift.Equatable {
    let directoryId: Swift.String?
}

extension CreateMicrosoftADOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
    }
}

enum CreateMicrosoftADOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryLimitExceededException": return try await DirectoryLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSnapshotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension CreateSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the inputs for the [CreateSnapshot] operation.
public struct CreateSnapshotInput: Swift.Equatable {
    /// The identifier of the directory of which to take a snapshot.
    /// This member is required.
    public var directoryId: Swift.String?
    /// The descriptive name to apply to the snapshot.
    public var name: Swift.String?

    public init(
        directoryId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.directoryId = directoryId
        self.name = name
    }
}

struct CreateSnapshotInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let name: Swift.String?
}

extension CreateSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateSnapshotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSnapshotOutputBody = try responseDecoder.decode(responseBody: data)
            self.snapshotId = output.snapshotId
        } else {
            self.snapshotId = nil
        }
    }
}

/// Contains the results of the [CreateSnapshot] operation.
public struct CreateSnapshotOutput: Swift.Equatable {
    /// The identifier of the snapshot that was created.
    public var snapshotId: Swift.String?

    public init(
        snapshotId: Swift.String? = nil
    )
    {
        self.snapshotId = snapshotId
    }
}

struct CreateSnapshotOutputBody: Swift.Equatable {
    let snapshotId: Swift.String?
}

extension CreateSnapshotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotId = "SnapshotId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
    }
}

enum CreateSnapshotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SnapshotLimitExceededException": return try await SnapshotLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateTrustInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTrustInput(conditionalForwarderIpAddrs: \(Swift.String(describing: conditionalForwarderIpAddrs)), directoryId: \(Swift.String(describing: directoryId)), remoteDomainName: \(Swift.String(describing: remoteDomainName)), selectiveAuth: \(Swift.String(describing: selectiveAuth)), trustDirection: \(Swift.String(describing: trustDirection)), trustType: \(Swift.String(describing: trustType)), trustPassword: \"CONTENT_REDACTED\")"}
}

extension CreateTrustInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conditionalForwarderIpAddrs = "ConditionalForwarderIpAddrs"
        case directoryId = "DirectoryId"
        case remoteDomainName = "RemoteDomainName"
        case selectiveAuth = "SelectiveAuth"
        case trustDirection = "TrustDirection"
        case trustPassword = "TrustPassword"
        case trustType = "TrustType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conditionalForwarderIpAddrs = conditionalForwarderIpAddrs {
            var conditionalForwarderIpAddrsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .conditionalForwarderIpAddrs)
            for ipaddr0 in conditionalForwarderIpAddrs {
                try conditionalForwarderIpAddrsContainer.encode(ipaddr0)
            }
        }
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let remoteDomainName = self.remoteDomainName {
            try encodeContainer.encode(remoteDomainName, forKey: .remoteDomainName)
        }
        if let selectiveAuth = self.selectiveAuth {
            try encodeContainer.encode(selectiveAuth.rawValue, forKey: .selectiveAuth)
        }
        if let trustDirection = self.trustDirection {
            try encodeContainer.encode(trustDirection.rawValue, forKey: .trustDirection)
        }
        if let trustPassword = self.trustPassword {
            try encodeContainer.encode(trustPassword, forKey: .trustPassword)
        }
        if let trustType = self.trustType {
            try encodeContainer.encode(trustType.rawValue, forKey: .trustType)
        }
    }
}

extension CreateTrustInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Directory Service for Microsoft Active Directory allows you to configure trust relationships. For example, you can establish a trust between your Managed Microsoft AD directory, and your existing self-managed Microsoft Active Directory. This would allow you to provide users and groups access to resources in either domain, with a single set of credentials. This action initiates the creation of the Amazon Web Services side of a trust relationship between an Managed Microsoft AD directory and an external domain.
public struct CreateTrustInput: Swift.Equatable {
    /// The IP addresses of the remote DNS server associated with RemoteDomainName.
    public var conditionalForwarderIpAddrs: [Swift.String]?
    /// The Directory ID of the Managed Microsoft AD directory for which to establish the trust relationship.
    /// This member is required.
    public var directoryId: Swift.String?
    /// The Fully Qualified Domain Name (FQDN) of the external domain for which to create the trust relationship.
    /// This member is required.
    public var remoteDomainName: Swift.String?
    /// Optional parameter to enable selective authentication for the trust.
    public var selectiveAuth: DirectoryClientTypes.SelectiveAuth?
    /// The direction of the trust relationship.
    /// This member is required.
    public var trustDirection: DirectoryClientTypes.TrustDirection?
    /// The trust password. The must be the same password that was used when creating the trust relationship on the external domain.
    /// This member is required.
    public var trustPassword: Swift.String?
    /// The trust relationship type. Forest is the default.
    public var trustType: DirectoryClientTypes.TrustType?

    public init(
        conditionalForwarderIpAddrs: [Swift.String]? = nil,
        directoryId: Swift.String? = nil,
        remoteDomainName: Swift.String? = nil,
        selectiveAuth: DirectoryClientTypes.SelectiveAuth? = nil,
        trustDirection: DirectoryClientTypes.TrustDirection? = nil,
        trustPassword: Swift.String? = nil,
        trustType: DirectoryClientTypes.TrustType? = nil
    )
    {
        self.conditionalForwarderIpAddrs = conditionalForwarderIpAddrs
        self.directoryId = directoryId
        self.remoteDomainName = remoteDomainName
        self.selectiveAuth = selectiveAuth
        self.trustDirection = trustDirection
        self.trustPassword = trustPassword
        self.trustType = trustType
    }
}

struct CreateTrustInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let remoteDomainName: Swift.String?
    let trustPassword: Swift.String?
    let trustDirection: DirectoryClientTypes.TrustDirection?
    let trustType: DirectoryClientTypes.TrustType?
    let conditionalForwarderIpAddrs: [Swift.String]?
    let selectiveAuth: DirectoryClientTypes.SelectiveAuth?
}

extension CreateTrustInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conditionalForwarderIpAddrs = "ConditionalForwarderIpAddrs"
        case directoryId = "DirectoryId"
        case remoteDomainName = "RemoteDomainName"
        case selectiveAuth = "SelectiveAuth"
        case trustDirection = "TrustDirection"
        case trustPassword = "TrustPassword"
        case trustType = "TrustType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let remoteDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .remoteDomainName)
        remoteDomainName = remoteDomainNameDecoded
        let trustPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustPassword)
        trustPassword = trustPasswordDecoded
        let trustDirectionDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.TrustDirection.self, forKey: .trustDirection)
        trustDirection = trustDirectionDecoded
        let trustTypeDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.TrustType.self, forKey: .trustType)
        trustType = trustTypeDecoded
        let conditionalForwarderIpAddrsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .conditionalForwarderIpAddrs)
        var conditionalForwarderIpAddrsDecoded0:[Swift.String]? = nil
        if let conditionalForwarderIpAddrsContainer = conditionalForwarderIpAddrsContainer {
            conditionalForwarderIpAddrsDecoded0 = [Swift.String]()
            for string0 in conditionalForwarderIpAddrsContainer {
                if let string0 = string0 {
                    conditionalForwarderIpAddrsDecoded0?.append(string0)
                }
            }
        }
        conditionalForwarderIpAddrs = conditionalForwarderIpAddrsDecoded0
        let selectiveAuthDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.SelectiveAuth.self, forKey: .selectiveAuth)
        selectiveAuth = selectiveAuthDecoded
    }
}

extension CreateTrustOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateTrustOutputBody = try responseDecoder.decode(responseBody: data)
            self.trustId = output.trustId
        } else {
            self.trustId = nil
        }
    }
}

/// The result of a CreateTrust request.
public struct CreateTrustOutput: Swift.Equatable {
    /// A unique identifier for the trust relationship that was created.
    public var trustId: Swift.String?

    public init(
        trustId: Swift.String? = nil
    )
    {
        self.trustId = trustId
    }
}

struct CreateTrustOutputBody: Swift.Equatable {
    let trustId: Swift.String?
}

extension CreateTrustOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustId = "TrustId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustId)
        trustId = trustIdDecoded
    }
}

enum CreateTrustOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityAlreadyExistsException": return try await EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteConditionalForwarderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case remoteDomainName = "RemoteDomainName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let remoteDomainName = self.remoteDomainName {
            try encodeContainer.encode(remoteDomainName, forKey: .remoteDomainName)
        }
    }
}

extension DeleteConditionalForwarderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Deletes a conditional forwarder.
public struct DeleteConditionalForwarderInput: Swift.Equatable {
    /// The directory ID for which you are deleting the conditional forwarder.
    /// This member is required.
    public var directoryId: Swift.String?
    /// The fully qualified domain name (FQDN) of the remote domain with which you are deleting the conditional forwarder.
    /// This member is required.
    public var remoteDomainName: Swift.String?

    public init(
        directoryId: Swift.String? = nil,
        remoteDomainName: Swift.String? = nil
    )
    {
        self.directoryId = directoryId
        self.remoteDomainName = remoteDomainName
    }
}

struct DeleteConditionalForwarderInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let remoteDomainName: Swift.String?
}

extension DeleteConditionalForwarderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case remoteDomainName = "RemoteDomainName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let remoteDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .remoteDomainName)
        remoteDomainName = remoteDomainNameDecoded
    }
}

extension DeleteConditionalForwarderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// The result of a DeleteConditionalForwarder request.
public struct DeleteConditionalForwarderOutput: Swift.Equatable {

    public init() { }
}

enum DeleteConditionalForwarderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryUnavailableException": return try await DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDirectoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
    }
}

extension DeleteDirectoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the inputs for the [DeleteDirectory] operation.
public struct DeleteDirectoryInput: Swift.Equatable {
    /// The identifier of the directory to delete.
    /// This member is required.
    public var directoryId: Swift.String?

    public init(
        directoryId: Swift.String? = nil
    )
    {
        self.directoryId = directoryId
    }
}

struct DeleteDirectoryInputBody: Swift.Equatable {
    let directoryId: Swift.String?
}

extension DeleteDirectoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
    }
}

extension DeleteDirectoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteDirectoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.directoryId = output.directoryId
        } else {
            self.directoryId = nil
        }
    }
}

/// Contains the results of the [DeleteDirectory] operation.
public struct DeleteDirectoryOutput: Swift.Equatable {
    /// The directory identifier.
    public var directoryId: Swift.String?

    public init(
        directoryId: Swift.String? = nil
    )
    {
        self.directoryId = directoryId
    }
}

struct DeleteDirectoryOutputBody: Swift.Equatable {
    let directoryId: Swift.String?
}

extension DeleteDirectoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
    }
}

enum DeleteDirectoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteLogSubscriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
    }
}

extension DeleteLogSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteLogSubscriptionInput: Swift.Equatable {
    /// Identifier of the directory whose log subscription you want to delete.
    /// This member is required.
    public var directoryId: Swift.String?

    public init(
        directoryId: Swift.String? = nil
    )
    {
        self.directoryId = directoryId
    }
}

struct DeleteLogSubscriptionInputBody: Swift.Equatable {
    let directoryId: Swift.String?
}

extension DeleteLogSubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
    }
}

extension DeleteLogSubscriptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteLogSubscriptionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteLogSubscriptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSnapshotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotId = "SnapshotId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let snapshotId = self.snapshotId {
            try encodeContainer.encode(snapshotId, forKey: .snapshotId)
        }
    }
}

extension DeleteSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the inputs for the [DeleteSnapshot] operation.
public struct DeleteSnapshotInput: Swift.Equatable {
    /// The identifier of the directory snapshot to be deleted.
    /// This member is required.
    public var snapshotId: Swift.String?

    public init(
        snapshotId: Swift.String? = nil
    )
    {
        self.snapshotId = snapshotId
    }
}

struct DeleteSnapshotInputBody: Swift.Equatable {
    let snapshotId: Swift.String?
}

extension DeleteSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotId = "SnapshotId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
    }
}

extension DeleteSnapshotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteSnapshotOutputBody = try responseDecoder.decode(responseBody: data)
            self.snapshotId = output.snapshotId
        } else {
            self.snapshotId = nil
        }
    }
}

/// Contains the results of the [DeleteSnapshot] operation.
public struct DeleteSnapshotOutput: Swift.Equatable {
    /// The identifier of the directory snapshot that was deleted.
    public var snapshotId: Swift.String?

    public init(
        snapshotId: Swift.String? = nil
    )
    {
        self.snapshotId = snapshotId
    }
}

struct DeleteSnapshotOutputBody: Swift.Equatable {
    let snapshotId: Swift.String?
}

extension DeleteSnapshotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotId = "SnapshotId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
    }
}

enum DeleteSnapshotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteTrustInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteAssociatedConditionalForwarder = "DeleteAssociatedConditionalForwarder"
        case trustId = "TrustId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deleteAssociatedConditionalForwarder = self.deleteAssociatedConditionalForwarder {
            try encodeContainer.encode(deleteAssociatedConditionalForwarder, forKey: .deleteAssociatedConditionalForwarder)
        }
        if let trustId = self.trustId {
            try encodeContainer.encode(trustId, forKey: .trustId)
        }
    }
}

extension DeleteTrustInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Deletes the local side of an existing trust relationship between the Managed Microsoft AD directory and the external domain.
public struct DeleteTrustInput: Swift.Equatable {
    /// Delete a conditional forwarder as part of a DeleteTrustRequest.
    public var deleteAssociatedConditionalForwarder: Swift.Bool?
    /// The Trust ID of the trust relationship to be deleted.
    /// This member is required.
    public var trustId: Swift.String?

    public init(
        deleteAssociatedConditionalForwarder: Swift.Bool? = nil,
        trustId: Swift.String? = nil
    )
    {
        self.deleteAssociatedConditionalForwarder = deleteAssociatedConditionalForwarder
        self.trustId = trustId
    }
}

struct DeleteTrustInputBody: Swift.Equatable {
    let trustId: Swift.String?
    let deleteAssociatedConditionalForwarder: Swift.Bool?
}

extension DeleteTrustInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteAssociatedConditionalForwarder = "DeleteAssociatedConditionalForwarder"
        case trustId = "TrustId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustId)
        trustId = trustIdDecoded
        let deleteAssociatedConditionalForwarderDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleteAssociatedConditionalForwarder)
        deleteAssociatedConditionalForwarder = deleteAssociatedConditionalForwarderDecoded
    }
}

extension DeleteTrustOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteTrustOutputBody = try responseDecoder.decode(responseBody: data)
            self.trustId = output.trustId
        } else {
            self.trustId = nil
        }
    }
}

/// The result of a DeleteTrust request.
public struct DeleteTrustOutput: Swift.Equatable {
    /// The Trust ID of the trust relationship that was deleted.
    public var trustId: Swift.String?

    public init(
        trustId: Swift.String? = nil
    )
    {
        self.trustId = trustId
    }
}

struct DeleteTrustOutputBody: Swift.Equatable {
    let trustId: Swift.String?
}

extension DeleteTrustOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustId = "TrustId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustId)
        trustId = trustIdDecoded
    }
}

enum DeleteTrustOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeregisterCertificateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateId = "CertificateId"
        case directoryId = "DirectoryId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateId = self.certificateId {
            try encodeContainer.encode(certificateId, forKey: .certificateId)
        }
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
    }
}

extension DeregisterCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeregisterCertificateInput: Swift.Equatable {
    /// The identifier of the certificate.
    /// This member is required.
    public var certificateId: Swift.String?
    /// The identifier of the directory.
    /// This member is required.
    public var directoryId: Swift.String?

    public init(
        certificateId: Swift.String? = nil,
        directoryId: Swift.String? = nil
    )
    {
        self.certificateId = certificateId
        self.directoryId = directoryId
    }
}

struct DeregisterCertificateInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let certificateId: Swift.String?
}

extension DeregisterCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateId = "CertificateId"
        case directoryId = "DirectoryId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let certificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
    }
}

extension DeregisterCertificateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeregisterCertificateOutput: Swift.Equatable {

    public init() { }
}

enum DeregisterCertificateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CertificateDoesNotExistException": return try await CertificateDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CertificateInUseException": return try await CertificateInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryDoesNotExistException": return try await DirectoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryUnavailableException": return try await DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeregisterEventTopicInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case topicName = "TopicName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let topicName = self.topicName {
            try encodeContainer.encode(topicName, forKey: .topicName)
        }
    }
}

extension DeregisterEventTopicInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Removes the specified directory as a publisher to the specified Amazon SNS topic.
public struct DeregisterEventTopicInput: Swift.Equatable {
    /// The Directory ID to remove as a publisher. This directory will no longer send messages to the specified Amazon SNS topic.
    /// This member is required.
    public var directoryId: Swift.String?
    /// The name of the Amazon SNS topic from which to remove the directory as a publisher.
    /// This member is required.
    public var topicName: Swift.String?

    public init(
        directoryId: Swift.String? = nil,
        topicName: Swift.String? = nil
    )
    {
        self.directoryId = directoryId
        self.topicName = topicName
    }
}

struct DeregisterEventTopicInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let topicName: Swift.String?
}

extension DeregisterEventTopicInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case topicName = "TopicName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let topicNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicName)
        topicName = topicNameDecoded
    }
}

extension DeregisterEventTopicOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// The result of a DeregisterEventTopic request.
public struct DeregisterEventTopicOutput: Swift.Equatable {

    public init() { }
}

enum DeregisterEventTopicOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeCertificateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateId = "CertificateId"
        case directoryId = "DirectoryId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateId = self.certificateId {
            try encodeContainer.encode(certificateId, forKey: .certificateId)
        }
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
    }
}

extension DescribeCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeCertificateInput: Swift.Equatable {
    /// The identifier of the certificate.
    /// This member is required.
    public var certificateId: Swift.String?
    /// The identifier of the directory.
    /// This member is required.
    public var directoryId: Swift.String?

    public init(
        certificateId: Swift.String? = nil,
        directoryId: Swift.String? = nil
    )
    {
        self.certificateId = certificateId
        self.directoryId = directoryId
    }
}

struct DescribeCertificateInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let certificateId: Swift.String?
}

extension DescribeCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateId = "CertificateId"
        case directoryId = "DirectoryId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let certificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
    }
}

extension DescribeCertificateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeCertificateOutputBody = try responseDecoder.decode(responseBody: data)
            self.certificate = output.certificate
        } else {
            self.certificate = nil
        }
    }
}

public struct DescribeCertificateOutput: Swift.Equatable {
    /// Information about the certificate, including registered date time, certificate state, the reason for the state, expiration date time, and certificate common name.
    public var certificate: DirectoryClientTypes.Certificate?

    public init(
        certificate: DirectoryClientTypes.Certificate? = nil
    )
    {
        self.certificate = certificate
    }
}

struct DescribeCertificateOutputBody: Swift.Equatable {
    let certificate: DirectoryClientTypes.Certificate?
}

extension DescribeCertificateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.Certificate.self, forKey: .certificate)
        certificate = certificateDecoded
    }
}

enum DescribeCertificateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CertificateDoesNotExistException": return try await CertificateDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryDoesNotExistException": return try await DirectoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeClientAuthenticationSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case limit = "Limit"
        case nextToken = "NextToken"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension DescribeClientAuthenticationSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeClientAuthenticationSettingsInput: Swift.Equatable {
    /// The identifier of the directory for which to retrieve information.
    /// This member is required.
    public var directoryId: Swift.String?
    /// The maximum number of items to return. If this value is zero, the maximum number of items is specified by the limitations of the operation.
    public var limit: Swift.Int?
    /// The DescribeClientAuthenticationSettingsResult.NextToken value from a previous call to [DescribeClientAuthenticationSettings]. Pass null if this is the first call.
    public var nextToken: Swift.String?
    /// The type of client authentication for which to retrieve information. If no type is specified, a list of all client authentication types that are supported for the specified directory is retrieved.
    public var type: DirectoryClientTypes.ClientAuthenticationType?

    public init(
        directoryId: Swift.String? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        type: DirectoryClientTypes.ClientAuthenticationType? = nil
    )
    {
        self.directoryId = directoryId
        self.limit = limit
        self.nextToken = nextToken
        self.type = type
    }
}

struct DescribeClientAuthenticationSettingsInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let type: DirectoryClientTypes.ClientAuthenticationType?
    let nextToken: Swift.String?
    let limit: Swift.Int?
}

extension DescribeClientAuthenticationSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case limit = "Limit"
        case nextToken = "NextToken"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.ClientAuthenticationType.self, forKey: .type)
        type = typeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension DescribeClientAuthenticationSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeClientAuthenticationSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.clientAuthenticationSettingsInfo = output.clientAuthenticationSettingsInfo
            self.nextToken = output.nextToken
        } else {
            self.clientAuthenticationSettingsInfo = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeClientAuthenticationSettingsOutput: Swift.Equatable {
    /// Information about the type of client authentication for the specified directory. The following information is retrieved: The date and time when the status of the client authentication type was last updated, whether the client authentication type is enabled or disabled, and the type of client authentication.
    public var clientAuthenticationSettingsInfo: [DirectoryClientTypes.ClientAuthenticationSettingInfo]?
    /// The next token used to retrieve the client authentication settings if the number of setting types exceeds page limit and there is another page.
    public var nextToken: Swift.String?

    public init(
        clientAuthenticationSettingsInfo: [DirectoryClientTypes.ClientAuthenticationSettingInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clientAuthenticationSettingsInfo = clientAuthenticationSettingsInfo
        self.nextToken = nextToken
    }
}

struct DescribeClientAuthenticationSettingsOutputBody: Swift.Equatable {
    let clientAuthenticationSettingsInfo: [DirectoryClientTypes.ClientAuthenticationSettingInfo]?
    let nextToken: Swift.String?
}

extension DescribeClientAuthenticationSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientAuthenticationSettingsInfo = "ClientAuthenticationSettingsInfo"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientAuthenticationSettingsInfoContainer = try containerValues.decodeIfPresent([DirectoryClientTypes.ClientAuthenticationSettingInfo?].self, forKey: .clientAuthenticationSettingsInfo)
        var clientAuthenticationSettingsInfoDecoded0:[DirectoryClientTypes.ClientAuthenticationSettingInfo]? = nil
        if let clientAuthenticationSettingsInfoContainer = clientAuthenticationSettingsInfoContainer {
            clientAuthenticationSettingsInfoDecoded0 = [DirectoryClientTypes.ClientAuthenticationSettingInfo]()
            for structure0 in clientAuthenticationSettingsInfoContainer {
                if let structure0 = structure0 {
                    clientAuthenticationSettingsInfoDecoded0?.append(structure0)
                }
            }
        }
        clientAuthenticationSettingsInfo = clientAuthenticationSettingsInfoDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeClientAuthenticationSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryDoesNotExistException": return try await DirectoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeConditionalForwardersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case remoteDomainNames = "RemoteDomainNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let remoteDomainNames = remoteDomainNames {
            var remoteDomainNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .remoteDomainNames)
            for remotedomainname0 in remoteDomainNames {
                try remoteDomainNamesContainer.encode(remotedomainname0)
            }
        }
    }
}

extension DescribeConditionalForwardersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Describes a conditional forwarder.
public struct DescribeConditionalForwardersInput: Swift.Equatable {
    /// The directory ID for which to get the list of associated conditional forwarders.
    /// This member is required.
    public var directoryId: Swift.String?
    /// The fully qualified domain names (FQDN) of the remote domains for which to get the list of associated conditional forwarders. If this member is null, all conditional forwarders are returned.
    public var remoteDomainNames: [Swift.String]?

    public init(
        directoryId: Swift.String? = nil,
        remoteDomainNames: [Swift.String]? = nil
    )
    {
        self.directoryId = directoryId
        self.remoteDomainNames = remoteDomainNames
    }
}

struct DescribeConditionalForwardersInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let remoteDomainNames: [Swift.String]?
}

extension DescribeConditionalForwardersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case remoteDomainNames = "RemoteDomainNames"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let remoteDomainNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .remoteDomainNames)
        var remoteDomainNamesDecoded0:[Swift.String]? = nil
        if let remoteDomainNamesContainer = remoteDomainNamesContainer {
            remoteDomainNamesDecoded0 = [Swift.String]()
            for string0 in remoteDomainNamesContainer {
                if let string0 = string0 {
                    remoteDomainNamesDecoded0?.append(string0)
                }
            }
        }
        remoteDomainNames = remoteDomainNamesDecoded0
    }
}

extension DescribeConditionalForwardersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeConditionalForwardersOutputBody = try responseDecoder.decode(responseBody: data)
            self.conditionalForwarders = output.conditionalForwarders
        } else {
            self.conditionalForwarders = nil
        }
    }
}

/// The result of a DescribeConditionalForwarder request.
public struct DescribeConditionalForwardersOutput: Swift.Equatable {
    /// The list of conditional forwarders that have been created.
    public var conditionalForwarders: [DirectoryClientTypes.ConditionalForwarder]?

    public init(
        conditionalForwarders: [DirectoryClientTypes.ConditionalForwarder]? = nil
    )
    {
        self.conditionalForwarders = conditionalForwarders
    }
}

struct DescribeConditionalForwardersOutputBody: Swift.Equatable {
    let conditionalForwarders: [DirectoryClientTypes.ConditionalForwarder]?
}

extension DescribeConditionalForwardersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conditionalForwarders = "ConditionalForwarders"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conditionalForwardersContainer = try containerValues.decodeIfPresent([DirectoryClientTypes.ConditionalForwarder?].self, forKey: .conditionalForwarders)
        var conditionalForwardersDecoded0:[DirectoryClientTypes.ConditionalForwarder]? = nil
        if let conditionalForwardersContainer = conditionalForwardersContainer {
            conditionalForwardersDecoded0 = [DirectoryClientTypes.ConditionalForwarder]()
            for structure0 in conditionalForwardersContainer {
                if let structure0 = structure0 {
                    conditionalForwardersDecoded0?.append(structure0)
                }
            }
        }
        conditionalForwarders = conditionalForwardersDecoded0
    }
}

enum DescribeConditionalForwardersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryUnavailableException": return try await DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeDirectoriesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryIds = "DirectoryIds"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryIds = directoryIds {
            var directoryIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .directoryIds)
            for directoryid0 in directoryIds {
                try directoryIdsContainer.encode(directoryid0)
            }
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeDirectoriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the inputs for the [DescribeDirectories] operation.
public struct DescribeDirectoriesInput: Swift.Equatable {
    /// A list of identifiers of the directories for which to obtain the information. If this member is null, all directories that belong to the current account are returned. An empty list results in an InvalidParameterException being thrown.
    public var directoryIds: [Swift.String]?
    /// The maximum number of items to return. If this value is zero, the maximum number of items is specified by the limitations of the operation.
    public var limit: Swift.Int?
    /// The DescribeDirectoriesResult.NextToken value from a previous call to [DescribeDirectories]. Pass null if this is the first call.
    public var nextToken: Swift.String?

    public init(
        directoryIds: [Swift.String]? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.directoryIds = directoryIds
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct DescribeDirectoriesInputBody: Swift.Equatable {
    let directoryIds: [Swift.String]?
    let nextToken: Swift.String?
    let limit: Swift.Int?
}

extension DescribeDirectoriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryIds = "DirectoryIds"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .directoryIds)
        var directoryIdsDecoded0:[Swift.String]? = nil
        if let directoryIdsContainer = directoryIdsContainer {
            directoryIdsDecoded0 = [Swift.String]()
            for string0 in directoryIdsContainer {
                if let string0 = string0 {
                    directoryIdsDecoded0?.append(string0)
                }
            }
        }
        directoryIds = directoryIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension DescribeDirectoriesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeDirectoriesOutputBody = try responseDecoder.decode(responseBody: data)
            self.directoryDescriptions = output.directoryDescriptions
            self.nextToken = output.nextToken
        } else {
            self.directoryDescriptions = nil
            self.nextToken = nil
        }
    }
}

/// Contains the results of the [DescribeDirectories] operation.
public struct DescribeDirectoriesOutput: Swift.Equatable {
    /// The list of [DirectoryDescription] objects that were retrieved. It is possible that this list contains less than the number of items specified in the Limit member of the request. This occurs if there are less than the requested number of items left to retrieve, or if the limitations of the operation have been exceeded.
    public var directoryDescriptions: [DirectoryClientTypes.DirectoryDescription]?
    /// If not null, more results are available. Pass this value for the NextToken parameter in a subsequent call to [DescribeDirectories] to retrieve the next set of items.
    public var nextToken: Swift.String?

    public init(
        directoryDescriptions: [DirectoryClientTypes.DirectoryDescription]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.directoryDescriptions = directoryDescriptions
        self.nextToken = nextToken
    }
}

struct DescribeDirectoriesOutputBody: Swift.Equatable {
    let directoryDescriptions: [DirectoryClientTypes.DirectoryDescription]?
    let nextToken: Swift.String?
}

extension DescribeDirectoriesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryDescriptions = "DirectoryDescriptions"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryDescriptionsContainer = try containerValues.decodeIfPresent([DirectoryClientTypes.DirectoryDescription?].self, forKey: .directoryDescriptions)
        var directoryDescriptionsDecoded0:[DirectoryClientTypes.DirectoryDescription]? = nil
        if let directoryDescriptionsContainer = directoryDescriptionsContainer {
            directoryDescriptionsDecoded0 = [DirectoryClientTypes.DirectoryDescription]()
            for structure0 in directoryDescriptionsContainer {
                if let structure0 = structure0 {
                    directoryDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        directoryDescriptions = directoryDescriptionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeDirectoriesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeDomainControllersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case domainControllerIds = "DomainControllerIds"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let domainControllerIds = domainControllerIds {
            var domainControllerIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domainControllerIds)
            for domaincontrollerid0 in domainControllerIds {
                try domainControllerIdsContainer.encode(domaincontrollerid0)
            }
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeDomainControllersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDomainControllersInput: Swift.Equatable {
    /// Identifier of the directory for which to retrieve the domain controller information.
    /// This member is required.
    public var directoryId: Swift.String?
    /// A list of identifiers for the domain controllers whose information will be provided.
    public var domainControllerIds: [Swift.String]?
    /// The maximum number of items to return.
    public var limit: Swift.Int?
    /// The DescribeDomainControllers.NextToken value from a previous call to [DescribeDomainControllers]. Pass null if this is the first call.
    public var nextToken: Swift.String?

    public init(
        directoryId: Swift.String? = nil,
        domainControllerIds: [Swift.String]? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.directoryId = directoryId
        self.domainControllerIds = domainControllerIds
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct DescribeDomainControllersInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let domainControllerIds: [Swift.String]?
    let nextToken: Swift.String?
    let limit: Swift.Int?
}

extension DescribeDomainControllersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case domainControllerIds = "DomainControllerIds"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let domainControllerIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .domainControllerIds)
        var domainControllerIdsDecoded0:[Swift.String]? = nil
        if let domainControllerIdsContainer = domainControllerIdsContainer {
            domainControllerIdsDecoded0 = [Swift.String]()
            for string0 in domainControllerIdsContainer {
                if let string0 = string0 {
                    domainControllerIdsDecoded0?.append(string0)
                }
            }
        }
        domainControllerIds = domainControllerIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension DescribeDomainControllersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeDomainControllersOutputBody = try responseDecoder.decode(responseBody: data)
            self.domainControllers = output.domainControllers
            self.nextToken = output.nextToken
        } else {
            self.domainControllers = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeDomainControllersOutput: Swift.Equatable {
    /// List of the [DomainController] objects that were retrieved.
    public var domainControllers: [DirectoryClientTypes.DomainController]?
    /// If not null, more results are available. Pass this value for the NextToken parameter in a subsequent call to [DescribeDomainControllers] retrieve the next set of items.
    public var nextToken: Swift.String?

    public init(
        domainControllers: [DirectoryClientTypes.DomainController]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainControllers = domainControllers
        self.nextToken = nextToken
    }
}

struct DescribeDomainControllersOutputBody: Swift.Equatable {
    let domainControllers: [DirectoryClientTypes.DomainController]?
    let nextToken: Swift.String?
}

extension DescribeDomainControllersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainControllers = "DomainControllers"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainControllersContainer = try containerValues.decodeIfPresent([DirectoryClientTypes.DomainController?].self, forKey: .domainControllers)
        var domainControllersDecoded0:[DirectoryClientTypes.DomainController]? = nil
        if let domainControllersContainer = domainControllersContainer {
            domainControllersDecoded0 = [DirectoryClientTypes.DomainController]()
            for structure0 in domainControllersContainer {
                if let structure0 = structure0 {
                    domainControllersDecoded0?.append(structure0)
                }
            }
        }
        domainControllers = domainControllersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeDomainControllersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeEventTopicsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case topicNames = "TopicNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let topicNames = topicNames {
            var topicNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .topicNames)
            for topicname0 in topicNames {
                try topicNamesContainer.encode(topicname0)
            }
        }
    }
}

extension DescribeEventTopicsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Describes event topics.
public struct DescribeEventTopicsInput: Swift.Equatable {
    /// The Directory ID for which to get the list of associated Amazon SNS topics. If this member is null, associations for all Directory IDs are returned.
    public var directoryId: Swift.String?
    /// A list of Amazon SNS topic names for which to obtain the information. If this member is null, all associations for the specified Directory ID are returned. An empty list results in an InvalidParameterException being thrown.
    public var topicNames: [Swift.String]?

    public init(
        directoryId: Swift.String? = nil,
        topicNames: [Swift.String]? = nil
    )
    {
        self.directoryId = directoryId
        self.topicNames = topicNames
    }
}

struct DescribeEventTopicsInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let topicNames: [Swift.String]?
}

extension DescribeEventTopicsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case topicNames = "TopicNames"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let topicNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .topicNames)
        var topicNamesDecoded0:[Swift.String]? = nil
        if let topicNamesContainer = topicNamesContainer {
            topicNamesDecoded0 = [Swift.String]()
            for string0 in topicNamesContainer {
                if let string0 = string0 {
                    topicNamesDecoded0?.append(string0)
                }
            }
        }
        topicNames = topicNamesDecoded0
    }
}

extension DescribeEventTopicsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeEventTopicsOutputBody = try responseDecoder.decode(responseBody: data)
            self.eventTopics = output.eventTopics
        } else {
            self.eventTopics = nil
        }
    }
}

/// The result of a DescribeEventTopic request.
public struct DescribeEventTopicsOutput: Swift.Equatable {
    /// A list of Amazon SNS topic names that receive status messages from the specified Directory ID.
    public var eventTopics: [DirectoryClientTypes.EventTopic]?

    public init(
        eventTopics: [DirectoryClientTypes.EventTopic]? = nil
    )
    {
        self.eventTopics = eventTopics
    }
}

struct DescribeEventTopicsOutputBody: Swift.Equatable {
    let eventTopics: [DirectoryClientTypes.EventTopic]?
}

extension DescribeEventTopicsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTopics = "EventTopics"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTopicsContainer = try containerValues.decodeIfPresent([DirectoryClientTypes.EventTopic?].self, forKey: .eventTopics)
        var eventTopicsDecoded0:[DirectoryClientTypes.EventTopic]? = nil
        if let eventTopicsContainer = eventTopicsContainer {
            eventTopicsDecoded0 = [DirectoryClientTypes.EventTopic]()
            for structure0 in eventTopicsContainer {
                if let structure0 = structure0 {
                    eventTopicsDecoded0?.append(structure0)
                }
            }
        }
        eventTopics = eventTopicsDecoded0
    }
}

enum DescribeEventTopicsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeLDAPSSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case limit = "Limit"
        case nextToken = "NextToken"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension DescribeLDAPSSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeLDAPSSettingsInput: Swift.Equatable {
    /// The identifier of the directory.
    /// This member is required.
    public var directoryId: Swift.String?
    /// Specifies the number of items that should be displayed on one page.
    public var limit: Swift.Int?
    /// The type of next token used for pagination.
    public var nextToken: Swift.String?
    /// The type of LDAP security to enable. Currently only the value Client is supported.
    public var type: DirectoryClientTypes.LDAPSType?

    public init(
        directoryId: Swift.String? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        type: DirectoryClientTypes.LDAPSType? = nil
    )
    {
        self.directoryId = directoryId
        self.limit = limit
        self.nextToken = nextToken
        self.type = type
    }
}

struct DescribeLDAPSSettingsInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let type: DirectoryClientTypes.LDAPSType?
    let nextToken: Swift.String?
    let limit: Swift.Int?
}

extension DescribeLDAPSSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case limit = "Limit"
        case nextToken = "NextToken"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.LDAPSType.self, forKey: .type)
        type = typeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension DescribeLDAPSSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeLDAPSSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.ldapsSettingsInfo = output.ldapsSettingsInfo
            self.nextToken = output.nextToken
        } else {
            self.ldapsSettingsInfo = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeLDAPSSettingsOutput: Swift.Equatable {
    /// Information about LDAP security for the specified directory, including status of enablement, state last updated date time, and the reason for the state.
    public var ldapsSettingsInfo: [DirectoryClientTypes.LDAPSSettingInfo]?
    /// The next token used to retrieve the LDAPS settings if the number of setting types exceeds page limit and there is another page.
    public var nextToken: Swift.String?

    public init(
        ldapsSettingsInfo: [DirectoryClientTypes.LDAPSSettingInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.ldapsSettingsInfo = ldapsSettingsInfo
        self.nextToken = nextToken
    }
}

struct DescribeLDAPSSettingsOutputBody: Swift.Equatable {
    let ldapsSettingsInfo: [DirectoryClientTypes.LDAPSSettingInfo]?
    let nextToken: Swift.String?
}

extension DescribeLDAPSSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ldapsSettingsInfo = "LDAPSSettingsInfo"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ldapsSettingsInfoContainer = try containerValues.decodeIfPresent([DirectoryClientTypes.LDAPSSettingInfo?].self, forKey: .ldapsSettingsInfo)
        var ldapsSettingsInfoDecoded0:[DirectoryClientTypes.LDAPSSettingInfo]? = nil
        if let ldapsSettingsInfoContainer = ldapsSettingsInfoContainer {
            ldapsSettingsInfoDecoded0 = [DirectoryClientTypes.LDAPSSettingInfo]()
            for structure0 in ldapsSettingsInfoContainer {
                if let structure0 = structure0 {
                    ldapsSettingsInfoDecoded0?.append(structure0)
                }
            }
        }
        ldapsSettingsInfo = ldapsSettingsInfoDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeLDAPSSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryDoesNotExistException": return try await DirectoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeRegionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case nextToken = "NextToken"
        case regionName = "RegionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let regionName = self.regionName {
            try encodeContainer.encode(regionName, forKey: .regionName)
        }
    }
}

extension DescribeRegionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeRegionsInput: Swift.Equatable {
    /// The identifier of the directory.
    /// This member is required.
    public var directoryId: Swift.String?
    /// The DescribeRegionsResult.NextToken value from a previous call to [DescribeRegions]. Pass null if this is the first call.
    public var nextToken: Swift.String?
    /// The name of the Region. For example, us-east-1.
    public var regionName: Swift.String?

    public init(
        directoryId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        regionName: Swift.String? = nil
    )
    {
        self.directoryId = directoryId
        self.nextToken = nextToken
        self.regionName = regionName
    }
}

struct DescribeRegionsInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let regionName: Swift.String?
    let nextToken: Swift.String?
}

extension DescribeRegionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case nextToken = "NextToken"
        case regionName = "RegionName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let regionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionName)
        regionName = regionNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeRegionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeRegionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.regionsDescription = output.regionsDescription
        } else {
            self.nextToken = nil
            self.regionsDescription = nil
        }
    }
}

public struct DescribeRegionsOutput: Swift.Equatable {
    /// If not null, more results are available. Pass this value for the NextToken parameter in a subsequent call to [DescribeRegions] to retrieve the next set of items.
    public var nextToken: Swift.String?
    /// List of Region information related to the directory for each replicated Region.
    public var regionsDescription: [DirectoryClientTypes.RegionDescription]?

    public init(
        nextToken: Swift.String? = nil,
        regionsDescription: [DirectoryClientTypes.RegionDescription]? = nil
    )
    {
        self.nextToken = nextToken
        self.regionsDescription = regionsDescription
    }
}

struct DescribeRegionsOutputBody: Swift.Equatable {
    let regionsDescription: [DirectoryClientTypes.RegionDescription]?
    let nextToken: Swift.String?
}

extension DescribeRegionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case regionsDescription = "RegionsDescription"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionsDescriptionContainer = try containerValues.decodeIfPresent([DirectoryClientTypes.RegionDescription?].self, forKey: .regionsDescription)
        var regionsDescriptionDecoded0:[DirectoryClientTypes.RegionDescription]? = nil
        if let regionsDescriptionContainer = regionsDescriptionContainer {
            regionsDescriptionDecoded0 = [DirectoryClientTypes.RegionDescription]()
            for structure0 in regionsDescriptionContainer {
                if let structure0 = structure0 {
                    regionsDescriptionDecoded0?.append(structure0)
                }
            }
        }
        regionsDescription = regionsDescriptionDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeRegionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryDoesNotExistException": return try await DirectoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case nextToken = "NextToken"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension DescribeSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeSettingsInput: Swift.Equatable {
    /// The identifier of the directory for which to retrieve information.
    /// This member is required.
    public var directoryId: Swift.String?
    /// The DescribeSettingsResult.NextToken value from a previous call to [DescribeSettings]. Pass null if this is the first call.
    public var nextToken: Swift.String?
    /// The status of the directory settings for which to retrieve information.
    public var status: DirectoryClientTypes.DirectoryConfigurationStatus?

    public init(
        directoryId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        status: DirectoryClientTypes.DirectoryConfigurationStatus? = nil
    )
    {
        self.directoryId = directoryId
        self.nextToken = nextToken
        self.status = status
    }
}

struct DescribeSettingsInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let status: DirectoryClientTypes.DirectoryConfigurationStatus?
    let nextToken: Swift.String?
}

extension DescribeSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case nextToken = "NextToken"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.DirectoryConfigurationStatus.self, forKey: .status)
        status = statusDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.directoryId = output.directoryId
            self.nextToken = output.nextToken
            self.settingEntries = output.settingEntries
        } else {
            self.directoryId = nil
            self.nextToken = nil
            self.settingEntries = nil
        }
    }
}

public struct DescribeSettingsOutput: Swift.Equatable {
    /// The identifier of the directory.
    public var directoryId: Swift.String?
    /// If not null, token that indicates that more results are available. Pass this value for the NextToken parameter in a subsequent call to DescribeSettings to retrieve the next set of items.
    public var nextToken: Swift.String?
    /// The list of [SettingEntry] objects that were retrieved. It is possible that this list contains less than the number of items specified in the Limit member of the request. This occurs if there are less than the requested number of items left to retrieve, or if the limitations of the operation have been exceeded.
    public var settingEntries: [DirectoryClientTypes.SettingEntry]?

    public init(
        directoryId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        settingEntries: [DirectoryClientTypes.SettingEntry]? = nil
    )
    {
        self.directoryId = directoryId
        self.nextToken = nextToken
        self.settingEntries = settingEntries
    }
}

struct DescribeSettingsOutputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let settingEntries: [DirectoryClientTypes.SettingEntry]?
    let nextToken: Swift.String?
}

extension DescribeSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case nextToken = "NextToken"
        case settingEntries = "SettingEntries"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let settingEntriesContainer = try containerValues.decodeIfPresent([DirectoryClientTypes.SettingEntry?].self, forKey: .settingEntries)
        var settingEntriesDecoded0:[DirectoryClientTypes.SettingEntry]? = nil
        if let settingEntriesContainer = settingEntriesContainer {
            settingEntriesDecoded0 = [DirectoryClientTypes.SettingEntry]()
            for structure0 in settingEntriesContainer {
                if let structure0 = structure0 {
                    settingEntriesDecoded0?.append(structure0)
                }
            }
        }
        settingEntries = settingEntriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryDoesNotExistException": return try await DirectoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeSharedDirectoriesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
        case ownerDirectoryId = "OwnerDirectoryId"
        case sharedDirectoryIds = "SharedDirectoryIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let ownerDirectoryId = self.ownerDirectoryId {
            try encodeContainer.encode(ownerDirectoryId, forKey: .ownerDirectoryId)
        }
        if let sharedDirectoryIds = sharedDirectoryIds {
            var sharedDirectoryIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sharedDirectoryIds)
            for directoryid0 in sharedDirectoryIds {
                try sharedDirectoryIdsContainer.encode(directoryid0)
            }
        }
    }
}

extension DescribeSharedDirectoriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeSharedDirectoriesInput: Swift.Equatable {
    /// The number of shared directories to return in the response object.
    public var limit: Swift.Int?
    /// The DescribeSharedDirectoriesResult.NextToken value from a previous call to [DescribeSharedDirectories]. Pass null if this is the first call.
    public var nextToken: Swift.String?
    /// Returns the identifier of the directory in the directory owner account.
    /// This member is required.
    public var ownerDirectoryId: Swift.String?
    /// A list of identifiers of all shared directories in your account.
    public var sharedDirectoryIds: [Swift.String]?

    public init(
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        ownerDirectoryId: Swift.String? = nil,
        sharedDirectoryIds: [Swift.String]? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.ownerDirectoryId = ownerDirectoryId
        self.sharedDirectoryIds = sharedDirectoryIds
    }
}

struct DescribeSharedDirectoriesInputBody: Swift.Equatable {
    let ownerDirectoryId: Swift.String?
    let sharedDirectoryIds: [Swift.String]?
    let nextToken: Swift.String?
    let limit: Swift.Int?
}

extension DescribeSharedDirectoriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
        case ownerDirectoryId = "OwnerDirectoryId"
        case sharedDirectoryIds = "SharedDirectoryIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerDirectoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerDirectoryId)
        ownerDirectoryId = ownerDirectoryIdDecoded
        let sharedDirectoryIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sharedDirectoryIds)
        var sharedDirectoryIdsDecoded0:[Swift.String]? = nil
        if let sharedDirectoryIdsContainer = sharedDirectoryIdsContainer {
            sharedDirectoryIdsDecoded0 = [Swift.String]()
            for string0 in sharedDirectoryIdsContainer {
                if let string0 = string0 {
                    sharedDirectoryIdsDecoded0?.append(string0)
                }
            }
        }
        sharedDirectoryIds = sharedDirectoryIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension DescribeSharedDirectoriesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeSharedDirectoriesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sharedDirectories = output.sharedDirectories
        } else {
            self.nextToken = nil
            self.sharedDirectories = nil
        }
    }
}

public struct DescribeSharedDirectoriesOutput: Swift.Equatable {
    /// If not null, token that indicates that more results are available. Pass this value for the NextToken parameter in a subsequent call to [DescribeSharedDirectories] to retrieve the next set of items.
    public var nextToken: Swift.String?
    /// A list of all shared directories in your account.
    public var sharedDirectories: [DirectoryClientTypes.SharedDirectory]?

    public init(
        nextToken: Swift.String? = nil,
        sharedDirectories: [DirectoryClientTypes.SharedDirectory]? = nil
    )
    {
        self.nextToken = nextToken
        self.sharedDirectories = sharedDirectories
    }
}

struct DescribeSharedDirectoriesOutputBody: Swift.Equatable {
    let sharedDirectories: [DirectoryClientTypes.SharedDirectory]?
    let nextToken: Swift.String?
}

extension DescribeSharedDirectoriesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case sharedDirectories = "SharedDirectories"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sharedDirectoriesContainer = try containerValues.decodeIfPresent([DirectoryClientTypes.SharedDirectory?].self, forKey: .sharedDirectories)
        var sharedDirectoriesDecoded0:[DirectoryClientTypes.SharedDirectory]? = nil
        if let sharedDirectoriesContainer = sharedDirectoriesContainer {
            sharedDirectoriesDecoded0 = [DirectoryClientTypes.SharedDirectory]()
            for structure0 in sharedDirectoriesContainer {
                if let structure0 = structure0 {
                    sharedDirectoriesDecoded0?.append(structure0)
                }
            }
        }
        sharedDirectories = sharedDirectoriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeSharedDirectoriesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeSnapshotsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case limit = "Limit"
        case nextToken = "NextToken"
        case snapshotIds = "SnapshotIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let snapshotIds = snapshotIds {
            var snapshotIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .snapshotIds)
            for snapshotid0 in snapshotIds {
                try snapshotIdsContainer.encode(snapshotid0)
            }
        }
    }
}

extension DescribeSnapshotsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the inputs for the [DescribeSnapshots] operation.
public struct DescribeSnapshotsInput: Swift.Equatable {
    /// The identifier of the directory for which to retrieve snapshot information.
    public var directoryId: Swift.String?
    /// The maximum number of objects to return.
    public var limit: Swift.Int?
    /// The DescribeSnapshotsResult.NextToken value from a previous call to [DescribeSnapshots]. Pass null if this is the first call.
    public var nextToken: Swift.String?
    /// A list of identifiers of the snapshots to obtain the information for. If this member is null or empty, all snapshots are returned using the Limit and NextToken members.
    public var snapshotIds: [Swift.String]?

    public init(
        directoryId: Swift.String? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        snapshotIds: [Swift.String]? = nil
    )
    {
        self.directoryId = directoryId
        self.limit = limit
        self.nextToken = nextToken
        self.snapshotIds = snapshotIds
    }
}

struct DescribeSnapshotsInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let snapshotIds: [Swift.String]?
    let nextToken: Swift.String?
    let limit: Swift.Int?
}

extension DescribeSnapshotsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case limit = "Limit"
        case nextToken = "NextToken"
        case snapshotIds = "SnapshotIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let snapshotIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .snapshotIds)
        var snapshotIdsDecoded0:[Swift.String]? = nil
        if let snapshotIdsContainer = snapshotIdsContainer {
            snapshotIdsDecoded0 = [Swift.String]()
            for string0 in snapshotIdsContainer {
                if let string0 = string0 {
                    snapshotIdsDecoded0?.append(string0)
                }
            }
        }
        snapshotIds = snapshotIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension DescribeSnapshotsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeSnapshotsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.snapshots = output.snapshots
        } else {
            self.nextToken = nil
            self.snapshots = nil
        }
    }
}

/// Contains the results of the [DescribeSnapshots] operation.
public struct DescribeSnapshotsOutput: Swift.Equatable {
    /// If not null, more results are available. Pass this value in the NextToken member of a subsequent call to [DescribeSnapshots].
    public var nextToken: Swift.String?
    /// The list of [Snapshot] objects that were retrieved. It is possible that this list contains less than the number of items specified in the Limit member of the request. This occurs if there are less than the requested number of items left to retrieve, or if the limitations of the operation have been exceeded.
    public var snapshots: [DirectoryClientTypes.Snapshot]?

    public init(
        nextToken: Swift.String? = nil,
        snapshots: [DirectoryClientTypes.Snapshot]? = nil
    )
    {
        self.nextToken = nextToken
        self.snapshots = snapshots
    }
}

struct DescribeSnapshotsOutputBody: Swift.Equatable {
    let snapshots: [DirectoryClientTypes.Snapshot]?
    let nextToken: Swift.String?
}

extension DescribeSnapshotsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case snapshots = "Snapshots"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotsContainer = try containerValues.decodeIfPresent([DirectoryClientTypes.Snapshot?].self, forKey: .snapshots)
        var snapshotsDecoded0:[DirectoryClientTypes.Snapshot]? = nil
        if let snapshotsContainer = snapshotsContainer {
            snapshotsDecoded0 = [DirectoryClientTypes.Snapshot]()
            for structure0 in snapshotsContainer {
                if let structure0 = structure0 {
                    snapshotsDecoded0?.append(structure0)
                }
            }
        }
        snapshots = snapshotsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeSnapshotsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeTrustsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case limit = "Limit"
        case nextToken = "NextToken"
        case trustIds = "TrustIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let trustIds = trustIds {
            var trustIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .trustIds)
            for trustid0 in trustIds {
                try trustIdsContainer.encode(trustid0)
            }
        }
    }
}

extension DescribeTrustsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Describes the trust relationships for a particular Managed Microsoft AD directory. If no input parameters are provided, such as directory ID or trust ID, this request describes all the trust relationships.
public struct DescribeTrustsInput: Swift.Equatable {
    /// The Directory ID of the Amazon Web Services directory that is a part of the requested trust relationship.
    public var directoryId: Swift.String?
    /// The maximum number of objects to return.
    public var limit: Swift.Int?
    /// The DescribeTrustsResult.NextToken value from a previous call to [DescribeTrusts]. Pass null if this is the first call.
    public var nextToken: Swift.String?
    /// A list of identifiers of the trust relationships for which to obtain the information. If this member is null, all trust relationships that belong to the current account are returned. An empty list results in an InvalidParameterException being thrown.
    public var trustIds: [Swift.String]?

    public init(
        directoryId: Swift.String? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        trustIds: [Swift.String]? = nil
    )
    {
        self.directoryId = directoryId
        self.limit = limit
        self.nextToken = nextToken
        self.trustIds = trustIds
    }
}

struct DescribeTrustsInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let trustIds: [Swift.String]?
    let nextToken: Swift.String?
    let limit: Swift.Int?
}

extension DescribeTrustsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case limit = "Limit"
        case nextToken = "NextToken"
        case trustIds = "TrustIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let trustIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .trustIds)
        var trustIdsDecoded0:[Swift.String]? = nil
        if let trustIdsContainer = trustIdsContainer {
            trustIdsDecoded0 = [Swift.String]()
            for string0 in trustIdsContainer {
                if let string0 = string0 {
                    trustIdsDecoded0?.append(string0)
                }
            }
        }
        trustIds = trustIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension DescribeTrustsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeTrustsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.trusts = output.trusts
        } else {
            self.nextToken = nil
            self.trusts = nil
        }
    }
}

/// The result of a DescribeTrust request.
public struct DescribeTrustsOutput: Swift.Equatable {
    /// If not null, more results are available. Pass this value for the NextToken parameter in a subsequent call to [DescribeTrusts] to retrieve the next set of items.
    public var nextToken: Swift.String?
    /// The list of Trust objects that were retrieved. It is possible that this list contains less than the number of items specified in the Limit member of the request. This occurs if there are less than the requested number of items left to retrieve, or if the limitations of the operation have been exceeded.
    public var trusts: [DirectoryClientTypes.Trust]?

    public init(
        nextToken: Swift.String? = nil,
        trusts: [DirectoryClientTypes.Trust]? = nil
    )
    {
        self.nextToken = nextToken
        self.trusts = trusts
    }
}

struct DescribeTrustsOutputBody: Swift.Equatable {
    let trusts: [DirectoryClientTypes.Trust]?
    let nextToken: Swift.String?
}

extension DescribeTrustsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case trusts = "Trusts"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustsContainer = try containerValues.decodeIfPresent([DirectoryClientTypes.Trust?].self, forKey: .trusts)
        var trustsDecoded0:[DirectoryClientTypes.Trust]? = nil
        if let trustsContainer = trustsContainer {
            trustsDecoded0 = [DirectoryClientTypes.Trust]()
            for structure0 in trustsContainer {
                if let structure0 = structure0 {
                    trustsDecoded0?.append(structure0)
                }
            }
        }
        trusts = trustsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeTrustsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeUpdateDirectoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case nextToken = "NextToken"
        case regionName = "RegionName"
        case updateType = "UpdateType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let regionName = self.regionName {
            try encodeContainer.encode(regionName, forKey: .regionName)
        }
        if let updateType = self.updateType {
            try encodeContainer.encode(updateType.rawValue, forKey: .updateType)
        }
    }
}

extension DescribeUpdateDirectoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeUpdateDirectoryInput: Swift.Equatable {
    /// The unique identifier of the directory.
    /// This member is required.
    public var directoryId: Swift.String?
    /// The DescribeUpdateDirectoryResult. NextToken value from a previous call to [DescribeUpdateDirectory]. Pass null if this is the first call.
    public var nextToken: Swift.String?
    /// The name of the Region.
    public var regionName: Swift.String?
    /// The type of updates you want to describe for the directory.
    /// This member is required.
    public var updateType: DirectoryClientTypes.UpdateType?

    public init(
        directoryId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        regionName: Swift.String? = nil,
        updateType: DirectoryClientTypes.UpdateType? = nil
    )
    {
        self.directoryId = directoryId
        self.nextToken = nextToken
        self.regionName = regionName
        self.updateType = updateType
    }
}

struct DescribeUpdateDirectoryInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let updateType: DirectoryClientTypes.UpdateType?
    let regionName: Swift.String?
    let nextToken: Swift.String?
}

extension DescribeUpdateDirectoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case nextToken = "NextToken"
        case regionName = "RegionName"
        case updateType = "UpdateType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let updateTypeDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.UpdateType.self, forKey: .updateType)
        updateType = updateTypeDecoded
        let regionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionName)
        regionName = regionNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeUpdateDirectoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeUpdateDirectoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.updateActivities = output.updateActivities
        } else {
            self.nextToken = nil
            self.updateActivities = nil
        }
    }
}

public struct DescribeUpdateDirectoryOutput: Swift.Equatable {
    /// If not null, more results are available. Pass this value for the NextToken parameter.
    public var nextToken: Swift.String?
    /// The list of update activities on a directory for the requested update type.
    public var updateActivities: [DirectoryClientTypes.UpdateInfoEntry]?

    public init(
        nextToken: Swift.String? = nil,
        updateActivities: [DirectoryClientTypes.UpdateInfoEntry]? = nil
    )
    {
        self.nextToken = nextToken
        self.updateActivities = updateActivities
    }
}

struct DescribeUpdateDirectoryOutputBody: Swift.Equatable {
    let updateActivities: [DirectoryClientTypes.UpdateInfoEntry]?
    let nextToken: Swift.String?
}

extension DescribeUpdateDirectoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case updateActivities = "UpdateActivities"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateActivitiesContainer = try containerValues.decodeIfPresent([DirectoryClientTypes.UpdateInfoEntry?].self, forKey: .updateActivities)
        var updateActivitiesDecoded0:[DirectoryClientTypes.UpdateInfoEntry]? = nil
        if let updateActivitiesContainer = updateActivitiesContainer {
            updateActivitiesDecoded0 = [DirectoryClientTypes.UpdateInfoEntry]()
            for structure0 in updateActivitiesContainer {
                if let structure0 = structure0 {
                    updateActivitiesDecoded0?.append(structure0)
                }
            }
        }
        updateActivities = updateActivitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeUpdateDirectoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryDoesNotExistException": return try await DirectoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DirectoryAlreadyInRegionException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DirectoryAlreadyInRegionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The Region you specified is the same Region where the Managed Microsoft AD directory was created. Specify a different Region and try again.
public struct DirectoryAlreadyInRegionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The descriptive message for the exception.
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request identifier.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DirectoryAlreadyInRegionException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct DirectoryAlreadyInRegionExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension DirectoryAlreadyInRegionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DirectoryAlreadySharedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DirectoryAlreadySharedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified directory has already been shared with this Amazon Web Services account.
public struct DirectoryAlreadySharedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The descriptive message for the exception.
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request identifier.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DirectoryAlreadySharedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct DirectoryAlreadySharedExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension DirectoryAlreadySharedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DirectoryClientTypes {
    public enum DirectoryConfigurationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `default`
        case failed
        case requested
        case updated
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [DirectoryConfigurationStatus] {
            return [
                .default,
                .failed,
                .requested,
                .updated,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .default: return "Default"
            case .failed: return "Failed"
            case .requested: return "Requested"
            case .updated: return "Updated"
            case .updating: return "Updating"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DirectoryConfigurationStatus(rawValue: rawValue) ?? DirectoryConfigurationStatus.sdkUnknown(rawValue)
        }
    }
}

extension DirectoryClientTypes.DirectoryConnectSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerDnsIps = "CustomerDnsIps"
        case customerUserName = "CustomerUserName"
        case subnetIds = "SubnetIds"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerDnsIps = customerDnsIps {
            var customerDnsIpsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customerDnsIps)
            for ipaddr0 in customerDnsIps {
                try customerDnsIpsContainer.encode(ipaddr0)
            }
        }
        if let customerUserName = self.customerUserName {
            try encodeContainer.encode(customerUserName, forKey: .customerUserName)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let customerDnsIpsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .customerDnsIps)
        var customerDnsIpsDecoded0:[Swift.String]? = nil
        if let customerDnsIpsContainer = customerDnsIpsContainer {
            customerDnsIpsDecoded0 = [Swift.String]()
            for string0 in customerDnsIpsContainer {
                if let string0 = string0 {
                    customerDnsIpsDecoded0?.append(string0)
                }
            }
        }
        customerDnsIps = customerDnsIpsDecoded0
        let customerUserNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerUserName)
        customerUserName = customerUserNameDecoded
    }
}

extension DirectoryClientTypes {
    /// Contains information for the [ConnectDirectory] operation when an AD Connector directory is being created.
    public struct DirectoryConnectSettings: Swift.Equatable {
        /// A list of one or more IP addresses of DNS servers or domain controllers in your self-managed directory.
        /// This member is required.
        public var customerDnsIps: [Swift.String]?
        /// The user name of an account in your self-managed directory that is used to connect to the directory. This account must have the following permissions:
        ///
        /// * Read users and groups
        ///
        /// * Create computer objects
        ///
        /// * Join computers to the domain
        /// This member is required.
        public var customerUserName: Swift.String?
        /// A list of subnet identifiers in the VPC in which the AD Connector is created.
        /// This member is required.
        public var subnetIds: [Swift.String]?
        /// The identifier of the VPC in which the AD Connector is created.
        /// This member is required.
        public var vpcId: Swift.String?

        public init(
            customerDnsIps: [Swift.String]? = nil,
            customerUserName: Swift.String? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.customerDnsIps = customerDnsIps
            self.customerUserName = customerUserName
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }

}

extension DirectoryClientTypes.DirectoryConnectSettingsDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case connectIps = "ConnectIps"
        case customerUserName = "CustomerUserName"
        case securityGroupId = "SecurityGroupId"
        case subnetIds = "SubnetIds"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for availabilityzone0 in availabilityZones {
                try availabilityZonesContainer.encode(availabilityzone0)
            }
        }
        if let connectIps = connectIps {
            var connectIpsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .connectIps)
            for ipaddr0 in connectIps {
                try connectIpsContainer.encode(ipaddr0)
            }
        }
        if let customerUserName = self.customerUserName {
            try encodeContainer.encode(customerUserName, forKey: .customerUserName)
        }
        if let securityGroupId = self.securityGroupId {
            try encodeContainer.encode(securityGroupId, forKey: .securityGroupId)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let customerUserNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerUserName)
        customerUserName = customerUserNameDecoded
        let securityGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityGroupId)
        securityGroupId = securityGroupIdDecoded
        let availabilityZonesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[Swift.String]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [Swift.String]()
            for string0 in availabilityZonesContainer {
                if let string0 = string0 {
                    availabilityZonesDecoded0?.append(string0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let connectIpsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .connectIps)
        var connectIpsDecoded0:[Swift.String]? = nil
        if let connectIpsContainer = connectIpsContainer {
            connectIpsDecoded0 = [Swift.String]()
            for string0 in connectIpsContainer {
                if let string0 = string0 {
                    connectIpsDecoded0?.append(string0)
                }
            }
        }
        connectIps = connectIpsDecoded0
    }
}

extension DirectoryClientTypes {
    /// Contains information about an AD Connector directory.
    public struct DirectoryConnectSettingsDescription: Swift.Equatable {
        /// A list of the Availability Zones that the directory is in.
        public var availabilityZones: [Swift.String]?
        /// The IP addresses of the AD Connector servers.
        public var connectIps: [Swift.String]?
        /// The user name of the service account in your self-managed directory.
        public var customerUserName: Swift.String?
        /// The security group identifier for the AD Connector directory.
        public var securityGroupId: Swift.String?
        /// A list of subnet identifiers in the VPC that the AD Connector is in.
        public var subnetIds: [Swift.String]?
        /// The identifier of the VPC that the AD Connector is in.
        public var vpcId: Swift.String?

        public init(
            availabilityZones: [Swift.String]? = nil,
            connectIps: [Swift.String]? = nil,
            customerUserName: Swift.String? = nil,
            securityGroupId: Swift.String? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.availabilityZones = availabilityZones
            self.connectIps = connectIps
            self.customerUserName = customerUserName
            self.securityGroupId = securityGroupId
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }

}

extension DirectoryClientTypes.DirectoryDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessUrl = "AccessUrl"
        case alias = "Alias"
        case connectSettings = "ConnectSettings"
        case description = "Description"
        case desiredNumberOfDomainControllers = "DesiredNumberOfDomainControllers"
        case directoryId = "DirectoryId"
        case dnsIpAddrs = "DnsIpAddrs"
        case edition = "Edition"
        case launchTime = "LaunchTime"
        case name = "Name"
        case osVersion = "OsVersion"
        case ownerDirectoryDescription = "OwnerDirectoryDescription"
        case radiusSettings = "RadiusSettings"
        case radiusStatus = "RadiusStatus"
        case regionsInfo = "RegionsInfo"
        case shareMethod = "ShareMethod"
        case shareNotes = "ShareNotes"
        case shareStatus = "ShareStatus"
        case shortName = "ShortName"
        case size = "Size"
        case ssoEnabled = "SsoEnabled"
        case stage = "Stage"
        case stageLastUpdatedDateTime = "StageLastUpdatedDateTime"
        case stageReason = "StageReason"
        case type = "Type"
        case vpcSettings = "VpcSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessUrl = self.accessUrl {
            try encodeContainer.encode(accessUrl, forKey: .accessUrl)
        }
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let connectSettings = self.connectSettings {
            try encodeContainer.encode(connectSettings, forKey: .connectSettings)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if desiredNumberOfDomainControllers != 0 {
            try encodeContainer.encode(desiredNumberOfDomainControllers, forKey: .desiredNumberOfDomainControllers)
        }
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let dnsIpAddrs = dnsIpAddrs {
            var dnsIpAddrsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dnsIpAddrs)
            for ipaddr0 in dnsIpAddrs {
                try dnsIpAddrsContainer.encode(ipaddr0)
            }
        }
        if let edition = self.edition {
            try encodeContainer.encode(edition.rawValue, forKey: .edition)
        }
        if let launchTime = self.launchTime {
            try encodeContainer.encodeTimestamp(launchTime, format: .epochSeconds, forKey: .launchTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let osVersion = self.osVersion {
            try encodeContainer.encode(osVersion.rawValue, forKey: .osVersion)
        }
        if let ownerDirectoryDescription = self.ownerDirectoryDescription {
            try encodeContainer.encode(ownerDirectoryDescription, forKey: .ownerDirectoryDescription)
        }
        if let radiusSettings = self.radiusSettings {
            try encodeContainer.encode(radiusSettings, forKey: .radiusSettings)
        }
        if let radiusStatus = self.radiusStatus {
            try encodeContainer.encode(radiusStatus.rawValue, forKey: .radiusStatus)
        }
        if let regionsInfo = self.regionsInfo {
            try encodeContainer.encode(regionsInfo, forKey: .regionsInfo)
        }
        if let shareMethod = self.shareMethod {
            try encodeContainer.encode(shareMethod.rawValue, forKey: .shareMethod)
        }
        if let shareNotes = self.shareNotes {
            try encodeContainer.encode(shareNotes, forKey: .shareNotes)
        }
        if let shareStatus = self.shareStatus {
            try encodeContainer.encode(shareStatus.rawValue, forKey: .shareStatus)
        }
        if let shortName = self.shortName {
            try encodeContainer.encode(shortName, forKey: .shortName)
        }
        if let size = self.size {
            try encodeContainer.encode(size.rawValue, forKey: .size)
        }
        if ssoEnabled != false {
            try encodeContainer.encode(ssoEnabled, forKey: .ssoEnabled)
        }
        if let stage = self.stage {
            try encodeContainer.encode(stage.rawValue, forKey: .stage)
        }
        if let stageLastUpdatedDateTime = self.stageLastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(stageLastUpdatedDateTime, format: .epochSeconds, forKey: .stageLastUpdatedDateTime)
        }
        if let stageReason = self.stageReason {
            try encodeContainer.encode(stageReason, forKey: .stageReason)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let vpcSettings = self.vpcSettings {
            try encodeContainer.encode(vpcSettings, forKey: .vpcSettings)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let shortNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shortName)
        shortName = shortNameDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.DirectorySize.self, forKey: .size)
        size = sizeDecoded
        let editionDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.DirectoryEdition.self, forKey: .edition)
        edition = editionDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let accessUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessUrl)
        accessUrl = accessUrlDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dnsIpAddrsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dnsIpAddrs)
        var dnsIpAddrsDecoded0:[Swift.String]? = nil
        if let dnsIpAddrsContainer = dnsIpAddrsContainer {
            dnsIpAddrsDecoded0 = [Swift.String]()
            for string0 in dnsIpAddrsContainer {
                if let string0 = string0 {
                    dnsIpAddrsDecoded0?.append(string0)
                }
            }
        }
        dnsIpAddrs = dnsIpAddrsDecoded0
        let stageDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.DirectoryStage.self, forKey: .stage)
        stage = stageDecoded
        let shareStatusDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.ShareStatus.self, forKey: .shareStatus)
        shareStatus = shareStatusDecoded
        let shareMethodDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.ShareMethod.self, forKey: .shareMethod)
        shareMethod = shareMethodDecoded
        let shareNotesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareNotes)
        shareNotes = shareNotesDecoded
        let launchTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .launchTime)
        launchTime = launchTimeDecoded
        let stageLastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .stageLastUpdatedDateTime)
        stageLastUpdatedDateTime = stageLastUpdatedDateTimeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.DirectoryType.self, forKey: .type)
        type = typeDecoded
        let vpcSettingsDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.DirectoryVpcSettingsDescription.self, forKey: .vpcSettings)
        vpcSettings = vpcSettingsDecoded
        let connectSettingsDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.DirectoryConnectSettingsDescription.self, forKey: .connectSettings)
        connectSettings = connectSettingsDecoded
        let radiusSettingsDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.RadiusSettings.self, forKey: .radiusSettings)
        radiusSettings = radiusSettingsDecoded
        let radiusStatusDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.RadiusStatus.self, forKey: .radiusStatus)
        radiusStatus = radiusStatusDecoded
        let stageReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageReason)
        stageReason = stageReasonDecoded
        let ssoEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ssoEnabled) ?? false
        ssoEnabled = ssoEnabledDecoded
        let desiredNumberOfDomainControllersDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .desiredNumberOfDomainControllers) ?? 0
        desiredNumberOfDomainControllers = desiredNumberOfDomainControllersDecoded
        let ownerDirectoryDescriptionDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.OwnerDirectoryDescription.self, forKey: .ownerDirectoryDescription)
        ownerDirectoryDescription = ownerDirectoryDescriptionDecoded
        let regionsInfoDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.RegionsInfo.self, forKey: .regionsInfo)
        regionsInfo = regionsInfoDecoded
        let osVersionDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.OSVersion.self, forKey: .osVersion)
        osVersion = osVersionDecoded
    }
}

extension DirectoryClientTypes.DirectoryDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DirectoryDescription(accessUrl: \(Swift.String(describing: accessUrl)), alias: \(Swift.String(describing: alias)), connectSettings: \(Swift.String(describing: connectSettings)), description: \(Swift.String(describing: description)), desiredNumberOfDomainControllers: \(Swift.String(describing: desiredNumberOfDomainControllers)), directoryId: \(Swift.String(describing: directoryId)), dnsIpAddrs: \(Swift.String(describing: dnsIpAddrs)), edition: \(Swift.String(describing: edition)), launchTime: \(Swift.String(describing: launchTime)), name: \(Swift.String(describing: name)), osVersion: \(Swift.String(describing: osVersion)), ownerDirectoryDescription: \(Swift.String(describing: ownerDirectoryDescription)), radiusSettings: \(Swift.String(describing: radiusSettings)), radiusStatus: \(Swift.String(describing: radiusStatus)), regionsInfo: \(Swift.String(describing: regionsInfo)), shareMethod: \(Swift.String(describing: shareMethod)), shareStatus: \(Swift.String(describing: shareStatus)), shortName: \(Swift.String(describing: shortName)), size: \(Swift.String(describing: size)), ssoEnabled: \(Swift.String(describing: ssoEnabled)), stage: \(Swift.String(describing: stage)), stageLastUpdatedDateTime: \(Swift.String(describing: stageLastUpdatedDateTime)), stageReason: \(Swift.String(describing: stageReason)), type: \(Swift.String(describing: type)), vpcSettings: \(Swift.String(describing: vpcSettings)), shareNotes: \"CONTENT_REDACTED\")"}
}

extension DirectoryClientTypes {
    /// Contains information about an Directory Service directory.
    public struct DirectoryDescription: Swift.Equatable {
        /// The access URL for the directory, such as http://.awsapps.com. If no alias has been created for the directory,  is the directory identifier, such as d-XXXXXXXXXX.
        public var accessUrl: Swift.String?
        /// The alias for the directory. If no alias has been created for the directory, the alias is the directory identifier, such as d-XXXXXXXXXX.
        public var alias: Swift.String?
        /// A [DirectoryConnectSettingsDescription] object that contains additional information about an AD Connector directory. This member is only present if the directory is an AD Connector directory.
        public var connectSettings: DirectoryClientTypes.DirectoryConnectSettingsDescription?
        /// The description for the directory.
        public var description: Swift.String?
        /// The desired number of domain controllers in the directory if the directory is Microsoft AD.
        public var desiredNumberOfDomainControllers: Swift.Int
        /// The directory identifier.
        public var directoryId: Swift.String?
        /// The IP addresses of the DNS servers for the directory. For a Simple AD or Microsoft AD directory, these are the IP addresses of the Simple AD or Microsoft AD directory servers. For an AD Connector directory, these are the IP addresses of the DNS servers or domain controllers in your self-managed directory to which the AD Connector is connected.
        public var dnsIpAddrs: [Swift.String]?
        /// The edition associated with this directory.
        public var edition: DirectoryClientTypes.DirectoryEdition?
        /// Specifies when the directory was created.
        public var launchTime: ClientRuntime.Date?
        /// The fully qualified name of the directory.
        public var name: Swift.String?
        /// The operating system (OS) version of the directory.
        public var osVersion: DirectoryClientTypes.OSVersion?
        /// Describes the Managed Microsoft AD directory in the directory owner account.
        public var ownerDirectoryDescription: DirectoryClientTypes.OwnerDirectoryDescription?
        /// A [RadiusSettings] object that contains information about the RADIUS server configured for this directory.
        public var radiusSettings: DirectoryClientTypes.RadiusSettings?
        /// The status of the RADIUS MFA server connection.
        public var radiusStatus: DirectoryClientTypes.RadiusStatus?
        /// Lists the Regions where the directory has replicated.
        public var regionsInfo: DirectoryClientTypes.RegionsInfo?
        /// The method used when sharing a directory to determine whether the directory should be shared within your Amazon Web Services organization (ORGANIZATIONS) or with any Amazon Web Services account by sending a shared directory request (HANDSHAKE).
        public var shareMethod: DirectoryClientTypes.ShareMethod?
        /// A directory share request that is sent by the directory owner to the directory consumer. The request includes a typed message to help the directory consumer administrator determine whether to approve or reject the share invitation.
        public var shareNotes: Swift.String?
        /// Current directory status of the shared Managed Microsoft AD directory.
        public var shareStatus: DirectoryClientTypes.ShareStatus?
        /// The short name of the directory.
        public var shortName: Swift.String?
        /// The directory size.
        public var size: DirectoryClientTypes.DirectorySize?
        /// Indicates if single sign-on is enabled for the directory. For more information, see [EnableSso] and [DisableSso].
        public var ssoEnabled: Swift.Bool
        /// The current stage of the directory.
        public var stage: DirectoryClientTypes.DirectoryStage?
        /// The date and time that the stage was last updated.
        public var stageLastUpdatedDateTime: ClientRuntime.Date?
        /// Additional information about the directory stage.
        public var stageReason: Swift.String?
        /// The directory size.
        public var type: DirectoryClientTypes.DirectoryType?
        /// A [DirectoryVpcSettingsDescription] object that contains additional information about a directory. This member is only present if the directory is a Simple AD or Managed Microsoft AD directory.
        public var vpcSettings: DirectoryClientTypes.DirectoryVpcSettingsDescription?

        public init(
            accessUrl: Swift.String? = nil,
            alias: Swift.String? = nil,
            connectSettings: DirectoryClientTypes.DirectoryConnectSettingsDescription? = nil,
            description: Swift.String? = nil,
            desiredNumberOfDomainControllers: Swift.Int = 0,
            directoryId: Swift.String? = nil,
            dnsIpAddrs: [Swift.String]? = nil,
            edition: DirectoryClientTypes.DirectoryEdition? = nil,
            launchTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            osVersion: DirectoryClientTypes.OSVersion? = nil,
            ownerDirectoryDescription: DirectoryClientTypes.OwnerDirectoryDescription? = nil,
            radiusSettings: DirectoryClientTypes.RadiusSettings? = nil,
            radiusStatus: DirectoryClientTypes.RadiusStatus? = nil,
            regionsInfo: DirectoryClientTypes.RegionsInfo? = nil,
            shareMethod: DirectoryClientTypes.ShareMethod? = nil,
            shareNotes: Swift.String? = nil,
            shareStatus: DirectoryClientTypes.ShareStatus? = nil,
            shortName: Swift.String? = nil,
            size: DirectoryClientTypes.DirectorySize? = nil,
            ssoEnabled: Swift.Bool = false,
            stage: DirectoryClientTypes.DirectoryStage? = nil,
            stageLastUpdatedDateTime: ClientRuntime.Date? = nil,
            stageReason: Swift.String? = nil,
            type: DirectoryClientTypes.DirectoryType? = nil,
            vpcSettings: DirectoryClientTypes.DirectoryVpcSettingsDescription? = nil
        )
        {
            self.accessUrl = accessUrl
            self.alias = alias
            self.connectSettings = connectSettings
            self.description = description
            self.desiredNumberOfDomainControllers = desiredNumberOfDomainControllers
            self.directoryId = directoryId
            self.dnsIpAddrs = dnsIpAddrs
            self.edition = edition
            self.launchTime = launchTime
            self.name = name
            self.osVersion = osVersion
            self.ownerDirectoryDescription = ownerDirectoryDescription
            self.radiusSettings = radiusSettings
            self.radiusStatus = radiusStatus
            self.regionsInfo = regionsInfo
            self.shareMethod = shareMethod
            self.shareNotes = shareNotes
            self.shareStatus = shareStatus
            self.shortName = shortName
            self.size = size
            self.ssoEnabled = ssoEnabled
            self.stage = stage
            self.stageLastUpdatedDateTime = stageLastUpdatedDateTime
            self.stageReason = stageReason
            self.type = type
            self.vpcSettings = vpcSettings
        }
    }

}

extension DirectoryDoesNotExistException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DirectoryDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified directory does not exist in the system.
public struct DirectoryDoesNotExistException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The descriptive message for the exception.
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request identifier.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DirectoryDoesNotExistException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct DirectoryDoesNotExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension DirectoryDoesNotExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DirectoryClientTypes {
    public enum DirectoryEdition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enterprise
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [DirectoryEdition] {
            return [
                .enterprise,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enterprise: return "Enterprise"
            case .standard: return "Standard"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DirectoryEdition(rawValue: rawValue) ?? DirectoryEdition.sdkUnknown(rawValue)
        }
    }
}

extension DirectoryInDesiredStateException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DirectoryInDesiredStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The directory is already updated to desired update type settings.
public struct DirectoryInDesiredStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The descriptive message for the exception.
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request identifier.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DirectoryInDesiredStateException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct DirectoryInDesiredStateExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension DirectoryInDesiredStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DirectoryLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DirectoryLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The maximum number of directories in the region has been reached. You can use the [GetDirectoryLimits] operation to determine your directory limits in the region.
public struct DirectoryLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The descriptive message for the exception.
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request identifier.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DirectoryLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct DirectoryLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension DirectoryLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DirectoryClientTypes.DirectoryLimits: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudOnlyDirectoriesCurrentCount = "CloudOnlyDirectoriesCurrentCount"
        case cloudOnlyDirectoriesLimit = "CloudOnlyDirectoriesLimit"
        case cloudOnlyDirectoriesLimitReached = "CloudOnlyDirectoriesLimitReached"
        case cloudOnlyMicrosoftADCurrentCount = "CloudOnlyMicrosoftADCurrentCount"
        case cloudOnlyMicrosoftADLimit = "CloudOnlyMicrosoftADLimit"
        case cloudOnlyMicrosoftADLimitReached = "CloudOnlyMicrosoftADLimitReached"
        case connectedDirectoriesCurrentCount = "ConnectedDirectoriesCurrentCount"
        case connectedDirectoriesLimit = "ConnectedDirectoriesLimit"
        case connectedDirectoriesLimitReached = "ConnectedDirectoriesLimitReached"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudOnlyDirectoriesCurrentCount = self.cloudOnlyDirectoriesCurrentCount {
            try encodeContainer.encode(cloudOnlyDirectoriesCurrentCount, forKey: .cloudOnlyDirectoriesCurrentCount)
        }
        if let cloudOnlyDirectoriesLimit = self.cloudOnlyDirectoriesLimit {
            try encodeContainer.encode(cloudOnlyDirectoriesLimit, forKey: .cloudOnlyDirectoriesLimit)
        }
        if cloudOnlyDirectoriesLimitReached != false {
            try encodeContainer.encode(cloudOnlyDirectoriesLimitReached, forKey: .cloudOnlyDirectoriesLimitReached)
        }
        if let cloudOnlyMicrosoftADCurrentCount = self.cloudOnlyMicrosoftADCurrentCount {
            try encodeContainer.encode(cloudOnlyMicrosoftADCurrentCount, forKey: .cloudOnlyMicrosoftADCurrentCount)
        }
        if let cloudOnlyMicrosoftADLimit = self.cloudOnlyMicrosoftADLimit {
            try encodeContainer.encode(cloudOnlyMicrosoftADLimit, forKey: .cloudOnlyMicrosoftADLimit)
        }
        if cloudOnlyMicrosoftADLimitReached != false {
            try encodeContainer.encode(cloudOnlyMicrosoftADLimitReached, forKey: .cloudOnlyMicrosoftADLimitReached)
        }
        if let connectedDirectoriesCurrentCount = self.connectedDirectoriesCurrentCount {
            try encodeContainer.encode(connectedDirectoriesCurrentCount, forKey: .connectedDirectoriesCurrentCount)
        }
        if let connectedDirectoriesLimit = self.connectedDirectoriesLimit {
            try encodeContainer.encode(connectedDirectoriesLimit, forKey: .connectedDirectoriesLimit)
        }
        if connectedDirectoriesLimitReached != false {
            try encodeContainer.encode(connectedDirectoriesLimitReached, forKey: .connectedDirectoriesLimitReached)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudOnlyDirectoriesLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cloudOnlyDirectoriesLimit)
        cloudOnlyDirectoriesLimit = cloudOnlyDirectoriesLimitDecoded
        let cloudOnlyDirectoriesCurrentCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cloudOnlyDirectoriesCurrentCount)
        cloudOnlyDirectoriesCurrentCount = cloudOnlyDirectoriesCurrentCountDecoded
        let cloudOnlyDirectoriesLimitReachedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cloudOnlyDirectoriesLimitReached) ?? false
        cloudOnlyDirectoriesLimitReached = cloudOnlyDirectoriesLimitReachedDecoded
        let cloudOnlyMicrosoftADLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cloudOnlyMicrosoftADLimit)
        cloudOnlyMicrosoftADLimit = cloudOnlyMicrosoftADLimitDecoded
        let cloudOnlyMicrosoftADCurrentCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cloudOnlyMicrosoftADCurrentCount)
        cloudOnlyMicrosoftADCurrentCount = cloudOnlyMicrosoftADCurrentCountDecoded
        let cloudOnlyMicrosoftADLimitReachedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cloudOnlyMicrosoftADLimitReached) ?? false
        cloudOnlyMicrosoftADLimitReached = cloudOnlyMicrosoftADLimitReachedDecoded
        let connectedDirectoriesLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .connectedDirectoriesLimit)
        connectedDirectoriesLimit = connectedDirectoriesLimitDecoded
        let connectedDirectoriesCurrentCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .connectedDirectoriesCurrentCount)
        connectedDirectoriesCurrentCount = connectedDirectoriesCurrentCountDecoded
        let connectedDirectoriesLimitReachedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .connectedDirectoriesLimitReached) ?? false
        connectedDirectoriesLimitReached = connectedDirectoriesLimitReachedDecoded
    }
}

extension DirectoryClientTypes {
    /// Contains directory limit information for a Region.
    public struct DirectoryLimits: Swift.Equatable {
        /// The current number of cloud directories in the Region.
        public var cloudOnlyDirectoriesCurrentCount: Swift.Int?
        /// The maximum number of cloud directories allowed in the Region.
        public var cloudOnlyDirectoriesLimit: Swift.Int?
        /// Indicates if the cloud directory limit has been reached.
        public var cloudOnlyDirectoriesLimitReached: Swift.Bool
        /// The current number of Managed Microsoft AD directories in the region.
        public var cloudOnlyMicrosoftADCurrentCount: Swift.Int?
        /// The maximum number of Managed Microsoft AD directories allowed in the region.
        public var cloudOnlyMicrosoftADLimit: Swift.Int?
        /// Indicates if the Managed Microsoft AD directory limit has been reached.
        public var cloudOnlyMicrosoftADLimitReached: Swift.Bool
        /// The current number of connected directories in the Region.
        public var connectedDirectoriesCurrentCount: Swift.Int?
        /// The maximum number of connected directories allowed in the Region.
        public var connectedDirectoriesLimit: Swift.Int?
        /// Indicates if the connected directory limit has been reached.
        public var connectedDirectoriesLimitReached: Swift.Bool

        public init(
            cloudOnlyDirectoriesCurrentCount: Swift.Int? = nil,
            cloudOnlyDirectoriesLimit: Swift.Int? = nil,
            cloudOnlyDirectoriesLimitReached: Swift.Bool = false,
            cloudOnlyMicrosoftADCurrentCount: Swift.Int? = nil,
            cloudOnlyMicrosoftADLimit: Swift.Int? = nil,
            cloudOnlyMicrosoftADLimitReached: Swift.Bool = false,
            connectedDirectoriesCurrentCount: Swift.Int? = nil,
            connectedDirectoriesLimit: Swift.Int? = nil,
            connectedDirectoriesLimitReached: Swift.Bool = false
        )
        {
            self.cloudOnlyDirectoriesCurrentCount = cloudOnlyDirectoriesCurrentCount
            self.cloudOnlyDirectoriesLimit = cloudOnlyDirectoriesLimit
            self.cloudOnlyDirectoriesLimitReached = cloudOnlyDirectoriesLimitReached
            self.cloudOnlyMicrosoftADCurrentCount = cloudOnlyMicrosoftADCurrentCount
            self.cloudOnlyMicrosoftADLimit = cloudOnlyMicrosoftADLimit
            self.cloudOnlyMicrosoftADLimitReached = cloudOnlyMicrosoftADLimitReached
            self.connectedDirectoriesCurrentCount = connectedDirectoriesCurrentCount
            self.connectedDirectoriesLimit = connectedDirectoriesLimit
            self.connectedDirectoriesLimitReached = connectedDirectoriesLimitReached
        }
    }

}

extension DirectoryNotSharedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DirectoryNotSharedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified directory has not been shared with this Amazon Web Services account.
public struct DirectoryNotSharedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The descriptive message for the exception.
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request identifier.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DirectoryNotSharedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct DirectoryNotSharedExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension DirectoryNotSharedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DirectoryClientTypes {
    public enum DirectorySize: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case large
        case small
        case sdkUnknown(Swift.String)

        public static var allCases: [DirectorySize] {
            return [
                .large,
                .small,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .large: return "Large"
            case .small: return "Small"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DirectorySize(rawValue: rawValue) ?? DirectorySize.sdkUnknown(rawValue)
        }
    }
}

extension DirectoryClientTypes {
    public enum DirectoryStage: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case created
        case creating
        case deleted
        case deleting
        case failed
        case impaired
        case inoperable
        case requested
        case restorefailed
        case restoring
        case sdkUnknown(Swift.String)

        public static var allCases: [DirectoryStage] {
            return [
                .active,
                .created,
                .creating,
                .deleted,
                .deleting,
                .failed,
                .impaired,
                .inoperable,
                .requested,
                .restorefailed,
                .restoring,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .created: return "Created"
            case .creating: return "Creating"
            case .deleted: return "Deleted"
            case .deleting: return "Deleting"
            case .failed: return "Failed"
            case .impaired: return "Impaired"
            case .inoperable: return "Inoperable"
            case .requested: return "Requested"
            case .restorefailed: return "RestoreFailed"
            case .restoring: return "Restoring"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DirectoryStage(rawValue: rawValue) ?? DirectoryStage.sdkUnknown(rawValue)
        }
    }
}

extension DirectoryClientTypes {
    public enum DirectoryType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case adConnector
        case microsoftAd
        case sharedMicrosoftAd
        case simpleAd
        case sdkUnknown(Swift.String)

        public static var allCases: [DirectoryType] {
            return [
                .adConnector,
                .microsoftAd,
                .sharedMicrosoftAd,
                .simpleAd,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .adConnector: return "ADConnector"
            case .microsoftAd: return "MicrosoftAD"
            case .sharedMicrosoftAd: return "SharedMicrosoftAD"
            case .simpleAd: return "SimpleAD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DirectoryType(rawValue: rawValue) ?? DirectoryType.sdkUnknown(rawValue)
        }
    }
}

extension DirectoryUnavailableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DirectoryUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified directory is unavailable or could not be found.
public struct DirectoryUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The descriptive message for the exception.
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request identifier.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DirectoryUnavailableException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct DirectoryUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension DirectoryUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DirectoryClientTypes.DirectoryVpcSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subnetIds = "SubnetIds"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
    }
}

extension DirectoryClientTypes {
    /// Contains VPC information for the [CreateDirectory] or [CreateMicrosoftAD] operation.
    public struct DirectoryVpcSettings: Swift.Equatable {
        /// The identifiers of the subnets for the directory servers. The two subnets must be in different Availability Zones. Directory Service creates a directory server and a DNS server in each of these subnets.
        /// This member is required.
        public var subnetIds: [Swift.String]?
        /// The identifier of the VPC in which to create the directory.
        /// This member is required.
        public var vpcId: Swift.String?

        public init(
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }

}

extension DirectoryClientTypes.DirectoryVpcSettingsDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case securityGroupId = "SecurityGroupId"
        case subnetIds = "SubnetIds"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for availabilityzone0 in availabilityZones {
                try availabilityZonesContainer.encode(availabilityzone0)
            }
        }
        if let securityGroupId = self.securityGroupId {
            try encodeContainer.encode(securityGroupId, forKey: .securityGroupId)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityGroupId)
        securityGroupId = securityGroupIdDecoded
        let availabilityZonesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[Swift.String]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [Swift.String]()
            for string0 in availabilityZonesContainer {
                if let string0 = string0 {
                    availabilityZonesDecoded0?.append(string0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
    }
}

extension DirectoryClientTypes {
    /// Contains information about the directory.
    public struct DirectoryVpcSettingsDescription: Swift.Equatable {
        /// The list of Availability Zones that the directory is in.
        public var availabilityZones: [Swift.String]?
        /// The domain controller security group identifier for the directory.
        public var securityGroupId: Swift.String?
        /// The identifiers of the subnets for the directory servers.
        public var subnetIds: [Swift.String]?
        /// The identifier of the VPC that the directory is in.
        public var vpcId: Swift.String?

        public init(
            availabilityZones: [Swift.String]? = nil,
            securityGroupId: Swift.String? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.availabilityZones = availabilityZones
            self.securityGroupId = securityGroupId
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }

}

extension DisableClientAuthenticationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension DisableClientAuthenticationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisableClientAuthenticationInput: Swift.Equatable {
    /// The identifier of the directory
    /// This member is required.
    public var directoryId: Swift.String?
    /// The type of client authentication to disable. Currently, only the parameter, SmartCard is supported.
    /// This member is required.
    public var type: DirectoryClientTypes.ClientAuthenticationType?

    public init(
        directoryId: Swift.String? = nil,
        type: DirectoryClientTypes.ClientAuthenticationType? = nil
    )
    {
        self.directoryId = directoryId
        self.type = type
    }
}

struct DisableClientAuthenticationInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let type: DirectoryClientTypes.ClientAuthenticationType?
}

extension DisableClientAuthenticationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.ClientAuthenticationType.self, forKey: .type)
        type = typeDecoded
    }
}

extension DisableClientAuthenticationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisableClientAuthenticationOutput: Swift.Equatable {

    public init() { }
}

enum DisableClientAuthenticationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryDoesNotExistException": return try await DirectoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidClientAuthStatusException": return try await InvalidClientAuthStatusException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisableLDAPSInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension DisableLDAPSInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisableLDAPSInput: Swift.Equatable {
    /// The identifier of the directory.
    /// This member is required.
    public var directoryId: Swift.String?
    /// The type of LDAP security to enable. Currently only the value Client is supported.
    /// This member is required.
    public var type: DirectoryClientTypes.LDAPSType?

    public init(
        directoryId: Swift.String? = nil,
        type: DirectoryClientTypes.LDAPSType? = nil
    )
    {
        self.directoryId = directoryId
        self.type = type
    }
}

struct DisableLDAPSInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let type: DirectoryClientTypes.LDAPSType?
}

extension DisableLDAPSInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.LDAPSType.self, forKey: .type)
        type = typeDecoded
    }
}

extension DisableLDAPSOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisableLDAPSOutput: Swift.Equatable {

    public init() { }
}

enum DisableLDAPSOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryDoesNotExistException": return try await DirectoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryUnavailableException": return try await DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidLDAPSStatusException": return try await InvalidLDAPSStatusException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisableRadiusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
    }
}

extension DisableRadiusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the inputs for the [DisableRadius] operation.
public struct DisableRadiusInput: Swift.Equatable {
    /// The identifier of the directory for which to disable MFA.
    /// This member is required.
    public var directoryId: Swift.String?

    public init(
        directoryId: Swift.String? = nil
    )
    {
        self.directoryId = directoryId
    }
}

struct DisableRadiusInputBody: Swift.Equatable {
    let directoryId: Swift.String?
}

extension DisableRadiusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
    }
}

extension DisableRadiusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// Contains the results of the [DisableRadius] operation.
public struct DisableRadiusOutput: Swift.Equatable {

    public init() { }
}

enum DisableRadiusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisableSsoInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisableSsoInput(directoryId: \(Swift.String(describing: directoryId)), userName: \(Swift.String(describing: userName)), password: \"CONTENT_REDACTED\")"}
}

extension DisableSsoInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case password = "Password"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

extension DisableSsoInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the inputs for the [DisableSso] operation.
public struct DisableSsoInput: Swift.Equatable {
    /// The identifier of the directory for which to disable single-sign on.
    /// This member is required.
    public var directoryId: Swift.String?
    /// The password of an alternate account to use to disable single-sign on. This is only used for AD Connector directories. For more information, see the UserName parameter.
    public var password: Swift.String?
    /// The username of an alternate account to use to disable single-sign on. This is only used for AD Connector directories. This account must have privileges to remove a service principal name. If the AD Connector service account does not have privileges to remove a service principal name, you can specify an alternate account with the UserName and Password parameters. These credentials are only used to disable single sign-on and are not stored by the service. The AD Connector service account is not changed.
    public var userName: Swift.String?

    public init(
        directoryId: Swift.String? = nil,
        password: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.directoryId = directoryId
        self.password = password
        self.userName = userName
    }
}

struct DisableSsoInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let userName: Swift.String?
    let password: Swift.String?
}

extension DisableSsoInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case password = "Password"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension DisableSsoOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// Contains the results of the [DisableSso] operation.
public struct DisableSsoOutput: Swift.Equatable {

    public init() { }
}

enum DisableSsoOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AuthenticationFailedException": return try await AuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsufficientPermissionsException": return try await InsufficientPermissionsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DirectoryClientTypes.DomainController: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "AvailabilityZone"
        case directoryId = "DirectoryId"
        case dnsIpAddr = "DnsIpAddr"
        case domainControllerId = "DomainControllerId"
        case launchTime = "LaunchTime"
        case status = "Status"
        case statusLastUpdatedDateTime = "StatusLastUpdatedDateTime"
        case statusReason = "StatusReason"
        case subnetId = "SubnetId"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let dnsIpAddr = self.dnsIpAddr {
            try encodeContainer.encode(dnsIpAddr, forKey: .dnsIpAddr)
        }
        if let domainControllerId = self.domainControllerId {
            try encodeContainer.encode(domainControllerId, forKey: .domainControllerId)
        }
        if let launchTime = self.launchTime {
            try encodeContainer.encodeTimestamp(launchTime, format: .epochSeconds, forKey: .launchTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusLastUpdatedDateTime = self.statusLastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(statusLastUpdatedDateTime, format: .epochSeconds, forKey: .statusLastUpdatedDateTime)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let domainControllerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainControllerId)
        domainControllerId = domainControllerIdDecoded
        let dnsIpAddrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dnsIpAddr)
        dnsIpAddr = dnsIpAddrDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.DomainControllerStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let launchTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .launchTime)
        launchTime = launchTimeDecoded
        let statusLastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .statusLastUpdatedDateTime)
        statusLastUpdatedDateTime = statusLastUpdatedDateTimeDecoded
    }
}

extension DirectoryClientTypes {
    /// Contains information about the domain controllers for a specified directory.
    public struct DomainController: Swift.Equatable {
        /// The Availability Zone where the domain controller is located.
        public var availabilityZone: Swift.String?
        /// Identifier of the directory where the domain controller resides.
        public var directoryId: Swift.String?
        /// The IP address of the domain controller.
        public var dnsIpAddr: Swift.String?
        /// Identifies a specific domain controller in the directory.
        public var domainControllerId: Swift.String?
        /// Specifies when the domain controller was created.
        public var launchTime: ClientRuntime.Date?
        /// The status of the domain controller.
        public var status: DirectoryClientTypes.DomainControllerStatus?
        /// The date and time that the status was last updated.
        public var statusLastUpdatedDateTime: ClientRuntime.Date?
        /// A description of the domain controller state.
        public var statusReason: Swift.String?
        /// Identifier of the subnet in the VPC that contains the domain controller.
        public var subnetId: Swift.String?
        /// The identifier of the VPC that contains the domain controller.
        public var vpcId: Swift.String?

        public init(
            availabilityZone: Swift.String? = nil,
            directoryId: Swift.String? = nil,
            dnsIpAddr: Swift.String? = nil,
            domainControllerId: Swift.String? = nil,
            launchTime: ClientRuntime.Date? = nil,
            status: DirectoryClientTypes.DomainControllerStatus? = nil,
            statusLastUpdatedDateTime: ClientRuntime.Date? = nil,
            statusReason: Swift.String? = nil,
            subnetId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.directoryId = directoryId
            self.dnsIpAddr = dnsIpAddr
            self.domainControllerId = domainControllerId
            self.launchTime = launchTime
            self.status = status
            self.statusLastUpdatedDateTime = statusLastUpdatedDateTime
            self.statusReason = statusReason
            self.subnetId = subnetId
            self.vpcId = vpcId
        }
    }

}

extension DomainControllerLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DomainControllerLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The maximum allowed number of domain controllers per directory was exceeded. The default limit per directory is 20 domain controllers.
public struct DomainControllerLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The descriptive message for the exception.
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request identifier.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DomainControllerLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct DomainControllerLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension DomainControllerLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DirectoryClientTypes {
    public enum DomainControllerStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleted
        case deleting
        case failed
        case impaired
        case restoring
        case sdkUnknown(Swift.String)

        public static var allCases: [DomainControllerStatus] {
            return [
                .active,
                .creating,
                .deleted,
                .deleting,
                .failed,
                .impaired,
                .restoring,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .creating: return "Creating"
            case .deleted: return "Deleted"
            case .deleting: return "Deleting"
            case .failed: return "Failed"
            case .impaired: return "Impaired"
            case .restoring: return "Restoring"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DomainControllerStatus(rawValue: rawValue) ?? DomainControllerStatus.sdkUnknown(rawValue)
        }
    }
}

extension EnableClientAuthenticationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension EnableClientAuthenticationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct EnableClientAuthenticationInput: Swift.Equatable {
    /// The identifier of the specified directory.
    /// This member is required.
    public var directoryId: Swift.String?
    /// The type of client authentication to enable. Currently only the value SmartCard is supported. Smart card authentication in AD Connector requires that you enable Kerberos Constrained Delegation for the Service User to the LDAP service in your self-managed AD.
    /// This member is required.
    public var type: DirectoryClientTypes.ClientAuthenticationType?

    public init(
        directoryId: Swift.String? = nil,
        type: DirectoryClientTypes.ClientAuthenticationType? = nil
    )
    {
        self.directoryId = directoryId
        self.type = type
    }
}

struct EnableClientAuthenticationInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let type: DirectoryClientTypes.ClientAuthenticationType?
}

extension EnableClientAuthenticationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.ClientAuthenticationType.self, forKey: .type)
        type = typeDecoded
    }
}

extension EnableClientAuthenticationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct EnableClientAuthenticationOutput: Swift.Equatable {

    public init() { }
}

enum EnableClientAuthenticationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryDoesNotExistException": return try await DirectoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidClientAuthStatusException": return try await InvalidClientAuthStatusException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoAvailableCertificateException": return try await NoAvailableCertificateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EnableLDAPSInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension EnableLDAPSInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct EnableLDAPSInput: Swift.Equatable {
    /// The identifier of the directory.
    /// This member is required.
    public var directoryId: Swift.String?
    /// The type of LDAP security to enable. Currently only the value Client is supported.
    /// This member is required.
    public var type: DirectoryClientTypes.LDAPSType?

    public init(
        directoryId: Swift.String? = nil,
        type: DirectoryClientTypes.LDAPSType? = nil
    )
    {
        self.directoryId = directoryId
        self.type = type
    }
}

struct EnableLDAPSInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let type: DirectoryClientTypes.LDAPSType?
}

extension EnableLDAPSInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.LDAPSType.self, forKey: .type)
        type = typeDecoded
    }
}

extension EnableLDAPSOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct EnableLDAPSOutput: Swift.Equatable {

    public init() { }
}

enum EnableLDAPSOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryDoesNotExistException": return try await DirectoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryUnavailableException": return try await DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidLDAPSStatusException": return try await InvalidLDAPSStatusException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoAvailableCertificateException": return try await NoAvailableCertificateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EnableRadiusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case radiusSettings = "RadiusSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let radiusSettings = self.radiusSettings {
            try encodeContainer.encode(radiusSettings, forKey: .radiusSettings)
        }
    }
}

extension EnableRadiusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the inputs for the [EnableRadius] operation.
public struct EnableRadiusInput: Swift.Equatable {
    /// The identifier of the directory for which to enable MFA.
    /// This member is required.
    public var directoryId: Swift.String?
    /// A [RadiusSettings] object that contains information about the RADIUS server.
    /// This member is required.
    public var radiusSettings: DirectoryClientTypes.RadiusSettings?

    public init(
        directoryId: Swift.String? = nil,
        radiusSettings: DirectoryClientTypes.RadiusSettings? = nil
    )
    {
        self.directoryId = directoryId
        self.radiusSettings = radiusSettings
    }
}

struct EnableRadiusInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let radiusSettings: DirectoryClientTypes.RadiusSettings?
}

extension EnableRadiusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case radiusSettings = "RadiusSettings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let radiusSettingsDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.RadiusSettings.self, forKey: .radiusSettings)
        radiusSettings = radiusSettingsDecoded
    }
}

extension EnableRadiusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// Contains the results of the [EnableRadius] operation.
public struct EnableRadiusOutput: Swift.Equatable {

    public init() { }
}

enum EnableRadiusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityAlreadyExistsException": return try await EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EnableSsoInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnableSsoInput(directoryId: \(Swift.String(describing: directoryId)), userName: \(Swift.String(describing: userName)), password: \"CONTENT_REDACTED\")"}
}

extension EnableSsoInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case password = "Password"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

extension EnableSsoInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the inputs for the [EnableSso] operation.
public struct EnableSsoInput: Swift.Equatable {
    /// The identifier of the directory for which to enable single-sign on.
    /// This member is required.
    public var directoryId: Swift.String?
    /// The password of an alternate account to use to enable single-sign on. This is only used for AD Connector directories. For more information, see the UserName parameter.
    public var password: Swift.String?
    /// The username of an alternate account to use to enable single-sign on. This is only used for AD Connector directories. This account must have privileges to add a service principal name. If the AD Connector service account does not have privileges to add a service principal name, you can specify an alternate account with the UserName and Password parameters. These credentials are only used to enable single sign-on and are not stored by the service. The AD Connector service account is not changed.
    public var userName: Swift.String?

    public init(
        directoryId: Swift.String? = nil,
        password: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.directoryId = directoryId
        self.password = password
        self.userName = userName
    }
}

struct EnableSsoInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let userName: Swift.String?
    let password: Swift.String?
}

extension EnableSsoInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case password = "Password"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension EnableSsoOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// Contains the results of the [EnableSso] operation.
public struct EnableSsoOutput: Swift.Equatable {

    public init() { }
}

enum EnableSsoOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AuthenticationFailedException": return try await AuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsufficientPermissionsException": return try await InsufficientPermissionsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EntityAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EntityAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified entity already exists.
public struct EntityAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The descriptive message for the exception.
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request identifier.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EntityAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct EntityAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension EntityAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension EntityDoesNotExistException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EntityDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified entity could not be found.
public struct EntityDoesNotExistException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The descriptive message for the exception.
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request identifier.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EntityDoesNotExistException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct EntityDoesNotExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension EntityDoesNotExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DirectoryClientTypes.EventTopic: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDateTime = "CreatedDateTime"
        case directoryId = "DirectoryId"
        case status = "Status"
        case topicArn = "TopicArn"
        case topicName = "TopicName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDateTime = self.createdDateTime {
            try encodeContainer.encodeTimestamp(createdDateTime, format: .epochSeconds, forKey: .createdDateTime)
        }
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let topicArn = self.topicArn {
            try encodeContainer.encode(topicArn, forKey: .topicArn)
        }
        if let topicName = self.topicName {
            try encodeContainer.encode(topicName, forKey: .topicName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let topicNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicName)
        topicName = topicNameDecoded
        let topicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
        let createdDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDateTime)
        createdDateTime = createdDateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.TopicStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DirectoryClientTypes {
    /// Information about Amazon SNS topic and Directory Service directory associations.
    public struct EventTopic: Swift.Equatable {
        /// The date and time of when you associated your directory with the Amazon SNS topic.
        public var createdDateTime: ClientRuntime.Date?
        /// The Directory ID of an Directory Service directory that will publish status messages to an Amazon SNS topic.
        public var directoryId: Swift.String?
        /// The topic registration status.
        public var status: DirectoryClientTypes.TopicStatus?
        /// The Amazon SNS topic ARN (Amazon Resource Name).
        public var topicArn: Swift.String?
        /// The name of an Amazon SNS topic the receives status messages from the directory.
        public var topicName: Swift.String?

        public init(
            createdDateTime: ClientRuntime.Date? = nil,
            directoryId: Swift.String? = nil,
            status: DirectoryClientTypes.TopicStatus? = nil,
            topicArn: Swift.String? = nil,
            topicName: Swift.String? = nil
        )
        {
            self.createdDateTime = createdDateTime
            self.directoryId = directoryId
            self.status = status
            self.topicArn = topicArn
            self.topicName = topicName
        }
    }

}

extension GetDirectoryLimitsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetDirectoryLimitsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the inputs for the [GetDirectoryLimits] operation.
public struct GetDirectoryLimitsInput: Swift.Equatable {

    public init() { }
}

struct GetDirectoryLimitsInputBody: Swift.Equatable {
}

extension GetDirectoryLimitsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDirectoryLimitsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDirectoryLimitsOutputBody = try responseDecoder.decode(responseBody: data)
            self.directoryLimits = output.directoryLimits
        } else {
            self.directoryLimits = nil
        }
    }
}

/// Contains the results of the [GetDirectoryLimits] operation.
public struct GetDirectoryLimitsOutput: Swift.Equatable {
    /// A [DirectoryLimits] object that contains the directory limits for the current Region.
    public var directoryLimits: DirectoryClientTypes.DirectoryLimits?

    public init(
        directoryLimits: DirectoryClientTypes.DirectoryLimits? = nil
    )
    {
        self.directoryLimits = directoryLimits
    }
}

struct GetDirectoryLimitsOutputBody: Swift.Equatable {
    let directoryLimits: DirectoryClientTypes.DirectoryLimits?
}

extension GetDirectoryLimitsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryLimits = "DirectoryLimits"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryLimitsDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.DirectoryLimits.self, forKey: .directoryLimits)
        directoryLimits = directoryLimitsDecoded
    }
}

enum GetDirectoryLimitsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSnapshotLimitsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
    }
}

extension GetSnapshotLimitsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the inputs for the [GetSnapshotLimits] operation.
public struct GetSnapshotLimitsInput: Swift.Equatable {
    /// Contains the identifier of the directory to obtain the limits for.
    /// This member is required.
    public var directoryId: Swift.String?

    public init(
        directoryId: Swift.String? = nil
    )
    {
        self.directoryId = directoryId
    }
}

struct GetSnapshotLimitsInputBody: Swift.Equatable {
    let directoryId: Swift.String?
}

extension GetSnapshotLimitsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
    }
}

extension GetSnapshotLimitsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSnapshotLimitsOutputBody = try responseDecoder.decode(responseBody: data)
            self.snapshotLimits = output.snapshotLimits
        } else {
            self.snapshotLimits = nil
        }
    }
}

/// Contains the results of the [GetSnapshotLimits] operation.
public struct GetSnapshotLimitsOutput: Swift.Equatable {
    /// A [SnapshotLimits] object that contains the manual snapshot limits for the specified directory.
    public var snapshotLimits: DirectoryClientTypes.SnapshotLimits?

    public init(
        snapshotLimits: DirectoryClientTypes.SnapshotLimits? = nil
    )
    {
        self.snapshotLimits = snapshotLimits
    }
}

struct GetSnapshotLimitsOutputBody: Swift.Equatable {
    let snapshotLimits: DirectoryClientTypes.SnapshotLimits?
}

extension GetSnapshotLimitsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotLimits = "SnapshotLimits"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotLimitsDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.SnapshotLimits.self, forKey: .snapshotLimits)
        snapshotLimits = snapshotLimitsDecoded
    }
}

enum GetSnapshotLimitsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IncompatibleSettingsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: IncompatibleSettingsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified directory setting is not compatible with other settings.
public struct IncompatibleSettingsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The descriptive message for the exception.
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request identifier.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IncompatibleSettingsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct IncompatibleSettingsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension IncompatibleSettingsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension InsufficientPermissionsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InsufficientPermissionsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The account does not have sufficient permission to perform the operation.
public struct InsufficientPermissionsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The descriptive message for the exception.
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request identifier.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InsufficientPermissionsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct InsufficientPermissionsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension InsufficientPermissionsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension InvalidCertificateException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidCertificateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The certificate PEM that was provided has incorrect encoding.
public struct InvalidCertificateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The descriptive message for the exception.
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request identifier.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidCertificateException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct InvalidCertificateExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension InvalidCertificateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension InvalidClientAuthStatusException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidClientAuthStatusExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Client authentication is already enabled.
public struct InvalidClientAuthStatusException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The descriptive message for the exception.
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request identifier.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidClientAuthStatusException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct InvalidClientAuthStatusExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension InvalidClientAuthStatusExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension InvalidLDAPSStatusException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidLDAPSStatusExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The LDAP activities could not be performed because they are limited by the LDAPS status.
public struct InvalidLDAPSStatusException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The descriptive message for the exception.
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request identifier.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidLDAPSStatusException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct InvalidLDAPSStatusExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension InvalidLDAPSStatusExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension InvalidNextTokenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The NextToken value is not valid.
public struct InvalidNextTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The descriptive message for the exception.
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request identifier.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNextTokenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension InvalidParameterException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// One or more parameters are not valid.
public struct InvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The descriptive message for the exception.
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request identifier.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension InvalidPasswordException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidPasswordExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The new password provided by the user does not meet the password complexity requirements defined in your directory.
public struct InvalidPasswordException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The descriptive message for the exception.
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request identifier.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPasswordException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct InvalidPasswordExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension InvalidPasswordExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension InvalidTargetException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidTargetExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified shared target is not valid.
public struct InvalidTargetException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The descriptive message for the exception.
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request identifier.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTargetException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct InvalidTargetExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension InvalidTargetExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DirectoryClientTypes.IpRoute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidrIp = "CidrIp"
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidrIp = self.cidrIp {
            try encodeContainer.encode(cidrIp, forKey: .cidrIp)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cidrIp)
        cidrIp = cidrIpDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension DirectoryClientTypes {
    /// IP address block. This is often the address block of the DNS server used for your self-managed domain.
    public struct IpRoute: Swift.Equatable {
        /// IP address block using CIDR format, for example 10.0.0.0/24. This is often the address block of the DNS server used for your self-managed domain. For a single IP address use a CIDR address block with /32. For example 10.0.0.0/32.
        public var cidrIp: Swift.String?
        /// Description of the address block.
        public var description: Swift.String?

        public init(
            cidrIp: Swift.String? = nil,
            description: Swift.String? = nil
        )
        {
            self.cidrIp = cidrIp
            self.description = description
        }
    }

}

extension DirectoryClientTypes.IpRouteInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addedDateTime = "AddedDateTime"
        case cidrIp = "CidrIp"
        case description = "Description"
        case directoryId = "DirectoryId"
        case ipRouteStatusMsg = "IpRouteStatusMsg"
        case ipRouteStatusReason = "IpRouteStatusReason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addedDateTime = self.addedDateTime {
            try encodeContainer.encodeTimestamp(addedDateTime, format: .epochSeconds, forKey: .addedDateTime)
        }
        if let cidrIp = self.cidrIp {
            try encodeContainer.encode(cidrIp, forKey: .cidrIp)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let ipRouteStatusMsg = self.ipRouteStatusMsg {
            try encodeContainer.encode(ipRouteStatusMsg.rawValue, forKey: .ipRouteStatusMsg)
        }
        if let ipRouteStatusReason = self.ipRouteStatusReason {
            try encodeContainer.encode(ipRouteStatusReason, forKey: .ipRouteStatusReason)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let cidrIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cidrIp)
        cidrIp = cidrIpDecoded
        let ipRouteStatusMsgDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.IpRouteStatusMsg.self, forKey: .ipRouteStatusMsg)
        ipRouteStatusMsg = ipRouteStatusMsgDecoded
        let addedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .addedDateTime)
        addedDateTime = addedDateTimeDecoded
        let ipRouteStatusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipRouteStatusReason)
        ipRouteStatusReason = ipRouteStatusReasonDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension DirectoryClientTypes {
    /// Information about one or more IP address blocks.
    public struct IpRouteInfo: Swift.Equatable {
        /// The date and time the address block was added to the directory.
        public var addedDateTime: ClientRuntime.Date?
        /// IP address block in the [IpRoute].
        public var cidrIp: Swift.String?
        /// Description of the [IpRouteInfo].
        public var description: Swift.String?
        /// Identifier (ID) of the directory associated with the IP addresses.
        public var directoryId: Swift.String?
        /// The status of the IP address block.
        public var ipRouteStatusMsg: DirectoryClientTypes.IpRouteStatusMsg?
        /// The reason for the IpRouteStatusMsg.
        public var ipRouteStatusReason: Swift.String?

        public init(
            addedDateTime: ClientRuntime.Date? = nil,
            cidrIp: Swift.String? = nil,
            description: Swift.String? = nil,
            directoryId: Swift.String? = nil,
            ipRouteStatusMsg: DirectoryClientTypes.IpRouteStatusMsg? = nil,
            ipRouteStatusReason: Swift.String? = nil
        )
        {
            self.addedDateTime = addedDateTime
            self.cidrIp = cidrIp
            self.description = description
            self.directoryId = directoryId
            self.ipRouteStatusMsg = ipRouteStatusMsg
            self.ipRouteStatusReason = ipRouteStatusReason
        }
    }

}

extension IpRouteLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: IpRouteLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The maximum allowed number of IP addresses was exceeded. The default limit is 100 IP address blocks.
public struct IpRouteLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The descriptive message for the exception.
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request identifier.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IpRouteLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct IpRouteLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension IpRouteLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DirectoryClientTypes {
    public enum IpRouteStatusMsg: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case added
        case adding
        case addFailed
        case removed
        case removeFailed
        case removing
        case sdkUnknown(Swift.String)

        public static var allCases: [IpRouteStatusMsg] {
            return [
                .added,
                .adding,
                .addFailed,
                .removed,
                .removeFailed,
                .removing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .added: return "Added"
            case .adding: return "Adding"
            case .addFailed: return "AddFailed"
            case .removed: return "Removed"
            case .removeFailed: return "RemoveFailed"
            case .removing: return "Removing"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IpRouteStatusMsg(rawValue: rawValue) ?? IpRouteStatusMsg.sdkUnknown(rawValue)
        }
    }
}

extension DirectoryClientTypes.LDAPSSettingInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ldapsStatus = "LDAPSStatus"
        case ldapsStatusReason = "LDAPSStatusReason"
        case lastUpdatedDateTime = "LastUpdatedDateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ldapsStatus = self.ldapsStatus {
            try encodeContainer.encode(ldapsStatus.rawValue, forKey: .ldapsStatus)
        }
        if let ldapsStatusReason = self.ldapsStatusReason {
            try encodeContainer.encode(ldapsStatusReason, forKey: .ldapsStatusReason)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ldapsStatusDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.LDAPSStatus.self, forKey: .ldapsStatus)
        ldapsStatus = ldapsStatusDecoded
        let ldapsStatusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ldapsStatusReason)
        ldapsStatusReason = ldapsStatusReasonDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension DirectoryClientTypes {
    /// Contains general information about the LDAPS settings.
    public struct LDAPSSettingInfo: Swift.Equatable {
        /// The date and time when the LDAPS settings were last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The state of the LDAPS settings.
        public var ldapsStatus: DirectoryClientTypes.LDAPSStatus?
        /// Describes a state change for LDAPS.
        public var ldapsStatusReason: Swift.String?

        public init(
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            ldapsStatus: DirectoryClientTypes.LDAPSStatus? = nil,
            ldapsStatusReason: Swift.String? = nil
        )
        {
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.ldapsStatus = ldapsStatus
            self.ldapsStatusReason = ldapsStatusReason
        }
    }

}

extension DirectoryClientTypes {
    public enum LDAPSStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case enableFailed
        case enabling
        case sdkUnknown(Swift.String)

        public static var allCases: [LDAPSStatus] {
            return [
                .disabled,
                .enabled,
                .enableFailed,
                .enabling,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case .enableFailed: return "EnableFailed"
            case .enabling: return "Enabling"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LDAPSStatus(rawValue: rawValue) ?? LDAPSStatus.sdkUnknown(rawValue)
        }
    }
}

extension DirectoryClientTypes {
    public enum LDAPSType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case client
        case sdkUnknown(Swift.String)

        public static var allCases: [LDAPSType] {
            return [
                .client,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .client: return "Client"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LDAPSType(rawValue: rawValue) ?? LDAPSType.sdkUnknown(rawValue)
        }
    }
}

extension ListCertificatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListCertificatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListCertificatesInput: Swift.Equatable {
    /// The identifier of the directory.
    /// This member is required.
    public var directoryId: Swift.String?
    /// The number of items that should show up on one page
    public var limit: Swift.Int?
    /// A token for requesting another page of certificates if the NextToken response element indicates that more certificates are available. Use the value of the returned NextToken element in your request until the token comes back as null. Pass null if this is the first call.
    public var nextToken: Swift.String?

    public init(
        directoryId: Swift.String? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.directoryId = directoryId
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct ListCertificatesInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let nextToken: Swift.String?
    let limit: Swift.Int?
}

extension ListCertificatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListCertificatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCertificatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.certificatesInfo = output.certificatesInfo
            self.nextToken = output.nextToken
        } else {
            self.certificatesInfo = nil
            self.nextToken = nil
        }
    }
}

public struct ListCertificatesOutput: Swift.Equatable {
    /// A list of certificates with basic details including certificate ID, certificate common name, certificate state.
    public var certificatesInfo: [DirectoryClientTypes.CertificateInfo]?
    /// Indicates whether another page of certificates is available when the number of available certificates exceeds the page limit.
    public var nextToken: Swift.String?

    public init(
        certificatesInfo: [DirectoryClientTypes.CertificateInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.certificatesInfo = certificatesInfo
        self.nextToken = nextToken
    }
}

struct ListCertificatesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let certificatesInfo: [DirectoryClientTypes.CertificateInfo]?
}

extension ListCertificatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificatesInfo = "CertificatesInfo"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let certificatesInfoContainer = try containerValues.decodeIfPresent([DirectoryClientTypes.CertificateInfo?].self, forKey: .certificatesInfo)
        var certificatesInfoDecoded0:[DirectoryClientTypes.CertificateInfo]? = nil
        if let certificatesInfoContainer = certificatesInfoContainer {
            certificatesInfoDecoded0 = [DirectoryClientTypes.CertificateInfo]()
            for structure0 in certificatesInfoContainer {
                if let structure0 = structure0 {
                    certificatesInfoDecoded0?.append(structure0)
                }
            }
        }
        certificatesInfo = certificatesInfoDecoded0
    }
}

enum ListCertificatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryDoesNotExistException": return try await DirectoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListIpRoutesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListIpRoutesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListIpRoutesInput: Swift.Equatable {
    /// Identifier (ID) of the directory for which you want to retrieve the IP addresses.
    /// This member is required.
    public var directoryId: Swift.String?
    /// Maximum number of items to return. If this value is zero, the maximum number of items is specified by the limitations of the operation.
    public var limit: Swift.Int?
    /// The ListIpRoutes.NextToken value from a previous call to [ListIpRoutes]. Pass null if this is the first call.
    public var nextToken: Swift.String?

    public init(
        directoryId: Swift.String? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.directoryId = directoryId
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct ListIpRoutesInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let nextToken: Swift.String?
    let limit: Swift.Int?
}

extension ListIpRoutesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListIpRoutesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListIpRoutesOutputBody = try responseDecoder.decode(responseBody: data)
            self.ipRoutesInfo = output.ipRoutesInfo
            self.nextToken = output.nextToken
        } else {
            self.ipRoutesInfo = nil
            self.nextToken = nil
        }
    }
}

public struct ListIpRoutesOutput: Swift.Equatable {
    /// A list of [IpRoute]s.
    public var ipRoutesInfo: [DirectoryClientTypes.IpRouteInfo]?
    /// If not null, more results are available. Pass this value for the NextToken parameter in a subsequent call to [ListIpRoutes] to retrieve the next set of items.
    public var nextToken: Swift.String?

    public init(
        ipRoutesInfo: [DirectoryClientTypes.IpRouteInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.ipRoutesInfo = ipRoutesInfo
        self.nextToken = nextToken
    }
}

struct ListIpRoutesOutputBody: Swift.Equatable {
    let ipRoutesInfo: [DirectoryClientTypes.IpRouteInfo]?
    let nextToken: Swift.String?
}

extension ListIpRoutesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipRoutesInfo = "IpRoutesInfo"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipRoutesInfoContainer = try containerValues.decodeIfPresent([DirectoryClientTypes.IpRouteInfo?].self, forKey: .ipRoutesInfo)
        var ipRoutesInfoDecoded0:[DirectoryClientTypes.IpRouteInfo]? = nil
        if let ipRoutesInfoContainer = ipRoutesInfoContainer {
            ipRoutesInfoDecoded0 = [DirectoryClientTypes.IpRouteInfo]()
            for structure0 in ipRoutesInfoContainer {
                if let structure0 = structure0 {
                    ipRoutesInfoDecoded0?.append(structure0)
                }
            }
        }
        ipRoutesInfo = ipRoutesInfoDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListIpRoutesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListLogSubscriptionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListLogSubscriptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListLogSubscriptionsInput: Swift.Equatable {
    /// If a DirectoryID is provided, lists only the log subscription associated with that directory. If no DirectoryId is provided, lists all log subscriptions associated with your Amazon Web Services account. If there are no log subscriptions for the Amazon Web Services account or the directory, an empty list will be returned.
    public var directoryId: Swift.String?
    /// The maximum number of items returned.
    public var limit: Swift.Int?
    /// The token for the next set of items to return.
    public var nextToken: Swift.String?

    public init(
        directoryId: Swift.String? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.directoryId = directoryId
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct ListLogSubscriptionsInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let nextToken: Swift.String?
    let limit: Swift.Int?
}

extension ListLogSubscriptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListLogSubscriptionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLogSubscriptionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.logSubscriptions = output.logSubscriptions
            self.nextToken = output.nextToken
        } else {
            self.logSubscriptions = nil
            self.nextToken = nil
        }
    }
}

public struct ListLogSubscriptionsOutput: Swift.Equatable {
    /// A list of active [LogSubscription] objects for calling the Amazon Web Services account.
    public var logSubscriptions: [DirectoryClientTypes.LogSubscription]?
    /// The token for the next set of items to return.
    public var nextToken: Swift.String?

    public init(
        logSubscriptions: [DirectoryClientTypes.LogSubscription]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.logSubscriptions = logSubscriptions
        self.nextToken = nextToken
    }
}

struct ListLogSubscriptionsOutputBody: Swift.Equatable {
    let logSubscriptions: [DirectoryClientTypes.LogSubscription]?
    let nextToken: Swift.String?
}

extension ListLogSubscriptionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logSubscriptions = "LogSubscriptions"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logSubscriptionsContainer = try containerValues.decodeIfPresent([DirectoryClientTypes.LogSubscription?].self, forKey: .logSubscriptions)
        var logSubscriptionsDecoded0:[DirectoryClientTypes.LogSubscription]? = nil
        if let logSubscriptionsContainer = logSubscriptionsContainer {
            logSubscriptionsDecoded0 = [DirectoryClientTypes.LogSubscription]()
            for structure0 in logSubscriptionsContainer {
                if let structure0 = structure0 {
                    logSubscriptionsDecoded0?.append(structure0)
                }
            }
        }
        logSubscriptions = logSubscriptionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListLogSubscriptionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSchemaExtensionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSchemaExtensionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSchemaExtensionsInput: Swift.Equatable {
    /// The identifier of the directory from which to retrieve the schema extension information.
    /// This member is required.
    public var directoryId: Swift.String?
    /// The maximum number of items to return.
    public var limit: Swift.Int?
    /// The ListSchemaExtensions.NextToken value from a previous call to ListSchemaExtensions. Pass null if this is the first call.
    public var nextToken: Swift.String?

    public init(
        directoryId: Swift.String? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.directoryId = directoryId
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct ListSchemaExtensionsInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let nextToken: Swift.String?
    let limit: Swift.Int?
}

extension ListSchemaExtensionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListSchemaExtensionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSchemaExtensionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.schemaExtensionsInfo = output.schemaExtensionsInfo
        } else {
            self.nextToken = nil
            self.schemaExtensionsInfo = nil
        }
    }
}

public struct ListSchemaExtensionsOutput: Swift.Equatable {
    /// If not null, more results are available. Pass this value for the NextToken parameter in a subsequent call to ListSchemaExtensions to retrieve the next set of items.
    public var nextToken: Swift.String?
    /// Information about the schema extensions applied to the directory.
    public var schemaExtensionsInfo: [DirectoryClientTypes.SchemaExtensionInfo]?

    public init(
        nextToken: Swift.String? = nil,
        schemaExtensionsInfo: [DirectoryClientTypes.SchemaExtensionInfo]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemaExtensionsInfo = schemaExtensionsInfo
    }
}

struct ListSchemaExtensionsOutputBody: Swift.Equatable {
    let schemaExtensionsInfo: [DirectoryClientTypes.SchemaExtensionInfo]?
    let nextToken: Swift.String?
}

extension ListSchemaExtensionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case schemaExtensionsInfo = "SchemaExtensionsInfo"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaExtensionsInfoContainer = try containerValues.decodeIfPresent([DirectoryClientTypes.SchemaExtensionInfo?].self, forKey: .schemaExtensionsInfo)
        var schemaExtensionsInfoDecoded0:[DirectoryClientTypes.SchemaExtensionInfo]? = nil
        if let schemaExtensionsInfoContainer = schemaExtensionsInfoContainer {
            schemaExtensionsInfoDecoded0 = [DirectoryClientTypes.SchemaExtensionInfo]()
            for structure0 in schemaExtensionsInfoContainer {
                if let structure0 = structure0 {
                    schemaExtensionsInfoDecoded0?.append(structure0)
                }
            }
        }
        schemaExtensionsInfo = schemaExtensionsInfoDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSchemaExtensionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// Reserved for future use.
    public var limit: Swift.Int?
    /// Reserved for future use.
    public var nextToken: Swift.String?
    /// Identifier (ID) of the directory for which you want to retrieve tags.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.resourceId = resourceId
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let nextToken: Swift.String?
    let limit: Swift.Int?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
        case resourceId = "ResourceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// Reserved for future use.
    public var nextToken: Swift.String?
    /// List of tags returned by the ListTagsForResource operation.
    public var tags: [DirectoryClientTypes.Tag]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [DirectoryClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [DirectoryClientTypes.Tag]?
    let nextToken: Swift.String?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([DirectoryClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DirectoryClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DirectoryClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DirectoryClientTypes.LogSubscription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case logGroupName = "LogGroupName"
        case subscriptionCreatedDateTime = "SubscriptionCreatedDateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let logGroupName = self.logGroupName {
            try encodeContainer.encode(logGroupName, forKey: .logGroupName)
        }
        if let subscriptionCreatedDateTime = self.subscriptionCreatedDateTime {
            try encodeContainer.encodeTimestamp(subscriptionCreatedDateTime, format: .epochSeconds, forKey: .subscriptionCreatedDateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let logGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
        let subscriptionCreatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .subscriptionCreatedDateTime)
        subscriptionCreatedDateTime = subscriptionCreatedDateTimeDecoded
    }
}

extension DirectoryClientTypes {
    /// Represents a log subscription, which tracks real-time data from a chosen log group to a specified destination.
    public struct LogSubscription: Swift.Equatable {
        /// Identifier (ID) of the directory that you want to associate with the log subscription.
        public var directoryId: Swift.String?
        /// The name of the log group.
        public var logGroupName: Swift.String?
        /// The date and time that the log subscription was created.
        public var subscriptionCreatedDateTime: ClientRuntime.Date?

        public init(
            directoryId: Swift.String? = nil,
            logGroupName: Swift.String? = nil,
            subscriptionCreatedDateTime: ClientRuntime.Date? = nil
        )
        {
            self.directoryId = directoryId
            self.logGroupName = logGroupName
            self.subscriptionCreatedDateTime = subscriptionCreatedDateTime
        }
    }

}

extension NoAvailableCertificateException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NoAvailableCertificateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Client authentication setup could not be completed because at least one valid certificate must be registered in the system.
public struct NoAvailableCertificateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The descriptive message for the exception.
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request identifier.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoAvailableCertificateException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct NoAvailableCertificateExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension NoAvailableCertificateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DirectoryClientTypes.OSUpdateSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case osVersion = "OSVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let osVersion = self.osVersion {
            try encodeContainer.encode(osVersion.rawValue, forKey: .osVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let osVersionDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.OSVersion.self, forKey: .osVersion)
        osVersion = osVersionDecoded
    }
}

extension DirectoryClientTypes {
    /// OS version that the directory needs to be updated to.
    public struct OSUpdateSettings: Swift.Equatable {
        /// OS version that the directory needs to be updated to.
        public var osVersion: DirectoryClientTypes.OSVersion?

        public init(
            osVersion: DirectoryClientTypes.OSVersion? = nil
        )
        {
            self.osVersion = osVersion
        }
    }

}

extension DirectoryClientTypes {
    public enum OSVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case version2012
        case version2019
        case sdkUnknown(Swift.String)

        public static var allCases: [OSVersion] {
            return [
                .version2012,
                .version2019,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .version2012: return "SERVER_2012"
            case .version2019: return "SERVER_2019"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OSVersion(rawValue: rawValue) ?? OSVersion.sdkUnknown(rawValue)
        }
    }
}

extension OrganizationsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: OrganizationsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception encountered while trying to access your Amazon Web Services organization.
public struct OrganizationsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The descriptive message for the exception.
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request identifier.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OrganizationsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct OrganizationsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension OrganizationsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DirectoryClientTypes.OwnerDirectoryDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case directoryId = "DirectoryId"
        case dnsIpAddrs = "DnsIpAddrs"
        case radiusSettings = "RadiusSettings"
        case radiusStatus = "RadiusStatus"
        case vpcSettings = "VpcSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let dnsIpAddrs = dnsIpAddrs {
            var dnsIpAddrsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dnsIpAddrs)
            for ipaddr0 in dnsIpAddrs {
                try dnsIpAddrsContainer.encode(ipaddr0)
            }
        }
        if let radiusSettings = self.radiusSettings {
            try encodeContainer.encode(radiusSettings, forKey: .radiusSettings)
        }
        if let radiusStatus = self.radiusStatus {
            try encodeContainer.encode(radiusStatus.rawValue, forKey: .radiusStatus)
        }
        if let vpcSettings = self.vpcSettings {
            try encodeContainer.encode(vpcSettings, forKey: .vpcSettings)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let dnsIpAddrsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dnsIpAddrs)
        var dnsIpAddrsDecoded0:[Swift.String]? = nil
        if let dnsIpAddrsContainer = dnsIpAddrsContainer {
            dnsIpAddrsDecoded0 = [Swift.String]()
            for string0 in dnsIpAddrsContainer {
                if let string0 = string0 {
                    dnsIpAddrsDecoded0?.append(string0)
                }
            }
        }
        dnsIpAddrs = dnsIpAddrsDecoded0
        let vpcSettingsDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.DirectoryVpcSettingsDescription.self, forKey: .vpcSettings)
        vpcSettings = vpcSettingsDecoded
        let radiusSettingsDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.RadiusSettings.self, forKey: .radiusSettings)
        radiusSettings = radiusSettingsDecoded
        let radiusStatusDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.RadiusStatus.self, forKey: .radiusStatus)
        radiusStatus = radiusStatusDecoded
    }
}

extension DirectoryClientTypes {
    /// Describes the directory owner account details that have been shared to the directory consumer account.
    public struct OwnerDirectoryDescription: Swift.Equatable {
        /// Identifier of the directory owner account.
        public var accountId: Swift.String?
        /// Identifier of the Managed Microsoft AD directory in the directory owner account.
        public var directoryId: Swift.String?
        /// IP address of the directorys domain controllers.
        public var dnsIpAddrs: [Swift.String]?
        /// A [RadiusSettings] object that contains information about the RADIUS server.
        public var radiusSettings: DirectoryClientTypes.RadiusSettings?
        /// Information about the status of the RADIUS server.
        public var radiusStatus: DirectoryClientTypes.RadiusStatus?
        /// Information about the VPC settings for the directory.
        public var vpcSettings: DirectoryClientTypes.DirectoryVpcSettingsDescription?

        public init(
            accountId: Swift.String? = nil,
            directoryId: Swift.String? = nil,
            dnsIpAddrs: [Swift.String]? = nil,
            radiusSettings: DirectoryClientTypes.RadiusSettings? = nil,
            radiusStatus: DirectoryClientTypes.RadiusStatus? = nil,
            vpcSettings: DirectoryClientTypes.DirectoryVpcSettingsDescription? = nil
        )
        {
            self.accountId = accountId
            self.directoryId = directoryId
            self.dnsIpAddrs = dnsIpAddrs
            self.radiusSettings = radiusSettings
            self.radiusStatus = radiusStatus
            self.vpcSettings = vpcSettings
        }
    }

}

extension DirectoryClientTypes {
    public enum RadiusAuthenticationProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case chap
        case mschapv1
        case mschapv2
        case pap
        case sdkUnknown(Swift.String)

        public static var allCases: [RadiusAuthenticationProtocol] {
            return [
                .chap,
                .mschapv1,
                .mschapv2,
                .pap,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .chap: return "CHAP"
            case .mschapv1: return "MS-CHAPv1"
            case .mschapv2: return "MS-CHAPv2"
            case .pap: return "PAP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RadiusAuthenticationProtocol(rawValue: rawValue) ?? RadiusAuthenticationProtocol.sdkUnknown(rawValue)
        }
    }
}

extension DirectoryClientTypes.RadiusSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationProtocol = "AuthenticationProtocol"
        case displayLabel = "DisplayLabel"
        case radiusPort = "RadiusPort"
        case radiusRetries = "RadiusRetries"
        case radiusServers = "RadiusServers"
        case radiusTimeout = "RadiusTimeout"
        case sharedSecret = "SharedSecret"
        case useSameUsername = "UseSameUsername"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationProtocol = self.authenticationProtocol {
            try encodeContainer.encode(authenticationProtocol.rawValue, forKey: .authenticationProtocol)
        }
        if let displayLabel = self.displayLabel {
            try encodeContainer.encode(displayLabel, forKey: .displayLabel)
        }
        if radiusPort != 0 {
            try encodeContainer.encode(radiusPort, forKey: .radiusPort)
        }
        if radiusRetries != 0 {
            try encodeContainer.encode(radiusRetries, forKey: .radiusRetries)
        }
        if let radiusServers = radiusServers {
            var radiusServersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .radiusServers)
            for server0 in radiusServers {
                try radiusServersContainer.encode(server0)
            }
        }
        if radiusTimeout != 0 {
            try encodeContainer.encode(radiusTimeout, forKey: .radiusTimeout)
        }
        if let sharedSecret = self.sharedSecret {
            try encodeContainer.encode(sharedSecret, forKey: .sharedSecret)
        }
        if useSameUsername != false {
            try encodeContainer.encode(useSameUsername, forKey: .useSameUsername)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let radiusServersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .radiusServers)
        var radiusServersDecoded0:[Swift.String]? = nil
        if let radiusServersContainer = radiusServersContainer {
            radiusServersDecoded0 = [Swift.String]()
            for string0 in radiusServersContainer {
                if let string0 = string0 {
                    radiusServersDecoded0?.append(string0)
                }
            }
        }
        radiusServers = radiusServersDecoded0
        let radiusPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .radiusPort) ?? 0
        radiusPort = radiusPortDecoded
        let radiusTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .radiusTimeout) ?? 0
        radiusTimeout = radiusTimeoutDecoded
        let radiusRetriesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .radiusRetries) ?? 0
        radiusRetries = radiusRetriesDecoded
        let sharedSecretDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedSecret)
        sharedSecret = sharedSecretDecoded
        let authenticationProtocolDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.RadiusAuthenticationProtocol.self, forKey: .authenticationProtocol)
        authenticationProtocol = authenticationProtocolDecoded
        let displayLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayLabel)
        displayLabel = displayLabelDecoded
        let useSameUsernameDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useSameUsername) ?? false
        useSameUsername = useSameUsernameDecoded
    }
}

extension DirectoryClientTypes.RadiusSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RadiusSettings(authenticationProtocol: \(Swift.String(describing: authenticationProtocol)), displayLabel: \(Swift.String(describing: displayLabel)), radiusPort: \(Swift.String(describing: radiusPort)), radiusRetries: \(Swift.String(describing: radiusRetries)), radiusServers: \(Swift.String(describing: radiusServers)), radiusTimeout: \(Swift.String(describing: radiusTimeout)), useSameUsername: \(Swift.String(describing: useSameUsername)), sharedSecret: \"CONTENT_REDACTED\")"}
}

extension DirectoryClientTypes {
    /// Contains information about a Remote Authentication Dial In User Service (RADIUS) server.
    public struct RadiusSettings: Swift.Equatable {
        /// The protocol specified for your RADIUS endpoints.
        public var authenticationProtocol: DirectoryClientTypes.RadiusAuthenticationProtocol?
        /// Not currently used.
        public var displayLabel: Swift.String?
        /// The port that your RADIUS server is using for communications. Your self-managed network must allow inbound traffic over this port from the Directory Service servers.
        public var radiusPort: Swift.Int
        /// The maximum number of times that communication with the RADIUS server is attempted.
        public var radiusRetries: Swift.Int
        /// An array of strings that contains the fully qualified domain name (FQDN) or IP addresses of the RADIUS server endpoints, or the FQDN or IP addresses of your RADIUS server load balancer.
        public var radiusServers: [Swift.String]?
        /// The amount of time, in seconds, to wait for the RADIUS server to respond.
        public var radiusTimeout: Swift.Int
        /// Required for enabling RADIUS on the directory.
        public var sharedSecret: Swift.String?
        /// Not currently used.
        public var useSameUsername: Swift.Bool

        public init(
            authenticationProtocol: DirectoryClientTypes.RadiusAuthenticationProtocol? = nil,
            displayLabel: Swift.String? = nil,
            radiusPort: Swift.Int = 0,
            radiusRetries: Swift.Int = 0,
            radiusServers: [Swift.String]? = nil,
            radiusTimeout: Swift.Int = 0,
            sharedSecret: Swift.String? = nil,
            useSameUsername: Swift.Bool = false
        )
        {
            self.authenticationProtocol = authenticationProtocol
            self.displayLabel = displayLabel
            self.radiusPort = radiusPort
            self.radiusRetries = radiusRetries
            self.radiusServers = radiusServers
            self.radiusTimeout = radiusTimeout
            self.sharedSecret = sharedSecret
            self.useSameUsername = useSameUsername
        }
    }

}

extension DirectoryClientTypes {
    public enum RadiusStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case creating
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [RadiusStatus] {
            return [
                .completed,
                .creating,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .creating: return "Creating"
            case .failed: return "Failed"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RadiusStatus(rawValue: rawValue) ?? RadiusStatus.sdkUnknown(rawValue)
        }
    }
}

extension DirectoryClientTypes.RegionDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case desiredNumberOfDomainControllers = "DesiredNumberOfDomainControllers"
        case directoryId = "DirectoryId"
        case lastUpdatedDateTime = "LastUpdatedDateTime"
        case launchTime = "LaunchTime"
        case regionName = "RegionName"
        case regionType = "RegionType"
        case status = "Status"
        case statusLastUpdatedDateTime = "StatusLastUpdatedDateTime"
        case vpcSettings = "VpcSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if desiredNumberOfDomainControllers != 0 {
            try encodeContainer.encode(desiredNumberOfDomainControllers, forKey: .desiredNumberOfDomainControllers)
        }
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let launchTime = self.launchTime {
            try encodeContainer.encodeTimestamp(launchTime, format: .epochSeconds, forKey: .launchTime)
        }
        if let regionName = self.regionName {
            try encodeContainer.encode(regionName, forKey: .regionName)
        }
        if let regionType = self.regionType {
            try encodeContainer.encode(regionType.rawValue, forKey: .regionType)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusLastUpdatedDateTime = self.statusLastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(statusLastUpdatedDateTime, format: .epochSeconds, forKey: .statusLastUpdatedDateTime)
        }
        if let vpcSettings = self.vpcSettings {
            try encodeContainer.encode(vpcSettings, forKey: .vpcSettings)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let regionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionName)
        regionName = regionNameDecoded
        let regionTypeDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.RegionType.self, forKey: .regionType)
        regionType = regionTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.DirectoryStage.self, forKey: .status)
        status = statusDecoded
        let vpcSettingsDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.DirectoryVpcSettings.self, forKey: .vpcSettings)
        vpcSettings = vpcSettingsDecoded
        let desiredNumberOfDomainControllersDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .desiredNumberOfDomainControllers) ?? 0
        desiredNumberOfDomainControllers = desiredNumberOfDomainControllersDecoded
        let launchTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .launchTime)
        launchTime = launchTimeDecoded
        let statusLastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .statusLastUpdatedDateTime)
        statusLastUpdatedDateTime = statusLastUpdatedDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension DirectoryClientTypes {
    /// The replicated Region information for a directory.
    public struct RegionDescription: Swift.Equatable {
        /// The desired number of domain controllers in the specified Region for the specified directory.
        public var desiredNumberOfDomainControllers: Swift.Int
        /// The identifier of the directory.
        public var directoryId: Swift.String?
        /// The date and time that the Region description was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// Specifies when the Region replication began.
        public var launchTime: ClientRuntime.Date?
        /// The name of the Region. For example, us-east-1.
        public var regionName: Swift.String?
        /// Specifies whether the Region is the primary Region or an additional Region.
        public var regionType: DirectoryClientTypes.RegionType?
        /// The status of the replication process for the specified Region.
        public var status: DirectoryClientTypes.DirectoryStage?
        /// The date and time that the Region status was last updated.
        public var statusLastUpdatedDateTime: ClientRuntime.Date?
        /// Contains VPC information for the [CreateDirectory] or [CreateMicrosoftAD] operation.
        public var vpcSettings: DirectoryClientTypes.DirectoryVpcSettings?

        public init(
            desiredNumberOfDomainControllers: Swift.Int = 0,
            directoryId: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            launchTime: ClientRuntime.Date? = nil,
            regionName: Swift.String? = nil,
            regionType: DirectoryClientTypes.RegionType? = nil,
            status: DirectoryClientTypes.DirectoryStage? = nil,
            statusLastUpdatedDateTime: ClientRuntime.Date? = nil,
            vpcSettings: DirectoryClientTypes.DirectoryVpcSettings? = nil
        )
        {
            self.desiredNumberOfDomainControllers = desiredNumberOfDomainControllers
            self.directoryId = directoryId
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.launchTime = launchTime
            self.regionName = regionName
            self.regionType = regionType
            self.status = status
            self.statusLastUpdatedDateTime = statusLastUpdatedDateTime
            self.vpcSettings = vpcSettings
        }
    }

}

extension RegionLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RegionLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You have reached the limit for maximum number of simultaneous Region replications per directory.
public struct RegionLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The descriptive message for the exception.
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request identifier.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RegionLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct RegionLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension RegionLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DirectoryClientTypes {
    public enum RegionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case additional
        case primary
        case sdkUnknown(Swift.String)

        public static var allCases: [RegionType] {
            return [
                .additional,
                .primary,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .additional: return "Additional"
            case .primary: return "Primary"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RegionType(rawValue: rawValue) ?? RegionType.sdkUnknown(rawValue)
        }
    }
}

extension DirectoryClientTypes.RegionsInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalRegions = "AdditionalRegions"
        case primaryRegion = "PrimaryRegion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalRegions = additionalRegions {
            var additionalRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalRegions)
            for regionname0 in additionalRegions {
                try additionalRegionsContainer.encode(regionname0)
            }
        }
        if let primaryRegion = self.primaryRegion {
            try encodeContainer.encode(primaryRegion, forKey: .primaryRegion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let primaryRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryRegion)
        primaryRegion = primaryRegionDecoded
        let additionalRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .additionalRegions)
        var additionalRegionsDecoded0:[Swift.String]? = nil
        if let additionalRegionsContainer = additionalRegionsContainer {
            additionalRegionsDecoded0 = [Swift.String]()
            for string0 in additionalRegionsContainer {
                if let string0 = string0 {
                    additionalRegionsDecoded0?.append(string0)
                }
            }
        }
        additionalRegions = additionalRegionsDecoded0
    }
}

extension DirectoryClientTypes {
    /// Provides information about the Regions that are configured for multi-Region replication.
    public struct RegionsInfo: Swift.Equatable {
        /// Lists the Regions where the directory has been replicated, excluding the primary Region.
        public var additionalRegions: [Swift.String]?
        /// The Region where the Managed Microsoft AD directory was originally created.
        public var primaryRegion: Swift.String?

        public init(
            additionalRegions: [Swift.String]? = nil,
            primaryRegion: Swift.String? = nil
        )
        {
            self.additionalRegions = additionalRegions
            self.primaryRegion = primaryRegion
        }
    }

}

extension RegisterCertificateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateData = "CertificateData"
        case clientCertAuthSettings = "ClientCertAuthSettings"
        case directoryId = "DirectoryId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateData = self.certificateData {
            try encodeContainer.encode(certificateData, forKey: .certificateData)
        }
        if let clientCertAuthSettings = self.clientCertAuthSettings {
            try encodeContainer.encode(clientCertAuthSettings, forKey: .clientCertAuthSettings)
        }
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension RegisterCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RegisterCertificateInput: Swift.Equatable {
    /// The certificate PEM string that needs to be registered.
    /// This member is required.
    public var certificateData: Swift.String?
    /// A ClientCertAuthSettings object that contains client certificate authentication settings.
    public var clientCertAuthSettings: DirectoryClientTypes.ClientCertAuthSettings?
    /// The identifier of the directory.
    /// This member is required.
    public var directoryId: Swift.String?
    /// The function that the registered certificate performs. Valid values include ClientLDAPS or ClientCertAuth. The default value is ClientLDAPS.
    public var type: DirectoryClientTypes.CertificateType?

    public init(
        certificateData: Swift.String? = nil,
        clientCertAuthSettings: DirectoryClientTypes.ClientCertAuthSettings? = nil,
        directoryId: Swift.String? = nil,
        type: DirectoryClientTypes.CertificateType? = nil
    )
    {
        self.certificateData = certificateData
        self.clientCertAuthSettings = clientCertAuthSettings
        self.directoryId = directoryId
        self.type = type
    }
}

struct RegisterCertificateInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let certificateData: Swift.String?
    let type: DirectoryClientTypes.CertificateType?
    let clientCertAuthSettings: DirectoryClientTypes.ClientCertAuthSettings?
}

extension RegisterCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateData = "CertificateData"
        case clientCertAuthSettings = "ClientCertAuthSettings"
        case directoryId = "DirectoryId"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let certificateDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateData)
        certificateData = certificateDataDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.CertificateType.self, forKey: .type)
        type = typeDecoded
        let clientCertAuthSettingsDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.ClientCertAuthSettings.self, forKey: .clientCertAuthSettings)
        clientCertAuthSettings = clientCertAuthSettingsDecoded
    }
}

extension RegisterCertificateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RegisterCertificateOutputBody = try responseDecoder.decode(responseBody: data)
            self.certificateId = output.certificateId
        } else {
            self.certificateId = nil
        }
    }
}

public struct RegisterCertificateOutput: Swift.Equatable {
    /// The identifier of the certificate.
    public var certificateId: Swift.String?

    public init(
        certificateId: Swift.String? = nil
    )
    {
        self.certificateId = certificateId
    }
}

struct RegisterCertificateOutputBody: Swift.Equatable {
    let certificateId: Swift.String?
}

extension RegisterCertificateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateId = "CertificateId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
    }
}

enum RegisterCertificateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CertificateAlreadyExistsException": return try await CertificateAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CertificateLimitExceededException": return try await CertificateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryDoesNotExistException": return try await DirectoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryUnavailableException": return try await DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCertificateException": return try await InvalidCertificateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RegisterEventTopicInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case topicName = "TopicName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let topicName = self.topicName {
            try encodeContainer.encode(topicName, forKey: .topicName)
        }
    }
}

extension RegisterEventTopicInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Registers a new event topic.
public struct RegisterEventTopicInput: Swift.Equatable {
    /// The Directory ID that will publish status messages to the Amazon SNS topic.
    /// This member is required.
    public var directoryId: Swift.String?
    /// The Amazon SNS topic name to which the directory will publish status messages. This Amazon SNS topic must be in the same region as the specified Directory ID.
    /// This member is required.
    public var topicName: Swift.String?

    public init(
        directoryId: Swift.String? = nil,
        topicName: Swift.String? = nil
    )
    {
        self.directoryId = directoryId
        self.topicName = topicName
    }
}

struct RegisterEventTopicInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let topicName: Swift.String?
}

extension RegisterEventTopicInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case topicName = "TopicName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let topicNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicName)
        topicName = topicNameDecoded
    }
}

extension RegisterEventTopicOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// The result of a RegisterEventTopic request.
public struct RegisterEventTopicOutput: Swift.Equatable {

    public init() { }
}

enum RegisterEventTopicOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RejectSharedDirectoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sharedDirectoryId = "SharedDirectoryId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sharedDirectoryId = self.sharedDirectoryId {
            try encodeContainer.encode(sharedDirectoryId, forKey: .sharedDirectoryId)
        }
    }
}

extension RejectSharedDirectoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RejectSharedDirectoryInput: Swift.Equatable {
    /// Identifier of the shared directory in the directory consumer account. This identifier is different for each directory owner account.
    /// This member is required.
    public var sharedDirectoryId: Swift.String?

    public init(
        sharedDirectoryId: Swift.String? = nil
    )
    {
        self.sharedDirectoryId = sharedDirectoryId
    }
}

struct RejectSharedDirectoryInputBody: Swift.Equatable {
    let sharedDirectoryId: Swift.String?
}

extension RejectSharedDirectoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sharedDirectoryId = "SharedDirectoryId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sharedDirectoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedDirectoryId)
        sharedDirectoryId = sharedDirectoryIdDecoded
    }
}

extension RejectSharedDirectoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RejectSharedDirectoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.sharedDirectoryId = output.sharedDirectoryId
        } else {
            self.sharedDirectoryId = nil
        }
    }
}

public struct RejectSharedDirectoryOutput: Swift.Equatable {
    /// Identifier of the shared directory in the directory consumer account.
    public var sharedDirectoryId: Swift.String?

    public init(
        sharedDirectoryId: Swift.String? = nil
    )
    {
        self.sharedDirectoryId = sharedDirectoryId
    }
}

struct RejectSharedDirectoryOutputBody: Swift.Equatable {
    let sharedDirectoryId: Swift.String?
}

extension RejectSharedDirectoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sharedDirectoryId = "SharedDirectoryId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sharedDirectoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedDirectoryId)
        sharedDirectoryId = sharedDirectoryIdDecoded
    }
}

enum RejectSharedDirectoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryAlreadySharedException": return try await DirectoryAlreadySharedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RemoveIpRoutesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidrIps = "CidrIps"
        case directoryId = "DirectoryId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidrIps = cidrIps {
            var cidrIpsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cidrIps)
            for cidrip0 in cidrIps {
                try cidrIpsContainer.encode(cidrip0)
            }
        }
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
    }
}

extension RemoveIpRoutesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RemoveIpRoutesInput: Swift.Equatable {
    /// IP address blocks that you want to remove.
    /// This member is required.
    public var cidrIps: [Swift.String]?
    /// Identifier (ID) of the directory from which you want to remove the IP addresses.
    /// This member is required.
    public var directoryId: Swift.String?

    public init(
        cidrIps: [Swift.String]? = nil,
        directoryId: Swift.String? = nil
    )
    {
        self.cidrIps = cidrIps
        self.directoryId = directoryId
    }
}

struct RemoveIpRoutesInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let cidrIps: [Swift.String]?
}

extension RemoveIpRoutesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidrIps = "CidrIps"
        case directoryId = "DirectoryId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let cidrIpsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cidrIps)
        var cidrIpsDecoded0:[Swift.String]? = nil
        if let cidrIpsContainer = cidrIpsContainer {
            cidrIpsDecoded0 = [Swift.String]()
            for string0 in cidrIpsContainer {
                if let string0 = string0 {
                    cidrIpsDecoded0?.append(string0)
                }
            }
        }
        cidrIps = cidrIpsDecoded0
    }
}

extension RemoveIpRoutesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RemoveIpRoutesOutput: Swift.Equatable {

    public init() { }
}

enum RemoveIpRoutesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryUnavailableException": return try await DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RemoveRegionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
    }
}

extension RemoveRegionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RemoveRegionInput: Swift.Equatable {
    /// The identifier of the directory for which you want to remove Region replication.
    /// This member is required.
    public var directoryId: Swift.String?

    public init(
        directoryId: Swift.String? = nil
    )
    {
        self.directoryId = directoryId
    }
}

struct RemoveRegionInputBody: Swift.Equatable {
    let directoryId: Swift.String?
}

extension RemoveRegionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
    }
}

extension RemoveRegionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RemoveRegionOutput: Swift.Equatable {

    public init() { }
}

enum RemoveRegionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryDoesNotExistException": return try await DirectoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryUnavailableException": return try await DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RemoveTagsFromResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension RemoveTagsFromResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RemoveTagsFromResourceInput: Swift.Equatable {
    /// Identifier (ID) of the directory from which to remove the tag.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The tag key (name) of the tag to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceId: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceId = resourceId
        self.tagKeys = tagKeys
    }
}

struct RemoveTagsFromResourceInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let tagKeys: [Swift.String]?
}

extension RemoveTagsFromResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension RemoveTagsFromResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RemoveTagsFromResourceOutput: Swift.Equatable {

    public init() { }
}

enum RemoveTagsFromResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DirectoryClientTypes {
    public enum ReplicationScope: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case domain
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationScope] {
            return [
                .domain,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .domain: return "Domain"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationScope(rawValue: rawValue) ?? ReplicationScope.sdkUnknown(rawValue)
        }
    }
}

extension ResetUserPasswordInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResetUserPasswordInput(directoryId: \(Swift.String(describing: directoryId)), userName: \(Swift.String(describing: userName)), newPassword: \"CONTENT_REDACTED\")"}
}

extension ResetUserPasswordInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case newPassword = "NewPassword"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let newPassword = self.newPassword {
            try encodeContainer.encode(newPassword, forKey: .newPassword)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

extension ResetUserPasswordInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ResetUserPasswordInput: Swift.Equatable {
    /// Identifier of the Managed Microsoft AD or Simple AD directory in which the user resides.
    /// This member is required.
    public var directoryId: Swift.String?
    /// The new password that will be reset.
    /// This member is required.
    public var newPassword: Swift.String?
    /// The user name of the user whose password will be reset.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        directoryId: Swift.String? = nil,
        newPassword: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.directoryId = directoryId
        self.newPassword = newPassword
        self.userName = userName
    }
}

struct ResetUserPasswordInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let userName: Swift.String?
    let newPassword: Swift.String?
}

extension ResetUserPasswordInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case newPassword = "NewPassword"
        case userName = "UserName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let newPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newPassword)
        newPassword = newPasswordDecoded
    }
}

extension ResetUserPasswordOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct ResetUserPasswordOutput: Swift.Equatable {

    public init() { }
}

enum ResetUserPasswordOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryUnavailableException": return try await DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPasswordException": return try await InvalidPasswordException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UserDoesNotExistException": return try await UserDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RestoreFromSnapshotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotId = "SnapshotId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let snapshotId = self.snapshotId {
            try encodeContainer.encode(snapshotId, forKey: .snapshotId)
        }
    }
}

extension RestoreFromSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// An object representing the inputs for the [RestoreFromSnapshot] operation.
public struct RestoreFromSnapshotInput: Swift.Equatable {
    /// The identifier of the snapshot to restore from.
    /// This member is required.
    public var snapshotId: Swift.String?

    public init(
        snapshotId: Swift.String? = nil
    )
    {
        self.snapshotId = snapshotId
    }
}

struct RestoreFromSnapshotInputBody: Swift.Equatable {
    let snapshotId: Swift.String?
}

extension RestoreFromSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotId = "SnapshotId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
    }
}

extension RestoreFromSnapshotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// Contains the results of the [RestoreFromSnapshot] operation.
public struct RestoreFromSnapshotOutput: Swift.Equatable {

    public init() { }
}

enum RestoreFromSnapshotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DirectoryClientTypes.SchemaExtensionInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case directoryId = "DirectoryId"
        case endDateTime = "EndDateTime"
        case schemaExtensionId = "SchemaExtensionId"
        case schemaExtensionStatus = "SchemaExtensionStatus"
        case schemaExtensionStatusReason = "SchemaExtensionStatusReason"
        case startDateTime = "StartDateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let endDateTime = self.endDateTime {
            try encodeContainer.encodeTimestamp(endDateTime, format: .epochSeconds, forKey: .endDateTime)
        }
        if let schemaExtensionId = self.schemaExtensionId {
            try encodeContainer.encode(schemaExtensionId, forKey: .schemaExtensionId)
        }
        if let schemaExtensionStatus = self.schemaExtensionStatus {
            try encodeContainer.encode(schemaExtensionStatus.rawValue, forKey: .schemaExtensionStatus)
        }
        if let schemaExtensionStatusReason = self.schemaExtensionStatusReason {
            try encodeContainer.encode(schemaExtensionStatusReason, forKey: .schemaExtensionStatusReason)
        }
        if let startDateTime = self.startDateTime {
            try encodeContainer.encodeTimestamp(startDateTime, format: .epochSeconds, forKey: .startDateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let schemaExtensionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaExtensionId)
        schemaExtensionId = schemaExtensionIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let schemaExtensionStatusDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.SchemaExtensionStatus.self, forKey: .schemaExtensionStatus)
        schemaExtensionStatus = schemaExtensionStatusDecoded
        let schemaExtensionStatusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaExtensionStatusReason)
        schemaExtensionStatusReason = schemaExtensionStatusReasonDecoded
        let startDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startDateTime)
        startDateTime = startDateTimeDecoded
        let endDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endDateTime)
        endDateTime = endDateTimeDecoded
    }
}

extension DirectoryClientTypes {
    /// Information about a schema extension.
    public struct SchemaExtensionInfo: Swift.Equatable {
        /// A description of the schema extension.
        public var description: Swift.String?
        /// The identifier of the directory to which the schema extension is applied.
        public var directoryId: Swift.String?
        /// The date and time that the schema extension was completed.
        public var endDateTime: ClientRuntime.Date?
        /// The identifier of the schema extension.
        public var schemaExtensionId: Swift.String?
        /// The current status of the schema extension.
        public var schemaExtensionStatus: DirectoryClientTypes.SchemaExtensionStatus?
        /// The reason for the SchemaExtensionStatus.
        public var schemaExtensionStatusReason: Swift.String?
        /// The date and time that the schema extension started being applied to the directory.
        public var startDateTime: ClientRuntime.Date?

        public init(
            description: Swift.String? = nil,
            directoryId: Swift.String? = nil,
            endDateTime: ClientRuntime.Date? = nil,
            schemaExtensionId: Swift.String? = nil,
            schemaExtensionStatus: DirectoryClientTypes.SchemaExtensionStatus? = nil,
            schemaExtensionStatusReason: Swift.String? = nil,
            startDateTime: ClientRuntime.Date? = nil
        )
        {
            self.description = description
            self.directoryId = directoryId
            self.endDateTime = endDateTime
            self.schemaExtensionId = schemaExtensionId
            self.schemaExtensionStatus = schemaExtensionStatus
            self.schemaExtensionStatusReason = schemaExtensionStatusReason
            self.startDateTime = startDateTime
        }
    }

}

extension DirectoryClientTypes {
    public enum SchemaExtensionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case cancelInProgress
        case completed
        case creatingSnapshot
        case failed
        case initializing
        case replicating
        case rollbackInProgress
        case updatingSchema
        case sdkUnknown(Swift.String)

        public static var allCases: [SchemaExtensionStatus] {
            return [
                .cancelled,
                .cancelInProgress,
                .completed,
                .creatingSnapshot,
                .failed,
                .initializing,
                .replicating,
                .rollbackInProgress,
                .updatingSchema,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "Cancelled"
            case .cancelInProgress: return "CancelInProgress"
            case .completed: return "Completed"
            case .creatingSnapshot: return "CreatingSnapshot"
            case .failed: return "Failed"
            case .initializing: return "Initializing"
            case .replicating: return "Replicating"
            case .rollbackInProgress: return "RollbackInProgress"
            case .updatingSchema: return "UpdatingSchema"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SchemaExtensionStatus(rawValue: rawValue) ?? SchemaExtensionStatus.sdkUnknown(rawValue)
        }
    }
}

extension DirectoryClientTypes {
    public enum SelectiveAuth: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [SelectiveAuth] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SelectiveAuth(rawValue: rawValue) ?? SelectiveAuth.sdkUnknown(rawValue)
        }
    }
}

extension ServiceException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An exception has occurred in Directory Service.
public struct ServiceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The descriptive message for the exception.
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request identifier.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct ServiceExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension ServiceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DirectoryClientTypes.Setting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension DirectoryClientTypes {
    /// Contains information about the configurable settings for a directory.
    public struct Setting: Swift.Equatable {
        /// The name of the directory setting. For example: TLS_1_0
        /// This member is required.
        public var name: Swift.String?
        /// The value of the directory setting for which to retrieve information. For example, for TLS_1_0, the valid values are: Enable and Disable.
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension DirectoryClientTypes.SettingEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedValues = "AllowedValues"
        case appliedValue = "AppliedValue"
        case dataType = "DataType"
        case lastRequestedDateTime = "LastRequestedDateTime"
        case lastUpdatedDateTime = "LastUpdatedDateTime"
        case name = "Name"
        case requestDetailedStatus = "RequestDetailedStatus"
        case requestStatus = "RequestStatus"
        case requestStatusMessage = "RequestStatusMessage"
        case requestedValue = "RequestedValue"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedValues = self.allowedValues {
            try encodeContainer.encode(allowedValues, forKey: .allowedValues)
        }
        if let appliedValue = self.appliedValue {
            try encodeContainer.encode(appliedValue, forKey: .appliedValue)
        }
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType, forKey: .dataType)
        }
        if let lastRequestedDateTime = self.lastRequestedDateTime {
            try encodeContainer.encodeTimestamp(lastRequestedDateTime, format: .epochSeconds, forKey: .lastRequestedDateTime)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requestDetailedStatus = requestDetailedStatus {
            var requestDetailedStatusContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestDetailedStatus)
            for (dictKey0, directoryConfigurationSettingRequestDetailedStatus0) in requestDetailedStatus {
                try requestDetailedStatusContainer.encode(directoryConfigurationSettingRequestDetailedStatus0.rawValue, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let requestStatus = self.requestStatus {
            try encodeContainer.encode(requestStatus.rawValue, forKey: .requestStatus)
        }
        if let requestStatusMessage = self.requestStatusMessage {
            try encodeContainer.encode(requestStatusMessage, forKey: .requestStatusMessage)
        }
        if let requestedValue = self.requestedValue {
            try encodeContainer.encode(requestedValue, forKey: .requestedValue)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let allowedValuesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .allowedValues)
        allowedValues = allowedValuesDecoded
        let appliedValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appliedValue)
        appliedValue = appliedValueDecoded
        let requestedValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestedValue)
        requestedValue = requestedValueDecoded
        let requestStatusDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.DirectoryConfigurationStatus.self, forKey: .requestStatus)
        requestStatus = requestStatusDecoded
        let requestDetailedStatusContainer = try containerValues.decodeIfPresent([Swift.String: DirectoryClientTypes.DirectoryConfigurationStatus?].self, forKey: .requestDetailedStatus)
        var requestDetailedStatusDecoded0: [Swift.String:DirectoryClientTypes.DirectoryConfigurationStatus]? = nil
        if let requestDetailedStatusContainer = requestDetailedStatusContainer {
            requestDetailedStatusDecoded0 = [Swift.String:DirectoryClientTypes.DirectoryConfigurationStatus]()
            for (key0, directoryconfigurationstatus0) in requestDetailedStatusContainer {
                if let directoryconfigurationstatus0 = directoryconfigurationstatus0 {
                    requestDetailedStatusDecoded0?[key0] = directoryconfigurationstatus0
                }
            }
        }
        requestDetailedStatus = requestDetailedStatusDecoded0
        let requestStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestStatusMessage)
        requestStatusMessage = requestStatusMessageDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let lastRequestedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastRequestedDateTime)
        lastRequestedDateTime = lastRequestedDateTimeDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataType)
        dataType = dataTypeDecoded
    }
}

extension DirectoryClientTypes {
    /// Contains information about the specified configurable setting for a directory.
    public struct SettingEntry: Swift.Equatable {
        /// The valid range of values for the directory setting. These values depend on the DataType of your directory.
        public var allowedValues: Swift.String?
        /// The value of the directory setting that is applied to the directory.
        public var appliedValue: Swift.String?
        /// The data type of a directory setting. This is used to define the AllowedValues of a setting. For example a data type can be Boolean, DurationInSeconds, or Enum.
        public var dataType: Swift.String?
        /// The date and time when the request to update a directory setting was last submitted.
        public var lastRequestedDateTime: ClientRuntime.Date?
        /// The date and time when the directory setting was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the directory setting. For example: TLS_1_0
        public var name: Swift.String?
        /// Details about the status of the request to update the directory setting. If the directory setting is deployed in more than one region, status is returned for the request in each region where the setting is deployed.
        public var requestDetailedStatus: [Swift.String:DirectoryClientTypes.DirectoryConfigurationStatus]?
        /// The overall status of the request to update the directory setting request. If the directory setting is deployed in more than one region, and the request fails in any region, the overall status is Failed.
        public var requestStatus: DirectoryClientTypes.DirectoryConfigurationStatus?
        /// The last status message for the directory status request.
        public var requestStatusMessage: Swift.String?
        /// The value that was last requested for the directory setting.
        public var requestedValue: Swift.String?
        /// The type, or category, of a directory setting. Similar settings have the same type. For example, Protocol, Cipher, or Certificate-Based Authentication.
        public var type: Swift.String?

        public init(
            allowedValues: Swift.String? = nil,
            appliedValue: Swift.String? = nil,
            dataType: Swift.String? = nil,
            lastRequestedDateTime: ClientRuntime.Date? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            requestDetailedStatus: [Swift.String:DirectoryClientTypes.DirectoryConfigurationStatus]? = nil,
            requestStatus: DirectoryClientTypes.DirectoryConfigurationStatus? = nil,
            requestStatusMessage: Swift.String? = nil,
            requestedValue: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.allowedValues = allowedValues
            self.appliedValue = appliedValue
            self.dataType = dataType
            self.lastRequestedDateTime = lastRequestedDateTime
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.requestDetailedStatus = requestDetailedStatus
            self.requestStatus = requestStatus
            self.requestStatusMessage = requestStatusMessage
            self.requestedValue = requestedValue
            self.type = type
        }
    }

}

extension ShareDirectoryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ShareDirectoryInput(directoryId: \(Swift.String(describing: directoryId)), shareMethod: \(Swift.String(describing: shareMethod)), shareTarget: \(Swift.String(describing: shareTarget)), shareNotes: \"CONTENT_REDACTED\")"}
}

extension ShareDirectoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case shareMethod = "ShareMethod"
        case shareNotes = "ShareNotes"
        case shareTarget = "ShareTarget"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let shareMethod = self.shareMethod {
            try encodeContainer.encode(shareMethod.rawValue, forKey: .shareMethod)
        }
        if let shareNotes = self.shareNotes {
            try encodeContainer.encode(shareNotes, forKey: .shareNotes)
        }
        if let shareTarget = self.shareTarget {
            try encodeContainer.encode(shareTarget, forKey: .shareTarget)
        }
    }
}

extension ShareDirectoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ShareDirectoryInput: Swift.Equatable {
    /// Identifier of the Managed Microsoft AD directory that you want to share with other Amazon Web Services accounts.
    /// This member is required.
    public var directoryId: Swift.String?
    /// The method used when sharing a directory to determine whether the directory should be shared within your Amazon Web Services organization (ORGANIZATIONS) or with any Amazon Web Services account by sending a directory sharing request (HANDSHAKE).
    /// This member is required.
    public var shareMethod: DirectoryClientTypes.ShareMethod?
    /// A directory share request that is sent by the directory owner to the directory consumer. The request includes a typed message to help the directory consumer administrator determine whether to approve or reject the share invitation.
    public var shareNotes: Swift.String?
    /// Identifier for the directory consumer account with whom the directory is to be shared.
    /// This member is required.
    public var shareTarget: DirectoryClientTypes.ShareTarget?

    public init(
        directoryId: Swift.String? = nil,
        shareMethod: DirectoryClientTypes.ShareMethod? = nil,
        shareNotes: Swift.String? = nil,
        shareTarget: DirectoryClientTypes.ShareTarget? = nil
    )
    {
        self.directoryId = directoryId
        self.shareMethod = shareMethod
        self.shareNotes = shareNotes
        self.shareTarget = shareTarget
    }
}

struct ShareDirectoryInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let shareNotes: Swift.String?
    let shareTarget: DirectoryClientTypes.ShareTarget?
    let shareMethod: DirectoryClientTypes.ShareMethod?
}

extension ShareDirectoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case shareMethod = "ShareMethod"
        case shareNotes = "ShareNotes"
        case shareTarget = "ShareTarget"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let shareNotesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareNotes)
        shareNotes = shareNotesDecoded
        let shareTargetDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.ShareTarget.self, forKey: .shareTarget)
        shareTarget = shareTargetDecoded
        let shareMethodDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.ShareMethod.self, forKey: .shareMethod)
        shareMethod = shareMethodDecoded
    }
}

extension ShareDirectoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ShareDirectoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.sharedDirectoryId = output.sharedDirectoryId
        } else {
            self.sharedDirectoryId = nil
        }
    }
}

public struct ShareDirectoryOutput: Swift.Equatable {
    /// Identifier of the directory that is stored in the directory consumer account that is shared from the specified directory (DirectoryId).
    public var sharedDirectoryId: Swift.String?

    public init(
        sharedDirectoryId: Swift.String? = nil
    )
    {
        self.sharedDirectoryId = sharedDirectoryId
    }
}

struct ShareDirectoryOutputBody: Swift.Equatable {
    let sharedDirectoryId: Swift.String?
}

extension ShareDirectoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sharedDirectoryId = "SharedDirectoryId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sharedDirectoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedDirectoryId)
        sharedDirectoryId = sharedDirectoryIdDecoded
    }
}

enum ShareDirectoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryAlreadySharedException": return try await DirectoryAlreadySharedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTargetException": return try await InvalidTargetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationsException": return try await OrganizationsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ShareLimitExceededException": return try await ShareLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ShareLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ShareLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The maximum number of Amazon Web Services accounts that you can share with this directory has been reached.
public struct ShareLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The descriptive message for the exception.
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request identifier.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ShareLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct ShareLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension ShareLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DirectoryClientTypes {
    public enum ShareMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case handshake
        case organizations
        case sdkUnknown(Swift.String)

        public static var allCases: [ShareMethod] {
            return [
                .handshake,
                .organizations,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .handshake: return "HANDSHAKE"
            case .organizations: return "ORGANIZATIONS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ShareMethod(rawValue: rawValue) ?? ShareMethod.sdkUnknown(rawValue)
        }
    }
}

extension DirectoryClientTypes {
    public enum ShareStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleted
        case deleting
        case pendingAcceptance
        case rejected
        case rejecting
        case rejectFailed
        case shared
        case shareFailed
        case sharing
        case sdkUnknown(Swift.String)

        public static var allCases: [ShareStatus] {
            return [
                .deleted,
                .deleting,
                .pendingAcceptance,
                .rejected,
                .rejecting,
                .rejectFailed,
                .shared,
                .shareFailed,
                .sharing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "Deleted"
            case .deleting: return "Deleting"
            case .pendingAcceptance: return "PendingAcceptance"
            case .rejected: return "Rejected"
            case .rejecting: return "Rejecting"
            case .rejectFailed: return "RejectFailed"
            case .shared: return "Shared"
            case .shareFailed: return "ShareFailed"
            case .sharing: return "Sharing"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ShareStatus(rawValue: rawValue) ?? ShareStatus.sdkUnknown(rawValue)
        }
    }
}

extension DirectoryClientTypes.ShareTarget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.TargetType.self, forKey: .type)
        type = typeDecoded
    }
}

extension DirectoryClientTypes {
    /// Identifier that contains details about the directory consumer account.
    public struct ShareTarget: Swift.Equatable {
        /// Identifier of the directory consumer account.
        /// This member is required.
        public var id: Swift.String?
        /// Type of identifier to be used in the Id field.
        /// This member is required.
        public var type: DirectoryClientTypes.TargetType?

        public init(
            id: Swift.String? = nil,
            type: DirectoryClientTypes.TargetType? = nil
        )
        {
            self.id = id
            self.type = type
        }
    }

}

extension DirectoryClientTypes.SharedDirectory: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDateTime = "CreatedDateTime"
        case lastUpdatedDateTime = "LastUpdatedDateTime"
        case ownerAccountId = "OwnerAccountId"
        case ownerDirectoryId = "OwnerDirectoryId"
        case shareMethod = "ShareMethod"
        case shareNotes = "ShareNotes"
        case shareStatus = "ShareStatus"
        case sharedAccountId = "SharedAccountId"
        case sharedDirectoryId = "SharedDirectoryId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDateTime = self.createdDateTime {
            try encodeContainer.encodeTimestamp(createdDateTime, format: .epochSeconds, forKey: .createdDateTime)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let ownerAccountId = self.ownerAccountId {
            try encodeContainer.encode(ownerAccountId, forKey: .ownerAccountId)
        }
        if let ownerDirectoryId = self.ownerDirectoryId {
            try encodeContainer.encode(ownerDirectoryId, forKey: .ownerDirectoryId)
        }
        if let shareMethod = self.shareMethod {
            try encodeContainer.encode(shareMethod.rawValue, forKey: .shareMethod)
        }
        if let shareNotes = self.shareNotes {
            try encodeContainer.encode(shareNotes, forKey: .shareNotes)
        }
        if let shareStatus = self.shareStatus {
            try encodeContainer.encode(shareStatus.rawValue, forKey: .shareStatus)
        }
        if let sharedAccountId = self.sharedAccountId {
            try encodeContainer.encode(sharedAccountId, forKey: .sharedAccountId)
        }
        if let sharedDirectoryId = self.sharedDirectoryId {
            try encodeContainer.encode(sharedDirectoryId, forKey: .sharedDirectoryId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let ownerDirectoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerDirectoryId)
        ownerDirectoryId = ownerDirectoryIdDecoded
        let shareMethodDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.ShareMethod.self, forKey: .shareMethod)
        shareMethod = shareMethodDecoded
        let sharedAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedAccountId)
        sharedAccountId = sharedAccountIdDecoded
        let sharedDirectoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedDirectoryId)
        sharedDirectoryId = sharedDirectoryIdDecoded
        let shareStatusDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.ShareStatus.self, forKey: .shareStatus)
        shareStatus = shareStatusDecoded
        let shareNotesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareNotes)
        shareNotes = shareNotesDecoded
        let createdDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDateTime)
        createdDateTime = createdDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension DirectoryClientTypes.SharedDirectory: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SharedDirectory(createdDateTime: \(Swift.String(describing: createdDateTime)), lastUpdatedDateTime: \(Swift.String(describing: lastUpdatedDateTime)), ownerAccountId: \(Swift.String(describing: ownerAccountId)), ownerDirectoryId: \(Swift.String(describing: ownerDirectoryId)), shareMethod: \(Swift.String(describing: shareMethod)), shareStatus: \(Swift.String(describing: shareStatus)), sharedAccountId: \(Swift.String(describing: sharedAccountId)), sharedDirectoryId: \(Swift.String(describing: sharedDirectoryId)), shareNotes: \"CONTENT_REDACTED\")"}
}

extension DirectoryClientTypes {
    /// Details about the shared directory in the directory owner account for which the share request in the directory consumer account has been accepted.
    public struct SharedDirectory: Swift.Equatable {
        /// The date and time that the shared directory was created.
        public var createdDateTime: ClientRuntime.Date?
        /// The date and time that the shared directory was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// Identifier of the directory owner account, which contains the directory that has been shared to the consumer account.
        public var ownerAccountId: Swift.String?
        /// Identifier of the directory in the directory owner account.
        public var ownerDirectoryId: Swift.String?
        /// The method used when sharing a directory to determine whether the directory should be shared within your Amazon Web Services organization (ORGANIZATIONS) or with any Amazon Web Services account by sending a shared directory request (HANDSHAKE).
        public var shareMethod: DirectoryClientTypes.ShareMethod?
        /// A directory share request that is sent by the directory owner to the directory consumer. The request includes a typed message to help the directory consumer administrator determine whether to approve or reject the share invitation.
        public var shareNotes: Swift.String?
        /// Current directory status of the shared Managed Microsoft AD directory.
        public var shareStatus: DirectoryClientTypes.ShareStatus?
        /// Identifier of the directory consumer account that has access to the shared directory (OwnerDirectoryId) in the directory owner account.
        public var sharedAccountId: Swift.String?
        /// Identifier of the shared directory in the directory consumer account. This identifier is different for each directory owner account.
        public var sharedDirectoryId: Swift.String?

        public init(
            createdDateTime: ClientRuntime.Date? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            ownerAccountId: Swift.String? = nil,
            ownerDirectoryId: Swift.String? = nil,
            shareMethod: DirectoryClientTypes.ShareMethod? = nil,
            shareNotes: Swift.String? = nil,
            shareStatus: DirectoryClientTypes.ShareStatus? = nil,
            sharedAccountId: Swift.String? = nil,
            sharedDirectoryId: Swift.String? = nil
        )
        {
            self.createdDateTime = createdDateTime
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.ownerAccountId = ownerAccountId
            self.ownerDirectoryId = ownerDirectoryId
            self.shareMethod = shareMethod
            self.shareNotes = shareNotes
            self.shareStatus = shareStatus
            self.sharedAccountId = sharedAccountId
            self.sharedDirectoryId = sharedDirectoryId
        }
    }

}

extension DirectoryClientTypes.Snapshot: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case name = "Name"
        case snapshotId = "SnapshotId"
        case startTime = "StartTime"
        case status = "Status"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let snapshotId = self.snapshotId {
            try encodeContainer.encode(snapshotId, forKey: .snapshotId)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let snapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.SnapshotType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.SnapshotStatus.self, forKey: .status)
        status = statusDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
    }
}

extension DirectoryClientTypes {
    /// Describes a directory snapshot.
    public struct Snapshot: Swift.Equatable {
        /// The directory identifier.
        public var directoryId: Swift.String?
        /// The descriptive name of the snapshot.
        public var name: Swift.String?
        /// The snapshot identifier.
        public var snapshotId: Swift.String?
        /// The date and time that the snapshot was taken.
        public var startTime: ClientRuntime.Date?
        /// The snapshot status.
        public var status: DirectoryClientTypes.SnapshotStatus?
        /// The snapshot type.
        public var type: DirectoryClientTypes.SnapshotType?

        public init(
            directoryId: Swift.String? = nil,
            name: Swift.String? = nil,
            snapshotId: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: DirectoryClientTypes.SnapshotStatus? = nil,
            type: DirectoryClientTypes.SnapshotType? = nil
        )
        {
            self.directoryId = directoryId
            self.name = name
            self.snapshotId = snapshotId
            self.startTime = startTime
            self.status = status
            self.type = type
        }
    }

}

extension SnapshotLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SnapshotLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The maximum number of manual snapshots for the directory has been reached. You can use the [GetSnapshotLimits] operation to determine the snapshot limits for a directory.
public struct SnapshotLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The descriptive message for the exception.
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request identifier.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SnapshotLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct SnapshotLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension SnapshotLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DirectoryClientTypes.SnapshotLimits: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case manualSnapshotsCurrentCount = "ManualSnapshotsCurrentCount"
        case manualSnapshotsLimit = "ManualSnapshotsLimit"
        case manualSnapshotsLimitReached = "ManualSnapshotsLimitReached"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let manualSnapshotsCurrentCount = self.manualSnapshotsCurrentCount {
            try encodeContainer.encode(manualSnapshotsCurrentCount, forKey: .manualSnapshotsCurrentCount)
        }
        if let manualSnapshotsLimit = self.manualSnapshotsLimit {
            try encodeContainer.encode(manualSnapshotsLimit, forKey: .manualSnapshotsLimit)
        }
        if manualSnapshotsLimitReached != false {
            try encodeContainer.encode(manualSnapshotsLimitReached, forKey: .manualSnapshotsLimitReached)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manualSnapshotsLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .manualSnapshotsLimit)
        manualSnapshotsLimit = manualSnapshotsLimitDecoded
        let manualSnapshotsCurrentCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .manualSnapshotsCurrentCount)
        manualSnapshotsCurrentCount = manualSnapshotsCurrentCountDecoded
        let manualSnapshotsLimitReachedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .manualSnapshotsLimitReached) ?? false
        manualSnapshotsLimitReached = manualSnapshotsLimitReachedDecoded
    }
}

extension DirectoryClientTypes {
    /// Contains manual snapshot limit information for a directory.
    public struct SnapshotLimits: Swift.Equatable {
        /// The current number of manual snapshots of the directory.
        public var manualSnapshotsCurrentCount: Swift.Int?
        /// The maximum number of manual snapshots allowed.
        public var manualSnapshotsLimit: Swift.Int?
        /// Indicates if the manual snapshot limit has been reached.
        public var manualSnapshotsLimitReached: Swift.Bool

        public init(
            manualSnapshotsCurrentCount: Swift.Int? = nil,
            manualSnapshotsLimit: Swift.Int? = nil,
            manualSnapshotsLimitReached: Swift.Bool = false
        )
        {
            self.manualSnapshotsCurrentCount = manualSnapshotsCurrentCount
            self.manualSnapshotsLimit = manualSnapshotsLimit
            self.manualSnapshotsLimitReached = manualSnapshotsLimitReached
        }
    }

}

extension DirectoryClientTypes {
    public enum SnapshotStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case creating
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [SnapshotStatus] {
            return [
                .completed,
                .creating,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .creating: return "Creating"
            case .failed: return "Failed"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SnapshotStatus(rawValue: rawValue) ?? SnapshotStatus.sdkUnknown(rawValue)
        }
    }
}

extension DirectoryClientTypes {
    public enum SnapshotType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case auto
        case manual
        case sdkUnknown(Swift.String)

        public static var allCases: [SnapshotType] {
            return [
                .auto,
                .manual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .auto: return "Auto"
            case .manual: return "Manual"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SnapshotType(rawValue: rawValue) ?? SnapshotType.sdkUnknown(rawValue)
        }
    }
}

extension StartSchemaExtensionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createSnapshotBeforeSchemaExtension = "CreateSnapshotBeforeSchemaExtension"
        case description = "Description"
        case directoryId = "DirectoryId"
        case ldifContent = "LdifContent"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createSnapshotBeforeSchemaExtension = self.createSnapshotBeforeSchemaExtension {
            try encodeContainer.encode(createSnapshotBeforeSchemaExtension, forKey: .createSnapshotBeforeSchemaExtension)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let ldifContent = self.ldifContent {
            try encodeContainer.encode(ldifContent, forKey: .ldifContent)
        }
    }
}

extension StartSchemaExtensionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartSchemaExtensionInput: Swift.Equatable {
    /// If true, creates a snapshot of the directory before applying the schema extension.
    /// This member is required.
    public var createSnapshotBeforeSchemaExtension: Swift.Bool?
    /// A description of the schema extension.
    /// This member is required.
    public var description: Swift.String?
    /// The identifier of the directory for which the schema extension will be applied to.
    /// This member is required.
    public var directoryId: Swift.String?
    /// The LDIF file represented as a string. To construct the LdifContent string, precede each line as it would be formatted in an ldif file with \n. See the example request below for more details. The file size can be no larger than 1MB.
    /// This member is required.
    public var ldifContent: Swift.String?

    public init(
        createSnapshotBeforeSchemaExtension: Swift.Bool? = nil,
        description: Swift.String? = nil,
        directoryId: Swift.String? = nil,
        ldifContent: Swift.String? = nil
    )
    {
        self.createSnapshotBeforeSchemaExtension = createSnapshotBeforeSchemaExtension
        self.description = description
        self.directoryId = directoryId
        self.ldifContent = ldifContent
    }
}

struct StartSchemaExtensionInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let createSnapshotBeforeSchemaExtension: Swift.Bool?
    let ldifContent: Swift.String?
    let description: Swift.String?
}

extension StartSchemaExtensionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createSnapshotBeforeSchemaExtension = "CreateSnapshotBeforeSchemaExtension"
        case description = "Description"
        case directoryId = "DirectoryId"
        case ldifContent = "LdifContent"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let createSnapshotBeforeSchemaExtensionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createSnapshotBeforeSchemaExtension)
        createSnapshotBeforeSchemaExtension = createSnapshotBeforeSchemaExtensionDecoded
        let ldifContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ldifContent)
        ldifContent = ldifContentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension StartSchemaExtensionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartSchemaExtensionOutputBody = try responseDecoder.decode(responseBody: data)
            self.schemaExtensionId = output.schemaExtensionId
        } else {
            self.schemaExtensionId = nil
        }
    }
}

public struct StartSchemaExtensionOutput: Swift.Equatable {
    /// The identifier of the schema extension that will be applied.
    public var schemaExtensionId: Swift.String?

    public init(
        schemaExtensionId: Swift.String? = nil
    )
    {
        self.schemaExtensionId = schemaExtensionId
    }
}

struct StartSchemaExtensionOutputBody: Swift.Equatable {
    let schemaExtensionId: Swift.String?
}

extension StartSchemaExtensionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schemaExtensionId = "SchemaExtensionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaExtensionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaExtensionId)
        schemaExtensionId = schemaExtensionIdDecoded
    }
}

enum StartSchemaExtensionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryUnavailableException": return try await DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SnapshotLimitExceededException": return try await SnapshotLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DirectoryClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension DirectoryClientTypes {
    /// Metadata assigned to a directory consisting of a key-value pair.
    public struct Tag: Swift.Equatable {
        /// Required name of the tag. The string value can be Unicode characters and cannot be prefixed with "aws:". The string can contain only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java regex: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").
        /// This member is required.
        public var key: Swift.String?
        /// The optional value of the tag. The string value can be Unicode characters. The string can contain only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java regex: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TagLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The maximum allowed number of tags was exceeded.
public struct TagLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The descriptive message for the exception.
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request identifier.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TagLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct TagLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension TagLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DirectoryClientTypes {
    public enum TargetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case account
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetType] {
            return [
                .account,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .account: return "ACCOUNT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetType(rawValue: rawValue) ?? TargetType.sdkUnknown(rawValue)
        }
    }
}

extension DirectoryClientTypes {
    public enum TopicStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleted
        case failed
        case registered
        case topicNotFound
        case sdkUnknown(Swift.String)

        public static var allCases: [TopicStatus] {
            return [
                .deleted,
                .failed,
                .registered,
                .topicNotFound,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "Deleted"
            case .failed: return "Failed"
            case .registered: return "Registered"
            case .topicNotFound: return "Topic not found"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TopicStatus(rawValue: rawValue) ?? TopicStatus.sdkUnknown(rawValue)
        }
    }
}

extension DirectoryClientTypes.Trust: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDateTime = "CreatedDateTime"
        case directoryId = "DirectoryId"
        case lastUpdatedDateTime = "LastUpdatedDateTime"
        case remoteDomainName = "RemoteDomainName"
        case selectiveAuth = "SelectiveAuth"
        case stateLastUpdatedDateTime = "StateLastUpdatedDateTime"
        case trustDirection = "TrustDirection"
        case trustId = "TrustId"
        case trustState = "TrustState"
        case trustStateReason = "TrustStateReason"
        case trustType = "TrustType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDateTime = self.createdDateTime {
            try encodeContainer.encodeTimestamp(createdDateTime, format: .epochSeconds, forKey: .createdDateTime)
        }
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let remoteDomainName = self.remoteDomainName {
            try encodeContainer.encode(remoteDomainName, forKey: .remoteDomainName)
        }
        if let selectiveAuth = self.selectiveAuth {
            try encodeContainer.encode(selectiveAuth.rawValue, forKey: .selectiveAuth)
        }
        if let stateLastUpdatedDateTime = self.stateLastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(stateLastUpdatedDateTime, format: .epochSeconds, forKey: .stateLastUpdatedDateTime)
        }
        if let trustDirection = self.trustDirection {
            try encodeContainer.encode(trustDirection.rawValue, forKey: .trustDirection)
        }
        if let trustId = self.trustId {
            try encodeContainer.encode(trustId, forKey: .trustId)
        }
        if let trustState = self.trustState {
            try encodeContainer.encode(trustState.rawValue, forKey: .trustState)
        }
        if let trustStateReason = self.trustStateReason {
            try encodeContainer.encode(trustStateReason, forKey: .trustStateReason)
        }
        if let trustType = self.trustType {
            try encodeContainer.encode(trustType.rawValue, forKey: .trustType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let trustIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustId)
        trustId = trustIdDecoded
        let remoteDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .remoteDomainName)
        remoteDomainName = remoteDomainNameDecoded
        let trustTypeDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.TrustType.self, forKey: .trustType)
        trustType = trustTypeDecoded
        let trustDirectionDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.TrustDirection.self, forKey: .trustDirection)
        trustDirection = trustDirectionDecoded
        let trustStateDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.TrustState.self, forKey: .trustState)
        trustState = trustStateDecoded
        let createdDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDateTime)
        createdDateTime = createdDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let stateLastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .stateLastUpdatedDateTime)
        stateLastUpdatedDateTime = stateLastUpdatedDateTimeDecoded
        let trustStateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustStateReason)
        trustStateReason = trustStateReasonDecoded
        let selectiveAuthDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.SelectiveAuth.self, forKey: .selectiveAuth)
        selectiveAuth = selectiveAuthDecoded
    }
}

extension DirectoryClientTypes {
    /// Describes a trust relationship between an Managed Microsoft AD directory and an external domain.
    public struct Trust: Swift.Equatable {
        /// The date and time that the trust relationship was created.
        public var createdDateTime: ClientRuntime.Date?
        /// The Directory ID of the Amazon Web Services directory involved in the trust relationship.
        public var directoryId: Swift.String?
        /// The date and time that the trust relationship was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The Fully Qualified Domain Name (FQDN) of the external domain involved in the trust relationship.
        public var remoteDomainName: Swift.String?
        /// Current state of selective authentication for the trust.
        public var selectiveAuth: DirectoryClientTypes.SelectiveAuth?
        /// The date and time that the TrustState was last updated.
        public var stateLastUpdatedDateTime: ClientRuntime.Date?
        /// The trust relationship direction.
        public var trustDirection: DirectoryClientTypes.TrustDirection?
        /// The unique ID of the trust relationship.
        public var trustId: Swift.String?
        /// The trust relationship state.
        public var trustState: DirectoryClientTypes.TrustState?
        /// The reason for the TrustState.
        public var trustStateReason: Swift.String?
        /// The trust relationship type. Forest is the default.
        public var trustType: DirectoryClientTypes.TrustType?

        public init(
            createdDateTime: ClientRuntime.Date? = nil,
            directoryId: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            remoteDomainName: Swift.String? = nil,
            selectiveAuth: DirectoryClientTypes.SelectiveAuth? = nil,
            stateLastUpdatedDateTime: ClientRuntime.Date? = nil,
            trustDirection: DirectoryClientTypes.TrustDirection? = nil,
            trustId: Swift.String? = nil,
            trustState: DirectoryClientTypes.TrustState? = nil,
            trustStateReason: Swift.String? = nil,
            trustType: DirectoryClientTypes.TrustType? = nil
        )
        {
            self.createdDateTime = createdDateTime
            self.directoryId = directoryId
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.remoteDomainName = remoteDomainName
            self.selectiveAuth = selectiveAuth
            self.stateLastUpdatedDateTime = stateLastUpdatedDateTime
            self.trustDirection = trustDirection
            self.trustId = trustId
            self.trustState = trustState
            self.trustStateReason = trustStateReason
            self.trustType = trustType
        }
    }

}

extension DirectoryClientTypes {
    public enum TrustDirection: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case oneWayIncoming
        case oneWayOutgoing
        case twoWay
        case sdkUnknown(Swift.String)

        public static var allCases: [TrustDirection] {
            return [
                .oneWayIncoming,
                .oneWayOutgoing,
                .twoWay,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .oneWayIncoming: return "One-Way: Incoming"
            case .oneWayOutgoing: return "One-Way: Outgoing"
            case .twoWay: return "Two-Way"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TrustDirection(rawValue: rawValue) ?? TrustDirection.sdkUnknown(rawValue)
        }
    }
}

extension DirectoryClientTypes {
    public enum TrustState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case created
        case creating
        case deleted
        case deleting
        case failed
        case updated
        case updateFailed
        case updating
        case verified
        case verifying
        case verifyFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [TrustState] {
            return [
                .created,
                .creating,
                .deleted,
                .deleting,
                .failed,
                .updated,
                .updateFailed,
                .updating,
                .verified,
                .verifying,
                .verifyFailed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .created: return "Created"
            case .creating: return "Creating"
            case .deleted: return "Deleted"
            case .deleting: return "Deleting"
            case .failed: return "Failed"
            case .updated: return "Updated"
            case .updateFailed: return "UpdateFailed"
            case .updating: return "Updating"
            case .verified: return "Verified"
            case .verifying: return "Verifying"
            case .verifyFailed: return "VerifyFailed"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TrustState(rawValue: rawValue) ?? TrustState.sdkUnknown(rawValue)
        }
    }
}

extension DirectoryClientTypes {
    public enum TrustType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case external
        case forest
        case sdkUnknown(Swift.String)

        public static var allCases: [TrustType] {
            return [
                .external,
                .forest,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .external: return "External"
            case .forest: return "Forest"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TrustType(rawValue: rawValue) ?? TrustType.sdkUnknown(rawValue)
        }
    }
}

extension UnshareDirectoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case unshareTarget = "UnshareTarget"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let unshareTarget = self.unshareTarget {
            try encodeContainer.encode(unshareTarget, forKey: .unshareTarget)
        }
    }
}

extension UnshareDirectoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UnshareDirectoryInput: Swift.Equatable {
    /// The identifier of the Managed Microsoft AD directory that you want to stop sharing.
    /// This member is required.
    public var directoryId: Swift.String?
    /// Identifier for the directory consumer account with whom the directory has to be unshared.
    /// This member is required.
    public var unshareTarget: DirectoryClientTypes.UnshareTarget?

    public init(
        directoryId: Swift.String? = nil,
        unshareTarget: DirectoryClientTypes.UnshareTarget? = nil
    )
    {
        self.directoryId = directoryId
        self.unshareTarget = unshareTarget
    }
}

struct UnshareDirectoryInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let unshareTarget: DirectoryClientTypes.UnshareTarget?
}

extension UnshareDirectoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case unshareTarget = "UnshareTarget"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let unshareTargetDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.UnshareTarget.self, forKey: .unshareTarget)
        unshareTarget = unshareTargetDecoded
    }
}

extension UnshareDirectoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnshareDirectoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.sharedDirectoryId = output.sharedDirectoryId
        } else {
            self.sharedDirectoryId = nil
        }
    }
}

public struct UnshareDirectoryOutput: Swift.Equatable {
    /// Identifier of the directory stored in the directory consumer account that is to be unshared from the specified directory (DirectoryId).
    public var sharedDirectoryId: Swift.String?

    public init(
        sharedDirectoryId: Swift.String? = nil
    )
    {
        self.sharedDirectoryId = sharedDirectoryId
    }
}

struct UnshareDirectoryOutputBody: Swift.Equatable {
    let sharedDirectoryId: Swift.String?
}

extension UnshareDirectoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sharedDirectoryId = "SharedDirectoryId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sharedDirectoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedDirectoryId)
        sharedDirectoryId = sharedDirectoryIdDecoded
    }
}

enum UnshareDirectoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryNotSharedException": return try await DirectoryNotSharedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTargetException": return try await InvalidTargetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DirectoryClientTypes.UnshareTarget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.TargetType.self, forKey: .type)
        type = typeDecoded
    }
}

extension DirectoryClientTypes {
    /// Identifier that contains details about the directory consumer account with whom the directory is being unshared.
    public struct UnshareTarget: Swift.Equatable {
        /// Identifier of the directory consumer account.
        /// This member is required.
        public var id: Swift.String?
        /// Type of identifier to be used in the Id field.
        /// This member is required.
        public var type: DirectoryClientTypes.TargetType?

        public init(
            id: Swift.String? = nil,
            type: DirectoryClientTypes.TargetType? = nil
        )
        {
            self.id = id
            self.type = type
        }
    }

}

extension UnsupportedOperationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnsupportedOperationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation is not supported.
public struct UnsupportedOperationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The descriptive message for the exception.
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request identifier.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedOperationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct UnsupportedOperationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension UnsupportedOperationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension UnsupportedSettingsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnsupportedSettingsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified directory setting is not supported.
public struct UnsupportedSettingsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The descriptive message for the exception.
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request identifier.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedSettingsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct UnsupportedSettingsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension UnsupportedSettingsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension UpdateConditionalForwarderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case dnsIpAddrs = "DnsIpAddrs"
        case remoteDomainName = "RemoteDomainName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let dnsIpAddrs = dnsIpAddrs {
            var dnsIpAddrsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dnsIpAddrs)
            for ipaddr0 in dnsIpAddrs {
                try dnsIpAddrsContainer.encode(ipaddr0)
            }
        }
        if let remoteDomainName = self.remoteDomainName {
            try encodeContainer.encode(remoteDomainName, forKey: .remoteDomainName)
        }
    }
}

extension UpdateConditionalForwarderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Updates a conditional forwarder.
public struct UpdateConditionalForwarderInput: Swift.Equatable {
    /// The directory ID of the Amazon Web Services directory for which to update the conditional forwarder.
    /// This member is required.
    public var directoryId: Swift.String?
    /// The updated IP addresses of the remote DNS server associated with the conditional forwarder.
    /// This member is required.
    public var dnsIpAddrs: [Swift.String]?
    /// The fully qualified domain name (FQDN) of the remote domain with which you will set up a trust relationship.
    /// This member is required.
    public var remoteDomainName: Swift.String?

    public init(
        directoryId: Swift.String? = nil,
        dnsIpAddrs: [Swift.String]? = nil,
        remoteDomainName: Swift.String? = nil
    )
    {
        self.directoryId = directoryId
        self.dnsIpAddrs = dnsIpAddrs
        self.remoteDomainName = remoteDomainName
    }
}

struct UpdateConditionalForwarderInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let remoteDomainName: Swift.String?
    let dnsIpAddrs: [Swift.String]?
}

extension UpdateConditionalForwarderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case dnsIpAddrs = "DnsIpAddrs"
        case remoteDomainName = "RemoteDomainName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let remoteDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .remoteDomainName)
        remoteDomainName = remoteDomainNameDecoded
        let dnsIpAddrsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dnsIpAddrs)
        var dnsIpAddrsDecoded0:[Swift.String]? = nil
        if let dnsIpAddrsContainer = dnsIpAddrsContainer {
            dnsIpAddrsDecoded0 = [Swift.String]()
            for string0 in dnsIpAddrsContainer {
                if let string0 = string0 {
                    dnsIpAddrsDecoded0?.append(string0)
                }
            }
        }
        dnsIpAddrs = dnsIpAddrsDecoded0
    }
}

extension UpdateConditionalForwarderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// The result of an UpdateConditionalForwarder request.
public struct UpdateConditionalForwarderOutput: Swift.Equatable {

    public init() { }
}

enum UpdateConditionalForwarderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryUnavailableException": return try await DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDirectorySetupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createSnapshotBeforeUpdate = "CreateSnapshotBeforeUpdate"
        case directoryId = "DirectoryId"
        case osUpdateSettings = "OSUpdateSettings"
        case updateType = "UpdateType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createSnapshotBeforeUpdate = self.createSnapshotBeforeUpdate {
            try encodeContainer.encode(createSnapshotBeforeUpdate, forKey: .createSnapshotBeforeUpdate)
        }
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let osUpdateSettings = self.osUpdateSettings {
            try encodeContainer.encode(osUpdateSettings, forKey: .osUpdateSettings)
        }
        if let updateType = self.updateType {
            try encodeContainer.encode(updateType.rawValue, forKey: .updateType)
        }
    }
}

extension UpdateDirectorySetupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateDirectorySetupInput: Swift.Equatable {
    /// The boolean that specifies if a snapshot for the directory needs to be taken before updating the directory.
    public var createSnapshotBeforeUpdate: Swift.Bool?
    /// The identifier of the directory on which you want to perform the update.
    /// This member is required.
    public var directoryId: Swift.String?
    /// The settings for the OS update that needs to be performed on the directory.
    public var osUpdateSettings: DirectoryClientTypes.OSUpdateSettings?
    /// The type of update that needs to be performed on the directory. For example, OS.
    /// This member is required.
    public var updateType: DirectoryClientTypes.UpdateType?

    public init(
        createSnapshotBeforeUpdate: Swift.Bool? = nil,
        directoryId: Swift.String? = nil,
        osUpdateSettings: DirectoryClientTypes.OSUpdateSettings? = nil,
        updateType: DirectoryClientTypes.UpdateType? = nil
    )
    {
        self.createSnapshotBeforeUpdate = createSnapshotBeforeUpdate
        self.directoryId = directoryId
        self.osUpdateSettings = osUpdateSettings
        self.updateType = updateType
    }
}

struct UpdateDirectorySetupInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let updateType: DirectoryClientTypes.UpdateType?
    let osUpdateSettings: DirectoryClientTypes.OSUpdateSettings?
    let createSnapshotBeforeUpdate: Swift.Bool?
}

extension UpdateDirectorySetupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createSnapshotBeforeUpdate = "CreateSnapshotBeforeUpdate"
        case directoryId = "DirectoryId"
        case osUpdateSettings = "OSUpdateSettings"
        case updateType = "UpdateType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let updateTypeDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.UpdateType.self, forKey: .updateType)
        updateType = updateTypeDecoded
        let osUpdateSettingsDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.OSUpdateSettings.self, forKey: .osUpdateSettings)
        osUpdateSettings = osUpdateSettingsDecoded
        let createSnapshotBeforeUpdateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createSnapshotBeforeUpdate)
        createSnapshotBeforeUpdate = createSnapshotBeforeUpdateDecoded
    }
}

extension UpdateDirectorySetupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateDirectorySetupOutput: Swift.Equatable {

    public init() { }
}

enum UpdateDirectorySetupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryDoesNotExistException": return try await DirectoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryInDesiredStateException": return try await DirectoryInDesiredStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryUnavailableException": return try await DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SnapshotLimitExceededException": return try await SnapshotLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DirectoryClientTypes.UpdateInfoEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initiatedBy = "InitiatedBy"
        case lastUpdatedDateTime = "LastUpdatedDateTime"
        case newValue = "NewValue"
        case previousValue = "PreviousValue"
        case region = "Region"
        case startTime = "StartTime"
        case status = "Status"
        case statusReason = "StatusReason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initiatedBy = self.initiatedBy {
            try encodeContainer.encode(initiatedBy, forKey: .initiatedBy)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let newValue = self.newValue {
            try encodeContainer.encode(newValue, forKey: .newValue)
        }
        if let previousValue = self.previousValue {
            try encodeContainer.encode(previousValue, forKey: .previousValue)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.UpdateStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let initiatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initiatedBy)
        initiatedBy = initiatedByDecoded
        let newValueDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.UpdateValue.self, forKey: .newValue)
        newValue = newValueDecoded
        let previousValueDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.UpdateValue.self, forKey: .previousValue)
        previousValue = previousValueDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension DirectoryClientTypes {
    /// An entry of update information related to a requested update type.
    public struct UpdateInfoEntry: Swift.Equatable {
        /// This specifies if the update was initiated by the customer or by the service team.
        public var initiatedBy: Swift.String?
        /// The last updated date and time of a particular directory setting.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The new value of the target setting.
        public var newValue: DirectoryClientTypes.UpdateValue?
        /// The old value of the target setting.
        public var previousValue: DirectoryClientTypes.UpdateValue?
        /// The name of the Region.
        public var region: Swift.String?
        /// The start time of the UpdateDirectorySetup for the particular type.
        public var startTime: ClientRuntime.Date?
        /// The status of the update performed on the directory.
        public var status: DirectoryClientTypes.UpdateStatus?
        /// The reason for the current status of the update type activity.
        public var statusReason: Swift.String?

        public init(
            initiatedBy: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            newValue: DirectoryClientTypes.UpdateValue? = nil,
            previousValue: DirectoryClientTypes.UpdateValue? = nil,
            region: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: DirectoryClientTypes.UpdateStatus? = nil,
            statusReason: Swift.String? = nil
        )
        {
            self.initiatedBy = initiatedBy
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.newValue = newValue
            self.previousValue = previousValue
            self.region = region
            self.startTime = startTime
            self.status = status
            self.statusReason = statusReason
        }
    }

}

extension UpdateNumberOfDomainControllersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case desiredNumber = "DesiredNumber"
        case directoryId = "DirectoryId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let desiredNumber = self.desiredNumber {
            try encodeContainer.encode(desiredNumber, forKey: .desiredNumber)
        }
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
    }
}

extension UpdateNumberOfDomainControllersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateNumberOfDomainControllersInput: Swift.Equatable {
    /// The number of domain controllers desired in the directory.
    /// This member is required.
    public var desiredNumber: Swift.Int?
    /// Identifier of the directory to which the domain controllers will be added or removed.
    /// This member is required.
    public var directoryId: Swift.String?

    public init(
        desiredNumber: Swift.Int? = nil,
        directoryId: Swift.String? = nil
    )
    {
        self.desiredNumber = desiredNumber
        self.directoryId = directoryId
    }
}

struct UpdateNumberOfDomainControllersInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let desiredNumber: Swift.Int?
}

extension UpdateNumberOfDomainControllersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case desiredNumber = "DesiredNumber"
        case directoryId = "DirectoryId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let desiredNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .desiredNumber)
        desiredNumber = desiredNumberDecoded
    }
}

extension UpdateNumberOfDomainControllersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateNumberOfDomainControllersOutput: Swift.Equatable {

    public init() { }
}

enum UpdateNumberOfDomainControllersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryUnavailableException": return try await DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DomainControllerLimitExceededException": return try await DomainControllerLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateRadiusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case radiusSettings = "RadiusSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let radiusSettings = self.radiusSettings {
            try encodeContainer.encode(radiusSettings, forKey: .radiusSettings)
        }
    }
}

extension UpdateRadiusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the inputs for the [UpdateRadius] operation.
public struct UpdateRadiusInput: Swift.Equatable {
    /// The identifier of the directory for which to update the RADIUS server information.
    /// This member is required.
    public var directoryId: Swift.String?
    /// A [RadiusSettings] object that contains information about the RADIUS server.
    /// This member is required.
    public var radiusSettings: DirectoryClientTypes.RadiusSettings?

    public init(
        directoryId: Swift.String? = nil,
        radiusSettings: DirectoryClientTypes.RadiusSettings? = nil
    )
    {
        self.directoryId = directoryId
        self.radiusSettings = radiusSettings
    }
}

struct UpdateRadiusInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let radiusSettings: DirectoryClientTypes.RadiusSettings?
}

extension UpdateRadiusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case radiusSettings = "RadiusSettings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let radiusSettingsDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.RadiusSettings.self, forKey: .radiusSettings)
        radiusSettings = radiusSettingsDecoded
    }
}

extension UpdateRadiusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// Contains the results of the [UpdateRadius] operation.
public struct UpdateRadiusOutput: Swift.Equatable {

    public init() { }
}

enum UpdateRadiusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case settings = "Settings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let settings = settings {
            var settingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .settings)
            for setting0 in settings {
                try settingsContainer.encode(setting0)
            }
        }
    }
}

extension UpdateSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateSettingsInput: Swift.Equatable {
    /// The identifier of the directory for which to update settings.
    /// This member is required.
    public var directoryId: Swift.String?
    /// The list of [Setting] objects.
    /// This member is required.
    public var settings: [DirectoryClientTypes.Setting]?

    public init(
        directoryId: Swift.String? = nil,
        settings: [DirectoryClientTypes.Setting]? = nil
    )
    {
        self.directoryId = directoryId
        self.settings = settings
    }
}

struct UpdateSettingsInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let settings: [DirectoryClientTypes.Setting]?
}

extension UpdateSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case settings = "Settings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let settingsContainer = try containerValues.decodeIfPresent([DirectoryClientTypes.Setting?].self, forKey: .settings)
        var settingsDecoded0:[DirectoryClientTypes.Setting]? = nil
        if let settingsContainer = settingsContainer {
            settingsDecoded0 = [DirectoryClientTypes.Setting]()
            for structure0 in settingsContainer {
                if let structure0 = structure0 {
                    settingsDecoded0?.append(structure0)
                }
            }
        }
        settings = settingsDecoded0
    }
}

extension UpdateSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.directoryId = output.directoryId
        } else {
            self.directoryId = nil
        }
    }
}

public struct UpdateSettingsOutput: Swift.Equatable {
    /// The identifier of the directory.
    public var directoryId: Swift.String?

    public init(
        directoryId: Swift.String? = nil
    )
    {
        self.directoryId = directoryId
    }
}

struct UpdateSettingsOutputBody: Swift.Equatable {
    let directoryId: Swift.String?
}

extension UpdateSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
    }
}

enum UpdateSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryDoesNotExistException": return try await DirectoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryUnavailableException": return try await DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IncompatibleSettingsException": return try await IncompatibleSettingsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedSettingsException": return try await UnsupportedSettingsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DirectoryClientTypes {
    public enum UpdateStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case updated
        case updateFailed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateStatus] {
            return [
                .updated,
                .updateFailed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .updated: return "Updated"
            case .updateFailed: return "UpdateFailed"
            case .updating: return "Updating"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpdateStatus(rawValue: rawValue) ?? UpdateStatus.sdkUnknown(rawValue)
        }
    }
}

extension UpdateTrustInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case selectiveAuth = "SelectiveAuth"
        case trustId = "TrustId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let selectiveAuth = self.selectiveAuth {
            try encodeContainer.encode(selectiveAuth.rawValue, forKey: .selectiveAuth)
        }
        if let trustId = self.trustId {
            try encodeContainer.encode(trustId, forKey: .trustId)
        }
    }
}

extension UpdateTrustInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateTrustInput: Swift.Equatable {
    /// Updates selective authentication for the trust.
    public var selectiveAuth: DirectoryClientTypes.SelectiveAuth?
    /// Identifier of the trust relationship.
    /// This member is required.
    public var trustId: Swift.String?

    public init(
        selectiveAuth: DirectoryClientTypes.SelectiveAuth? = nil,
        trustId: Swift.String? = nil
    )
    {
        self.selectiveAuth = selectiveAuth
        self.trustId = trustId
    }
}

struct UpdateTrustInputBody: Swift.Equatable {
    let trustId: Swift.String?
    let selectiveAuth: DirectoryClientTypes.SelectiveAuth?
}

extension UpdateTrustInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case selectiveAuth = "SelectiveAuth"
        case trustId = "TrustId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustId)
        trustId = trustIdDecoded
        let selectiveAuthDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.SelectiveAuth.self, forKey: .selectiveAuth)
        selectiveAuth = selectiveAuthDecoded
    }
}

extension UpdateTrustOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateTrustOutputBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
            self.trustId = output.trustId
        } else {
            self.requestId = nil
            self.trustId = nil
        }
    }
}

public struct UpdateTrustOutput: Swift.Equatable {
    /// The Amazon Web Services request identifier.
    public var requestId: Swift.String?
    /// Identifier of the trust relationship.
    public var trustId: Swift.String?

    public init(
        requestId: Swift.String? = nil,
        trustId: Swift.String? = nil
    )
    {
        self.requestId = requestId
        self.trustId = trustId
    }
}

struct UpdateTrustOutputBody: Swift.Equatable {
    let requestId: Swift.String?
    let trustId: Swift.String?
}

extension UpdateTrustOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case trustId = "TrustId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let trustIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustId)
        trustId = trustIdDecoded
    }
}

enum UpdateTrustOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DirectoryClientTypes {
    public enum UpdateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case os
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateType] {
            return [
                .os,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .os: return "OS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpdateType(rawValue: rawValue) ?? UpdateType.sdkUnknown(rawValue)
        }
    }
}

extension DirectoryClientTypes.UpdateValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case osUpdateSettings = "OSUpdateSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let osUpdateSettings = self.osUpdateSettings {
            try encodeContainer.encode(osUpdateSettings, forKey: .osUpdateSettings)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let osUpdateSettingsDecoded = try containerValues.decodeIfPresent(DirectoryClientTypes.OSUpdateSettings.self, forKey: .osUpdateSettings)
        osUpdateSettings = osUpdateSettingsDecoded
    }
}

extension DirectoryClientTypes {
    /// The value for a given type of UpdateSettings.
    public struct UpdateValue: Swift.Equatable {
        /// The OS update related settings.
        public var osUpdateSettings: DirectoryClientTypes.OSUpdateSettings?

        public init(
            osUpdateSettings: DirectoryClientTypes.OSUpdateSettings? = nil
        )
        {
            self.osUpdateSettings = osUpdateSettings
        }
    }

}

extension UserDoesNotExistException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UserDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The user provided a username that does not exist in your directory.
public struct UserDoesNotExistException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The descriptive message for the exception.
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request identifier.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UserDoesNotExistException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct UserDoesNotExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension UserDoesNotExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension VerifyTrustInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustId = "TrustId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let trustId = self.trustId {
            try encodeContainer.encode(trustId, forKey: .trustId)
        }
    }
}

extension VerifyTrustInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Initiates the verification of an existing trust relationship between an Managed Microsoft AD directory and an external domain.
public struct VerifyTrustInput: Swift.Equatable {
    /// The unique Trust ID of the trust relationship to verify.
    /// This member is required.
    public var trustId: Swift.String?

    public init(
        trustId: Swift.String? = nil
    )
    {
        self.trustId = trustId
    }
}

struct VerifyTrustInputBody: Swift.Equatable {
    let trustId: Swift.String?
}

extension VerifyTrustInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustId = "TrustId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustId)
        trustId = trustIdDecoded
    }
}

extension VerifyTrustOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: VerifyTrustOutputBody = try responseDecoder.decode(responseBody: data)
            self.trustId = output.trustId
        } else {
            self.trustId = nil
        }
    }
}

/// Result of a VerifyTrust request.
public struct VerifyTrustOutput: Swift.Equatable {
    /// The unique Trust ID of the trust relationship that was verified.
    public var trustId: Swift.String?

    public init(
        trustId: Swift.String? = nil
    )
    {
        self.trustId = trustId
    }
}

struct VerifyTrustOutputBody: Swift.Equatable {
    let trustId: Swift.String?
}

extension VerifyTrustOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustId = "TrustId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustId)
        trustId = trustIdDecoded
    }
}

enum VerifyTrustOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientException": return try await ClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntityDoesNotExistException": return try await EntityDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceException": return try await ServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}
