// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension DirectoryClient {
    /// Paginate over `[DescribeClientAuthenticationSettingsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeClientAuthenticationSettingsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeClientAuthenticationSettingsOutputResponse`
    public func describeClientAuthenticationSettingsPaginated(input: DescribeClientAuthenticationSettingsInput) -> ClientRuntime.PaginatorSequence<DescribeClientAuthenticationSettingsInput, DescribeClientAuthenticationSettingsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeClientAuthenticationSettingsInput, DescribeClientAuthenticationSettingsOutputResponse>(input: input, inputKey: \DescribeClientAuthenticationSettingsInput.nextToken, outputKey: \DescribeClientAuthenticationSettingsOutputResponse.nextToken, paginationFunction: self.describeClientAuthenticationSettings(input:))
    }
}

extension DescribeClientAuthenticationSettingsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeClientAuthenticationSettingsInput {
        return DescribeClientAuthenticationSettingsInput(
            directoryId: self.directoryId,
            limit: self.limit,
            nextToken: token,
            type: self.type
        )}
}

extension PaginatorSequence where Input == DescribeClientAuthenticationSettingsInput, Output == DescribeClientAuthenticationSettingsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeClientAuthenticationSettingsPaginated`
    /// to access the nested member `[DirectoryClientTypes.ClientAuthenticationSettingInfo]`
    /// - Returns: `[DirectoryClientTypes.ClientAuthenticationSettingInfo]`
    public func clientAuthenticationSettingsInfo() async throws -> [DirectoryClientTypes.ClientAuthenticationSettingInfo] {
        return try await self.asyncCompactMap { item in item.clientAuthenticationSettingsInfo }
    }
}
extension DirectoryClient {
    /// Paginate over `[DescribeDirectoriesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeDirectoriesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeDirectoriesOutputResponse`
    public func describeDirectoriesPaginated(input: DescribeDirectoriesInput) -> ClientRuntime.PaginatorSequence<DescribeDirectoriesInput, DescribeDirectoriesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeDirectoriesInput, DescribeDirectoriesOutputResponse>(input: input, inputKey: \DescribeDirectoriesInput.nextToken, outputKey: \DescribeDirectoriesOutputResponse.nextToken, paginationFunction: self.describeDirectories(input:))
    }
}

extension DescribeDirectoriesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDirectoriesInput {
        return DescribeDirectoriesInput(
            directoryIds: self.directoryIds,
            limit: self.limit,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == DescribeDirectoriesInput, Output == DescribeDirectoriesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeDirectoriesPaginated`
    /// to access the nested member `[DirectoryClientTypes.DirectoryDescription]`
    /// - Returns: `[DirectoryClientTypes.DirectoryDescription]`
    public func directoryDescriptions() async throws -> [DirectoryClientTypes.DirectoryDescription] {
        return try await self.asyncCompactMap { item in item.directoryDescriptions }
    }
}
extension DirectoryClient {
    /// Paginate over `[DescribeDomainControllersOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeDomainControllersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeDomainControllersOutputResponse`
    public func describeDomainControllersPaginated(input: DescribeDomainControllersInput) -> ClientRuntime.PaginatorSequence<DescribeDomainControllersInput, DescribeDomainControllersOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeDomainControllersInput, DescribeDomainControllersOutputResponse>(input: input, inputKey: \DescribeDomainControllersInput.nextToken, outputKey: \DescribeDomainControllersOutputResponse.nextToken, paginationFunction: self.describeDomainControllers(input:))
    }
}

extension DescribeDomainControllersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDomainControllersInput {
        return DescribeDomainControllersInput(
            directoryId: self.directoryId,
            domainControllerIds: self.domainControllerIds,
            limit: self.limit,
            nextToken: token
        )}
}
extension DirectoryClient {
    /// Paginate over `[DescribeLDAPSSettingsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeLDAPSSettingsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeLDAPSSettingsOutputResponse`
    public func describeLDAPSSettingsPaginated(input: DescribeLDAPSSettingsInput) -> ClientRuntime.PaginatorSequence<DescribeLDAPSSettingsInput, DescribeLDAPSSettingsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeLDAPSSettingsInput, DescribeLDAPSSettingsOutputResponse>(input: input, inputKey: \DescribeLDAPSSettingsInput.nextToken, outputKey: \DescribeLDAPSSettingsOutputResponse.nextToken, paginationFunction: self.describeLDAPSSettings(input:))
    }
}

extension DescribeLDAPSSettingsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeLDAPSSettingsInput {
        return DescribeLDAPSSettingsInput(
            directoryId: self.directoryId,
            limit: self.limit,
            nextToken: token,
            type: self.type
        )}
}

extension PaginatorSequence where Input == DescribeLDAPSSettingsInput, Output == DescribeLDAPSSettingsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeLDAPSSettingsPaginated`
    /// to access the nested member `[DirectoryClientTypes.LDAPSSettingInfo]`
    /// - Returns: `[DirectoryClientTypes.LDAPSSettingInfo]`
    public func ldapsSettingsInfo() async throws -> [DirectoryClientTypes.LDAPSSettingInfo] {
        return try await self.asyncCompactMap { item in item.ldapsSettingsInfo }
    }
}
extension DirectoryClient {
    /// Paginate over `[DescribeRegionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeRegionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeRegionsOutputResponse`
    public func describeRegionsPaginated(input: DescribeRegionsInput) -> ClientRuntime.PaginatorSequence<DescribeRegionsInput, DescribeRegionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeRegionsInput, DescribeRegionsOutputResponse>(input: input, inputKey: \DescribeRegionsInput.nextToken, outputKey: \DescribeRegionsOutputResponse.nextToken, paginationFunction: self.describeRegions(input:))
    }
}

extension DescribeRegionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeRegionsInput {
        return DescribeRegionsInput(
            directoryId: self.directoryId,
            nextToken: token,
            regionName: self.regionName
        )}
}

extension PaginatorSequence where Input == DescribeRegionsInput, Output == DescribeRegionsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeRegionsPaginated`
    /// to access the nested member `[DirectoryClientTypes.RegionDescription]`
    /// - Returns: `[DirectoryClientTypes.RegionDescription]`
    public func regionsDescription() async throws -> [DirectoryClientTypes.RegionDescription] {
        return try await self.asyncCompactMap { item in item.regionsDescription }
    }
}
extension DirectoryClient {
    /// Paginate over `[DescribeSharedDirectoriesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeSharedDirectoriesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeSharedDirectoriesOutputResponse`
    public func describeSharedDirectoriesPaginated(input: DescribeSharedDirectoriesInput) -> ClientRuntime.PaginatorSequence<DescribeSharedDirectoriesInput, DescribeSharedDirectoriesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeSharedDirectoriesInput, DescribeSharedDirectoriesOutputResponse>(input: input, inputKey: \DescribeSharedDirectoriesInput.nextToken, outputKey: \DescribeSharedDirectoriesOutputResponse.nextToken, paginationFunction: self.describeSharedDirectories(input:))
    }
}

extension DescribeSharedDirectoriesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeSharedDirectoriesInput {
        return DescribeSharedDirectoriesInput(
            limit: self.limit,
            nextToken: token,
            ownerDirectoryId: self.ownerDirectoryId,
            sharedDirectoryIds: self.sharedDirectoryIds
        )}
}

extension PaginatorSequence where Input == DescribeSharedDirectoriesInput, Output == DescribeSharedDirectoriesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeSharedDirectoriesPaginated`
    /// to access the nested member `[DirectoryClientTypes.SharedDirectory]`
    /// - Returns: `[DirectoryClientTypes.SharedDirectory]`
    public func sharedDirectories() async throws -> [DirectoryClientTypes.SharedDirectory] {
        return try await self.asyncCompactMap { item in item.sharedDirectories }
    }
}
extension DirectoryClient {
    /// Paginate over `[DescribeSnapshotsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeSnapshotsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeSnapshotsOutputResponse`
    public func describeSnapshotsPaginated(input: DescribeSnapshotsInput) -> ClientRuntime.PaginatorSequence<DescribeSnapshotsInput, DescribeSnapshotsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeSnapshotsInput, DescribeSnapshotsOutputResponse>(input: input, inputKey: \DescribeSnapshotsInput.nextToken, outputKey: \DescribeSnapshotsOutputResponse.nextToken, paginationFunction: self.describeSnapshots(input:))
    }
}

extension DescribeSnapshotsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeSnapshotsInput {
        return DescribeSnapshotsInput(
            directoryId: self.directoryId,
            limit: self.limit,
            nextToken: token,
            snapshotIds: self.snapshotIds
        )}
}

extension PaginatorSequence where Input == DescribeSnapshotsInput, Output == DescribeSnapshotsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeSnapshotsPaginated`
    /// to access the nested member `[DirectoryClientTypes.Snapshot]`
    /// - Returns: `[DirectoryClientTypes.Snapshot]`
    public func snapshots() async throws -> [DirectoryClientTypes.Snapshot] {
        return try await self.asyncCompactMap { item in item.snapshots }
    }
}
extension DirectoryClient {
    /// Paginate over `[DescribeTrustsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeTrustsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeTrustsOutputResponse`
    public func describeTrustsPaginated(input: DescribeTrustsInput) -> ClientRuntime.PaginatorSequence<DescribeTrustsInput, DescribeTrustsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeTrustsInput, DescribeTrustsOutputResponse>(input: input, inputKey: \DescribeTrustsInput.nextToken, outputKey: \DescribeTrustsOutputResponse.nextToken, paginationFunction: self.describeTrusts(input:))
    }
}

extension DescribeTrustsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeTrustsInput {
        return DescribeTrustsInput(
            directoryId: self.directoryId,
            limit: self.limit,
            nextToken: token,
            trustIds: self.trustIds
        )}
}

extension PaginatorSequence where Input == DescribeTrustsInput, Output == DescribeTrustsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeTrustsPaginated`
    /// to access the nested member `[DirectoryClientTypes.Trust]`
    /// - Returns: `[DirectoryClientTypes.Trust]`
    public func trusts() async throws -> [DirectoryClientTypes.Trust] {
        return try await self.asyncCompactMap { item in item.trusts }
    }
}
extension DirectoryClient {
    /// Paginate over `[DescribeUpdateDirectoryOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeUpdateDirectoryInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeUpdateDirectoryOutputResponse`
    public func describeUpdateDirectoryPaginated(input: DescribeUpdateDirectoryInput) -> ClientRuntime.PaginatorSequence<DescribeUpdateDirectoryInput, DescribeUpdateDirectoryOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeUpdateDirectoryInput, DescribeUpdateDirectoryOutputResponse>(input: input, inputKey: \DescribeUpdateDirectoryInput.nextToken, outputKey: \DescribeUpdateDirectoryOutputResponse.nextToken, paginationFunction: self.describeUpdateDirectory(input:))
    }
}

extension DescribeUpdateDirectoryInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeUpdateDirectoryInput {
        return DescribeUpdateDirectoryInput(
            directoryId: self.directoryId,
            nextToken: token,
            regionName: self.regionName,
            updateType: self.updateType
        )}
}

extension PaginatorSequence where Input == DescribeUpdateDirectoryInput, Output == DescribeUpdateDirectoryOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeUpdateDirectoryPaginated`
    /// to access the nested member `[DirectoryClientTypes.UpdateInfoEntry]`
    /// - Returns: `[DirectoryClientTypes.UpdateInfoEntry]`
    public func updateActivities() async throws -> [DirectoryClientTypes.UpdateInfoEntry] {
        return try await self.asyncCompactMap { item in item.updateActivities }
    }
}
extension DirectoryClient {
    /// Paginate over `[ListCertificatesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListCertificatesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListCertificatesOutputResponse`
    public func listCertificatesPaginated(input: ListCertificatesInput) -> ClientRuntime.PaginatorSequence<ListCertificatesInput, ListCertificatesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListCertificatesInput, ListCertificatesOutputResponse>(input: input, inputKey: \ListCertificatesInput.nextToken, outputKey: \ListCertificatesOutputResponse.nextToken, paginationFunction: self.listCertificates(input:))
    }
}

extension ListCertificatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCertificatesInput {
        return ListCertificatesInput(
            directoryId: self.directoryId,
            limit: self.limit,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListCertificatesInput, Output == ListCertificatesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listCertificatesPaginated`
    /// to access the nested member `[DirectoryClientTypes.CertificateInfo]`
    /// - Returns: `[DirectoryClientTypes.CertificateInfo]`
    public func certificatesInfo() async throws -> [DirectoryClientTypes.CertificateInfo] {
        return try await self.asyncCompactMap { item in item.certificatesInfo }
    }
}
extension DirectoryClient {
    /// Paginate over `[ListIpRoutesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListIpRoutesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListIpRoutesOutputResponse`
    public func listIpRoutesPaginated(input: ListIpRoutesInput) -> ClientRuntime.PaginatorSequence<ListIpRoutesInput, ListIpRoutesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListIpRoutesInput, ListIpRoutesOutputResponse>(input: input, inputKey: \ListIpRoutesInput.nextToken, outputKey: \ListIpRoutesOutputResponse.nextToken, paginationFunction: self.listIpRoutes(input:))
    }
}

extension ListIpRoutesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListIpRoutesInput {
        return ListIpRoutesInput(
            directoryId: self.directoryId,
            limit: self.limit,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListIpRoutesInput, Output == ListIpRoutesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listIpRoutesPaginated`
    /// to access the nested member `[DirectoryClientTypes.IpRouteInfo]`
    /// - Returns: `[DirectoryClientTypes.IpRouteInfo]`
    public func ipRoutesInfo() async throws -> [DirectoryClientTypes.IpRouteInfo] {
        return try await self.asyncCompactMap { item in item.ipRoutesInfo }
    }
}
extension DirectoryClient {
    /// Paginate over `[ListLogSubscriptionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListLogSubscriptionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListLogSubscriptionsOutputResponse`
    public func listLogSubscriptionsPaginated(input: ListLogSubscriptionsInput) -> ClientRuntime.PaginatorSequence<ListLogSubscriptionsInput, ListLogSubscriptionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListLogSubscriptionsInput, ListLogSubscriptionsOutputResponse>(input: input, inputKey: \ListLogSubscriptionsInput.nextToken, outputKey: \ListLogSubscriptionsOutputResponse.nextToken, paginationFunction: self.listLogSubscriptions(input:))
    }
}

extension ListLogSubscriptionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListLogSubscriptionsInput {
        return ListLogSubscriptionsInput(
            directoryId: self.directoryId,
            limit: self.limit,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListLogSubscriptionsInput, Output == ListLogSubscriptionsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listLogSubscriptionsPaginated`
    /// to access the nested member `[DirectoryClientTypes.LogSubscription]`
    /// - Returns: `[DirectoryClientTypes.LogSubscription]`
    public func logSubscriptions() async throws -> [DirectoryClientTypes.LogSubscription] {
        return try await self.asyncCompactMap { item in item.logSubscriptions }
    }
}
extension DirectoryClient {
    /// Paginate over `[ListSchemaExtensionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSchemaExtensionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSchemaExtensionsOutputResponse`
    public func listSchemaExtensionsPaginated(input: ListSchemaExtensionsInput) -> ClientRuntime.PaginatorSequence<ListSchemaExtensionsInput, ListSchemaExtensionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListSchemaExtensionsInput, ListSchemaExtensionsOutputResponse>(input: input, inputKey: \ListSchemaExtensionsInput.nextToken, outputKey: \ListSchemaExtensionsOutputResponse.nextToken, paginationFunction: self.listSchemaExtensions(input:))
    }
}

extension ListSchemaExtensionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSchemaExtensionsInput {
        return ListSchemaExtensionsInput(
            directoryId: self.directoryId,
            limit: self.limit,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListSchemaExtensionsInput, Output == ListSchemaExtensionsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listSchemaExtensionsPaginated`
    /// to access the nested member `[DirectoryClientTypes.SchemaExtensionInfo]`
    /// - Returns: `[DirectoryClientTypes.SchemaExtensionInfo]`
    public func schemaExtensionsInfo() async throws -> [DirectoryClientTypes.SchemaExtensionInfo] {
        return try await self.asyncCompactMap { item in item.schemaExtensionsInfo }
    }
}
extension DirectoryClient {
    /// Paginate over `[ListTagsForResourceOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTagsForResourceInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTagsForResourceOutputResponse`
    public func listTagsForResourcePaginated(input: ListTagsForResourceInput) -> ClientRuntime.PaginatorSequence<ListTagsForResourceInput, ListTagsForResourceOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTagsForResourceInput, ListTagsForResourceOutputResponse>(input: input, inputKey: \ListTagsForResourceInput.nextToken, outputKey: \ListTagsForResourceOutputResponse.nextToken, paginationFunction: self.listTagsForResource(input:))
    }
}

extension ListTagsForResourceInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTagsForResourceInput {
        return ListTagsForResourceInput(
            limit: self.limit,
            nextToken: token,
            resourceId: self.resourceId
        )}
}

extension PaginatorSequence where Input == ListTagsForResourceInput, Output == ListTagsForResourceOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listTagsForResourcePaginated`
    /// to access the nested member `[DirectoryClientTypes.Tag]`
    /// - Returns: `[DirectoryClientTypes.Tag]`
    public func tags() async throws -> [DirectoryClientTypes.Tag] {
        return try await self.asyncCompactMap { item in item.tags }
    }
}
