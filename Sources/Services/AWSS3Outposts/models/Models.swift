// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Access was denied for this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There was a conflict with this action, and it could not be completed.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessType = "AccessType"
        case customerOwnedIpv4Pool = "CustomerOwnedIpv4Pool"
        case outpostId = "OutpostId"
        case securityGroupId = "SecurityGroupId"
        case subnetId = "SubnetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessType = self.accessType {
            try encodeContainer.encode(accessType.rawValue, forKey: .accessType)
        }
        if let customerOwnedIpv4Pool = self.customerOwnedIpv4Pool {
            try encodeContainer.encode(customerOwnedIpv4Pool, forKey: .customerOwnedIpv4Pool)
        }
        if let outpostId = self.outpostId {
            try encodeContainer.encode(outpostId, forKey: .outpostId)
        }
        if let securityGroupId = self.securityGroupId {
            try encodeContainer.encode(securityGroupId, forKey: .securityGroupId)
        }
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
    }
}

extension CreateEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/S3Outposts/CreateEndpoint"
    }
}

public struct CreateEndpointInput: Swift.Equatable {
    /// The type of access for the network connectivity for the Amazon S3 on Outposts endpoint. To use the Amazon Web Services VPC, choose Private. To use the endpoint with an on-premises network, choose CustomerOwnedIp. If you choose CustomerOwnedIp, you must also provide the customer-owned IP address pool (CoIP pool). Private is the default access type value.
    public var accessType: S3OutpostsClientTypes.EndpointAccessType?
    /// The ID of the customer-owned IPv4 address pool (CoIP pool) for the endpoint. IP addresses are allocated from this pool for the endpoint.
    public var customerOwnedIpv4Pool: Swift.String?
    /// The ID of the Outposts.
    /// This member is required.
    public var outpostId: Swift.String?
    /// The ID of the security group to use with the endpoint.
    /// This member is required.
    public var securityGroupId: Swift.String?
    /// The ID of the subnet in the selected VPC. The endpoint subnet must belong to the Outpost that has Amazon S3 on Outposts provisioned.
    /// This member is required.
    public var subnetId: Swift.String?

    public init(
        accessType: S3OutpostsClientTypes.EndpointAccessType? = nil,
        customerOwnedIpv4Pool: Swift.String? = nil,
        outpostId: Swift.String? = nil,
        securityGroupId: Swift.String? = nil,
        subnetId: Swift.String? = nil
    )
    {
        self.accessType = accessType
        self.customerOwnedIpv4Pool = customerOwnedIpv4Pool
        self.outpostId = outpostId
        self.securityGroupId = securityGroupId
        self.subnetId = subnetId
    }
}

struct CreateEndpointInputBody: Swift.Equatable {
    let outpostId: Swift.String?
    let subnetId: Swift.String?
    let securityGroupId: Swift.String?
    let accessType: S3OutpostsClientTypes.EndpointAccessType?
    let customerOwnedIpv4Pool: Swift.String?
}

extension CreateEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessType = "AccessType"
        case customerOwnedIpv4Pool = "CustomerOwnedIpv4Pool"
        case outpostId = "OutpostId"
        case securityGroupId = "SecurityGroupId"
        case subnetId = "SubnetId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outpostIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outpostId)
        outpostId = outpostIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let securityGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityGroupId)
        securityGroupId = securityGroupIdDecoded
        let accessTypeDecoded = try containerValues.decodeIfPresent(S3OutpostsClientTypes.EndpointAccessType.self, forKey: .accessType)
        accessType = accessTypeDecoded
        let customerOwnedIpv4PoolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerOwnedIpv4Pool)
        customerOwnedIpv4Pool = customerOwnedIpv4PoolDecoded
    }
}

extension CreateEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.endpointArn = output.endpointArn
        } else {
            self.endpointArn = nil
        }
    }
}

public struct CreateEndpointOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the endpoint.
    public var endpointArn: Swift.String?

    public init(
        endpointArn: Swift.String? = nil
    )
    {
        self.endpointArn = endpointArn
    }
}

struct CreateEndpointOutputBody: Swift.Equatable {
    let endpointArn: Swift.String?
}

extension CreateEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
    }
}

enum CreateEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OutpostOfflineException": return try await OutpostOfflineException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteEndpointInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let outpostId = outpostId else {
                let message = "Creating a URL Query Item failed. outpostId is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let outpostIdQueryItem = ClientRuntime.URLQueryItem(name: "outpostId".urlPercentEncoding(), value: Swift.String(outpostId).urlPercentEncoding())
            items.append(outpostIdQueryItem)
            guard let endpointId = endpointId else {
                let message = "Creating a URL Query Item failed. endpointId is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let endpointIdQueryItem = ClientRuntime.URLQueryItem(name: "endpointId".urlPercentEncoding(), value: Swift.String(endpointId).urlPercentEncoding())
            items.append(endpointIdQueryItem)
            return items
        }
    }
}

extension DeleteEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/S3Outposts/DeleteEndpoint"
    }
}

public struct DeleteEndpointInput: Swift.Equatable {
    /// The ID of the endpoint.
    /// This member is required.
    public var endpointId: Swift.String?
    /// The ID of the Outposts.
    /// This member is required.
    public var outpostId: Swift.String?

    public init(
        endpointId: Swift.String? = nil,
        outpostId: Swift.String? = nil
    )
    {
        self.endpointId = endpointId
        self.outpostId = outpostId
    }
}

struct DeleteEndpointInputBody: Swift.Equatable {
}

extension DeleteEndpointInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteEndpointOutput: Swift.Equatable {

    public init() { }
}

enum DeleteEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OutpostOfflineException": return try await OutpostOfflineException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension S3OutpostsClientTypes.Endpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessType = "AccessType"
        case cidrBlock = "CidrBlock"
        case creationTime = "CreationTime"
        case customerOwnedIpv4Pool = "CustomerOwnedIpv4Pool"
        case endpointArn = "EndpointArn"
        case failedReason = "FailedReason"
        case networkInterfaces = "NetworkInterfaces"
        case outpostsId = "OutpostsId"
        case securityGroupId = "SecurityGroupId"
        case status = "Status"
        case subnetId = "SubnetId"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessType = self.accessType {
            try encodeContainer.encode(accessType.rawValue, forKey: .accessType)
        }
        if let cidrBlock = self.cidrBlock {
            try encodeContainer.encode(cidrBlock, forKey: .cidrBlock)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let customerOwnedIpv4Pool = self.customerOwnedIpv4Pool {
            try encodeContainer.encode(customerOwnedIpv4Pool, forKey: .customerOwnedIpv4Pool)
        }
        if let endpointArn = self.endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
        if let failedReason = self.failedReason {
            try encodeContainer.encode(failedReason, forKey: .failedReason)
        }
        if let networkInterfaces = networkInterfaces {
            var networkInterfacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkInterfaces)
            for networkinterface0 in networkInterfaces {
                try networkInterfacesContainer.encode(networkinterface0)
            }
        }
        if let outpostsId = self.outpostsId {
            try encodeContainer.encode(outpostsId, forKey: .outpostsId)
        }
        if let securityGroupId = self.securityGroupId {
            try encodeContainer.encode(securityGroupId, forKey: .securityGroupId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
        let outpostsIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outpostsId)
        outpostsId = outpostsIdDecoded
        let cidrBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cidrBlock)
        cidrBlock = cidrBlockDecoded
        let statusDecoded = try containerValues.decodeIfPresent(S3OutpostsClientTypes.EndpointStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let networkInterfacesContainer = try containerValues.decodeIfPresent([S3OutpostsClientTypes.NetworkInterface?].self, forKey: .networkInterfaces)
        var networkInterfacesDecoded0:[S3OutpostsClientTypes.NetworkInterface]? = nil
        if let networkInterfacesContainer = networkInterfacesContainer {
            networkInterfacesDecoded0 = [S3OutpostsClientTypes.NetworkInterface]()
            for structure0 in networkInterfacesContainer {
                if let structure0 = structure0 {
                    networkInterfacesDecoded0?.append(structure0)
                }
            }
        }
        networkInterfaces = networkInterfacesDecoded0
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let securityGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityGroupId)
        securityGroupId = securityGroupIdDecoded
        let accessTypeDecoded = try containerValues.decodeIfPresent(S3OutpostsClientTypes.EndpointAccessType.self, forKey: .accessType)
        accessType = accessTypeDecoded
        let customerOwnedIpv4PoolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerOwnedIpv4Pool)
        customerOwnedIpv4Pool = customerOwnedIpv4PoolDecoded
        let failedReasonDecoded = try containerValues.decodeIfPresent(S3OutpostsClientTypes.FailedReason.self, forKey: .failedReason)
        failedReason = failedReasonDecoded
    }
}

extension S3OutpostsClientTypes {
    /// Amazon S3 on Outposts Access Points simplify managing data access at scale for shared datasets in S3 on Outposts. S3 on Outposts uses endpoints to connect to Outposts buckets so that you can perform actions within your virtual private cloud (VPC). For more information, see [ Accessing S3 on Outposts using VPC-only access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/WorkingWithS3Outposts.html) in the Amazon Simple Storage Service User Guide.
    public struct Endpoint: Swift.Equatable {
        /// The type of connectivity used to access the Amazon S3 on Outposts endpoint.
        public var accessType: S3OutpostsClientTypes.EndpointAccessType?
        /// The VPC CIDR committed by this endpoint.
        public var cidrBlock: Swift.String?
        /// The time the endpoint was created.
        public var creationTime: ClientRuntime.Date?
        /// The ID of the customer-owned IPv4 address pool used for the endpoint.
        public var customerOwnedIpv4Pool: Swift.String?
        /// The Amazon Resource Name (ARN) of the endpoint.
        public var endpointArn: Swift.String?
        /// The failure reason, if any, for a create or delete endpoint operation.
        public var failedReason: S3OutpostsClientTypes.FailedReason?
        /// The network interface of the endpoint.
        public var networkInterfaces: [S3OutpostsClientTypes.NetworkInterface]?
        /// The ID of the Outposts.
        public var outpostsId: Swift.String?
        /// The ID of the security group used for the endpoint.
        public var securityGroupId: Swift.String?
        /// The status of the endpoint.
        public var status: S3OutpostsClientTypes.EndpointStatus?
        /// The ID of the subnet used for the endpoint.
        public var subnetId: Swift.String?
        /// The ID of the VPC used for the endpoint.
        public var vpcId: Swift.String?

        public init(
            accessType: S3OutpostsClientTypes.EndpointAccessType? = nil,
            cidrBlock: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            customerOwnedIpv4Pool: Swift.String? = nil,
            endpointArn: Swift.String? = nil,
            failedReason: S3OutpostsClientTypes.FailedReason? = nil,
            networkInterfaces: [S3OutpostsClientTypes.NetworkInterface]? = nil,
            outpostsId: Swift.String? = nil,
            securityGroupId: Swift.String? = nil,
            status: S3OutpostsClientTypes.EndpointStatus? = nil,
            subnetId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.accessType = accessType
            self.cidrBlock = cidrBlock
            self.creationTime = creationTime
            self.customerOwnedIpv4Pool = customerOwnedIpv4Pool
            self.endpointArn = endpointArn
            self.failedReason = failedReason
            self.networkInterfaces = networkInterfaces
            self.outpostsId = outpostsId
            self.securityGroupId = securityGroupId
            self.status = status
            self.subnetId = subnetId
            self.vpcId = vpcId
        }
    }

}

extension S3OutpostsClientTypes {
    public enum EndpointAccessType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case customerOwnedIp
        case `private`
        case sdkUnknown(Swift.String)

        public static var allCases: [EndpointAccessType] {
            return [
                .customerOwnedIp,
                .private,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .customerOwnedIp: return "CustomerOwnedIp"
            case .private: return "Private"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EndpointAccessType(rawValue: rawValue) ?? EndpointAccessType.sdkUnknown(rawValue)
        }
    }
}

extension S3OutpostsClientTypes {
    public enum EndpointStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case createFailed
        case deleteFailed
        case deleting
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [EndpointStatus] {
            return [
                .available,
                .createFailed,
                .deleteFailed,
                .deleting,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "Available"
            case .createFailed: return "Create_Failed"
            case .deleteFailed: return "Delete_Failed"
            case .deleting: return "Deleting"
            case .pending: return "Pending"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EndpointStatus(rawValue: rawValue) ?? EndpointStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3OutpostsClientTypes.FailedReason: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension S3OutpostsClientTypes {
    /// The failure reason, if any, for a create or delete endpoint operation.
    public struct FailedReason: Swift.Equatable {
        /// The failure code, if any, for a create or delete endpoint operation.
        public var errorCode: Swift.String?
        /// Additional error details describing the endpoint failure and recommended action.
        public var message: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.message = message
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There was an exception with the internal server.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListEndpointsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListEndpointsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/S3Outposts/ListEndpoints"
    }
}

public struct ListEndpointsInput: Swift.Equatable {
    /// The maximum number of endpoints that will be returned in the response.
    public var maxResults: Swift.Int?
    /// If a previous response from this operation included a NextToken value, provide that value here to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEndpointsInputBody: Swift.Equatable {
}

extension ListEndpointsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListEndpointsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEndpointsOutputBody = try responseDecoder.decode(responseBody: data)
            self.endpoints = output.endpoints
            self.nextToken = output.nextToken
        } else {
            self.endpoints = nil
            self.nextToken = nil
        }
    }
}

public struct ListEndpointsOutput: Swift.Equatable {
    /// The list of endpoints associated with the specified Outpost.
    public var endpoints: [S3OutpostsClientTypes.Endpoint]?
    /// If the number of endpoints associated with the specified Outpost exceeds MaxResults, you can include this value in subsequent calls to this operation to retrieve more results.
    public var nextToken: Swift.String?

    public init(
        endpoints: [S3OutpostsClientTypes.Endpoint]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.endpoints = endpoints
        self.nextToken = nextToken
    }
}

struct ListEndpointsOutputBody: Swift.Equatable {
    let endpoints: [S3OutpostsClientTypes.Endpoint]?
    let nextToken: Swift.String?
}

extension ListEndpointsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoints = "Endpoints"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointsContainer = try containerValues.decodeIfPresent([S3OutpostsClientTypes.Endpoint?].self, forKey: .endpoints)
        var endpointsDecoded0:[S3OutpostsClientTypes.Endpoint]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [S3OutpostsClientTypes.Endpoint]()
            for structure0 in endpointsContainer {
                if let structure0 = structure0 {
                    endpointsDecoded0?.append(structure0)
                }
            }
        }
        endpoints = endpointsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEndpointsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListOutpostsWithS3Input: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListOutpostsWithS3Input: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/S3Outposts/ListOutpostsWithS3"
    }
}

public struct ListOutpostsWithS3Input: Swift.Equatable {
    /// The maximum number of Outposts to return. The limit is 100.
    public var maxResults: Swift.Int?
    /// When you can get additional results from the ListOutpostsWithS3 call, a NextToken parameter is returned in the output. You can then pass in a subsequent command to the NextToken parameter to continue listing additional Outposts.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListOutpostsWithS3InputBody: Swift.Equatable {
}

extension ListOutpostsWithS3InputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListOutpostsWithS3Output: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListOutpostsWithS3OutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.outposts = output.outposts
        } else {
            self.nextToken = nil
            self.outposts = nil
        }
    }
}

public struct ListOutpostsWithS3Output: Swift.Equatable {
    /// Returns a token that you can use to call ListOutpostsWithS3 again and receive additional results, if there are any.
    public var nextToken: Swift.String?
    /// Returns the list of Outposts that have the following characteristics:
    ///
    /// * outposts that have S3 provisioned
    ///
    /// * outposts that are Active (not pending any provisioning nor decommissioned)
    ///
    /// * outposts to which the the calling Amazon Web Services account has access
    public var outposts: [S3OutpostsClientTypes.Outpost]?

    public init(
        nextToken: Swift.String? = nil,
        outposts: [S3OutpostsClientTypes.Outpost]? = nil
    )
    {
        self.nextToken = nextToken
        self.outposts = outposts
    }
}

struct ListOutpostsWithS3OutputBody: Swift.Equatable {
    let outposts: [S3OutpostsClientTypes.Outpost]?
    let nextToken: Swift.String?
}

extension ListOutpostsWithS3OutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case outposts = "Outposts"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outpostsContainer = try containerValues.decodeIfPresent([S3OutpostsClientTypes.Outpost?].self, forKey: .outposts)
        var outpostsDecoded0:[S3OutpostsClientTypes.Outpost]? = nil
        if let outpostsContainer = outpostsContainer {
            outpostsDecoded0 = [S3OutpostsClientTypes.Outpost]()
            for structure0 in outpostsContainer {
                if let structure0 = structure0 {
                    outpostsDecoded0?.append(structure0)
                }
            }
        }
        outposts = outpostsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListOutpostsWithS3OutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSharedEndpointsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let outpostId = outpostId else {
                let message = "Creating a URL Query Item failed. outpostId is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let outpostIdQueryItem = ClientRuntime.URLQueryItem(name: "outpostId".urlPercentEncoding(), value: Swift.String(outpostId).urlPercentEncoding())
            items.append(outpostIdQueryItem)
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListSharedEndpointsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/S3Outposts/ListSharedEndpoints"
    }
}

public struct ListSharedEndpointsInput: Swift.Equatable {
    /// The maximum number of endpoints that will be returned in the response.
    public var maxResults: Swift.Int?
    /// If a previous response from this operation included a NextToken value, you can provide that value here to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The ID of the Amazon Web Services Outpost.
    /// This member is required.
    public var outpostId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        outpostId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.outpostId = outpostId
    }
}

struct ListSharedEndpointsInputBody: Swift.Equatable {
}

extension ListSharedEndpointsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSharedEndpointsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSharedEndpointsOutputBody = try responseDecoder.decode(responseBody: data)
            self.endpoints = output.endpoints
            self.nextToken = output.nextToken
        } else {
            self.endpoints = nil
            self.nextToken = nil
        }
    }
}

public struct ListSharedEndpointsOutput: Swift.Equatable {
    /// The list of endpoints associated with the specified Outpost that have been shared by Amazon Web Services Resource Access Manager (RAM).
    public var endpoints: [S3OutpostsClientTypes.Endpoint]?
    /// If the number of endpoints associated with the specified Outpost exceeds MaxResults, you can include this value in subsequent calls to this operation to retrieve more results.
    public var nextToken: Swift.String?

    public init(
        endpoints: [S3OutpostsClientTypes.Endpoint]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.endpoints = endpoints
        self.nextToken = nextToken
    }
}

struct ListSharedEndpointsOutputBody: Swift.Equatable {
    let endpoints: [S3OutpostsClientTypes.Endpoint]?
    let nextToken: Swift.String?
}

extension ListSharedEndpointsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoints = "Endpoints"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointsContainer = try containerValues.decodeIfPresent([S3OutpostsClientTypes.Endpoint?].self, forKey: .endpoints)
        var endpointsDecoded0:[S3OutpostsClientTypes.Endpoint]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [S3OutpostsClientTypes.Endpoint]()
            for structure0 in endpointsContainer {
                if let structure0 = structure0 {
                    endpointsDecoded0?.append(structure0)
                }
            }
        }
        endpoints = endpointsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSharedEndpointsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension S3OutpostsClientTypes.NetworkInterface: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkInterfaceId = "NetworkInterfaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let networkInterfaceId = self.networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
    }
}

extension S3OutpostsClientTypes {
    /// The container for the network interface.
    public struct NetworkInterface: Swift.Equatable {
        /// The ID for the network interface.
        public var networkInterfaceId: Swift.String?

        public init(
            networkInterfaceId: Swift.String? = nil
        )
        {
            self.networkInterfaceId = networkInterfaceId
        }
    }

}

extension S3OutpostsClientTypes.Outpost: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacityInBytes = "CapacityInBytes"
        case outpostArn = "OutpostArn"
        case outpostId = "OutpostId"
        case ownerId = "OwnerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if capacityInBytes != 0 {
            try encodeContainer.encode(capacityInBytes, forKey: .capacityInBytes)
        }
        if let outpostArn = self.outpostArn {
            try encodeContainer.encode(outpostArn, forKey: .outpostArn)
        }
        if let outpostId = self.outpostId {
            try encodeContainer.encode(outpostId, forKey: .outpostId)
        }
        if let ownerId = self.ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outpostArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outpostArn)
        outpostArn = outpostArnDecoded
        let outpostIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outpostId)
        outpostId = outpostIdDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let capacityInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .capacityInBytes) ?? 0
        capacityInBytes = capacityInBytesDecoded
    }
}

extension S3OutpostsClientTypes {
    /// Contains the details for the Outpost object.
    public struct Outpost: Swift.Equatable {
        /// The Amazon S3 capacity of the outpost in bytes.
        public var capacityInBytes: Swift.Int
        /// Specifies the unique Amazon Resource Name (ARN) for the outpost.
        public var outpostArn: Swift.String?
        /// Specifies the unique identifier for the outpost.
        public var outpostId: Swift.String?
        /// Returns the Amazon Web Services account ID of the outpost owner. Useful for comparing owned versus shared outposts.
        public var ownerId: Swift.String?

        public init(
            capacityInBytes: Swift.Int = 0,
            outpostArn: Swift.String? = nil,
            outpostId: Swift.String? = nil,
            ownerId: Swift.String? = nil
        )
        {
            self.capacityInBytes = capacityInBytes
            self.outpostArn = outpostArn
            self.outpostId = outpostId
            self.ownerId = ownerId
        }
    }

}

extension OutpostOfflineException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: OutpostOfflineExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service link connection to your Outposts home Region is down. Check your connection and try again.
public struct OutpostOfflineException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OutpostOfflineException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct OutpostOfflineExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OutpostOfflineExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The requested resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There was an exception validating this data.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
