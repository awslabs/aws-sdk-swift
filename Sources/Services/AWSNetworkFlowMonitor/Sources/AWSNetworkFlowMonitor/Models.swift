//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.timestampReadingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// You don't have sufficient permission to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The requested resource is in use.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// An internal error occurred.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request exceeded a service quota.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// Invalid request.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension NetworkFlowMonitorClientTypes {

    public enum MonitorLocalResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsAz
        case awsSubnet
        case awsVpc
        case sdkUnknown(Swift.String)

        public static var allCases: [MonitorLocalResourceType] {
            return [
                .awsAz,
                .awsSubnet,
                .awsVpc
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsAz: return "AWS::AvailabilityZone"
            case .awsSubnet: return "AWS::EC2::Subnet"
            case .awsVpc: return "AWS::EC2::VPC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NetworkFlowMonitorClientTypes {

    /// A local resource is the host where the agent is installed. Local resources can be a a subnet, a VPC, or an Availability Zone.
    public struct MonitorLocalResource: Swift.Sendable {
        /// The identifier of the local resource, such as an ARN.
        /// This member is required.
        public var identifier: Swift.String?
        /// The type of the local resource. Valid values are AWS::EC2::VPCAWS::AvailabilityZone or AWS::EC2::Subnet.
        /// This member is required.
        public var type: NetworkFlowMonitorClientTypes.MonitorLocalResourceType?

        public init(
            identifier: Swift.String? = nil,
            type: NetworkFlowMonitorClientTypes.MonitorLocalResourceType? = nil
        ) {
            self.identifier = identifier
            self.type = type
        }
    }
}

extension NetworkFlowMonitorClientTypes {

    public enum MonitorRemoteResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsAz
        case awsService
        case awsSubnet
        case awsVpc
        case sdkUnknown(Swift.String)

        public static var allCases: [MonitorRemoteResourceType] {
            return [
                .awsAz,
                .awsService,
                .awsSubnet,
                .awsVpc
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsAz: return "AWS::AvailabilityZone"
            case .awsService: return "AWS::AWSService"
            case .awsSubnet: return "AWS::EC2::Subnet"
            case .awsVpc: return "AWS::EC2::VPC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NetworkFlowMonitorClientTypes {

    /// A remote resource is the other endpoint in a network flow. That is, one endpoint is the local resource and the other is the remote resource. Remote resources can be a a subnet, a VPC, an Availability Zone, or an Amazon Web Services service.
    public struct MonitorRemoteResource: Swift.Sendable {
        /// The identifier of the remote resource, such as an ARN.
        /// This member is required.
        public var identifier: Swift.String?
        /// The type of the remote resource. Valid values are AWS::EC2::VPCAWS::AvailabilityZone, AWS::EC2::Subnet, or AWS::AWSService.
        /// This member is required.
        public var type: NetworkFlowMonitorClientTypes.MonitorRemoteResourceType?

        public init(
            identifier: Swift.String? = nil,
            type: NetworkFlowMonitorClientTypes.MonitorRemoteResourceType? = nil
        ) {
            self.identifier = identifier
            self.type = type
        }
    }
}

public struct CreateMonitorInput: Swift.Sendable {
    /// A unique, case-sensitive string of up to 64 ASCII characters that you specify to make an idempotent API request. Don't reuse the same client token for other API requests.
    public var clientToken: Swift.String?
    /// The local resources to monitor. A local resource, in a bi-directional flow of a workload, is the host where the agent is installed. For example, if a workload consists of an interaction between a web service and a backend database (for example, Amazon Relational Database Service (RDS)), the EC2 instance hosting the web service, which also runs the agent, is the local resource.
    /// This member is required.
    public var localResources: [NetworkFlowMonitorClientTypes.MonitorLocalResource]?
    /// The name of the monitor.
    /// This member is required.
    public var monitorName: Swift.String?
    /// The remote resources to monitor. A remote resource is the other endpoint in the bi-directional flow of a workload, with a local resource. For example, Amazon Relational Database Service (RDS) can be a remote resource.
    public var remoteResources: [NetworkFlowMonitorClientTypes.MonitorRemoteResource]?
    /// The Amazon Resource Name (ARN) of the scope for the monitor.
    /// This member is required.
    public var scopeArn: Swift.String?
    /// The tags for a monitor. You can add a maximum of 200 tags.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        localResources: [NetworkFlowMonitorClientTypes.MonitorLocalResource]? = nil,
        monitorName: Swift.String? = nil,
        remoteResources: [NetworkFlowMonitorClientTypes.MonitorRemoteResource]? = nil,
        scopeArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.clientToken = clientToken
        self.localResources = localResources
        self.monitorName = monitorName
        self.remoteResources = remoteResources
        self.scopeArn = scopeArn
        self.tags = tags
    }
}

extension NetworkFlowMonitorClientTypes {

    public enum MonitorStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deleting
        case error
        case inactive
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [MonitorStatus] {
            return [
                .active,
                .deleting,
                .error,
                .inactive,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleting: return "DELETING"
            case .error: return "ERROR"
            case .inactive: return "INACTIVE"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateMonitorOutput: Swift.Sendable {
    /// The date and time when the monitor was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The local resources to monitor. A local resource, in a bi-directional flow of a workload, is the host where the agent is installed.
    /// This member is required.
    public var localResources: [NetworkFlowMonitorClientTypes.MonitorLocalResource]?
    /// The last date and time that the monitor was modified.
    /// This member is required.
    public var modifiedAt: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the monitor.
    /// This member is required.
    public var monitorArn: Swift.String?
    /// The name of the monitor.
    /// This member is required.
    public var monitorName: Swift.String?
    /// The status of a monitor. The status can be one of the following
    ///
    /// * PENDING: The monitor is in the process of being created.
    ///
    /// * ACTIVE: The monitor is active.
    ///
    /// * INACTIVE: The monitor is inactive.
    ///
    /// * ERROR: Monitor creation failed due to an error.
    ///
    /// * DELETING: The monitor is in the process of being deleted.
    /// This member is required.
    public var monitorStatus: NetworkFlowMonitorClientTypes.MonitorStatus?
    /// The remote resources to monitor. A remote resource is the other endpoint in the bi-directional flow of a workload, with a local resource. For example, Amazon Relational Database Service (RDS) can be a remote resource. The remote resource is identified by its ARN or an identifier.
    /// This member is required.
    public var remoteResources: [NetworkFlowMonitorClientTypes.MonitorRemoteResource]?
    /// The tags for a monitor.
    public var tags: [Swift.String: Swift.String]?

    public init(
        createdAt: Foundation.Date? = nil,
        localResources: [NetworkFlowMonitorClientTypes.MonitorLocalResource]? = nil,
        modifiedAt: Foundation.Date? = nil,
        monitorArn: Swift.String? = nil,
        monitorName: Swift.String? = nil,
        monitorStatus: NetworkFlowMonitorClientTypes.MonitorStatus? = nil,
        remoteResources: [NetworkFlowMonitorClientTypes.MonitorRemoteResource]? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.createdAt = createdAt
        self.localResources = localResources
        self.modifiedAt = modifiedAt
        self.monitorArn = monitorArn
        self.monitorName = monitorName
        self.monitorStatus = monitorStatus
        self.remoteResources = remoteResources
        self.tags = tags
    }
}

extension NetworkFlowMonitorClientTypes {

    /// A target ID is an internally-generated identifier for a target. A target allows you to identify all the resources in a Network Flow Monitor scope. Currently, a target is always an Amazon Web Services account.
    public enum TargetId: Swift.Sendable {
        /// The identifier for the account for a target.
        case accountid(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension NetworkFlowMonitorClientTypes {

    public enum TargetType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case account
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetType] {
            return [
                .account
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .account: return "ACCOUNT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NetworkFlowMonitorClientTypes {

    /// A target identifier is a pair of identifying information for a resource that is included in a target. A target identifier includes the target ID and the target type.
    public struct TargetIdentifier: Swift.Sendable {
        /// The identifier for a target.
        /// This member is required.
        public var targetId: NetworkFlowMonitorClientTypes.TargetId?
        /// The type of a target. A target type is currently always ACCOUNT because a target is currently a single Amazon Web Services account.
        /// This member is required.
        public var targetType: NetworkFlowMonitorClientTypes.TargetType?

        public init(
            targetId: NetworkFlowMonitorClientTypes.TargetId? = nil,
            targetType: NetworkFlowMonitorClientTypes.TargetType? = nil
        ) {
            self.targetId = targetId
            self.targetType = targetType
        }
    }
}

extension NetworkFlowMonitorClientTypes {

    /// A target resource in a scope. The resource is identified by a Region and a target identifier, which includes a target ID and a target type.
    public struct TargetResource: Swift.Sendable {
        /// The Amazon Web Services Region where the target resource is located.
        /// This member is required.
        public var region: Swift.String?
        /// A target identifier is a pair of identifying information for a resource that is included in a target. A target identifier includes the target ID and the target type.
        /// This member is required.
        public var targetIdentifier: NetworkFlowMonitorClientTypes.TargetIdentifier?

        public init(
            region: Swift.String? = nil,
            targetIdentifier: NetworkFlowMonitorClientTypes.TargetIdentifier? = nil
        ) {
            self.region = region
            self.targetIdentifier = targetIdentifier
        }
    }
}

public struct CreateScopeInput: Swift.Sendable {
    /// A unique, case-sensitive string of up to 64 ASCII characters that you specify to make an idempotent API request. Don't reuse the same client token for other API requests.
    public var clientToken: Swift.String?
    /// The tags for a scope. You can add a maximum of 200 tags.
    public var tags: [Swift.String: Swift.String]?
    /// The targets to define the scope to be monitored. Currently, a target is an Amazon Web Services account.
    /// This member is required.
    public var targets: [NetworkFlowMonitorClientTypes.TargetResource]?

    public init(
        clientToken: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        targets: [NetworkFlowMonitorClientTypes.TargetResource]? = nil
    ) {
        self.clientToken = clientToken
        self.tags = tags
        self.targets = targets
    }
}

extension NetworkFlowMonitorClientTypes {

    public enum ScopeStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ScopeStatus] {
            return [
                .failed,
                .inProgress,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateScopeOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the scope.
    /// This member is required.
    public var scopeArn: Swift.String?
    /// The identifier for the scope that includes the resources you want to get metrics for. A scope ID is an internally-generated identifier that includes all the resources for a specific root account.
    /// This member is required.
    public var scopeId: Swift.String?
    /// The status for a call to create a scope. The status can be one of the following: SUCCEEDED, IN_PROGRESS, or FAILED.
    /// This member is required.
    public var status: NetworkFlowMonitorClientTypes.ScopeStatus?
    /// The tags for a scope.
    public var tags: [Swift.String: Swift.String]?

    public init(
        scopeArn: Swift.String? = nil,
        scopeId: Swift.String? = nil,
        status: NetworkFlowMonitorClientTypes.ScopeStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.scopeArn = scopeArn
        self.scopeId = scopeId
        self.status = status
        self.tags = tags
    }
}

/// The request specifies a resource that doesn't exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct DeleteMonitorInput: Swift.Sendable {
    /// The name of the monitor to delete.
    /// This member is required.
    public var monitorName: Swift.String?

    public init(
        monitorName: Swift.String? = nil
    ) {
        self.monitorName = monitorName
    }
}

public struct DeleteMonitorOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteScopeInput: Swift.Sendable {
    /// The identifier for the scope that includes the resources you want to get data results for. A scope ID is an internally-generated identifier that includes all the resources for a specific root account.
    /// This member is required.
    public var scopeId: Swift.String?

    public init(
        scopeId: Swift.String? = nil
    ) {
        self.scopeId = scopeId
    }
}

public struct DeleteScopeOutput: Swift.Sendable {

    public init() { }
}

extension NetworkFlowMonitorClientTypes {

    public enum DestinationCategory: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case amazonDynamodb
        case amazonS3
        case interAz
        case interVpc
        case intraAz
        case unclassified
        case sdkUnknown(Swift.String)

        public static var allCases: [DestinationCategory] {
            return [
                .amazonDynamodb,
                .amazonS3,
                .interAz,
                .interVpc,
                .intraAz,
                .unclassified
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .amazonDynamodb: return "AMAZON_DYNAMODB"
            case .amazonS3: return "AMAZON_S3"
            case .interAz: return "INTER_AZ"
            case .interVpc: return "INTER_VPC"
            case .intraAz: return "INTRA_AZ"
            case .unclassified: return "UNCLASSIFIED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetMonitorInput: Swift.Sendable {
    /// The name of the monitor.
    /// This member is required.
    public var monitorName: Swift.String?

    public init(
        monitorName: Swift.String? = nil
    ) {
        self.monitorName = monitorName
    }
}

public struct GetMonitorOutput: Swift.Sendable {
    /// The date and time when the monitor was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The local resources for this monitor.
    /// This member is required.
    public var localResources: [NetworkFlowMonitorClientTypes.MonitorLocalResource]?
    /// The date and time when the monitor was last modified.
    /// This member is required.
    public var modifiedAt: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the monitor.
    /// This member is required.
    public var monitorArn: Swift.String?
    /// The name of the monitor.
    /// This member is required.
    public var monitorName: Swift.String?
    /// The status of a monitor. The status can be one of the following
    ///
    /// * PENDING: The monitor is in the process of being created.
    ///
    /// * ACTIVE: The monitor is active.
    ///
    /// * INACTIVE: The monitor is inactive.
    ///
    /// * ERROR: Monitor creation failed due to an error.
    ///
    /// * DELETING: The monitor is in the process of being deleted.
    /// This member is required.
    public var monitorStatus: NetworkFlowMonitorClientTypes.MonitorStatus?
    /// The remote resources for this monitor.
    /// This member is required.
    public var remoteResources: [NetworkFlowMonitorClientTypes.MonitorRemoteResource]?
    /// The tags for a monitor.
    public var tags: [Swift.String: Swift.String]?

    public init(
        createdAt: Foundation.Date? = nil,
        localResources: [NetworkFlowMonitorClientTypes.MonitorLocalResource]? = nil,
        modifiedAt: Foundation.Date? = nil,
        monitorArn: Swift.String? = nil,
        monitorName: Swift.String? = nil,
        monitorStatus: NetworkFlowMonitorClientTypes.MonitorStatus? = nil,
        remoteResources: [NetworkFlowMonitorClientTypes.MonitorRemoteResource]? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.createdAt = createdAt
        self.localResources = localResources
        self.modifiedAt = modifiedAt
        self.monitorArn = monitorArn
        self.monitorName = monitorName
        self.monitorStatus = monitorStatus
        self.remoteResources = remoteResources
        self.tags = tags
    }
}

public struct GetQueryResultsMonitorTopContributorsInput: Swift.Sendable {
    /// The number of query results that you want to return with this call.
    public var maxResults: Swift.Int?
    /// The name of the monitor.
    /// This member is required.
    public var monitorName: Swift.String?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?
    /// The identifier for the query. A query ID is an internally-generated identifier for a specific query returned from an API call to start a query.
    /// This member is required.
    public var queryId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        monitorName: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        queryId: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.monitorName = monitorName
        self.nextToken = nextToken
        self.queryId = queryId
    }
}

extension NetworkFlowMonitorClientTypes {

    /// Meta data about Kubernetes resources.
    public struct KubernetesMetadata: Swift.Sendable {
        /// The name of the pod for a local resource.
        public var localPodName: Swift.String?
        /// The namespace of the pod for a local resource.
        public var localPodNamespace: Swift.String?
        /// The service name for a local resource.
        public var localServiceName: Swift.String?
        /// The name of the pod for a remote resource.
        public var remotePodName: Swift.String?
        /// The namespace of the pod for a remote resource.
        public var remotePodNamespace: Swift.String?
        /// The service name for a remote resource.
        public var remoteServiceName: Swift.String?

        public init(
            localPodName: Swift.String? = nil,
            localPodNamespace: Swift.String? = nil,
            localServiceName: Swift.String? = nil,
            remotePodName: Swift.String? = nil,
            remotePodNamespace: Swift.String? = nil,
            remoteServiceName: Swift.String? = nil
        ) {
            self.localPodName = localPodName
            self.localPodNamespace = localPodNamespace
            self.localServiceName = localServiceName
            self.remotePodName = remotePodName
            self.remotePodNamespace = remotePodNamespace
            self.remoteServiceName = remoteServiceName
        }
    }
}

extension NetworkFlowMonitorClientTypes {

    /// A section of the network that a network flow has traveled through.
    public struct TraversedComponent: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of a tranversed component.
        public var componentArn: Swift.String?
        /// The identifier for the traversed component.
        public var componentId: Swift.String?
        /// The type of component that was traversed.
        public var componentType: Swift.String?
        /// The service name for the traversed component.
        public var serviceName: Swift.String?

        public init(
            componentArn: Swift.String? = nil,
            componentId: Swift.String? = nil,
            componentType: Swift.String? = nil,
            serviceName: Swift.String? = nil
        ) {
            self.componentArn = componentArn
            self.componentId = componentId
            self.componentType = componentType
            self.serviceName = serviceName
        }
    }
}

extension NetworkFlowMonitorClientTypes {

    /// A set of information for a top contributor network flow in a monitor. In a monitor, Network Flow Monitor returns information about the network flows for top contributors for each metric. Top contributors are network flows with the top values for each metric type.
    public struct MonitorTopContributorsRow: Swift.Sendable {
        /// The destination category for a top contributors row. Destination categories can be one of the following:
        ///
        /// * INTRA_AZ: Top contributor network flows within a single Availability Zone
        ///
        /// * INTER_AZ: Top contributor network flows between Availability Zones
        ///
        /// * INTER_VPC: Top contributor network flows between VPCs
        ///
        /// * AWS_SERVICES: Top contributor network flows to or from Amazon Web Services services
        ///
        /// * UNCLASSIFIED: Top contributor network flows that do not have a bucket classification
        public var destinationCategory: NetworkFlowMonitorClientTypes.DestinationCategory?
        /// The destination network address translation (DNAT) IP address for a top contributor network flow.
        public var dnatIp: Swift.String?
        /// Meta data about Kubernetes resources.
        public var kubernetesMetadata: NetworkFlowMonitorClientTypes.KubernetesMetadata?
        /// The Availability Zone for the local resource for a top contributor network flow.
        public var localAz: Swift.String?
        /// The Amazon Resource Name (ARN) of a local resource.
        public var localInstanceArn: Swift.String?
        /// The instance identifier for the local resource for a top contributor network flow.
        public var localInstanceId: Swift.String?
        /// The IP address of the local resource for a top contributor network flow.
        public var localIp: Swift.String?
        /// The Amazon Web Services Region for the local resource for a top contributor network flow.
        public var localRegion: Swift.String?
        /// The Amazon Resource Name (ARN) of a local subnet.
        public var localSubnetArn: Swift.String?
        /// The subnet ID for the local resource for a top contributor network flow.
        public var localSubnetId: Swift.String?
        /// The Amazon Resource Name (ARN) of a local VPC.
        public var localVpcArn: Swift.String?
        /// The VPC ID for a top contributor network flow for the local resource.
        public var localVpcId: Swift.String?
        /// The Availability Zone for the remote resource for a top contributor network flow.
        public var remoteAz: Swift.String?
        /// The Amazon Resource Name (ARN) of a remote resource.
        public var remoteInstanceArn: Swift.String?
        /// The instance identifier for the remote resource for a top contributor network flow.
        public var remoteInstanceId: Swift.String?
        /// The IP address of the remote resource for a top contributor network flow.
        public var remoteIp: Swift.String?
        /// The Amazon Web Services Region for the remote resource for a top contributor network flow.
        public var remoteRegion: Swift.String?
        /// The Amazon Resource Name (ARN) of a remote subnet.
        public var remoteSubnetArn: Swift.String?
        /// The subnet ID for the remote resource for a top contributor network flow.
        public var remoteSubnetId: Swift.String?
        /// The Amazon Resource Name (ARN) of a remote VPC.
        public var remoteVpcArn: Swift.String?
        /// The VPC ID for a top contributor network flow for the remote resource.
        public var remoteVpcId: Swift.String?
        /// The secure network address translation (SNAT) IP address for a top contributor network flow.
        public var snatIp: Swift.String?
        /// The target port.
        public var targetPort: Swift.Int?
        /// The constructs traversed by a network flow.
        public var traversedConstructs: [NetworkFlowMonitorClientTypes.TraversedComponent]?
        /// The value of the metric for a top contributor network flow.
        public var value: Swift.Int?

        public init(
            destinationCategory: NetworkFlowMonitorClientTypes.DestinationCategory? = nil,
            dnatIp: Swift.String? = nil,
            kubernetesMetadata: NetworkFlowMonitorClientTypes.KubernetesMetadata? = nil,
            localAz: Swift.String? = nil,
            localInstanceArn: Swift.String? = nil,
            localInstanceId: Swift.String? = nil,
            localIp: Swift.String? = nil,
            localRegion: Swift.String? = nil,
            localSubnetArn: Swift.String? = nil,
            localSubnetId: Swift.String? = nil,
            localVpcArn: Swift.String? = nil,
            localVpcId: Swift.String? = nil,
            remoteAz: Swift.String? = nil,
            remoteInstanceArn: Swift.String? = nil,
            remoteInstanceId: Swift.String? = nil,
            remoteIp: Swift.String? = nil,
            remoteRegion: Swift.String? = nil,
            remoteSubnetArn: Swift.String? = nil,
            remoteSubnetId: Swift.String? = nil,
            remoteVpcArn: Swift.String? = nil,
            remoteVpcId: Swift.String? = nil,
            snatIp: Swift.String? = nil,
            targetPort: Swift.Int? = nil,
            traversedConstructs: [NetworkFlowMonitorClientTypes.TraversedComponent]? = nil,
            value: Swift.Int? = nil
        ) {
            self.destinationCategory = destinationCategory
            self.dnatIp = dnatIp
            self.kubernetesMetadata = kubernetesMetadata
            self.localAz = localAz
            self.localInstanceArn = localInstanceArn
            self.localInstanceId = localInstanceId
            self.localIp = localIp
            self.localRegion = localRegion
            self.localSubnetArn = localSubnetArn
            self.localSubnetId = localSubnetId
            self.localVpcArn = localVpcArn
            self.localVpcId = localVpcId
            self.remoteAz = remoteAz
            self.remoteInstanceArn = remoteInstanceArn
            self.remoteInstanceId = remoteInstanceId
            self.remoteIp = remoteIp
            self.remoteRegion = remoteRegion
            self.remoteSubnetArn = remoteSubnetArn
            self.remoteSubnetId = remoteSubnetId
            self.remoteVpcArn = remoteVpcArn
            self.remoteVpcId = remoteVpcId
            self.snatIp = snatIp
            self.targetPort = targetPort
            self.traversedConstructs = traversedConstructs
            self.value = value
        }
    }
}

extension NetworkFlowMonitorClientTypes {

    public enum MetricUnit: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bits
        case bitsPerSecond
        case bytes
        case bytesPerSecond
        case count
        case countPerSecond
        case gigabits
        case gigabitsPerSecond
        case gigabytes
        case gigabytesPerSecond
        case kilobits
        case kilobitsPerSecond
        case kilobytes
        case kilobytesPerSecond
        case megabits
        case megabitsPerSecond
        case megabytes
        case megabytesPerSecond
        case microseconds
        case milliseconds
        case `none`
        case percent
        case seconds
        case terabits
        case terabitsPerSecond
        case terabytes
        case terabytesPerSecond
        case sdkUnknown(Swift.String)

        public static var allCases: [MetricUnit] {
            return [
                .bits,
                .bitsPerSecond,
                .bytes,
                .bytesPerSecond,
                .count,
                .countPerSecond,
                .gigabits,
                .gigabitsPerSecond,
                .gigabytes,
                .gigabytesPerSecond,
                .kilobits,
                .kilobitsPerSecond,
                .kilobytes,
                .kilobytesPerSecond,
                .megabits,
                .megabitsPerSecond,
                .megabytes,
                .megabytesPerSecond,
                .microseconds,
                .milliseconds,
                .none,
                .percent,
                .seconds,
                .terabits,
                .terabitsPerSecond,
                .terabytes,
                .terabytesPerSecond
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bits: return "Bits"
            case .bitsPerSecond: return "Bits/Second"
            case .bytes: return "Bytes"
            case .bytesPerSecond: return "Bytes/Second"
            case .count: return "Count"
            case .countPerSecond: return "Count/Second"
            case .gigabits: return "Gigabits"
            case .gigabitsPerSecond: return "Gigabits/Second"
            case .gigabytes: return "Gigabytes"
            case .gigabytesPerSecond: return "Gigabytes/Second"
            case .kilobits: return "Kilobits"
            case .kilobitsPerSecond: return "Kilobits/Second"
            case .kilobytes: return "Kilobytes"
            case .kilobytesPerSecond: return "Kilobytes/Second"
            case .megabits: return "Megabits"
            case .megabitsPerSecond: return "Megabits/Second"
            case .megabytes: return "Megabytes"
            case .megabytesPerSecond: return "Megabytes/Second"
            case .microseconds: return "Microseconds"
            case .milliseconds: return "Milliseconds"
            case .none: return "None"
            case .percent: return "Percent"
            case .seconds: return "Seconds"
            case .terabits: return "Terabits"
            case .terabitsPerSecond: return "Terabits/Second"
            case .terabytes: return "Terabytes"
            case .terabytesPerSecond: return "Terabytes/Second"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetQueryResultsMonitorTopContributorsOutput: Swift.Sendable {
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?
    /// The top contributor network flows overall for a specific metric type, for example, the number of retransmissions.
    public var topContributors: [NetworkFlowMonitorClientTypes.MonitorTopContributorsRow]?
    /// The units for a metric returned by the query.
    public var unit: NetworkFlowMonitorClientTypes.MetricUnit?

    public init(
        nextToken: Swift.String? = nil,
        topContributors: [NetworkFlowMonitorClientTypes.MonitorTopContributorsRow]? = nil,
        unit: NetworkFlowMonitorClientTypes.MetricUnit? = nil
    ) {
        self.nextToken = nextToken
        self.topContributors = topContributors
        self.unit = unit
    }
}

public struct GetQueryResultsWorkloadInsightsTopContributorsInput: Swift.Sendable {
    /// The number of query results that you want to return with this call.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?
    /// The identifier for the query. A query ID is an internally-generated identifier for a specific query returned from an API call to start a query.
    /// This member is required.
    public var queryId: Swift.String?
    /// The identifier for the scope that includes the resources you want to get data results for. A scope ID is an internally-generated identifier that includes all the resources for a specific root account.
    /// This member is required.
    public var scopeId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queryId: Swift.String? = nil,
        scopeId: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queryId = queryId
        self.scopeId = scopeId
    }
}

extension NetworkFlowMonitorClientTypes {

    /// A row for a top contributor for a scope.
    public struct WorkloadInsightsTopContributorsRow: Swift.Sendable {
        /// The account ID for a specific row of data.
        public var accountId: Swift.String?
        /// The identifier for the Availability Zone where the local resource is located.
        public var localAz: Swift.String?
        /// The Amazon Web Services Region where the local resource is located.
        public var localRegion: Swift.String?
        /// The Amazon Resource Name (ARN) of a local subnet.
        public var localSubnetArn: Swift.String?
        /// The subnet identifier for the local resource.
        public var localSubnetId: Swift.String?
        /// The Amazon Resource Name (ARN) of a local VPC.
        public var localVpcArn: Swift.String?
        /// The identifier for the VPC for the local resource.
        public var localVpcId: Swift.String?
        /// The identifier of a remote resource.
        public var remoteIdentifier: Swift.String?
        /// The value for a metric.
        public var value: Swift.Int?

        public init(
            accountId: Swift.String? = nil,
            localAz: Swift.String? = nil,
            localRegion: Swift.String? = nil,
            localSubnetArn: Swift.String? = nil,
            localSubnetId: Swift.String? = nil,
            localVpcArn: Swift.String? = nil,
            localVpcId: Swift.String? = nil,
            remoteIdentifier: Swift.String? = nil,
            value: Swift.Int? = nil
        ) {
            self.accountId = accountId
            self.localAz = localAz
            self.localRegion = localRegion
            self.localSubnetArn = localSubnetArn
            self.localSubnetId = localSubnetId
            self.localVpcArn = localVpcArn
            self.localVpcId = localVpcId
            self.remoteIdentifier = remoteIdentifier
            self.value = value
        }
    }
}

public struct GetQueryResultsWorkloadInsightsTopContributorsOutput: Swift.Sendable {
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?
    /// The top contributor network flows overall for a specific metric type, for example, the number of retransmissions.
    public var topContributors: [NetworkFlowMonitorClientTypes.WorkloadInsightsTopContributorsRow]?

    public init(
        nextToken: Swift.String? = nil,
        topContributors: [NetworkFlowMonitorClientTypes.WorkloadInsightsTopContributorsRow]? = nil
    ) {
        self.nextToken = nextToken
        self.topContributors = topContributors
    }
}

public struct GetQueryResultsWorkloadInsightsTopContributorsDataInput: Swift.Sendable {
    /// The number of query results that you want to return with this call.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?
    /// The identifier for the query. A query ID is an internally-generated identifier for a specific query returned from an API call to start a query.
    /// This member is required.
    public var queryId: Swift.String?
    /// The identifier for the scope that includes the resources you want to get data results for. A scope ID is an internally-generated identifier that includes all the resources for a specific root account.
    /// This member is required.
    public var scopeId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queryId: Swift.String? = nil,
        scopeId: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queryId = queryId
        self.scopeId = scopeId
    }
}

extension NetworkFlowMonitorClientTypes {

    /// A data point for a top contributor network flow in a scope. Network Flow Monitor returns information about the network flows with the top values for each metric type, which are called top contributors.
    public struct WorkloadInsightsTopContributorsDataPoint: Swift.Sendable {
        /// The label identifying the data point.
        /// This member is required.
        public var label: Swift.String?
        /// An array of the timestamps for the data point.
        /// This member is required.
        public var timestamps: [Foundation.Date]?
        /// The values for the data point.
        /// This member is required.
        public var values: [Swift.Double]?

        public init(
            label: Swift.String? = nil,
            timestamps: [Foundation.Date]? = nil,
            values: [Swift.Double]? = nil
        ) {
            self.label = label
            self.timestamps = timestamps
            self.values = values
        }
    }
}

public struct GetQueryResultsWorkloadInsightsTopContributorsDataOutput: Swift.Sendable {
    /// The datapoints returned by the query.
    /// This member is required.
    public var datapoints: [NetworkFlowMonitorClientTypes.WorkloadInsightsTopContributorsDataPoint]?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?
    /// The units for a metric returned by the query.
    /// This member is required.
    public var unit: NetworkFlowMonitorClientTypes.MetricUnit?

    public init(
        datapoints: [NetworkFlowMonitorClientTypes.WorkloadInsightsTopContributorsDataPoint]? = nil,
        nextToken: Swift.String? = nil,
        unit: NetworkFlowMonitorClientTypes.MetricUnit? = nil
    ) {
        self.datapoints = datapoints
        self.nextToken = nextToken
        self.unit = unit
    }
}

public struct GetQueryStatusMonitorTopContributorsInput: Swift.Sendable {
    /// The name of the monitor.
    /// This member is required.
    public var monitorName: Swift.String?
    /// The identifier for the query. A query ID is an internally-generated identifier for a specific query returned from an API call to start a query.
    /// This member is required.
    public var queryId: Swift.String?

    public init(
        monitorName: Swift.String? = nil,
        queryId: Swift.String? = nil
    ) {
        self.monitorName = monitorName
        self.queryId = queryId
    }
}

extension NetworkFlowMonitorClientTypes {

    public enum QueryStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canceled
        case failed
        case queued
        case running
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [QueryStatus] {
            return [
                .canceled,
                .failed,
                .queued,
                .running,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .failed: return "FAILED"
            case .queued: return "QUEUED"
            case .running: return "RUNNING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetQueryStatusMonitorTopContributorsOutput: Swift.Sendable {
    /// When you run a query, use this call to check the status of the query to make sure that the query has SUCCEEDED before you review the results.
    ///
    /// * QUEUED: The query is scheduled to run.
    ///
    /// * RUNNING: The query is in progress but not complete.
    ///
    /// * SUCCEEDED: The query completed sucessfully.
    ///
    /// * FAILED: The query failed due to an error.
    ///
    /// * CANCELED: The query was canceled.
    /// This member is required.
    public var status: NetworkFlowMonitorClientTypes.QueryStatus?

    public init(
        status: NetworkFlowMonitorClientTypes.QueryStatus? = nil
    ) {
        self.status = status
    }
}

public struct GetQueryStatusWorkloadInsightsTopContributorsInput: Swift.Sendable {
    /// The identifier for the query. A query ID is an internally-generated identifier for a specific query returned from an API call to start a query.
    /// This member is required.
    public var queryId: Swift.String?
    /// The identifier for the scope that includes the resources you want to get data results for. A scope ID is an internally-generated identifier that includes all the resources for a specific root account.
    /// This member is required.
    public var scopeId: Swift.String?

    public init(
        queryId: Swift.String? = nil,
        scopeId: Swift.String? = nil
    ) {
        self.queryId = queryId
        self.scopeId = scopeId
    }
}

public struct GetQueryStatusWorkloadInsightsTopContributorsOutput: Swift.Sendable {
    /// When you run a query, use this call to check the status of the query to make sure that the query has SUCCEEDED before you review the results.
    ///
    /// * QUEUED: The query is scheduled to run.
    ///
    /// * RUNNING: The query is in progress but not complete.
    ///
    /// * SUCCEEDED: The query completed sucessfully.
    ///
    /// * FAILED: The query failed due to an error.
    ///
    /// * CANCELED: The query was canceled.
    /// This member is required.
    public var status: NetworkFlowMonitorClientTypes.QueryStatus?

    public init(
        status: NetworkFlowMonitorClientTypes.QueryStatus? = nil
    ) {
        self.status = status
    }
}

public struct GetQueryStatusWorkloadInsightsTopContributorsDataInput: Swift.Sendable {
    /// The identifier for the query. A query ID is an internally-generated identifier for a specific query returned from an API call to start a query.
    /// This member is required.
    public var queryId: Swift.String?
    /// The identifier for the scope that includes the resources you want to get data results for. A scope ID is an internally-generated identifier that includes all the resources for a specific root account. A scope ID is returned from a CreateScope API call.
    /// This member is required.
    public var scopeId: Swift.String?

    public init(
        queryId: Swift.String? = nil,
        scopeId: Swift.String? = nil
    ) {
        self.queryId = queryId
        self.scopeId = scopeId
    }
}

public struct GetQueryStatusWorkloadInsightsTopContributorsDataOutput: Swift.Sendable {
    /// The status of a query for top contributors data.
    ///
    /// * QUEUED: The query is scheduled to run.
    ///
    /// * RUNNING: The query is in progress but not complete.
    ///
    /// * SUCCEEDED: The query completed sucessfully.
    ///
    /// * FAILED: The query failed due to an error.
    ///
    /// * CANCELED: The query was canceled.
    /// This member is required.
    public var status: NetworkFlowMonitorClientTypes.QueryStatus?

    public init(
        status: NetworkFlowMonitorClientTypes.QueryStatus? = nil
    ) {
        self.status = status
    }
}

public struct GetScopeInput: Swift.Sendable {
    /// The identifier for the scope that includes the resources you want to get data results for. A scope ID is an internally-generated identifier that includes all the resources for a specific root account. A scope ID is returned from a CreateScope API call.
    /// This member is required.
    public var scopeId: Swift.String?

    public init(
        scopeId: Swift.String? = nil
    ) {
        self.scopeId = scopeId
    }
}

public struct GetScopeOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the scope.
    /// This member is required.
    public var scopeArn: Swift.String?
    /// The identifier for the scope that includes the resources you want to get data results for. A scope ID is an internally-generated identifier that includes all the resources for a specific root account. A scope ID is returned from a CreateScope API call.
    /// This member is required.
    public var scopeId: Swift.String?
    /// The status of a scope. The status can be one of the following: SUCCEEDED, IN_PROGRESS, or FAILED.
    /// This member is required.
    public var status: NetworkFlowMonitorClientTypes.ScopeStatus?
    /// The tags for a scope.
    public var tags: [Swift.String: Swift.String]?
    /// The targets for a scope
    /// This member is required.
    public var targets: [NetworkFlowMonitorClientTypes.TargetResource]?

    public init(
        scopeArn: Swift.String? = nil,
        scopeId: Swift.String? = nil,
        status: NetworkFlowMonitorClientTypes.ScopeStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        targets: [NetworkFlowMonitorClientTypes.TargetResource]? = nil
    ) {
        self.scopeArn = scopeArn
        self.scopeId = scopeId
        self.status = status
        self.tags = tags
        self.targets = targets
    }
}

public struct ListMonitorsInput: Swift.Sendable {
    /// The number of query results that you want to return with this call.
    public var maxResults: Swift.Int?
    /// The status of a monitor. The status can be one of the following
    ///
    /// * PENDING: The monitor is in the process of being created.
    ///
    /// * ACTIVE: The monitor is active.
    ///
    /// * INACTIVE: The monitor is inactive.
    ///
    /// * ERROR: Monitor creation failed due to an error.
    ///
    /// * DELETING: The monitor is in the process of being deleted.
    public var monitorStatus: NetworkFlowMonitorClientTypes.MonitorStatus?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        monitorStatus: NetworkFlowMonitorClientTypes.MonitorStatus? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.monitorStatus = monitorStatus
        self.nextToken = nextToken
    }
}

extension NetworkFlowMonitorClientTypes {

    /// A summary of information about a monitor, includ the ARN, the name, and the status.
    public struct MonitorSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the monitor.
        /// This member is required.
        public var monitorArn: Swift.String?
        /// The name of the monitor.
        /// This member is required.
        public var monitorName: Swift.String?
        /// The status of a monitor. The status can be one of the following
        ///
        /// * PENDING: The monitor is in the process of being created.
        ///
        /// * ACTIVE: The monitor is active.
        ///
        /// * INACTIVE: The monitor is inactive.
        ///
        /// * ERROR: Monitor creation failed due to an error.
        ///
        /// * DELETING: The monitor is in the process of being deleted.
        /// This member is required.
        public var monitorStatus: NetworkFlowMonitorClientTypes.MonitorStatus?

        public init(
            monitorArn: Swift.String? = nil,
            monitorName: Swift.String? = nil,
            monitorStatus: NetworkFlowMonitorClientTypes.MonitorStatus? = nil
        ) {
            self.monitorArn = monitorArn
            self.monitorName = monitorName
            self.monitorStatus = monitorStatus
        }
    }
}

public struct ListMonitorsOutput: Swift.Sendable {
    /// The monitors that are in an account.
    /// This member is required.
    public var monitors: [NetworkFlowMonitorClientTypes.MonitorSummary]?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        monitors: [NetworkFlowMonitorClientTypes.MonitorSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.monitors = monitors
        self.nextToken = nextToken
    }
}

public struct ListScopesInput: Swift.Sendable {
    /// The number of query results that you want to return with this call.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension NetworkFlowMonitorClientTypes {

    /// A summary of information about a scope, including the ARN, target ID, and Amazon Web Services Region.
    public struct ScopeSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the scope.
        /// This member is required.
        public var scopeArn: Swift.String?
        /// The identifier for the scope that includes the resources you want to get data results for. A scope ID is an internally-generated identifier that includes all the resources for a specific root account.
        /// This member is required.
        public var scopeId: Swift.String?
        /// The status of a scope. The status can be one of the following, depending on the state of scope creation: SUCCEEDED, IN_PROGRESS, or FAILED.
        /// This member is required.
        public var status: NetworkFlowMonitorClientTypes.ScopeStatus?

        public init(
            scopeArn: Swift.String? = nil,
            scopeId: Swift.String? = nil,
            status: NetworkFlowMonitorClientTypes.ScopeStatus? = nil
        ) {
            self.scopeArn = scopeArn
            self.scopeId = scopeId
            self.status = status
        }
    }
}

public struct ListScopesOutput: Swift.Sendable {
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?
    /// The scopes returned by the call.
    /// This member is required.
    public var scopes: [NetworkFlowMonitorClientTypes.ScopeSummary]?

    public init(
        nextToken: Swift.String? = nil,
        scopes: [NetworkFlowMonitorClientTypes.ScopeSummary]? = nil
    ) {
        self.nextToken = nextToken
        self.scopes = scopes
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    ) {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The tags for a resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.tags = tags
    }
}

extension NetworkFlowMonitorClientTypes {

    public enum MonitorMetric: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dataTransferred
        case retransmissions
        case roundTripTime
        case timeouts
        case sdkUnknown(Swift.String)

        public static var allCases: [MonitorMetric] {
            return [
                .dataTransferred,
                .retransmissions,
                .roundTripTime,
                .timeouts
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dataTransferred: return "DATA_TRANSFERRED"
            case .retransmissions: return "RETRANSMISSIONS"
            case .roundTripTime: return "ROUND_TRIP_TIME"
            case .timeouts: return "TIMEOUTS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct StartQueryMonitorTopContributorsInput: Swift.Sendable {
    /// The category that you want to query top contributors for, for a specific monitor. Destination categories can be one of the following:
    ///
    /// * INTRA_AZ: Top contributor network flows within a single Availability Zone
    ///
    /// * INTER_AZ: Top contributor network flows between Availability Zones
    ///
    /// * INTER_VPC: Top contributor network flows between VPCs
    ///
    /// * AWS_SERVICES: Top contributor network flows to or from Amazon Web Services services
    ///
    /// * UNCLASSIFIED: Top contributor network flows that do not have a bucket classification
    /// This member is required.
    public var destinationCategory: NetworkFlowMonitorClientTypes.DestinationCategory?
    /// The timestamp that is the date and time end of the period that you want to retrieve results for with your query.
    /// This member is required.
    public var endTime: Foundation.Date?
    /// The maximum number of top contributors to return.
    public var limit: Swift.Int?
    /// The metric that you want to query top contributors for. That is, you can specify this metric to return the top contributor network flows, for this type of metric, for a monitor and (optionally) within a specific category, such as network flows between Availability Zones.
    /// This member is required.
    public var metricName: NetworkFlowMonitorClientTypes.MonitorMetric?
    /// The name of the monitor.
    /// This member is required.
    public var monitorName: Swift.String?
    /// The timestamp that is the date and time beginning of the period that you want to retrieve results for with your query.
    /// This member is required.
    public var startTime: Foundation.Date?

    public init(
        destinationCategory: NetworkFlowMonitorClientTypes.DestinationCategory? = nil,
        endTime: Foundation.Date? = nil,
        limit: Swift.Int? = nil,
        metricName: NetworkFlowMonitorClientTypes.MonitorMetric? = nil,
        monitorName: Swift.String? = nil,
        startTime: Foundation.Date? = nil
    ) {
        self.destinationCategory = destinationCategory
        self.endTime = endTime
        self.limit = limit
        self.metricName = metricName
        self.monitorName = monitorName
        self.startTime = startTime
    }
}

public struct StartQueryMonitorTopContributorsOutput: Swift.Sendable {
    /// The identifier for the query. A query ID is an internally-generated identifier for a specific query returned from an API call to start a query.
    /// This member is required.
    public var queryId: Swift.String?

    public init(
        queryId: Swift.String? = nil
    ) {
        self.queryId = queryId
    }
}

public struct StopQueryMonitorTopContributorsInput: Swift.Sendable {
    /// The name of the monitor.
    /// This member is required.
    public var monitorName: Swift.String?
    /// The identifier for the query. A query ID is an internally-generated identifier for a specific query returned from an API call to start a query.
    /// This member is required.
    public var queryId: Swift.String?

    public init(
        monitorName: Swift.String? = nil,
        queryId: Swift.String? = nil
    ) {
        self.monitorName = monitorName
        self.queryId = queryId
    }
}

public struct StopQueryMonitorTopContributorsOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateMonitorInput: Swift.Sendable {
    /// A unique, case-sensitive string of up to 64 ASCII characters that you specify to make an idempotent API request. Don't reuse the same client token for other API requests.
    public var clientToken: Swift.String?
    /// The local resources to add, as an array of resources with identifiers and types.
    public var localResourcesToAdd: [NetworkFlowMonitorClientTypes.MonitorLocalResource]?
    /// The local resources to remove, as an array of resources with identifiers and types.
    public var localResourcesToRemove: [NetworkFlowMonitorClientTypes.MonitorLocalResource]?
    /// The name of the monitor.
    /// This member is required.
    public var monitorName: Swift.String?
    /// The remove resources to add, as an array of resources with identifiers and types.
    public var remoteResourcesToAdd: [NetworkFlowMonitorClientTypes.MonitorRemoteResource]?
    /// The remove resources to remove, as an array of resources with identifiers and types.
    public var remoteResourcesToRemove: [NetworkFlowMonitorClientTypes.MonitorRemoteResource]?

    public init(
        clientToken: Swift.String? = nil,
        localResourcesToAdd: [NetworkFlowMonitorClientTypes.MonitorLocalResource]? = nil,
        localResourcesToRemove: [NetworkFlowMonitorClientTypes.MonitorLocalResource]? = nil,
        monitorName: Swift.String? = nil,
        remoteResourcesToAdd: [NetworkFlowMonitorClientTypes.MonitorRemoteResource]? = nil,
        remoteResourcesToRemove: [NetworkFlowMonitorClientTypes.MonitorRemoteResource]? = nil
    ) {
        self.clientToken = clientToken
        self.localResourcesToAdd = localResourcesToAdd
        self.localResourcesToRemove = localResourcesToRemove
        self.monitorName = monitorName
        self.remoteResourcesToAdd = remoteResourcesToAdd
        self.remoteResourcesToRemove = remoteResourcesToRemove
    }
}

public struct UpdateMonitorOutput: Swift.Sendable {
    /// The date and time when the monitor was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The local resources updated for a monitor, as an array of resources with identifiers and types.
    /// This member is required.
    public var localResources: [NetworkFlowMonitorClientTypes.MonitorLocalResource]?
    /// The last date and time that the monitor was modified.
    /// This member is required.
    public var modifiedAt: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the monitor.
    /// This member is required.
    public var monitorArn: Swift.String?
    /// The name of the monitor.
    /// This member is required.
    public var monitorName: Swift.String?
    /// The status of a monitor. The status can be one of the following
    ///
    /// * PENDING: The monitor is in the process of being created.
    ///
    /// * ACTIVE: The monitor is active.
    ///
    /// * INACTIVE: The monitor is inactive.
    ///
    /// * ERROR: Monitor creation failed due to an error.
    ///
    /// * DELETING: The monitor is in the process of being deleted.
    /// This member is required.
    public var monitorStatus: NetworkFlowMonitorClientTypes.MonitorStatus?
    /// The remote resources updated for a monitor, as an array of resources with identifiers and types.
    /// This member is required.
    public var remoteResources: [NetworkFlowMonitorClientTypes.MonitorRemoteResource]?
    /// The tags for a monitor.
    public var tags: [Swift.String: Swift.String]?

    public init(
        createdAt: Foundation.Date? = nil,
        localResources: [NetworkFlowMonitorClientTypes.MonitorLocalResource]? = nil,
        modifiedAt: Foundation.Date? = nil,
        monitorArn: Swift.String? = nil,
        monitorName: Swift.String? = nil,
        monitorStatus: NetworkFlowMonitorClientTypes.MonitorStatus? = nil,
        remoteResources: [NetworkFlowMonitorClientTypes.MonitorRemoteResource]? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.createdAt = createdAt
        self.localResources = localResources
        self.modifiedAt = modifiedAt
        self.monitorArn = monitorArn
        self.monitorName = monitorName
        self.monitorStatus = monitorStatus
        self.remoteResources = remoteResources
        self.tags = tags
    }
}

extension NetworkFlowMonitorClientTypes {

    public enum WorkloadInsightsMetric: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dataTransferred
        case retransmissions
        case timeouts
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkloadInsightsMetric] {
            return [
                .dataTransferred,
                .retransmissions,
                .timeouts
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dataTransferred: return "DATA_TRANSFERRED"
            case .retransmissions: return "RETRANSMISSIONS"
            case .timeouts: return "TIMEOUTS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct StartQueryWorkloadInsightsTopContributorsInput: Swift.Sendable {
    /// The destination category for a top contributors row. Destination categories can be one of the following:
    ///
    /// * INTRA_AZ: Top contributor network flows within a single Availability Zone
    ///
    /// * INTER_AZ: Top contributor network flows between Availability Zones
    ///
    /// * INTER_VPC: Top contributor network flows between VPCs
    ///
    /// * AWS_SERVICES: Top contributor network flows to or from Amazon Web Services services
    ///
    /// * UNCLASSIFIED: Top contributor network flows that do not have a bucket classification
    /// This member is required.
    public var destinationCategory: NetworkFlowMonitorClientTypes.DestinationCategory?
    /// The timestamp that is the date and time end of the period that you want to retrieve results for with your query.
    /// This member is required.
    public var endTime: Foundation.Date?
    /// The maximum number of top contributors to return.
    public var limit: Swift.Int?
    /// The metric that you want to query top contributors for. That is, you can specify this metric to return the top contributor network flows, for this type of metric, for a monitor and (optionally) within a specific category, such as network flows between Availability Zones.
    /// This member is required.
    public var metricName: NetworkFlowMonitorClientTypes.WorkloadInsightsMetric?
    /// The identifier for the scope that includes the resources you want to get data results for. A scope ID is an internally-generated identifier that includes all the resources for a specific root account. A scope ID is returned from a CreateScope API call.
    /// This member is required.
    public var scopeId: Swift.String?
    /// The timestamp that is the date and time beginning of the period that you want to retrieve results for with your query.
    /// This member is required.
    public var startTime: Foundation.Date?

    public init(
        destinationCategory: NetworkFlowMonitorClientTypes.DestinationCategory? = nil,
        endTime: Foundation.Date? = nil,
        limit: Swift.Int? = nil,
        metricName: NetworkFlowMonitorClientTypes.WorkloadInsightsMetric? = nil,
        scopeId: Swift.String? = nil,
        startTime: Foundation.Date? = nil
    ) {
        self.destinationCategory = destinationCategory
        self.endTime = endTime
        self.limit = limit
        self.metricName = metricName
        self.scopeId = scopeId
        self.startTime = startTime
    }
}

public struct StartQueryWorkloadInsightsTopContributorsOutput: Swift.Sendable {
    /// The identifier for the query. A query ID is an internally-generated identifier for a specific query returned from an API call to start a query.
    /// This member is required.
    public var queryId: Swift.String?

    public init(
        queryId: Swift.String? = nil
    ) {
        self.queryId = queryId
    }
}

public struct StartQueryWorkloadInsightsTopContributorsDataInput: Swift.Sendable {
    /// The destination category for a top contributors. Destination categories can be one of the following:
    ///
    /// * INTRA_AZ: Top contributor network flows within a single Availability Zone
    ///
    /// * INTER_AZ: Top contributor network flows between Availability Zones
    ///
    /// * INTER_VPC: Top contributor network flows between VPCs
    ///
    /// * AWS_SERVICES: Top contributor network flows to or from Amazon Web Services services
    ///
    /// * UNCLASSIFIED: Top contributor network flows that do not have a bucket classification
    /// This member is required.
    public var destinationCategory: NetworkFlowMonitorClientTypes.DestinationCategory?
    /// The timestamp that is the date and time end of the period that you want to retrieve results for with your query.
    /// This member is required.
    public var endTime: Foundation.Date?
    /// The metric that you want to query top contributors for. That is, you can specify this metric to return the top contributor network flows, for this type of metric, for a monitor and (optionally) within a specific category, such as network flows between Availability Zones.
    /// This member is required.
    public var metricName: NetworkFlowMonitorClientTypes.WorkloadInsightsMetric?
    /// The identifier for the scope that includes the resources you want to get data results for. A scope ID is an internally-generated identifier that includes all the resources for a specific root account.
    /// This member is required.
    public var scopeId: Swift.String?
    /// The timestamp that is the date and time beginning of the period that you want to retrieve results for with your query.
    /// This member is required.
    public var startTime: Foundation.Date?

    public init(
        destinationCategory: NetworkFlowMonitorClientTypes.DestinationCategory? = nil,
        endTime: Foundation.Date? = nil,
        metricName: NetworkFlowMonitorClientTypes.WorkloadInsightsMetric? = nil,
        scopeId: Swift.String? = nil,
        startTime: Foundation.Date? = nil
    ) {
        self.destinationCategory = destinationCategory
        self.endTime = endTime
        self.metricName = metricName
        self.scopeId = scopeId
        self.startTime = startTime
    }
}

public struct StartQueryWorkloadInsightsTopContributorsDataOutput: Swift.Sendable {
    /// The identifier for the query. A query ID is an internally-generated identifier for a specific query returned from an API call to start a query.
    /// This member is required.
    public var queryId: Swift.String?

    public init(
        queryId: Swift.String? = nil
    ) {
        self.queryId = queryId
    }
}

public struct StopQueryWorkloadInsightsTopContributorsInput: Swift.Sendable {
    /// The identifier for the query. A query ID is an internally-generated identifier for a specific query returned from an API call to start a query.
    /// This member is required.
    public var queryId: Swift.String?
    /// The identifier for the scope that includes the resources you want to get data results for. A scope ID is an internally-generated identifier that includes all the resources for a specific root account.
    /// This member is required.
    public var scopeId: Swift.String?

    public init(
        queryId: Swift.String? = nil,
        scopeId: Swift.String? = nil
    ) {
        self.queryId = queryId
        self.scopeId = scopeId
    }
}

public struct StopQueryWorkloadInsightsTopContributorsOutput: Swift.Sendable {

    public init() { }
}

public struct StopQueryWorkloadInsightsTopContributorsDataInput: Swift.Sendable {
    /// The identifier for the query. A query ID is an internally-generated identifier for a specific query returned from an API call to start a query.
    /// This member is required.
    public var queryId: Swift.String?
    /// The identifier for the scope that includes the resources you want to get data results for. A scope ID is an internally-generated identifier that includes all the resources for a specific root account.
    /// This member is required.
    public var scopeId: Swift.String?

    public init(
        queryId: Swift.String? = nil,
        scopeId: Swift.String? = nil
    ) {
        self.queryId = queryId
        self.scopeId = scopeId
    }
}

public struct StopQueryWorkloadInsightsTopContributorsDataOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateScopeInput: Swift.Sendable {
    /// A list of resources to add to a scope.
    public var resourcesToAdd: [NetworkFlowMonitorClientTypes.TargetResource]?
    /// A list of resources to delete from a scope.
    public var resourcesToDelete: [NetworkFlowMonitorClientTypes.TargetResource]?
    /// The identifier for the scope that includes the resources you want to get data results for. A scope ID is an internally-generated identifier that includes all the resources for a specific root account.
    /// This member is required.
    public var scopeId: Swift.String?

    public init(
        resourcesToAdd: [NetworkFlowMonitorClientTypes.TargetResource]? = nil,
        resourcesToDelete: [NetworkFlowMonitorClientTypes.TargetResource]? = nil,
        scopeId: Swift.String? = nil
    ) {
        self.resourcesToAdd = resourcesToAdd
        self.resourcesToDelete = resourcesToDelete
        self.scopeId = scopeId
    }
}

public struct UpdateScopeOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the scope.
    /// This member is required.
    public var scopeArn: Swift.String?
    /// The identifier for the scope that includes the resources you want to get data results for. A scope ID is an internally-generated identifier that includes all the resources for a specific root account.
    /// This member is required.
    public var scopeId: Swift.String?
    /// The status for a call to update a scope. The status can be one of the following: SUCCEEDED, IN_PROGRESS, or FAILED.
    /// This member is required.
    public var status: NetworkFlowMonitorClientTypes.ScopeStatus?
    /// The tags for a scope.
    public var tags: [Swift.String: Swift.String]?

    public init(
        scopeArn: Swift.String? = nil,
        scopeId: Swift.String? = nil,
        status: NetworkFlowMonitorClientTypes.ScopeStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.scopeArn = scopeArn
        self.scopeId = scopeId
        self.status = status
        self.tags = tags
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags for a resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Keys that you specified when you tagged a resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension CreateMonitorInput {

    static func urlPathProvider(_ value: CreateMonitorInput) -> Swift.String? {
        return "/monitors"
    }
}

extension CreateScopeInput {

    static func urlPathProvider(_ value: CreateScopeInput) -> Swift.String? {
        return "/scopes"
    }
}

extension DeleteMonitorInput {

    static func urlPathProvider(_ value: DeleteMonitorInput) -> Swift.String? {
        guard let monitorName = value.monitorName else {
            return nil
        }
        return "/monitors/\(monitorName.urlPercentEncoding())"
    }
}

extension DeleteScopeInput {

    static func urlPathProvider(_ value: DeleteScopeInput) -> Swift.String? {
        guard let scopeId = value.scopeId else {
            return nil
        }
        return "/scopes/\(scopeId.urlPercentEncoding())"
    }
}

extension GetMonitorInput {

    static func urlPathProvider(_ value: GetMonitorInput) -> Swift.String? {
        guard let monitorName = value.monitorName else {
            return nil
        }
        return "/monitors/\(monitorName.urlPercentEncoding())"
    }
}

extension GetQueryResultsMonitorTopContributorsInput {

    static func urlPathProvider(_ value: GetQueryResultsMonitorTopContributorsInput) -> Swift.String? {
        guard let monitorName = value.monitorName else {
            return nil
        }
        guard let queryId = value.queryId else {
            return nil
        }
        return "/monitors/\(monitorName.urlPercentEncoding())/topContributorsQueries/\(queryId.urlPercentEncoding())/results"
    }
}

extension GetQueryResultsMonitorTopContributorsInput {

    static func queryItemProvider(_ value: GetQueryResultsMonitorTopContributorsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetQueryResultsWorkloadInsightsTopContributorsInput {

    static func urlPathProvider(_ value: GetQueryResultsWorkloadInsightsTopContributorsInput) -> Swift.String? {
        guard let scopeId = value.scopeId else {
            return nil
        }
        guard let queryId = value.queryId else {
            return nil
        }
        return "/workloadInsights/\(scopeId.urlPercentEncoding())/topContributorsQueries/\(queryId.urlPercentEncoding())/results"
    }
}

extension GetQueryResultsWorkloadInsightsTopContributorsInput {

    static func queryItemProvider(_ value: GetQueryResultsWorkloadInsightsTopContributorsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetQueryResultsWorkloadInsightsTopContributorsDataInput {

    static func urlPathProvider(_ value: GetQueryResultsWorkloadInsightsTopContributorsDataInput) -> Swift.String? {
        guard let scopeId = value.scopeId else {
            return nil
        }
        guard let queryId = value.queryId else {
            return nil
        }
        return "/workloadInsights/\(scopeId.urlPercentEncoding())/topContributorsDataQueries/\(queryId.urlPercentEncoding())/results"
    }
}

extension GetQueryResultsWorkloadInsightsTopContributorsDataInput {

    static func queryItemProvider(_ value: GetQueryResultsWorkloadInsightsTopContributorsDataInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetQueryStatusMonitorTopContributorsInput {

    static func urlPathProvider(_ value: GetQueryStatusMonitorTopContributorsInput) -> Swift.String? {
        guard let monitorName = value.monitorName else {
            return nil
        }
        guard let queryId = value.queryId else {
            return nil
        }
        return "/monitors/\(monitorName.urlPercentEncoding())/topContributorsQueries/\(queryId.urlPercentEncoding())/status"
    }
}

extension GetQueryStatusWorkloadInsightsTopContributorsInput {

    static func urlPathProvider(_ value: GetQueryStatusWorkloadInsightsTopContributorsInput) -> Swift.String? {
        guard let scopeId = value.scopeId else {
            return nil
        }
        guard let queryId = value.queryId else {
            return nil
        }
        return "/workloadInsights/\(scopeId.urlPercentEncoding())/topContributorsQueries/\(queryId.urlPercentEncoding())/status"
    }
}

extension GetQueryStatusWorkloadInsightsTopContributorsDataInput {

    static func urlPathProvider(_ value: GetQueryStatusWorkloadInsightsTopContributorsDataInput) -> Swift.String? {
        guard let scopeId = value.scopeId else {
            return nil
        }
        guard let queryId = value.queryId else {
            return nil
        }
        return "/workloadInsights/\(scopeId.urlPercentEncoding())/topContributorsDataQueries/\(queryId.urlPercentEncoding())/status"
    }
}

extension GetScopeInput {

    static func urlPathProvider(_ value: GetScopeInput) -> Swift.String? {
        guard let scopeId = value.scopeId else {
            return nil
        }
        return "/scopes/\(scopeId.urlPercentEncoding())"
    }
}

extension ListMonitorsInput {

    static func urlPathProvider(_ value: ListMonitorsInput) -> Swift.String? {
        return "/monitors"
    }
}

extension ListMonitorsInput {

    static func queryItemProvider(_ value: ListMonitorsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let monitorStatus = value.monitorStatus {
            let monitorStatusQueryItem = Smithy.URIQueryItem(name: "monitorStatus".urlPercentEncoding(), value: Swift.String(monitorStatus.rawValue).urlPercentEncoding())
            items.append(monitorStatusQueryItem)
        }
        return items
    }
}

extension ListScopesInput {

    static func urlPathProvider(_ value: ListScopesInput) -> Swift.String? {
        return "/scopes"
    }
}

extension ListScopesInput {

    static func queryItemProvider(_ value: ListScopesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension StartQueryMonitorTopContributorsInput {

    static func urlPathProvider(_ value: StartQueryMonitorTopContributorsInput) -> Swift.String? {
        guard let monitorName = value.monitorName else {
            return nil
        }
        return "/monitors/\(monitorName.urlPercentEncoding())/topContributorsQueries"
    }
}

extension StartQueryWorkloadInsightsTopContributorsInput {

    static func urlPathProvider(_ value: StartQueryWorkloadInsightsTopContributorsInput) -> Swift.String? {
        guard let scopeId = value.scopeId else {
            return nil
        }
        return "/workloadInsights/\(scopeId.urlPercentEncoding())/topContributorsQueries"
    }
}

extension StartQueryWorkloadInsightsTopContributorsDataInput {

    static func urlPathProvider(_ value: StartQueryWorkloadInsightsTopContributorsDataInput) -> Swift.String? {
        guard let scopeId = value.scopeId else {
            return nil
        }
        return "/workloadInsights/\(scopeId.urlPercentEncoding())/topContributorsDataQueries"
    }
}

extension StopQueryMonitorTopContributorsInput {

    static func urlPathProvider(_ value: StopQueryMonitorTopContributorsInput) -> Swift.String? {
        guard let monitorName = value.monitorName else {
            return nil
        }
        guard let queryId = value.queryId else {
            return nil
        }
        return "/monitors/\(monitorName.urlPercentEncoding())/topContributorsQueries/\(queryId.urlPercentEncoding())"
    }
}

extension StopQueryWorkloadInsightsTopContributorsInput {

    static func urlPathProvider(_ value: StopQueryWorkloadInsightsTopContributorsInput) -> Swift.String? {
        guard let scopeId = value.scopeId else {
            return nil
        }
        guard let queryId = value.queryId else {
            return nil
        }
        return "/workloadInsights/\(scopeId.urlPercentEncoding())/topContributorsQueries/\(queryId.urlPercentEncoding())"
    }
}

extension StopQueryWorkloadInsightsTopContributorsDataInput {

    static func urlPathProvider(_ value: StopQueryWorkloadInsightsTopContributorsDataInput) -> Swift.String? {
        guard let scopeId = value.scopeId else {
            return nil
        }
        guard let queryId = value.queryId else {
            return nil
        }
        return "/workloadInsights/\(scopeId.urlPercentEncoding())/topContributorsDataQueries/\(queryId.urlPercentEncoding())"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateMonitorInput {

    static func urlPathProvider(_ value: UpdateMonitorInput) -> Swift.String? {
        guard let monitorName = value.monitorName else {
            return nil
        }
        return "/monitors/\(monitorName.urlPercentEncoding())"
    }
}

extension UpdateScopeInput {

    static func urlPathProvider(_ value: UpdateScopeInput) -> Swift.String? {
        guard let scopeId = value.scopeId else {
            return nil
        }
        return "/scopes/\(scopeId.urlPercentEncoding())"
    }
}

extension CreateMonitorInput {

    static func write(value: CreateMonitorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["localResources"].writeList(value.localResources, memberWritingClosure: NetworkFlowMonitorClientTypes.MonitorLocalResource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["monitorName"].write(value.monitorName)
        try writer["remoteResources"].writeList(value.remoteResources, memberWritingClosure: NetworkFlowMonitorClientTypes.MonitorRemoteResource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["scopeArn"].write(value.scopeArn)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateScopeInput {

    static func write(value: CreateScopeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["targets"].writeList(value.targets, memberWritingClosure: NetworkFlowMonitorClientTypes.TargetResource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension StartQueryMonitorTopContributorsInput {

    static func write(value: StartQueryMonitorTopContributorsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destinationCategory"].write(value.destinationCategory)
        try writer["endTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.dateTime)
        try writer["limit"].write(value.limit)
        try writer["metricName"].write(value.metricName)
        try writer["startTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.dateTime)
    }
}

extension StartQueryWorkloadInsightsTopContributorsInput {

    static func write(value: StartQueryWorkloadInsightsTopContributorsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destinationCategory"].write(value.destinationCategory)
        try writer["endTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.dateTime)
        try writer["limit"].write(value.limit)
        try writer["metricName"].write(value.metricName)
        try writer["startTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.dateTime)
    }
}

extension StartQueryWorkloadInsightsTopContributorsDataInput {

    static func write(value: StartQueryWorkloadInsightsTopContributorsDataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destinationCategory"].write(value.destinationCategory)
        try writer["endTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.dateTime)
        try writer["metricName"].write(value.metricName)
        try writer["startTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.dateTime)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateMonitorInput {

    static func write(value: UpdateMonitorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["localResourcesToAdd"].writeList(value.localResourcesToAdd, memberWritingClosure: NetworkFlowMonitorClientTypes.MonitorLocalResource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["localResourcesToRemove"].writeList(value.localResourcesToRemove, memberWritingClosure: NetworkFlowMonitorClientTypes.MonitorLocalResource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["remoteResourcesToAdd"].writeList(value.remoteResourcesToAdd, memberWritingClosure: NetworkFlowMonitorClientTypes.MonitorRemoteResource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["remoteResourcesToRemove"].writeList(value.remoteResourcesToRemove, memberWritingClosure: NetworkFlowMonitorClientTypes.MonitorRemoteResource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateScopeInput {

    static func write(value: UpdateScopeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourcesToAdd"].writeList(value.resourcesToAdd, memberWritingClosure: NetworkFlowMonitorClientTypes.TargetResource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["resourcesToDelete"].writeList(value.resourcesToDelete, memberWritingClosure: NetworkFlowMonitorClientTypes.TargetResource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateMonitorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMonitorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMonitorOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.localResources = try reader["localResources"].readListIfPresent(memberReadingClosure: NetworkFlowMonitorClientTypes.MonitorLocalResource.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.monitorArn = try reader["monitorArn"].readIfPresent() ?? ""
        value.monitorName = try reader["monitorName"].readIfPresent() ?? ""
        value.monitorStatus = try reader["monitorStatus"].readIfPresent() ?? .sdkUnknown("")
        value.remoteResources = try reader["remoteResources"].readListIfPresent(memberReadingClosure: NetworkFlowMonitorClientTypes.MonitorRemoteResource.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CreateScopeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateScopeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateScopeOutput()
        value.scopeArn = try reader["scopeArn"].readIfPresent() ?? ""
        value.scopeId = try reader["scopeId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension DeleteMonitorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMonitorOutput {
        return DeleteMonitorOutput()
    }
}

extension DeleteScopeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteScopeOutput {
        return DeleteScopeOutput()
    }
}

extension GetMonitorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMonitorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMonitorOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.localResources = try reader["localResources"].readListIfPresent(memberReadingClosure: NetworkFlowMonitorClientTypes.MonitorLocalResource.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.monitorArn = try reader["monitorArn"].readIfPresent() ?? ""
        value.monitorName = try reader["monitorName"].readIfPresent() ?? ""
        value.monitorStatus = try reader["monitorStatus"].readIfPresent() ?? .sdkUnknown("")
        value.remoteResources = try reader["remoteResources"].readListIfPresent(memberReadingClosure: NetworkFlowMonitorClientTypes.MonitorRemoteResource.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetQueryResultsMonitorTopContributorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetQueryResultsMonitorTopContributorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetQueryResultsMonitorTopContributorsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.topContributors = try reader["topContributors"].readListIfPresent(memberReadingClosure: NetworkFlowMonitorClientTypes.MonitorTopContributorsRow.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.unit = try reader["unit"].readIfPresent()
        return value
    }
}

extension GetQueryResultsWorkloadInsightsTopContributorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetQueryResultsWorkloadInsightsTopContributorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetQueryResultsWorkloadInsightsTopContributorsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.topContributors = try reader["topContributors"].readListIfPresent(memberReadingClosure: NetworkFlowMonitorClientTypes.WorkloadInsightsTopContributorsRow.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetQueryResultsWorkloadInsightsTopContributorsDataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetQueryResultsWorkloadInsightsTopContributorsDataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetQueryResultsWorkloadInsightsTopContributorsDataOutput()
        value.datapoints = try reader["datapoints"].readListIfPresent(memberReadingClosure: NetworkFlowMonitorClientTypes.WorkloadInsightsTopContributorsDataPoint.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.unit = try reader["unit"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GetQueryStatusMonitorTopContributorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetQueryStatusMonitorTopContributorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetQueryStatusMonitorTopContributorsOutput()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GetQueryStatusWorkloadInsightsTopContributorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetQueryStatusWorkloadInsightsTopContributorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetQueryStatusWorkloadInsightsTopContributorsOutput()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GetQueryStatusWorkloadInsightsTopContributorsDataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetQueryStatusWorkloadInsightsTopContributorsDataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetQueryStatusWorkloadInsightsTopContributorsDataOutput()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GetScopeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetScopeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetScopeOutput()
        value.scopeArn = try reader["scopeArn"].readIfPresent() ?? ""
        value.scopeId = try reader["scopeId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.targets = try reader["targets"].readListIfPresent(memberReadingClosure: NetworkFlowMonitorClientTypes.TargetResource.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListMonitorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMonitorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMonitorsOutput()
        value.monitors = try reader["monitors"].readListIfPresent(memberReadingClosure: NetworkFlowMonitorClientTypes.MonitorSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListScopesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListScopesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListScopesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.scopes = try reader["scopes"].readListIfPresent(memberReadingClosure: NetworkFlowMonitorClientTypes.ScopeSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension StartQueryMonitorTopContributorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartQueryMonitorTopContributorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartQueryMonitorTopContributorsOutput()
        value.queryId = try reader["queryId"].readIfPresent() ?? ""
        return value
    }
}

extension StartQueryWorkloadInsightsTopContributorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartQueryWorkloadInsightsTopContributorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartQueryWorkloadInsightsTopContributorsOutput()
        value.queryId = try reader["queryId"].readIfPresent() ?? ""
        return value
    }
}

extension StartQueryWorkloadInsightsTopContributorsDataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartQueryWorkloadInsightsTopContributorsDataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartQueryWorkloadInsightsTopContributorsDataOutput()
        value.queryId = try reader["queryId"].readIfPresent() ?? ""
        return value
    }
}

extension StopQueryMonitorTopContributorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopQueryMonitorTopContributorsOutput {
        return StopQueryMonitorTopContributorsOutput()
    }
}

extension StopQueryWorkloadInsightsTopContributorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopQueryWorkloadInsightsTopContributorsOutput {
        return StopQueryWorkloadInsightsTopContributorsOutput()
    }
}

extension StopQueryWorkloadInsightsTopContributorsDataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopQueryWorkloadInsightsTopContributorsDataOutput {
        return StopQueryWorkloadInsightsTopContributorsDataOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateMonitorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateMonitorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateMonitorOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.localResources = try reader["localResources"].readListIfPresent(memberReadingClosure: NetworkFlowMonitorClientTypes.MonitorLocalResource.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.monitorArn = try reader["monitorArn"].readIfPresent() ?? ""
        value.monitorName = try reader["monitorName"].readIfPresent() ?? ""
        value.monitorStatus = try reader["monitorStatus"].readIfPresent() ?? .sdkUnknown("")
        value.remoteResources = try reader["remoteResources"].readListIfPresent(memberReadingClosure: NetworkFlowMonitorClientTypes.MonitorRemoteResource.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension UpdateScopeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateScopeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateScopeOutput()
        value.scopeArn = try reader["scopeArn"].readIfPresent() ?? ""
        value.scopeId = try reader["scopeId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

enum CreateMonitorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateScopeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMonitorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteScopeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMonitorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetQueryResultsMonitorTopContributorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetQueryResultsWorkloadInsightsTopContributorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetQueryResultsWorkloadInsightsTopContributorsDataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetQueryStatusMonitorTopContributorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetQueryStatusWorkloadInsightsTopContributorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetQueryStatusWorkloadInsightsTopContributorsDataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetScopeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMonitorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListScopesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartQueryMonitorTopContributorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartQueryWorkloadInsightsTopContributorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartQueryWorkloadInsightsTopContributorsDataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopQueryMonitorTopContributorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopQueryWorkloadInsightsTopContributorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopQueryWorkloadInsightsTopContributorsDataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateMonitorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateScopeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NetworkFlowMonitorClientTypes.MonitorLocalResource {

    static func write(value: NetworkFlowMonitorClientTypes.MonitorLocalResource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["identifier"].write(value.identifier)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkFlowMonitorClientTypes.MonitorLocalResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkFlowMonitorClientTypes.MonitorLocalResource()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.identifier = try reader["identifier"].readIfPresent() ?? ""
        return value
    }
}

extension NetworkFlowMonitorClientTypes.MonitorRemoteResource {

    static func write(value: NetworkFlowMonitorClientTypes.MonitorRemoteResource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["identifier"].write(value.identifier)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkFlowMonitorClientTypes.MonitorRemoteResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkFlowMonitorClientTypes.MonitorRemoteResource()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.identifier = try reader["identifier"].readIfPresent() ?? ""
        return value
    }
}

extension NetworkFlowMonitorClientTypes.MonitorTopContributorsRow {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkFlowMonitorClientTypes.MonitorTopContributorsRow {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkFlowMonitorClientTypes.MonitorTopContributorsRow()
        value.localIp = try reader["localIp"].readIfPresent()
        value.snatIp = try reader["snatIp"].readIfPresent()
        value.localInstanceId = try reader["localInstanceId"].readIfPresent()
        value.localVpcId = try reader["localVpcId"].readIfPresent()
        value.localRegion = try reader["localRegion"].readIfPresent()
        value.localAz = try reader["localAz"].readIfPresent()
        value.localSubnetId = try reader["localSubnetId"].readIfPresent()
        value.targetPort = try reader["targetPort"].readIfPresent()
        value.destinationCategory = try reader["destinationCategory"].readIfPresent()
        value.remoteVpcId = try reader["remoteVpcId"].readIfPresent()
        value.remoteRegion = try reader["remoteRegion"].readIfPresent()
        value.remoteAz = try reader["remoteAz"].readIfPresent()
        value.remoteSubnetId = try reader["remoteSubnetId"].readIfPresent()
        value.remoteInstanceId = try reader["remoteInstanceId"].readIfPresent()
        value.remoteIp = try reader["remoteIp"].readIfPresent()
        value.dnatIp = try reader["dnatIp"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        value.traversedConstructs = try reader["traversedConstructs"].readListIfPresent(memberReadingClosure: NetworkFlowMonitorClientTypes.TraversedComponent.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.kubernetesMetadata = try reader["kubernetesMetadata"].readIfPresent(with: NetworkFlowMonitorClientTypes.KubernetesMetadata.read(from:))
        value.localInstanceArn = try reader["localInstanceArn"].readIfPresent()
        value.localSubnetArn = try reader["localSubnetArn"].readIfPresent()
        value.localVpcArn = try reader["localVpcArn"].readIfPresent()
        value.remoteInstanceArn = try reader["remoteInstanceArn"].readIfPresent()
        value.remoteSubnetArn = try reader["remoteSubnetArn"].readIfPresent()
        value.remoteVpcArn = try reader["remoteVpcArn"].readIfPresent()
        return value
    }
}

extension NetworkFlowMonitorClientTypes.KubernetesMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkFlowMonitorClientTypes.KubernetesMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkFlowMonitorClientTypes.KubernetesMetadata()
        value.localServiceName = try reader["localServiceName"].readIfPresent()
        value.localPodName = try reader["localPodName"].readIfPresent()
        value.localPodNamespace = try reader["localPodNamespace"].readIfPresent()
        value.remoteServiceName = try reader["remoteServiceName"].readIfPresent()
        value.remotePodName = try reader["remotePodName"].readIfPresent()
        value.remotePodNamespace = try reader["remotePodNamespace"].readIfPresent()
        return value
    }
}

extension NetworkFlowMonitorClientTypes.TraversedComponent {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkFlowMonitorClientTypes.TraversedComponent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkFlowMonitorClientTypes.TraversedComponent()
        value.componentId = try reader["componentId"].readIfPresent()
        value.componentType = try reader["componentType"].readIfPresent()
        value.componentArn = try reader["componentArn"].readIfPresent()
        value.serviceName = try reader["serviceName"].readIfPresent()
        return value
    }
}

extension NetworkFlowMonitorClientTypes.WorkloadInsightsTopContributorsRow {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkFlowMonitorClientTypes.WorkloadInsightsTopContributorsRow {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkFlowMonitorClientTypes.WorkloadInsightsTopContributorsRow()
        value.accountId = try reader["accountId"].readIfPresent()
        value.localSubnetId = try reader["localSubnetId"].readIfPresent()
        value.localAz = try reader["localAz"].readIfPresent()
        value.localVpcId = try reader["localVpcId"].readIfPresent()
        value.localRegion = try reader["localRegion"].readIfPresent()
        value.remoteIdentifier = try reader["remoteIdentifier"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        value.localSubnetArn = try reader["localSubnetArn"].readIfPresent()
        value.localVpcArn = try reader["localVpcArn"].readIfPresent()
        return value
    }
}

extension NetworkFlowMonitorClientTypes.WorkloadInsightsTopContributorsDataPoint {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkFlowMonitorClientTypes.WorkloadInsightsTopContributorsDataPoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkFlowMonitorClientTypes.WorkloadInsightsTopContributorsDataPoint()
        value.timestamps = try reader["timestamps"].readListIfPresent(memberReadingClosure: SmithyReadWrite.timestampReadingClosure(format: SmithyTimestamps.TimestampFormat.dateTime), memberNodeInfo: "member", isFlattened: false) ?? []
        value.values = try reader["values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.label = try reader["label"].readIfPresent() ?? ""
        return value
    }
}

extension NetworkFlowMonitorClientTypes.TargetResource {

    static func write(value: NetworkFlowMonitorClientTypes.TargetResource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["region"].write(value.region)
        try writer["targetIdentifier"].write(value.targetIdentifier, with: NetworkFlowMonitorClientTypes.TargetIdentifier.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkFlowMonitorClientTypes.TargetResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkFlowMonitorClientTypes.TargetResource()
        value.targetIdentifier = try reader["targetIdentifier"].readIfPresent(with: NetworkFlowMonitorClientTypes.TargetIdentifier.read(from:))
        value.region = try reader["region"].readIfPresent() ?? ""
        return value
    }
}

extension NetworkFlowMonitorClientTypes.TargetIdentifier {

    static func write(value: NetworkFlowMonitorClientTypes.TargetIdentifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["targetId"].write(value.targetId, with: NetworkFlowMonitorClientTypes.TargetId.write(value:to:))
        try writer["targetType"].write(value.targetType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkFlowMonitorClientTypes.TargetIdentifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkFlowMonitorClientTypes.TargetIdentifier()
        value.targetId = try reader["targetId"].readIfPresent(with: NetworkFlowMonitorClientTypes.TargetId.read(from:))
        value.targetType = try reader["targetType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension NetworkFlowMonitorClientTypes.TargetId {

    static func write(value: NetworkFlowMonitorClientTypes.TargetId?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .accountid(accountid):
                try writer["accountId"].write(accountid)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkFlowMonitorClientTypes.TargetId {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "accountId":
                return .accountid(try reader["accountId"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension NetworkFlowMonitorClientTypes.MonitorSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkFlowMonitorClientTypes.MonitorSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkFlowMonitorClientTypes.MonitorSummary()
        value.monitorArn = try reader["monitorArn"].readIfPresent() ?? ""
        value.monitorName = try reader["monitorName"].readIfPresent() ?? ""
        value.monitorStatus = try reader["monitorStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension NetworkFlowMonitorClientTypes.ScopeSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkFlowMonitorClientTypes.ScopeSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkFlowMonitorClientTypes.ScopeSummary()
        value.scopeId = try reader["scopeId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.scopeArn = try reader["scopeArn"].readIfPresent() ?? ""
        return value
    }
}

public enum NetworkFlowMonitorClientTypes {}
