// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime
import SmithyXML

extension S3ControlClientTypes.AbortIncompleteMultipartUpload: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case daysAfterInitiation = "DaysAfterInitiation"
    }

    static func writingClosure(_ value: S3ControlClientTypes.AbortIncompleteMultipartUpload?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("DaysAfterInitiation")].write(value.daysAfterInitiation)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let daysAfterInitiationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .daysAfterInitiation) ?? 0
        daysAfterInitiation = daysAfterInitiationDecoded
    }
}

extension S3ControlClientTypes {
    /// The container for abort incomplete multipart upload
    public struct AbortIncompleteMultipartUpload: Swift.Equatable {
        /// Specifies the number of days after which Amazon S3 aborts an incomplete multipart upload to the Outposts bucket.
        public var daysAfterInitiation: Swift.Int

        public init(
            daysAfterInitiation: Swift.Int = 0
        )
        {
            self.daysAfterInitiation = daysAfterInitiation
        }
    }

}

extension S3ControlClientTypes.AccessControlTranslation: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case owner = "Owner"
    }

    static func writingClosure(_ value: S3ControlClientTypes.AccessControlTranslation?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Owner")].write(value.owner)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.OwnerOverride.self, forKey: .owner)
        owner = ownerDecoded
    }
}

extension S3ControlClientTypes {
    /// A container for information about access control for replicas. This is not supported by Amazon S3 on Outposts buckets.
    public struct AccessControlTranslation: Swift.Equatable {
        /// Specifies the replica ownership.
        /// This member is required.
        public var owner: S3ControlClientTypes.OwnerOverride?

        public init(
            owner: S3ControlClientTypes.OwnerOverride? = nil
        )
        {
            self.owner = owner
        }
    }

}

extension S3ControlClientTypes.AccessGrantsLocationConfiguration: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3SubPrefix = "S3SubPrefix"
    }

    static func writingClosure(_ value: S3ControlClientTypes.AccessGrantsLocationConfiguration?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("S3SubPrefix")].write(value.s3SubPrefix)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3SubPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3SubPrefix)
        s3SubPrefix = s3SubPrefixDecoded
    }
}

extension S3ControlClientTypes {
    /// The configuration options of the S3 Access Grants location. It contains the S3SubPrefix field. The grant scope, the data to which you are granting access, is the result of appending the Subprefix field to the scope of the registered location.
    public struct AccessGrantsLocationConfiguration: Swift.Equatable {
        /// The S3SubPrefix is appended to the location scope creating the grant scope. Use this field to narrow the scope of the grant to a subset of the location scope. This field is required if the location scope is the default location s3:// because you cannot create a grant for all of your S3 data in the Region and must narrow the scope. For example, if the location scope is the default location s3://, the S3SubPrefx can be a /*, so the full grant scope path would be s3:///*. Or the S3SubPrefx can be /*, so the full grant scope path would be or s3:///*. If the S3SubPrefix includes a prefix, append the wildcard character * after the prefix to indicate that you want to include all object key names in the bucket that start with that prefix.
        public var s3SubPrefix: Swift.String?

        public init(
            s3SubPrefix: Swift.String? = nil
        )
        {
            self.s3SubPrefix = s3SubPrefix
        }
    }

}

extension S3ControlClientTypes.AccessPoint: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPointArn = "AccessPointArn"
        case alias = "Alias"
        case bucket = "Bucket"
        case bucketAccountId = "BucketAccountId"
        case name = "Name"
        case networkOrigin = "NetworkOrigin"
        case vpcConfiguration = "VpcConfiguration"
    }

    static func writingClosure(_ value: S3ControlClientTypes.AccessPoint?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("AccessPointArn")].write(value.accessPointArn)
        try writer[.init("Alias")].write(value.alias)
        try writer[.init("Bucket")].write(value.bucket)
        try writer[.init("BucketAccountId")].write(value.bucketAccountId)
        try writer[.init("Name")].write(value.name)
        try writer[.init("NetworkOrigin")].write(value.networkOrigin)
        try writer[.init("VpcConfiguration")].write(value.vpcConfiguration, writingClosure: S3ControlClientTypes.VpcConfiguration.writingClosure(_:to:))
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let networkOriginDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.NetworkOrigin.self, forKey: .networkOrigin)
        networkOrigin = networkOriginDecoded
        let vpcConfigurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.VpcConfiguration.self, forKey: .vpcConfiguration)
        vpcConfiguration = vpcConfigurationDecoded
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let accessPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPointArn)
        accessPointArn = accessPointArnDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let bucketAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketAccountId)
        bucketAccountId = bucketAccountIdDecoded
    }
}

extension S3ControlClientTypes {
    /// An access point used to access a bucket.
    public struct AccessPoint: Swift.Equatable {
        /// The ARN for the access point.
        public var accessPointArn: Swift.String?
        /// The name or alias of the access point.
        public var alias: Swift.String?
        /// The name of the bucket associated with this access point.
        /// This member is required.
        public var bucket: Swift.String?
        /// The Amazon Web Services account ID associated with the S3 bucket associated with this access point.
        public var bucketAccountId: Swift.String?
        /// The name of this access point.
        /// This member is required.
        public var name: Swift.String?
        /// Indicates whether this access point allows access from the public internet. If VpcConfiguration is specified for this access point, then NetworkOrigin is VPC, and the access point doesn't allow access from the public internet. Otherwise, NetworkOrigin is Internet, and the access point allows access from the public internet, subject to the access point and bucket access policies.
        /// This member is required.
        public var networkOrigin: S3ControlClientTypes.NetworkOrigin?
        /// The virtual private cloud (VPC) configuration for this access point, if one exists. This element is empty if this access point is an Amazon S3 on Outposts access point that is used by other Amazon Web Services.
        public var vpcConfiguration: S3ControlClientTypes.VpcConfiguration?

        public init(
            accessPointArn: Swift.String? = nil,
            alias: Swift.String? = nil,
            bucket: Swift.String? = nil,
            bucketAccountId: Swift.String? = nil,
            name: Swift.String? = nil,
            networkOrigin: S3ControlClientTypes.NetworkOrigin? = nil,
            vpcConfiguration: S3ControlClientTypes.VpcConfiguration? = nil
        )
        {
            self.accessPointArn = accessPointArn
            self.alias = alias
            self.bucket = bucket
            self.bucketAccountId = bucketAccountId
            self.name = name
            self.networkOrigin = networkOrigin
            self.vpcConfiguration = vpcConfiguration
        }
    }

}

extension S3ControlClientTypes.AccountLevel: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activityMetrics = "ActivityMetrics"
        case advancedCostOptimizationMetrics = "AdvancedCostOptimizationMetrics"
        case advancedDataProtectionMetrics = "AdvancedDataProtectionMetrics"
        case bucketLevel = "BucketLevel"
        case detailedStatusCodesMetrics = "DetailedStatusCodesMetrics"
        case storageLensGroupLevel = "StorageLensGroupLevel"
    }

    static func writingClosure(_ value: S3ControlClientTypes.AccountLevel?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("ActivityMetrics")].write(value.activityMetrics, writingClosure: S3ControlClientTypes.ActivityMetrics.writingClosure(_:to:))
        try writer[.init("AdvancedCostOptimizationMetrics")].write(value.advancedCostOptimizationMetrics, writingClosure: S3ControlClientTypes.AdvancedCostOptimizationMetrics.writingClosure(_:to:))
        try writer[.init("AdvancedDataProtectionMetrics")].write(value.advancedDataProtectionMetrics, writingClosure: S3ControlClientTypes.AdvancedDataProtectionMetrics.writingClosure(_:to:))
        try writer[.init("BucketLevel")].write(value.bucketLevel, writingClosure: S3ControlClientTypes.BucketLevel.writingClosure(_:to:))
        try writer[.init("DetailedStatusCodesMetrics")].write(value.detailedStatusCodesMetrics, writingClosure: S3ControlClientTypes.DetailedStatusCodesMetrics.writingClosure(_:to:))
        try writer[.init("StorageLensGroupLevel")].write(value.storageLensGroupLevel, writingClosure: S3ControlClientTypes.StorageLensGroupLevel.writingClosure(_:to:))
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activityMetricsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ActivityMetrics.self, forKey: .activityMetrics)
        activityMetrics = activityMetricsDecoded
        let bucketLevelDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.BucketLevel.self, forKey: .bucketLevel)
        bucketLevel = bucketLevelDecoded
        let advancedCostOptimizationMetricsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.AdvancedCostOptimizationMetrics.self, forKey: .advancedCostOptimizationMetrics)
        advancedCostOptimizationMetrics = advancedCostOptimizationMetricsDecoded
        let advancedDataProtectionMetricsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.AdvancedDataProtectionMetrics.self, forKey: .advancedDataProtectionMetrics)
        advancedDataProtectionMetrics = advancedDataProtectionMetricsDecoded
        let detailedStatusCodesMetricsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.DetailedStatusCodesMetrics.self, forKey: .detailedStatusCodesMetrics)
        detailedStatusCodesMetrics = detailedStatusCodesMetricsDecoded
        let storageLensGroupLevelDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.StorageLensGroupLevel.self, forKey: .storageLensGroupLevel)
        storageLensGroupLevel = storageLensGroupLevelDecoded
    }
}

extension S3ControlClientTypes {
    /// A container element for the account-level Amazon S3 Storage Lens configuration. For more information about S3 Storage Lens, see [Assessing your storage activity and usage with S3 Storage Lens](https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage_lens.html) in the Amazon S3 User Guide. For a complete list of S3 Storage Lens metrics, see [S3 Storage Lens metrics glossary](https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage_lens_metrics_glossary.html) in the Amazon S3 User Guide.
    public struct AccountLevel: Swift.Equatable {
        /// A container element for S3 Storage Lens activity metrics.
        public var activityMetrics: S3ControlClientTypes.ActivityMetrics?
        /// A container element for S3 Storage Lens advanced cost-optimization metrics.
        public var advancedCostOptimizationMetrics: S3ControlClientTypes.AdvancedCostOptimizationMetrics?
        /// A container element for S3 Storage Lens advanced data-protection metrics.
        public var advancedDataProtectionMetrics: S3ControlClientTypes.AdvancedDataProtectionMetrics?
        /// A container element for the S3 Storage Lens bucket-level configuration.
        /// This member is required.
        public var bucketLevel: S3ControlClientTypes.BucketLevel?
        /// A container element for detailed status code metrics.
        public var detailedStatusCodesMetrics: S3ControlClientTypes.DetailedStatusCodesMetrics?
        /// A container element for S3 Storage Lens groups metrics.
        public var storageLensGroupLevel: S3ControlClientTypes.StorageLensGroupLevel?

        public init(
            activityMetrics: S3ControlClientTypes.ActivityMetrics? = nil,
            advancedCostOptimizationMetrics: S3ControlClientTypes.AdvancedCostOptimizationMetrics? = nil,
            advancedDataProtectionMetrics: S3ControlClientTypes.AdvancedDataProtectionMetrics? = nil,
            bucketLevel: S3ControlClientTypes.BucketLevel? = nil,
            detailedStatusCodesMetrics: S3ControlClientTypes.DetailedStatusCodesMetrics? = nil,
            storageLensGroupLevel: S3ControlClientTypes.StorageLensGroupLevel? = nil
        )
        {
            self.activityMetrics = activityMetrics
            self.advancedCostOptimizationMetrics = advancedCostOptimizationMetrics
            self.advancedDataProtectionMetrics = advancedDataProtectionMetrics
            self.bucketLevel = bucketLevel
            self.detailedStatusCodesMetrics = detailedStatusCodesMetrics
            self.storageLensGroupLevel = storageLensGroupLevel
        }
    }

}

extension S3ControlClientTypes.ActivityMetrics: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isEnabled = "IsEnabled"
    }

    static func writingClosure(_ value: S3ControlClientTypes.ActivityMetrics?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("IsEnabled")].write(value.isEnabled)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isEnabled) ?? false
        isEnabled = isEnabledDecoded
    }
}

extension S3ControlClientTypes {
    /// The container element for Amazon S3 Storage Lens activity metrics. Activity metrics show details about how your storage is requested, such as requests (for example, All requests, Get requests, Put requests), bytes uploaded or downloaded, and errors. For more information about S3 Storage Lens, see [Assessing your storage activity and usage with S3 Storage Lens](https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage_lens.html) in the Amazon S3 User Guide. For a complete list of S3 Storage Lens metrics, see [S3 Storage Lens metrics glossary](https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage_lens_metrics_glossary.html) in the Amazon S3 User Guide.
    public struct ActivityMetrics: Swift.Equatable {
        /// A container that indicates whether activity metrics are enabled.
        public var isEnabled: Swift.Bool

        public init(
            isEnabled: Swift.Bool = false
        )
        {
            self.isEnabled = isEnabled
        }
    }

}

extension S3ControlClientTypes.AdvancedCostOptimizationMetrics: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isEnabled = "IsEnabled"
    }

    static func writingClosure(_ value: S3ControlClientTypes.AdvancedCostOptimizationMetrics?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("IsEnabled")].write(value.isEnabled)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isEnabled) ?? false
        isEnabled = isEnabledDecoded
    }
}

extension S3ControlClientTypes {
    /// The container element for Amazon S3 Storage Lens advanced cost-optimization metrics. Advanced cost-optimization metrics provide insights that you can use to manage and optimize your storage costs, for example, lifecycle rule counts for transitions, expirations, and incomplete multipart uploads. For more information about S3 Storage Lens, see [Assessing your storage activity and usage with S3 Storage Lens](https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage_lens.html) in the Amazon S3 User Guide. For a complete list of S3 Storage Lens metrics, see [S3 Storage Lens metrics glossary](https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage_lens_metrics_glossary.html) in the Amazon S3 User Guide.
    public struct AdvancedCostOptimizationMetrics: Swift.Equatable {
        /// A container that indicates whether advanced cost-optimization metrics are enabled.
        public var isEnabled: Swift.Bool

        public init(
            isEnabled: Swift.Bool = false
        )
        {
            self.isEnabled = isEnabled
        }
    }

}

extension S3ControlClientTypes.AdvancedDataProtectionMetrics: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isEnabled = "IsEnabled"
    }

    static func writingClosure(_ value: S3ControlClientTypes.AdvancedDataProtectionMetrics?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("IsEnabled")].write(value.isEnabled)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isEnabled) ?? false
        isEnabled = isEnabledDecoded
    }
}

extension S3ControlClientTypes {
    /// The container element for Amazon S3 Storage Lens advanced data-protection metrics. Advanced data-protection metrics provide insights that you can use to perform audits and protect your data, for example replication rule counts within and across Regions. For more information about S3 Storage Lens, see [Assessing your storage activity and usage with S3 Storage Lens](https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage_lens.html) in the Amazon S3 User Guide. For a complete list of S3 Storage Lens metrics, see [S3 Storage Lens metrics glossary](https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage_lens_metrics_glossary.html) in the Amazon S3 User Guide.
    public struct AdvancedDataProtectionMetrics: Swift.Equatable {
        /// A container that indicates whether advanced data-protection metrics are enabled.
        public var isEnabled: Swift.Bool

        public init(
            isEnabled: Swift.Bool = false
        )
        {
            self.isEnabled = isEnabled
        }
    }

}

extension AssociateAccessGrantsIdentityCenterInput {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityCenterArn = "IdentityCenterArn"
    }

    static func writingClosure(_ value: AssociateAccessGrantsIdentityCenterInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("IdentityCenterArn")].write(value.identityCenterArn)
    }
}

extension AssociateAccessGrantsIdentityCenterInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension AssociateAccessGrantsIdentityCenterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/accessgrantsinstance/identitycenter"
    }
}

public struct AssociateAccessGrantsIdentityCenterInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that is making this request.
    /// This member is required.
    public var accountId: Swift.String?
    /// The Amazon Resource Name (ARN) of the Amazon Web Services IAM Identity Center instance that you are associating with your S3 Access Grants instance. An IAM Identity Center instance is your corporate identity directory that you added to the IAM Identity Center. You can use the [ListInstances](https://docs.aws.amazon.com/singlesignon/latest/APIReference/API_ListInstances.html) API operation to retrieve a list of your Identity Center instances and their ARNs.
    /// This member is required.
    public var identityCenterArn: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        identityCenterArn: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.identityCenterArn = identityCenterArn
    }
}

struct AssociateAccessGrantsIdentityCenterInputBody: Swift.Equatable {
    let identityCenterArn: Swift.String?
}

extension AssociateAccessGrantsIdentityCenterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityCenterArn = "IdentityCenterArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityCenterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityCenterArn)
        identityCenterArn = identityCenterArnDecoded
    }
}

extension AssociateAccessGrantsIdentityCenterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateAccessGrantsIdentityCenterOutput: Swift.Equatable {

    public init() { }
}

enum AssociateAccessGrantsIdentityCenterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension S3ControlClientTypes.AsyncErrorDetails: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
        case resource = "Resource"
    }

    static func writingClosure(_ value: S3ControlClientTypes.AsyncErrorDetails?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Code")].write(value.code)
        try writer[.init("Message")].write(value.message)
        try writer[.init("RequestId")].write(value.requestId)
        try writer[.init("Resource")].write(value.resource)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resource)
        resource = resourceDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension S3ControlClientTypes {
    /// Error details for the failed asynchronous operation.
    public struct AsyncErrorDetails: Swift.Equatable {
        /// A string that uniquely identifies the error condition.
        public var code: Swift.String?
        /// A generic description of the error condition in English.
        public var message: Swift.String?
        /// The ID of the request associated with the error.
        public var requestId: Swift.String?
        /// The identifier of the resource associated with the error.
        public var resource: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil,
            requestId: Swift.String? = nil,
            resource: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
            self.requestId = requestId
            self.resource = resource
        }
    }

}

extension S3ControlClientTypes.AsyncOperation: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case operation = "Operation"
        case requestParameters = "RequestParameters"
        case requestStatus = "RequestStatus"
        case requestTokenARN = "RequestTokenARN"
        case responseDetails = "ResponseDetails"
    }

    static func writingClosure(_ value: S3ControlClientTypes.AsyncOperation?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("CreationTime")].writeTimestamp(value.creationTime, format: .dateTime)
        try writer[.init("Operation")].write(value.operation)
        try writer[.init("RequestParameters")].write(value.requestParameters, writingClosure: S3ControlClientTypes.AsyncRequestParameters.writingClosure(_:to:))
        try writer[.init("RequestStatus")].write(value.requestStatus)
        try writer[.init("RequestTokenARN")].write(value.requestTokenARN)
        try writer[.init("ResponseDetails")].write(value.responseDetails, writingClosure: S3ControlClientTypes.AsyncResponseDetails.writingClosure(_:to:))
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let operationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.AsyncOperationName.self, forKey: .operation)
        operation = operationDecoded
        let requestTokenARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestTokenARN)
        requestTokenARN = requestTokenARNDecoded
        let requestParametersDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.AsyncRequestParameters.self, forKey: .requestParameters)
        requestParameters = requestParametersDecoded
        let requestStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestStatus)
        requestStatus = requestStatusDecoded
        let responseDetailsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.AsyncResponseDetails.self, forKey: .responseDetails)
        responseDetails = responseDetailsDecoded
    }
}

extension S3ControlClientTypes {
    /// A container for the information about an asynchronous operation.
    public struct AsyncOperation: Swift.Equatable {
        /// The time that the request was sent to the service.
        public var creationTime: ClientRuntime.Date?
        /// The specific operation for the asynchronous request.
        public var operation: S3ControlClientTypes.AsyncOperationName?
        /// The parameters associated with the request.
        public var requestParameters: S3ControlClientTypes.AsyncRequestParameters?
        /// The current status of the request.
        public var requestStatus: Swift.String?
        /// The request token associated with the request.
        public var requestTokenARN: Swift.String?
        /// The details of the response.
        public var responseDetails: S3ControlClientTypes.AsyncResponseDetails?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            operation: S3ControlClientTypes.AsyncOperationName? = nil,
            requestParameters: S3ControlClientTypes.AsyncRequestParameters? = nil,
            requestStatus: Swift.String? = nil,
            requestTokenARN: Swift.String? = nil,
            responseDetails: S3ControlClientTypes.AsyncResponseDetails? = nil
        )
        {
            self.creationTime = creationTime
            self.operation = operation
            self.requestParameters = requestParameters
            self.requestStatus = requestStatus
            self.requestTokenARN = requestTokenARN
            self.responseDetails = responseDetails
        }
    }

}

extension S3ControlClientTypes {
    public enum AsyncOperationName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createmultiregionaccesspoint
        case deletemultiregionaccesspoint
        case putmultiregionaccesspointpolicy
        case sdkUnknown(Swift.String)

        public static var allCases: [AsyncOperationName] {
            return [
                .createmultiregionaccesspoint,
                .deletemultiregionaccesspoint,
                .putmultiregionaccesspointpolicy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createmultiregionaccesspoint: return "CreateMultiRegionAccessPoint"
            case .deletemultiregionaccesspoint: return "DeleteMultiRegionAccessPoint"
            case .putmultiregionaccesspointpolicy: return "PutMultiRegionAccessPointPolicy"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AsyncOperationName(rawValue: rawValue) ?? AsyncOperationName.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.AsyncRequestParameters: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createMultiRegionAccessPointRequest = "CreateMultiRegionAccessPointRequest"
        case deleteMultiRegionAccessPointRequest = "DeleteMultiRegionAccessPointRequest"
        case putMultiRegionAccessPointPolicyRequest = "PutMultiRegionAccessPointPolicyRequest"
    }

    static func writingClosure(_ value: S3ControlClientTypes.AsyncRequestParameters?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("CreateMultiRegionAccessPointRequest")].write(value.createMultiRegionAccessPointRequest, writingClosure: S3ControlClientTypes.CreateMultiRegionAccessPointInput.writingClosure(_:to:))
        try writer[.init("DeleteMultiRegionAccessPointRequest")].write(value.deleteMultiRegionAccessPointRequest, writingClosure: S3ControlClientTypes.DeleteMultiRegionAccessPointInput.writingClosure(_:to:))
        try writer[.init("PutMultiRegionAccessPointPolicyRequest")].write(value.putMultiRegionAccessPointPolicyRequest, writingClosure: S3ControlClientTypes.PutMultiRegionAccessPointPolicyInput.writingClosure(_:to:))
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createMultiRegionAccessPointRequestDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.CreateMultiRegionAccessPointInput.self, forKey: .createMultiRegionAccessPointRequest)
        createMultiRegionAccessPointRequest = createMultiRegionAccessPointRequestDecoded
        let deleteMultiRegionAccessPointRequestDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.DeleteMultiRegionAccessPointInput.self, forKey: .deleteMultiRegionAccessPointRequest)
        deleteMultiRegionAccessPointRequest = deleteMultiRegionAccessPointRequestDecoded
        let putMultiRegionAccessPointPolicyRequestDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.PutMultiRegionAccessPointPolicyInput.self, forKey: .putMultiRegionAccessPointPolicyRequest)
        putMultiRegionAccessPointPolicyRequest = putMultiRegionAccessPointPolicyRequestDecoded
    }
}

extension S3ControlClientTypes {
    /// A container for the request parameters associated with an asynchronous request.
    public struct AsyncRequestParameters: Swift.Equatable {
        /// A container of the parameters for a [CreateMultiRegionAccessPoint](https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_CreateMultiRegionAccessPoint.html) request.
        public var createMultiRegionAccessPointRequest: S3ControlClientTypes.CreateMultiRegionAccessPointInput?
        /// A container of the parameters for a [DeleteMultiRegionAccessPoint](https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_DeleteMultiRegionAccessPoint.html) request.
        public var deleteMultiRegionAccessPointRequest: S3ControlClientTypes.DeleteMultiRegionAccessPointInput?
        /// A container of the parameters for a [PutMultiRegionAccessPoint](https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_PutMultiRegionAccessPoint.html) request.
        public var putMultiRegionAccessPointPolicyRequest: S3ControlClientTypes.PutMultiRegionAccessPointPolicyInput?

        public init(
            createMultiRegionAccessPointRequest: S3ControlClientTypes.CreateMultiRegionAccessPointInput? = nil,
            deleteMultiRegionAccessPointRequest: S3ControlClientTypes.DeleteMultiRegionAccessPointInput? = nil,
            putMultiRegionAccessPointPolicyRequest: S3ControlClientTypes.PutMultiRegionAccessPointPolicyInput? = nil
        )
        {
            self.createMultiRegionAccessPointRequest = createMultiRegionAccessPointRequest
            self.deleteMultiRegionAccessPointRequest = deleteMultiRegionAccessPointRequest
            self.putMultiRegionAccessPointPolicyRequest = putMultiRegionAccessPointPolicyRequest
        }
    }

}

extension S3ControlClientTypes.AsyncResponseDetails: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorDetails = "ErrorDetails"
        case multiRegionAccessPointDetails = "MultiRegionAccessPointDetails"
    }

    static func writingClosure(_ value: S3ControlClientTypes.AsyncResponseDetails?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("ErrorDetails")].write(value.errorDetails, writingClosure: S3ControlClientTypes.AsyncErrorDetails.writingClosure(_:to:))
        try writer[.init("MultiRegionAccessPointDetails")].write(value.multiRegionAccessPointDetails, writingClosure: S3ControlClientTypes.MultiRegionAccessPointsAsyncResponse.writingClosure(_:to:))
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let multiRegionAccessPointDetailsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.MultiRegionAccessPointsAsyncResponse.self, forKey: .multiRegionAccessPointDetails)
        multiRegionAccessPointDetails = multiRegionAccessPointDetailsDecoded
        let errorDetailsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.AsyncErrorDetails.self, forKey: .errorDetails)
        errorDetails = errorDetailsDecoded
    }
}

extension S3ControlClientTypes {
    /// A container for the response details that are returned when querying about an asynchronous request.
    public struct AsyncResponseDetails: Swift.Equatable {
        /// Error details for an asynchronous request.
        public var errorDetails: S3ControlClientTypes.AsyncErrorDetails?
        /// The details for the Multi-Region Access Point.
        public var multiRegionAccessPointDetails: S3ControlClientTypes.MultiRegionAccessPointsAsyncResponse?

        public init(
            errorDetails: S3ControlClientTypes.AsyncErrorDetails? = nil,
            multiRegionAccessPointDetails: S3ControlClientTypes.MultiRegionAccessPointsAsyncResponse? = nil
        )
        {
            self.errorDetails = errorDetails
            self.multiRegionAccessPointDetails = multiRegionAccessPointDetails
        }
    }

}

extension S3ControlClientTypes.AwsLambdaTransformation: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionArn = "FunctionArn"
        case functionPayload = "FunctionPayload"
    }

    static func writingClosure(_ value: S3ControlClientTypes.AwsLambdaTransformation?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("FunctionArn")].write(value.functionArn)
        try writer[.init("FunctionPayload")].write(value.functionPayload)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let functionPayloadDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionPayload)
        functionPayload = functionPayloadDecoded
    }
}

extension S3ControlClientTypes {
    /// Lambda function used to transform objects through an Object Lambda Access Point.
    public struct AwsLambdaTransformation: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Lambda function.
        /// This member is required.
        public var functionArn: Swift.String?
        /// Additional JSON that provides supplemental data to the Lambda function used to transform objects.
        public var functionPayload: Swift.String?

        public init(
            functionArn: Swift.String? = nil,
            functionPayload: Swift.String? = nil
        )
        {
            self.functionArn = functionArn
            self.functionPayload = functionPayload
        }
    }

}

extension BadRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<BadRequestExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BucketAlreadyExists {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The requested Outposts bucket name is not available. The bucket namespace is shared by all users of the Outposts in this Region. Select a different name and try again.
public struct BucketAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {
    public static var typeName: Swift.String { "BucketAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init() { }
}

extension BucketAlreadyOwnedByYou {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The Outposts bucket you tried to create already exists, and you own it.
public struct BucketAlreadyOwnedByYou: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {
    public static var typeName: Swift.String { "BucketAlreadyOwnedByYou" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init() { }
}

extension S3ControlClientTypes {
    public enum BucketCannedACL: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case authenticatedRead
        case `private`
        case publicRead
        case publicReadWrite
        case sdkUnknown(Swift.String)

        public static var allCases: [BucketCannedACL] {
            return [
                .authenticatedRead,
                .private,
                .publicRead,
                .publicReadWrite,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .authenticatedRead: return "authenticated-read"
            case .private: return "private"
            case .publicRead: return "public-read"
            case .publicReadWrite: return "public-read-write"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BucketCannedACL(rawValue: rawValue) ?? BucketCannedACL.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.BucketLevel: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activityMetrics = "ActivityMetrics"
        case advancedCostOptimizationMetrics = "AdvancedCostOptimizationMetrics"
        case advancedDataProtectionMetrics = "AdvancedDataProtectionMetrics"
        case detailedStatusCodesMetrics = "DetailedStatusCodesMetrics"
        case prefixLevel = "PrefixLevel"
    }

    static func writingClosure(_ value: S3ControlClientTypes.BucketLevel?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("ActivityMetrics")].write(value.activityMetrics, writingClosure: S3ControlClientTypes.ActivityMetrics.writingClosure(_:to:))
        try writer[.init("AdvancedCostOptimizationMetrics")].write(value.advancedCostOptimizationMetrics, writingClosure: S3ControlClientTypes.AdvancedCostOptimizationMetrics.writingClosure(_:to:))
        try writer[.init("AdvancedDataProtectionMetrics")].write(value.advancedDataProtectionMetrics, writingClosure: S3ControlClientTypes.AdvancedDataProtectionMetrics.writingClosure(_:to:))
        try writer[.init("DetailedStatusCodesMetrics")].write(value.detailedStatusCodesMetrics, writingClosure: S3ControlClientTypes.DetailedStatusCodesMetrics.writingClosure(_:to:))
        try writer[.init("PrefixLevel")].write(value.prefixLevel, writingClosure: S3ControlClientTypes.PrefixLevel.writingClosure(_:to:))
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activityMetricsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ActivityMetrics.self, forKey: .activityMetrics)
        activityMetrics = activityMetricsDecoded
        let prefixLevelDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.PrefixLevel.self, forKey: .prefixLevel)
        prefixLevel = prefixLevelDecoded
        let advancedCostOptimizationMetricsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.AdvancedCostOptimizationMetrics.self, forKey: .advancedCostOptimizationMetrics)
        advancedCostOptimizationMetrics = advancedCostOptimizationMetricsDecoded
        let advancedDataProtectionMetricsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.AdvancedDataProtectionMetrics.self, forKey: .advancedDataProtectionMetrics)
        advancedDataProtectionMetrics = advancedDataProtectionMetricsDecoded
        let detailedStatusCodesMetricsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.DetailedStatusCodesMetrics.self, forKey: .detailedStatusCodesMetrics)
        detailedStatusCodesMetrics = detailedStatusCodesMetricsDecoded
    }
}

extension S3ControlClientTypes {
    /// A container for the bucket-level configuration for Amazon S3 Storage Lens. For more information about S3 Storage Lens, see [Assessing your storage activity and usage with S3 Storage Lens](https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage_lens.html) in the Amazon S3 User Guide.
    public struct BucketLevel: Swift.Equatable {
        /// A container for the bucket-level activity metrics for S3 Storage Lens.
        public var activityMetrics: S3ControlClientTypes.ActivityMetrics?
        /// A container for bucket-level advanced cost-optimization metrics for S3 Storage Lens.
        public var advancedCostOptimizationMetrics: S3ControlClientTypes.AdvancedCostOptimizationMetrics?
        /// A container for bucket-level advanced data-protection metrics for S3 Storage Lens.
        public var advancedDataProtectionMetrics: S3ControlClientTypes.AdvancedDataProtectionMetrics?
        /// A container for bucket-level detailed status code metrics for S3 Storage Lens.
        public var detailedStatusCodesMetrics: S3ControlClientTypes.DetailedStatusCodesMetrics?
        /// A container for the prefix-level metrics for S3 Storage Lens.
        public var prefixLevel: S3ControlClientTypes.PrefixLevel?

        public init(
            activityMetrics: S3ControlClientTypes.ActivityMetrics? = nil,
            advancedCostOptimizationMetrics: S3ControlClientTypes.AdvancedCostOptimizationMetrics? = nil,
            advancedDataProtectionMetrics: S3ControlClientTypes.AdvancedDataProtectionMetrics? = nil,
            detailedStatusCodesMetrics: S3ControlClientTypes.DetailedStatusCodesMetrics? = nil,
            prefixLevel: S3ControlClientTypes.PrefixLevel? = nil
        )
        {
            self.activityMetrics = activityMetrics
            self.advancedCostOptimizationMetrics = advancedCostOptimizationMetrics
            self.advancedDataProtectionMetrics = advancedDataProtectionMetrics
            self.detailedStatusCodesMetrics = detailedStatusCodesMetrics
            self.prefixLevel = prefixLevel
        }
    }

}

extension S3ControlClientTypes {
    public enum BucketLocationConstraint: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case eu
        case apNortheast1
        case apSouth1
        case apSoutheast1
        case apSoutheast2
        case cnNorth1
        case euCentral1
        case euWest1
        case saEast1
        case usWest1
        case usWest2
        case sdkUnknown(Swift.String)

        public static var allCases: [BucketLocationConstraint] {
            return [
                .eu,
                .apNortheast1,
                .apSouth1,
                .apSoutheast1,
                .apSoutheast2,
                .cnNorth1,
                .euCentral1,
                .euWest1,
                .saEast1,
                .usWest1,
                .usWest2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .eu: return "EU"
            case .apNortheast1: return "ap-northeast-1"
            case .apSouth1: return "ap-south-1"
            case .apSoutheast1: return "ap-southeast-1"
            case .apSoutheast2: return "ap-southeast-2"
            case .cnNorth1: return "cn-north-1"
            case .euCentral1: return "eu-central-1"
            case .euWest1: return "eu-west-1"
            case .saEast1: return "sa-east-1"
            case .usWest1: return "us-west-1"
            case .usWest2: return "us-west-2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BucketLocationConstraint(rawValue: rawValue) ?? BucketLocationConstraint.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum BucketVersioningStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enabled
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [BucketVersioningStatus] {
            return [
                .enabled,
                .suspended,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enabled: return "Enabled"
            case .suspended: return "Suspended"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BucketVersioningStatus(rawValue: rawValue) ?? BucketVersioningStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.CloudWatchMetrics: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isEnabled = "IsEnabled"
    }

    static func writingClosure(_ value: S3ControlClientTypes.CloudWatchMetrics?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("IsEnabled")].write(value.isEnabled)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isEnabled) ?? false
        isEnabled = isEnabledDecoded
    }
}

extension S3ControlClientTypes {
    /// A container for enabling Amazon CloudWatch publishing for S3 Storage Lens metrics. For more information about publishing S3 Storage Lens metrics to CloudWatch, see [Monitor S3 Storage Lens metrics in CloudWatch](https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage_lens_view_metrics_cloudwatch.html) in the Amazon S3 User Guide.
    public struct CloudWatchMetrics: Swift.Equatable {
        /// A container that indicates whether CloudWatch publishing for S3 Storage Lens metrics is enabled. A value of true indicates that CloudWatch publishing for S3 Storage Lens metrics is enabled.
        /// This member is required.
        public var isEnabled: Swift.Bool

        public init(
            isEnabled: Swift.Bool = false
        )
        {
            self.isEnabled = isEnabled
        }
    }

}

extension CreateAccessGrantInput {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessGrantsLocationConfiguration = "AccessGrantsLocationConfiguration"
        case accessGrantsLocationId = "AccessGrantsLocationId"
        case applicationArn = "ApplicationArn"
        case grantee = "Grantee"
        case permission = "Permission"
        case s3PrefixType = "S3PrefixType"
        case tags = "Tags"
    }

    static func writingClosure(_ value: CreateAccessGrantInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("AccessGrantsLocationConfiguration")].write(value.accessGrantsLocationConfiguration, writingClosure: S3ControlClientTypes.AccessGrantsLocationConfiguration.writingClosure(_:to:))
        try writer[.init("AccessGrantsLocationId")].write(value.accessGrantsLocationId)
        try writer[.init("ApplicationArn")].write(value.applicationArn)
        try writer[.init("Grantee")].write(value.grantee, writingClosure: S3ControlClientTypes.Grantee.writingClosure(_:to:))
        try writer[.init("Permission")].write(value.permission)
        try writer[.init("S3PrefixType")].write(value.s3PrefixType)
        try writer[.init("Tags")].writeList(value.tags, memberWritingClosure: S3ControlClientTypes.Tag.writingClosure(_:to:), memberNodeInfo: .init("Tag"), isFlattened: false)
    }
}

extension CreateAccessGrantInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension CreateAccessGrantInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/accessgrantsinstance/grant"
    }
}

public struct CreateAccessGrantInput: Swift.Equatable {
    /// The configuration options of the grant location. The grant location is the S3 path to the data to which you are granting access. It contains the S3SubPrefix field. The grant scope is the result of appending the subprefix to the location scope of the registered location.
    public var accessGrantsLocationConfiguration: S3ControlClientTypes.AccessGrantsLocationConfiguration?
    /// The ID of the registered location to which you are granting access. S3 Access Grants assigns this ID when you register the location. S3 Access Grants assigns the ID default to the default location s3:// and assigns an auto-generated ID to other locations that you register. If you are passing the default location, you cannot create an access grant for the entire default location. You must also specify a bucket or a bucket and prefix in the Subprefix field.
    /// This member is required.
    public var accessGrantsLocationId: Swift.String?
    /// The ID of the Amazon Web Services account that is making this request.
    /// This member is required.
    public var accountId: Swift.String?
    /// The Amazon Resource Name (ARN) of an Amazon Web Services IAM Identity Center application associated with your Identity Center instance. If an application ARN is included in the request to create an access grant, the grantee can only access the S3 data through this application.
    public var applicationArn: Swift.String?
    /// The user, group, or role to which you are granting access. You can grant access to an IAM user or role. If you have added your corporate directory to Amazon Web Services IAM Identity Center and associated your Identity Center instance with your S3 Access Grants instance, the grantee can also be a corporate directory user or group.
    /// This member is required.
    public var grantee: S3ControlClientTypes.Grantee?
    /// The type of access that you are granting to your S3 data, which can be set to one of the following values:
    ///
    /// * READ – Grant read-only access to the S3 data.
    ///
    /// * WRITE – Grant write-only access to the S3 data.
    ///
    /// * READWRITE – Grant both read and write access to the S3 data.
    /// This member is required.
    public var permission: S3ControlClientTypes.Permission?
    /// The type of S3SubPrefix. The only possible value is Object. Pass this value if the access grant scope is an object. Do not pass this value if the access grant scope is a bucket or a bucket and a prefix.
    public var s3PrefixType: S3ControlClientTypes.S3PrefixType?
    /// The Amazon Web Services resource tags that you are adding to the access grant. Each tag is a label consisting of a user-defined key and value. Tags can help you manage, identify, organize, search for, and filter resources.
    public var tags: [S3ControlClientTypes.Tag]?

    public init(
        accessGrantsLocationConfiguration: S3ControlClientTypes.AccessGrantsLocationConfiguration? = nil,
        accessGrantsLocationId: Swift.String? = nil,
        accountId: Swift.String? = nil,
        applicationArn: Swift.String? = nil,
        grantee: S3ControlClientTypes.Grantee? = nil,
        permission: S3ControlClientTypes.Permission? = nil,
        s3PrefixType: S3ControlClientTypes.S3PrefixType? = nil,
        tags: [S3ControlClientTypes.Tag]? = nil
    )
    {
        self.accessGrantsLocationConfiguration = accessGrantsLocationConfiguration
        self.accessGrantsLocationId = accessGrantsLocationId
        self.accountId = accountId
        self.applicationArn = applicationArn
        self.grantee = grantee
        self.permission = permission
        self.s3PrefixType = s3PrefixType
        self.tags = tags
    }
}

struct CreateAccessGrantInputBody: Swift.Equatable {
    let accessGrantsLocationId: Swift.String?
    let accessGrantsLocationConfiguration: S3ControlClientTypes.AccessGrantsLocationConfiguration?
    let grantee: S3ControlClientTypes.Grantee?
    let permission: S3ControlClientTypes.Permission?
    let applicationArn: Swift.String?
    let s3PrefixType: S3ControlClientTypes.S3PrefixType?
    let tags: [S3ControlClientTypes.Tag]?
}

extension CreateAccessGrantInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessGrantsLocationConfiguration = "AccessGrantsLocationConfiguration"
        case accessGrantsLocationId = "AccessGrantsLocationId"
        case applicationArn = "ApplicationArn"
        case grantee = "Grantee"
        case permission = "Permission"
        case s3PrefixType = "S3PrefixType"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessGrantsLocationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessGrantsLocationId)
        accessGrantsLocationId = accessGrantsLocationIdDecoded
        let accessGrantsLocationConfigurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.AccessGrantsLocationConfiguration.self, forKey: .accessGrantsLocationConfiguration)
        accessGrantsLocationConfiguration = accessGrantsLocationConfigurationDecoded
        let granteeDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.Grantee.self, forKey: .grantee)
        grantee = granteeDecoded
        let permissionDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.Permission.self, forKey: .permission)
        permission = permissionDecoded
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let s3PrefixTypeDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3PrefixType.self, forKey: .s3PrefixType)
        s3PrefixType = s3PrefixTypeDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([S3ControlClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[S3ControlClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [S3ControlClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension CreateAccessGrantOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAccessGrantOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessGrantArn = output.accessGrantArn
            self.accessGrantId = output.accessGrantId
            self.accessGrantsLocationConfiguration = output.accessGrantsLocationConfiguration
            self.accessGrantsLocationId = output.accessGrantsLocationId
            self.applicationArn = output.applicationArn
            self.createdAt = output.createdAt
            self.grantScope = output.grantScope
            self.grantee = output.grantee
            self.permission = output.permission
        } else {
            self.accessGrantArn = nil
            self.accessGrantId = nil
            self.accessGrantsLocationConfiguration = nil
            self.accessGrantsLocationId = nil
            self.applicationArn = nil
            self.createdAt = nil
            self.grantScope = nil
            self.grantee = nil
            self.permission = nil
        }
    }
}

public struct CreateAccessGrantOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the access grant.
    public var accessGrantArn: Swift.String?
    /// The ID of the access grant. S3 Access Grants auto-generates this ID when you create the access grant.
    public var accessGrantId: Swift.String?
    /// The configuration options of the grant location. The grant location is the S3 path to the data to which you are granting access.
    public var accessGrantsLocationConfiguration: S3ControlClientTypes.AccessGrantsLocationConfiguration?
    /// The ID of the registered location to which you are granting access. S3 Access Grants assigns this ID when you register the location. S3 Access Grants assigns the ID default to the default location s3:// and assigns an auto-generated ID to other locations that you register.
    public var accessGrantsLocationId: Swift.String?
    /// The Amazon Resource Name (ARN) of an Amazon Web Services IAM Identity Center application associated with your Identity Center instance. If the grant includes an application ARN, the grantee can only access the S3 data through this application.
    public var applicationArn: Swift.String?
    /// The date and time when you created the access grant.
    public var createdAt: ClientRuntime.Date?
    /// The S3 path of the data to which you are granting access. It is the result of appending the Subprefix to the location scope.
    public var grantScope: Swift.String?
    /// The user, group, or role to which you are granting access. You can grant access to an IAM user or role. If you have added your corporate directory to Amazon Web Services IAM Identity Center and associated your Identity Center instance with your S3 Access Grants instance, the grantee can also be a corporate directory user or group.
    public var grantee: S3ControlClientTypes.Grantee?
    /// The type of access that you are granting to your S3 data, which can be set to one of the following values:
    ///
    /// * READ – Grant read-only access to the S3 data.
    ///
    /// * WRITE – Grant write-only access to the S3 data.
    ///
    /// * READWRITE – Grant both read and write access to the S3 data.
    public var permission: S3ControlClientTypes.Permission?

    public init(
        accessGrantArn: Swift.String? = nil,
        accessGrantId: Swift.String? = nil,
        accessGrantsLocationConfiguration: S3ControlClientTypes.AccessGrantsLocationConfiguration? = nil,
        accessGrantsLocationId: Swift.String? = nil,
        applicationArn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        grantScope: Swift.String? = nil,
        grantee: S3ControlClientTypes.Grantee? = nil,
        permission: S3ControlClientTypes.Permission? = nil
    )
    {
        self.accessGrantArn = accessGrantArn
        self.accessGrantId = accessGrantId
        self.accessGrantsLocationConfiguration = accessGrantsLocationConfiguration
        self.accessGrantsLocationId = accessGrantsLocationId
        self.applicationArn = applicationArn
        self.createdAt = createdAt
        self.grantScope = grantScope
        self.grantee = grantee
        self.permission = permission
    }
}

struct CreateAccessGrantOutputBody: Swift.Equatable {
    let createdAt: ClientRuntime.Date?
    let accessGrantId: Swift.String?
    let accessGrantArn: Swift.String?
    let grantee: S3ControlClientTypes.Grantee?
    let accessGrantsLocationId: Swift.String?
    let accessGrantsLocationConfiguration: S3ControlClientTypes.AccessGrantsLocationConfiguration?
    let permission: S3ControlClientTypes.Permission?
    let applicationArn: Swift.String?
    let grantScope: Swift.String?
}

extension CreateAccessGrantOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessGrantArn = "AccessGrantArn"
        case accessGrantId = "AccessGrantId"
        case accessGrantsLocationConfiguration = "AccessGrantsLocationConfiguration"
        case accessGrantsLocationId = "AccessGrantsLocationId"
        case applicationArn = "ApplicationArn"
        case createdAt = "CreatedAt"
        case grantScope = "GrantScope"
        case grantee = "Grantee"
        case permission = "Permission"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let accessGrantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessGrantId)
        accessGrantId = accessGrantIdDecoded
        let accessGrantArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessGrantArn)
        accessGrantArn = accessGrantArnDecoded
        let granteeDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.Grantee.self, forKey: .grantee)
        grantee = granteeDecoded
        let accessGrantsLocationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessGrantsLocationId)
        accessGrantsLocationId = accessGrantsLocationIdDecoded
        let accessGrantsLocationConfigurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.AccessGrantsLocationConfiguration.self, forKey: .accessGrantsLocationConfiguration)
        accessGrantsLocationConfiguration = accessGrantsLocationConfigurationDecoded
        let permissionDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.Permission.self, forKey: .permission)
        permission = permissionDecoded
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let grantScopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantScope)
        grantScope = grantScopeDecoded
    }
}

enum CreateAccessGrantOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension CreateAccessGrantsInstanceInput {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityCenterArn = "IdentityCenterArn"
        case tags = "Tags"
    }

    static func writingClosure(_ value: CreateAccessGrantsInstanceInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("IdentityCenterArn")].write(value.identityCenterArn)
        try writer[.init("Tags")].writeList(value.tags, memberWritingClosure: S3ControlClientTypes.Tag.writingClosure(_:to:), memberNodeInfo: .init("Tag"), isFlattened: false)
    }
}

extension CreateAccessGrantsInstanceInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension CreateAccessGrantsInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/accessgrantsinstance"
    }
}

public struct CreateAccessGrantsInstanceInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that is making this request.
    /// This member is required.
    public var accountId: Swift.String?
    /// If you would like to associate your S3 Access Grants instance with an Amazon Web Services IAM Identity Center instance, use this field to pass the Amazon Resource Name (ARN) of the Amazon Web Services IAM Identity Center instance that you are associating with your S3 Access Grants instance. An IAM Identity Center instance is your corporate identity directory that you added to the IAM Identity Center. You can use the [ListInstances](https://docs.aws.amazon.com/singlesignon/latest/APIReference/API_ListInstances.html) API operation to retrieve a list of your Identity Center instances and their ARNs.
    public var identityCenterArn: Swift.String?
    /// The Amazon Web Services resource tags that you are adding to the S3 Access Grants instance. Each tag is a label consisting of a user-defined key and value. Tags can help you manage, identify, organize, search for, and filter resources.
    public var tags: [S3ControlClientTypes.Tag]?

    public init(
        accountId: Swift.String? = nil,
        identityCenterArn: Swift.String? = nil,
        tags: [S3ControlClientTypes.Tag]? = nil
    )
    {
        self.accountId = accountId
        self.identityCenterArn = identityCenterArn
        self.tags = tags
    }
}

struct CreateAccessGrantsInstanceInputBody: Swift.Equatable {
    let identityCenterArn: Swift.String?
    let tags: [S3ControlClientTypes.Tag]?
}

extension CreateAccessGrantsInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityCenterArn = "IdentityCenterArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityCenterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityCenterArn)
        identityCenterArn = identityCenterArnDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([S3ControlClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[S3ControlClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [S3ControlClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension CreateAccessGrantsInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAccessGrantsInstanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessGrantsInstanceArn = output.accessGrantsInstanceArn
            self.accessGrantsInstanceId = output.accessGrantsInstanceId
            self.createdAt = output.createdAt
            self.identityCenterArn = output.identityCenterArn
        } else {
            self.accessGrantsInstanceArn = nil
            self.accessGrantsInstanceId = nil
            self.createdAt = nil
            self.identityCenterArn = nil
        }
    }
}

public struct CreateAccessGrantsInstanceOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the S3 Access Grants instance.
    public var accessGrantsInstanceArn: Swift.String?
    /// The ID of the S3 Access Grants instance. The ID is default. You can have one S3 Access Grants instance per Region per account.
    public var accessGrantsInstanceId: Swift.String?
    /// The date and time when you created the S3 Access Grants instance.
    public var createdAt: ClientRuntime.Date?
    /// If you associated your S3 Access Grants instance with an Amazon Web Services IAM Identity Center instance, this field returns the Amazon Resource Name (ARN) of the IAM Identity Center instance application; a subresource of the original Identity Center instance passed in the request. S3 Access Grants creates this Identity Center application for this specific S3 Access Grants instance.
    public var identityCenterArn: Swift.String?

    public init(
        accessGrantsInstanceArn: Swift.String? = nil,
        accessGrantsInstanceId: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        identityCenterArn: Swift.String? = nil
    )
    {
        self.accessGrantsInstanceArn = accessGrantsInstanceArn
        self.accessGrantsInstanceId = accessGrantsInstanceId
        self.createdAt = createdAt
        self.identityCenterArn = identityCenterArn
    }
}

struct CreateAccessGrantsInstanceOutputBody: Swift.Equatable {
    let createdAt: ClientRuntime.Date?
    let accessGrantsInstanceId: Swift.String?
    let accessGrantsInstanceArn: Swift.String?
    let identityCenterArn: Swift.String?
}

extension CreateAccessGrantsInstanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessGrantsInstanceArn = "AccessGrantsInstanceArn"
        case accessGrantsInstanceId = "AccessGrantsInstanceId"
        case createdAt = "CreatedAt"
        case identityCenterArn = "IdentityCenterArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let accessGrantsInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessGrantsInstanceId)
        accessGrantsInstanceId = accessGrantsInstanceIdDecoded
        let accessGrantsInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessGrantsInstanceArn)
        accessGrantsInstanceArn = accessGrantsInstanceArnDecoded
        let identityCenterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityCenterArn)
        identityCenterArn = identityCenterArnDecoded
    }
}

enum CreateAccessGrantsInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension CreateAccessGrantsLocationInput {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamRoleArn = "IAMRoleArn"
        case locationScope = "LocationScope"
        case tags = "Tags"
    }

    static func writingClosure(_ value: CreateAccessGrantsLocationInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("IAMRoleArn")].write(value.iamRoleArn)
        try writer[.init("LocationScope")].write(value.locationScope)
        try writer[.init("Tags")].writeList(value.tags, memberWritingClosure: S3ControlClientTypes.Tag.writingClosure(_:to:), memberNodeInfo: .init("Tag"), isFlattened: false)
    }
}

extension CreateAccessGrantsLocationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension CreateAccessGrantsLocationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/accessgrantsinstance/location"
    }
}

public struct CreateAccessGrantsLocationInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that is making this request.
    /// This member is required.
    public var accountId: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role for the registered location. S3 Access Grants assumes this role to manage access to the registered location.
    /// This member is required.
    public var iamRoleArn: Swift.String?
    /// The S3 path to the location that you are registering. The location scope can be the default S3 location s3://, the S3 path to a bucket s3://, or the S3 path to a bucket and prefix s3:///. A prefix in S3 is a string of characters at the beginning of an object key name used to organize the objects that you store in your S3 buckets. For example, object key names that start with the engineering/ prefix or object key names that start with the marketing/campaigns/ prefix.
    /// This member is required.
    public var locationScope: Swift.String?
    /// The Amazon Web Services resource tags that you are adding to the S3 Access Grants location. Each tag is a label consisting of a user-defined key and value. Tags can help you manage, identify, organize, search for, and filter resources.
    public var tags: [S3ControlClientTypes.Tag]?

    public init(
        accountId: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        locationScope: Swift.String? = nil,
        tags: [S3ControlClientTypes.Tag]? = nil
    )
    {
        self.accountId = accountId
        self.iamRoleArn = iamRoleArn
        self.locationScope = locationScope
        self.tags = tags
    }
}

struct CreateAccessGrantsLocationInputBody: Swift.Equatable {
    let locationScope: Swift.String?
    let iamRoleArn: Swift.String?
    let tags: [S3ControlClientTypes.Tag]?
}

extension CreateAccessGrantsLocationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamRoleArn = "IAMRoleArn"
        case locationScope = "LocationScope"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationScopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locationScope)
        locationScope = locationScopeDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([S3ControlClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[S3ControlClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [S3ControlClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension CreateAccessGrantsLocationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAccessGrantsLocationOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessGrantsLocationArn = output.accessGrantsLocationArn
            self.accessGrantsLocationId = output.accessGrantsLocationId
            self.createdAt = output.createdAt
            self.iamRoleArn = output.iamRoleArn
            self.locationScope = output.locationScope
        } else {
            self.accessGrantsLocationArn = nil
            self.accessGrantsLocationId = nil
            self.createdAt = nil
            self.iamRoleArn = nil
            self.locationScope = nil
        }
    }
}

public struct CreateAccessGrantsLocationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the location you are registering.
    public var accessGrantsLocationArn: Swift.String?
    /// The ID of the registered location to which you are granting access. S3 Access Grants assigns this ID when you register the location. S3 Access Grants assigns the ID default to the default location s3:// and assigns an auto-generated ID to other locations that you register.
    public var accessGrantsLocationId: Swift.String?
    /// The date and time when you registered the location.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the IAM role for the registered location. S3 Access Grants assumes this role to manage access to the registered location.
    public var iamRoleArn: Swift.String?
    /// The S3 URI path to the location that you are registering. The location scope can be the default S3 location s3://, the S3 path to a bucket, or the S3 path to a bucket and prefix. A prefix in S3 is a string of characters at the beginning of an object key name used to organize the objects that you store in your S3 buckets. For example, object key names that start with the engineering/ prefix or object key names that start with the marketing/campaigns/ prefix.
    public var locationScope: Swift.String?

    public init(
        accessGrantsLocationArn: Swift.String? = nil,
        accessGrantsLocationId: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        iamRoleArn: Swift.String? = nil,
        locationScope: Swift.String? = nil
    )
    {
        self.accessGrantsLocationArn = accessGrantsLocationArn
        self.accessGrantsLocationId = accessGrantsLocationId
        self.createdAt = createdAt
        self.iamRoleArn = iamRoleArn
        self.locationScope = locationScope
    }
}

struct CreateAccessGrantsLocationOutputBody: Swift.Equatable {
    let createdAt: ClientRuntime.Date?
    let accessGrantsLocationId: Swift.String?
    let accessGrantsLocationArn: Swift.String?
    let locationScope: Swift.String?
    let iamRoleArn: Swift.String?
}

extension CreateAccessGrantsLocationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessGrantsLocationArn = "AccessGrantsLocationArn"
        case accessGrantsLocationId = "AccessGrantsLocationId"
        case createdAt = "CreatedAt"
        case iamRoleArn = "IAMRoleArn"
        case locationScope = "LocationScope"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let accessGrantsLocationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessGrantsLocationId)
        accessGrantsLocationId = accessGrantsLocationIdDecoded
        let accessGrantsLocationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessGrantsLocationArn)
        accessGrantsLocationArn = accessGrantsLocationArnDecoded
        let locationScopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locationScope)
        locationScope = locationScopeDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
    }
}

enum CreateAccessGrantsLocationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension CreateAccessPointForObjectLambdaInput {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
    }

    static func writingClosure(_ value: CreateAccessPointForObjectLambdaInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Configuration")].write(value.configuration, writingClosure: S3ControlClientTypes.ObjectLambdaConfiguration.writingClosure(_:to:))
    }
}

extension CreateAccessPointForObjectLambdaInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension CreateAccessPointForObjectLambdaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v20180820/accesspointforobjectlambda/\(name.urlPercentEncoding())"
    }
}

public struct CreateAccessPointForObjectLambdaInput: Swift.Equatable {
    /// The Amazon Web Services account ID for owner of the specified Object Lambda Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// Object Lambda Access Point configuration as a JSON document.
    /// This member is required.
    public var configuration: S3ControlClientTypes.ObjectLambdaConfiguration?
    /// The name you want to assign to this Object Lambda Access Point.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        configuration: S3ControlClientTypes.ObjectLambdaConfiguration? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.configuration = configuration
        self.name = name
    }
}

struct CreateAccessPointForObjectLambdaInputBody: Swift.Equatable {
    let configuration: S3ControlClientTypes.ObjectLambdaConfiguration?
}

extension CreateAccessPointForObjectLambdaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ObjectLambdaConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension CreateAccessPointForObjectLambdaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAccessPointForObjectLambdaOutputBody = try responseDecoder.decode(responseBody: data)
            self.alias = output.alias
            self.objectLambdaAccessPointArn = output.objectLambdaAccessPointArn
        } else {
            self.alias = nil
            self.objectLambdaAccessPointArn = nil
        }
    }
}

public struct CreateAccessPointForObjectLambdaOutput: Swift.Equatable {
    /// The alias of the Object Lambda Access Point.
    public var alias: S3ControlClientTypes.ObjectLambdaAccessPointAlias?
    /// Specifies the ARN for the Object Lambda Access Point.
    public var objectLambdaAccessPointArn: Swift.String?

    public init(
        alias: S3ControlClientTypes.ObjectLambdaAccessPointAlias? = nil,
        objectLambdaAccessPointArn: Swift.String? = nil
    )
    {
        self.alias = alias
        self.objectLambdaAccessPointArn = objectLambdaAccessPointArn
    }
}

struct CreateAccessPointForObjectLambdaOutputBody: Swift.Equatable {
    let objectLambdaAccessPointArn: Swift.String?
    let alias: S3ControlClientTypes.ObjectLambdaAccessPointAlias?
}

extension CreateAccessPointForObjectLambdaOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case objectLambdaAccessPointArn = "ObjectLambdaAccessPointArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectLambdaAccessPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectLambdaAccessPointArn)
        objectLambdaAccessPointArn = objectLambdaAccessPointArnDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ObjectLambdaAccessPointAlias.self, forKey: .alias)
        alias = aliasDecoded
    }
}

enum CreateAccessPointForObjectLambdaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension CreateAccessPointInput {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case bucketAccountId = "BucketAccountId"
        case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
        case vpcConfiguration = "VpcConfiguration"
    }

    static func writingClosure(_ value: CreateAccessPointInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Bucket")].write(value.bucket)
        try writer[.init("BucketAccountId")].write(value.bucketAccountId)
        try writer[.init("PublicAccessBlockConfiguration")].write(value.publicAccessBlockConfiguration, writingClosure: S3ControlClientTypes.PublicAccessBlockConfiguration.writingClosure(_:to:))
        try writer[.init("VpcConfiguration")].write(value.vpcConfiguration, writingClosure: S3ControlClientTypes.VpcConfiguration.writingClosure(_:to:))
    }
}

extension CreateAccessPointInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension CreateAccessPointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v20180820/accesspoint/\(name.urlPercentEncoding())"
    }
}

public struct CreateAccessPointInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the account that owns the specified access point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the bucket that you want to associate this access point with. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?
    /// The Amazon Web Services account ID associated with the S3 bucket associated with this access point.
    public var bucketAccountId: Swift.String?
    /// The name you want to assign to this access point.
    /// This member is required.
    public var name: Swift.String?
    /// The PublicAccessBlock configuration that you want to apply to the access point.
    public var publicAccessBlockConfiguration: S3ControlClientTypes.PublicAccessBlockConfiguration?
    /// If you include this field, Amazon S3 restricts access to this access point to requests from the specified virtual private cloud (VPC). This is required for creating an access point for Amazon S3 on Outposts buckets.
    public var vpcConfiguration: S3ControlClientTypes.VpcConfiguration?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil,
        bucketAccountId: Swift.String? = nil,
        name: Swift.String? = nil,
        publicAccessBlockConfiguration: S3ControlClientTypes.PublicAccessBlockConfiguration? = nil,
        vpcConfiguration: S3ControlClientTypes.VpcConfiguration? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
        self.bucketAccountId = bucketAccountId
        self.name = name
        self.publicAccessBlockConfiguration = publicAccessBlockConfiguration
        self.vpcConfiguration = vpcConfiguration
    }
}

struct CreateAccessPointInputBody: Swift.Equatable {
    let bucket: Swift.String?
    let vpcConfiguration: S3ControlClientTypes.VpcConfiguration?
    let publicAccessBlockConfiguration: S3ControlClientTypes.PublicAccessBlockConfiguration?
    let bucketAccountId: Swift.String?
}

extension CreateAccessPointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case bucketAccountId = "BucketAccountId"
        case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
        case vpcConfiguration = "VpcConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let vpcConfigurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.VpcConfiguration.self, forKey: .vpcConfiguration)
        vpcConfiguration = vpcConfigurationDecoded
        let publicAccessBlockConfigurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.PublicAccessBlockConfiguration.self, forKey: .publicAccessBlockConfiguration)
        publicAccessBlockConfiguration = publicAccessBlockConfigurationDecoded
        let bucketAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketAccountId)
        bucketAccountId = bucketAccountIdDecoded
    }
}

extension CreateAccessPointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAccessPointOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessPointArn = output.accessPointArn
            self.alias = output.alias
        } else {
            self.accessPointArn = nil
            self.alias = nil
        }
    }
}

public struct CreateAccessPointOutput: Swift.Equatable {
    /// The ARN of the access point. This is only supported by Amazon S3 on Outposts.
    public var accessPointArn: Swift.String?
    /// The name or alias of the access point.
    public var alias: Swift.String?

    public init(
        accessPointArn: Swift.String? = nil,
        alias: Swift.String? = nil
    )
    {
        self.accessPointArn = accessPointArn
        self.alias = alias
    }
}

struct CreateAccessPointOutputBody: Swift.Equatable {
    let accessPointArn: Swift.String?
    let alias: Swift.String?
}

extension CreateAccessPointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPointArn = "AccessPointArn"
        case alias = "Alias"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPointArn)
        accessPointArn = accessPointArnDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
    }
}

enum CreateAccessPointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension S3ControlClientTypes.CreateBucketConfiguration: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case locationConstraint = "LocationConstraint"
    }

    static func writingClosure(_ value: S3ControlClientTypes.CreateBucketConfiguration?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("LocationConstraint")].write(value.locationConstraint)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationConstraintDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.BucketLocationConstraint.self, forKey: .locationConstraint)
        locationConstraint = locationConstraintDecoded
    }
}

extension S3ControlClientTypes {
    /// The container for the bucket configuration. This is not supported by Amazon S3 on Outposts buckets.
    public struct CreateBucketConfiguration: Swift.Equatable {
        /// Specifies the Region where the bucket will be created. If you are creating a bucket on the US East (N. Virginia) Region (us-east-1), you do not need to specify the location. This is not supported by Amazon S3 on Outposts buckets.
        public var locationConstraint: S3ControlClientTypes.BucketLocationConstraint?

        public init(
            locationConstraint: S3ControlClientTypes.BucketLocationConstraint? = nil
        )
        {
            self.locationConstraint = locationConstraint
        }
    }

}

extension CreateBucketInput {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createBucketConfiguration = "CreateBucketConfiguration"
    }

    static func writingClosure(_ value: CreateBucketInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("CreateBucketConfiguration")].write(value.createBucketConfiguration, writingClosure: S3ControlClientTypes.CreateBucketConfiguration.writingClosure(_:to:))
    }
}

extension CreateBucketInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let acl = acl {
            items.add(Header(name: "x-amz-acl", value: Swift.String(acl.rawValue)))
        }
        if let grantFullControl = grantFullControl {
            items.add(Header(name: "x-amz-grant-full-control", value: Swift.String(grantFullControl)))
        }
        if let grantRead = grantRead {
            items.add(Header(name: "x-amz-grant-read", value: Swift.String(grantRead)))
        }
        if let grantReadACP = grantReadACP {
            items.add(Header(name: "x-amz-grant-read-acp", value: Swift.String(grantReadACP)))
        }
        if let grantWrite = grantWrite {
            items.add(Header(name: "x-amz-grant-write", value: Swift.String(grantWrite)))
        }
        if let grantWriteACP = grantWriteACP {
            items.add(Header(name: "x-amz-grant-write-acp", value: Swift.String(grantWriteACP)))
        }
        if let objectLockEnabledForBucket = objectLockEnabledForBucket {
            items.add(Header(name: "x-amz-bucket-object-lock-enabled", value: Swift.String(objectLockEnabledForBucket)))
        }
        if let outpostId = outpostId {
            items.add(Header(name: "x-amz-outpost-id", value: Swift.String(outpostId)))
        }
        return items
    }
}

extension CreateBucketInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())"
    }
}

public struct CreateBucketInput: Swift.Equatable {
    /// The canned ACL to apply to the bucket. This is not supported by Amazon S3 on Outposts buckets.
    public var acl: S3ControlClientTypes.BucketCannedACL?
    /// The name of the bucket.
    /// This member is required.
    public var bucket: Swift.String?
    /// The configuration information for the bucket. This is not supported by Amazon S3 on Outposts buckets.
    public var createBucketConfiguration: S3ControlClientTypes.CreateBucketConfiguration?
    /// Allows grantee the read, write, read ACP, and write ACP permissions on the bucket. This is not supported by Amazon S3 on Outposts buckets.
    public var grantFullControl: Swift.String?
    /// Allows grantee to list the objects in the bucket. This is not supported by Amazon S3 on Outposts buckets.
    public var grantRead: Swift.String?
    /// Allows grantee to read the bucket ACL. This is not supported by Amazon S3 on Outposts buckets.
    public var grantReadACP: Swift.String?
    /// Allows grantee to create, overwrite, and delete any object in the bucket. This is not supported by Amazon S3 on Outposts buckets.
    public var grantWrite: Swift.String?
    /// Allows grantee to write the ACL for the applicable bucket. This is not supported by Amazon S3 on Outposts buckets.
    public var grantWriteACP: Swift.String?
    /// Specifies whether you want S3 Object Lock to be enabled for the new bucket. This is not supported by Amazon S3 on Outposts buckets.
    public var objectLockEnabledForBucket: Swift.Bool?
    /// The ID of the Outposts where the bucket is being created. This ID is required by Amazon S3 on Outposts buckets.
    public var outpostId: Swift.String?

    public init(
        acl: S3ControlClientTypes.BucketCannedACL? = nil,
        bucket: Swift.String? = nil,
        createBucketConfiguration: S3ControlClientTypes.CreateBucketConfiguration? = nil,
        grantFullControl: Swift.String? = nil,
        grantRead: Swift.String? = nil,
        grantReadACP: Swift.String? = nil,
        grantWrite: Swift.String? = nil,
        grantWriteACP: Swift.String? = nil,
        objectLockEnabledForBucket: Swift.Bool? = nil,
        outpostId: Swift.String? = nil
    )
    {
        self.acl = acl
        self.bucket = bucket
        self.createBucketConfiguration = createBucketConfiguration
        self.grantFullControl = grantFullControl
        self.grantRead = grantRead
        self.grantReadACP = grantReadACP
        self.grantWrite = grantWrite
        self.grantWriteACP = grantWriteACP
        self.objectLockEnabledForBucket = objectLockEnabledForBucket
        self.outpostId = outpostId
    }
}

struct CreateBucketInputBody: Swift.Equatable {
    let createBucketConfiguration: S3ControlClientTypes.CreateBucketConfiguration?
}

extension CreateBucketInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createBucketConfiguration = "CreateBucketConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createBucketConfigurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.CreateBucketConfiguration.self, forKey: .createBucketConfiguration)
        createBucketConfiguration = createBucketConfigurationDecoded
    }
}

extension CreateBucketOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateBucketOutputBody = try responseDecoder.decode(responseBody: data)
            self.bucketArn = output.bucketArn
        } else {
            self.bucketArn = nil
        }
    }
}

public struct CreateBucketOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the bucket. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    public var bucketArn: Swift.String?
    /// The location of the bucket.
    public var location: Swift.String?

    public init(
        bucketArn: Swift.String? = nil,
        location: Swift.String? = nil
    )
    {
        self.bucketArn = bucketArn
        self.location = location
    }
}

struct CreateBucketOutputBody: Swift.Equatable {
    let bucketArn: Swift.String?
}

extension CreateBucketOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketArn = "BucketArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketArn)
        bucketArn = bucketArnDecoded
    }
}

enum CreateBucketOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "BucketAlreadyExists": return try await BucketAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "BucketAlreadyOwnedByYou": return try await BucketAlreadyOwnedByYou(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension CreateJobInput {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case confirmationRequired = "ConfirmationRequired"
        case description = "Description"
        case manifest = "Manifest"
        case manifestGenerator = "ManifestGenerator"
        case operation = "Operation"
        case priority = "Priority"
        case report = "Report"
        case roleArn = "RoleArn"
        case tags = "Tags"
    }

    static func writingClosure(_ value: CreateJobInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("ClientRequestToken")].write(value.clientRequestToken)
        try writer[.init("ConfirmationRequired")].write(value.confirmationRequired)
        try writer[.init("Description")].write(value.description)
        try writer[.init("Manifest")].write(value.manifest, writingClosure: S3ControlClientTypes.JobManifest.writingClosure(_:to:))
        try writer[.init("ManifestGenerator")].write(value.manifestGenerator, writingClosure: S3ControlClientTypes.JobManifestGenerator.writingClosure(_:to:))
        try writer[.init("Operation")].write(value.operation, writingClosure: S3ControlClientTypes.JobOperation.writingClosure(_:to:))
        try writer[.init("Priority")].write(value.priority)
        try writer[.init("Report")].write(value.report, writingClosure: S3ControlClientTypes.JobReport.writingClosure(_:to:))
        try writer[.init("RoleArn")].write(value.roleArn)
        try writer[.init("Tags")].writeList(value.tags, memberWritingClosure: S3ControlClientTypes.S3Tag.writingClosure(_:to:), memberNodeInfo: .init("member"), isFlattened: false)
    }
}

extension CreateJobInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension CreateJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/jobs"
    }
}

public struct CreateJobInput: Swift.Equatable {
    /// The Amazon Web Services account ID that creates the job.
    /// This member is required.
    public var accountId: Swift.String?
    /// An idempotency token to ensure that you don't accidentally submit the same request twice. You can use any string up to the maximum length.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// Indicates whether confirmation is required before Amazon S3 runs the job. Confirmation is only required for jobs created through the Amazon S3 console.
    public var confirmationRequired: Swift.Bool?
    /// A description for this job. You can use any string within the permitted length. Descriptions don't need to be unique and can be used for multiple jobs.
    public var description: Swift.String?
    /// Configuration parameters for the manifest.
    public var manifest: S3ControlClientTypes.JobManifest?
    /// The attribute container for the ManifestGenerator details. Jobs must be created with either a manifest file or a ManifestGenerator, but not both.
    public var manifestGenerator: S3ControlClientTypes.JobManifestGenerator?
    /// The action that you want this job to perform on every object listed in the manifest. For more information about the available actions, see [Operations](https://docs.aws.amazon.com/AmazonS3/latest/dev/batch-ops-actions.html) in the Amazon S3 User Guide.
    /// This member is required.
    public var operation: S3ControlClientTypes.JobOperation?
    /// The numerical priority for this job. Higher numbers indicate higher priority.
    /// This member is required.
    public var priority: Swift.Int?
    /// Configuration parameters for the optional job-completion report.
    /// This member is required.
    public var report: S3ControlClientTypes.JobReport?
    /// The Amazon Resource Name (ARN) for the Identity and Access Management (IAM) role that Batch Operations will use to run this job's action on every object in the manifest.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A set of tags to associate with the S3 Batch Operations job. This is an optional parameter.
    public var tags: [S3ControlClientTypes.S3Tag]?

    public init(
        accountId: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        confirmationRequired: Swift.Bool? = nil,
        description: Swift.String? = nil,
        manifest: S3ControlClientTypes.JobManifest? = nil,
        manifestGenerator: S3ControlClientTypes.JobManifestGenerator? = nil,
        operation: S3ControlClientTypes.JobOperation? = nil,
        priority: Swift.Int? = nil,
        report: S3ControlClientTypes.JobReport? = nil,
        roleArn: Swift.String? = nil,
        tags: [S3ControlClientTypes.S3Tag]? = nil
    )
    {
        self.accountId = accountId
        self.clientRequestToken = clientRequestToken
        self.confirmationRequired = confirmationRequired
        self.description = description
        self.manifest = manifest
        self.manifestGenerator = manifestGenerator
        self.operation = operation
        self.priority = priority
        self.report = report
        self.roleArn = roleArn
        self.tags = tags
    }
}

struct CreateJobInputBody: Swift.Equatable {
    let confirmationRequired: Swift.Bool?
    let operation: S3ControlClientTypes.JobOperation?
    let report: S3ControlClientTypes.JobReport?
    let clientRequestToken: Swift.String?
    let manifest: S3ControlClientTypes.JobManifest?
    let description: Swift.String?
    let priority: Swift.Int?
    let roleArn: Swift.String?
    let tags: [S3ControlClientTypes.S3Tag]?
    let manifestGenerator: S3ControlClientTypes.JobManifestGenerator?
}

extension CreateJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case confirmationRequired = "ConfirmationRequired"
        case description = "Description"
        case manifest = "Manifest"
        case manifestGenerator = "ManifestGenerator"
        case operation = "Operation"
        case priority = "Priority"
        case report = "Report"
        case roleArn = "RoleArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let confirmationRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .confirmationRequired) ?? nil
        confirmationRequired = confirmationRequiredDecoded
        let operationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobOperation.self, forKey: .operation)
        operation = operationDecoded
        let reportDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobReport.self, forKey: .report)
        report = reportDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let manifestDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobManifest.self, forKey: .manifest)
        manifest = manifestDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority) ?? nil
        priority = priorityDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([S3ControlClientTypes.S3Tag].self, forKey: .member)
                var tagsBuffer:[S3ControlClientTypes.S3Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [S3ControlClientTypes.S3Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let manifestGeneratorDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobManifestGenerator.self, forKey: .manifestGenerator)
        manifestGenerator = manifestGeneratorDecoded
    }
}

extension CreateJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct CreateJobOutput: Swift.Equatable {
    /// The ID for this job. Amazon S3 generates this ID automatically and returns it after a successful Create Job request.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct CreateJobOutputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension CreateJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

enum CreateJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "IdempotencyException": return try await IdempotencyException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension S3ControlClientTypes.CreateMultiRegionAccessPointInput: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case publicAccessBlock = "PublicAccessBlock"
        case regions = "Regions"
    }

    static func writingClosure(_ value: S3ControlClientTypes.CreateMultiRegionAccessPointInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Name")].write(value.name)
        try writer[.init("PublicAccessBlock")].write(value.publicAccessBlock, writingClosure: S3ControlClientTypes.PublicAccessBlockConfiguration.writingClosure(_:to:))
        try writer[.init("Regions")].writeList(value.regions, memberWritingClosure: S3ControlClientTypes.Region.writingClosure(_:to:), memberNodeInfo: .init("Region"), isFlattened: false)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let publicAccessBlockDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.PublicAccessBlockConfiguration.self, forKey: .publicAccessBlock)
        publicAccessBlock = publicAccessBlockDecoded
        if containerValues.contains(.regions) {
            struct KeyVal0{struct Region{}}
            let regionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Region>.CodingKeys.self, forKey: .regions)
            if let regionsWrappedContainer = regionsWrappedContainer {
                let regionsContainer = try regionsWrappedContainer.decodeIfPresent([S3ControlClientTypes.Region].self, forKey: .member)
                var regionsBuffer:[S3ControlClientTypes.Region]? = nil
                if let regionsContainer = regionsContainer {
                    regionsBuffer = [S3ControlClientTypes.Region]()
                    for structureContainer0 in regionsContainer {
                        regionsBuffer?.append(structureContainer0)
                    }
                }
                regions = regionsBuffer
            } else {
                regions = []
            }
        } else {
            regions = nil
        }
    }
}

extension CreateMultiRegionAccessPointInput {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case details = "Details"
    }

    static func writingClosure(_ value: CreateMultiRegionAccessPointInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("ClientToken")].write(value.clientToken)
        try writer[.init("Details")].write(value.details, writingClosure: S3ControlClientTypes.CreateMultiRegionAccessPointInput.writingClosure(_:to:))
    }
}

extension CreateMultiRegionAccessPointInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension CreateMultiRegionAccessPointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/async-requests/mrap/create"
    }
}

extension S3ControlClientTypes {
    /// A container for the information associated with a [CreateMultiRegionAccessPoint](https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_CreateMultiRegionAccessPoint.html) request.
    public struct CreateMultiRegionAccessPointInput: Swift.Equatable {
        /// The name of the Multi-Region Access Point associated with this request.
        /// This member is required.
        public var name: Swift.String?
        /// The PublicAccessBlock configuration that you want to apply to this Amazon S3 account. You can enable the configuration options in any combination. For more information about when Amazon S3 considers a bucket or object public, see [The Meaning of "Public"](https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status) in the Amazon S3 User Guide. This data type is not supported for Amazon S3 on Outposts.
        public var publicAccessBlock: S3ControlClientTypes.PublicAccessBlockConfiguration?
        /// The buckets in different Regions that are associated with the Multi-Region Access Point.
        /// This member is required.
        public var regions: [S3ControlClientTypes.Region]?

        public init(
            name: Swift.String? = nil,
            publicAccessBlock: S3ControlClientTypes.PublicAccessBlockConfiguration? = nil,
            regions: [S3ControlClientTypes.Region]? = nil
        )
        {
            self.name = name
            self.publicAccessBlock = publicAccessBlock
            self.regions = regions
        }
    }

}

public struct CreateMultiRegionAccessPointInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the owner of the Multi-Region Access Point. The owner of the Multi-Region Access Point also must own the underlying buckets.
    /// This member is required.
    public var accountId: Swift.String?
    /// An idempotency token used to identify the request and guarantee that requests are unique.
    /// This member is required.
    public var clientToken: Swift.String?
    /// A container element containing details about the Multi-Region Access Point.
    /// This member is required.
    public var details: S3ControlClientTypes.CreateMultiRegionAccessPointInput?

    public init(
        accountId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        details: S3ControlClientTypes.CreateMultiRegionAccessPointInput? = nil
    )
    {
        self.accountId = accountId
        self.clientToken = clientToken
        self.details = details
    }
}

struct CreateMultiRegionAccessPointInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let details: S3ControlClientTypes.CreateMultiRegionAccessPointInput?
}

extension CreateMultiRegionAccessPointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case details = "Details"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.CreateMultiRegionAccessPointInput.self, forKey: .details)
        details = detailsDecoded
    }
}

extension CreateMultiRegionAccessPointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateMultiRegionAccessPointOutputBody = try responseDecoder.decode(responseBody: data)
            self.requestTokenARN = output.requestTokenARN
        } else {
            self.requestTokenARN = nil
        }
    }
}

public struct CreateMultiRegionAccessPointOutput: Swift.Equatable {
    /// The request token associated with the request. You can use this token with [DescribeMultiRegionAccessPointOperation](https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_DescribeMultiRegionAccessPointOperation.html) to determine the status of asynchronous requests.
    public var requestTokenARN: Swift.String?

    public init(
        requestTokenARN: Swift.String? = nil
    )
    {
        self.requestTokenARN = requestTokenARN
    }
}

struct CreateMultiRegionAccessPointOutputBody: Swift.Equatable {
    let requestTokenARN: Swift.String?
}

extension CreateMultiRegionAccessPointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestTokenARN = "RequestTokenARN"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestTokenARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestTokenARN)
        requestTokenARN = requestTokenARNDecoded
    }
}

enum CreateMultiRegionAccessPointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension CreateStorageLensGroupInput {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case storageLensGroup = "StorageLensGroup"
        case tags = "Tags"
    }

    static func writingClosure(_ value: CreateStorageLensGroupInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("StorageLensGroup")].write(value.storageLensGroup, writingClosure: S3ControlClientTypes.StorageLensGroup.writingClosure(_:to:))
        try writer[.init("Tags")].writeList(value.tags, memberWritingClosure: S3ControlClientTypes.Tag.writingClosure(_:to:), memberNodeInfo: .init("Tag"), isFlattened: false)
    }
}

extension CreateStorageLensGroupInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension CreateStorageLensGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/storagelensgroup"
    }
}

public struct CreateStorageLensGroupInput: Swift.Equatable {
    /// The Amazon Web Services account ID that the Storage Lens group is created from and associated with.
    /// This member is required.
    public var accountId: Swift.String?
    /// The Storage Lens group configuration.
    /// This member is required.
    public var storageLensGroup: S3ControlClientTypes.StorageLensGroup?
    /// The Amazon Web Services resource tags that you're adding to your Storage Lens group. This parameter is optional.
    public var tags: [S3ControlClientTypes.Tag]?

    public init(
        accountId: Swift.String? = nil,
        storageLensGroup: S3ControlClientTypes.StorageLensGroup? = nil,
        tags: [S3ControlClientTypes.Tag]? = nil
    )
    {
        self.accountId = accountId
        self.storageLensGroup = storageLensGroup
        self.tags = tags
    }
}

struct CreateStorageLensGroupInputBody: Swift.Equatable {
    let storageLensGroup: S3ControlClientTypes.StorageLensGroup?
    let tags: [S3ControlClientTypes.Tag]?
}

extension CreateStorageLensGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case storageLensGroup = "StorageLensGroup"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageLensGroupDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.StorageLensGroup.self, forKey: .storageLensGroup)
        storageLensGroup = storageLensGroupDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([S3ControlClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[S3ControlClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [S3ControlClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension CreateStorageLensGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateStorageLensGroupOutput: Swift.Equatable {

    public init() { }
}

enum CreateStorageLensGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension S3ControlClientTypes.Credentials: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId = "AccessKeyId"
        case expiration = "Expiration"
        case secretAccessKey = "SecretAccessKey"
        case sessionToken = "SessionToken"
    }

    static func writingClosure(_ value: S3ControlClientTypes.Credentials?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("AccessKeyId")].write(value.accessKeyId)
        try writer[.init("Expiration")].writeTimestamp(value.expiration, format: .dateTime)
        try writer[.init("SecretAccessKey")].write(value.secretAccessKey)
        try writer[.init("SessionToken")].write(value.sessionToken)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let secretAccessKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretAccessKey)
        secretAccessKey = secretAccessKeyDecoded
        let sessionTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionToken)
        sessionToken = sessionTokenDecoded
        let expirationDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .expiration)
        expiration = expirationDecoded
    }
}

extension S3ControlClientTypes.Credentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension S3ControlClientTypes {
    /// The Amazon Web Services Security Token Service temporary credential that S3 Access Grants vends to grantees and client applications.
    public struct Credentials: Swift.Equatable {
        /// The unique access key ID of the Amazon Web Services STS temporary credential that S3 Access Grants vends to grantees and client applications.
        public var accessKeyId: Swift.String?
        /// The expiration date and time of the temporary credential that S3 Access Grants vends to grantees and client applications.
        public var expiration: ClientRuntime.Date?
        /// The secret access key of the Amazon Web Services STS temporary credential that S3 Access Grants vends to grantees and client applications.
        public var secretAccessKey: Swift.String?
        /// The Amazon Web Services STS temporary credential that S3 Access Grants vends to grantees and client applications.
        public var sessionToken: Swift.String?

        public init(
            accessKeyId: Swift.String? = nil,
            expiration: ClientRuntime.Date? = nil,
            secretAccessKey: Swift.String? = nil,
            sessionToken: Swift.String? = nil
        )
        {
            self.accessKeyId = accessKeyId
            self.expiration = expiration
            self.secretAccessKey = secretAccessKey
            self.sessionToken = sessionToken
        }
    }

}

extension DeleteAccessGrantInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteAccessGrantInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accessGrantId = accessGrantId else {
            return nil
        }
        return "/v20180820/accessgrantsinstance/grant/\(accessGrantId.urlPercentEncoding())"
    }
}

public struct DeleteAccessGrantInput: Swift.Equatable {
    /// The ID of the access grant. S3 Access Grants auto-generates this ID when you create the access grant.
    /// This member is required.
    public var accessGrantId: Swift.String?
    /// The ID of the Amazon Web Services account that is making this request.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accessGrantId: Swift.String? = nil,
        accountId: Swift.String? = nil
    )
    {
        self.accessGrantId = accessGrantId
        self.accountId = accountId
    }
}

extension DeleteAccessGrantOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAccessGrantOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAccessGrantOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteAccessGrantsInstanceInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteAccessGrantsInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/accessgrantsinstance"
    }
}

public struct DeleteAccessGrantsInstanceInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that is making this request.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

extension DeleteAccessGrantsInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAccessGrantsInstanceOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAccessGrantsInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteAccessGrantsInstanceResourcePolicyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteAccessGrantsInstanceResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/accessgrantsinstance/resourcepolicy"
    }
}

public struct DeleteAccessGrantsInstanceResourcePolicyInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that is making this request.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

extension DeleteAccessGrantsInstanceResourcePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAccessGrantsInstanceResourcePolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAccessGrantsInstanceResourcePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteAccessGrantsLocationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteAccessGrantsLocationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accessGrantsLocationId = accessGrantsLocationId else {
            return nil
        }
        return "/v20180820/accessgrantsinstance/location/\(accessGrantsLocationId.urlPercentEncoding())"
    }
}

public struct DeleteAccessGrantsLocationInput: Swift.Equatable {
    /// The ID of the registered location that you are deregistering from your S3 Access Grants instance. S3 Access Grants assigned this ID when you registered the location. S3 Access Grants assigns the ID default to the default location s3:// and assigns an auto-generated ID to other locations that you register.
    /// This member is required.
    public var accessGrantsLocationId: Swift.String?
    /// The ID of the Amazon Web Services account that is making this request.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accessGrantsLocationId: Swift.String? = nil,
        accountId: Swift.String? = nil
    )
    {
        self.accessGrantsLocationId = accessGrantsLocationId
        self.accountId = accountId
    }
}

extension DeleteAccessGrantsLocationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAccessGrantsLocationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAccessGrantsLocationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteAccessPointForObjectLambdaInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteAccessPointForObjectLambdaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v20180820/accesspointforobjectlambda/\(name.urlPercentEncoding())"
    }
}

public struct DeleteAccessPointForObjectLambdaInput: Swift.Equatable {
    /// The account ID for the account that owns the specified Object Lambda Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the access point you want to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

extension DeleteAccessPointForObjectLambdaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAccessPointForObjectLambdaOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAccessPointForObjectLambdaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteAccessPointInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteAccessPointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v20180820/accesspoint/\(name.urlPercentEncoding())"
    }
}

public struct DeleteAccessPointInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the account that owns the specified access point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the access point you want to delete. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the access point accessed in the format arn:aws:s3-outposts:::outpost//accesspoint/. For example, to access the access point reports-ap through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/accesspoint/reports-ap. The value must be URL encoded.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

extension DeleteAccessPointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAccessPointOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAccessPointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteAccessPointPolicyForObjectLambdaInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteAccessPointPolicyForObjectLambdaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v20180820/accesspointforobjectlambda/\(name.urlPercentEncoding())/policy"
    }
}

public struct DeleteAccessPointPolicyForObjectLambdaInput: Swift.Equatable {
    /// The account ID for the account that owns the specified Object Lambda Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the Object Lambda Access Point you want to delete the policy for.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

extension DeleteAccessPointPolicyForObjectLambdaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAccessPointPolicyForObjectLambdaOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAccessPointPolicyForObjectLambdaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteAccessPointPolicyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteAccessPointPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v20180820/accesspoint/\(name.urlPercentEncoding())/policy"
    }
}

public struct DeleteAccessPointPolicyInput: Swift.Equatable {
    /// The account ID for the account that owns the specified access point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the access point whose policy you want to delete. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the access point accessed in the format arn:aws:s3-outposts:::outpost//accesspoint/. For example, to access the access point reports-ap through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/accesspoint/reports-ap. The value must be URL encoded.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

extension DeleteAccessPointPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAccessPointPolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAccessPointPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteBucketInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteBucketInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())"
    }
}

public struct DeleteBucketInput: Swift.Equatable {
    /// The account ID that owns the Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    /// Specifies the bucket being deleted. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
    }
}

extension DeleteBucketLifecycleConfigurationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteBucketLifecycleConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/lifecycleconfiguration"
    }
}

public struct DeleteBucketLifecycleConfigurationInput: Swift.Equatable {
    /// The account ID of the lifecycle configuration to delete.
    /// This member is required.
    public var accountId: Swift.String?
    /// Specifies the bucket. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
    }
}

extension DeleteBucketLifecycleConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteBucketLifecycleConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteBucketLifecycleConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteBucketOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteBucketOutput: Swift.Equatable {

    public init() { }
}

enum DeleteBucketOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteBucketPolicyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteBucketPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/policy"
    }
}

public struct DeleteBucketPolicyInput: Swift.Equatable {
    /// The account ID of the Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    /// Specifies the bucket. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
    }
}

extension DeleteBucketPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteBucketPolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteBucketPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteBucketReplicationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteBucketReplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/replication"
    }
}

public struct DeleteBucketReplicationInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Outposts bucket to delete the replication configuration for.
    /// This member is required.
    public var accountId: Swift.String?
    /// Specifies the S3 on Outposts bucket to delete the replication configuration for. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
    }
}

extension DeleteBucketReplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteBucketReplicationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteBucketReplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteBucketTaggingInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteBucketTaggingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/tagging"
    }
}

public struct DeleteBucketTaggingInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Outposts bucket tag set to be removed.
    /// This member is required.
    public var accountId: Swift.String?
    /// The bucket ARN that has the tag set to be removed. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
    }
}

extension DeleteBucketTaggingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteBucketTaggingOutput: Swift.Equatable {

    public init() { }
}

enum DeleteBucketTaggingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteJobTaggingInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteJobTaggingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/v20180820/jobs/\(jobId.urlPercentEncoding())/tagging"
    }
}

public struct DeleteJobTaggingInput: Swift.Equatable {
    /// The Amazon Web Services account ID associated with the S3 Batch Operations job.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID for the S3 Batch Operations job whose tags you want to delete.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.jobId = jobId
    }
}

extension DeleteJobTaggingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteJobTaggingOutput: Swift.Equatable {

    public init() { }
}

enum DeleteJobTaggingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension S3ControlClientTypes.DeleteMarkerReplication: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    static func writingClosure(_ value: S3ControlClientTypes.DeleteMarkerReplication?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Status")].write(value.status)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.DeleteMarkerReplicationStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension S3ControlClientTypes {
    /// Specifies whether S3 on Outposts replicates delete markers. If you specify a Filter element in your replication configuration, you must also include a DeleteMarkerReplication element. If your Filter includes a Tag element, the DeleteMarkerReplication element's Status child element must be set to Disabled, because S3 on Outposts does not support replicating delete markers for tag-based rules. For more information about delete marker replication, see [How delete operations affect replication](https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3OutpostsReplication.html#outposts-replication-what-is-replicated) in the Amazon S3 User Guide.
    public struct DeleteMarkerReplication: Swift.Equatable {
        /// Indicates whether to replicate delete markers.
        /// This member is required.
        public var status: S3ControlClientTypes.DeleteMarkerReplicationStatus?

        public init(
            status: S3ControlClientTypes.DeleteMarkerReplicationStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension S3ControlClientTypes {
    public enum DeleteMarkerReplicationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DeleteMarkerReplicationStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeleteMarkerReplicationStatus(rawValue: rawValue) ?? DeleteMarkerReplicationStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.DeleteMultiRegionAccessPointInput: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    static func writingClosure(_ value: S3ControlClientTypes.DeleteMultiRegionAccessPointInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Name")].write(value.name)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteMultiRegionAccessPointInput {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case details = "Details"
    }

    static func writingClosure(_ value: DeleteMultiRegionAccessPointInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("ClientToken")].write(value.clientToken)
        try writer[.init("Details")].write(value.details, writingClosure: S3ControlClientTypes.DeleteMultiRegionAccessPointInput.writingClosure(_:to:))
    }
}

extension DeleteMultiRegionAccessPointInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteMultiRegionAccessPointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/async-requests/mrap/delete"
    }
}

extension S3ControlClientTypes {
    /// A container for the information associated with a [DeleteMultiRegionAccessPoint](https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_DeleteMultiRegionAccessPoint.html) request.
    public struct DeleteMultiRegionAccessPointInput: Swift.Equatable {
        /// The name of the Multi-Region Access Point associated with this request.
        /// This member is required.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

public struct DeleteMultiRegionAccessPointInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the owner of the Multi-Region Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// An idempotency token used to identify the request and guarantee that requests are unique.
    /// This member is required.
    public var clientToken: Swift.String?
    /// A container element containing details about the Multi-Region Access Point.
    /// This member is required.
    public var details: S3ControlClientTypes.DeleteMultiRegionAccessPointInput?

    public init(
        accountId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        details: S3ControlClientTypes.DeleteMultiRegionAccessPointInput? = nil
    )
    {
        self.accountId = accountId
        self.clientToken = clientToken
        self.details = details
    }
}

struct DeleteMultiRegionAccessPointInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let details: S3ControlClientTypes.DeleteMultiRegionAccessPointInput?
}

extension DeleteMultiRegionAccessPointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case details = "Details"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.DeleteMultiRegionAccessPointInput.self, forKey: .details)
        details = detailsDecoded
    }
}

extension DeleteMultiRegionAccessPointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteMultiRegionAccessPointOutputBody = try responseDecoder.decode(responseBody: data)
            self.requestTokenARN = output.requestTokenARN
        } else {
            self.requestTokenARN = nil
        }
    }
}

public struct DeleteMultiRegionAccessPointOutput: Swift.Equatable {
    /// The request token associated with the request. You can use this token with [DescribeMultiRegionAccessPointOperation](https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_DescribeMultiRegionAccessPointOperation.html) to determine the status of asynchronous requests.
    public var requestTokenARN: Swift.String?

    public init(
        requestTokenARN: Swift.String? = nil
    )
    {
        self.requestTokenARN = requestTokenARN
    }
}

struct DeleteMultiRegionAccessPointOutputBody: Swift.Equatable {
    let requestTokenARN: Swift.String?
}

extension DeleteMultiRegionAccessPointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestTokenARN = "RequestTokenARN"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestTokenARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestTokenARN)
        requestTokenARN = requestTokenARNDecoded
    }
}

enum DeleteMultiRegionAccessPointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeletePublicAccessBlockInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeletePublicAccessBlockInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/configuration/publicAccessBlock"
    }
}

public struct DeletePublicAccessBlockInput: Swift.Equatable {
    /// The account ID for the Amazon Web Services account whose PublicAccessBlock configuration you want to remove.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

extension DeletePublicAccessBlockOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeletePublicAccessBlockOutput: Swift.Equatable {

    public init() { }
}

enum DeletePublicAccessBlockOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteStorageLensConfigurationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteStorageLensConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configId = configId else {
            return nil
        }
        return "/v20180820/storagelens/\(configId.urlPercentEncoding())"
    }
}

public struct DeleteStorageLensConfigurationInput: Swift.Equatable {
    /// The account ID of the requester.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID of the S3 Storage Lens configuration.
    /// This member is required.
    public var configId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        configId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.configId = configId
    }
}

extension DeleteStorageLensConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteStorageLensConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteStorageLensConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteStorageLensConfigurationTaggingInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteStorageLensConfigurationTaggingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configId = configId else {
            return nil
        }
        return "/v20180820/storagelens/\(configId.urlPercentEncoding())/tagging"
    }
}

public struct DeleteStorageLensConfigurationTaggingInput: Swift.Equatable {
    /// The account ID of the requester.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID of the S3 Storage Lens configuration.
    /// This member is required.
    public var configId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        configId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.configId = configId
    }
}

extension DeleteStorageLensConfigurationTaggingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteStorageLensConfigurationTaggingOutput: Swift.Equatable {

    public init() { }
}

enum DeleteStorageLensConfigurationTaggingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteStorageLensGroupInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteStorageLensGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v20180820/storagelensgroup/\(name.urlPercentEncoding())"
    }
}

public struct DeleteStorageLensGroupInput: Swift.Equatable {
    /// The Amazon Web Services account ID used to create the Storage Lens group that you're trying to delete.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the Storage Lens group that you're trying to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

extension DeleteStorageLensGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteStorageLensGroupOutput: Swift.Equatable {

    public init() { }
}

enum DeleteStorageLensGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DescribeJobInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DescribeJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/v20180820/jobs/\(jobId.urlPercentEncoding())"
    }
}

public struct DescribeJobInput: Swift.Equatable {
    /// The Amazon Web Services account ID associated with the S3 Batch Operations job.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID for the job whose information you want to retrieve.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.jobId = jobId
    }
}

extension DescribeJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct DescribeJobOutput: Swift.Equatable {
    /// Contains the configuration parameters and status for the job specified in the Describe Job request.
    public var job: S3ControlClientTypes.JobDescriptor?

    public init(
        job: S3ControlClientTypes.JobDescriptor? = nil
    )
    {
        self.job = job
    }
}

struct DescribeJobOutputBody: Swift.Equatable {
    let job: S3ControlClientTypes.JobDescriptor?
}

extension DescribeJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job = "Job"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobDescriptor.self, forKey: .job)
        job = jobDecoded
    }
}

enum DescribeJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DescribeMultiRegionAccessPointOperationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DescribeMultiRegionAccessPointOperationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let requestTokenARN = requestTokenARN else {
            return nil
        }
        return "/v20180820/async-requests/mrap/\(requestTokenARN.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct DescribeMultiRegionAccessPointOperationInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the owner of the Multi-Region Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The request token associated with the request you want to know about. This request token is returned as part of the response when you make an asynchronous request. You provide this token to query about the status of the asynchronous action.
    /// This member is required.
    public var requestTokenARN: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        requestTokenARN: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.requestTokenARN = requestTokenARN
    }
}

extension DescribeMultiRegionAccessPointOperationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeMultiRegionAccessPointOperationOutputBody = try responseDecoder.decode(responseBody: data)
            self.asyncOperation = output.asyncOperation
        } else {
            self.asyncOperation = nil
        }
    }
}

public struct DescribeMultiRegionAccessPointOperationOutput: Swift.Equatable {
    /// A container element containing the details of the asynchronous operation.
    public var asyncOperation: S3ControlClientTypes.AsyncOperation?

    public init(
        asyncOperation: S3ControlClientTypes.AsyncOperation? = nil
    )
    {
        self.asyncOperation = asyncOperation
    }
}

struct DescribeMultiRegionAccessPointOperationOutputBody: Swift.Equatable {
    let asyncOperation: S3ControlClientTypes.AsyncOperation?
}

extension DescribeMultiRegionAccessPointOperationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case asyncOperation = "AsyncOperation"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let asyncOperationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.AsyncOperation.self, forKey: .asyncOperation)
        asyncOperation = asyncOperationDecoded
    }
}

enum DescribeMultiRegionAccessPointOperationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension S3ControlClientTypes.Destination: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessControlTranslation = "AccessControlTranslation"
        case account = "Account"
        case bucket = "Bucket"
        case encryptionConfiguration = "EncryptionConfiguration"
        case metrics = "Metrics"
        case replicationTime = "ReplicationTime"
        case storageClass = "StorageClass"
    }

    static func writingClosure(_ value: S3ControlClientTypes.Destination?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("AccessControlTranslation")].write(value.accessControlTranslation, writingClosure: S3ControlClientTypes.AccessControlTranslation.writingClosure(_:to:))
        try writer[.init("Account")].write(value.account)
        try writer[.init("Bucket")].write(value.bucket)
        try writer[.init("EncryptionConfiguration")].write(value.encryptionConfiguration, writingClosure: S3ControlClientTypes.EncryptionConfiguration.writingClosure(_:to:))
        try writer[.init("Metrics")].write(value.metrics, writingClosure: S3ControlClientTypes.Metrics.writingClosure(_:to:))
        try writer[.init("ReplicationTime")].write(value.replicationTime, writingClosure: S3ControlClientTypes.ReplicationTime.writingClosure(_:to:))
        try writer[.init("StorageClass")].write(value.storageClass)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .account)
        account = accountDecoded
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let replicationTimeDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ReplicationTime.self, forKey: .replicationTime)
        replicationTime = replicationTimeDecoded
        let accessControlTranslationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.AccessControlTranslation.self, forKey: .accessControlTranslation)
        accessControlTranslation = accessControlTranslationDecoded
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.EncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
        let metricsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.Metrics.self, forKey: .metrics)
        metrics = metricsDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ReplicationStorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
    }
}

extension S3ControlClientTypes {
    /// Specifies information about the replication destination bucket and its settings for an S3 on Outposts replication configuration.
    public struct Destination: Swift.Equatable {
        /// Specify this property only in a cross-account scenario (where the source and destination bucket owners are not the same), and you want to change replica ownership to the Amazon Web Services account that owns the destination bucket. If this property is not specified in the replication configuration, the replicas are owned by same Amazon Web Services account that owns the source object. This is not supported by Amazon S3 on Outposts buckets.
        public var accessControlTranslation: S3ControlClientTypes.AccessControlTranslation?
        /// The destination bucket owner's account ID.
        public var account: Swift.String?
        /// The Amazon Resource Name (ARN) of the access point for the destination bucket where you want S3 on Outposts to store the replication results.
        /// This member is required.
        public var bucket: Swift.String?
        /// A container that provides information about encryption. If SourceSelectionCriteria is specified, you must specify this element. This is not supported by Amazon S3 on Outposts buckets.
        public var encryptionConfiguration: S3ControlClientTypes.EncryptionConfiguration?
        /// A container that specifies replication metrics-related settings.
        public var metrics: S3ControlClientTypes.Metrics?
        /// A container that specifies S3 Replication Time Control (S3 RTC) settings, including whether S3 RTC is enabled and the time when all objects and operations on objects must be replicated. Must be specified together with a Metrics block. This is not supported by Amazon S3 on Outposts buckets.
        public var replicationTime: S3ControlClientTypes.ReplicationTime?
        /// The storage class to use when replicating objects. All objects stored on S3 on Outposts are stored in the OUTPOSTS storage class. S3 on Outposts uses the OUTPOSTS storage class to create the object replicas. Values other than OUTPOSTS aren't supported by Amazon S3 on Outposts.
        public var storageClass: S3ControlClientTypes.ReplicationStorageClass?

        public init(
            accessControlTranslation: S3ControlClientTypes.AccessControlTranslation? = nil,
            account: Swift.String? = nil,
            bucket: Swift.String? = nil,
            encryptionConfiguration: S3ControlClientTypes.EncryptionConfiguration? = nil,
            metrics: S3ControlClientTypes.Metrics? = nil,
            replicationTime: S3ControlClientTypes.ReplicationTime? = nil,
            storageClass: S3ControlClientTypes.ReplicationStorageClass? = nil
        )
        {
            self.accessControlTranslation = accessControlTranslation
            self.account = account
            self.bucket = bucket
            self.encryptionConfiguration = encryptionConfiguration
            self.metrics = metrics
            self.replicationTime = replicationTime
            self.storageClass = storageClass
        }
    }

}

extension S3ControlClientTypes.DetailedStatusCodesMetrics: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isEnabled = "IsEnabled"
    }

    static func writingClosure(_ value: S3ControlClientTypes.DetailedStatusCodesMetrics?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("IsEnabled")].write(value.isEnabled)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isEnabled) ?? false
        isEnabled = isEnabledDecoded
    }
}

extension S3ControlClientTypes {
    /// The container element for Amazon S3 Storage Lens detailed status code metrics. Detailed status code metrics generate metrics for HTTP status codes, such as 200 OK, 403 Forbidden, 503 Service Unavailable and others. For more information about S3 Storage Lens, see [Assessing your storage activity and usage with S3 Storage Lens](https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage_lens.html) in the Amazon S3 User Guide. For a complete list of S3 Storage Lens metrics, see [S3 Storage Lens metrics glossary](https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage_lens_metrics_glossary.html) in the Amazon S3 User Guide.
    public struct DetailedStatusCodesMetrics: Swift.Equatable {
        /// A container that indicates whether detailed status code metrics are enabled.
        public var isEnabled: Swift.Bool

        public init(
            isEnabled: Swift.Bool = false
        )
        {
            self.isEnabled = isEnabled
        }
    }

}

extension DissociateAccessGrantsIdentityCenterInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DissociateAccessGrantsIdentityCenterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/accessgrantsinstance/identitycenter"
    }
}

public struct DissociateAccessGrantsIdentityCenterInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that is making this request.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

extension DissociateAccessGrantsIdentityCenterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DissociateAccessGrantsIdentityCenterOutput: Swift.Equatable {

    public init() { }
}

enum DissociateAccessGrantsIdentityCenterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension S3ControlClientTypes.EncryptionConfiguration: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicaKmsKeyID = "ReplicaKmsKeyID"
    }

    static func writingClosure(_ value: S3ControlClientTypes.EncryptionConfiguration?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("ReplicaKmsKeyID")].write(value.replicaKmsKeyID)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicaKmsKeyIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicaKmsKeyID)
        replicaKmsKeyID = replicaKmsKeyIDDecoded
    }
}

extension S3ControlClientTypes {
    /// Specifies encryption-related information for an Amazon S3 bucket that is a destination for replicated objects. This is not supported by Amazon S3 on Outposts buckets.
    public struct EncryptionConfiguration: Swift.Equatable {
        /// Specifies the ID of the customer managed KMS key that's stored in Key Management Service (KMS) for the destination bucket. This ID is either the Amazon Resource Name (ARN) for the KMS key or the alias ARN for the KMS key. Amazon S3 uses this KMS key to encrypt replica objects. Amazon S3 supports only symmetric encryption KMS keys. For more information, see [Symmetric encryption KMS keys](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#symmetric-cmks) in the Amazon Web Services Key Management Service Developer Guide.
        public var replicaKmsKeyID: Swift.String?

        public init(
            replicaKmsKeyID: Swift.String? = nil
        )
        {
            self.replicaKmsKeyID = replicaKmsKeyID
        }
    }

}

extension S3ControlClientTypes.EstablishedMultiRegionAccessPointPolicy: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    static func writingClosure(_ value: S3ControlClientTypes.EstablishedMultiRegionAccessPointPolicy?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Policy")].write(value.policy)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension S3ControlClientTypes {
    /// The last established access control policy for a Multi-Region Access Point. When you update the policy, the update is first listed as the proposed policy. After the update is finished and all Regions have been updated, the proposed policy is listed as the established policy. If both policies have the same version number, the proposed policy is the established policy.
    public struct EstablishedMultiRegionAccessPointPolicy: Swift.Equatable {
        /// The details of the last established policy.
        public var policy: Swift.String?

        public init(
            policy: Swift.String? = nil
        )
        {
            self.policy = policy
        }
    }

}

extension S3ControlClientTypes.Exclude: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case buckets = "Buckets"
        case regions = "Regions"
    }

    static func writingClosure(_ value: S3ControlClientTypes.Exclude?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Buckets")].writeList(value.buckets, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: .init("Arn"), isFlattened: false)
        try writer[.init("Regions")].writeList(value.regions, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: .init("Region"), isFlattened: false)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.buckets) {
            struct KeyVal0{struct Arn{}}
            let bucketsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Arn>.CodingKeys.self, forKey: .buckets)
            if let bucketsWrappedContainer = bucketsWrappedContainer {
                let bucketsContainer = try bucketsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var bucketsBuffer:[Swift.String]? = nil
                if let bucketsContainer = bucketsContainer {
                    bucketsBuffer = [Swift.String]()
                    for stringContainer0 in bucketsContainer {
                        bucketsBuffer?.append(stringContainer0)
                    }
                }
                buckets = bucketsBuffer
            } else {
                buckets = []
            }
        } else {
            buckets = nil
        }
        if containerValues.contains(.regions) {
            struct KeyVal0{struct Region{}}
            let regionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Region>.CodingKeys.self, forKey: .regions)
            if let regionsWrappedContainer = regionsWrappedContainer {
                let regionsContainer = try regionsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var regionsBuffer:[Swift.String]? = nil
                if let regionsContainer = regionsContainer {
                    regionsBuffer = [Swift.String]()
                    for stringContainer0 in regionsContainer {
                        regionsBuffer?.append(stringContainer0)
                    }
                }
                regions = regionsBuffer
            } else {
                regions = []
            }
        } else {
            regions = nil
        }
    }
}

extension S3ControlClientTypes {
    /// A container for what Amazon S3 Storage Lens will exclude.
    public struct Exclude: Swift.Equatable {
        /// A container for the S3 Storage Lens bucket excludes.
        public var buckets: [Swift.String]?
        /// A container for the S3 Storage Lens Region excludes.
        public var regions: [Swift.String]?

        public init(
            buckets: [Swift.String]? = nil,
            regions: [Swift.String]? = nil
        )
        {
            self.buckets = buckets
            self.regions = regions
        }
    }

}

extension S3ControlClientTypes.ExistingObjectReplication: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    static func writingClosure(_ value: S3ControlClientTypes.ExistingObjectReplication?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Status")].write(value.status)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ExistingObjectReplicationStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension S3ControlClientTypes {
    /// An optional configuration to replicate existing source bucket objects. This is not supported by Amazon S3 on Outposts buckets.
    public struct ExistingObjectReplication: Swift.Equatable {
        /// Specifies whether Amazon S3 replicates existing source bucket objects.
        /// This member is required.
        public var status: S3ControlClientTypes.ExistingObjectReplicationStatus?

        public init(
            status: S3ControlClientTypes.ExistingObjectReplicationStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension S3ControlClientTypes {
    public enum ExistingObjectReplicationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ExistingObjectReplicationStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExistingObjectReplicationStatus(rawValue: rawValue) ?? ExistingObjectReplicationStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum ExpirationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ExpirationStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExpirationStatus(rawValue: rawValue) ?? ExpirationStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum Format: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case parquet
        case sdkUnknown(Swift.String)

        public static var allCases: [Format] {
            return [
                .csv,
                .parquet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .parquet: return "Parquet"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Format(rawValue: rawValue) ?? Format.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.GeneratedManifestEncryption: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ssekms = "SSE-KMS"
        case sses3 = "SSE-S3"
    }

    static func writingClosure(_ value: S3ControlClientTypes.GeneratedManifestEncryption?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("SSE-KMS")].write(value.ssekms, writingClosure: S3ControlClientTypes.SSEKMSEncryption.writingClosure(_:to:))
        try writer[.init("SSE-S3")].write(value.sses3, writingClosure: S3ControlClientTypes.SSES3Encryption.writingClosure(_:to:))
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sses3Decoded = try containerValues.decodeIfPresent(S3ControlClientTypes.SSES3Encryption.self, forKey: .sses3)
        sses3 = sses3Decoded
        let ssekmsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.SSEKMSEncryption.self, forKey: .ssekms)
        ssekms = ssekmsDecoded
    }
}

extension S3ControlClientTypes {
    /// The encryption configuration to use when storing the generated manifest.
    public struct GeneratedManifestEncryption: Swift.Equatable {
        /// Configuration details on how SSE-KMS is used to encrypt generated manifest objects.
        public var ssekms: S3ControlClientTypes.SSEKMSEncryption?
        /// Specifies the use of SSE-S3 to encrypt generated manifest objects.
        public var sses3: S3ControlClientTypes.SSES3Encryption?

        public init(
            ssekms: S3ControlClientTypes.SSEKMSEncryption? = nil,
            sses3: S3ControlClientTypes.SSES3Encryption? = nil
        )
        {
            self.ssekms = ssekms
            self.sses3 = sses3
        }
    }

}

extension S3ControlClientTypes {
    public enum GeneratedManifestFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case s3inventoryreportCsv20211130
        case sdkUnknown(Swift.String)

        public static var allCases: [GeneratedManifestFormat] {
            return [
                .s3inventoryreportCsv20211130,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .s3inventoryreportCsv20211130: return "S3InventoryReport_CSV_20211130"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GeneratedManifestFormat(rawValue: rawValue) ?? GeneratedManifestFormat.sdkUnknown(rawValue)
        }
    }
}

extension GetAccessGrantInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetAccessGrantInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accessGrantId = accessGrantId else {
            return nil
        }
        return "/v20180820/accessgrantsinstance/grant/\(accessGrantId.urlPercentEncoding())"
    }
}

public struct GetAccessGrantInput: Swift.Equatable {
    /// The ID of the access grant. S3 Access Grants auto-generates this ID when you create the access grant.
    /// This member is required.
    public var accessGrantId: Swift.String?
    /// The ID of the Amazon Web Services account that is making this request.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accessGrantId: Swift.String? = nil,
        accountId: Swift.String? = nil
    )
    {
        self.accessGrantId = accessGrantId
        self.accountId = accountId
    }
}

extension GetAccessGrantOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAccessGrantOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessGrantArn = output.accessGrantArn
            self.accessGrantId = output.accessGrantId
            self.accessGrantsLocationConfiguration = output.accessGrantsLocationConfiguration
            self.accessGrantsLocationId = output.accessGrantsLocationId
            self.applicationArn = output.applicationArn
            self.createdAt = output.createdAt
            self.grantScope = output.grantScope
            self.grantee = output.grantee
            self.permission = output.permission
        } else {
            self.accessGrantArn = nil
            self.accessGrantId = nil
            self.accessGrantsLocationConfiguration = nil
            self.accessGrantsLocationId = nil
            self.applicationArn = nil
            self.createdAt = nil
            self.grantScope = nil
            self.grantee = nil
            self.permission = nil
        }
    }
}

public struct GetAccessGrantOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the access grant.
    public var accessGrantArn: Swift.String?
    /// The ID of the access grant. S3 Access Grants auto-generates this ID when you create the access grant.
    public var accessGrantId: Swift.String?
    /// The configuration options of the grant location. The grant location is the S3 path to the data to which you are granting access.
    public var accessGrantsLocationConfiguration: S3ControlClientTypes.AccessGrantsLocationConfiguration?
    /// The ID of the registered location to which you are granting access. S3 Access Grants assigns this ID when you register the location. S3 Access Grants assigns the ID default to the default location s3:// and assigns an auto-generated ID to other locations that you register.
    public var accessGrantsLocationId: Swift.String?
    /// The Amazon Resource Name (ARN) of an Amazon Web Services IAM Identity Center application associated with your Identity Center instance. If the grant includes an application ARN, the grantee can only access the S3 data through this application.
    public var applicationArn: Swift.String?
    /// The date and time when you created the access grant.
    public var createdAt: ClientRuntime.Date?
    /// The S3 path of the data to which you are granting access. It is the result of appending the Subprefix to the location scope.
    public var grantScope: Swift.String?
    /// The user, group, or role to which you are granting access. You can grant access to an IAM user or role. If you have added a corporate directory to Amazon Web Services IAM Identity Center and associated this Identity Center instance with the S3 Access Grants instance, the grantee can also be a corporate directory user or group.
    public var grantee: S3ControlClientTypes.Grantee?
    /// The type of permission that was granted in the access grant. Can be one of the following values:
    ///
    /// * READ – Grant read-only access to the S3 data.
    ///
    /// * WRITE – Grant write-only access to the S3 data.
    ///
    /// * READWRITE – Grant both read and write access to the S3 data.
    public var permission: S3ControlClientTypes.Permission?

    public init(
        accessGrantArn: Swift.String? = nil,
        accessGrantId: Swift.String? = nil,
        accessGrantsLocationConfiguration: S3ControlClientTypes.AccessGrantsLocationConfiguration? = nil,
        accessGrantsLocationId: Swift.String? = nil,
        applicationArn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        grantScope: Swift.String? = nil,
        grantee: S3ControlClientTypes.Grantee? = nil,
        permission: S3ControlClientTypes.Permission? = nil
    )
    {
        self.accessGrantArn = accessGrantArn
        self.accessGrantId = accessGrantId
        self.accessGrantsLocationConfiguration = accessGrantsLocationConfiguration
        self.accessGrantsLocationId = accessGrantsLocationId
        self.applicationArn = applicationArn
        self.createdAt = createdAt
        self.grantScope = grantScope
        self.grantee = grantee
        self.permission = permission
    }
}

struct GetAccessGrantOutputBody: Swift.Equatable {
    let createdAt: ClientRuntime.Date?
    let accessGrantId: Swift.String?
    let accessGrantArn: Swift.String?
    let grantee: S3ControlClientTypes.Grantee?
    let permission: S3ControlClientTypes.Permission?
    let accessGrantsLocationId: Swift.String?
    let accessGrantsLocationConfiguration: S3ControlClientTypes.AccessGrantsLocationConfiguration?
    let grantScope: Swift.String?
    let applicationArn: Swift.String?
}

extension GetAccessGrantOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessGrantArn = "AccessGrantArn"
        case accessGrantId = "AccessGrantId"
        case accessGrantsLocationConfiguration = "AccessGrantsLocationConfiguration"
        case accessGrantsLocationId = "AccessGrantsLocationId"
        case applicationArn = "ApplicationArn"
        case createdAt = "CreatedAt"
        case grantScope = "GrantScope"
        case grantee = "Grantee"
        case permission = "Permission"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let accessGrantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessGrantId)
        accessGrantId = accessGrantIdDecoded
        let accessGrantArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessGrantArn)
        accessGrantArn = accessGrantArnDecoded
        let granteeDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.Grantee.self, forKey: .grantee)
        grantee = granteeDecoded
        let permissionDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.Permission.self, forKey: .permission)
        permission = permissionDecoded
        let accessGrantsLocationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessGrantsLocationId)
        accessGrantsLocationId = accessGrantsLocationIdDecoded
        let accessGrantsLocationConfigurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.AccessGrantsLocationConfiguration.self, forKey: .accessGrantsLocationConfiguration)
        accessGrantsLocationConfiguration = accessGrantsLocationConfigurationDecoded
        let grantScopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantScope)
        grantScope = grantScopeDecoded
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
    }
}

enum GetAccessGrantOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetAccessGrantsInstanceForPrefixInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetAccessGrantsInstanceForPrefixInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let s3Prefix = s3Prefix else {
                let message = "Creating a URL Query Item failed. s3Prefix is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let s3PrefixQueryItem = ClientRuntime.URLQueryItem(name: "s3prefix".urlPercentEncoding(), value: Swift.String(s3Prefix).urlPercentEncoding())
            items.append(s3PrefixQueryItem)
            return items
        }
    }
}

extension GetAccessGrantsInstanceForPrefixInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/accessgrantsinstance/prefix"
    }
}

public struct GetAccessGrantsInstanceForPrefixInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that is making this request.
    /// This member is required.
    public var accountId: Swift.String?
    /// The S3 prefix of the access grants that you would like to retrieve.
    /// This member is required.
    public var s3Prefix: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        s3Prefix: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.s3Prefix = s3Prefix
    }
}

extension GetAccessGrantsInstanceForPrefixOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAccessGrantsInstanceForPrefixOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessGrantsInstanceArn = output.accessGrantsInstanceArn
            self.accessGrantsInstanceId = output.accessGrantsInstanceId
        } else {
            self.accessGrantsInstanceArn = nil
            self.accessGrantsInstanceId = nil
        }
    }
}

public struct GetAccessGrantsInstanceForPrefixOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the S3 Access Grants instance.
    public var accessGrantsInstanceArn: Swift.String?
    /// The ID of the S3 Access Grants instance. The ID is default. You can have one S3 Access Grants instance per Region per account.
    public var accessGrantsInstanceId: Swift.String?

    public init(
        accessGrantsInstanceArn: Swift.String? = nil,
        accessGrantsInstanceId: Swift.String? = nil
    )
    {
        self.accessGrantsInstanceArn = accessGrantsInstanceArn
        self.accessGrantsInstanceId = accessGrantsInstanceId
    }
}

struct GetAccessGrantsInstanceForPrefixOutputBody: Swift.Equatable {
    let accessGrantsInstanceArn: Swift.String?
    let accessGrantsInstanceId: Swift.String?
}

extension GetAccessGrantsInstanceForPrefixOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessGrantsInstanceArn = "AccessGrantsInstanceArn"
        case accessGrantsInstanceId = "AccessGrantsInstanceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessGrantsInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessGrantsInstanceArn)
        accessGrantsInstanceArn = accessGrantsInstanceArnDecoded
        let accessGrantsInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessGrantsInstanceId)
        accessGrantsInstanceId = accessGrantsInstanceIdDecoded
    }
}

enum GetAccessGrantsInstanceForPrefixOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetAccessGrantsInstanceInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetAccessGrantsInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/accessgrantsinstance"
    }
}

public struct GetAccessGrantsInstanceInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that is making this request.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

extension GetAccessGrantsInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAccessGrantsInstanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessGrantsInstanceArn = output.accessGrantsInstanceArn
            self.accessGrantsInstanceId = output.accessGrantsInstanceId
            self.createdAt = output.createdAt
            self.identityCenterArn = output.identityCenterArn
        } else {
            self.accessGrantsInstanceArn = nil
            self.accessGrantsInstanceId = nil
            self.createdAt = nil
            self.identityCenterArn = nil
        }
    }
}

public struct GetAccessGrantsInstanceOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the S3 Access Grants instance.
    public var accessGrantsInstanceArn: Swift.String?
    /// The ID of the S3 Access Grants instance. The ID is default. You can have one S3 Access Grants instance per Region per account.
    public var accessGrantsInstanceId: Swift.String?
    /// The date and time when you created the S3 Access Grants instance.
    public var createdAt: ClientRuntime.Date?
    /// If you associated your S3 Access Grants instance with an Amazon Web Services IAM Identity Center instance, this field returns the Amazon Resource Name (ARN) of the Amazon Web Services IAM Identity Center instance application; a subresource of the original Identity Center instance. S3 Access Grants creates this Identity Center application for the specific S3 Access Grants instance.
    public var identityCenterArn: Swift.String?

    public init(
        accessGrantsInstanceArn: Swift.String? = nil,
        accessGrantsInstanceId: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        identityCenterArn: Swift.String? = nil
    )
    {
        self.accessGrantsInstanceArn = accessGrantsInstanceArn
        self.accessGrantsInstanceId = accessGrantsInstanceId
        self.createdAt = createdAt
        self.identityCenterArn = identityCenterArn
    }
}

struct GetAccessGrantsInstanceOutputBody: Swift.Equatable {
    let accessGrantsInstanceArn: Swift.String?
    let accessGrantsInstanceId: Swift.String?
    let identityCenterArn: Swift.String?
    let createdAt: ClientRuntime.Date?
}

extension GetAccessGrantsInstanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessGrantsInstanceArn = "AccessGrantsInstanceArn"
        case accessGrantsInstanceId = "AccessGrantsInstanceId"
        case createdAt = "CreatedAt"
        case identityCenterArn = "IdentityCenterArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessGrantsInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessGrantsInstanceArn)
        accessGrantsInstanceArn = accessGrantsInstanceArnDecoded
        let accessGrantsInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessGrantsInstanceId)
        accessGrantsInstanceId = accessGrantsInstanceIdDecoded
        let identityCenterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityCenterArn)
        identityCenterArn = identityCenterArnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

enum GetAccessGrantsInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetAccessGrantsInstanceResourcePolicyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetAccessGrantsInstanceResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/accessgrantsinstance/resourcepolicy"
    }
}

public struct GetAccessGrantsInstanceResourcePolicyInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that is making this request.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

extension GetAccessGrantsInstanceResourcePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAccessGrantsInstanceResourcePolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.organization = output.organization
            self.policy = output.policy
        } else {
            self.createdAt = nil
            self.organization = nil
            self.policy = nil
        }
    }
}

public struct GetAccessGrantsInstanceResourcePolicyOutput: Swift.Equatable {
    /// The date and time when you created the S3 Access Grants instance resource policy.
    public var createdAt: ClientRuntime.Date?
    /// The Organization of the resource policy of the S3 Access Grants instance.
    public var organization: Swift.String?
    /// The resource policy of the S3 Access Grants instance.
    public var policy: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        organization: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.organization = organization
        self.policy = policy
    }
}

struct GetAccessGrantsInstanceResourcePolicyOutputBody: Swift.Equatable {
    let policy: Swift.String?
    let organization: Swift.String?
    let createdAt: ClientRuntime.Date?
}

extension GetAccessGrantsInstanceResourcePolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case organization = "Organization"
        case policy = "Policy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let organizationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organization)
        organization = organizationDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

enum GetAccessGrantsInstanceResourcePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetAccessGrantsLocationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetAccessGrantsLocationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accessGrantsLocationId = accessGrantsLocationId else {
            return nil
        }
        return "/v20180820/accessgrantsinstance/location/\(accessGrantsLocationId.urlPercentEncoding())"
    }
}

public struct GetAccessGrantsLocationInput: Swift.Equatable {
    /// The ID of the registered location that you are retrieving. S3 Access Grants assigns this ID when you register the location. S3 Access Grants assigns the ID default to the default location s3:// and assigns an auto-generated ID to other locations that you register.
    /// This member is required.
    public var accessGrantsLocationId: Swift.String?
    /// The ID of the Amazon Web Services account that is making this request.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accessGrantsLocationId: Swift.String? = nil,
        accountId: Swift.String? = nil
    )
    {
        self.accessGrantsLocationId = accessGrantsLocationId
        self.accountId = accountId
    }
}

extension GetAccessGrantsLocationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAccessGrantsLocationOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessGrantsLocationArn = output.accessGrantsLocationArn
            self.accessGrantsLocationId = output.accessGrantsLocationId
            self.createdAt = output.createdAt
            self.iamRoleArn = output.iamRoleArn
            self.locationScope = output.locationScope
        } else {
            self.accessGrantsLocationArn = nil
            self.accessGrantsLocationId = nil
            self.createdAt = nil
            self.iamRoleArn = nil
            self.locationScope = nil
        }
    }
}

public struct GetAccessGrantsLocationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the registered location.
    public var accessGrantsLocationArn: Swift.String?
    /// The ID of the registered location to which you are granting access. S3 Access Grants assigns this ID when you register the location. S3 Access Grants assigns the ID default to the default location s3:// and assigns an auto-generated ID to other locations that you register.
    public var accessGrantsLocationId: Swift.String?
    /// The date and time when you registered the location.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the IAM role for the registered location. S3 Access Grants assumes this role to manage access to the registered location.
    public var iamRoleArn: Swift.String?
    /// The S3 URI path to the registered location. The location scope can be the default S3 location s3://, the S3 path to a bucket, or the S3 path to a bucket and prefix. A prefix in S3 is a string of characters at the beginning of an object key name used to organize the objects that you store in your S3 buckets. For example, object key names that start with the engineering/ prefix or object key names that start with the marketing/campaigns/ prefix.
    public var locationScope: Swift.String?

    public init(
        accessGrantsLocationArn: Swift.String? = nil,
        accessGrantsLocationId: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        iamRoleArn: Swift.String? = nil,
        locationScope: Swift.String? = nil
    )
    {
        self.accessGrantsLocationArn = accessGrantsLocationArn
        self.accessGrantsLocationId = accessGrantsLocationId
        self.createdAt = createdAt
        self.iamRoleArn = iamRoleArn
        self.locationScope = locationScope
    }
}

struct GetAccessGrantsLocationOutputBody: Swift.Equatable {
    let createdAt: ClientRuntime.Date?
    let accessGrantsLocationId: Swift.String?
    let accessGrantsLocationArn: Swift.String?
    let locationScope: Swift.String?
    let iamRoleArn: Swift.String?
}

extension GetAccessGrantsLocationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessGrantsLocationArn = "AccessGrantsLocationArn"
        case accessGrantsLocationId = "AccessGrantsLocationId"
        case createdAt = "CreatedAt"
        case iamRoleArn = "IAMRoleArn"
        case locationScope = "LocationScope"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let accessGrantsLocationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessGrantsLocationId)
        accessGrantsLocationId = accessGrantsLocationIdDecoded
        let accessGrantsLocationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessGrantsLocationArn)
        accessGrantsLocationArn = accessGrantsLocationArnDecoded
        let locationScopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locationScope)
        locationScope = locationScopeDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
    }
}

enum GetAccessGrantsLocationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetAccessPointConfigurationForObjectLambdaInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetAccessPointConfigurationForObjectLambdaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v20180820/accesspointforobjectlambda/\(name.urlPercentEncoding())/configuration"
    }
}

public struct GetAccessPointConfigurationForObjectLambdaInput: Swift.Equatable {
    /// The account ID for the account that owns the specified Object Lambda Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the Object Lambda Access Point you want to return the configuration for.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

extension GetAccessPointConfigurationForObjectLambdaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAccessPointConfigurationForObjectLambdaOutputBody = try responseDecoder.decode(responseBody: data)
            self.configuration = output.configuration
        } else {
            self.configuration = nil
        }
    }
}

public struct GetAccessPointConfigurationForObjectLambdaOutput: Swift.Equatable {
    /// Object Lambda Access Point configuration document.
    public var configuration: S3ControlClientTypes.ObjectLambdaConfiguration?

    public init(
        configuration: S3ControlClientTypes.ObjectLambdaConfiguration? = nil
    )
    {
        self.configuration = configuration
    }
}

struct GetAccessPointConfigurationForObjectLambdaOutputBody: Swift.Equatable {
    let configuration: S3ControlClientTypes.ObjectLambdaConfiguration?
}

extension GetAccessPointConfigurationForObjectLambdaOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ObjectLambdaConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

enum GetAccessPointConfigurationForObjectLambdaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetAccessPointForObjectLambdaInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetAccessPointForObjectLambdaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v20180820/accesspointforobjectlambda/\(name.urlPercentEncoding())"
    }
}

public struct GetAccessPointForObjectLambdaInput: Swift.Equatable {
    /// The account ID for the account that owns the specified Object Lambda Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the Object Lambda Access Point.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

extension GetAccessPointForObjectLambdaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAccessPointForObjectLambdaOutputBody = try responseDecoder.decode(responseBody: data)
            self.alias = output.alias
            self.creationDate = output.creationDate
            self.name = output.name
            self.publicAccessBlockConfiguration = output.publicAccessBlockConfiguration
        } else {
            self.alias = nil
            self.creationDate = nil
            self.name = nil
            self.publicAccessBlockConfiguration = nil
        }
    }
}

public struct GetAccessPointForObjectLambdaOutput: Swift.Equatable {
    /// The alias of the Object Lambda Access Point.
    public var alias: S3ControlClientTypes.ObjectLambdaAccessPointAlias?
    /// The date and time when the specified Object Lambda Access Point was created.
    public var creationDate: ClientRuntime.Date?
    /// The name of the Object Lambda Access Point.
    public var name: Swift.String?
    /// Configuration to block all public access. This setting is turned on and can not be edited.
    public var publicAccessBlockConfiguration: S3ControlClientTypes.PublicAccessBlockConfiguration?

    public init(
        alias: S3ControlClientTypes.ObjectLambdaAccessPointAlias? = nil,
        creationDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        publicAccessBlockConfiguration: S3ControlClientTypes.PublicAccessBlockConfiguration? = nil
    )
    {
        self.alias = alias
        self.creationDate = creationDate
        self.name = name
        self.publicAccessBlockConfiguration = publicAccessBlockConfiguration
    }
}

struct GetAccessPointForObjectLambdaOutputBody: Swift.Equatable {
    let name: Swift.String?
    let publicAccessBlockConfiguration: S3ControlClientTypes.PublicAccessBlockConfiguration?
    let creationDate: ClientRuntime.Date?
    let alias: S3ControlClientTypes.ObjectLambdaAccessPointAlias?
}

extension GetAccessPointForObjectLambdaOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case creationDate = "CreationDate"
        case name = "Name"
        case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let publicAccessBlockConfigurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.PublicAccessBlockConfiguration.self, forKey: .publicAccessBlockConfiguration)
        publicAccessBlockConfiguration = publicAccessBlockConfigurationDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationDate)
        creationDate = creationDateDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ObjectLambdaAccessPointAlias.self, forKey: .alias)
        alias = aliasDecoded
    }
}

enum GetAccessPointForObjectLambdaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetAccessPointInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetAccessPointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v20180820/accesspoint/\(name.urlPercentEncoding())"
    }
}

public struct GetAccessPointInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the account that owns the specified access point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the access point whose configuration information you want to retrieve. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the access point accessed in the format arn:aws:s3-outposts:::outpost//accesspoint/. For example, to access the access point reports-ap through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/accesspoint/reports-ap. The value must be URL encoded.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

extension GetAccessPointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAccessPointOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessPointArn = output.accessPointArn
            self.alias = output.alias
            self.bucket = output.bucket
            self.bucketAccountId = output.bucketAccountId
            self.creationDate = output.creationDate
            self.endpoints = output.endpoints
            self.name = output.name
            self.networkOrigin = output.networkOrigin
            self.publicAccessBlockConfiguration = output.publicAccessBlockConfiguration
            self.vpcConfiguration = output.vpcConfiguration
        } else {
            self.accessPointArn = nil
            self.alias = nil
            self.bucket = nil
            self.bucketAccountId = nil
            self.creationDate = nil
            self.endpoints = nil
            self.name = nil
            self.networkOrigin = nil
            self.publicAccessBlockConfiguration = nil
            self.vpcConfiguration = nil
        }
    }
}

public struct GetAccessPointOutput: Swift.Equatable {
    /// The ARN of the access point.
    public var accessPointArn: Swift.String?
    /// The name or alias of the access point.
    public var alias: Swift.String?
    /// The name of the bucket associated with the specified access point.
    public var bucket: Swift.String?
    /// The Amazon Web Services account ID associated with the S3 bucket associated with this access point.
    public var bucketAccountId: Swift.String?
    /// The date and time when the specified access point was created.
    public var creationDate: ClientRuntime.Date?
    /// The VPC endpoint for the access point.
    public var endpoints: [Swift.String:Swift.String]?
    /// The name of the specified access point.
    public var name: Swift.String?
    /// Indicates whether this access point allows access from the public internet. If VpcConfiguration is specified for this access point, then NetworkOrigin is VPC, and the access point doesn't allow access from the public internet. Otherwise, NetworkOrigin is Internet, and the access point allows access from the public internet, subject to the access point and bucket access policies. This will always be true for an Amazon S3 on Outposts access point
    public var networkOrigin: S3ControlClientTypes.NetworkOrigin?
    /// The PublicAccessBlock configuration that you want to apply to this Amazon S3 account. You can enable the configuration options in any combination. For more information about when Amazon S3 considers a bucket or object public, see [The Meaning of "Public"](https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status) in the Amazon S3 User Guide. This data type is not supported for Amazon S3 on Outposts.
    public var publicAccessBlockConfiguration: S3ControlClientTypes.PublicAccessBlockConfiguration?
    /// Contains the virtual private cloud (VPC) configuration for the specified access point. This element is empty if this access point is an Amazon S3 on Outposts access point that is used by other Amazon Web Services.
    public var vpcConfiguration: S3ControlClientTypes.VpcConfiguration?

    public init(
        accessPointArn: Swift.String? = nil,
        alias: Swift.String? = nil,
        bucket: Swift.String? = nil,
        bucketAccountId: Swift.String? = nil,
        creationDate: ClientRuntime.Date? = nil,
        endpoints: [Swift.String:Swift.String]? = nil,
        name: Swift.String? = nil,
        networkOrigin: S3ControlClientTypes.NetworkOrigin? = nil,
        publicAccessBlockConfiguration: S3ControlClientTypes.PublicAccessBlockConfiguration? = nil,
        vpcConfiguration: S3ControlClientTypes.VpcConfiguration? = nil
    )
    {
        self.accessPointArn = accessPointArn
        self.alias = alias
        self.bucket = bucket
        self.bucketAccountId = bucketAccountId
        self.creationDate = creationDate
        self.endpoints = endpoints
        self.name = name
        self.networkOrigin = networkOrigin
        self.publicAccessBlockConfiguration = publicAccessBlockConfiguration
        self.vpcConfiguration = vpcConfiguration
    }
}

struct GetAccessPointOutputBody: Swift.Equatable {
    let name: Swift.String?
    let bucket: Swift.String?
    let networkOrigin: S3ControlClientTypes.NetworkOrigin?
    let vpcConfiguration: S3ControlClientTypes.VpcConfiguration?
    let publicAccessBlockConfiguration: S3ControlClientTypes.PublicAccessBlockConfiguration?
    let creationDate: ClientRuntime.Date?
    let alias: Swift.String?
    let accessPointArn: Swift.String?
    let endpoints: [Swift.String:Swift.String]?
    let bucketAccountId: Swift.String?
}

extension GetAccessPointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPointArn = "AccessPointArn"
        case alias = "Alias"
        case bucket = "Bucket"
        case bucketAccountId = "BucketAccountId"
        case creationDate = "CreationDate"
        case endpoints = "Endpoints"
        case name = "Name"
        case networkOrigin = "NetworkOrigin"
        case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
        case vpcConfiguration = "VpcConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let networkOriginDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.NetworkOrigin.self, forKey: .networkOrigin)
        networkOrigin = networkOriginDecoded
        let vpcConfigurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.VpcConfiguration.self, forKey: .vpcConfiguration)
        vpcConfiguration = vpcConfigurationDecoded
        let publicAccessBlockConfigurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.PublicAccessBlockConfiguration.self, forKey: .publicAccessBlockConfiguration)
        publicAccessBlockConfiguration = publicAccessBlockConfigurationDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationDate)
        creationDate = creationDateDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let accessPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPointArn)
        accessPointArn = accessPointArnDecoded
        if containerValues.contains(.endpoints) {
            struct KeyVal0{struct key{}; struct value{}}
            let endpointsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: ClientRuntime.MapEntry<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .endpoints)
            if let endpointsWrappedContainer = endpointsWrappedContainer {
                let endpointsContainer = try endpointsWrappedContainer.decodeIfPresent([ClientRuntime.MapKeyValue<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var endpointsBuffer: [Swift.String:Swift.String]? = nil
                if let endpointsContainer = endpointsContainer {
                    endpointsBuffer = [Swift.String:Swift.String]()
                    for stringContainer0 in endpointsContainer {
                        endpointsBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                endpoints = endpointsBuffer
            } else {
                endpoints = [:]
            }
        } else {
            endpoints = nil
        }
        let bucketAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketAccountId)
        bucketAccountId = bucketAccountIdDecoded
    }
}

enum GetAccessPointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetAccessPointPolicyForObjectLambdaInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetAccessPointPolicyForObjectLambdaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v20180820/accesspointforobjectlambda/\(name.urlPercentEncoding())/policy"
    }
}

public struct GetAccessPointPolicyForObjectLambdaInput: Swift.Equatable {
    /// The account ID for the account that owns the specified Object Lambda Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the Object Lambda Access Point.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

extension GetAccessPointPolicyForObjectLambdaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAccessPointPolicyForObjectLambdaOutputBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetAccessPointPolicyForObjectLambdaOutput: Swift.Equatable {
    /// Object Lambda Access Point resource policy document.
    public var policy: Swift.String?

    public init(
        policy: Swift.String? = nil
    )
    {
        self.policy = policy
    }
}

struct GetAccessPointPolicyForObjectLambdaOutputBody: Swift.Equatable {
    let policy: Swift.String?
}

extension GetAccessPointPolicyForObjectLambdaOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum GetAccessPointPolicyForObjectLambdaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetAccessPointPolicyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetAccessPointPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v20180820/accesspoint/\(name.urlPercentEncoding())/policy"
    }
}

public struct GetAccessPointPolicyInput: Swift.Equatable {
    /// The account ID for the account that owns the specified access point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the access point whose policy you want to retrieve. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the access point accessed in the format arn:aws:s3-outposts:::outpost//accesspoint/. For example, to access the access point reports-ap through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/accesspoint/reports-ap. The value must be URL encoded.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

extension GetAccessPointPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAccessPointPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetAccessPointPolicyOutput: Swift.Equatable {
    /// The access point policy associated with the specified access point.
    public var policy: Swift.String?

    public init(
        policy: Swift.String? = nil
    )
    {
        self.policy = policy
    }
}

struct GetAccessPointPolicyOutputBody: Swift.Equatable {
    let policy: Swift.String?
}

extension GetAccessPointPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum GetAccessPointPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetAccessPointPolicyStatusForObjectLambdaInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetAccessPointPolicyStatusForObjectLambdaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v20180820/accesspointforobjectlambda/\(name.urlPercentEncoding())/policyStatus"
    }
}

public struct GetAccessPointPolicyStatusForObjectLambdaInput: Swift.Equatable {
    /// The account ID for the account that owns the specified Object Lambda Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the Object Lambda Access Point.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

extension GetAccessPointPolicyStatusForObjectLambdaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAccessPointPolicyStatusForObjectLambdaOutputBody = try responseDecoder.decode(responseBody: data)
            self.policyStatus = output.policyStatus
        } else {
            self.policyStatus = nil
        }
    }
}

public struct GetAccessPointPolicyStatusForObjectLambdaOutput: Swift.Equatable {
    /// Indicates whether this access point policy is public. For more information about how Amazon S3 evaluates policies to determine whether they are public, see [The Meaning of "Public"](https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status) in the Amazon S3 User Guide.
    public var policyStatus: S3ControlClientTypes.PolicyStatus?

    public init(
        policyStatus: S3ControlClientTypes.PolicyStatus? = nil
    )
    {
        self.policyStatus = policyStatus
    }
}

struct GetAccessPointPolicyStatusForObjectLambdaOutputBody: Swift.Equatable {
    let policyStatus: S3ControlClientTypes.PolicyStatus?
}

extension GetAccessPointPolicyStatusForObjectLambdaOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyStatus = "PolicyStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyStatusDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.PolicyStatus.self, forKey: .policyStatus)
        policyStatus = policyStatusDecoded
    }
}

enum GetAccessPointPolicyStatusForObjectLambdaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetAccessPointPolicyStatusInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetAccessPointPolicyStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v20180820/accesspoint/\(name.urlPercentEncoding())/policyStatus"
    }
}

public struct GetAccessPointPolicyStatusInput: Swift.Equatable {
    /// The account ID for the account that owns the specified access point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the access point whose policy status you want to retrieve.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

extension GetAccessPointPolicyStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAccessPointPolicyStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.policyStatus = output.policyStatus
        } else {
            self.policyStatus = nil
        }
    }
}

public struct GetAccessPointPolicyStatusOutput: Swift.Equatable {
    /// Indicates the current policy status of the specified access point.
    public var policyStatus: S3ControlClientTypes.PolicyStatus?

    public init(
        policyStatus: S3ControlClientTypes.PolicyStatus? = nil
    )
    {
        self.policyStatus = policyStatus
    }
}

struct GetAccessPointPolicyStatusOutputBody: Swift.Equatable {
    let policyStatus: S3ControlClientTypes.PolicyStatus?
}

extension GetAccessPointPolicyStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyStatus = "PolicyStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyStatusDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.PolicyStatus.self, forKey: .policyStatus)
        policyStatus = policyStatusDecoded
    }
}

enum GetAccessPointPolicyStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetBucketInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetBucketInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())"
    }
}

public struct GetBucketInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    /// Specifies the bucket. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
    }
}

extension GetBucketLifecycleConfigurationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetBucketLifecycleConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/lifecycleconfiguration"
    }
}

public struct GetBucketLifecycleConfigurationInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    /// The Amazon Resource Name (ARN) of the bucket. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
    }
}

extension GetBucketLifecycleConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBucketLifecycleConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.rules = output.rules
        } else {
            self.rules = nil
        }
    }
}

public struct GetBucketLifecycleConfigurationOutput: Swift.Equatable {
    /// Container for the lifecycle rule of the Outposts bucket.
    public var rules: [S3ControlClientTypes.LifecycleRule]?

    public init(
        rules: [S3ControlClientTypes.LifecycleRule]? = nil
    )
    {
        self.rules = rules
    }
}

struct GetBucketLifecycleConfigurationOutputBody: Swift.Equatable {
    let rules: [S3ControlClientTypes.LifecycleRule]?
}

extension GetBucketLifecycleConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rules = "Rules"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.rules) {
            struct KeyVal0{struct Rule{}}
            let rulesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Rule>.CodingKeys.self, forKey: .rules)
            if let rulesWrappedContainer = rulesWrappedContainer {
                let rulesContainer = try rulesWrappedContainer.decodeIfPresent([S3ControlClientTypes.LifecycleRule].self, forKey: .member)
                var rulesBuffer:[S3ControlClientTypes.LifecycleRule]? = nil
                if let rulesContainer = rulesContainer {
                    rulesBuffer = [S3ControlClientTypes.LifecycleRule]()
                    for structureContainer0 in rulesContainer {
                        rulesBuffer?.append(structureContainer0)
                    }
                }
                rules = rulesBuffer
            } else {
                rules = []
            }
        } else {
            rules = nil
        }
    }
}

enum GetBucketLifecycleConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetBucketOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBucketOutputBody = try responseDecoder.decode(responseBody: data)
            self.bucket = output.bucket
            self.creationDate = output.creationDate
            self.publicAccessBlockEnabled = output.publicAccessBlockEnabled
        } else {
            self.bucket = nil
            self.creationDate = nil
            self.publicAccessBlockEnabled = false
        }
    }
}

public struct GetBucketOutput: Swift.Equatable {
    /// The Outposts bucket requested.
    public var bucket: Swift.String?
    /// The creation date of the Outposts bucket.
    public var creationDate: ClientRuntime.Date?
    ///
    public var publicAccessBlockEnabled: Swift.Bool

    public init(
        bucket: Swift.String? = nil,
        creationDate: ClientRuntime.Date? = nil,
        publicAccessBlockEnabled: Swift.Bool = false
    )
    {
        self.bucket = bucket
        self.creationDate = creationDate
        self.publicAccessBlockEnabled = publicAccessBlockEnabled
    }
}

struct GetBucketOutputBody: Swift.Equatable {
    let bucket: Swift.String?
    let publicAccessBlockEnabled: Swift.Bool
    let creationDate: ClientRuntime.Date?
}

extension GetBucketOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case creationDate = "CreationDate"
        case publicAccessBlockEnabled = "PublicAccessBlockEnabled"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let publicAccessBlockEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publicAccessBlockEnabled) ?? false
        publicAccessBlockEnabled = publicAccessBlockEnabledDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

enum GetBucketOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetBucketPolicyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetBucketPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/policy"
    }
}

public struct GetBucketPolicyInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    /// Specifies the bucket. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
    }
}

extension GetBucketPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBucketPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetBucketPolicyOutput: Swift.Equatable {
    /// The policy of the Outposts bucket.
    public var policy: Swift.String?

    public init(
        policy: Swift.String? = nil
    )
    {
        self.policy = policy
    }
}

struct GetBucketPolicyOutputBody: Swift.Equatable {
    let policy: Swift.String?
}

extension GetBucketPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum GetBucketPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetBucketReplicationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetBucketReplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/replication"
    }
}

public struct GetBucketReplicationInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    /// Specifies the bucket to get the replication information for. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
    }
}

extension GetBucketReplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBucketReplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.replicationConfiguration = output.replicationConfiguration
        } else {
            self.replicationConfiguration = nil
        }
    }
}

public struct GetBucketReplicationOutput: Swift.Equatable {
    /// A container for one or more replication rules. A replication configuration must have at least one rule and you can add up to 100 rules. The maximum size of a replication configuration is 128 KB.
    public var replicationConfiguration: S3ControlClientTypes.ReplicationConfiguration?

    public init(
        replicationConfiguration: S3ControlClientTypes.ReplicationConfiguration? = nil
    )
    {
        self.replicationConfiguration = replicationConfiguration
    }
}

struct GetBucketReplicationOutputBody: Swift.Equatable {
    let replicationConfiguration: S3ControlClientTypes.ReplicationConfiguration?
}

extension GetBucketReplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationConfiguration = "ReplicationConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ReplicationConfiguration.self, forKey: .replicationConfiguration)
        replicationConfiguration = replicationConfigurationDecoded
    }
}

enum GetBucketReplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetBucketTaggingInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetBucketTaggingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/tagging"
    }
}

public struct GetBucketTaggingInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    /// Specifies the bucket. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
    }
}

extension GetBucketTaggingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBucketTaggingOutputBody = try responseDecoder.decode(responseBody: data)
            self.tagSet = output.tagSet
        } else {
            self.tagSet = nil
        }
    }
}

public struct GetBucketTaggingOutput: Swift.Equatable {
    /// The tags set of the Outposts bucket.
    /// This member is required.
    public var tagSet: [S3ControlClientTypes.S3Tag]?

    public init(
        tagSet: [S3ControlClientTypes.S3Tag]? = nil
    )
    {
        self.tagSet = tagSet
    }
}

struct GetBucketTaggingOutputBody: Swift.Equatable {
    let tagSet: [S3ControlClientTypes.S3Tag]?
}

extension GetBucketTaggingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagSet = "TagSet"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.tagSet) {
            struct KeyVal0{struct member{}}
            let tagSetWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tagSet)
            if let tagSetWrappedContainer = tagSetWrappedContainer {
                let tagSetContainer = try tagSetWrappedContainer.decodeIfPresent([S3ControlClientTypes.S3Tag].self, forKey: .member)
                var tagSetBuffer:[S3ControlClientTypes.S3Tag]? = nil
                if let tagSetContainer = tagSetContainer {
                    tagSetBuffer = [S3ControlClientTypes.S3Tag]()
                    for structureContainer0 in tagSetContainer {
                        tagSetBuffer?.append(structureContainer0)
                    }
                }
                tagSet = tagSetBuffer
            } else {
                tagSet = []
            }
        } else {
            tagSet = nil
        }
    }
}

enum GetBucketTaggingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetBucketVersioningInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetBucketVersioningInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/versioning"
    }
}

public struct GetBucketVersioningInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the S3 on Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    /// The S3 on Outposts bucket to return the versioning state for.
    /// This member is required.
    public var bucket: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
    }
}

extension GetBucketVersioningOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBucketVersioningOutputBody = try responseDecoder.decode(responseBody: data)
            self.mfaDelete = output.mfaDelete
            self.status = output.status
        } else {
            self.mfaDelete = nil
            self.status = nil
        }
    }
}

public struct GetBucketVersioningOutput: Swift.Equatable {
    /// Specifies whether MFA delete is enabled in the bucket versioning configuration. This element is returned only if the bucket has been configured with MFA delete. If MFA delete has never been configured for the bucket, this element is not returned.
    public var mfaDelete: S3ControlClientTypes.MFADeleteStatus?
    /// The versioning state of the S3 on Outposts bucket.
    public var status: S3ControlClientTypes.BucketVersioningStatus?

    public init(
        mfaDelete: S3ControlClientTypes.MFADeleteStatus? = nil,
        status: S3ControlClientTypes.BucketVersioningStatus? = nil
    )
    {
        self.mfaDelete = mfaDelete
        self.status = status
    }
}

struct GetBucketVersioningOutputBody: Swift.Equatable {
    let status: S3ControlClientTypes.BucketVersioningStatus?
    let mfaDelete: S3ControlClientTypes.MFADeleteStatus?
}

extension GetBucketVersioningOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mfaDelete = "MfaDelete"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.BucketVersioningStatus.self, forKey: .status)
        status = statusDecoded
        let mfaDeleteDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.MFADeleteStatus.self, forKey: .mfaDelete)
        mfaDelete = mfaDeleteDecoded
    }
}

enum GetBucketVersioningOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetDataAccessInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetDataAccessInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let target = target else {
                let message = "Creating a URL Query Item failed. target is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let targetQueryItem = ClientRuntime.URLQueryItem(name: "target".urlPercentEncoding(), value: Swift.String(target).urlPercentEncoding())
            items.append(targetQueryItem)
            guard let permission = permission else {
                let message = "Creating a URL Query Item failed. permission is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let permissionQueryItem = ClientRuntime.URLQueryItem(name: "permission".urlPercentEncoding(), value: Swift.String(permission.rawValue).urlPercentEncoding())
            items.append(permissionQueryItem)
            if let targetType = targetType {
                let targetTypeQueryItem = ClientRuntime.URLQueryItem(name: "targetType".urlPercentEncoding(), value: Swift.String(targetType.rawValue).urlPercentEncoding())
                items.append(targetTypeQueryItem)
            }
            if let durationSeconds = durationSeconds {
                let durationSecondsQueryItem = ClientRuntime.URLQueryItem(name: "durationSeconds".urlPercentEncoding(), value: Swift.String(durationSeconds).urlPercentEncoding())
                items.append(durationSecondsQueryItem)
            }
            if let privilege = privilege {
                let privilegeQueryItem = ClientRuntime.URLQueryItem(name: "privilege".urlPercentEncoding(), value: Swift.String(privilege.rawValue).urlPercentEncoding())
                items.append(privilegeQueryItem)
            }
            return items
        }
    }
}

extension GetDataAccessInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/accessgrantsinstance/dataaccess"
    }
}

public struct GetDataAccessInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that is making this request.
    /// This member is required.
    public var accountId: Swift.String?
    /// The session duration, in seconds, of the temporary access credential that S3 Access Grants vends to the grantee or client application. The default value is 1 hour, but the grantee can specify a range from 900 seconds (15 minutes) up to 43200 seconds (12 hours). If the grantee requests a value higher than this maximum, the operation fails.
    public var durationSeconds: Swift.Int?
    /// The type of permission granted to your S3 data, which can be set to one of the following values:
    ///
    /// * READ – Grant read-only access to the S3 data.
    ///
    /// * WRITE – Grant write-only access to the S3 data.
    ///
    /// * READWRITE – Grant both read and write access to the S3 data.
    /// This member is required.
    public var permission: S3ControlClientTypes.Permission?
    /// The scope of the temporary access credential that S3 Access Grants vends to the grantee or client application.
    ///
    /// * Default – The scope of the returned temporary access token is the scope of the grant that is closest to the target scope.
    ///
    /// * Minimal – The scope of the returned temporary access token is the same as the requested target scope as long as the requested scope is the same as or a subset of the grant scope.
    public var privilege: S3ControlClientTypes.Privilege?
    /// The S3 URI path of the data to which you are requesting temporary access credentials. If the requesting account has an access grant for this data, S3 Access Grants vends temporary access credentials in the response.
    /// This member is required.
    public var target: Swift.String?
    /// The type of Target. The only possible value is Object. Pass this value if the target data that you would like to access is a path to an object. Do not pass this value if the target data is a bucket or a bucket and a prefix.
    public var targetType: S3ControlClientTypes.S3PrefixType?

    public init(
        accountId: Swift.String? = nil,
        durationSeconds: Swift.Int? = nil,
        permission: S3ControlClientTypes.Permission? = nil,
        privilege: S3ControlClientTypes.Privilege? = nil,
        target: Swift.String? = nil,
        targetType: S3ControlClientTypes.S3PrefixType? = nil
    )
    {
        self.accountId = accountId
        self.durationSeconds = durationSeconds
        self.permission = permission
        self.privilege = privilege
        self.target = target
        self.targetType = targetType
    }
}

extension GetDataAccessOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDataAccessOutput(matchedGrantTarget: \(Swift.String(describing: matchedGrantTarget)), credentials: \"CONTENT_REDACTED\")"}
}

extension GetDataAccessOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDataAccessOutputBody = try responseDecoder.decode(responseBody: data)
            self.credentials = output.credentials
            self.matchedGrantTarget = output.matchedGrantTarget
        } else {
            self.credentials = nil
            self.matchedGrantTarget = nil
        }
    }
}

public struct GetDataAccessOutput: Swift.Equatable {
    /// The temporary credential token that S3 Access Grants vends.
    public var credentials: S3ControlClientTypes.Credentials?
    /// The S3 URI path of the data to which you are being granted temporary access credentials.
    public var matchedGrantTarget: Swift.String?

    public init(
        credentials: S3ControlClientTypes.Credentials? = nil,
        matchedGrantTarget: Swift.String? = nil
    )
    {
        self.credentials = credentials
        self.matchedGrantTarget = matchedGrantTarget
    }
}

struct GetDataAccessOutputBody: Swift.Equatable {
    let credentials: S3ControlClientTypes.Credentials?
    let matchedGrantTarget: Swift.String?
}

extension GetDataAccessOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentials = "Credentials"
        case matchedGrantTarget = "MatchedGrantTarget"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let credentialsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.Credentials.self, forKey: .credentials)
        credentials = credentialsDecoded
        let matchedGrantTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .matchedGrantTarget)
        matchedGrantTarget = matchedGrantTargetDecoded
    }
}

enum GetDataAccessOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetJobTaggingInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetJobTaggingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/v20180820/jobs/\(jobId.urlPercentEncoding())/tagging"
    }
}

public struct GetJobTaggingInput: Swift.Equatable {
    /// The Amazon Web Services account ID associated with the S3 Batch Operations job.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID for the S3 Batch Operations job whose tags you want to retrieve.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.jobId = jobId
    }
}

extension GetJobTaggingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetJobTaggingOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct GetJobTaggingOutput: Swift.Equatable {
    /// The set of tags associated with the S3 Batch Operations job.
    public var tags: [S3ControlClientTypes.S3Tag]?

    public init(
        tags: [S3ControlClientTypes.S3Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct GetJobTaggingOutputBody: Swift.Equatable {
    let tags: [S3ControlClientTypes.S3Tag]?
}

extension GetJobTaggingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([S3ControlClientTypes.S3Tag].self, forKey: .member)
                var tagsBuffer:[S3ControlClientTypes.S3Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [S3ControlClientTypes.S3Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

enum GetJobTaggingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetMultiRegionAccessPointInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetMultiRegionAccessPointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v20180820/mrap/instances/\(name.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct GetMultiRegionAccessPointInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the owner of the Multi-Region Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the Multi-Region Access Point whose configuration information you want to receive. The name of the Multi-Region Access Point is different from the alias. For more information about the distinction between the name and the alias of an Multi-Region Access Point, see [Managing Multi-Region Access Points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/CreatingMultiRegionAccessPoints.html#multi-region-access-point-naming) in the Amazon S3 User Guide.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

extension GetMultiRegionAccessPointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMultiRegionAccessPointOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessPoint = output.accessPoint
        } else {
            self.accessPoint = nil
        }
    }
}

public struct GetMultiRegionAccessPointOutput: Swift.Equatable {
    /// A container element containing the details of the requested Multi-Region Access Point.
    public var accessPoint: S3ControlClientTypes.MultiRegionAccessPointReport?

    public init(
        accessPoint: S3ControlClientTypes.MultiRegionAccessPointReport? = nil
    )
    {
        self.accessPoint = accessPoint
    }
}

struct GetMultiRegionAccessPointOutputBody: Swift.Equatable {
    let accessPoint: S3ControlClientTypes.MultiRegionAccessPointReport?
}

extension GetMultiRegionAccessPointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPoint = "AccessPoint"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPointDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.MultiRegionAccessPointReport.self, forKey: .accessPoint)
        accessPoint = accessPointDecoded
    }
}

enum GetMultiRegionAccessPointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetMultiRegionAccessPointPolicyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetMultiRegionAccessPointPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v20180820/mrap/instances/\(name.urlPercentEncoding(encodeForwardSlash: false))/policy"
    }
}

public struct GetMultiRegionAccessPointPolicyInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the owner of the Multi-Region Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// Specifies the Multi-Region Access Point. The name of the Multi-Region Access Point is different from the alias. For more information about the distinction between the name and the alias of an Multi-Region Access Point, see [Managing Multi-Region Access Points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/CreatingMultiRegionAccessPoints.html#multi-region-access-point-naming) in the Amazon S3 User Guide.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

extension GetMultiRegionAccessPointPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMultiRegionAccessPointPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetMultiRegionAccessPointPolicyOutput: Swift.Equatable {
    /// The policy associated with the specified Multi-Region Access Point.
    public var policy: S3ControlClientTypes.MultiRegionAccessPointPolicyDocument?

    public init(
        policy: S3ControlClientTypes.MultiRegionAccessPointPolicyDocument? = nil
    )
    {
        self.policy = policy
    }
}

struct GetMultiRegionAccessPointPolicyOutputBody: Swift.Equatable {
    let policy: S3ControlClientTypes.MultiRegionAccessPointPolicyDocument?
}

extension GetMultiRegionAccessPointPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.MultiRegionAccessPointPolicyDocument.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum GetMultiRegionAccessPointPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetMultiRegionAccessPointPolicyStatusInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetMultiRegionAccessPointPolicyStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v20180820/mrap/instances/\(name.urlPercentEncoding(encodeForwardSlash: false))/policystatus"
    }
}

public struct GetMultiRegionAccessPointPolicyStatusInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the owner of the Multi-Region Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// Specifies the Multi-Region Access Point. The name of the Multi-Region Access Point is different from the alias. For more information about the distinction between the name and the alias of an Multi-Region Access Point, see [Managing Multi-Region Access Points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/CreatingMultiRegionAccessPoints.html#multi-region-access-point-naming) in the Amazon S3 User Guide.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

extension GetMultiRegionAccessPointPolicyStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMultiRegionAccessPointPolicyStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.established = output.established
        } else {
            self.established = nil
        }
    }
}

public struct GetMultiRegionAccessPointPolicyStatusOutput: Swift.Equatable {
    /// Indicates whether this access point policy is public. For more information about how Amazon S3 evaluates policies to determine whether they are public, see [The Meaning of "Public"](https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status) in the Amazon S3 User Guide.
    public var established: S3ControlClientTypes.PolicyStatus?

    public init(
        established: S3ControlClientTypes.PolicyStatus? = nil
    )
    {
        self.established = established
    }
}

struct GetMultiRegionAccessPointPolicyStatusOutputBody: Swift.Equatable {
    let established: S3ControlClientTypes.PolicyStatus?
}

extension GetMultiRegionAccessPointPolicyStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case established = "Established"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let establishedDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.PolicyStatus.self, forKey: .established)
        established = establishedDecoded
    }
}

enum GetMultiRegionAccessPointPolicyStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetMultiRegionAccessPointRoutesInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetMultiRegionAccessPointRoutesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let mrap = mrap else {
            return nil
        }
        return "/v20180820/mrap/instances/\(mrap.urlPercentEncoding(encodeForwardSlash: false))/routes"
    }
}

public struct GetMultiRegionAccessPointRoutesInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the owner of the Multi-Region Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The Multi-Region Access Point ARN.
    /// This member is required.
    public var mrap: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        mrap: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.mrap = mrap
    }
}

extension GetMultiRegionAccessPointRoutesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMultiRegionAccessPointRoutesOutputBody = try responseDecoder.decode(responseBody: data)
            self.mrap = output.mrap
            self.routes = output.routes
        } else {
            self.mrap = nil
            self.routes = nil
        }
    }
}

public struct GetMultiRegionAccessPointRoutesOutput: Swift.Equatable {
    /// The Multi-Region Access Point ARN.
    public var mrap: Swift.String?
    /// The different routes that make up the route configuration. Active routes return a value of 100, and passive routes return a value of 0.
    public var routes: [S3ControlClientTypes.MultiRegionAccessPointRoute]?

    public init(
        mrap: Swift.String? = nil,
        routes: [S3ControlClientTypes.MultiRegionAccessPointRoute]? = nil
    )
    {
        self.mrap = mrap
        self.routes = routes
    }
}

struct GetMultiRegionAccessPointRoutesOutputBody: Swift.Equatable {
    let mrap: Swift.String?
    let routes: [S3ControlClientTypes.MultiRegionAccessPointRoute]?
}

extension GetMultiRegionAccessPointRoutesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mrap = "Mrap"
        case routes = "Routes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mrapDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mrap)
        mrap = mrapDecoded
        if containerValues.contains(.routes) {
            struct KeyVal0{struct Route{}}
            let routesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Route>.CodingKeys.self, forKey: .routes)
            if let routesWrappedContainer = routesWrappedContainer {
                let routesContainer = try routesWrappedContainer.decodeIfPresent([S3ControlClientTypes.MultiRegionAccessPointRoute].self, forKey: .member)
                var routesBuffer:[S3ControlClientTypes.MultiRegionAccessPointRoute]? = nil
                if let routesContainer = routesContainer {
                    routesBuffer = [S3ControlClientTypes.MultiRegionAccessPointRoute]()
                    for structureContainer0 in routesContainer {
                        routesBuffer?.append(structureContainer0)
                    }
                }
                routes = routesBuffer
            } else {
                routes = []
            }
        } else {
            routes = nil
        }
    }
}

enum GetMultiRegionAccessPointRoutesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetPublicAccessBlockInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetPublicAccessBlockInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/configuration/publicAccessBlock"
    }
}

public struct GetPublicAccessBlockInput: Swift.Equatable {
    /// The account ID for the Amazon Web Services account whose PublicAccessBlock configuration you want to retrieve.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

extension GetPublicAccessBlockOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: S3ControlClientTypes.PublicAccessBlockConfiguration = try responseDecoder.decode(responseBody: data)
            self.publicAccessBlockConfiguration = output
        } else {
            self.publicAccessBlockConfiguration = nil
        }
    }
}

public struct GetPublicAccessBlockOutput: Swift.Equatable {
    /// The PublicAccessBlock configuration currently in effect for this Amazon Web Services account.
    public var publicAccessBlockConfiguration: S3ControlClientTypes.PublicAccessBlockConfiguration?

    public init(
        publicAccessBlockConfiguration: S3ControlClientTypes.PublicAccessBlockConfiguration? = nil
    )
    {
        self.publicAccessBlockConfiguration = publicAccessBlockConfiguration
    }
}

struct GetPublicAccessBlockOutputBody: Swift.Equatable {
    let publicAccessBlockConfiguration: S3ControlClientTypes.PublicAccessBlockConfiguration?
}

extension GetPublicAccessBlockOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicAccessBlockConfigurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.PublicAccessBlockConfiguration.self, forKey: .publicAccessBlockConfiguration)
        publicAccessBlockConfiguration = publicAccessBlockConfigurationDecoded
    }
}

enum GetPublicAccessBlockOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchPublicAccessBlockConfiguration": return try await NoSuchPublicAccessBlockConfiguration(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetStorageLensConfigurationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetStorageLensConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configId = configId else {
            return nil
        }
        return "/v20180820/storagelens/\(configId.urlPercentEncoding())"
    }
}

public struct GetStorageLensConfigurationInput: Swift.Equatable {
    /// The account ID of the requester.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID of the Amazon S3 Storage Lens configuration.
    /// This member is required.
    public var configId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        configId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.configId = configId
    }
}

extension GetStorageLensConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: S3ControlClientTypes.StorageLensConfiguration = try responseDecoder.decode(responseBody: data)
            self.storageLensConfiguration = output
        } else {
            self.storageLensConfiguration = nil
        }
    }
}

public struct GetStorageLensConfigurationOutput: Swift.Equatable {
    /// The S3 Storage Lens configuration requested.
    public var storageLensConfiguration: S3ControlClientTypes.StorageLensConfiguration?

    public init(
        storageLensConfiguration: S3ControlClientTypes.StorageLensConfiguration? = nil
    )
    {
        self.storageLensConfiguration = storageLensConfiguration
    }
}

struct GetStorageLensConfigurationOutputBody: Swift.Equatable {
    let storageLensConfiguration: S3ControlClientTypes.StorageLensConfiguration?
}

extension GetStorageLensConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case storageLensConfiguration = "StorageLensConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageLensConfigurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.StorageLensConfiguration.self, forKey: .storageLensConfiguration)
        storageLensConfiguration = storageLensConfigurationDecoded
    }
}

enum GetStorageLensConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetStorageLensConfigurationTaggingInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetStorageLensConfigurationTaggingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configId = configId else {
            return nil
        }
        return "/v20180820/storagelens/\(configId.urlPercentEncoding())/tagging"
    }
}

public struct GetStorageLensConfigurationTaggingInput: Swift.Equatable {
    /// The account ID of the requester.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID of the Amazon S3 Storage Lens configuration.
    /// This member is required.
    public var configId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        configId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.configId = configId
    }
}

extension GetStorageLensConfigurationTaggingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetStorageLensConfigurationTaggingOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct GetStorageLensConfigurationTaggingOutput: Swift.Equatable {
    /// The tags of S3 Storage Lens configuration requested.
    public var tags: [S3ControlClientTypes.StorageLensTag]?

    public init(
        tags: [S3ControlClientTypes.StorageLensTag]? = nil
    )
    {
        self.tags = tags
    }
}

struct GetStorageLensConfigurationTaggingOutputBody: Swift.Equatable {
    let tags: [S3ControlClientTypes.StorageLensTag]?
}

extension GetStorageLensConfigurationTaggingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([S3ControlClientTypes.StorageLensTag].self, forKey: .member)
                var tagsBuffer:[S3ControlClientTypes.StorageLensTag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [S3ControlClientTypes.StorageLensTag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

enum GetStorageLensConfigurationTaggingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetStorageLensGroupInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetStorageLensGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v20180820/storagelensgroup/\(name.urlPercentEncoding())"
    }
}

public struct GetStorageLensGroupInput: Swift.Equatable {
    /// The Amazon Web Services account ID associated with the Storage Lens group that you're trying to retrieve the details for.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the Storage Lens group that you're trying to retrieve the configuration details for.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

extension GetStorageLensGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: S3ControlClientTypes.StorageLensGroup = try responseDecoder.decode(responseBody: data)
            self.storageLensGroup = output
        } else {
            self.storageLensGroup = nil
        }
    }
}

public struct GetStorageLensGroupOutput: Swift.Equatable {
    /// The name of the Storage Lens group that you're trying to retrieve the configuration details for.
    public var storageLensGroup: S3ControlClientTypes.StorageLensGroup?

    public init(
        storageLensGroup: S3ControlClientTypes.StorageLensGroup? = nil
    )
    {
        self.storageLensGroup = storageLensGroup
    }
}

struct GetStorageLensGroupOutputBody: Swift.Equatable {
    let storageLensGroup: S3ControlClientTypes.StorageLensGroup?
}

extension GetStorageLensGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case storageLensGroup = "StorageLensGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageLensGroupDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.StorageLensGroup.self, forKey: .storageLensGroup)
        storageLensGroup = storageLensGroupDecoded
    }
}

enum GetStorageLensGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension S3ControlClientTypes.Grantee: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case granteeIdentifier = "GranteeIdentifier"
        case granteeType = "GranteeType"
    }

    static func writingClosure(_ value: S3ControlClientTypes.Grantee?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("GranteeIdentifier")].write(value.granteeIdentifier)
        try writer[.init("GranteeType")].write(value.granteeType)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let granteeTypeDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.GranteeType.self, forKey: .granteeType)
        granteeType = granteeTypeDecoded
        let granteeIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .granteeIdentifier)
        granteeIdentifier = granteeIdentifierDecoded
    }
}

extension S3ControlClientTypes {
    /// The user, group, or role to which you are granting access. You can grant access to an IAM user or role. If you have added your corporate directory to Amazon Web Services IAM Identity Center and associated your Identity Center instance with your S3 Access Grants instance, the grantee can also be a corporate directory user or group.
    public struct Grantee: Swift.Equatable {
        /// The unique identifier of the Grantee. If the grantee type is IAM, the identifier is the IAM Amazon Resource Name (ARN) of the user or role. If the grantee type is a directory user or group, the identifier is 128-bit universally unique identifier (UUID) in the format a1b2c3d4-5678-90ab-cdef-EXAMPLE11111. You can obtain this UUID from your Amazon Web Services IAM Identity Center instance.
        public var granteeIdentifier: Swift.String?
        /// The type of the grantee to which access has been granted. It can be one of the following values:
        ///
        /// * IAM - An IAM user or role.
        ///
        /// * DIRECTORY_USER - Your corporate directory user. You can use this option if you have added your corporate identity directory to IAM Identity Center and associated the IAM Identity Center instance with your S3 Access Grants instance.
        ///
        /// * DIRECTORY_GROUP - Your corporate directory group. You can use this option if you have added your corporate identity directory to IAM Identity Center and associated the IAM Identity Center instance with your S3 Access Grants instance.
        public var granteeType: S3ControlClientTypes.GranteeType?

        public init(
            granteeIdentifier: Swift.String? = nil,
            granteeType: S3ControlClientTypes.GranteeType? = nil
        )
        {
            self.granteeIdentifier = granteeIdentifier
            self.granteeType = granteeType
        }
    }

}

extension S3ControlClientTypes {
    public enum GranteeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case directoryGroup
        case directoryUser
        case iam
        case sdkUnknown(Swift.String)

        public static var allCases: [GranteeType] {
            return [
                .directoryGroup,
                .directoryUser,
                .iam,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .directoryGroup: return "DIRECTORY_GROUP"
            case .directoryUser: return "DIRECTORY_USER"
            case .iam: return "IAM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GranteeType(rawValue: rawValue) ?? GranteeType.sdkUnknown(rawValue)
        }
    }
}

extension IdempotencyException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<IdempotencyExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct IdempotencyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IdempotencyException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct IdempotencyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension IdempotencyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension S3ControlClientTypes.Include: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case buckets = "Buckets"
        case regions = "Regions"
    }

    static func writingClosure(_ value: S3ControlClientTypes.Include?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Buckets")].writeList(value.buckets, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: .init("Arn"), isFlattened: false)
        try writer[.init("Regions")].writeList(value.regions, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: .init("Region"), isFlattened: false)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.buckets) {
            struct KeyVal0{struct Arn{}}
            let bucketsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Arn>.CodingKeys.self, forKey: .buckets)
            if let bucketsWrappedContainer = bucketsWrappedContainer {
                let bucketsContainer = try bucketsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var bucketsBuffer:[Swift.String]? = nil
                if let bucketsContainer = bucketsContainer {
                    bucketsBuffer = [Swift.String]()
                    for stringContainer0 in bucketsContainer {
                        bucketsBuffer?.append(stringContainer0)
                    }
                }
                buckets = bucketsBuffer
            } else {
                buckets = []
            }
        } else {
            buckets = nil
        }
        if containerValues.contains(.regions) {
            struct KeyVal0{struct Region{}}
            let regionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Region>.CodingKeys.self, forKey: .regions)
            if let regionsWrappedContainer = regionsWrappedContainer {
                let regionsContainer = try regionsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var regionsBuffer:[Swift.String]? = nil
                if let regionsContainer = regionsContainer {
                    regionsBuffer = [Swift.String]()
                    for stringContainer0 in regionsContainer {
                        regionsBuffer?.append(stringContainer0)
                    }
                }
                regions = regionsBuffer
            } else {
                regions = []
            }
        } else {
            regions = nil
        }
    }
}

extension S3ControlClientTypes {
    /// A container for what Amazon S3 Storage Lens configuration includes.
    public struct Include: Swift.Equatable {
        /// A container for the S3 Storage Lens bucket includes.
        public var buckets: [Swift.String]?
        /// A container for the S3 Storage Lens Region includes.
        public var regions: [Swift.String]?

        public init(
            buckets: [Swift.String]? = nil,
            regions: [Swift.String]? = nil
        )
        {
            self.buckets = buckets
            self.regions = regions
        }
    }

}

extension InternalServiceException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InternalServiceExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct InternalServiceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServiceException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServiceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServiceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidNextTokenExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct InvalidNextTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNextTokenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidRequestExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension S3ControlClientTypes.JobDescriptor: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case confirmationRequired = "ConfirmationRequired"
        case creationTime = "CreationTime"
        case description = "Description"
        case failureReasons = "FailureReasons"
        case generatedManifestDescriptor = "GeneratedManifestDescriptor"
        case jobArn = "JobArn"
        case jobId = "JobId"
        case manifest = "Manifest"
        case manifestGenerator = "ManifestGenerator"
        case operation = "Operation"
        case priority = "Priority"
        case progressSummary = "ProgressSummary"
        case report = "Report"
        case roleArn = "RoleArn"
        case status = "Status"
        case statusUpdateReason = "StatusUpdateReason"
        case suspendedCause = "SuspendedCause"
        case suspendedDate = "SuspendedDate"
        case terminationDate = "TerminationDate"
    }

    static func writingClosure(_ value: S3ControlClientTypes.JobDescriptor?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("ConfirmationRequired")].write(value.confirmationRequired)
        try writer[.init("CreationTime")].writeTimestamp(value.creationTime, format: .dateTime)
        try writer[.init("Description")].write(value.description)
        try writer[.init("FailureReasons")].writeList(value.failureReasons, memberWritingClosure: S3ControlClientTypes.JobFailure.writingClosure(_:to:), memberNodeInfo: .init("member"), isFlattened: false)
        try writer[.init("GeneratedManifestDescriptor")].write(value.generatedManifestDescriptor, writingClosure: S3ControlClientTypes.S3GeneratedManifestDescriptor.writingClosure(_:to:))
        try writer[.init("JobArn")].write(value.jobArn)
        try writer[.init("JobId")].write(value.jobId)
        try writer[.init("Manifest")].write(value.manifest, writingClosure: S3ControlClientTypes.JobManifest.writingClosure(_:to:))
        try writer[.init("ManifestGenerator")].write(value.manifestGenerator, writingClosure: S3ControlClientTypes.JobManifestGenerator.writingClosure(_:to:))
        try writer[.init("Operation")].write(value.operation, writingClosure: S3ControlClientTypes.JobOperation.writingClosure(_:to:))
        try writer[.init("Priority")].write(value.priority)
        try writer[.init("ProgressSummary")].write(value.progressSummary, writingClosure: S3ControlClientTypes.JobProgressSummary.writingClosure(_:to:))
        try writer[.init("Report")].write(value.report, writingClosure: S3ControlClientTypes.JobReport.writingClosure(_:to:))
        try writer[.init("RoleArn")].write(value.roleArn)
        try writer[.init("Status")].write(value.status)
        try writer[.init("StatusUpdateReason")].write(value.statusUpdateReason)
        try writer[.init("SuspendedCause")].write(value.suspendedCause)
        try writer[.init("SuspendedDate")].writeTimestamp(value.suspendedDate, format: .dateTime)
        try writer[.init("TerminationDate")].writeTimestamp(value.terminationDate, format: .dateTime)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let confirmationRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .confirmationRequired) ?? nil
        confirmationRequired = confirmationRequiredDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let jobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobArn)
        jobArn = jobArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
        let manifestDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobManifest.self, forKey: .manifest)
        manifest = manifestDecoded
        let operationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobOperation.self, forKey: .operation)
        operation = operationDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority) ?? 0
        priority = priorityDecoded
        let progressSummaryDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobProgressSummary.self, forKey: .progressSummary)
        progressSummary = progressSummaryDecoded
        let statusUpdateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusUpdateReason)
        statusUpdateReason = statusUpdateReasonDecoded
        if containerValues.contains(.failureReasons) {
            struct KeyVal0{struct member{}}
            let failureReasonsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .failureReasons)
            if let failureReasonsWrappedContainer = failureReasonsWrappedContainer {
                let failureReasonsContainer = try failureReasonsWrappedContainer.decodeIfPresent([S3ControlClientTypes.JobFailure].self, forKey: .member)
                var failureReasonsBuffer:[S3ControlClientTypes.JobFailure]? = nil
                if let failureReasonsContainer = failureReasonsContainer {
                    failureReasonsBuffer = [S3ControlClientTypes.JobFailure]()
                    for structureContainer0 in failureReasonsContainer {
                        failureReasonsBuffer?.append(structureContainer0)
                    }
                }
                failureReasons = failureReasonsBuffer
            } else {
                failureReasons = []
            }
        } else {
            failureReasons = nil
        }
        let reportDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobReport.self, forKey: .report)
        report = reportDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let terminationDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .terminationDate)
        terminationDate = terminationDateDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let suspendedDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .suspendedDate)
        suspendedDate = suspendedDateDecoded
        let suspendedCauseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suspendedCause)
        suspendedCause = suspendedCauseDecoded
        let manifestGeneratorDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobManifestGenerator.self, forKey: .manifestGenerator)
        manifestGenerator = manifestGeneratorDecoded
        let generatedManifestDescriptorDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3GeneratedManifestDescriptor.self, forKey: .generatedManifestDescriptor)
        generatedManifestDescriptor = generatedManifestDescriptorDecoded
    }
}

extension S3ControlClientTypes {
    /// A container element for the job configuration and status information returned by a Describe Job request.
    public struct JobDescriptor: Swift.Equatable {
        /// Indicates whether confirmation is required before Amazon S3 begins running the specified job. Confirmation is required only for jobs created through the Amazon S3 console.
        public var confirmationRequired: Swift.Bool?
        /// A timestamp indicating when this job was created.
        public var creationTime: ClientRuntime.Date?
        /// The description for this job, if one was provided in this job's Create Job request.
        public var description: Swift.String?
        /// If the specified job failed, this field contains information describing the failure.
        public var failureReasons: [S3ControlClientTypes.JobFailure]?
        /// The attribute of the JobDescriptor containing details about the job's generated manifest.
        public var generatedManifestDescriptor: S3ControlClientTypes.S3GeneratedManifestDescriptor?
        /// The Amazon Resource Name (ARN) for this job.
        public var jobArn: Swift.String?
        /// The ID for the specified job.
        public var jobId: Swift.String?
        /// The configuration information for the specified job's manifest object.
        public var manifest: S3ControlClientTypes.JobManifest?
        /// The manifest generator that was used to generate a job manifest for this job.
        public var manifestGenerator: S3ControlClientTypes.JobManifestGenerator?
        /// The operation that the specified job is configured to run on the objects listed in the manifest.
        public var operation: S3ControlClientTypes.JobOperation?
        /// The priority of the specified job.
        public var priority: Swift.Int
        /// Describes the total number of tasks that the specified job has run, the number of tasks that succeeded, and the number of tasks that failed.
        public var progressSummary: S3ControlClientTypes.JobProgressSummary?
        /// Contains the configuration information for the job-completion report if you requested one in the Create Job request.
        public var report: S3ControlClientTypes.JobReport?
        /// The Amazon Resource Name (ARN) for the Identity and Access Management (IAM) role assigned to run the tasks for this job.
        public var roleArn: Swift.String?
        /// The current status of the specified job.
        public var status: S3ControlClientTypes.JobStatus?
        /// The reason for updating the job.
        public var statusUpdateReason: Swift.String?
        /// The reason why the specified job was suspended. A job is only suspended if you create it through the Amazon S3 console. When you create the job, it enters the Suspended state to await confirmation before running. After you confirm the job, it automatically exits the Suspended state.
        public var suspendedCause: Swift.String?
        /// The timestamp when this job was suspended, if it has been suspended.
        public var suspendedDate: ClientRuntime.Date?
        /// A timestamp indicating when this job terminated. A job's termination date is the date and time when it succeeded, failed, or was canceled.
        public var terminationDate: ClientRuntime.Date?

        public init(
            confirmationRequired: Swift.Bool? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            failureReasons: [S3ControlClientTypes.JobFailure]? = nil,
            generatedManifestDescriptor: S3ControlClientTypes.S3GeneratedManifestDescriptor? = nil,
            jobArn: Swift.String? = nil,
            jobId: Swift.String? = nil,
            manifest: S3ControlClientTypes.JobManifest? = nil,
            manifestGenerator: S3ControlClientTypes.JobManifestGenerator? = nil,
            operation: S3ControlClientTypes.JobOperation? = nil,
            priority: Swift.Int = 0,
            progressSummary: S3ControlClientTypes.JobProgressSummary? = nil,
            report: S3ControlClientTypes.JobReport? = nil,
            roleArn: Swift.String? = nil,
            status: S3ControlClientTypes.JobStatus? = nil,
            statusUpdateReason: Swift.String? = nil,
            suspendedCause: Swift.String? = nil,
            suspendedDate: ClientRuntime.Date? = nil,
            terminationDate: ClientRuntime.Date? = nil
        )
        {
            self.confirmationRequired = confirmationRequired
            self.creationTime = creationTime
            self.description = description
            self.failureReasons = failureReasons
            self.generatedManifestDescriptor = generatedManifestDescriptor
            self.jobArn = jobArn
            self.jobId = jobId
            self.manifest = manifest
            self.manifestGenerator = manifestGenerator
            self.operation = operation
            self.priority = priority
            self.progressSummary = progressSummary
            self.report = report
            self.roleArn = roleArn
            self.status = status
            self.statusUpdateReason = statusUpdateReason
            self.suspendedCause = suspendedCause
            self.suspendedDate = suspendedDate
            self.terminationDate = terminationDate
        }
    }

}

extension S3ControlClientTypes.JobFailure: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureCode = "FailureCode"
        case failureReason = "FailureReason"
    }

    static func writingClosure(_ value: S3ControlClientTypes.JobFailure?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("FailureCode")].write(value.failureCode)
        try writer[.init("FailureReason")].write(value.failureReason)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failureCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension S3ControlClientTypes {
    /// If this job failed, this element indicates why the job failed.
    public struct JobFailure: Swift.Equatable {
        /// The failure code, if any, for the specified job.
        public var failureCode: Swift.String?
        /// The failure reason, if any, for the specified job.
        public var failureReason: Swift.String?

        public init(
            failureCode: Swift.String? = nil,
            failureReason: Swift.String? = nil
        )
        {
            self.failureCode = failureCode
            self.failureReason = failureReason
        }
    }

}

extension S3ControlClientTypes.JobListDescriptor: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case description = "Description"
        case jobId = "JobId"
        case operation = "Operation"
        case priority = "Priority"
        case progressSummary = "ProgressSummary"
        case status = "Status"
        case terminationDate = "TerminationDate"
    }

    static func writingClosure(_ value: S3ControlClientTypes.JobListDescriptor?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("CreationTime")].writeTimestamp(value.creationTime, format: .dateTime)
        try writer[.init("Description")].write(value.description)
        try writer[.init("JobId")].write(value.jobId)
        try writer[.init("Operation")].write(value.operation)
        try writer[.init("Priority")].write(value.priority)
        try writer[.init("ProgressSummary")].write(value.progressSummary, writingClosure: S3ControlClientTypes.JobProgressSummary.writingClosure(_:to:))
        try writer[.init("Status")].write(value.status)
        try writer[.init("TerminationDate")].writeTimestamp(value.terminationDate, format: .dateTime)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let operationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.OperationName.self, forKey: .operation)
        operation = operationDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority) ?? 0
        priority = priorityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let terminationDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .terminationDate)
        terminationDate = terminationDateDecoded
        let progressSummaryDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobProgressSummary.self, forKey: .progressSummary)
        progressSummary = progressSummaryDecoded
    }
}

extension S3ControlClientTypes {
    /// Contains the configuration and status information for a single job retrieved as part of a job list.
    public struct JobListDescriptor: Swift.Equatable {
        /// A timestamp indicating when the specified job was created.
        public var creationTime: ClientRuntime.Date?
        /// The user-specified description that was included in the specified job's Create Job request.
        public var description: Swift.String?
        /// The ID for the specified job.
        public var jobId: Swift.String?
        /// The operation that the specified job is configured to run on every object listed in the manifest.
        public var operation: S3ControlClientTypes.OperationName?
        /// The current priority for the specified job.
        public var priority: Swift.Int
        /// Describes the total number of tasks that the specified job has run, the number of tasks that succeeded, and the number of tasks that failed.
        public var progressSummary: S3ControlClientTypes.JobProgressSummary?
        /// The specified job's current status.
        public var status: S3ControlClientTypes.JobStatus?
        /// A timestamp indicating when the specified job terminated. A job's termination date is the date and time when it succeeded, failed, or was canceled.
        public var terminationDate: ClientRuntime.Date?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            jobId: Swift.String? = nil,
            operation: S3ControlClientTypes.OperationName? = nil,
            priority: Swift.Int = 0,
            progressSummary: S3ControlClientTypes.JobProgressSummary? = nil,
            status: S3ControlClientTypes.JobStatus? = nil,
            terminationDate: ClientRuntime.Date? = nil
        )
        {
            self.creationTime = creationTime
            self.description = description
            self.jobId = jobId
            self.operation = operation
            self.priority = priority
            self.progressSummary = progressSummary
            self.status = status
            self.terminationDate = terminationDate
        }
    }

}

extension S3ControlClientTypes.JobManifest: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case location = "Location"
        case spec = "Spec"
    }

    static func writingClosure(_ value: S3ControlClientTypes.JobManifest?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Location")].write(value.location, writingClosure: S3ControlClientTypes.JobManifestLocation.writingClosure(_:to:))
        try writer[.init("Spec")].write(value.spec, writingClosure: S3ControlClientTypes.JobManifestSpec.writingClosure(_:to:))
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let specDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobManifestSpec.self, forKey: .spec)
        spec = specDecoded
        let locationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobManifestLocation.self, forKey: .location)
        location = locationDecoded
    }
}

extension S3ControlClientTypes {
    /// Contains the configuration information for a job's manifest.
    public struct JobManifest: Swift.Equatable {
        /// Contains the information required to locate the specified job's manifest. Manifests can't be imported from directory buckets. For more information, see [Directory buckets](https://docs.aws.amazon.com/AmazonS3/latest/userguide/directory-buckets-overview.html).
        /// This member is required.
        public var location: S3ControlClientTypes.JobManifestLocation?
        /// Describes the format of the specified job's manifest. If the manifest is in CSV format, also describes the columns contained within the manifest.
        /// This member is required.
        public var spec: S3ControlClientTypes.JobManifestSpec?

        public init(
            location: S3ControlClientTypes.JobManifestLocation? = nil,
            spec: S3ControlClientTypes.JobManifestSpec? = nil
        )
        {
            self.location = location
            self.spec = spec
        }
    }

}

extension S3ControlClientTypes {
    public enum JobManifestFieldName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bucket
        case ignore
        case key
        case versionid
        case sdkUnknown(Swift.String)

        public static var allCases: [JobManifestFieldName] {
            return [
                .bucket,
                .ignore,
                .key,
                .versionid,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bucket: return "Bucket"
            case .ignore: return "Ignore"
            case .key: return "Key"
            case .versionid: return "VersionId"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobManifestFieldName(rawValue: rawValue) ?? JobManifestFieldName.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum JobManifestFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case s3batchoperationsCsv20180820
        case s3inventoryreportCsv20161130
        case sdkUnknown(Swift.String)

        public static var allCases: [JobManifestFormat] {
            return [
                .s3batchoperationsCsv20180820,
                .s3inventoryreportCsv20161130,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .s3batchoperationsCsv20180820: return "S3BatchOperations_CSV_20180820"
            case .s3inventoryreportCsv20161130: return "S3InventoryReport_CSV_20161130"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobManifestFormat(rawValue: rawValue) ?? JobManifestFormat.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.JobManifestGenerator: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3jobmanifestgenerator = "S3JobManifestGenerator"
        case sdkUnknown
    }

    static func writingClosure(_ value: S3ControlClientTypes.JobManifestGenerator?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        switch value {
            case let .s3jobmanifestgenerator(s3jobmanifestgenerator):
                try writer[.init("S3JobManifestGenerator")].write(s3jobmanifestgenerator, writingClosure: S3ControlClientTypes.S3JobManifestGenerator.writingClosure(_:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer[.init("sdkUnknown")].write(sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let key = containerValues.allKeys.first
        switch key {
            case .s3jobmanifestgenerator:
                let s3jobmanifestgeneratorDecoded = try containerValues.decode(S3ControlClientTypes.S3JobManifestGenerator.self, forKey: .s3jobmanifestgenerator)
                self = .s3jobmanifestgenerator(s3jobmanifestgeneratorDecoded)
            default:
                self = .sdkUnknown("")
        }
    }
}

extension S3ControlClientTypes {
    /// Configures the type of the job's ManifestGenerator.
    public enum JobManifestGenerator: Swift.Equatable {
        /// The S3 job ManifestGenerator's configuration details.
        case s3jobmanifestgenerator(S3ControlClientTypes.S3JobManifestGenerator)
        case sdkUnknown(Swift.String)
    }

}

extension S3ControlClientTypes.JobManifestGeneratorFilter: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAfter = "CreatedAfter"
        case createdBefore = "CreatedBefore"
        case eligibleForReplication = "EligibleForReplication"
        case keyNameConstraint = "KeyNameConstraint"
        case matchAnyStorageClass = "MatchAnyStorageClass"
        case objectReplicationStatuses = "ObjectReplicationStatuses"
        case objectSizeGreaterThanBytes = "ObjectSizeGreaterThanBytes"
        case objectSizeLessThanBytes = "ObjectSizeLessThanBytes"
    }

    static func writingClosure(_ value: S3ControlClientTypes.JobManifestGeneratorFilter?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("CreatedAfter")].writeTimestamp(value.createdAfter, format: .dateTime)
        try writer[.init("CreatedBefore")].writeTimestamp(value.createdBefore, format: .dateTime)
        try writer[.init("EligibleForReplication")].write(value.eligibleForReplication)
        try writer[.init("KeyNameConstraint")].write(value.keyNameConstraint, writingClosure: S3ControlClientTypes.KeyNameConstraint.writingClosure(_:to:))
        try writer[.init("MatchAnyStorageClass")].writeList(value.matchAnyStorageClass, memberWritingClosure: S3ControlClientTypes.S3StorageClass.writingClosure(_:to:), memberNodeInfo: .init("member"), isFlattened: false)
        try writer[.init("ObjectReplicationStatuses")].writeList(value.objectReplicationStatuses, memberWritingClosure: S3ControlClientTypes.ReplicationStatus.writingClosure(_:to:), memberNodeInfo: .init("member"), isFlattened: false)
        try writer[.init("ObjectSizeGreaterThanBytes")].write(value.objectSizeGreaterThanBytes)
        try writer[.init("ObjectSizeLessThanBytes")].write(value.objectSizeLessThanBytes)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eligibleForReplicationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .eligibleForReplication) ?? nil
        eligibleForReplication = eligibleForReplicationDecoded
        let createdAfterDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAfter)
        createdAfter = createdAfterDecoded
        let createdBeforeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdBefore)
        createdBefore = createdBeforeDecoded
        if containerValues.contains(.objectReplicationStatuses) {
            struct KeyVal0{struct member{}}
            let objectReplicationStatusesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .objectReplicationStatuses)
            if let objectReplicationStatusesWrappedContainer = objectReplicationStatusesWrappedContainer {
                let objectReplicationStatusesContainer = try objectReplicationStatusesWrappedContainer.decodeIfPresent([S3ControlClientTypes.ReplicationStatus].self, forKey: .member)
                var objectReplicationStatusesBuffer:[S3ControlClientTypes.ReplicationStatus]? = nil
                if let objectReplicationStatusesContainer = objectReplicationStatusesContainer {
                    objectReplicationStatusesBuffer = [S3ControlClientTypes.ReplicationStatus]()
                    for enumContainer0 in objectReplicationStatusesContainer {
                        objectReplicationStatusesBuffer?.append(enumContainer0)
                    }
                }
                objectReplicationStatuses = objectReplicationStatusesBuffer
            } else {
                objectReplicationStatuses = []
            }
        } else {
            objectReplicationStatuses = nil
        }
        let keyNameConstraintDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.KeyNameConstraint.self, forKey: .keyNameConstraint)
        keyNameConstraint = keyNameConstraintDecoded
        let objectSizeGreaterThanBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .objectSizeGreaterThanBytes) ?? nil
        objectSizeGreaterThanBytes = objectSizeGreaterThanBytesDecoded
        let objectSizeLessThanBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .objectSizeLessThanBytes) ?? nil
        objectSizeLessThanBytes = objectSizeLessThanBytesDecoded
        if containerValues.contains(.matchAnyStorageClass) {
            struct KeyVal0{struct member{}}
            let matchAnyStorageClassWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .matchAnyStorageClass)
            if let matchAnyStorageClassWrappedContainer = matchAnyStorageClassWrappedContainer {
                let matchAnyStorageClassContainer = try matchAnyStorageClassWrappedContainer.decodeIfPresent([S3ControlClientTypes.S3StorageClass].self, forKey: .member)
                var matchAnyStorageClassBuffer:[S3ControlClientTypes.S3StorageClass]? = nil
                if let matchAnyStorageClassContainer = matchAnyStorageClassContainer {
                    matchAnyStorageClassBuffer = [S3ControlClientTypes.S3StorageClass]()
                    for enumContainer0 in matchAnyStorageClassContainer {
                        matchAnyStorageClassBuffer?.append(enumContainer0)
                    }
                }
                matchAnyStorageClass = matchAnyStorageClassBuffer
            } else {
                matchAnyStorageClass = []
            }
        } else {
            matchAnyStorageClass = nil
        }
    }
}

extension S3ControlClientTypes {
    /// The filter used to describe a set of objects for the job's manifest.
    public struct JobManifestGeneratorFilter: Swift.Equatable {
        /// If provided, the generated manifest includes only source bucket objects that were created after this time.
        public var createdAfter: ClientRuntime.Date?
        /// If provided, the generated manifest includes only source bucket objects that were created before this time.
        public var createdBefore: ClientRuntime.Date?
        /// Include objects in the generated manifest only if they are eligible for replication according to the Replication configuration on the source bucket.
        public var eligibleForReplication: Swift.Bool?
        /// If provided, the generated manifest includes only source bucket objects whose object keys match the string constraints specified for MatchAnyPrefix, MatchAnySuffix, and MatchAnySubstring.
        public var keyNameConstraint: S3ControlClientTypes.KeyNameConstraint?
        /// If provided, the generated manifest includes only source bucket objects that are stored with the specified storage class.
        public var matchAnyStorageClass: [S3ControlClientTypes.S3StorageClass]?
        /// If provided, the generated manifest includes only source bucket objects that have one of the specified Replication statuses.
        public var objectReplicationStatuses: [S3ControlClientTypes.ReplicationStatus]?
        /// If provided, the generated manifest includes only source bucket objects whose file size is greater than the specified number of bytes.
        public var objectSizeGreaterThanBytes: Swift.Int?
        /// If provided, the generated manifest includes only source bucket objects whose file size is less than the specified number of bytes.
        public var objectSizeLessThanBytes: Swift.Int?

        public init(
            createdAfter: ClientRuntime.Date? = nil,
            createdBefore: ClientRuntime.Date? = nil,
            eligibleForReplication: Swift.Bool? = nil,
            keyNameConstraint: S3ControlClientTypes.KeyNameConstraint? = nil,
            matchAnyStorageClass: [S3ControlClientTypes.S3StorageClass]? = nil,
            objectReplicationStatuses: [S3ControlClientTypes.ReplicationStatus]? = nil,
            objectSizeGreaterThanBytes: Swift.Int? = nil,
            objectSizeLessThanBytes: Swift.Int? = nil
        )
        {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.eligibleForReplication = eligibleForReplication
            self.keyNameConstraint = keyNameConstraint
            self.matchAnyStorageClass = matchAnyStorageClass
            self.objectReplicationStatuses = objectReplicationStatuses
            self.objectSizeGreaterThanBytes = objectSizeGreaterThanBytes
            self.objectSizeLessThanBytes = objectSizeLessThanBytes
        }
    }

}

extension S3ControlClientTypes.JobManifestLocation: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eTag = "ETag"
        case objectArn = "ObjectArn"
        case objectVersionId = "ObjectVersionId"
    }

    static func writingClosure(_ value: S3ControlClientTypes.JobManifestLocation?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("ETag")].write(value.eTag)
        try writer[.init("ObjectArn")].write(value.objectArn)
        try writer[.init("ObjectVersionId")].write(value.objectVersionId)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectArn)
        objectArn = objectArnDecoded
        let objectVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectVersionId)
        objectVersionId = objectVersionIdDecoded
        let eTagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eTag)
        eTag = eTagDecoded
    }
}

extension S3ControlClientTypes {
    /// Contains the information required to locate a manifest object. Manifests can't be imported from directory buckets. For more information, see [Directory buckets](https://docs.aws.amazon.com/AmazonS3/latest/userguide/directory-buckets-overview.html).
    public struct JobManifestLocation: Swift.Equatable {
        /// The ETag for the specified manifest object.
        /// This member is required.
        public var eTag: Swift.String?
        /// The Amazon Resource Name (ARN) for a manifest object. When you're using XML requests, you must replace special characters (such as carriage returns) in object keys with their equivalent XML entity codes. For more information, see [ XML-related object key constraints](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints) in the Amazon S3 User Guide.
        /// This member is required.
        public var objectArn: Swift.String?
        /// The optional version ID to identify a specific version of the manifest object.
        public var objectVersionId: Swift.String?

        public init(
            eTag: Swift.String? = nil,
            objectArn: Swift.String? = nil,
            objectVersionId: Swift.String? = nil
        )
        {
            self.eTag = eTag
            self.objectArn = objectArn
            self.objectVersionId = objectVersionId
        }
    }

}

extension S3ControlClientTypes.JobManifestSpec: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields = "Fields"
        case format = "Format"
    }

    static func writingClosure(_ value: S3ControlClientTypes.JobManifestSpec?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Fields")].writeList(value.fields, memberWritingClosure: S3ControlClientTypes.JobManifestFieldName.writingClosure(_:to:), memberNodeInfo: .init("member"), isFlattened: false)
        try writer[.init("Format")].write(value.format)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobManifestFormat.self, forKey: .format)
        format = formatDecoded
        if containerValues.contains(.fields) {
            struct KeyVal0{struct member{}}
            let fieldsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .fields)
            if let fieldsWrappedContainer = fieldsWrappedContainer {
                let fieldsContainer = try fieldsWrappedContainer.decodeIfPresent([S3ControlClientTypes.JobManifestFieldName].self, forKey: .member)
                var fieldsBuffer:[S3ControlClientTypes.JobManifestFieldName]? = nil
                if let fieldsContainer = fieldsContainer {
                    fieldsBuffer = [S3ControlClientTypes.JobManifestFieldName]()
                    for enumContainer0 in fieldsContainer {
                        fieldsBuffer?.append(enumContainer0)
                    }
                }
                fields = fieldsBuffer
            } else {
                fields = []
            }
        } else {
            fields = nil
        }
    }
}

extension S3ControlClientTypes {
    /// Describes the format of a manifest. If the manifest is in CSV format, also describes the columns contained within the manifest.
    public struct JobManifestSpec: Swift.Equatable {
        /// If the specified manifest object is in the S3BatchOperations_CSV_20180820 format, this element describes which columns contain the required data.
        public var fields: [S3ControlClientTypes.JobManifestFieldName]?
        /// Indicates which of the available formats the specified manifest uses.
        /// This member is required.
        public var format: S3ControlClientTypes.JobManifestFormat?

        public init(
            fields: [S3ControlClientTypes.JobManifestFieldName]? = nil,
            format: S3ControlClientTypes.JobManifestFormat? = nil
        )
        {
            self.fields = fields
            self.format = format
        }
    }

}

extension S3ControlClientTypes.JobOperation: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lambdaInvoke = "LambdaInvoke"
        case s3DeleteObjectTagging = "S3DeleteObjectTagging"
        case s3InitiateRestoreObject = "S3InitiateRestoreObject"
        case s3PutObjectAcl = "S3PutObjectAcl"
        case s3PutObjectCopy = "S3PutObjectCopy"
        case s3PutObjectLegalHold = "S3PutObjectLegalHold"
        case s3PutObjectRetention = "S3PutObjectRetention"
        case s3PutObjectTagging = "S3PutObjectTagging"
        case s3ReplicateObject = "S3ReplicateObject"
    }

    static func writingClosure(_ value: S3ControlClientTypes.JobOperation?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("LambdaInvoke")].write(value.lambdaInvoke, writingClosure: S3ControlClientTypes.LambdaInvokeOperation.writingClosure(_:to:))
        try writer[.init("S3DeleteObjectTagging")].write(value.s3DeleteObjectTagging, writingClosure: S3ControlClientTypes.S3DeleteObjectTaggingOperation.writingClosure(_:to:))
        try writer[.init("S3InitiateRestoreObject")].write(value.s3InitiateRestoreObject, writingClosure: S3ControlClientTypes.S3InitiateRestoreObjectOperation.writingClosure(_:to:))
        try writer[.init("S3PutObjectAcl")].write(value.s3PutObjectAcl, writingClosure: S3ControlClientTypes.S3SetObjectAclOperation.writingClosure(_:to:))
        try writer[.init("S3PutObjectCopy")].write(value.s3PutObjectCopy, writingClosure: S3ControlClientTypes.S3CopyObjectOperation.writingClosure(_:to:))
        try writer[.init("S3PutObjectLegalHold")].write(value.s3PutObjectLegalHold, writingClosure: S3ControlClientTypes.S3SetObjectLegalHoldOperation.writingClosure(_:to:))
        try writer[.init("S3PutObjectRetention")].write(value.s3PutObjectRetention, writingClosure: S3ControlClientTypes.S3SetObjectRetentionOperation.writingClosure(_:to:))
        try writer[.init("S3PutObjectTagging")].write(value.s3PutObjectTagging, writingClosure: S3ControlClientTypes.S3SetObjectTaggingOperation.writingClosure(_:to:))
        try writer[.init("S3ReplicateObject")].write(value.s3ReplicateObject, writingClosure: S3ControlClientTypes.S3ReplicateObjectOperation.writingClosure(_:to:))
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaInvokeDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.LambdaInvokeOperation.self, forKey: .lambdaInvoke)
        lambdaInvoke = lambdaInvokeDecoded
        let s3PutObjectCopyDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3CopyObjectOperation.self, forKey: .s3PutObjectCopy)
        s3PutObjectCopy = s3PutObjectCopyDecoded
        let s3PutObjectAclDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3SetObjectAclOperation.self, forKey: .s3PutObjectAcl)
        s3PutObjectAcl = s3PutObjectAclDecoded
        let s3PutObjectTaggingDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3SetObjectTaggingOperation.self, forKey: .s3PutObjectTagging)
        s3PutObjectTagging = s3PutObjectTaggingDecoded
        let s3DeleteObjectTaggingDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3DeleteObjectTaggingOperation.self, forKey: .s3DeleteObjectTagging)
        s3DeleteObjectTagging = s3DeleteObjectTaggingDecoded
        let s3InitiateRestoreObjectDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3InitiateRestoreObjectOperation.self, forKey: .s3InitiateRestoreObject)
        s3InitiateRestoreObject = s3InitiateRestoreObjectDecoded
        let s3PutObjectLegalHoldDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3SetObjectLegalHoldOperation.self, forKey: .s3PutObjectLegalHold)
        s3PutObjectLegalHold = s3PutObjectLegalHoldDecoded
        let s3PutObjectRetentionDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3SetObjectRetentionOperation.self, forKey: .s3PutObjectRetention)
        s3PutObjectRetention = s3PutObjectRetentionDecoded
        let s3ReplicateObjectDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3ReplicateObjectOperation.self, forKey: .s3ReplicateObject)
        s3ReplicateObject = s3ReplicateObjectDecoded
    }
}

extension S3ControlClientTypes {
    /// The operation that you want this job to perform on every object listed in the manifest. For more information about the available operations, see [Operations](https://docs.aws.amazon.com/AmazonS3/latest/dev/batch-ops-operations.html) in the Amazon S3 User Guide.
    public struct JobOperation: Swift.Equatable {
        /// Directs the specified job to invoke an Lambda function on every object in the manifest.
        public var lambdaInvoke: S3ControlClientTypes.LambdaInvokeOperation?
        /// Directs the specified job to execute a DELETE Object tagging call on every object in the manifest. This functionality is not supported by directory buckets.
        public var s3DeleteObjectTagging: S3ControlClientTypes.S3DeleteObjectTaggingOperation?
        /// Directs the specified job to initiate restore requests for every archived object in the manifest. This functionality is not supported by directory buckets.
        public var s3InitiateRestoreObject: S3ControlClientTypes.S3InitiateRestoreObjectOperation?
        /// Directs the specified job to run a PutObjectAcl call on every object in the manifest. This functionality is not supported by directory buckets.
        public var s3PutObjectAcl: S3ControlClientTypes.S3SetObjectAclOperation?
        /// Directs the specified job to run a PUT Copy object call on every object in the manifest.
        public var s3PutObjectCopy: S3ControlClientTypes.S3CopyObjectOperation?
        /// Contains the configuration for an S3 Object Lock legal hold operation that an S3 Batch Operations job passes to every object to the underlying PutObjectLegalHold API operation. For more information, see [Using S3 Object Lock legal hold with S3 Batch Operations](https://docs.aws.amazon.com/AmazonS3/latest/dev/batch-ops-legal-hold.html) in the Amazon S3 User Guide. This functionality is not supported by directory buckets.
        public var s3PutObjectLegalHold: S3ControlClientTypes.S3SetObjectLegalHoldOperation?
        /// Contains the configuration parameters for the Object Lock retention action for an S3 Batch Operations job. Batch Operations passes every object to the underlying PutObjectRetention API operation. For more information, see [Using S3 Object Lock retention with S3 Batch Operations](https://docs.aws.amazon.com/AmazonS3/latest/dev/batch-ops-retention-date.html) in the Amazon S3 User Guide. This functionality is not supported by directory buckets.
        public var s3PutObjectRetention: S3ControlClientTypes.S3SetObjectRetentionOperation?
        /// Directs the specified job to run a PUT Object tagging call on every object in the manifest. This functionality is not supported by directory buckets.
        public var s3PutObjectTagging: S3ControlClientTypes.S3SetObjectTaggingOperation?
        /// Directs the specified job to invoke ReplicateObject on every object in the job's manifest. This functionality is not supported by directory buckets.
        public var s3ReplicateObject: S3ControlClientTypes.S3ReplicateObjectOperation?

        public init(
            lambdaInvoke: S3ControlClientTypes.LambdaInvokeOperation? = nil,
            s3DeleteObjectTagging: S3ControlClientTypes.S3DeleteObjectTaggingOperation? = nil,
            s3InitiateRestoreObject: S3ControlClientTypes.S3InitiateRestoreObjectOperation? = nil,
            s3PutObjectAcl: S3ControlClientTypes.S3SetObjectAclOperation? = nil,
            s3PutObjectCopy: S3ControlClientTypes.S3CopyObjectOperation? = nil,
            s3PutObjectLegalHold: S3ControlClientTypes.S3SetObjectLegalHoldOperation? = nil,
            s3PutObjectRetention: S3ControlClientTypes.S3SetObjectRetentionOperation? = nil,
            s3PutObjectTagging: S3ControlClientTypes.S3SetObjectTaggingOperation? = nil,
            s3ReplicateObject: S3ControlClientTypes.S3ReplicateObjectOperation? = nil
        )
        {
            self.lambdaInvoke = lambdaInvoke
            self.s3DeleteObjectTagging = s3DeleteObjectTagging
            self.s3InitiateRestoreObject = s3InitiateRestoreObject
            self.s3PutObjectAcl = s3PutObjectAcl
            self.s3PutObjectCopy = s3PutObjectCopy
            self.s3PutObjectLegalHold = s3PutObjectLegalHold
            self.s3PutObjectRetention = s3PutObjectRetention
            self.s3PutObjectTagging = s3PutObjectTagging
            self.s3ReplicateObject = s3ReplicateObject
        }
    }

}

extension S3ControlClientTypes.JobProgressSummary: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case numberOfTasksFailed = "NumberOfTasksFailed"
        case numberOfTasksSucceeded = "NumberOfTasksSucceeded"
        case timers = "Timers"
        case totalNumberOfTasks = "TotalNumberOfTasks"
    }

    static func writingClosure(_ value: S3ControlClientTypes.JobProgressSummary?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("NumberOfTasksFailed")].write(value.numberOfTasksFailed)
        try writer[.init("NumberOfTasksSucceeded")].write(value.numberOfTasksSucceeded)
        try writer[.init("Timers")].write(value.timers, writingClosure: S3ControlClientTypes.JobTimers.writingClosure(_:to:))
        try writer[.init("TotalNumberOfTasks")].write(value.totalNumberOfTasks)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalNumberOfTasksDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalNumberOfTasks) ?? nil
        totalNumberOfTasks = totalNumberOfTasksDecoded
        let numberOfTasksSucceededDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfTasksSucceeded) ?? nil
        numberOfTasksSucceeded = numberOfTasksSucceededDecoded
        let numberOfTasksFailedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfTasksFailed) ?? nil
        numberOfTasksFailed = numberOfTasksFailedDecoded
        let timersDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobTimers.self, forKey: .timers)
        timers = timersDecoded
    }
}

extension S3ControlClientTypes {
    /// Describes the total number of tasks that the specified job has started, the number of tasks that succeeded, and the number of tasks that failed.
    public struct JobProgressSummary: Swift.Equatable {
        ///
        public var numberOfTasksFailed: Swift.Int?
        ///
        public var numberOfTasksSucceeded: Swift.Int?
        /// The JobTimers attribute of a job's progress summary.
        public var timers: S3ControlClientTypes.JobTimers?
        ///
        public var totalNumberOfTasks: Swift.Int?

        public init(
            numberOfTasksFailed: Swift.Int? = nil,
            numberOfTasksSucceeded: Swift.Int? = nil,
            timers: S3ControlClientTypes.JobTimers? = nil,
            totalNumberOfTasks: Swift.Int? = nil
        )
        {
            self.numberOfTasksFailed = numberOfTasksFailed
            self.numberOfTasksSucceeded = numberOfTasksSucceeded
            self.timers = timers
            self.totalNumberOfTasks = totalNumberOfTasks
        }
    }

}

extension S3ControlClientTypes.JobReport: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case enabled = "Enabled"
        case format = "Format"
        case `prefix` = "Prefix"
        case reportScope = "ReportScope"
    }

    static func writingClosure(_ value: S3ControlClientTypes.JobReport?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Bucket")].write(value.bucket)
        try writer[.init("Enabled")].write(value.enabled)
        try writer[.init("Format")].write(value.format)
        try writer[.init("Prefix")].write(value.`prefix`)
        try writer[.init("ReportScope")].write(value.reportScope)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let formatDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobReportFormat.self, forKey: .format)
        format = formatDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        let reportScopeDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobReportScope.self, forKey: .reportScope)
        reportScope = reportScopeDecoded
    }
}

extension S3ControlClientTypes {
    /// Contains the configuration parameters for a job-completion report.
    public struct JobReport: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the bucket where specified job-completion report will be stored. Directory buckets - Directory buckets aren't supported as a location for Batch Operations to store job completion reports.
        public var bucket: Swift.String?
        /// Indicates whether the specified job will generate a job-completion report.
        /// This member is required.
        public var enabled: Swift.Bool
        /// The format of the specified job-completion report.
        public var format: S3ControlClientTypes.JobReportFormat?
        /// An optional prefix to describe where in the specified bucket the job-completion report will be stored. Amazon S3 stores the job-completion report at /job-/report.json.
        public var `prefix`: Swift.String?
        /// Indicates whether the job-completion report will include details of all tasks or only failed tasks.
        public var reportScope: S3ControlClientTypes.JobReportScope?

        public init(
            bucket: Swift.String? = nil,
            enabled: Swift.Bool = false,
            format: S3ControlClientTypes.JobReportFormat? = nil,
            `prefix`: Swift.String? = nil,
            reportScope: S3ControlClientTypes.JobReportScope? = nil
        )
        {
            self.bucket = bucket
            self.enabled = enabled
            self.format = format
            self.`prefix` = `prefix`
            self.reportScope = reportScope
        }
    }

}

extension S3ControlClientTypes {
    public enum JobReportFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case reportCsv20180820
        case sdkUnknown(Swift.String)

        public static var allCases: [JobReportFormat] {
            return [
                .reportCsv20180820,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .reportCsv20180820: return "Report_CSV_20180820"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobReportFormat(rawValue: rawValue) ?? JobReportFormat.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum JobReportScope: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case alltasks
        case failedtasksonly
        case sdkUnknown(Swift.String)

        public static var allCases: [JobReportScope] {
            return [
                .alltasks,
                .failedtasksonly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .alltasks: return "AllTasks"
            case .failedtasksonly: return "FailedTasksOnly"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobReportScope(rawValue: rawValue) ?? JobReportScope.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum JobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case cancelled
        case cancelling
        case complete
        case completing
        case failed
        case failing
        case new
        case paused
        case pausing
        case preparing
        case ready
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .active,
                .cancelled,
                .cancelling,
                .complete,
                .completing,
                .failed,
                .failing,
                .new,
                .paused,
                .pausing,
                .preparing,
                .ready,
                .suspended,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .cancelled: return "Cancelled"
            case .cancelling: return "Cancelling"
            case .complete: return "Complete"
            case .completing: return "Completing"
            case .failed: return "Failed"
            case .failing: return "Failing"
            case .new: return "New"
            case .paused: return "Paused"
            case .pausing: return "Pausing"
            case .preparing: return "Preparing"
            case .ready: return "Ready"
            case .suspended: return "Suspended"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
        }
    }
}

extension JobStatusException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<JobStatusExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct JobStatusException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "JobStatusException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct JobStatusExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension JobStatusExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension S3ControlClientTypes.JobTimers: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elapsedTimeInActiveSeconds = "ElapsedTimeInActiveSeconds"
    }

    static func writingClosure(_ value: S3ControlClientTypes.JobTimers?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("ElapsedTimeInActiveSeconds")].write(value.elapsedTimeInActiveSeconds)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elapsedTimeInActiveSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .elapsedTimeInActiveSeconds) ?? nil
        elapsedTimeInActiveSeconds = elapsedTimeInActiveSecondsDecoded
    }
}

extension S3ControlClientTypes {
    /// Provides timing details for the job.
    public struct JobTimers: Swift.Equatable {
        /// Indicates the elapsed time in seconds the job has been in the Active job state.
        public var elapsedTimeInActiveSeconds: Swift.Int?

        public init(
            elapsedTimeInActiveSeconds: Swift.Int? = nil
        )
        {
            self.elapsedTimeInActiveSeconds = elapsedTimeInActiveSeconds
        }
    }

}

extension S3ControlClientTypes.KeyNameConstraint: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case matchAnyPrefix = "MatchAnyPrefix"
        case matchAnySubstring = "MatchAnySubstring"
        case matchAnySuffix = "MatchAnySuffix"
    }

    static func writingClosure(_ value: S3ControlClientTypes.KeyNameConstraint?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("MatchAnyPrefix")].writeList(value.matchAnyPrefix, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: .init("member"), isFlattened: false)
        try writer[.init("MatchAnySubstring")].writeList(value.matchAnySubstring, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: .init("member"), isFlattened: false)
        try writer[.init("MatchAnySuffix")].writeList(value.matchAnySuffix, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: .init("member"), isFlattened: false)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.matchAnyPrefix) {
            struct KeyVal0{struct member{}}
            let matchAnyPrefixWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .matchAnyPrefix)
            if let matchAnyPrefixWrappedContainer = matchAnyPrefixWrappedContainer {
                let matchAnyPrefixContainer = try matchAnyPrefixWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var matchAnyPrefixBuffer:[Swift.String]? = nil
                if let matchAnyPrefixContainer = matchAnyPrefixContainer {
                    matchAnyPrefixBuffer = [Swift.String]()
                    for stringContainer0 in matchAnyPrefixContainer {
                        matchAnyPrefixBuffer?.append(stringContainer0)
                    }
                }
                matchAnyPrefix = matchAnyPrefixBuffer
            } else {
                matchAnyPrefix = []
            }
        } else {
            matchAnyPrefix = nil
        }
        if containerValues.contains(.matchAnySuffix) {
            struct KeyVal0{struct member{}}
            let matchAnySuffixWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .matchAnySuffix)
            if let matchAnySuffixWrappedContainer = matchAnySuffixWrappedContainer {
                let matchAnySuffixContainer = try matchAnySuffixWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var matchAnySuffixBuffer:[Swift.String]? = nil
                if let matchAnySuffixContainer = matchAnySuffixContainer {
                    matchAnySuffixBuffer = [Swift.String]()
                    for stringContainer0 in matchAnySuffixContainer {
                        matchAnySuffixBuffer?.append(stringContainer0)
                    }
                }
                matchAnySuffix = matchAnySuffixBuffer
            } else {
                matchAnySuffix = []
            }
        } else {
            matchAnySuffix = nil
        }
        if containerValues.contains(.matchAnySubstring) {
            struct KeyVal0{struct member{}}
            let matchAnySubstringWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .matchAnySubstring)
            if let matchAnySubstringWrappedContainer = matchAnySubstringWrappedContainer {
                let matchAnySubstringContainer = try matchAnySubstringWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var matchAnySubstringBuffer:[Swift.String]? = nil
                if let matchAnySubstringContainer = matchAnySubstringContainer {
                    matchAnySubstringBuffer = [Swift.String]()
                    for stringContainer0 in matchAnySubstringContainer {
                        matchAnySubstringBuffer?.append(stringContainer0)
                    }
                }
                matchAnySubstring = matchAnySubstringBuffer
            } else {
                matchAnySubstring = []
            }
        } else {
            matchAnySubstring = nil
        }
    }
}

extension S3ControlClientTypes {
    /// If provided, the generated manifest includes only source bucket objects whose object keys match the string constraints specified for MatchAnyPrefix, MatchAnySuffix, and MatchAnySubstring.
    public struct KeyNameConstraint: Swift.Equatable {
        /// If provided, the generated manifest includes objects where the specified string appears at the start of the object key string.
        public var matchAnyPrefix: [Swift.String]?
        /// If provided, the generated manifest includes objects where the specified string appears anywhere within the object key string.
        public var matchAnySubstring: [Swift.String]?
        /// If provided, the generated manifest includes objects where the specified string appears at the end of the object key string.
        public var matchAnySuffix: [Swift.String]?

        public init(
            matchAnyPrefix: [Swift.String]? = nil,
            matchAnySubstring: [Swift.String]? = nil,
            matchAnySuffix: [Swift.String]? = nil
        )
        {
            self.matchAnyPrefix = matchAnyPrefix
            self.matchAnySubstring = matchAnySubstring
            self.matchAnySuffix = matchAnySuffix
        }
    }

}

extension S3ControlClientTypes.LambdaInvokeOperation: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionArn = "FunctionArn"
        case invocationSchemaVersion = "InvocationSchemaVersion"
        case userArguments = "UserArguments"
    }

    static func writingClosure(_ value: S3ControlClientTypes.LambdaInvokeOperation?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("FunctionArn")].write(value.functionArn)
        try writer[.init("InvocationSchemaVersion")].write(value.invocationSchemaVersion)
        try writer[.init("UserArguments")].writeMap(value.userArguments, valueWritingClosure: Swift.String.writingClosure(_:to:), keyNodeInfo: .init("key"), valueNodeInfo: .init("value"), isFlattened: false)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let invocationSchemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invocationSchemaVersion)
        invocationSchemaVersion = invocationSchemaVersionDecoded
        if containerValues.contains(.userArguments) {
            struct KeyVal0{struct key{}; struct value{}}
            let userArgumentsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: ClientRuntime.MapEntry<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .userArguments)
            if let userArgumentsWrappedContainer = userArgumentsWrappedContainer {
                let userArgumentsContainer = try userArgumentsWrappedContainer.decodeIfPresent([ClientRuntime.MapKeyValue<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var userArgumentsBuffer: [Swift.String:Swift.String]? = nil
                if let userArgumentsContainer = userArgumentsContainer {
                    userArgumentsBuffer = [Swift.String:Swift.String]()
                    for stringContainer0 in userArgumentsContainer {
                        userArgumentsBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                userArguments = userArgumentsBuffer
            } else {
                userArguments = [:]
            }
        } else {
            userArguments = nil
        }
    }
}

extension S3ControlClientTypes {
    /// Contains the configuration parameters for a Lambda Invoke operation.
    public struct LambdaInvokeOperation: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the Lambda function that the specified job will invoke on every object in the manifest.
        public var functionArn: Swift.String?
        /// Specifies the schema version for the payload that Batch Operations sends when invoking an Lambda function. Version 1.0 is the default. Version 2.0 is required when you use Batch Operations to invoke Lambda functions that act on directory buckets, or if you need to specify UserArguments. For more information, see [Using Lambda with Amazon S3 Batch Operations and Amazon S3 Express One Zone](https://aws.amazon.com/blogs/storage/using-lambda-with-s3-batch-operations-and-s3-express-one-zone/) in the Amazon Web Services Storage Blog. Ensure that your Lambda function code expects InvocationSchemaVersion 2.0 and uses bucket name rather than bucket ARN. If the InvocationSchemaVersion does not match what your Lambda function expects, your function might not work as expected. Directory buckets - To initiate Amazon Web Services Lambda function to perform custom actions on objects in directory buckets, you must specify 2.0.
        public var invocationSchemaVersion: Swift.String?
        /// Key-value pairs that are passed in the payload that Batch Operations sends when invoking an Lambda function. You must specify InvocationSchemaVersion 2.0 for LambdaInvoke operations that include UserArguments. For more information, see [Using Lambda with Amazon S3 Batch Operations and Amazon S3 Express One Zone](https://aws.amazon.com/blogs/storage/using-lambda-with-s3-batch-operations-and-s3-express-one-zone/) in the Amazon Web Services Storage Blog.
        public var userArguments: [Swift.String:Swift.String]?

        public init(
            functionArn: Swift.String? = nil,
            invocationSchemaVersion: Swift.String? = nil,
            userArguments: [Swift.String:Swift.String]? = nil
        )
        {
            self.functionArn = functionArn
            self.invocationSchemaVersion = invocationSchemaVersion
            self.userArguments = userArguments
        }
    }

}

extension S3ControlClientTypes.LifecycleConfiguration: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rules = "Rules"
    }

    static func writingClosure(_ value: S3ControlClientTypes.LifecycleConfiguration?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Rules")].writeList(value.rules, memberWritingClosure: S3ControlClientTypes.LifecycleRule.writingClosure(_:to:), memberNodeInfo: .init("Rule"), isFlattened: false)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.rules) {
            struct KeyVal0{struct Rule{}}
            let rulesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Rule>.CodingKeys.self, forKey: .rules)
            if let rulesWrappedContainer = rulesWrappedContainer {
                let rulesContainer = try rulesWrappedContainer.decodeIfPresent([S3ControlClientTypes.LifecycleRule].self, forKey: .member)
                var rulesBuffer:[S3ControlClientTypes.LifecycleRule]? = nil
                if let rulesContainer = rulesContainer {
                    rulesBuffer = [S3ControlClientTypes.LifecycleRule]()
                    for structureContainer0 in rulesContainer {
                        rulesBuffer?.append(structureContainer0)
                    }
                }
                rules = rulesBuffer
            } else {
                rules = []
            }
        } else {
            rules = nil
        }
    }
}

extension S3ControlClientTypes {
    /// The container for the Outposts bucket lifecycle configuration.
    public struct LifecycleConfiguration: Swift.Equatable {
        /// A lifecycle rule for individual objects in an Outposts bucket.
        public var rules: [S3ControlClientTypes.LifecycleRule]?

        public init(
            rules: [S3ControlClientTypes.LifecycleRule]? = nil
        )
        {
            self.rules = rules
        }
    }

}

extension S3ControlClientTypes.LifecycleExpiration: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case date = "Date"
        case days = "Days"
        case expiredObjectDeleteMarker = "ExpiredObjectDeleteMarker"
    }

    static func writingClosure(_ value: S3ControlClientTypes.LifecycleExpiration?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Date")].writeTimestamp(value.date, format: .dateTime)
        try writer[.init("Days")].write(value.days)
        try writer[.init("ExpiredObjectDeleteMarker")].write(value.expiredObjectDeleteMarker)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .date)
        date = dateDecoded
        let daysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .days) ?? 0
        days = daysDecoded
        let expiredObjectDeleteMarkerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .expiredObjectDeleteMarker) ?? false
        expiredObjectDeleteMarker = expiredObjectDeleteMarkerDecoded
    }
}

extension S3ControlClientTypes {
    /// The container of the Outposts bucket lifecycle expiration.
    public struct LifecycleExpiration: Swift.Equatable {
        /// Indicates at what date the object is to be deleted. Should be in GMT ISO 8601 format.
        public var date: ClientRuntime.Date?
        /// Indicates the lifetime, in days, of the objects that are subject to the rule. The value must be a non-zero positive integer.
        public var days: Swift.Int
        /// Indicates whether Amazon S3 will remove a delete marker with no noncurrent versions. If set to true, the delete marker will be expired. If set to false, the policy takes no action. This cannot be specified with Days or Date in a Lifecycle Expiration Policy.
        public var expiredObjectDeleteMarker: Swift.Bool

        public init(
            date: ClientRuntime.Date? = nil,
            days: Swift.Int = 0,
            expiredObjectDeleteMarker: Swift.Bool = false
        )
        {
            self.date = date
            self.days = days
            self.expiredObjectDeleteMarker = expiredObjectDeleteMarker
        }
    }

}

extension S3ControlClientTypes.LifecycleRule: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case abortIncompleteMultipartUpload = "AbortIncompleteMultipartUpload"
        case expiration = "Expiration"
        case filter = "Filter"
        case id = "ID"
        case noncurrentVersionExpiration = "NoncurrentVersionExpiration"
        case noncurrentVersionTransitions = "NoncurrentVersionTransitions"
        case status = "Status"
        case transitions = "Transitions"
    }

    static func writingClosure(_ value: S3ControlClientTypes.LifecycleRule?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("AbortIncompleteMultipartUpload")].write(value.abortIncompleteMultipartUpload, writingClosure: S3ControlClientTypes.AbortIncompleteMultipartUpload.writingClosure(_:to:))
        try writer[.init("Expiration")].write(value.expiration, writingClosure: S3ControlClientTypes.LifecycleExpiration.writingClosure(_:to:))
        try writer[.init("Filter")].write(value.filter, writingClosure: S3ControlClientTypes.LifecycleRuleFilter.writingClosure(_:to:))
        try writer[.init("ID")].write(value.id)
        try writer[.init("NoncurrentVersionExpiration")].write(value.noncurrentVersionExpiration, writingClosure: S3ControlClientTypes.NoncurrentVersionExpiration.writingClosure(_:to:))
        try writer[.init("NoncurrentVersionTransitions")].writeList(value.noncurrentVersionTransitions, memberWritingClosure: S3ControlClientTypes.NoncurrentVersionTransition.writingClosure(_:to:), memberNodeInfo: .init("NoncurrentVersionTransition"), isFlattened: false)
        try writer[.init("Status")].write(value.status)
        try writer[.init("Transitions")].writeList(value.transitions, memberWritingClosure: S3ControlClientTypes.Transition.writingClosure(_:to:), memberNodeInfo: .init("Transition"), isFlattened: false)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expirationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.LifecycleExpiration.self, forKey: .expiration)
        expiration = expirationDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let filterDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.LifecycleRuleFilter.self, forKey: .filter)
        filter = filterDecoded
        let statusDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ExpirationStatus.self, forKey: .status)
        status = statusDecoded
        if containerValues.contains(.transitions) {
            struct KeyVal0{struct Transition{}}
            let transitionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Transition>.CodingKeys.self, forKey: .transitions)
            if let transitionsWrappedContainer = transitionsWrappedContainer {
                let transitionsContainer = try transitionsWrappedContainer.decodeIfPresent([S3ControlClientTypes.Transition].self, forKey: .member)
                var transitionsBuffer:[S3ControlClientTypes.Transition]? = nil
                if let transitionsContainer = transitionsContainer {
                    transitionsBuffer = [S3ControlClientTypes.Transition]()
                    for structureContainer0 in transitionsContainer {
                        transitionsBuffer?.append(structureContainer0)
                    }
                }
                transitions = transitionsBuffer
            } else {
                transitions = []
            }
        } else {
            transitions = nil
        }
        if containerValues.contains(.noncurrentVersionTransitions) {
            struct KeyVal0{struct NoncurrentVersionTransition{}}
            let noncurrentVersionTransitionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.NoncurrentVersionTransition>.CodingKeys.self, forKey: .noncurrentVersionTransitions)
            if let noncurrentVersionTransitionsWrappedContainer = noncurrentVersionTransitionsWrappedContainer {
                let noncurrentVersionTransitionsContainer = try noncurrentVersionTransitionsWrappedContainer.decodeIfPresent([S3ControlClientTypes.NoncurrentVersionTransition].self, forKey: .member)
                var noncurrentVersionTransitionsBuffer:[S3ControlClientTypes.NoncurrentVersionTransition]? = nil
                if let noncurrentVersionTransitionsContainer = noncurrentVersionTransitionsContainer {
                    noncurrentVersionTransitionsBuffer = [S3ControlClientTypes.NoncurrentVersionTransition]()
                    for structureContainer0 in noncurrentVersionTransitionsContainer {
                        noncurrentVersionTransitionsBuffer?.append(structureContainer0)
                    }
                }
                noncurrentVersionTransitions = noncurrentVersionTransitionsBuffer
            } else {
                noncurrentVersionTransitions = []
            }
        } else {
            noncurrentVersionTransitions = nil
        }
        let noncurrentVersionExpirationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.NoncurrentVersionExpiration.self, forKey: .noncurrentVersionExpiration)
        noncurrentVersionExpiration = noncurrentVersionExpirationDecoded
        let abortIncompleteMultipartUploadDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.AbortIncompleteMultipartUpload.self, forKey: .abortIncompleteMultipartUpload)
        abortIncompleteMultipartUpload = abortIncompleteMultipartUploadDecoded
    }
}

extension S3ControlClientTypes {
    /// The container for the Outposts bucket lifecycle rule.
    public struct LifecycleRule: Swift.Equatable {
        /// Specifies the days since the initiation of an incomplete multipart upload that Amazon S3 waits before permanently removing all parts of the upload. For more information, see [ Aborting Incomplete Multipart Uploads Using a Bucket Lifecycle Configuration](https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuoverview.html#mpu-abort-incomplete-mpu-lifecycle-config) in the Amazon S3 User Guide.
        public var abortIncompleteMultipartUpload: S3ControlClientTypes.AbortIncompleteMultipartUpload?
        /// Specifies the expiration for the lifecycle of the object in the form of date, days and, whether the object has a delete marker.
        public var expiration: S3ControlClientTypes.LifecycleExpiration?
        /// The container for the filter of lifecycle rule.
        public var filter: S3ControlClientTypes.LifecycleRuleFilter?
        /// Unique identifier for the rule. The value cannot be longer than 255 characters.
        public var id: Swift.String?
        /// The noncurrent version expiration of the lifecycle rule.
        public var noncurrentVersionExpiration: S3ControlClientTypes.NoncurrentVersionExpiration?
        /// Specifies the transition rule for the lifecycle rule that describes when noncurrent objects transition to a specific storage class. If your bucket is versioning-enabled (or versioning is suspended), you can set this action to request that Amazon S3 transition noncurrent object versions to a specific storage class at a set period in the object's lifetime. This is not supported by Amazon S3 on Outposts buckets.
        public var noncurrentVersionTransitions: [S3ControlClientTypes.NoncurrentVersionTransition]?
        /// If 'Enabled', the rule is currently being applied. If 'Disabled', the rule is not currently being applied.
        /// This member is required.
        public var status: S3ControlClientTypes.ExpirationStatus?
        /// Specifies when an Amazon S3 object transitions to a specified storage class. This is not supported by Amazon S3 on Outposts buckets.
        public var transitions: [S3ControlClientTypes.Transition]?

        public init(
            abortIncompleteMultipartUpload: S3ControlClientTypes.AbortIncompleteMultipartUpload? = nil,
            expiration: S3ControlClientTypes.LifecycleExpiration? = nil,
            filter: S3ControlClientTypes.LifecycleRuleFilter? = nil,
            id: Swift.String? = nil,
            noncurrentVersionExpiration: S3ControlClientTypes.NoncurrentVersionExpiration? = nil,
            noncurrentVersionTransitions: [S3ControlClientTypes.NoncurrentVersionTransition]? = nil,
            status: S3ControlClientTypes.ExpirationStatus? = nil,
            transitions: [S3ControlClientTypes.Transition]? = nil
        )
        {
            self.abortIncompleteMultipartUpload = abortIncompleteMultipartUpload
            self.expiration = expiration
            self.filter = filter
            self.id = id
            self.noncurrentVersionExpiration = noncurrentVersionExpiration
            self.noncurrentVersionTransitions = noncurrentVersionTransitions
            self.status = status
            self.transitions = transitions
        }
    }

}

extension S3ControlClientTypes.LifecycleRuleAndOperator: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectSizeGreaterThan = "ObjectSizeGreaterThan"
        case objectSizeLessThan = "ObjectSizeLessThan"
        case `prefix` = "Prefix"
        case tags = "Tags"
    }

    static func writingClosure(_ value: S3ControlClientTypes.LifecycleRuleAndOperator?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("ObjectSizeGreaterThan")].write(value.objectSizeGreaterThan)
        try writer[.init("ObjectSizeLessThan")].write(value.objectSizeLessThan)
        try writer[.init("Prefix")].write(value.`prefix`)
        try writer[.init("Tags")].writeList(value.tags, memberWritingClosure: S3ControlClientTypes.S3Tag.writingClosure(_:to:), memberNodeInfo: .init("member"), isFlattened: false)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([S3ControlClientTypes.S3Tag].self, forKey: .member)
                var tagsBuffer:[S3ControlClientTypes.S3Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [S3ControlClientTypes.S3Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let objectSizeGreaterThanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .objectSizeGreaterThan) ?? nil
        objectSizeGreaterThan = objectSizeGreaterThanDecoded
        let objectSizeLessThanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .objectSizeLessThan) ?? nil
        objectSizeLessThan = objectSizeLessThanDecoded
    }
}

extension S3ControlClientTypes {
    /// The container for the Outposts bucket lifecycle rule and operator.
    public struct LifecycleRuleAndOperator: Swift.Equatable {
        /// Minimum object size to which the rule applies.
        public var objectSizeGreaterThan: Swift.Int?
        /// Maximum object size to which the rule applies.
        public var objectSizeLessThan: Swift.Int?
        /// Prefix identifying one or more objects to which the rule applies.
        public var `prefix`: Swift.String?
        /// All of these tags must exist in the object's tag set in order for the rule to apply.
        public var tags: [S3ControlClientTypes.S3Tag]?

        public init(
            objectSizeGreaterThan: Swift.Int? = nil,
            objectSizeLessThan: Swift.Int? = nil,
            `prefix`: Swift.String? = nil,
            tags: [S3ControlClientTypes.S3Tag]? = nil
        )
        {
            self.objectSizeGreaterThan = objectSizeGreaterThan
            self.objectSizeLessThan = objectSizeLessThan
            self.`prefix` = `prefix`
            self.tags = tags
        }
    }

}

extension S3ControlClientTypes.LifecycleRuleFilter: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case and = "And"
        case objectSizeGreaterThan = "ObjectSizeGreaterThan"
        case objectSizeLessThan = "ObjectSizeLessThan"
        case `prefix` = "Prefix"
        case tag = "Tag"
    }

    static func writingClosure(_ value: S3ControlClientTypes.LifecycleRuleFilter?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("And")].write(value.and, writingClosure: S3ControlClientTypes.LifecycleRuleAndOperator.writingClosure(_:to:))
        try writer[.init("ObjectSizeGreaterThan")].write(value.objectSizeGreaterThan)
        try writer[.init("ObjectSizeLessThan")].write(value.objectSizeLessThan)
        try writer[.init("Prefix")].write(value.`prefix`)
        try writer[.init("Tag")].write(value.tag, writingClosure: S3ControlClientTypes.S3Tag.writingClosure(_:to:))
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        let tagDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3Tag.self, forKey: .tag)
        tag = tagDecoded
        let andDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.LifecycleRuleAndOperator.self, forKey: .and)
        and = andDecoded
        let objectSizeGreaterThanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .objectSizeGreaterThan) ?? nil
        objectSizeGreaterThan = objectSizeGreaterThanDecoded
        let objectSizeLessThanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .objectSizeLessThan) ?? nil
        objectSizeLessThan = objectSizeLessThanDecoded
    }
}

extension S3ControlClientTypes {
    /// The container for the filter of the lifecycle rule.
    public struct LifecycleRuleFilter: Swift.Equatable {
        /// The container for the AND condition for the lifecycle rule.
        public var and: S3ControlClientTypes.LifecycleRuleAndOperator?
        /// Minimum object size to which the rule applies.
        public var objectSizeGreaterThan: Swift.Int?
        /// Maximum object size to which the rule applies.
        public var objectSizeLessThan: Swift.Int?
        /// Prefix identifying one or more objects to which the rule applies. When you're using XML requests, you must replace special characters (such as carriage returns) in object keys with their equivalent XML entity codes. For more information, see [ XML-related object key constraints](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints) in the Amazon S3 User Guide.
        public var `prefix`: Swift.String?
        /// A container for a key-value name pair.
        public var tag: S3ControlClientTypes.S3Tag?

        public init(
            and: S3ControlClientTypes.LifecycleRuleAndOperator? = nil,
            objectSizeGreaterThan: Swift.Int? = nil,
            objectSizeLessThan: Swift.Int? = nil,
            `prefix`: Swift.String? = nil,
            tag: S3ControlClientTypes.S3Tag? = nil
        )
        {
            self.and = and
            self.objectSizeGreaterThan = objectSizeGreaterThan
            self.objectSizeLessThan = objectSizeLessThan
            self.`prefix` = `prefix`
            self.tag = tag
        }
    }

}

extension S3ControlClientTypes.ListAccessGrantEntry: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessGrantArn = "AccessGrantArn"
        case accessGrantId = "AccessGrantId"
        case accessGrantsLocationConfiguration = "AccessGrantsLocationConfiguration"
        case accessGrantsLocationId = "AccessGrantsLocationId"
        case applicationArn = "ApplicationArn"
        case createdAt = "CreatedAt"
        case grantScope = "GrantScope"
        case grantee = "Grantee"
        case permission = "Permission"
    }

    static func writingClosure(_ value: S3ControlClientTypes.ListAccessGrantEntry?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("AccessGrantArn")].write(value.accessGrantArn)
        try writer[.init("AccessGrantId")].write(value.accessGrantId)
        try writer[.init("AccessGrantsLocationConfiguration")].write(value.accessGrantsLocationConfiguration, writingClosure: S3ControlClientTypes.AccessGrantsLocationConfiguration.writingClosure(_:to:))
        try writer[.init("AccessGrantsLocationId")].write(value.accessGrantsLocationId)
        try writer[.init("ApplicationArn")].write(value.applicationArn)
        try writer[.init("CreatedAt")].writeTimestamp(value.createdAt, format: .dateTime)
        try writer[.init("GrantScope")].write(value.grantScope)
        try writer[.init("Grantee")].write(value.grantee, writingClosure: S3ControlClientTypes.Grantee.writingClosure(_:to:))
        try writer[.init("Permission")].write(value.permission)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let accessGrantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessGrantId)
        accessGrantId = accessGrantIdDecoded
        let accessGrantArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessGrantArn)
        accessGrantArn = accessGrantArnDecoded
        let granteeDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.Grantee.self, forKey: .grantee)
        grantee = granteeDecoded
        let permissionDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.Permission.self, forKey: .permission)
        permission = permissionDecoded
        let accessGrantsLocationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessGrantsLocationId)
        accessGrantsLocationId = accessGrantsLocationIdDecoded
        let accessGrantsLocationConfigurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.AccessGrantsLocationConfiguration.self, forKey: .accessGrantsLocationConfiguration)
        accessGrantsLocationConfiguration = accessGrantsLocationConfigurationDecoded
        let grantScopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantScope)
        grantScope = grantScopeDecoded
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
    }
}

extension S3ControlClientTypes {
    /// Information about the access grant.
    public struct ListAccessGrantEntry: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the access grant.
        public var accessGrantArn: Swift.String?
        /// The ID of the access grant. S3 Access Grants auto-generates this ID when you create the access grant.
        public var accessGrantId: Swift.String?
        /// The configuration options of the grant location. The grant location is the S3 path to the data to which you are granting access.
        public var accessGrantsLocationConfiguration: S3ControlClientTypes.AccessGrantsLocationConfiguration?
        /// The ID of the registered location to which you are granting access. S3 Access Grants assigns this ID when you register the location. S3 Access Grants assigns the ID default to the default location s3:// and assigns an auto-generated ID to other locations that you register.
        public var accessGrantsLocationId: Swift.String?
        /// The Amazon Resource Name (ARN) of an Amazon Web Services IAM Identity Center application associated with your Identity Center instance. If the grant includes an application ARN, the grantee can only access the S3 data through this application.
        public var applicationArn: Swift.String?
        /// The date and time when you created the S3 Access Grants instance.
        public var createdAt: ClientRuntime.Date?
        /// The S3 path of the data to which you are granting access. It is the result of appending the Subprefix to the location scope.
        public var grantScope: Swift.String?
        /// The user, group, or role to which you are granting access. You can grant access to an IAM user or role. If you have added your corporate directory to Amazon Web Services IAM Identity Center and associated your Identity Center instance with your S3 Access Grants instance, the grantee can also be a corporate directory user or group.
        public var grantee: S3ControlClientTypes.Grantee?
        /// The type of access granted to your S3 data, which can be set to one of the following values:
        ///
        /// * READ – Grant read-only access to the S3 data.
        ///
        /// * WRITE – Grant write-only access to the S3 data.
        ///
        /// * READWRITE – Grant both read and write access to the S3 data.
        public var permission: S3ControlClientTypes.Permission?

        public init(
            accessGrantArn: Swift.String? = nil,
            accessGrantId: Swift.String? = nil,
            accessGrantsLocationConfiguration: S3ControlClientTypes.AccessGrantsLocationConfiguration? = nil,
            accessGrantsLocationId: Swift.String? = nil,
            applicationArn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            grantScope: Swift.String? = nil,
            grantee: S3ControlClientTypes.Grantee? = nil,
            permission: S3ControlClientTypes.Permission? = nil
        )
        {
            self.accessGrantArn = accessGrantArn
            self.accessGrantId = accessGrantId
            self.accessGrantsLocationConfiguration = accessGrantsLocationConfiguration
            self.accessGrantsLocationId = accessGrantsLocationId
            self.applicationArn = applicationArn
            self.createdAt = createdAt
            self.grantScope = grantScope
            self.grantee = grantee
            self.permission = permission
        }
    }

}

extension ListAccessGrantsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension ListAccessGrantsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let grantScope = grantScope {
                let grantScopeQueryItem = ClientRuntime.URLQueryItem(name: "grantscope".urlPercentEncoding(), value: Swift.String(grantScope).urlPercentEncoding())
                items.append(grantScopeQueryItem)
            }
            if let granteeType = granteeType {
                let granteeTypeQueryItem = ClientRuntime.URLQueryItem(name: "granteetype".urlPercentEncoding(), value: Swift.String(granteeType.rawValue).urlPercentEncoding())
                items.append(granteeTypeQueryItem)
            }
            if let applicationArn = applicationArn {
                let applicationArnQueryItem = ClientRuntime.URLQueryItem(name: "application_arn".urlPercentEncoding(), value: Swift.String(applicationArn).urlPercentEncoding())
                items.append(applicationArnQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let permission = permission {
                let permissionQueryItem = ClientRuntime.URLQueryItem(name: "permission".urlPercentEncoding(), value: Swift.String(permission.rawValue).urlPercentEncoding())
                items.append(permissionQueryItem)
            }
            if let granteeIdentifier = granteeIdentifier {
                let granteeIdentifierQueryItem = ClientRuntime.URLQueryItem(name: "granteeidentifier".urlPercentEncoding(), value: Swift.String(granteeIdentifier).urlPercentEncoding())
                items.append(granteeIdentifierQueryItem)
            }
            return items
        }
    }
}

extension ListAccessGrantsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/accessgrantsinstance/grants"
    }
}

public struct ListAccessGrantsInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that is making this request.
    /// This member is required.
    public var accountId: Swift.String?
    /// The Amazon Resource Name (ARN) of an Amazon Web Services IAM Identity Center application associated with your Identity Center instance. If the grant includes an application ARN, the grantee can only access the S3 data through this application.
    public var applicationArn: Swift.String?
    /// The S3 path of the data to which you are granting access. It is the result of appending the Subprefix to the location scope.
    public var grantScope: Swift.String?
    /// The unique identifer of the Grantee. If the grantee type is IAM, the identifier is the IAM Amazon Resource Name (ARN) of the user or role. If the grantee type is a directory user or group, the identifier is 128-bit universally unique identifier (UUID) in the format a1b2c3d4-5678-90ab-cdef-EXAMPLE11111. You can obtain this UUID from your Amazon Web Services IAM Identity Center instance.
    public var granteeIdentifier: Swift.String?
    /// The type of the grantee to which access has been granted. It can be one of the following values:
    ///
    /// * IAM - An IAM user or role.
    ///
    /// * DIRECTORY_USER - Your corporate directory user. You can use this option if you have added your corporate identity directory to IAM Identity Center and associated the IAM Identity Center instance with your S3 Access Grants instance.
    ///
    /// * DIRECTORY_GROUP - Your corporate directory group. You can use this option if you have added your corporate identity directory to IAM Identity Center and associated the IAM Identity Center instance with your S3 Access Grants instance.
    public var granteeType: S3ControlClientTypes.GranteeType?
    /// The maximum number of access grants that you would like returned in the List Access Grants response. If the results include the pagination token NextToken, make another call using the NextToken to determine if there are more results.
    public var maxResults: Swift.Int?
    /// A pagination token to request the next page of results. Pass this value into a subsequent List Access Grants request in order to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The type of permission granted to your S3 data, which can be set to one of the following values:
    ///
    /// * READ – Grant read-only access to the S3 data.
    ///
    /// * WRITE – Grant write-only access to the S3 data.
    ///
    /// * READWRITE – Grant both read and write access to the S3 data.
    public var permission: S3ControlClientTypes.Permission?

    public init(
        accountId: Swift.String? = nil,
        applicationArn: Swift.String? = nil,
        grantScope: Swift.String? = nil,
        granteeIdentifier: Swift.String? = nil,
        granteeType: S3ControlClientTypes.GranteeType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        permission: S3ControlClientTypes.Permission? = nil
    )
    {
        self.accountId = accountId
        self.applicationArn = applicationArn
        self.grantScope = grantScope
        self.granteeIdentifier = granteeIdentifier
        self.granteeType = granteeType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.permission = permission
    }
}

extension S3ControlClientTypes.ListAccessGrantsInstanceEntry: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessGrantsInstanceArn = "AccessGrantsInstanceArn"
        case accessGrantsInstanceId = "AccessGrantsInstanceId"
        case createdAt = "CreatedAt"
        case identityCenterArn = "IdentityCenterArn"
    }

    static func writingClosure(_ value: S3ControlClientTypes.ListAccessGrantsInstanceEntry?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("AccessGrantsInstanceArn")].write(value.accessGrantsInstanceArn)
        try writer[.init("AccessGrantsInstanceId")].write(value.accessGrantsInstanceId)
        try writer[.init("CreatedAt")].writeTimestamp(value.createdAt, format: .dateTime)
        try writer[.init("IdentityCenterArn")].write(value.identityCenterArn)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessGrantsInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessGrantsInstanceId)
        accessGrantsInstanceId = accessGrantsInstanceIdDecoded
        let accessGrantsInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessGrantsInstanceArn)
        accessGrantsInstanceArn = accessGrantsInstanceArnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let identityCenterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityCenterArn)
        identityCenterArn = identityCenterArnDecoded
    }
}

extension S3ControlClientTypes {
    /// Information about the S3 Access Grants instance.
    public struct ListAccessGrantsInstanceEntry: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the S3 Access Grants instance.
        public var accessGrantsInstanceArn: Swift.String?
        /// The ID of the S3 Access Grants instance. The ID is default. You can have one S3 Access Grants instance per Region per account.
        public var accessGrantsInstanceId: Swift.String?
        /// The date and time when you created the S3 Access Grants instance.
        public var createdAt: ClientRuntime.Date?
        /// If you associated your S3 Access Grants instance with an Amazon Web Services IAM Identity Center instance, this field returns the Amazon Resource Name (ARN) of the IAM Identity Center instance application; a subresource of the original Identity Center instance. S3 Access Grants creates this Identity Center application for the specific S3 Access Grants instance.
        public var identityCenterArn: Swift.String?

        public init(
            accessGrantsInstanceArn: Swift.String? = nil,
            accessGrantsInstanceId: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            identityCenterArn: Swift.String? = nil
        )
        {
            self.accessGrantsInstanceArn = accessGrantsInstanceArn
            self.accessGrantsInstanceId = accessGrantsInstanceId
            self.createdAt = createdAt
            self.identityCenterArn = identityCenterArn
        }
    }

}

extension ListAccessGrantsInstancesInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension ListAccessGrantsInstancesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAccessGrantsInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/accessgrantsinstances"
    }
}

public struct ListAccessGrantsInstancesInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that is making this request.
    /// This member is required.
    public var accountId: Swift.String?
    /// The maximum number of access grants that you would like returned in the List Access Grants response. If the results include the pagination token NextToken, make another call using the NextToken to determine if there are more results.
    public var maxResults: Swift.Int?
    /// A pagination token to request the next page of results. Pass this value into a subsequent List Access Grants Instances request in order to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListAccessGrantsInstancesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAccessGrantsInstancesOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessGrantsInstancesList = output.accessGrantsInstancesList
            self.nextToken = output.nextToken
        } else {
            self.accessGrantsInstancesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccessGrantsInstancesOutput: Swift.Equatable {
    /// A container for a list of S3 Access Grants instances.
    public var accessGrantsInstancesList: [S3ControlClientTypes.ListAccessGrantsInstanceEntry]?
    /// A pagination token to request the next page of results. Pass this value into a subsequent List Access Grants Instances request in order to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        accessGrantsInstancesList: [S3ControlClientTypes.ListAccessGrantsInstanceEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accessGrantsInstancesList = accessGrantsInstancesList
        self.nextToken = nextToken
    }
}

struct ListAccessGrantsInstancesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let accessGrantsInstancesList: [S3ControlClientTypes.ListAccessGrantsInstanceEntry]?
}

extension ListAccessGrantsInstancesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessGrantsInstancesList = "AccessGrantsInstancesList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        if containerValues.contains(.accessGrantsInstancesList) {
            struct KeyVal0{struct AccessGrantsInstance{}}
            let accessGrantsInstancesListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AccessGrantsInstance>.CodingKeys.self, forKey: .accessGrantsInstancesList)
            if let accessGrantsInstancesListWrappedContainer = accessGrantsInstancesListWrappedContainer {
                let accessGrantsInstancesListContainer = try accessGrantsInstancesListWrappedContainer.decodeIfPresent([S3ControlClientTypes.ListAccessGrantsInstanceEntry].self, forKey: .member)
                var accessGrantsInstancesListBuffer:[S3ControlClientTypes.ListAccessGrantsInstanceEntry]? = nil
                if let accessGrantsInstancesListContainer = accessGrantsInstancesListContainer {
                    accessGrantsInstancesListBuffer = [S3ControlClientTypes.ListAccessGrantsInstanceEntry]()
                    for structureContainer0 in accessGrantsInstancesListContainer {
                        accessGrantsInstancesListBuffer?.append(structureContainer0)
                    }
                }
                accessGrantsInstancesList = accessGrantsInstancesListBuffer
            } else {
                accessGrantsInstancesList = []
            }
        } else {
            accessGrantsInstancesList = nil
        }
    }
}

enum ListAccessGrantsInstancesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension S3ControlClientTypes.ListAccessGrantsLocationsEntry: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessGrantsLocationArn = "AccessGrantsLocationArn"
        case accessGrantsLocationId = "AccessGrantsLocationId"
        case createdAt = "CreatedAt"
        case iamRoleArn = "IAMRoleArn"
        case locationScope = "LocationScope"
    }

    static func writingClosure(_ value: S3ControlClientTypes.ListAccessGrantsLocationsEntry?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("AccessGrantsLocationArn")].write(value.accessGrantsLocationArn)
        try writer[.init("AccessGrantsLocationId")].write(value.accessGrantsLocationId)
        try writer[.init("CreatedAt")].writeTimestamp(value.createdAt, format: .dateTime)
        try writer[.init("IAMRoleArn")].write(value.iamRoleArn)
        try writer[.init("LocationScope")].write(value.locationScope)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let accessGrantsLocationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessGrantsLocationId)
        accessGrantsLocationId = accessGrantsLocationIdDecoded
        let accessGrantsLocationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessGrantsLocationArn)
        accessGrantsLocationArn = accessGrantsLocationArnDecoded
        let locationScopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locationScope)
        locationScope = locationScopeDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
    }
}

extension S3ControlClientTypes {
    /// A container for information about the registered location.
    public struct ListAccessGrantsLocationsEntry: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the registered location.
        public var accessGrantsLocationArn: Swift.String?
        /// The ID of the registered location to which you are granting access. S3 Access Grants assigns this ID when you register the location. S3 Access Grants assigns the ID default to the default location s3:// and assigns an auto-generated ID to other locations that you register.
        public var accessGrantsLocationId: Swift.String?
        /// The date and time when you registered the location.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the IAM role for the registered location. S3 Access Grants assumes this role to manage access to the registered location.
        public var iamRoleArn: Swift.String?
        /// The S3 path to the location that you are registering. The location scope can be the default S3 location s3://, the S3 path to a bucket s3://, or the S3 path to a bucket and prefix s3:///. A prefix in S3 is a string of characters at the beginning of an object key name used to organize the objects that you store in your S3 buckets. For example, object key names that start with the engineering/ prefix or object key names that start with the marketing/campaigns/ prefix.
        public var locationScope: Swift.String?

        public init(
            accessGrantsLocationArn: Swift.String? = nil,
            accessGrantsLocationId: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            iamRoleArn: Swift.String? = nil,
            locationScope: Swift.String? = nil
        )
        {
            self.accessGrantsLocationArn = accessGrantsLocationArn
            self.accessGrantsLocationId = accessGrantsLocationId
            self.createdAt = createdAt
            self.iamRoleArn = iamRoleArn
            self.locationScope = locationScope
        }
    }

}

extension ListAccessGrantsLocationsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension ListAccessGrantsLocationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let locationScope = locationScope {
                let locationScopeQueryItem = ClientRuntime.URLQueryItem(name: "locationscope".urlPercentEncoding(), value: Swift.String(locationScope).urlPercentEncoding())
                items.append(locationScopeQueryItem)
            }
            return items
        }
    }
}

extension ListAccessGrantsLocationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/accessgrantsinstance/locations"
    }
}

public struct ListAccessGrantsLocationsInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that is making this request.
    /// This member is required.
    public var accountId: Swift.String?
    /// The S3 path to the location that you are registering. The location scope can be the default S3 location s3://, the S3 path to a bucket s3://, or the S3 path to a bucket and prefix s3:///. A prefix in S3 is a string of characters at the beginning of an object key name used to organize the objects that you store in your S3 buckets. For example, object key names that start with the engineering/ prefix or object key names that start with the marketing/campaigns/ prefix.
    public var locationScope: Swift.String?
    /// The maximum number of access grants that you would like returned in the List Access Grants response. If the results include the pagination token NextToken, make another call using the NextToken to determine if there are more results.
    public var maxResults: Swift.Int?
    /// A pagination token to request the next page of results. Pass this value into a subsequent List Access Grants Locations request in order to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        locationScope: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.locationScope = locationScope
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListAccessGrantsLocationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAccessGrantsLocationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessGrantsLocationsList = output.accessGrantsLocationsList
            self.nextToken = output.nextToken
        } else {
            self.accessGrantsLocationsList = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccessGrantsLocationsOutput: Swift.Equatable {
    /// A container for a list of registered locations in an S3 Access Grants instance.
    public var accessGrantsLocationsList: [S3ControlClientTypes.ListAccessGrantsLocationsEntry]?
    /// A pagination token to request the next page of results. Pass this value into a subsequent List Access Grants Locations request in order to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        accessGrantsLocationsList: [S3ControlClientTypes.ListAccessGrantsLocationsEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accessGrantsLocationsList = accessGrantsLocationsList
        self.nextToken = nextToken
    }
}

struct ListAccessGrantsLocationsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let accessGrantsLocationsList: [S3ControlClientTypes.ListAccessGrantsLocationsEntry]?
}

extension ListAccessGrantsLocationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessGrantsLocationsList = "AccessGrantsLocationsList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        if containerValues.contains(.accessGrantsLocationsList) {
            struct KeyVal0{struct AccessGrantsLocation{}}
            let accessGrantsLocationsListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AccessGrantsLocation>.CodingKeys.self, forKey: .accessGrantsLocationsList)
            if let accessGrantsLocationsListWrappedContainer = accessGrantsLocationsListWrappedContainer {
                let accessGrantsLocationsListContainer = try accessGrantsLocationsListWrappedContainer.decodeIfPresent([S3ControlClientTypes.ListAccessGrantsLocationsEntry].self, forKey: .member)
                var accessGrantsLocationsListBuffer:[S3ControlClientTypes.ListAccessGrantsLocationsEntry]? = nil
                if let accessGrantsLocationsListContainer = accessGrantsLocationsListContainer {
                    accessGrantsLocationsListBuffer = [S3ControlClientTypes.ListAccessGrantsLocationsEntry]()
                    for structureContainer0 in accessGrantsLocationsListContainer {
                        accessGrantsLocationsListBuffer?.append(structureContainer0)
                    }
                }
                accessGrantsLocationsList = accessGrantsLocationsListBuffer
            } else {
                accessGrantsLocationsList = []
            }
        } else {
            accessGrantsLocationsList = nil
        }
    }
}

enum ListAccessGrantsLocationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListAccessGrantsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAccessGrantsOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessGrantsList = output.accessGrantsList
            self.nextToken = output.nextToken
        } else {
            self.accessGrantsList = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccessGrantsOutput: Swift.Equatable {
    /// A container for a list of grants in an S3 Access Grants instance.
    public var accessGrantsList: [S3ControlClientTypes.ListAccessGrantEntry]?
    /// A pagination token to request the next page of results. Pass this value into a subsequent List Access Grants request in order to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        accessGrantsList: [S3ControlClientTypes.ListAccessGrantEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accessGrantsList = accessGrantsList
        self.nextToken = nextToken
    }
}

struct ListAccessGrantsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let accessGrantsList: [S3ControlClientTypes.ListAccessGrantEntry]?
}

extension ListAccessGrantsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessGrantsList = "AccessGrantsList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        if containerValues.contains(.accessGrantsList) {
            struct KeyVal0{struct AccessGrant{}}
            let accessGrantsListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AccessGrant>.CodingKeys.self, forKey: .accessGrantsList)
            if let accessGrantsListWrappedContainer = accessGrantsListWrappedContainer {
                let accessGrantsListContainer = try accessGrantsListWrappedContainer.decodeIfPresent([S3ControlClientTypes.ListAccessGrantEntry].self, forKey: .member)
                var accessGrantsListBuffer:[S3ControlClientTypes.ListAccessGrantEntry]? = nil
                if let accessGrantsListContainer = accessGrantsListContainer {
                    accessGrantsListBuffer = [S3ControlClientTypes.ListAccessGrantEntry]()
                    for structureContainer0 in accessGrantsListContainer {
                        accessGrantsListBuffer?.append(structureContainer0)
                    }
                }
                accessGrantsList = accessGrantsListBuffer
            } else {
                accessGrantsList = []
            }
        } else {
            accessGrantsList = nil
        }
    }
}

enum ListAccessGrantsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListAccessPointsForObjectLambdaInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension ListAccessPointsForObjectLambdaInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAccessPointsForObjectLambdaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/accesspointforobjectlambda"
    }
}

public struct ListAccessPointsForObjectLambdaInput: Swift.Equatable {
    /// The account ID for the account that owns the specified Object Lambda Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The maximum number of access points that you want to include in the list. The response may contain fewer access points but will never contain more. If there are more than this number of access points, then the response will include a continuation token in the NextToken field that you can use to retrieve the next page of access points.
    public var maxResults: Swift.Int?
    /// If the list has more access points than can be returned in one call to this API, this field contains a continuation token that you can provide in subsequent calls to this API to retrieve additional access points.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListAccessPointsForObjectLambdaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAccessPointsForObjectLambdaOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.objectLambdaAccessPointList = output.objectLambdaAccessPointList
        } else {
            self.nextToken = nil
            self.objectLambdaAccessPointList = nil
        }
    }
}

public struct ListAccessPointsForObjectLambdaOutput: Swift.Equatable {
    /// If the list has more access points than can be returned in one call to this API, this field contains a continuation token that you can provide in subsequent calls to this API to retrieve additional access points.
    public var nextToken: Swift.String?
    /// Returns list of Object Lambda Access Points.
    public var objectLambdaAccessPointList: [S3ControlClientTypes.ObjectLambdaAccessPoint]?

    public init(
        nextToken: Swift.String? = nil,
        objectLambdaAccessPointList: [S3ControlClientTypes.ObjectLambdaAccessPoint]? = nil
    )
    {
        self.nextToken = nextToken
        self.objectLambdaAccessPointList = objectLambdaAccessPointList
    }
}

struct ListAccessPointsForObjectLambdaOutputBody: Swift.Equatable {
    let objectLambdaAccessPointList: [S3ControlClientTypes.ObjectLambdaAccessPoint]?
    let nextToken: Swift.String?
}

extension ListAccessPointsForObjectLambdaOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case objectLambdaAccessPointList = "ObjectLambdaAccessPointList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.objectLambdaAccessPointList) {
            struct KeyVal0{struct ObjectLambdaAccessPoint{}}
            let objectLambdaAccessPointListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ObjectLambdaAccessPoint>.CodingKeys.self, forKey: .objectLambdaAccessPointList)
            if let objectLambdaAccessPointListWrappedContainer = objectLambdaAccessPointListWrappedContainer {
                let objectLambdaAccessPointListContainer = try objectLambdaAccessPointListWrappedContainer.decodeIfPresent([S3ControlClientTypes.ObjectLambdaAccessPoint].self, forKey: .member)
                var objectLambdaAccessPointListBuffer:[S3ControlClientTypes.ObjectLambdaAccessPoint]? = nil
                if let objectLambdaAccessPointListContainer = objectLambdaAccessPointListContainer {
                    objectLambdaAccessPointListBuffer = [S3ControlClientTypes.ObjectLambdaAccessPoint]()
                    for structureContainer0 in objectLambdaAccessPointListContainer {
                        objectLambdaAccessPointListBuffer?.append(structureContainer0)
                    }
                }
                objectLambdaAccessPointList = objectLambdaAccessPointListBuffer
            } else {
                objectLambdaAccessPointList = []
            }
        } else {
            objectLambdaAccessPointList = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAccessPointsForObjectLambdaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListAccessPointsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension ListAccessPointsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let bucket = bucket {
                let bucketQueryItem = ClientRuntime.URLQueryItem(name: "bucket".urlPercentEncoding(), value: Swift.String(bucket).urlPercentEncoding())
                items.append(bucketQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAccessPointsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/accesspoint"
    }
}

public struct ListAccessPointsInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the account that owns the specified access points.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the bucket whose associated access points you want to list. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    public var bucket: Swift.String?
    /// The maximum number of access points that you want to include in the list. If the specified bucket has more than this number of access points, then the response will include a continuation token in the NextToken field that you can use to retrieve the next page of access points.
    public var maxResults: Swift.Int?
    /// A continuation token. If a previous call to ListAccessPoints returned a continuation token in the NextToken field, then providing that value here causes Amazon S3 to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListAccessPointsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAccessPointsOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessPointList = output.accessPointList
            self.nextToken = output.nextToken
        } else {
            self.accessPointList = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccessPointsOutput: Swift.Equatable {
    /// Contains identification and configuration information for one or more access points associated with the specified bucket.
    public var accessPointList: [S3ControlClientTypes.AccessPoint]?
    /// If the specified bucket has more access points than can be returned in one call to this API, this field contains a continuation token that you can provide in subsequent calls to this API to retrieve additional access points.
    public var nextToken: Swift.String?

    public init(
        accessPointList: [S3ControlClientTypes.AccessPoint]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accessPointList = accessPointList
        self.nextToken = nextToken
    }
}

struct ListAccessPointsOutputBody: Swift.Equatable {
    let accessPointList: [S3ControlClientTypes.AccessPoint]?
    let nextToken: Swift.String?
}

extension ListAccessPointsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPointList = "AccessPointList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.accessPointList) {
            struct KeyVal0{struct AccessPoint{}}
            let accessPointListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AccessPoint>.CodingKeys.self, forKey: .accessPointList)
            if let accessPointListWrappedContainer = accessPointListWrappedContainer {
                let accessPointListContainer = try accessPointListWrappedContainer.decodeIfPresent([S3ControlClientTypes.AccessPoint].self, forKey: .member)
                var accessPointListBuffer:[S3ControlClientTypes.AccessPoint]? = nil
                if let accessPointListContainer = accessPointListContainer {
                    accessPointListBuffer = [S3ControlClientTypes.AccessPoint]()
                    for structureContainer0 in accessPointListContainer {
                        accessPointListBuffer?.append(structureContainer0)
                    }
                }
                accessPointList = accessPointListBuffer
            } else {
                accessPointList = []
            }
        } else {
            accessPointList = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAccessPointsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListJobsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension ListJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let jobStatuses = jobStatuses {
                jobStatuses.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "jobStatuses".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/jobs"
    }
}

public struct ListJobsInput: Swift.Equatable {
    /// The Amazon Web Services account ID associated with the S3 Batch Operations job.
    /// This member is required.
    public var accountId: Swift.String?
    /// The List Jobs request returns jobs that match the statuses listed in this element.
    public var jobStatuses: [S3ControlClientTypes.JobStatus]?
    /// The maximum number of jobs that Amazon S3 will include in the List Jobs response. If there are more jobs than this number, the response will include a pagination token in the NextToken field to enable you to retrieve the next page of results.
    public var maxResults: Swift.Int?
    /// A pagination token to request the next page of results. Use the token that Amazon S3 returned in the NextToken element of the ListJobsResult from the previous List Jobs request.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        jobStatuses: [S3ControlClientTypes.JobStatus]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.jobStatuses = jobStatuses
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobs = output.jobs
            self.nextToken = output.nextToken
        } else {
            self.jobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListJobsOutput: Swift.Equatable {
    /// The list of current jobs and jobs that have ended within the last 30 days.
    public var jobs: [S3ControlClientTypes.JobListDescriptor]?
    /// If the List Jobs request produced more than the maximum number of results, you can pass this value into a subsequent List Jobs request in order to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        jobs: [S3ControlClientTypes.JobListDescriptor]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

struct ListJobsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let jobs: [S3ControlClientTypes.JobListDescriptor]?
}

extension ListJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobs = "Jobs"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        if containerValues.contains(.jobs) {
            struct KeyVal0{struct member{}}
            let jobsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .jobs)
            if let jobsWrappedContainer = jobsWrappedContainer {
                let jobsContainer = try jobsWrappedContainer.decodeIfPresent([S3ControlClientTypes.JobListDescriptor].self, forKey: .member)
                var jobsBuffer:[S3ControlClientTypes.JobListDescriptor]? = nil
                if let jobsContainer = jobsContainer {
                    jobsBuffer = [S3ControlClientTypes.JobListDescriptor]()
                    for structureContainer0 in jobsContainer {
                        jobsBuffer?.append(structureContainer0)
                    }
                }
                jobs = jobsBuffer
            } else {
                jobs = []
            }
        } else {
            jobs = nil
        }
    }
}

enum ListJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListMultiRegionAccessPointsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension ListMultiRegionAccessPointsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListMultiRegionAccessPointsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/mrap/instances"
    }
}

public struct ListMultiRegionAccessPointsInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the owner of the Multi-Region Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// Not currently used. Do not use this parameter.
    public var maxResults: Swift.Int?
    /// Not currently used. Do not use this parameter.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListMultiRegionAccessPointsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMultiRegionAccessPointsOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessPoints = output.accessPoints
            self.nextToken = output.nextToken
        } else {
            self.accessPoints = nil
            self.nextToken = nil
        }
    }
}

public struct ListMultiRegionAccessPointsOutput: Swift.Equatable {
    /// The list of Multi-Region Access Points associated with the user.
    public var accessPoints: [S3ControlClientTypes.MultiRegionAccessPointReport]?
    /// If the specified bucket has more Multi-Region Access Points than can be returned in one call to this action, this field contains a continuation token. You can use this token tin subsequent calls to this action to retrieve additional Multi-Region Access Points.
    public var nextToken: Swift.String?

    public init(
        accessPoints: [S3ControlClientTypes.MultiRegionAccessPointReport]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accessPoints = accessPoints
        self.nextToken = nextToken
    }
}

struct ListMultiRegionAccessPointsOutputBody: Swift.Equatable {
    let accessPoints: [S3ControlClientTypes.MultiRegionAccessPointReport]?
    let nextToken: Swift.String?
}

extension ListMultiRegionAccessPointsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPoints = "AccessPoints"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.accessPoints) {
            struct KeyVal0{struct AccessPoint{}}
            let accessPointsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AccessPoint>.CodingKeys.self, forKey: .accessPoints)
            if let accessPointsWrappedContainer = accessPointsWrappedContainer {
                let accessPointsContainer = try accessPointsWrappedContainer.decodeIfPresent([S3ControlClientTypes.MultiRegionAccessPointReport].self, forKey: .member)
                var accessPointsBuffer:[S3ControlClientTypes.MultiRegionAccessPointReport]? = nil
                if let accessPointsContainer = accessPointsContainer {
                    accessPointsBuffer = [S3ControlClientTypes.MultiRegionAccessPointReport]()
                    for structureContainer0 in accessPointsContainer {
                        accessPointsBuffer?.append(structureContainer0)
                    }
                }
                accessPoints = accessPointsBuffer
            } else {
                accessPoints = []
            }
        } else {
            accessPoints = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListMultiRegionAccessPointsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListRegionalBucketsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        if let outpostId = outpostId {
            items.add(Header(name: "x-amz-outpost-id", value: Swift.String(outpostId)))
        }
        return items
    }
}

extension ListRegionalBucketsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListRegionalBucketsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/bucket"
    }
}

public struct ListRegionalBucketsInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    ///
    public var maxResults: Swift.Int?
    ///
    public var nextToken: Swift.String?
    /// The ID of the Outposts resource. This ID is required by Amazon S3 on Outposts buckets.
    public var outpostId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        outpostId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.outpostId = outpostId
    }
}

extension ListRegionalBucketsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRegionalBucketsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.regionalBucketList = output.regionalBucketList
        } else {
            self.nextToken = nil
            self.regionalBucketList = nil
        }
    }
}

public struct ListRegionalBucketsOutput: Swift.Equatable {
    /// NextToken is sent when isTruncated is true, which means there are more buckets that can be listed. The next list requests to Amazon S3 can be continued with this NextToken. NextToken is obfuscated and is not a real key.
    public var nextToken: Swift.String?
    ///
    public var regionalBucketList: [S3ControlClientTypes.RegionalBucket]?

    public init(
        nextToken: Swift.String? = nil,
        regionalBucketList: [S3ControlClientTypes.RegionalBucket]? = nil
    )
    {
        self.nextToken = nextToken
        self.regionalBucketList = regionalBucketList
    }
}

struct ListRegionalBucketsOutputBody: Swift.Equatable {
    let regionalBucketList: [S3ControlClientTypes.RegionalBucket]?
    let nextToken: Swift.String?
}

extension ListRegionalBucketsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case regionalBucketList = "RegionalBucketList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.regionalBucketList) {
            struct KeyVal0{struct RegionalBucket{}}
            let regionalBucketListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.RegionalBucket>.CodingKeys.self, forKey: .regionalBucketList)
            if let regionalBucketListWrappedContainer = regionalBucketListWrappedContainer {
                let regionalBucketListContainer = try regionalBucketListWrappedContainer.decodeIfPresent([S3ControlClientTypes.RegionalBucket].self, forKey: .member)
                var regionalBucketListBuffer:[S3ControlClientTypes.RegionalBucket]? = nil
                if let regionalBucketListContainer = regionalBucketListContainer {
                    regionalBucketListBuffer = [S3ControlClientTypes.RegionalBucket]()
                    for structureContainer0 in regionalBucketListContainer {
                        regionalBucketListBuffer?.append(structureContainer0)
                    }
                }
                regionalBucketList = regionalBucketListBuffer
            } else {
                regionalBucketList = []
            }
        } else {
            regionalBucketList = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRegionalBucketsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension S3ControlClientTypes.ListStorageLensConfigurationEntry: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case homeRegion = "HomeRegion"
        case id = "Id"
        case isEnabled = "IsEnabled"
        case storageLensArn = "StorageLensArn"
    }

    static func writingClosure(_ value: S3ControlClientTypes.ListStorageLensConfigurationEntry?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("HomeRegion")].write(value.homeRegion)
        try writer[.init("Id")].write(value.id)
        try writer[.init("IsEnabled")].write(value.isEnabled)
        try writer[.init("StorageLensArn")].write(value.storageLensArn)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let storageLensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageLensArn)
        storageLensArn = storageLensArnDecoded
        let homeRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
        let isEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isEnabled) ?? false
        isEnabled = isEnabledDecoded
    }
}

extension S3ControlClientTypes {
    /// Part of ListStorageLensConfigurationResult. Each entry includes the description of the S3 Storage Lens configuration, its home Region, whether it is enabled, its Amazon Resource Name (ARN), and config ID.
    public struct ListStorageLensConfigurationEntry: Swift.Equatable {
        /// A container for the S3 Storage Lens home Region. Your metrics data is stored and retained in your designated S3 Storage Lens home Region.
        /// This member is required.
        public var homeRegion: Swift.String?
        /// A container for the S3 Storage Lens configuration ID.
        /// This member is required.
        public var id: Swift.String?
        /// A container for whether the S3 Storage Lens configuration is enabled. This property is required.
        public var isEnabled: Swift.Bool
        /// The ARN of the S3 Storage Lens configuration. This property is read-only.
        /// This member is required.
        public var storageLensArn: Swift.String?

        public init(
            homeRegion: Swift.String? = nil,
            id: Swift.String? = nil,
            isEnabled: Swift.Bool = false,
            storageLensArn: Swift.String? = nil
        )
        {
            self.homeRegion = homeRegion
            self.id = id
            self.isEnabled = isEnabled
            self.storageLensArn = storageLensArn
        }
    }

}

extension ListStorageLensConfigurationsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension ListStorageLensConfigurationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListStorageLensConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/storagelens"
    }
}

public struct ListStorageLensConfigurationsInput: Swift.Equatable {
    /// The account ID of the requester.
    /// This member is required.
    public var accountId: Swift.String?
    /// A pagination token to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.nextToken = nextToken
    }
}

extension ListStorageLensConfigurationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListStorageLensConfigurationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.storageLensConfigurationList = output.storageLensConfigurationList
        } else {
            self.nextToken = nil
            self.storageLensConfigurationList = nil
        }
    }
}

public struct ListStorageLensConfigurationsOutput: Swift.Equatable {
    /// If the request produced more than the maximum number of S3 Storage Lens configuration results, you can pass this value into a subsequent request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// A list of S3 Storage Lens configurations.
    public var storageLensConfigurationList: [S3ControlClientTypes.ListStorageLensConfigurationEntry]?

    public init(
        nextToken: Swift.String? = nil,
        storageLensConfigurationList: [S3ControlClientTypes.ListStorageLensConfigurationEntry]? = nil
    )
    {
        self.nextToken = nextToken
        self.storageLensConfigurationList = storageLensConfigurationList
    }
}

struct ListStorageLensConfigurationsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let storageLensConfigurationList: [S3ControlClientTypes.ListStorageLensConfigurationEntry]?
}

extension ListStorageLensConfigurationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case storageLensConfigurationList = "StorageLensConfigurationList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        if containerValues.contains(.storageLensConfigurationList) {
            let storageLensConfigurationListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .storageLensConfigurationList)
            if storageLensConfigurationListWrappedContainer != nil {
                let storageLensConfigurationListContainer = try containerValues.decodeIfPresent([S3ControlClientTypes.ListStorageLensConfigurationEntry].self, forKey: .storageLensConfigurationList)
                var storageLensConfigurationListBuffer:[S3ControlClientTypes.ListStorageLensConfigurationEntry]? = nil
                if let storageLensConfigurationListContainer = storageLensConfigurationListContainer {
                    storageLensConfigurationListBuffer = [S3ControlClientTypes.ListStorageLensConfigurationEntry]()
                    for structureContainer0 in storageLensConfigurationListContainer {
                        storageLensConfigurationListBuffer?.append(structureContainer0)
                    }
                }
                storageLensConfigurationList = storageLensConfigurationListBuffer
            } else {
                storageLensConfigurationList = []
            }
        } else {
            storageLensConfigurationList = nil
        }
    }
}

enum ListStorageLensConfigurationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension S3ControlClientTypes.ListStorageLensGroupEntry: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case homeRegion = "HomeRegion"
        case name = "Name"
        case storageLensGroupArn = "StorageLensGroupArn"
    }

    static func writingClosure(_ value: S3ControlClientTypes.ListStorageLensGroupEntry?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("HomeRegion")].write(value.homeRegion)
        try writer[.init("Name")].write(value.name)
        try writer[.init("StorageLensGroupArn")].write(value.storageLensGroupArn)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let storageLensGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageLensGroupArn)
        storageLensGroupArn = storageLensGroupArnDecoded
        let homeRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
    }
}

extension S3ControlClientTypes {
    /// Each entry contains a Storage Lens group that exists in the specified home Region.
    public struct ListStorageLensGroupEntry: Swift.Equatable {
        /// Contains the Amazon Web Services Region where the Storage Lens group was created.
        /// This member is required.
        public var homeRegion: Swift.String?
        /// Contains the name of the Storage Lens group that exists in the specified home Region.
        /// This member is required.
        public var name: Swift.String?
        /// Contains the Amazon Resource Name (ARN) of the Storage Lens group. This property is read-only.
        /// This member is required.
        public var storageLensGroupArn: Swift.String?

        public init(
            homeRegion: Swift.String? = nil,
            name: Swift.String? = nil,
            storageLensGroupArn: Swift.String? = nil
        )
        {
            self.homeRegion = homeRegion
            self.name = name
            self.storageLensGroupArn = storageLensGroupArn
        }
    }

}

extension ListStorageLensGroupsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension ListStorageLensGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListStorageLensGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/storagelensgroup"
    }
}

public struct ListStorageLensGroupsInput: Swift.Equatable {
    /// The Amazon Web Services account ID that owns the Storage Lens groups.
    /// This member is required.
    public var accountId: Swift.String?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.nextToken = nextToken
    }
}

extension ListStorageLensGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListStorageLensGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.storageLensGroupList = output.storageLensGroupList
        } else {
            self.nextToken = nil
            self.storageLensGroupList = nil
        }
    }
}

public struct ListStorageLensGroupsOutput: Swift.Equatable {
    /// If NextToken is returned, there are more Storage Lens groups results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?
    /// The list of Storage Lens groups that exist in the specified home Region.
    public var storageLensGroupList: [S3ControlClientTypes.ListStorageLensGroupEntry]?

    public init(
        nextToken: Swift.String? = nil,
        storageLensGroupList: [S3ControlClientTypes.ListStorageLensGroupEntry]? = nil
    )
    {
        self.nextToken = nextToken
        self.storageLensGroupList = storageLensGroupList
    }
}

struct ListStorageLensGroupsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let storageLensGroupList: [S3ControlClientTypes.ListStorageLensGroupEntry]?
}

extension ListStorageLensGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case storageLensGroupList = "StorageLensGroupList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        if containerValues.contains(.storageLensGroupList) {
            let storageLensGroupListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .storageLensGroupList)
            if storageLensGroupListWrappedContainer != nil {
                let storageLensGroupListContainer = try containerValues.decodeIfPresent([S3ControlClientTypes.ListStorageLensGroupEntry].self, forKey: .storageLensGroupList)
                var storageLensGroupListBuffer:[S3ControlClientTypes.ListStorageLensGroupEntry]? = nil
                if let storageLensGroupListContainer = storageLensGroupListContainer {
                    storageLensGroupListBuffer = [S3ControlClientTypes.ListStorageLensGroupEntry]()
                    for structureContainer0 in storageLensGroupListContainer {
                        storageLensGroupListBuffer?.append(structureContainer0)
                    }
                }
                storageLensGroupList = storageLensGroupListBuffer
            } else {
                storageLensGroupList = []
            }
        } else {
            storageLensGroupList = nil
        }
    }
}

enum ListStorageLensGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/v20180820/tags/\(resourceArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the resource owner.
    /// This member is required.
    public var accountId: Swift.String?
    /// The Amazon Resource Name (ARN) of the S3 resource that you want to list the tags for. The tagged resource can be an S3 Storage Lens group or S3 Access Grants instance, registered location, or grant.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.resourceArn = resourceArn
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The Amazon Web Services resource tags that are associated with the resource.
    public var tags: [S3ControlClientTypes.Tag]?

    public init(
        tags: [S3ControlClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [S3ControlClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([S3ControlClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[S3ControlClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [S3ControlClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension S3ControlClientTypes {
    public enum MFADelete: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [MFADelete] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MFADelete(rawValue: rawValue) ?? MFADelete.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum MFADeleteStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [MFADeleteStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MFADeleteStatus(rawValue: rawValue) ?? MFADeleteStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.MatchObjectAge: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case daysGreaterThan = "DaysGreaterThan"
        case daysLessThan = "DaysLessThan"
    }

    static func writingClosure(_ value: S3ControlClientTypes.MatchObjectAge?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("DaysGreaterThan")].write(value.daysGreaterThan)
        try writer[.init("DaysLessThan")].write(value.daysLessThan)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let daysGreaterThanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .daysGreaterThan) ?? 0
        daysGreaterThan = daysGreaterThanDecoded
        let daysLessThanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .daysLessThan) ?? 0
        daysLessThan = daysLessThanDecoded
    }
}

extension S3ControlClientTypes {
    /// A filter condition that specifies the object age range of included objects in days. Only integers are supported.
    public struct MatchObjectAge: Swift.Equatable {
        /// Specifies the maximum object age in days. Must be a positive whole number, greater than the minimum object age and less than or equal to 2,147,483,647.
        public var daysGreaterThan: Swift.Int
        /// Specifies the minimum object age in days. The value must be a positive whole number, greater than 0 and less than or equal to 2,147,483,647.
        public var daysLessThan: Swift.Int

        public init(
            daysGreaterThan: Swift.Int = 0,
            daysLessThan: Swift.Int = 0
        )
        {
            self.daysGreaterThan = daysGreaterThan
            self.daysLessThan = daysLessThan
        }
    }

}

extension S3ControlClientTypes.MatchObjectSize: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bytesGreaterThan = "BytesGreaterThan"
        case bytesLessThan = "BytesLessThan"
    }

    static func writingClosure(_ value: S3ControlClientTypes.MatchObjectSize?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("BytesGreaterThan")].write(value.bytesGreaterThan)
        try writer[.init("BytesLessThan")].write(value.bytesLessThan)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bytesGreaterThanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bytesGreaterThan) ?? 0
        bytesGreaterThan = bytesGreaterThanDecoded
        let bytesLessThanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bytesLessThan) ?? 0
        bytesLessThan = bytesLessThanDecoded
    }
}

extension S3ControlClientTypes {
    /// A filter condition that specifies the object size range of included objects in bytes. Only integers are supported.
    public struct MatchObjectSize: Swift.Equatable {
        /// Specifies the minimum object size in Bytes. The value must be a positive number, greater than 0 and less than 5 TB.
        public var bytesGreaterThan: Swift.Int
        /// Specifies the maximum object size in Bytes. The value must be a positive number, greater than the minimum object size and less than 5 TB.
        public var bytesLessThan: Swift.Int

        public init(
            bytesGreaterThan: Swift.Int = 0,
            bytesLessThan: Swift.Int = 0
        )
        {
            self.bytesGreaterThan = bytesGreaterThan
            self.bytesLessThan = bytesLessThan
        }
    }

}

extension S3ControlClientTypes.Metrics: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventThreshold = "EventThreshold"
        case status = "Status"
    }

    static func writingClosure(_ value: S3ControlClientTypes.Metrics?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("EventThreshold")].write(value.eventThreshold, writingClosure: S3ControlClientTypes.ReplicationTimeValue.writingClosure(_:to:))
        try writer[.init("Status")].write(value.status)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.MetricsStatus.self, forKey: .status)
        status = statusDecoded
        let eventThresholdDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ReplicationTimeValue.self, forKey: .eventThreshold)
        eventThreshold = eventThresholdDecoded
    }
}

extension S3ControlClientTypes {
    /// A container that specifies replication metrics-related settings.
    public struct Metrics: Swift.Equatable {
        /// A container that specifies the time threshold for emitting the s3:Replication:OperationMissedThreshold event. This is not supported by Amazon S3 on Outposts buckets.
        public var eventThreshold: S3ControlClientTypes.ReplicationTimeValue?
        /// Specifies whether replication metrics are enabled.
        /// This member is required.
        public var status: S3ControlClientTypes.MetricsStatus?

        public init(
            eventThreshold: S3ControlClientTypes.ReplicationTimeValue? = nil,
            status: S3ControlClientTypes.MetricsStatus? = nil
        )
        {
            self.eventThreshold = eventThreshold
            self.status = status
        }
    }

}

extension S3ControlClientTypes {
    public enum MetricsStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [MetricsStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MetricsStatus(rawValue: rawValue) ?? MetricsStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.MultiRegionAccessPointPolicyDocument: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case established = "Established"
        case proposed = "Proposed"
    }

    static func writingClosure(_ value: S3ControlClientTypes.MultiRegionAccessPointPolicyDocument?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Established")].write(value.established, writingClosure: S3ControlClientTypes.EstablishedMultiRegionAccessPointPolicy.writingClosure(_:to:))
        try writer[.init("Proposed")].write(value.proposed, writingClosure: S3ControlClientTypes.ProposedMultiRegionAccessPointPolicy.writingClosure(_:to:))
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let establishedDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.EstablishedMultiRegionAccessPointPolicy.self, forKey: .established)
        established = establishedDecoded
        let proposedDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ProposedMultiRegionAccessPointPolicy.self, forKey: .proposed)
        proposed = proposedDecoded
    }
}

extension S3ControlClientTypes {
    /// The Multi-Region Access Point access control policy. When you update the policy, the update is first listed as the proposed policy. After the update is finished and all Regions have been updated, the proposed policy is listed as the established policy. If both policies have the same version number, the proposed policy is the established policy.
    public struct MultiRegionAccessPointPolicyDocument: Swift.Equatable {
        /// The last established policy for the Multi-Region Access Point.
        public var established: S3ControlClientTypes.EstablishedMultiRegionAccessPointPolicy?
        /// The proposed policy for the Multi-Region Access Point.
        public var proposed: S3ControlClientTypes.ProposedMultiRegionAccessPointPolicy?

        public init(
            established: S3ControlClientTypes.EstablishedMultiRegionAccessPointPolicy? = nil,
            proposed: S3ControlClientTypes.ProposedMultiRegionAccessPointPolicy? = nil
        )
        {
            self.established = established
            self.proposed = proposed
        }
    }

}

extension S3ControlClientTypes.MultiRegionAccessPointRegionalResponse: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case requestStatus = "RequestStatus"
    }

    static func writingClosure(_ value: S3ControlClientTypes.MultiRegionAccessPointRegionalResponse?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Name")].write(value.name)
        try writer[.init("RequestStatus")].write(value.requestStatus)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let requestStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestStatus)
        requestStatus = requestStatusDecoded
    }
}

extension S3ControlClientTypes {
    /// Status information for a single Multi-Region Access Point Region.
    public struct MultiRegionAccessPointRegionalResponse: Swift.Equatable {
        /// The name of the Region in the Multi-Region Access Point.
        public var name: Swift.String?
        /// The current status of the Multi-Region Access Point in this Region.
        public var requestStatus: Swift.String?

        public init(
            name: Swift.String? = nil,
            requestStatus: Swift.String? = nil
        )
        {
            self.name = name
            self.requestStatus = requestStatus
        }
    }

}

extension S3ControlClientTypes.MultiRegionAccessPointReport: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case createdAt = "CreatedAt"
        case name = "Name"
        case publicAccessBlock = "PublicAccessBlock"
        case regions = "Regions"
        case status = "Status"
    }

    static func writingClosure(_ value: S3ControlClientTypes.MultiRegionAccessPointReport?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Alias")].write(value.alias)
        try writer[.init("CreatedAt")].writeTimestamp(value.createdAt, format: .dateTime)
        try writer[.init("Name")].write(value.name)
        try writer[.init("PublicAccessBlock")].write(value.publicAccessBlock, writingClosure: S3ControlClientTypes.PublicAccessBlockConfiguration.writingClosure(_:to:))
        try writer[.init("Regions")].writeList(value.regions, memberWritingClosure: S3ControlClientTypes.RegionReport.writingClosure(_:to:), memberNodeInfo: .init("Region"), isFlattened: false)
        try writer[.init("Status")].write(value.status)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let publicAccessBlockDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.PublicAccessBlockConfiguration.self, forKey: .publicAccessBlock)
        publicAccessBlock = publicAccessBlockDecoded
        let statusDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.MultiRegionAccessPointStatus.self, forKey: .status)
        status = statusDecoded
        if containerValues.contains(.regions) {
            struct KeyVal0{struct Region{}}
            let regionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Region>.CodingKeys.self, forKey: .regions)
            if let regionsWrappedContainer = regionsWrappedContainer {
                let regionsContainer = try regionsWrappedContainer.decodeIfPresent([S3ControlClientTypes.RegionReport].self, forKey: .member)
                var regionsBuffer:[S3ControlClientTypes.RegionReport]? = nil
                if let regionsContainer = regionsContainer {
                    regionsBuffer = [S3ControlClientTypes.RegionReport]()
                    for structureContainer0 in regionsContainer {
                        regionsBuffer?.append(structureContainer0)
                    }
                }
                regions = regionsBuffer
            } else {
                regions = []
            }
        } else {
            regions = nil
        }
    }
}

extension S3ControlClientTypes {
    /// A collection of statuses for a Multi-Region Access Point in the various Regions it supports.
    public struct MultiRegionAccessPointReport: Swift.Equatable {
        /// The alias for the Multi-Region Access Point. For more information about the distinction between the name and the alias of an Multi-Region Access Point, see [Managing Multi-Region Access Points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/CreatingMultiRegionAccessPoints.html#multi-region-access-point-naming).
        public var alias: Swift.String?
        /// When the Multi-Region Access Point create request was received.
        public var createdAt: ClientRuntime.Date?
        /// The name of the Multi-Region Access Point.
        public var name: Swift.String?
        /// The PublicAccessBlock configuration that you want to apply to this Amazon S3 account. You can enable the configuration options in any combination. For more information about when Amazon S3 considers a bucket or object public, see [The Meaning of "Public"](https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status) in the Amazon S3 User Guide. This data type is not supported for Amazon S3 on Outposts.
        public var publicAccessBlock: S3ControlClientTypes.PublicAccessBlockConfiguration?
        /// A collection of the Regions and buckets associated with the Multi-Region Access Point.
        public var regions: [S3ControlClientTypes.RegionReport]?
        /// The current status of the Multi-Region Access Point. CREATING and DELETING are temporary states that exist while the request is propagating and being completed. If a Multi-Region Access Point has a status of PARTIALLY_CREATED, you can retry creation or send a request to delete the Multi-Region Access Point. If a Multi-Region Access Point has a status of PARTIALLY_DELETED, you can retry a delete request to finish the deletion of the Multi-Region Access Point.
        public var status: S3ControlClientTypes.MultiRegionAccessPointStatus?

        public init(
            alias: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            publicAccessBlock: S3ControlClientTypes.PublicAccessBlockConfiguration? = nil,
            regions: [S3ControlClientTypes.RegionReport]? = nil,
            status: S3ControlClientTypes.MultiRegionAccessPointStatus? = nil
        )
        {
            self.alias = alias
            self.createdAt = createdAt
            self.name = name
            self.publicAccessBlock = publicAccessBlock
            self.regions = regions
            self.status = status
        }
    }

}

extension S3ControlClientTypes.MultiRegionAccessPointRoute: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case region = "Region"
        case trafficDialPercentage = "TrafficDialPercentage"
    }

    static func writingClosure(_ value: S3ControlClientTypes.MultiRegionAccessPointRoute?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Bucket")].write(value.bucket)
        try writer[.init("Region")].write(value.region)
        try writer[.init("TrafficDialPercentage")].write(value.trafficDialPercentage)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let trafficDialPercentageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .trafficDialPercentage)
        trafficDialPercentage = trafficDialPercentageDecoded
    }
}

extension S3ControlClientTypes {
    /// A structure for a Multi-Region Access Point that indicates where Amazon S3 traffic can be routed. Routes can be either active or passive. Active routes can process Amazon S3 requests through the Multi-Region Access Point, but passive routes are not eligible to process Amazon S3 requests. Each route contains the Amazon S3 bucket name and the Amazon Web Services Region that the bucket is located in. The route also includes the TrafficDialPercentage value, which shows whether the bucket and Region are active (indicated by a value of 100) or passive (indicated by a value of 0).
    public struct MultiRegionAccessPointRoute: Swift.Equatable {
        /// The name of the Amazon S3 bucket for which you'll submit a routing configuration change. Either the Bucket or the Region value must be provided. If both are provided, the bucket must be in the specified Region.
        public var bucket: Swift.String?
        /// The Amazon Web Services Region to which you'll be submitting a routing configuration change. Either the Bucket or the Region value must be provided. If both are provided, the bucket must be in the specified Region.
        public var region: Swift.String?
        /// The traffic state for the specified bucket or Amazon Web Services Region. A value of 0 indicates a passive state, which means that no new traffic will be routed to the Region. A value of 100 indicates an active state, which means that traffic will be routed to the specified Region. When the routing configuration for a Region is changed from active to passive, any in-progress operations (uploads, copies, deletes, and so on) to the formerly active Region will continue to run to until a final success or failure status is reached. If all Regions in the routing configuration are designated as passive, you'll receive an InvalidRequest error.
        /// This member is required.
        public var trafficDialPercentage: Swift.Int?

        public init(
            bucket: Swift.String? = nil,
            region: Swift.String? = nil,
            trafficDialPercentage: Swift.Int? = nil
        )
        {
            self.bucket = bucket
            self.region = region
            self.trafficDialPercentage = trafficDialPercentage
        }
    }

}

extension S3ControlClientTypes {
    public enum MultiRegionAccessPointStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case creating
        case deleting
        case inconsistentAcrossRegions
        case partiallyCreated
        case partiallyDeleted
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [MultiRegionAccessPointStatus] {
            return [
                .creating,
                .deleting,
                .inconsistentAcrossRegions,
                .partiallyCreated,
                .partiallyDeleted,
                .ready,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .inconsistentAcrossRegions: return "INCONSISTENT_ACROSS_REGIONS"
            case .partiallyCreated: return "PARTIALLY_CREATED"
            case .partiallyDeleted: return "PARTIALLY_DELETED"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MultiRegionAccessPointStatus(rawValue: rawValue) ?? MultiRegionAccessPointStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.MultiRegionAccessPointsAsyncResponse: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case regions = "Regions"
    }

    static func writingClosure(_ value: S3ControlClientTypes.MultiRegionAccessPointsAsyncResponse?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Regions")].writeList(value.regions, memberWritingClosure: S3ControlClientTypes.MultiRegionAccessPointRegionalResponse.writingClosure(_:to:), memberNodeInfo: .init("Region"), isFlattened: false)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.regions) {
            struct KeyVal0{struct Region{}}
            let regionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Region>.CodingKeys.self, forKey: .regions)
            if let regionsWrappedContainer = regionsWrappedContainer {
                let regionsContainer = try regionsWrappedContainer.decodeIfPresent([S3ControlClientTypes.MultiRegionAccessPointRegionalResponse].self, forKey: .member)
                var regionsBuffer:[S3ControlClientTypes.MultiRegionAccessPointRegionalResponse]? = nil
                if let regionsContainer = regionsContainer {
                    regionsBuffer = [S3ControlClientTypes.MultiRegionAccessPointRegionalResponse]()
                    for structureContainer0 in regionsContainer {
                        regionsBuffer?.append(structureContainer0)
                    }
                }
                regions = regionsBuffer
            } else {
                regions = []
            }
        } else {
            regions = nil
        }
    }
}

extension S3ControlClientTypes {
    /// The Multi-Region Access Point details that are returned when querying about an asynchronous request.
    public struct MultiRegionAccessPointsAsyncResponse: Swift.Equatable {
        /// A collection of status information for the different Regions that a Multi-Region Access Point supports.
        public var regions: [S3ControlClientTypes.MultiRegionAccessPointRegionalResponse]?

        public init(
            regions: [S3ControlClientTypes.MultiRegionAccessPointRegionalResponse]? = nil
        )
        {
            self.regions = regions
        }
    }

}

extension S3ControlClientTypes {
    public enum NetworkOrigin: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internet
        case vpc
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkOrigin] {
            return [
                .internet,
                .vpc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internet: return "Internet"
            case .vpc: return "VPC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NetworkOrigin(rawValue: rawValue) ?? NetworkOrigin.sdkUnknown(rawValue)
        }
    }
}

extension NoSuchPublicAccessBlockConfiguration {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchPublicAccessBlockConfigurationBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Amazon S3 throws this exception if you make a GetPublicAccessBlock request against an account that doesn't have a PublicAccessBlockConfiguration set.
public struct NoSuchPublicAccessBlockConfiguration: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchPublicAccessBlockConfiguration" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NoSuchPublicAccessBlockConfigurationBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchPublicAccessBlockConfigurationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension S3ControlClientTypes.NoncurrentVersionExpiration: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case newerNoncurrentVersions = "NewerNoncurrentVersions"
        case noncurrentDays = "NoncurrentDays"
    }

    static func writingClosure(_ value: S3ControlClientTypes.NoncurrentVersionExpiration?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("NewerNoncurrentVersions")].write(value.newerNoncurrentVersions)
        try writer[.init("NoncurrentDays")].write(value.noncurrentDays)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let noncurrentDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .noncurrentDays) ?? 0
        noncurrentDays = noncurrentDaysDecoded
        let newerNoncurrentVersionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .newerNoncurrentVersions) ?? nil
        newerNoncurrentVersions = newerNoncurrentVersionsDecoded
    }
}

extension S3ControlClientTypes {
    /// The container of the noncurrent version expiration.
    public struct NoncurrentVersionExpiration: Swift.Equatable {
        /// Specifies how many noncurrent versions S3 on Outposts will retain. If there are this many more recent noncurrent versions, S3 on Outposts will take the associated action. For more information about noncurrent versions, see [Lifecycle configuration elements](https://docs.aws.amazon.com/AmazonS3/latest/userguide/intro-lifecycle-rules.html) in the Amazon S3 User Guide.
        public var newerNoncurrentVersions: Swift.Int?
        /// Specifies the number of days an object is noncurrent before Amazon S3 can perform the associated action. For information about the noncurrent days calculations, see [How Amazon S3 Calculates When an Object Became Noncurrent](https://docs.aws.amazon.com/AmazonS3/latest/dev/intro-lifecycle-rules.html#non-current-days-calculations) in the Amazon S3 User Guide.
        public var noncurrentDays: Swift.Int

        public init(
            newerNoncurrentVersions: Swift.Int? = nil,
            noncurrentDays: Swift.Int = 0
        )
        {
            self.newerNoncurrentVersions = newerNoncurrentVersions
            self.noncurrentDays = noncurrentDays
        }
    }

}

extension S3ControlClientTypes.NoncurrentVersionTransition: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case noncurrentDays = "NoncurrentDays"
        case storageClass = "StorageClass"
    }

    static func writingClosure(_ value: S3ControlClientTypes.NoncurrentVersionTransition?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("NoncurrentDays")].write(value.noncurrentDays)
        try writer[.init("StorageClass")].write(value.storageClass)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let noncurrentDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .noncurrentDays) ?? 0
        noncurrentDays = noncurrentDaysDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.TransitionStorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
    }
}

extension S3ControlClientTypes {
    /// The container for the noncurrent version transition.
    public struct NoncurrentVersionTransition: Swift.Equatable {
        /// Specifies the number of days an object is noncurrent before Amazon S3 can perform the associated action. For information about the noncurrent days calculations, see [ How Amazon S3 Calculates How Long an Object Has Been Noncurrent](https://docs.aws.amazon.com/AmazonS3/latest/dev/intro-lifecycle-rules.html#non-current-days-calculations) in the Amazon S3 User Guide.
        public var noncurrentDays: Swift.Int
        /// The class of storage used to store the object.
        public var storageClass: S3ControlClientTypes.TransitionStorageClass?

        public init(
            noncurrentDays: Swift.Int = 0,
            storageClass: S3ControlClientTypes.TransitionStorageClass? = nil
        )
        {
            self.noncurrentDays = noncurrentDays
            self.storageClass = storageClass
        }
    }

}

extension NotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<NotFoundExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension S3ControlClientTypes.ObjectLambdaAccessPoint: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case name = "Name"
        case objectLambdaAccessPointArn = "ObjectLambdaAccessPointArn"
    }

    static func writingClosure(_ value: S3ControlClientTypes.ObjectLambdaAccessPoint?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Alias")].write(value.alias, writingClosure: S3ControlClientTypes.ObjectLambdaAccessPointAlias.writingClosure(_:to:))
        try writer[.init("Name")].write(value.name)
        try writer[.init("ObjectLambdaAccessPointArn")].write(value.objectLambdaAccessPointArn)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let objectLambdaAccessPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectLambdaAccessPointArn)
        objectLambdaAccessPointArn = objectLambdaAccessPointArnDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ObjectLambdaAccessPointAlias.self, forKey: .alias)
        alias = aliasDecoded
    }
}

extension S3ControlClientTypes {
    /// An access point with an attached Lambda function used to access transformed data from an Amazon S3 bucket.
    public struct ObjectLambdaAccessPoint: Swift.Equatable {
        /// The alias of the Object Lambda Access Point.
        public var alias: S3ControlClientTypes.ObjectLambdaAccessPointAlias?
        /// The name of the Object Lambda Access Point.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies the ARN for the Object Lambda Access Point.
        public var objectLambdaAccessPointArn: Swift.String?

        public init(
            alias: S3ControlClientTypes.ObjectLambdaAccessPointAlias? = nil,
            name: Swift.String? = nil,
            objectLambdaAccessPointArn: Swift.String? = nil
        )
        {
            self.alias = alias
            self.name = name
            self.objectLambdaAccessPointArn = objectLambdaAccessPointArn
        }
    }

}

extension S3ControlClientTypes.ObjectLambdaAccessPointAlias: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
        case value = "Value"
    }

    static func writingClosure(_ value: S3ControlClientTypes.ObjectLambdaAccessPointAlias?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Status")].write(value.status)
        try writer[.init("Value")].write(value.value)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let statusDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ObjectLambdaAccessPointAliasStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension S3ControlClientTypes {
    /// The alias of an Object Lambda Access Point. For more information, see [How to use a bucket-style alias for your S3 bucket Object Lambda Access Point](https://docs.aws.amazon.com/AmazonS3/latest/userguide/olap-use.html#ol-access-points-alias).
    public struct ObjectLambdaAccessPointAlias: Swift.Equatable {
        /// The status of the Object Lambda Access Point alias. If the status is PROVISIONING, the Object Lambda Access Point is provisioning the alias and the alias is not ready for use yet. If the status is READY, the Object Lambda Access Point alias is successfully provisioned and ready for use.
        public var status: S3ControlClientTypes.ObjectLambdaAccessPointAliasStatus?
        /// The alias value of the Object Lambda Access Point.
        public var value: Swift.String?

        public init(
            status: S3ControlClientTypes.ObjectLambdaAccessPointAliasStatus? = nil,
            value: Swift.String? = nil
        )
        {
            self.status = status
            self.value = value
        }
    }

}

extension S3ControlClientTypes {
    public enum ObjectLambdaAccessPointAliasStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case provisioning
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [ObjectLambdaAccessPointAliasStatus] {
            return [
                .provisioning,
                .ready,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .provisioning: return "PROVISIONING"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ObjectLambdaAccessPointAliasStatus(rawValue: rawValue) ?? ObjectLambdaAccessPointAliasStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum ObjectLambdaAllowedFeature: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case getobjectpartnumber
        case getobjectrange
        case headobjectpartnumber
        case headobjectrange
        case sdkUnknown(Swift.String)

        public static var allCases: [ObjectLambdaAllowedFeature] {
            return [
                .getobjectpartnumber,
                .getobjectrange,
                .headobjectpartnumber,
                .headobjectrange,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .getobjectpartnumber: return "GetObject-PartNumber"
            case .getobjectrange: return "GetObject-Range"
            case .headobjectpartnumber: return "HeadObject-PartNumber"
            case .headobjectrange: return "HeadObject-Range"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ObjectLambdaAllowedFeature(rawValue: rawValue) ?? ObjectLambdaAllowedFeature.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.ObjectLambdaConfiguration: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedFeatures = "AllowedFeatures"
        case cloudWatchMetricsEnabled = "CloudWatchMetricsEnabled"
        case supportingAccessPoint = "SupportingAccessPoint"
        case transformationConfigurations = "TransformationConfigurations"
    }

    static func writingClosure(_ value: S3ControlClientTypes.ObjectLambdaConfiguration?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("AllowedFeatures")].writeList(value.allowedFeatures, memberWritingClosure: S3ControlClientTypes.ObjectLambdaAllowedFeature.writingClosure(_:to:), memberNodeInfo: .init("AllowedFeature"), isFlattened: false)
        try writer[.init("CloudWatchMetricsEnabled")].write(value.cloudWatchMetricsEnabled)
        try writer[.init("SupportingAccessPoint")].write(value.supportingAccessPoint)
        try writer[.init("TransformationConfigurations")].writeList(value.transformationConfigurations, memberWritingClosure: S3ControlClientTypes.ObjectLambdaTransformationConfiguration.writingClosure(_:to:), memberNodeInfo: .init("TransformationConfiguration"), isFlattened: false)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let supportingAccessPointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supportingAccessPoint)
        supportingAccessPoint = supportingAccessPointDecoded
        let cloudWatchMetricsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cloudWatchMetricsEnabled) ?? false
        cloudWatchMetricsEnabled = cloudWatchMetricsEnabledDecoded
        if containerValues.contains(.allowedFeatures) {
            struct KeyVal0{struct AllowedFeature{}}
            let allowedFeaturesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AllowedFeature>.CodingKeys.self, forKey: .allowedFeatures)
            if let allowedFeaturesWrappedContainer = allowedFeaturesWrappedContainer {
                let allowedFeaturesContainer = try allowedFeaturesWrappedContainer.decodeIfPresent([S3ControlClientTypes.ObjectLambdaAllowedFeature].self, forKey: .member)
                var allowedFeaturesBuffer:[S3ControlClientTypes.ObjectLambdaAllowedFeature]? = nil
                if let allowedFeaturesContainer = allowedFeaturesContainer {
                    allowedFeaturesBuffer = [S3ControlClientTypes.ObjectLambdaAllowedFeature]()
                    for enumContainer0 in allowedFeaturesContainer {
                        allowedFeaturesBuffer?.append(enumContainer0)
                    }
                }
                allowedFeatures = allowedFeaturesBuffer
            } else {
                allowedFeatures = []
            }
        } else {
            allowedFeatures = nil
        }
        if containerValues.contains(.transformationConfigurations) {
            struct KeyVal0{struct TransformationConfiguration{}}
            let transformationConfigurationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.TransformationConfiguration>.CodingKeys.self, forKey: .transformationConfigurations)
            if let transformationConfigurationsWrappedContainer = transformationConfigurationsWrappedContainer {
                let transformationConfigurationsContainer = try transformationConfigurationsWrappedContainer.decodeIfPresent([S3ControlClientTypes.ObjectLambdaTransformationConfiguration].self, forKey: .member)
                var transformationConfigurationsBuffer:[S3ControlClientTypes.ObjectLambdaTransformationConfiguration]? = nil
                if let transformationConfigurationsContainer = transformationConfigurationsContainer {
                    transformationConfigurationsBuffer = [S3ControlClientTypes.ObjectLambdaTransformationConfiguration]()
                    for structureContainer0 in transformationConfigurationsContainer {
                        transformationConfigurationsBuffer?.append(structureContainer0)
                    }
                }
                transformationConfigurations = transformationConfigurationsBuffer
            } else {
                transformationConfigurations = []
            }
        } else {
            transformationConfigurations = nil
        }
    }
}

extension S3ControlClientTypes {
    /// A configuration used when creating an Object Lambda Access Point.
    public struct ObjectLambdaConfiguration: Swift.Equatable {
        /// A container for allowed features. Valid inputs are GetObject-Range, GetObject-PartNumber, HeadObject-Range, and HeadObject-PartNumber.
        public var allowedFeatures: [S3ControlClientTypes.ObjectLambdaAllowedFeature]?
        /// A container for whether the CloudWatch metrics configuration is enabled.
        public var cloudWatchMetricsEnabled: Swift.Bool
        /// Standard access point associated with the Object Lambda Access Point.
        /// This member is required.
        public var supportingAccessPoint: Swift.String?
        /// A container for transformation configurations for an Object Lambda Access Point.
        /// This member is required.
        public var transformationConfigurations: [S3ControlClientTypes.ObjectLambdaTransformationConfiguration]?

        public init(
            allowedFeatures: [S3ControlClientTypes.ObjectLambdaAllowedFeature]? = nil,
            cloudWatchMetricsEnabled: Swift.Bool = false,
            supportingAccessPoint: Swift.String? = nil,
            transformationConfigurations: [S3ControlClientTypes.ObjectLambdaTransformationConfiguration]? = nil
        )
        {
            self.allowedFeatures = allowedFeatures
            self.cloudWatchMetricsEnabled = cloudWatchMetricsEnabled
            self.supportingAccessPoint = supportingAccessPoint
            self.transformationConfigurations = transformationConfigurations
        }
    }

}

extension S3ControlClientTypes.ObjectLambdaContentTransformation: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awslambda = "AwsLambda"
        case sdkUnknown
    }

    static func writingClosure(_ value: S3ControlClientTypes.ObjectLambdaContentTransformation?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        switch value {
            case let .awslambda(awslambda):
                try writer[.init("AwsLambda")].write(awslambda, writingClosure: S3ControlClientTypes.AwsLambdaTransformation.writingClosure(_:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer[.init("sdkUnknown")].write(sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let key = containerValues.allKeys.first
        switch key {
            case .awslambda:
                let awslambdaDecoded = try containerValues.decode(S3ControlClientTypes.AwsLambdaTransformation.self, forKey: .awslambda)
                self = .awslambda(awslambdaDecoded)
            default:
                self = .sdkUnknown("")
        }
    }
}

extension S3ControlClientTypes {
    /// A container for AwsLambdaTransformation.
    public enum ObjectLambdaContentTransformation: Swift.Equatable {
        /// A container for an Lambda function.
        case awslambda(S3ControlClientTypes.AwsLambdaTransformation)
        case sdkUnknown(Swift.String)
    }

}

extension S3ControlClientTypes.ObjectLambdaTransformationConfiguration: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case contentTransformation = "ContentTransformation"
    }

    static func writingClosure(_ value: S3ControlClientTypes.ObjectLambdaTransformationConfiguration?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Actions")].writeList(value.actions, memberWritingClosure: S3ControlClientTypes.ObjectLambdaTransformationConfigurationAction.writingClosure(_:to:), memberNodeInfo: .init("Action"), isFlattened: false)
        try writer[.init("ContentTransformation")].write(value.contentTransformation, writingClosure: S3ControlClientTypes.ObjectLambdaContentTransformation.writingClosure(_:to:))
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.actions) {
            struct KeyVal0{struct Action{}}
            let actionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Action>.CodingKeys.self, forKey: .actions)
            if let actionsWrappedContainer = actionsWrappedContainer {
                let actionsContainer = try actionsWrappedContainer.decodeIfPresent([S3ControlClientTypes.ObjectLambdaTransformationConfigurationAction].self, forKey: .member)
                var actionsBuffer:[S3ControlClientTypes.ObjectLambdaTransformationConfigurationAction]? = nil
                if let actionsContainer = actionsContainer {
                    actionsBuffer = [S3ControlClientTypes.ObjectLambdaTransformationConfigurationAction]()
                    for enumContainer0 in actionsContainer {
                        actionsBuffer?.append(enumContainer0)
                    }
                }
                actions = actionsBuffer
            } else {
                actions = []
            }
        } else {
            actions = nil
        }
        let contentTransformationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ObjectLambdaContentTransformation.self, forKey: .contentTransformation)
        contentTransformation = contentTransformationDecoded
    }
}

extension S3ControlClientTypes {
    /// A configuration used when creating an Object Lambda Access Point transformation.
    public struct ObjectLambdaTransformationConfiguration: Swift.Equatable {
        /// A container for the action of an Object Lambda Access Point configuration. Valid inputs are GetObject, ListObjects, HeadObject, and ListObjectsV2.
        /// This member is required.
        public var actions: [S3ControlClientTypes.ObjectLambdaTransformationConfigurationAction]?
        /// A container for the content transformation of an Object Lambda Access Point configuration.
        /// This member is required.
        public var contentTransformation: S3ControlClientTypes.ObjectLambdaContentTransformation?

        public init(
            actions: [S3ControlClientTypes.ObjectLambdaTransformationConfigurationAction]? = nil,
            contentTransformation: S3ControlClientTypes.ObjectLambdaContentTransformation? = nil
        )
        {
            self.actions = actions
            self.contentTransformation = contentTransformation
        }
    }

}

extension S3ControlClientTypes {
    public enum ObjectLambdaTransformationConfigurationAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case getobject
        case headobject
        case listobjects
        case listobjectsv2
        case sdkUnknown(Swift.String)

        public static var allCases: [ObjectLambdaTransformationConfigurationAction] {
            return [
                .getobject,
                .headobject,
                .listobjects,
                .listobjectsv2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .getobject: return "GetObject"
            case .headobject: return "HeadObject"
            case .listobjects: return "ListObjects"
            case .listobjectsv2: return "ListObjectsV2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ObjectLambdaTransformationConfigurationAction(rawValue: rawValue) ?? ObjectLambdaTransformationConfigurationAction.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum OperationName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lambdainvoke
        case s3deleteobjecttagging
        case s3initiaterestoreobject
        case s3putobjectacl
        case s3putobjectcopy
        case s3putobjectlegalhold
        case s3putobjectretention
        case s3putobjecttagging
        case s3replicateobject
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationName] {
            return [
                .lambdainvoke,
                .s3deleteobjecttagging,
                .s3initiaterestoreobject,
                .s3putobjectacl,
                .s3putobjectcopy,
                .s3putobjectlegalhold,
                .s3putobjectretention,
                .s3putobjecttagging,
                .s3replicateobject,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lambdainvoke: return "LambdaInvoke"
            case .s3deleteobjecttagging: return "S3DeleteObjectTagging"
            case .s3initiaterestoreobject: return "S3InitiateRestoreObject"
            case .s3putobjectacl: return "S3PutObjectAcl"
            case .s3putobjectcopy: return "S3PutObjectCopy"
            case .s3putobjectlegalhold: return "S3PutObjectLegalHold"
            case .s3putobjectretention: return "S3PutObjectRetention"
            case .s3putobjecttagging: return "S3PutObjectTagging"
            case .s3replicateobject: return "S3ReplicateObject"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperationName(rawValue: rawValue) ?? OperationName.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum OutputSchemaVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case v1
        case sdkUnknown(Swift.String)

        public static var allCases: [OutputSchemaVersion] {
            return [
                .v1,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .v1: return "V_1"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OutputSchemaVersion(rawValue: rawValue) ?? OutputSchemaVersion.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum OwnerOverride: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case destination
        case sdkUnknown(Swift.String)

        public static var allCases: [OwnerOverride] {
            return [
                .destination,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .destination: return "Destination"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OwnerOverride(rawValue: rawValue) ?? OwnerOverride.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum Permission: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case read
        case readwrite
        case write
        case sdkUnknown(Swift.String)

        public static var allCases: [Permission] {
            return [
                .read,
                .readwrite,
                .write,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .read: return "READ"
            case .readwrite: return "READWRITE"
            case .write: return "WRITE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Permission(rawValue: rawValue) ?? Permission.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.PolicyStatus: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isPublic = "IsPublic"
    }

    static func writingClosure(_ value: S3ControlClientTypes.PolicyStatus?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("IsPublic")].write(value.isPublic)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isPublicDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isPublic) ?? false
        isPublic = isPublicDecoded
    }
}

extension S3ControlClientTypes {
    /// Indicates whether this access point policy is public. For more information about how Amazon S3 evaluates policies to determine whether they are public, see [The Meaning of "Public"](https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status) in the Amazon S3 User Guide.
    public struct PolicyStatus: Swift.Equatable {
        ///
        public var isPublic: Swift.Bool

        public init(
            isPublic: Swift.Bool = false
        )
        {
            self.isPublic = isPublic
        }
    }

}

extension S3ControlClientTypes.PrefixLevel: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case storageMetrics = "StorageMetrics"
    }

    static func writingClosure(_ value: S3ControlClientTypes.PrefixLevel?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("StorageMetrics")].write(value.storageMetrics, writingClosure: S3ControlClientTypes.PrefixLevelStorageMetrics.writingClosure(_:to:))
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageMetricsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.PrefixLevelStorageMetrics.self, forKey: .storageMetrics)
        storageMetrics = storageMetricsDecoded
    }
}

extension S3ControlClientTypes {
    /// A container for the prefix-level configuration.
    public struct PrefixLevel: Swift.Equatable {
        /// A container for the prefix-level storage metrics for S3 Storage Lens.
        /// This member is required.
        public var storageMetrics: S3ControlClientTypes.PrefixLevelStorageMetrics?

        public init(
            storageMetrics: S3ControlClientTypes.PrefixLevelStorageMetrics? = nil
        )
        {
            self.storageMetrics = storageMetrics
        }
    }

}

extension S3ControlClientTypes.PrefixLevelStorageMetrics: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isEnabled = "IsEnabled"
        case selectionCriteria = "SelectionCriteria"
    }

    static func writingClosure(_ value: S3ControlClientTypes.PrefixLevelStorageMetrics?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("IsEnabled")].write(value.isEnabled)
        try writer[.init("SelectionCriteria")].write(value.selectionCriteria, writingClosure: S3ControlClientTypes.SelectionCriteria.writingClosure(_:to:))
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isEnabled) ?? false
        isEnabled = isEnabledDecoded
        let selectionCriteriaDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.SelectionCriteria.self, forKey: .selectionCriteria)
        selectionCriteria = selectionCriteriaDecoded
    }
}

extension S3ControlClientTypes {
    /// A container for the prefix-level storage metrics for S3 Storage Lens.
    public struct PrefixLevelStorageMetrics: Swift.Equatable {
        /// A container for whether prefix-level storage metrics are enabled.
        public var isEnabled: Swift.Bool
        ///
        public var selectionCriteria: S3ControlClientTypes.SelectionCriteria?

        public init(
            isEnabled: Swift.Bool = false,
            selectionCriteria: S3ControlClientTypes.SelectionCriteria? = nil
        )
        {
            self.isEnabled = isEnabled
            self.selectionCriteria = selectionCriteria
        }
    }

}

extension S3ControlClientTypes {
    public enum Privilege: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `default`
        case minimal
        case sdkUnknown(Swift.String)

        public static var allCases: [Privilege] {
            return [
                .default,
                .minimal,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .default: return "Default"
            case .minimal: return "Minimal"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Privilege(rawValue: rawValue) ?? Privilege.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.ProposedMultiRegionAccessPointPolicy: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    static func writingClosure(_ value: S3ControlClientTypes.ProposedMultiRegionAccessPointPolicy?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Policy")].write(value.policy)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension S3ControlClientTypes {
    /// The proposed access control policy for the Multi-Region Access Point. When you update the policy, the update is first listed as the proposed policy. After the update is finished and all Regions have been updated, the proposed policy is listed as the established policy. If both policies have the same version number, the proposed policy is the established policy.
    public struct ProposedMultiRegionAccessPointPolicy: Swift.Equatable {
        /// The details of the proposed policy.
        public var policy: Swift.String?

        public init(
            policy: Swift.String? = nil
        )
        {
            self.policy = policy
        }
    }

}

extension S3ControlClientTypes.PublicAccessBlockConfiguration: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockPublicAcls = "BlockPublicAcls"
        case blockPublicPolicy = "BlockPublicPolicy"
        case ignorePublicAcls = "IgnorePublicAcls"
        case restrictPublicBuckets = "RestrictPublicBuckets"
    }

    static func writingClosure(_ value: S3ControlClientTypes.PublicAccessBlockConfiguration?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("BlockPublicAcls")].write(value.blockPublicAcls)
        try writer[.init("BlockPublicPolicy")].write(value.blockPublicPolicy)
        try writer[.init("IgnorePublicAcls")].write(value.ignorePublicAcls)
        try writer[.init("RestrictPublicBuckets")].write(value.restrictPublicBuckets)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockPublicAclsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .blockPublicAcls) ?? false
        blockPublicAcls = blockPublicAclsDecoded
        let ignorePublicAclsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ignorePublicAcls) ?? false
        ignorePublicAcls = ignorePublicAclsDecoded
        let blockPublicPolicyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .blockPublicPolicy) ?? false
        blockPublicPolicy = blockPublicPolicyDecoded
        let restrictPublicBucketsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .restrictPublicBuckets) ?? false
        restrictPublicBuckets = restrictPublicBucketsDecoded
    }
}

extension S3ControlClientTypes {
    /// The PublicAccessBlock configuration that you want to apply to this Amazon S3 account. You can enable the configuration options in any combination. For more information about when Amazon S3 considers a bucket or object public, see [The Meaning of "Public"](https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status) in the Amazon S3 User Guide. This data type is not supported for Amazon S3 on Outposts.
    public struct PublicAccessBlockConfiguration: Swift.Equatable {
        /// Specifies whether Amazon S3 should block public access control lists (ACLs) for buckets in this account. Setting this element to TRUE causes the following behavior:
        ///
        /// * PutBucketAcl and PutObjectAcl calls fail if the specified ACL is public.
        ///
        /// * PUT Object calls fail if the request includes a public ACL.
        ///
        /// * PUT Bucket calls fail if the request includes a public ACL.
        ///
        ///
        /// Enabling this setting doesn't affect existing policies or ACLs. This property is not supported for Amazon S3 on Outposts.
        public var blockPublicAcls: Swift.Bool
        /// Specifies whether Amazon S3 should block public bucket policies for buckets in this account. Setting this element to TRUE causes Amazon S3 to reject calls to PUT Bucket policy if the specified bucket policy allows public access. Enabling this setting doesn't affect existing bucket policies. This property is not supported for Amazon S3 on Outposts.
        public var blockPublicPolicy: Swift.Bool
        /// Specifies whether Amazon S3 should ignore public ACLs for buckets in this account. Setting this element to TRUE causes Amazon S3 to ignore all public ACLs on buckets in this account and any objects that they contain. Enabling this setting doesn't affect the persistence of any existing ACLs and doesn't prevent new public ACLs from being set. This property is not supported for Amazon S3 on Outposts.
        public var ignorePublicAcls: Swift.Bool
        /// Specifies whether Amazon S3 should restrict public bucket policies for buckets in this account. Setting this element to TRUE restricts access to buckets with public policies to only Amazon Web Service principals and authorized users within this account. Enabling this setting doesn't affect previously stored bucket policies, except that public and cross-account access within any public bucket policy, including non-public delegation to specific accounts, is blocked. This property is not supported for Amazon S3 on Outposts.
        public var restrictPublicBuckets: Swift.Bool

        public init(
            blockPublicAcls: Swift.Bool = false,
            blockPublicPolicy: Swift.Bool = false,
            ignorePublicAcls: Swift.Bool = false,
            restrictPublicBuckets: Swift.Bool = false
        )
        {
            self.blockPublicAcls = blockPublicAcls
            self.blockPublicPolicy = blockPublicPolicy
            self.ignorePublicAcls = ignorePublicAcls
            self.restrictPublicBuckets = restrictPublicBuckets
        }
    }

}

extension PutAccessGrantsInstanceResourcePolicyInput {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organization = "Organization"
        case policy = "Policy"
    }

    static func writingClosure(_ value: PutAccessGrantsInstanceResourcePolicyInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Organization")].write(value.organization)
        try writer[.init("Policy")].write(value.policy)
    }
}

extension PutAccessGrantsInstanceResourcePolicyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension PutAccessGrantsInstanceResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/accessgrantsinstance/resourcepolicy"
    }
}

public struct PutAccessGrantsInstanceResourcePolicyInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that is making this request.
    /// This member is required.
    public var accountId: Swift.String?
    /// The Organization of the resource policy of the S3 Access Grants instance.
    public var organization: Swift.String?
    /// The resource policy of the S3 Access Grants instance that you are updating.
    /// This member is required.
    public var policy: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        organization: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.organization = organization
        self.policy = policy
    }
}

struct PutAccessGrantsInstanceResourcePolicyInputBody: Swift.Equatable {
    let policy: Swift.String?
    let organization: Swift.String?
}

extension PutAccessGrantsInstanceResourcePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organization = "Organization"
        case policy = "Policy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let organizationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organization)
        organization = organizationDecoded
    }
}

extension PutAccessGrantsInstanceResourcePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutAccessGrantsInstanceResourcePolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.organization = output.organization
            self.policy = output.policy
        } else {
            self.createdAt = nil
            self.organization = nil
            self.policy = nil
        }
    }
}

public struct PutAccessGrantsInstanceResourcePolicyOutput: Swift.Equatable {
    /// The date and time when you created the S3 Access Grants instance resource policy.
    public var createdAt: ClientRuntime.Date?
    /// The Organization of the resource policy of the S3 Access Grants instance.
    public var organization: Swift.String?
    /// The updated resource policy of the S3 Access Grants instance.
    public var policy: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        organization: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.organization = organization
        self.policy = policy
    }
}

struct PutAccessGrantsInstanceResourcePolicyOutputBody: Swift.Equatable {
    let policy: Swift.String?
    let organization: Swift.String?
    let createdAt: ClientRuntime.Date?
}

extension PutAccessGrantsInstanceResourcePolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case organization = "Organization"
        case policy = "Policy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let organizationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organization)
        organization = organizationDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

enum PutAccessGrantsInstanceResourcePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension PutAccessPointConfigurationForObjectLambdaInput {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
    }

    static func writingClosure(_ value: PutAccessPointConfigurationForObjectLambdaInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Configuration")].write(value.configuration, writingClosure: S3ControlClientTypes.ObjectLambdaConfiguration.writingClosure(_:to:))
    }
}

extension PutAccessPointConfigurationForObjectLambdaInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension PutAccessPointConfigurationForObjectLambdaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v20180820/accesspointforobjectlambda/\(name.urlPercentEncoding())/configuration"
    }
}

public struct PutAccessPointConfigurationForObjectLambdaInput: Swift.Equatable {
    /// The account ID for the account that owns the specified Object Lambda Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// Object Lambda Access Point configuration document.
    /// This member is required.
    public var configuration: S3ControlClientTypes.ObjectLambdaConfiguration?
    /// The name of the Object Lambda Access Point.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        configuration: S3ControlClientTypes.ObjectLambdaConfiguration? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.configuration = configuration
        self.name = name
    }
}

struct PutAccessPointConfigurationForObjectLambdaInputBody: Swift.Equatable {
    let configuration: S3ControlClientTypes.ObjectLambdaConfiguration?
}

extension PutAccessPointConfigurationForObjectLambdaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ObjectLambdaConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension PutAccessPointConfigurationForObjectLambdaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutAccessPointConfigurationForObjectLambdaOutput: Swift.Equatable {

    public init() { }
}

enum PutAccessPointConfigurationForObjectLambdaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension PutAccessPointPolicyForObjectLambdaInput {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    static func writingClosure(_ value: PutAccessPointPolicyForObjectLambdaInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Policy")].write(value.policy)
    }
}

extension PutAccessPointPolicyForObjectLambdaInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension PutAccessPointPolicyForObjectLambdaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v20180820/accesspointforobjectlambda/\(name.urlPercentEncoding())/policy"
    }
}

public struct PutAccessPointPolicyForObjectLambdaInput: Swift.Equatable {
    /// The account ID for the account that owns the specified Object Lambda Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the Object Lambda Access Point.
    /// This member is required.
    public var name: Swift.String?
    /// Object Lambda Access Point resource policy document.
    /// This member is required.
    public var policy: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
        self.policy = policy
    }
}

struct PutAccessPointPolicyForObjectLambdaInputBody: Swift.Equatable {
    let policy: Swift.String?
}

extension PutAccessPointPolicyForObjectLambdaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutAccessPointPolicyForObjectLambdaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutAccessPointPolicyForObjectLambdaOutput: Swift.Equatable {

    public init() { }
}

enum PutAccessPointPolicyForObjectLambdaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension PutAccessPointPolicyInput {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    static func writingClosure(_ value: PutAccessPointPolicyInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Policy")].write(value.policy)
    }
}

extension PutAccessPointPolicyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension PutAccessPointPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v20180820/accesspoint/\(name.urlPercentEncoding())/policy"
    }
}

public struct PutAccessPointPolicyInput: Swift.Equatable {
    /// The Amazon Web Services account ID for owner of the bucket associated with the specified access point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the access point that you want to associate with the specified policy. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the access point accessed in the format arn:aws:s3-outposts:::outpost//accesspoint/. For example, to access the access point reports-ap through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/accesspoint/reports-ap. The value must be URL encoded.
    /// This member is required.
    public var name: Swift.String?
    /// The policy that you want to apply to the specified access point. For more information about access point policies, see [Managing data access with Amazon S3 access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-points.html) in the Amazon S3 User Guide.
    /// This member is required.
    public var policy: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
        self.policy = policy
    }
}

struct PutAccessPointPolicyInputBody: Swift.Equatable {
    let policy: Swift.String?
}

extension PutAccessPointPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutAccessPointPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutAccessPointPolicyOutput: Swift.Equatable {

    public init() { }
}

enum PutAccessPointPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension PutBucketLifecycleConfigurationInput {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecycleConfiguration = "LifecycleConfiguration"
    }

    static func writingClosure(_ value: PutBucketLifecycleConfigurationInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("LifecycleConfiguration")].write(value.lifecycleConfiguration, writingClosure: S3ControlClientTypes.LifecycleConfiguration.writingClosure(_:to:))
    }
}

extension PutBucketLifecycleConfigurationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension PutBucketLifecycleConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/lifecycleconfiguration"
    }
}

public struct PutBucketLifecycleConfigurationInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the bucket for which to set the configuration.
    /// This member is required.
    public var bucket: Swift.String?
    /// Container for lifecycle rules. You can add as many as 1,000 rules.
    public var lifecycleConfiguration: S3ControlClientTypes.LifecycleConfiguration?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil,
        lifecycleConfiguration: S3ControlClientTypes.LifecycleConfiguration? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
        self.lifecycleConfiguration = lifecycleConfiguration
    }
}

struct PutBucketLifecycleConfigurationInputBody: Swift.Equatable {
    let lifecycleConfiguration: S3ControlClientTypes.LifecycleConfiguration?
}

extension PutBucketLifecycleConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecycleConfiguration = "LifecycleConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecycleConfigurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.LifecycleConfiguration.self, forKey: .lifecycleConfiguration)
        lifecycleConfiguration = lifecycleConfigurationDecoded
    }
}

extension PutBucketLifecycleConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutBucketLifecycleConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum PutBucketLifecycleConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension PutBucketPolicyInput {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    static func writingClosure(_ value: PutBucketPolicyInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Policy")].write(value.policy)
    }
}

extension PutBucketPolicyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        if let confirmRemoveSelfBucketAccess = confirmRemoveSelfBucketAccess {
            items.add(Header(name: "x-amz-confirm-remove-self-bucket-access", value: Swift.String(confirmRemoveSelfBucketAccess)))
        }
        return items
    }
}

extension PutBucketPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/policy"
    }
}

public struct PutBucketPolicyInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    /// Specifies the bucket. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?
    /// Set this parameter to true to confirm that you want to remove your permissions to change this bucket policy in the future. This is not supported by Amazon S3 on Outposts buckets.
    public var confirmRemoveSelfBucketAccess: Swift.Bool?
    /// The bucket policy as a JSON document.
    /// This member is required.
    public var policy: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil,
        confirmRemoveSelfBucketAccess: Swift.Bool? = nil,
        policy: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
        self.confirmRemoveSelfBucketAccess = confirmRemoveSelfBucketAccess
        self.policy = policy
    }
}

struct PutBucketPolicyInputBody: Swift.Equatable {
    let policy: Swift.String?
}

extension PutBucketPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutBucketPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutBucketPolicyOutput: Swift.Equatable {

    public init() { }
}

enum PutBucketPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension PutBucketReplicationInput {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationConfiguration = "ReplicationConfiguration"
    }

    static func writingClosure(_ value: PutBucketReplicationInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("ReplicationConfiguration")].write(value.replicationConfiguration, writingClosure: S3ControlClientTypes.ReplicationConfiguration.writingClosure(_:to:))
    }
}

extension PutBucketReplicationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension PutBucketReplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/replication"
    }
}

public struct PutBucketReplicationInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    /// Specifies the S3 on Outposts bucket to set the configuration for. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?
    ///
    /// This member is required.
    public var replicationConfiguration: S3ControlClientTypes.ReplicationConfiguration?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil,
        replicationConfiguration: S3ControlClientTypes.ReplicationConfiguration? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
        self.replicationConfiguration = replicationConfiguration
    }
}

struct PutBucketReplicationInputBody: Swift.Equatable {
    let replicationConfiguration: S3ControlClientTypes.ReplicationConfiguration?
}

extension PutBucketReplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationConfiguration = "ReplicationConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ReplicationConfiguration.self, forKey: .replicationConfiguration)
        replicationConfiguration = replicationConfigurationDecoded
    }
}

extension PutBucketReplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutBucketReplicationOutput: Swift.Equatable {

    public init() { }
}

enum PutBucketReplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension PutBucketTaggingInput {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagging = "Tagging"
    }

    static func writingClosure(_ value: PutBucketTaggingInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Tagging")].write(value.tagging, writingClosure: S3ControlClientTypes.Tagging.writingClosure(_:to:))
    }
}

extension PutBucketTaggingInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension PutBucketTaggingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/tagging"
    }
}

public struct PutBucketTaggingInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    /// The Amazon Resource Name (ARN) of the bucket. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?
    ///
    /// This member is required.
    public var tagging: S3ControlClientTypes.Tagging?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil,
        tagging: S3ControlClientTypes.Tagging? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
        self.tagging = tagging
    }
}

struct PutBucketTaggingInputBody: Swift.Equatable {
    let tagging: S3ControlClientTypes.Tagging?
}

extension PutBucketTaggingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagging = "Tagging"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taggingDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.Tagging.self, forKey: .tagging)
        tagging = taggingDecoded
    }
}

extension PutBucketTaggingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutBucketTaggingOutput: Swift.Equatable {

    public init() { }
}

enum PutBucketTaggingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension PutBucketVersioningInput {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case versioningConfiguration = "VersioningConfiguration"
    }

    static func writingClosure(_ value: PutBucketVersioningInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("VersioningConfiguration")].write(value.versioningConfiguration, writingClosure: S3ControlClientTypes.VersioningConfiguration.writingClosure(_:to:))
    }
}

extension PutBucketVersioningInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        if let mfa = mfa {
            items.add(Header(name: "x-amz-mfa", value: Swift.String(mfa)))
        }
        return items
    }
}

extension PutBucketVersioningInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/versioning"
    }
}

public struct PutBucketVersioningInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the S3 on Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    /// The S3 on Outposts bucket to set the versioning state for.
    /// This member is required.
    public var bucket: Swift.String?
    /// The concatenation of the authentication device's serial number, a space, and the value that is displayed on your authentication device.
    public var mfa: Swift.String?
    /// The root-level tag for the VersioningConfiguration parameters.
    /// This member is required.
    public var versioningConfiguration: S3ControlClientTypes.VersioningConfiguration?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil,
        mfa: Swift.String? = nil,
        versioningConfiguration: S3ControlClientTypes.VersioningConfiguration? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
        self.mfa = mfa
        self.versioningConfiguration = versioningConfiguration
    }
}

struct PutBucketVersioningInputBody: Swift.Equatable {
    let versioningConfiguration: S3ControlClientTypes.VersioningConfiguration?
}

extension PutBucketVersioningInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case versioningConfiguration = "VersioningConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versioningConfigurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.VersioningConfiguration.self, forKey: .versioningConfiguration)
        versioningConfiguration = versioningConfigurationDecoded
    }
}

extension PutBucketVersioningOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutBucketVersioningOutput: Swift.Equatable {

    public init() { }
}

enum PutBucketVersioningOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension PutJobTaggingInput {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    static func writingClosure(_ value: PutJobTaggingInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Tags")].writeList(value.tags, memberWritingClosure: S3ControlClientTypes.S3Tag.writingClosure(_:to:), memberNodeInfo: .init("member"), isFlattened: false)
    }
}

extension PutJobTaggingInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension PutJobTaggingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/v20180820/jobs/\(jobId.urlPercentEncoding())/tagging"
    }
}

public struct PutJobTaggingInput: Swift.Equatable {
    /// The Amazon Web Services account ID associated with the S3 Batch Operations job.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID for the S3 Batch Operations job whose tags you want to replace.
    /// This member is required.
    public var jobId: Swift.String?
    /// The set of tags to associate with the S3 Batch Operations job.
    /// This member is required.
    public var tags: [S3ControlClientTypes.S3Tag]?

    public init(
        accountId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        tags: [S3ControlClientTypes.S3Tag]? = nil
    )
    {
        self.accountId = accountId
        self.jobId = jobId
        self.tags = tags
    }
}

struct PutJobTaggingInputBody: Swift.Equatable {
    let tags: [S3ControlClientTypes.S3Tag]?
}

extension PutJobTaggingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([S3ControlClientTypes.S3Tag].self, forKey: .member)
                var tagsBuffer:[S3ControlClientTypes.S3Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [S3ControlClientTypes.S3Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension PutJobTaggingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutJobTaggingOutput: Swift.Equatable {

    public init() { }
}

enum PutJobTaggingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension S3ControlClientTypes.PutMultiRegionAccessPointPolicyInput: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case policy = "Policy"
    }

    static func writingClosure(_ value: S3ControlClientTypes.PutMultiRegionAccessPointPolicyInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Name")].write(value.name)
        try writer[.init("Policy")].write(value.policy)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutMultiRegionAccessPointPolicyInput {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case details = "Details"
    }

    static func writingClosure(_ value: PutMultiRegionAccessPointPolicyInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("ClientToken")].write(value.clientToken)
        try writer[.init("Details")].write(value.details, writingClosure: S3ControlClientTypes.PutMultiRegionAccessPointPolicyInput.writingClosure(_:to:))
    }
}

extension PutMultiRegionAccessPointPolicyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension PutMultiRegionAccessPointPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/async-requests/mrap/put-policy"
    }
}

public struct PutMultiRegionAccessPointPolicyInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the owner of the Multi-Region Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// An idempotency token used to identify the request and guarantee that requests are unique.
    /// This member is required.
    public var clientToken: Swift.String?
    /// A container element containing the details of the policy for the Multi-Region Access Point.
    /// This member is required.
    public var details: S3ControlClientTypes.PutMultiRegionAccessPointPolicyInput?

    public init(
        accountId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        details: S3ControlClientTypes.PutMultiRegionAccessPointPolicyInput? = nil
    )
    {
        self.accountId = accountId
        self.clientToken = clientToken
        self.details = details
    }
}

extension S3ControlClientTypes {
    /// A container for the information associated with a [PutMultiRegionAccessPoint](https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_PutMultiRegionAccessPoint.html) request.
    public struct PutMultiRegionAccessPointPolicyInput: Swift.Equatable {
        /// The name of the Multi-Region Access Point associated with the request.
        /// This member is required.
        public var name: Swift.String?
        /// The policy details for the PutMultiRegionAccessPoint request.
        /// This member is required.
        public var policy: Swift.String?

        public init(
            name: Swift.String? = nil,
            policy: Swift.String? = nil
        )
        {
            self.name = name
            self.policy = policy
        }
    }

}

struct PutMultiRegionAccessPointPolicyInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let details: S3ControlClientTypes.PutMultiRegionAccessPointPolicyInput?
}

extension PutMultiRegionAccessPointPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case details = "Details"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.PutMultiRegionAccessPointPolicyInput.self, forKey: .details)
        details = detailsDecoded
    }
}

extension PutMultiRegionAccessPointPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutMultiRegionAccessPointPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.requestTokenARN = output.requestTokenARN
        } else {
            self.requestTokenARN = nil
        }
    }
}

public struct PutMultiRegionAccessPointPolicyOutput: Swift.Equatable {
    /// The request token associated with the request. You can use this token with [DescribeMultiRegionAccessPointOperation](https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_DescribeMultiRegionAccessPointOperation.html) to determine the status of asynchronous requests.
    public var requestTokenARN: Swift.String?

    public init(
        requestTokenARN: Swift.String? = nil
    )
    {
        self.requestTokenARN = requestTokenARN
    }
}

struct PutMultiRegionAccessPointPolicyOutputBody: Swift.Equatable {
    let requestTokenARN: Swift.String?
}

extension PutMultiRegionAccessPointPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestTokenARN = "RequestTokenARN"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestTokenARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestTokenARN)
        requestTokenARN = requestTokenARNDecoded
    }
}

enum PutMultiRegionAccessPointPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension PutPublicAccessBlockInput {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
    }

    static func writingClosure(_ value: PutPublicAccessBlockInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("PublicAccessBlockConfiguration")].write(value.publicAccessBlockConfiguration, writingClosure: S3ControlClientTypes.PublicAccessBlockConfiguration.writingClosure(_:to:))
    }
}

extension PutPublicAccessBlockInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension PutPublicAccessBlockInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/configuration/publicAccessBlock"
    }
}

public struct PutPublicAccessBlockInput: Swift.Equatable {
    /// The account ID for the Amazon Web Services account whose PublicAccessBlock configuration you want to set.
    /// This member is required.
    public var accountId: Swift.String?
    /// The PublicAccessBlock configuration that you want to apply to the specified Amazon Web Services account.
    /// This member is required.
    public var publicAccessBlockConfiguration: S3ControlClientTypes.PublicAccessBlockConfiguration?

    public init(
        accountId: Swift.String? = nil,
        publicAccessBlockConfiguration: S3ControlClientTypes.PublicAccessBlockConfiguration? = nil
    )
    {
        self.accountId = accountId
        self.publicAccessBlockConfiguration = publicAccessBlockConfiguration
    }
}

struct PutPublicAccessBlockInputBody: Swift.Equatable {
    let publicAccessBlockConfiguration: S3ControlClientTypes.PublicAccessBlockConfiguration?
}

extension PutPublicAccessBlockInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicAccessBlockConfigurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.PublicAccessBlockConfiguration.self, forKey: .publicAccessBlockConfiguration)
        publicAccessBlockConfiguration = publicAccessBlockConfigurationDecoded
    }
}

extension PutPublicAccessBlockOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutPublicAccessBlockOutput: Swift.Equatable {

    public init() { }
}

enum PutPublicAccessBlockOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension PutStorageLensConfigurationInput {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case storageLensConfiguration = "StorageLensConfiguration"
        case tags = "Tags"
    }

    static func writingClosure(_ value: PutStorageLensConfigurationInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("StorageLensConfiguration")].write(value.storageLensConfiguration, writingClosure: S3ControlClientTypes.StorageLensConfiguration.writingClosure(_:to:))
        try writer[.init("Tags")].writeList(value.tags, memberWritingClosure: S3ControlClientTypes.StorageLensTag.writingClosure(_:to:), memberNodeInfo: .init("Tag"), isFlattened: false)
    }
}

extension PutStorageLensConfigurationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension PutStorageLensConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configId = configId else {
            return nil
        }
        return "/v20180820/storagelens/\(configId.urlPercentEncoding())"
    }
}

public struct PutStorageLensConfigurationInput: Swift.Equatable {
    /// The account ID of the requester.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID of the S3 Storage Lens configuration.
    /// This member is required.
    public var configId: Swift.String?
    /// The S3 Storage Lens configuration.
    /// This member is required.
    public var storageLensConfiguration: S3ControlClientTypes.StorageLensConfiguration?
    /// The tag set of the S3 Storage Lens configuration. You can set up to a maximum of 50 tags.
    public var tags: [S3ControlClientTypes.StorageLensTag]?

    public init(
        accountId: Swift.String? = nil,
        configId: Swift.String? = nil,
        storageLensConfiguration: S3ControlClientTypes.StorageLensConfiguration? = nil,
        tags: [S3ControlClientTypes.StorageLensTag]? = nil
    )
    {
        self.accountId = accountId
        self.configId = configId
        self.storageLensConfiguration = storageLensConfiguration
        self.tags = tags
    }
}

struct PutStorageLensConfigurationInputBody: Swift.Equatable {
    let storageLensConfiguration: S3ControlClientTypes.StorageLensConfiguration?
    let tags: [S3ControlClientTypes.StorageLensTag]?
}

extension PutStorageLensConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case storageLensConfiguration = "StorageLensConfiguration"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageLensConfigurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.StorageLensConfiguration.self, forKey: .storageLensConfiguration)
        storageLensConfiguration = storageLensConfigurationDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([S3ControlClientTypes.StorageLensTag].self, forKey: .member)
                var tagsBuffer:[S3ControlClientTypes.StorageLensTag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [S3ControlClientTypes.StorageLensTag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension PutStorageLensConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutStorageLensConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum PutStorageLensConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension PutStorageLensConfigurationTaggingInput {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    static func writingClosure(_ value: PutStorageLensConfigurationTaggingInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Tags")].writeList(value.tags, memberWritingClosure: S3ControlClientTypes.StorageLensTag.writingClosure(_:to:), memberNodeInfo: .init("Tag"), isFlattened: false)
    }
}

extension PutStorageLensConfigurationTaggingInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension PutStorageLensConfigurationTaggingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configId = configId else {
            return nil
        }
        return "/v20180820/storagelens/\(configId.urlPercentEncoding())/tagging"
    }
}

public struct PutStorageLensConfigurationTaggingInput: Swift.Equatable {
    /// The account ID of the requester.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID of the S3 Storage Lens configuration.
    /// This member is required.
    public var configId: Swift.String?
    /// The tag set of the S3 Storage Lens configuration. You can set up to a maximum of 50 tags.
    /// This member is required.
    public var tags: [S3ControlClientTypes.StorageLensTag]?

    public init(
        accountId: Swift.String? = nil,
        configId: Swift.String? = nil,
        tags: [S3ControlClientTypes.StorageLensTag]? = nil
    )
    {
        self.accountId = accountId
        self.configId = configId
        self.tags = tags
    }
}

struct PutStorageLensConfigurationTaggingInputBody: Swift.Equatable {
    let tags: [S3ControlClientTypes.StorageLensTag]?
}

extension PutStorageLensConfigurationTaggingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([S3ControlClientTypes.StorageLensTag].self, forKey: .member)
                var tagsBuffer:[S3ControlClientTypes.StorageLensTag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [S3ControlClientTypes.StorageLensTag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension PutStorageLensConfigurationTaggingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutStorageLensConfigurationTaggingOutput: Swift.Equatable {

    public init() { }
}

enum PutStorageLensConfigurationTaggingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension S3ControlClientTypes.Region: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case bucketAccountId = "BucketAccountId"
    }

    static func writingClosure(_ value: S3ControlClientTypes.Region?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Bucket")].write(value.bucket)
        try writer[.init("BucketAccountId")].write(value.bucketAccountId)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let bucketAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketAccountId)
        bucketAccountId = bucketAccountIdDecoded
    }
}

extension S3ControlClientTypes {
    /// A Region that supports a Multi-Region Access Point as well as the associated bucket for the Region.
    public struct Region: Swift.Equatable {
        /// The name of the associated bucket for the Region.
        /// This member is required.
        public var bucket: Swift.String?
        /// The Amazon Web Services account ID that owns the Amazon S3 bucket that's associated with this Multi-Region Access Point.
        public var bucketAccountId: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            bucketAccountId: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.bucketAccountId = bucketAccountId
        }
    }

}

extension S3ControlClientTypes.RegionReport: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case bucketAccountId = "BucketAccountId"
        case region = "Region"
    }

    static func writingClosure(_ value: S3ControlClientTypes.RegionReport?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Bucket")].write(value.bucket)
        try writer[.init("BucketAccountId")].write(value.bucketAccountId)
        try writer[.init("Region")].write(value.region)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let bucketAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketAccountId)
        bucketAccountId = bucketAccountIdDecoded
    }
}

extension S3ControlClientTypes {
    /// A combination of a bucket and Region that's part of a Multi-Region Access Point.
    public struct RegionReport: Swift.Equatable {
        /// The name of the bucket.
        public var bucket: Swift.String?
        /// The Amazon Web Services account ID that owns the Amazon S3 bucket that's associated with this Multi-Region Access Point.
        public var bucketAccountId: Swift.String?
        /// The name of the Region.
        public var region: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            bucketAccountId: Swift.String? = nil,
            region: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.bucketAccountId = bucketAccountId
            self.region = region
        }
    }

}

extension S3ControlClientTypes.RegionalBucket: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case bucketArn = "BucketArn"
        case creationDate = "CreationDate"
        case outpostId = "OutpostId"
        case publicAccessBlockEnabled = "PublicAccessBlockEnabled"
    }

    static func writingClosure(_ value: S3ControlClientTypes.RegionalBucket?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Bucket")].write(value.bucket)
        try writer[.init("BucketArn")].write(value.bucketArn)
        try writer[.init("CreationDate")].writeTimestamp(value.creationDate, format: .dateTime)
        try writer[.init("OutpostId")].write(value.outpostId)
        try writer[.init("PublicAccessBlockEnabled")].write(value.publicAccessBlockEnabled)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let bucketArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketArn)
        bucketArn = bucketArnDecoded
        let publicAccessBlockEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publicAccessBlockEnabled) ?? false
        publicAccessBlockEnabled = publicAccessBlockEnabledDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationDate)
        creationDate = creationDateDecoded
        let outpostIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outpostId)
        outpostId = outpostIdDecoded
    }
}

extension S3ControlClientTypes {
    /// The container for the regional bucket.
    public struct RegionalBucket: Swift.Equatable {
        ///
        /// This member is required.
        public var bucket: Swift.String?
        /// The Amazon Resource Name (ARN) for the regional bucket.
        public var bucketArn: Swift.String?
        /// The creation date of the regional bucket
        /// This member is required.
        public var creationDate: ClientRuntime.Date?
        /// The Outposts ID of the regional bucket.
        public var outpostId: Swift.String?
        ///
        /// This member is required.
        public var publicAccessBlockEnabled: Swift.Bool

        public init(
            bucket: Swift.String? = nil,
            bucketArn: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            outpostId: Swift.String? = nil,
            publicAccessBlockEnabled: Swift.Bool = false
        )
        {
            self.bucket = bucket
            self.bucketArn = bucketArn
            self.creationDate = creationDate
            self.outpostId = outpostId
            self.publicAccessBlockEnabled = publicAccessBlockEnabled
        }
    }

}

extension S3ControlClientTypes.ReplicaModifications: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    static func writingClosure(_ value: S3ControlClientTypes.ReplicaModifications?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Status")].write(value.status)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ReplicaModificationsStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension S3ControlClientTypes {
    /// A filter that you can use to specify whether replica modification sync is enabled. S3 on Outposts replica modification sync can help you keep object metadata synchronized between replicas and source objects. By default, S3 on Outposts replicates metadata from the source objects to the replicas only. When replica modification sync is enabled, S3 on Outposts replicates metadata changes made to the replica copies back to the source object, making the replication bidirectional. To replicate object metadata modifications on replicas, you can specify this element and set the Status of this element to Enabled. You must enable replica modification sync on the source and destination buckets to replicate replica metadata changes between the source and the replicas.
    public struct ReplicaModifications: Swift.Equatable {
        /// Specifies whether S3 on Outposts replicates modifications to object metadata on replicas.
        /// This member is required.
        public var status: S3ControlClientTypes.ReplicaModificationsStatus?

        public init(
            status: S3ControlClientTypes.ReplicaModificationsStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension S3ControlClientTypes {
    public enum ReplicaModificationsStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicaModificationsStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicaModificationsStatus(rawValue: rawValue) ?? ReplicaModificationsStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.ReplicationConfiguration: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case role = "Role"
        case rules = "Rules"
    }

    static func writingClosure(_ value: S3ControlClientTypes.ReplicationConfiguration?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Role")].write(value.role)
        try writer[.init("Rules")].writeList(value.rules, memberWritingClosure: S3ControlClientTypes.ReplicationRule.writingClosure(_:to:), memberNodeInfo: .init("Rule"), isFlattened: false)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        if containerValues.contains(.rules) {
            struct KeyVal0{struct Rule{}}
            let rulesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Rule>.CodingKeys.self, forKey: .rules)
            if let rulesWrappedContainer = rulesWrappedContainer {
                let rulesContainer = try rulesWrappedContainer.decodeIfPresent([S3ControlClientTypes.ReplicationRule].self, forKey: .member)
                var rulesBuffer:[S3ControlClientTypes.ReplicationRule]? = nil
                if let rulesContainer = rulesContainer {
                    rulesBuffer = [S3ControlClientTypes.ReplicationRule]()
                    for structureContainer0 in rulesContainer {
                        rulesBuffer?.append(structureContainer0)
                    }
                }
                rules = rulesBuffer
            } else {
                rules = []
            }
        } else {
            rules = nil
        }
    }
}

extension S3ControlClientTypes {
    /// A container for one or more replication rules. A replication configuration must have at least one rule and you can add up to 100 rules. The maximum size of a replication configuration is 128 KB.
    public struct ReplicationConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that S3 on Outposts assumes when replicating objects. For information about S3 replication on Outposts configuration, see [Setting up replication](https://docs.aws.amazon.com/AmazonS3/latest/userguide/outposts-replication-how-setup.html) in the Amazon S3 User Guide.
        /// This member is required.
        public var role: Swift.String?
        /// A container for one or more replication rules. A replication configuration must have at least one rule and can contain an array of 100 rules at the most.
        /// This member is required.
        public var rules: [S3ControlClientTypes.ReplicationRule]?

        public init(
            role: Swift.String? = nil,
            rules: [S3ControlClientTypes.ReplicationRule]? = nil
        )
        {
            self.role = role
            self.rules = rules
        }
    }

}

extension S3ControlClientTypes.ReplicationRule: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case deleteMarkerReplication = "DeleteMarkerReplication"
        case destination = "Destination"
        case existingObjectReplication = "ExistingObjectReplication"
        case filter = "Filter"
        case id = "ID"
        case `prefix` = "Prefix"
        case priority = "Priority"
        case sourceSelectionCriteria = "SourceSelectionCriteria"
        case status = "Status"
    }

    static func writingClosure(_ value: S3ControlClientTypes.ReplicationRule?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Bucket")].write(value.bucket)
        try writer[.init("DeleteMarkerReplication")].write(value.deleteMarkerReplication, writingClosure: S3ControlClientTypes.DeleteMarkerReplication.writingClosure(_:to:))
        try writer[.init("Destination")].write(value.destination, writingClosure: S3ControlClientTypes.Destination.writingClosure(_:to:))
        try writer[.init("ExistingObjectReplication")].write(value.existingObjectReplication, writingClosure: S3ControlClientTypes.ExistingObjectReplication.writingClosure(_:to:))
        try writer[.init("Filter")].write(value.filter, writingClosure: S3ControlClientTypes.ReplicationRuleFilter.writingClosure(_:to:))
        try writer[.init("ID")].write(value.id)
        try writer[.init("Prefix")].write(value.`prefix`)
        try writer[.init("Priority")].write(value.priority)
        try writer[.init("SourceSelectionCriteria")].write(value.sourceSelectionCriteria, writingClosure: S3ControlClientTypes.SourceSelectionCriteria.writingClosure(_:to:))
        try writer[.init("Status")].write(value.status)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority) ?? nil
        priority = priorityDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        let filterDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ReplicationRuleFilter.self, forKey: .filter)
        filter = filterDecoded
        let statusDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ReplicationRuleStatus.self, forKey: .status)
        status = statusDecoded
        let sourceSelectionCriteriaDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.SourceSelectionCriteria.self, forKey: .sourceSelectionCriteria)
        sourceSelectionCriteria = sourceSelectionCriteriaDecoded
        let existingObjectReplicationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ExistingObjectReplication.self, forKey: .existingObjectReplication)
        existingObjectReplication = existingObjectReplicationDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.Destination.self, forKey: .destination)
        destination = destinationDecoded
        let deleteMarkerReplicationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.DeleteMarkerReplication.self, forKey: .deleteMarkerReplication)
        deleteMarkerReplication = deleteMarkerReplicationDecoded
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
    }
}

extension S3ControlClientTypes {
    /// Specifies which S3 on Outposts objects to replicate and where to store the replicas.
    public struct ReplicationRule: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the access point for the source Outposts bucket that you want S3 on Outposts to replicate the objects from.
        /// This member is required.
        public var bucket: Swift.String?
        /// Specifies whether S3 on Outposts replicates delete markers. If you specify a Filter element in your replication configuration, you must also include a DeleteMarkerReplication element. If your Filter includes a Tag element, the DeleteMarkerReplication element's Status child element must be set to Disabled, because S3 on Outposts doesn't support replicating delete markers for tag-based rules. For more information about delete marker replication, see [How delete operations affect replication](https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3OutpostsReplication.html#outposts-replication-what-is-replicated) in the Amazon S3 User Guide.
        public var deleteMarkerReplication: S3ControlClientTypes.DeleteMarkerReplication?
        /// A container for information about the replication destination and its configurations.
        /// This member is required.
        public var destination: S3ControlClientTypes.Destination?
        /// An optional configuration to replicate existing source bucket objects. This is not supported by Amazon S3 on Outposts buckets.
        public var existingObjectReplication: S3ControlClientTypes.ExistingObjectReplication?
        /// A filter that identifies the subset of objects to which the replication rule applies. A Filter element must specify exactly one Prefix, Tag, or And child element.
        public var filter: S3ControlClientTypes.ReplicationRuleFilter?
        /// A unique identifier for the rule. The maximum value is 255 characters.
        public var id: Swift.String?
        /// An object key name prefix that identifies the object or objects to which the rule applies. The maximum prefix length is 1,024 characters. To include all objects in an Outposts bucket, specify an empty string. When you're using XML requests, you must replace special characters (such as carriage returns) in object keys with their equivalent XML entity codes. For more information, see [ XML-related object key constraints](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints) in the Amazon S3 User Guide.
        @available(*, deprecated, message: "Prefix has been deprecated")
        public var `prefix`: Swift.String?
        /// The priority indicates which rule has precedence whenever two or more replication rules conflict. S3 on Outposts attempts to replicate objects according to all replication rules. However, if there are two or more rules with the same destination Outposts bucket, then objects will be replicated according to the rule with the highest priority. The higher the number, the higher the priority. For more information, see [Creating replication rules on Outposts](https://docs.aws.amazon.com/AmazonS3/latest/userguide/replication-between-outposts.html) in the Amazon S3 User Guide.
        public var priority: Swift.Int?
        /// A container that describes additional filters for identifying the source Outposts objects that you want to replicate. You can choose to enable or disable the replication of these objects.
        public var sourceSelectionCriteria: S3ControlClientTypes.SourceSelectionCriteria?
        /// Specifies whether the rule is enabled.
        /// This member is required.
        public var status: S3ControlClientTypes.ReplicationRuleStatus?

        public init(
            bucket: Swift.String? = nil,
            deleteMarkerReplication: S3ControlClientTypes.DeleteMarkerReplication? = nil,
            destination: S3ControlClientTypes.Destination? = nil,
            existingObjectReplication: S3ControlClientTypes.ExistingObjectReplication? = nil,
            filter: S3ControlClientTypes.ReplicationRuleFilter? = nil,
            id: Swift.String? = nil,
            `prefix`: Swift.String? = nil,
            priority: Swift.Int? = nil,
            sourceSelectionCriteria: S3ControlClientTypes.SourceSelectionCriteria? = nil,
            status: S3ControlClientTypes.ReplicationRuleStatus? = nil
        )
        {
            self.bucket = bucket
            self.deleteMarkerReplication = deleteMarkerReplication
            self.destination = destination
            self.existingObjectReplication = existingObjectReplication
            self.filter = filter
            self.id = id
            self.`prefix` = `prefix`
            self.priority = priority
            self.sourceSelectionCriteria = sourceSelectionCriteria
            self.status = status
        }
    }

}

extension S3ControlClientTypes.ReplicationRuleAndOperator: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case `prefix` = "Prefix"
        case tags = "Tags"
    }

    static func writingClosure(_ value: S3ControlClientTypes.ReplicationRuleAndOperator?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Prefix")].write(value.`prefix`)
        try writer[.init("Tags")].writeList(value.tags, memberWritingClosure: S3ControlClientTypes.S3Tag.writingClosure(_:to:), memberNodeInfo: .init("member"), isFlattened: false)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([S3ControlClientTypes.S3Tag].self, forKey: .member)
                var tagsBuffer:[S3ControlClientTypes.S3Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [S3ControlClientTypes.S3Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension S3ControlClientTypes {
    /// A container for specifying rule filters. The filters determine the subset of objects to which the rule applies. This element is required only if you specify more than one filter. For example:
    ///
    /// * If you specify both a Prefix and a Tag filter, wrap these filters in an And element.
    ///
    /// * If you specify a filter based on multiple tags, wrap the Tag elements in an And element.
    public struct ReplicationRuleAndOperator: Swift.Equatable {
        /// An object key name prefix that identifies the subset of objects that the rule applies to.
        public var `prefix`: Swift.String?
        /// An array of tags that contain key and value pairs.
        public var tags: [S3ControlClientTypes.S3Tag]?

        public init(
            `prefix`: Swift.String? = nil,
            tags: [S3ControlClientTypes.S3Tag]? = nil
        )
        {
            self.`prefix` = `prefix`
            self.tags = tags
        }
    }

}

extension S3ControlClientTypes.ReplicationRuleFilter: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case and = "And"
        case `prefix` = "Prefix"
        case tag = "Tag"
    }

    static func writingClosure(_ value: S3ControlClientTypes.ReplicationRuleFilter?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("And")].write(value.and, writingClosure: S3ControlClientTypes.ReplicationRuleAndOperator.writingClosure(_:to:))
        try writer[.init("Prefix")].write(value.`prefix`)
        try writer[.init("Tag")].write(value.tag, writingClosure: S3ControlClientTypes.S3Tag.writingClosure(_:to:))
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        let tagDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3Tag.self, forKey: .tag)
        tag = tagDecoded
        let andDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ReplicationRuleAndOperator.self, forKey: .and)
        and = andDecoded
    }
}

extension S3ControlClientTypes {
    /// A filter that identifies the subset of objects to which the replication rule applies. A Filter element must specify exactly one Prefix, Tag, or And child element.
    public struct ReplicationRuleFilter: Swift.Equatable {
        /// A container for specifying rule filters. The filters determine the subset of objects that the rule applies to. This element is required only if you specify more than one filter. For example:
        ///
        /// * If you specify both a Prefix and a Tag filter, wrap these filters in an And element.
        ///
        /// * If you specify a filter based on multiple tags, wrap the Tag elements in an And element.
        public var and: S3ControlClientTypes.ReplicationRuleAndOperator?
        /// An object key name prefix that identifies the subset of objects that the rule applies to. When you're using XML requests, you must replace special characters (such as carriage returns) in object keys with their equivalent XML entity codes. For more information, see [ XML-related object key constraints](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints) in the Amazon S3 User Guide.
        public var `prefix`: Swift.String?
        /// A container for a key-value name pair.
        public var tag: S3ControlClientTypes.S3Tag?

        public init(
            and: S3ControlClientTypes.ReplicationRuleAndOperator? = nil,
            `prefix`: Swift.String? = nil,
            tag: S3ControlClientTypes.S3Tag? = nil
        )
        {
            self.and = and
            self.`prefix` = `prefix`
            self.tag = tag
        }
    }

}

extension S3ControlClientTypes {
    public enum ReplicationRuleStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationRuleStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationRuleStatus(rawValue: rawValue) ?? ReplicationRuleStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum ReplicationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case `none`
        case replica
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationStatus] {
            return [
                .completed,
                .failed,
                .none,
                .replica,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .none: return "NONE"
            case .replica: return "REPLICA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationStatus(rawValue: rawValue) ?? ReplicationStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum ReplicationStorageClass: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deepArchive
        case glacier
        case glacierIr
        case intelligentTiering
        case onezoneIa
        case outposts
        case reducedRedundancy
        case standard
        case standardIa
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationStorageClass] {
            return [
                .deepArchive,
                .glacier,
                .glacierIr,
                .intelligentTiering,
                .onezoneIa,
                .outposts,
                .reducedRedundancy,
                .standard,
                .standardIa,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deepArchive: return "DEEP_ARCHIVE"
            case .glacier: return "GLACIER"
            case .glacierIr: return "GLACIER_IR"
            case .intelligentTiering: return "INTELLIGENT_TIERING"
            case .onezoneIa: return "ONEZONE_IA"
            case .outposts: return "OUTPOSTS"
            case .reducedRedundancy: return "REDUCED_REDUNDANCY"
            case .standard: return "STANDARD"
            case .standardIa: return "STANDARD_IA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationStorageClass(rawValue: rawValue) ?? ReplicationStorageClass.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.ReplicationTime: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
        case time = "Time"
    }

    static func writingClosure(_ value: S3ControlClientTypes.ReplicationTime?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Status")].write(value.status)
        try writer[.init("Time")].write(value.time, writingClosure: S3ControlClientTypes.ReplicationTimeValue.writingClosure(_:to:))
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ReplicationTimeStatus.self, forKey: .status)
        status = statusDecoded
        let timeDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ReplicationTimeValue.self, forKey: .time)
        time = timeDecoded
    }
}

extension S3ControlClientTypes {
    /// A container that specifies S3 Replication Time Control (S3 RTC) related information, including whether S3 RTC is enabled and the time when all objects and operations on objects must be replicated. This is not supported by Amazon S3 on Outposts buckets.
    public struct ReplicationTime: Swift.Equatable {
        /// Specifies whether S3 Replication Time Control (S3 RTC) is enabled.
        /// This member is required.
        public var status: S3ControlClientTypes.ReplicationTimeStatus?
        /// A container that specifies the time by which replication should be complete for all objects and operations on objects.
        /// This member is required.
        public var time: S3ControlClientTypes.ReplicationTimeValue?

        public init(
            status: S3ControlClientTypes.ReplicationTimeStatus? = nil,
            time: S3ControlClientTypes.ReplicationTimeValue? = nil
        )
        {
            self.status = status
            self.time = time
        }
    }

}

extension S3ControlClientTypes {
    public enum ReplicationTimeStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationTimeStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationTimeStatus(rawValue: rawValue) ?? ReplicationTimeStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.ReplicationTimeValue: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case minutes = "Minutes"
    }

    static func writingClosure(_ value: S3ControlClientTypes.ReplicationTimeValue?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Minutes")].write(value.minutes)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minutes) ?? nil
        minutes = minutesDecoded
    }
}

extension S3ControlClientTypes {
    /// A container that specifies the time value for S3 Replication Time Control (S3 RTC). This value is also used for the replication metrics EventThreshold element. This is not supported by Amazon S3 on Outposts buckets.
    public struct ReplicationTimeValue: Swift.Equatable {
        /// Contains an integer that specifies the time period in minutes. Valid value: 15
        public var minutes: Swift.Int?

        public init(
            minutes: Swift.Int? = nil
        )
        {
            self.minutes = minutes
        }
    }

}

extension S3ControlClientTypes {
    public enum RequestedJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [RequestedJobStatus] {
            return [
                .cancelled,
                .ready,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "Cancelled"
            case .ready: return "Ready"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RequestedJobStatus(rawValue: rawValue) ?? RequestedJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.S3AccessControlList: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grants = "Grants"
        case owner = "Owner"
    }

    static func writingClosure(_ value: S3ControlClientTypes.S3AccessControlList?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Grants")].writeList(value.grants, memberWritingClosure: S3ControlClientTypes.S3Grant.writingClosure(_:to:), memberNodeInfo: .init("member"), isFlattened: false)
        try writer[.init("Owner")].write(value.owner, writingClosure: S3ControlClientTypes.S3ObjectOwner.writingClosure(_:to:))
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3ObjectOwner.self, forKey: .owner)
        owner = ownerDecoded
        if containerValues.contains(.grants) {
            struct KeyVal0{struct member{}}
            let grantsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .grants)
            if let grantsWrappedContainer = grantsWrappedContainer {
                let grantsContainer = try grantsWrappedContainer.decodeIfPresent([S3ControlClientTypes.S3Grant].self, forKey: .member)
                var grantsBuffer:[S3ControlClientTypes.S3Grant]? = nil
                if let grantsContainer = grantsContainer {
                    grantsBuffer = [S3ControlClientTypes.S3Grant]()
                    for structureContainer0 in grantsContainer {
                        grantsBuffer?.append(structureContainer0)
                    }
                }
                grants = grantsBuffer
            } else {
                grants = []
            }
        } else {
            grants = nil
        }
    }
}

extension S3ControlClientTypes {
    ///
    public struct S3AccessControlList: Swift.Equatable {
        ///
        public var grants: [S3ControlClientTypes.S3Grant]?
        ///
        /// This member is required.
        public var owner: S3ControlClientTypes.S3ObjectOwner?

        public init(
            grants: [S3ControlClientTypes.S3Grant]? = nil,
            owner: S3ControlClientTypes.S3ObjectOwner? = nil
        )
        {
            self.grants = grants
            self.owner = owner
        }
    }

}

extension S3ControlClientTypes.S3AccessControlPolicy: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessControlList = "AccessControlList"
        case cannedAccessControlList = "CannedAccessControlList"
    }

    static func writingClosure(_ value: S3ControlClientTypes.S3AccessControlPolicy?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("AccessControlList")].write(value.accessControlList, writingClosure: S3ControlClientTypes.S3AccessControlList.writingClosure(_:to:))
        try writer[.init("CannedAccessControlList")].write(value.cannedAccessControlList)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessControlListDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3AccessControlList.self, forKey: .accessControlList)
        accessControlList = accessControlListDecoded
        let cannedAccessControlListDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3CannedAccessControlList.self, forKey: .cannedAccessControlList)
        cannedAccessControlList = cannedAccessControlListDecoded
    }
}

extension S3ControlClientTypes {
    ///
    public struct S3AccessControlPolicy: Swift.Equatable {
        ///
        public var accessControlList: S3ControlClientTypes.S3AccessControlList?
        ///
        public var cannedAccessControlList: S3ControlClientTypes.S3CannedAccessControlList?

        public init(
            accessControlList: S3ControlClientTypes.S3AccessControlList? = nil,
            cannedAccessControlList: S3ControlClientTypes.S3CannedAccessControlList? = nil
        )
        {
            self.accessControlList = accessControlList
            self.cannedAccessControlList = cannedAccessControlList
        }
    }

}

extension S3ControlClientTypes.S3BucketDestination: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case arn = "Arn"
        case encryption = "Encryption"
        case format = "Format"
        case outputSchemaVersion = "OutputSchemaVersion"
        case `prefix` = "Prefix"
    }

    static func writingClosure(_ value: S3ControlClientTypes.S3BucketDestination?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("AccountId")].write(value.accountId)
        try writer[.init("Arn")].write(value.arn)
        try writer[.init("Encryption")].write(value.encryption, writingClosure: S3ControlClientTypes.StorageLensDataExportEncryption.writingClosure(_:to:))
        try writer[.init("Format")].write(value.format)
        try writer[.init("OutputSchemaVersion")].write(value.outputSchemaVersion)
        try writer[.init("Prefix")].write(value.`prefix`)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.Format.self, forKey: .format)
        format = formatDecoded
        let outputSchemaVersionDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.OutputSchemaVersion.self, forKey: .outputSchemaVersion)
        outputSchemaVersion = outputSchemaVersionDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.StorageLensDataExportEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
    }
}

extension S3ControlClientTypes {
    /// A container for the bucket where the Amazon S3 Storage Lens metrics export files are located.
    public struct S3BucketDestination: Swift.Equatable {
        /// The account ID of the owner of the S3 Storage Lens metrics export bucket.
        /// This member is required.
        public var accountId: Swift.String?
        /// The Amazon Resource Name (ARN) of the bucket. This property is read-only and follows the following format:  arn:aws:s3:us-east-1:example-account-id:bucket/your-destination-bucket-name
        /// This member is required.
        public var arn: Swift.String?
        /// The container for the type encryption of the metrics exports in this bucket.
        public var encryption: S3ControlClientTypes.StorageLensDataExportEncryption?
        ///
        /// This member is required.
        public var format: S3ControlClientTypes.Format?
        /// The schema version of the export file.
        /// This member is required.
        public var outputSchemaVersion: S3ControlClientTypes.OutputSchemaVersion?
        /// The prefix of the destination bucket where the metrics export will be delivered.
        public var `prefix`: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            arn: Swift.String? = nil,
            encryption: S3ControlClientTypes.StorageLensDataExportEncryption? = nil,
            format: S3ControlClientTypes.Format? = nil,
            outputSchemaVersion: S3ControlClientTypes.OutputSchemaVersion? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.arn = arn
            self.encryption = encryption
            self.format = format
            self.outputSchemaVersion = outputSchemaVersion
            self.`prefix` = `prefix`
        }
    }

}

extension S3ControlClientTypes {
    public enum S3CannedAccessControlList: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case authenticatedRead
        case awsExecRead
        case bucketOwnerFullControl
        case bucketOwnerRead
        case `private`
        case publicRead
        case publicReadWrite
        case sdkUnknown(Swift.String)

        public static var allCases: [S3CannedAccessControlList] {
            return [
                .authenticatedRead,
                .awsExecRead,
                .bucketOwnerFullControl,
                .bucketOwnerRead,
                .private,
                .publicRead,
                .publicReadWrite,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .authenticatedRead: return "authenticated-read"
            case .awsExecRead: return "aws-exec-read"
            case .bucketOwnerFullControl: return "bucket-owner-full-control"
            case .bucketOwnerRead: return "bucket-owner-read"
            case .private: return "private"
            case .publicRead: return "public-read"
            case .publicReadWrite: return "public-read-write"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3CannedAccessControlList(rawValue: rawValue) ?? S3CannedAccessControlList.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum S3ChecksumAlgorithm: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case crc32
        case crc32c
        case sha1
        case sha256
        case sdkUnknown(Swift.String)

        public static var allCases: [S3ChecksumAlgorithm] {
            return [
                .crc32,
                .crc32c,
                .sha1,
                .sha256,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .crc32: return "CRC32"
            case .crc32c: return "CRC32C"
            case .sha1: return "SHA1"
            case .sha256: return "SHA256"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3ChecksumAlgorithm(rawValue: rawValue) ?? S3ChecksumAlgorithm.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.S3CopyObjectOperation: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessControlGrants = "AccessControlGrants"
        case bucketKeyEnabled = "BucketKeyEnabled"
        case cannedAccessControlList = "CannedAccessControlList"
        case checksumAlgorithm = "ChecksumAlgorithm"
        case metadataDirective = "MetadataDirective"
        case modifiedSinceConstraint = "ModifiedSinceConstraint"
        case newObjectMetadata = "NewObjectMetadata"
        case newObjectTagging = "NewObjectTagging"
        case objectLockLegalHoldStatus = "ObjectLockLegalHoldStatus"
        case objectLockMode = "ObjectLockMode"
        case objectLockRetainUntilDate = "ObjectLockRetainUntilDate"
        case redirectLocation = "RedirectLocation"
        case requesterPays = "RequesterPays"
        case sseAwsKmsKeyId = "SSEAwsKmsKeyId"
        case storageClass = "StorageClass"
        case targetKeyPrefix = "TargetKeyPrefix"
        case targetResource = "TargetResource"
        case unModifiedSinceConstraint = "UnModifiedSinceConstraint"
    }

    static func writingClosure(_ value: S3ControlClientTypes.S3CopyObjectOperation?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("AccessControlGrants")].writeList(value.accessControlGrants, memberWritingClosure: S3ControlClientTypes.S3Grant.writingClosure(_:to:), memberNodeInfo: .init("member"), isFlattened: false)
        try writer[.init("BucketKeyEnabled")].write(value.bucketKeyEnabled)
        try writer[.init("CannedAccessControlList")].write(value.cannedAccessControlList)
        try writer[.init("ChecksumAlgorithm")].write(value.checksumAlgorithm)
        try writer[.init("MetadataDirective")].write(value.metadataDirective)
        try writer[.init("ModifiedSinceConstraint")].writeTimestamp(value.modifiedSinceConstraint, format: .dateTime)
        try writer[.init("NewObjectMetadata")].write(value.newObjectMetadata, writingClosure: S3ControlClientTypes.S3ObjectMetadata.writingClosure(_:to:))
        try writer[.init("NewObjectTagging")].writeList(value.newObjectTagging, memberWritingClosure: S3ControlClientTypes.S3Tag.writingClosure(_:to:), memberNodeInfo: .init("member"), isFlattened: false)
        try writer[.init("ObjectLockLegalHoldStatus")].write(value.objectLockLegalHoldStatus)
        try writer[.init("ObjectLockMode")].write(value.objectLockMode)
        try writer[.init("ObjectLockRetainUntilDate")].writeTimestamp(value.objectLockRetainUntilDate, format: .dateTime)
        try writer[.init("RedirectLocation")].write(value.redirectLocation)
        try writer[.init("RequesterPays")].write(value.requesterPays)
        try writer[.init("SSEAwsKmsKeyId")].write(value.sseAwsKmsKeyId)
        try writer[.init("StorageClass")].write(value.storageClass)
        try writer[.init("TargetKeyPrefix")].write(value.targetKeyPrefix)
        try writer[.init("TargetResource")].write(value.targetResource)
        try writer[.init("UnModifiedSinceConstraint")].writeTimestamp(value.unModifiedSinceConstraint, format: .dateTime)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetResourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetResource)
        targetResource = targetResourceDecoded
        let cannedAccessControlListDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3CannedAccessControlList.self, forKey: .cannedAccessControlList)
        cannedAccessControlList = cannedAccessControlListDecoded
        if containerValues.contains(.accessControlGrants) {
            struct KeyVal0{struct member{}}
            let accessControlGrantsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .accessControlGrants)
            if let accessControlGrantsWrappedContainer = accessControlGrantsWrappedContainer {
                let accessControlGrantsContainer = try accessControlGrantsWrappedContainer.decodeIfPresent([S3ControlClientTypes.S3Grant].self, forKey: .member)
                var accessControlGrantsBuffer:[S3ControlClientTypes.S3Grant]? = nil
                if let accessControlGrantsContainer = accessControlGrantsContainer {
                    accessControlGrantsBuffer = [S3ControlClientTypes.S3Grant]()
                    for structureContainer0 in accessControlGrantsContainer {
                        accessControlGrantsBuffer?.append(structureContainer0)
                    }
                }
                accessControlGrants = accessControlGrantsBuffer
            } else {
                accessControlGrants = []
            }
        } else {
            accessControlGrants = nil
        }
        let metadataDirectiveDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3MetadataDirective.self, forKey: .metadataDirective)
        metadataDirective = metadataDirectiveDecoded
        let modifiedSinceConstraintDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .modifiedSinceConstraint)
        modifiedSinceConstraint = modifiedSinceConstraintDecoded
        let newObjectMetadataDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3ObjectMetadata.self, forKey: .newObjectMetadata)
        newObjectMetadata = newObjectMetadataDecoded
        if containerValues.contains(.newObjectTagging) {
            struct KeyVal0{struct member{}}
            let newObjectTaggingWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .newObjectTagging)
            if let newObjectTaggingWrappedContainer = newObjectTaggingWrappedContainer {
                let newObjectTaggingContainer = try newObjectTaggingWrappedContainer.decodeIfPresent([S3ControlClientTypes.S3Tag].self, forKey: .member)
                var newObjectTaggingBuffer:[S3ControlClientTypes.S3Tag]? = nil
                if let newObjectTaggingContainer = newObjectTaggingContainer {
                    newObjectTaggingBuffer = [S3ControlClientTypes.S3Tag]()
                    for structureContainer0 in newObjectTaggingContainer {
                        newObjectTaggingBuffer?.append(structureContainer0)
                    }
                }
                newObjectTagging = newObjectTaggingBuffer
            } else {
                newObjectTagging = []
            }
        } else {
            newObjectTagging = nil
        }
        let redirectLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .redirectLocation)
        redirectLocation = redirectLocationDecoded
        let requesterPaysDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requesterPays) ?? false
        requesterPays = requesterPaysDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3StorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
        let unModifiedSinceConstraintDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .unModifiedSinceConstraint)
        unModifiedSinceConstraint = unModifiedSinceConstraintDecoded
        let sseAwsKmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sseAwsKmsKeyId)
        sseAwsKmsKeyId = sseAwsKmsKeyIdDecoded
        let targetKeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetKeyPrefix)
        targetKeyPrefix = targetKeyPrefixDecoded
        let objectLockLegalHoldStatusDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3ObjectLockLegalHoldStatus.self, forKey: .objectLockLegalHoldStatus)
        objectLockLegalHoldStatus = objectLockLegalHoldStatusDecoded
        let objectLockModeDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3ObjectLockMode.self, forKey: .objectLockMode)
        objectLockMode = objectLockModeDecoded
        let objectLockRetainUntilDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .objectLockRetainUntilDate)
        objectLockRetainUntilDate = objectLockRetainUntilDateDecoded
        let bucketKeyEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .bucketKeyEnabled) ?? false
        bucketKeyEnabled = bucketKeyEnabledDecoded
        let checksumAlgorithmDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3ChecksumAlgorithm.self, forKey: .checksumAlgorithm)
        checksumAlgorithm = checksumAlgorithmDecoded
    }
}

extension S3ControlClientTypes {
    /// Contains the configuration parameters for a PUT Copy object operation. S3 Batch Operations passes every object to the underlying CopyObject API operation. For more information about the parameters for this operation, see [CopyObject](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectCOPY.html).
    public struct S3CopyObjectOperation: Swift.Equatable {
        /// This functionality is not supported by directory buckets.
        public var accessControlGrants: [S3ControlClientTypes.S3Grant]?
        /// Specifies whether Amazon S3 should use an S3 Bucket Key for object encryption with server-side encryption using Amazon Web Services KMS (SSE-KMS). Setting this header to true causes Amazon S3 to use an S3 Bucket Key for object encryption with SSE-KMS. Specifying this header with an object action doesn’t affect bucket-level settings for S3 Bucket Key. This functionality is not supported by directory buckets.
        public var bucketKeyEnabled: Swift.Bool
        /// This functionality is not supported by directory buckets.
        public var cannedAccessControlList: S3ControlClientTypes.S3CannedAccessControlList?
        /// Indicates the algorithm that you want Amazon S3 to use to create the checksum. For more information, see [ Checking object integrity](https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html) in the Amazon S3 User Guide.
        public var checksumAlgorithm: S3ControlClientTypes.S3ChecksumAlgorithm?
        ///
        public var metadataDirective: S3ControlClientTypes.S3MetadataDirective?
        ///
        public var modifiedSinceConstraint: ClientRuntime.Date?
        /// If you don't provide this parameter, Amazon S3 copies all the metadata from the original objects. If you specify an empty set, the new objects will have no tags. Otherwise, Amazon S3 assigns the supplied tags to the new objects.
        public var newObjectMetadata: S3ControlClientTypes.S3ObjectMetadata?
        /// Specifies a list of tags to add to the destination objects after they are copied. If NewObjectTagging is not specified, the tags of the source objects are copied to destination objects by default. Directory buckets - Tags aren't supported by directory buckets. If your source objects have tags and your destination bucket is a directory bucket, specify an empty tag set in the NewObjectTagging field to prevent copying the source object tags to the directory bucket.
        public var newObjectTagging: [S3ControlClientTypes.S3Tag]?
        /// The legal hold status to be applied to all objects in the Batch Operations job. This functionality is not supported by directory buckets.
        public var objectLockLegalHoldStatus: S3ControlClientTypes.S3ObjectLockLegalHoldStatus?
        /// The retention mode to be applied to all objects in the Batch Operations job. This functionality is not supported by directory buckets.
        public var objectLockMode: S3ControlClientTypes.S3ObjectLockMode?
        /// The date when the applied object retention configuration expires on all objects in the Batch Operations job. This functionality is not supported by directory buckets.
        public var objectLockRetainUntilDate: ClientRuntime.Date?
        /// If the destination bucket is configured as a website, specifies an optional metadata property for website redirects, x-amz-website-redirect-location. Allows webpage redirects if the object copy is accessed through a website endpoint. This functionality is not supported by directory buckets.
        public var redirectLocation: Swift.String?
        /// This functionality is not supported by directory buckets.
        public var requesterPays: Swift.Bool
        /// This functionality is not supported by directory buckets.
        public var sseAwsKmsKeyId: Swift.String?
        /// Specify the storage class for the destination objects in a Copy operation. Directory buckets - This functionality is not supported by directory buckets.
        public var storageClass: S3ControlClientTypes.S3StorageClass?
        /// Specifies the folder prefix that you want the objects to be copied into. For example, to copy objects into a folder named Folder1 in the destination bucket, set the TargetKeyPrefix property to Folder1.
        public var targetKeyPrefix: Swift.String?
        /// Specifies the destination bucket Amazon Resource Name (ARN) for the batch copy operation.
        ///
        /// * General purpose buckets - For example, to copy objects to a general purpose bucket named destinationBucket, set the TargetResource property to arn:aws:s3:::destinationBucket.
        ///
        /// * Directory buckets - For example, to copy objects to a directory bucket named destinationBucket in the Availability Zone; identified by the AZ ID usw2-az2, set the TargetResource property to arn:aws:s3express:region:account_id:/bucket/destination_bucket_base_name--usw2-az2--x-s3.
        public var targetResource: Swift.String?
        ///
        public var unModifiedSinceConstraint: ClientRuntime.Date?

        public init(
            accessControlGrants: [S3ControlClientTypes.S3Grant]? = nil,
            bucketKeyEnabled: Swift.Bool = false,
            cannedAccessControlList: S3ControlClientTypes.S3CannedAccessControlList? = nil,
            checksumAlgorithm: S3ControlClientTypes.S3ChecksumAlgorithm? = nil,
            metadataDirective: S3ControlClientTypes.S3MetadataDirective? = nil,
            modifiedSinceConstraint: ClientRuntime.Date? = nil,
            newObjectMetadata: S3ControlClientTypes.S3ObjectMetadata? = nil,
            newObjectTagging: [S3ControlClientTypes.S3Tag]? = nil,
            objectLockLegalHoldStatus: S3ControlClientTypes.S3ObjectLockLegalHoldStatus? = nil,
            objectLockMode: S3ControlClientTypes.S3ObjectLockMode? = nil,
            objectLockRetainUntilDate: ClientRuntime.Date? = nil,
            redirectLocation: Swift.String? = nil,
            requesterPays: Swift.Bool = false,
            sseAwsKmsKeyId: Swift.String? = nil,
            storageClass: S3ControlClientTypes.S3StorageClass? = nil,
            targetKeyPrefix: Swift.String? = nil,
            targetResource: Swift.String? = nil,
            unModifiedSinceConstraint: ClientRuntime.Date? = nil
        )
        {
            self.accessControlGrants = accessControlGrants
            self.bucketKeyEnabled = bucketKeyEnabled
            self.cannedAccessControlList = cannedAccessControlList
            self.checksumAlgorithm = checksumAlgorithm
            self.metadataDirective = metadataDirective
            self.modifiedSinceConstraint = modifiedSinceConstraint
            self.newObjectMetadata = newObjectMetadata
            self.newObjectTagging = newObjectTagging
            self.objectLockLegalHoldStatus = objectLockLegalHoldStatus
            self.objectLockMode = objectLockMode
            self.objectLockRetainUntilDate = objectLockRetainUntilDate
            self.redirectLocation = redirectLocation
            self.requesterPays = requesterPays
            self.sseAwsKmsKeyId = sseAwsKmsKeyId
            self.storageClass = storageClass
            self.targetKeyPrefix = targetKeyPrefix
            self.targetResource = targetResource
            self.unModifiedSinceConstraint = unModifiedSinceConstraint
        }
    }

}

extension S3ControlClientTypes.S3DeleteObjectTaggingOperation: Swift.Decodable {

    static func writingClosure(_ value: S3ControlClientTypes.S3DeleteObjectTaggingOperation?, to writer: SmithyXML.Writer) throws {
        guard value != nil else { writer.detach(); return }
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension S3ControlClientTypes {
    /// Contains no configuration parameters because the DELETE Object tagging (DeleteObjectTagging) API operation accepts only the bucket name and key name as parameters, which are defined in the job's manifest.
    public struct S3DeleteObjectTaggingOperation: Swift.Equatable {

        public init() { }
    }

}

extension S3ControlClientTypes.S3GeneratedManifestDescriptor: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format = "Format"
        case location = "Location"
    }

    static func writingClosure(_ value: S3ControlClientTypes.S3GeneratedManifestDescriptor?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Format")].write(value.format)
        try writer[.init("Location")].write(value.location, writingClosure: S3ControlClientTypes.JobManifestLocation.writingClosure(_:to:))
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.GeneratedManifestFormat.self, forKey: .format)
        format = formatDecoded
        let locationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobManifestLocation.self, forKey: .location)
        location = locationDecoded
    }
}

extension S3ControlClientTypes {
    /// Describes the specified job's generated manifest. Batch Operations jobs created with a ManifestGenerator populate details of this descriptor after execution of the ManifestGenerator.
    public struct S3GeneratedManifestDescriptor: Swift.Equatable {
        /// The format of the generated manifest.
        public var format: S3ControlClientTypes.GeneratedManifestFormat?
        /// Contains the information required to locate a manifest object. Manifests can't be imported from directory buckets. For more information, see [Directory buckets](https://docs.aws.amazon.com/AmazonS3/latest/userguide/directory-buckets-overview.html).
        public var location: S3ControlClientTypes.JobManifestLocation?

        public init(
            format: S3ControlClientTypes.GeneratedManifestFormat? = nil,
            location: S3ControlClientTypes.JobManifestLocation? = nil
        )
        {
            self.format = format
            self.location = location
        }
    }

}

extension S3ControlClientTypes {
    public enum S3GlacierJobTier: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bulk
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [S3GlacierJobTier] {
            return [
                .bulk,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bulk: return "BULK"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3GlacierJobTier(rawValue: rawValue) ?? S3GlacierJobTier.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.S3Grant: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantee = "Grantee"
        case permission = "Permission"
    }

    static func writingClosure(_ value: S3ControlClientTypes.S3Grant?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Grantee")].write(value.grantee, writingClosure: S3ControlClientTypes.S3Grantee.writingClosure(_:to:))
        try writer[.init("Permission")].write(value.permission)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let granteeDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3Grantee.self, forKey: .grantee)
        grantee = granteeDecoded
        let permissionDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3Permission.self, forKey: .permission)
        permission = permissionDecoded
    }
}

extension S3ControlClientTypes {
    ///
    public struct S3Grant: Swift.Equatable {
        ///
        public var grantee: S3ControlClientTypes.S3Grantee?
        ///
        public var permission: S3ControlClientTypes.S3Permission?

        public init(
            grantee: S3ControlClientTypes.S3Grantee? = nil,
            permission: S3ControlClientTypes.S3Permission? = nil
        )
        {
            self.grantee = grantee
            self.permission = permission
        }
    }

}

extension S3ControlClientTypes.S3Grantee: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case identifier = "Identifier"
        case typeIdentifier = "TypeIdentifier"
    }

    static func writingClosure(_ value: S3ControlClientTypes.S3Grantee?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("DisplayName")].write(value.displayName)
        try writer[.init("Identifier")].write(value.identifier)
        try writer[.init("TypeIdentifier")].write(value.typeIdentifier)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeIdentifierDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3GranteeTypeIdentifier.self, forKey: .typeIdentifier)
        typeIdentifier = typeIdentifierDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension S3ControlClientTypes {
    ///
    public struct S3Grantee: Swift.Equatable {
        ///
        public var displayName: Swift.String?
        ///
        public var identifier: Swift.String?
        ///
        public var typeIdentifier: S3ControlClientTypes.S3GranteeTypeIdentifier?

        public init(
            displayName: Swift.String? = nil,
            identifier: Swift.String? = nil,
            typeIdentifier: S3ControlClientTypes.S3GranteeTypeIdentifier? = nil
        )
        {
            self.displayName = displayName
            self.identifier = identifier
            self.typeIdentifier = typeIdentifier
        }
    }

}

extension S3ControlClientTypes {
    public enum S3GranteeTypeIdentifier: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canonical
        case emailAddress
        case group
        case sdkUnknown(Swift.String)

        public static var allCases: [S3GranteeTypeIdentifier] {
            return [
                .canonical,
                .emailAddress,
                .group,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canonical: return "id"
            case .emailAddress: return "emailAddress"
            case .group: return "uri"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3GranteeTypeIdentifier(rawValue: rawValue) ?? S3GranteeTypeIdentifier.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.S3InitiateRestoreObjectOperation: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expirationInDays = "ExpirationInDays"
        case glacierJobTier = "GlacierJobTier"
    }

    static func writingClosure(_ value: S3ControlClientTypes.S3InitiateRestoreObjectOperation?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("ExpirationInDays")].write(value.expirationInDays)
        try writer[.init("GlacierJobTier")].write(value.glacierJobTier)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expirationInDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expirationInDays) ?? nil
        expirationInDays = expirationInDaysDecoded
        let glacierJobTierDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3GlacierJobTier.self, forKey: .glacierJobTier)
        glacierJobTier = glacierJobTierDecoded
    }
}

extension S3ControlClientTypes {
    /// Contains the configuration parameters for a POST Object restore job. S3 Batch Operations passes every object to the underlying RestoreObject API operation. For more information about the parameters for this operation, see [RestoreObject](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectPOSTrestore.html#RESTObjectPOSTrestore-restore-request).
    public struct S3InitiateRestoreObjectOperation: Swift.Equatable {
        /// This argument specifies how long the S3 Glacier or S3 Glacier Deep Archive object remains available in Amazon S3. S3 Initiate Restore Object jobs that target S3 Glacier and S3 Glacier Deep Archive objects require ExpirationInDays set to 1 or greater. Conversely, do not set ExpirationInDays when creating S3 Initiate Restore Object jobs that target S3 Intelligent-Tiering Archive Access and Deep Archive Access tier objects. Objects in S3 Intelligent-Tiering archive access tiers are not subject to restore expiry, so specifying ExpirationInDays results in restore request failure. S3 Batch Operations jobs can operate either on S3 Glacier and S3 Glacier Deep Archive storage class objects or on S3 Intelligent-Tiering Archive Access and Deep Archive Access storage tier objects, but not both types in the same job. If you need to restore objects of both types you must create separate Batch Operations jobs.
        public var expirationInDays: Swift.Int?
        /// S3 Batch Operations supports STANDARD and BULK retrieval tiers, but not the EXPEDITED retrieval tier.
        public var glacierJobTier: S3ControlClientTypes.S3GlacierJobTier?

        public init(
            expirationInDays: Swift.Int? = nil,
            glacierJobTier: S3ControlClientTypes.S3GlacierJobTier? = nil
        )
        {
            self.expirationInDays = expirationInDays
            self.glacierJobTier = glacierJobTier
        }
    }

}

extension S3ControlClientTypes.S3JobManifestGenerator: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableManifestOutput = "EnableManifestOutput"
        case expectedBucketOwner = "ExpectedBucketOwner"
        case filter = "Filter"
        case manifestOutputLocation = "ManifestOutputLocation"
        case sourceBucket = "SourceBucket"
    }

    static func writingClosure(_ value: S3ControlClientTypes.S3JobManifestGenerator?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("EnableManifestOutput")].write(value.enableManifestOutput)
        try writer[.init("ExpectedBucketOwner")].write(value.expectedBucketOwner)
        try writer[.init("Filter")].write(value.filter, writingClosure: S3ControlClientTypes.JobManifestGeneratorFilter.writingClosure(_:to:))
        try writer[.init("ManifestOutputLocation")].write(value.manifestOutputLocation, writingClosure: S3ControlClientTypes.S3ManifestOutputLocation.writingClosure(_:to:))
        try writer[.init("SourceBucket")].write(value.sourceBucket)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expectedBucketOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expectedBucketOwner)
        expectedBucketOwner = expectedBucketOwnerDecoded
        let sourceBucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceBucket)
        sourceBucket = sourceBucketDecoded
        let manifestOutputLocationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3ManifestOutputLocation.self, forKey: .manifestOutputLocation)
        manifestOutputLocation = manifestOutputLocationDecoded
        let filterDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobManifestGeneratorFilter.self, forKey: .filter)
        filter = filterDecoded
        let enableManifestOutputDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableManifestOutput) ?? false
        enableManifestOutput = enableManifestOutputDecoded
    }
}

extension S3ControlClientTypes {
    /// The container for the service that will create the S3 manifest.
    public struct S3JobManifestGenerator: Swift.Equatable {
        /// Determines whether or not to write the job's generated manifest to a bucket.
        /// This member is required.
        public var enableManifestOutput: Swift.Bool
        /// The Amazon Web Services account ID that owns the bucket the generated manifest is written to. If provided the generated manifest bucket's owner Amazon Web Services account ID must match this value, else the job fails.
        public var expectedBucketOwner: Swift.String?
        /// Specifies rules the S3JobManifestGenerator should use to decide whether an object in the source bucket should or should not be included in the generated job manifest.
        public var filter: S3ControlClientTypes.JobManifestGeneratorFilter?
        /// Specifies the location the generated manifest will be written to. Manifests can't be written to directory buckets. For more information, see [Directory buckets](https://docs.aws.amazon.com/AmazonS3/latest/userguide/directory-buckets-overview.html).
        public var manifestOutputLocation: S3ControlClientTypes.S3ManifestOutputLocation?
        /// The source bucket used by the ManifestGenerator. Directory buckets - Directory buckets aren't supported as the source buckets used by S3JobManifestGenerator to generate the job manifest.
        /// This member is required.
        public var sourceBucket: Swift.String?

        public init(
            enableManifestOutput: Swift.Bool = false,
            expectedBucketOwner: Swift.String? = nil,
            filter: S3ControlClientTypes.JobManifestGeneratorFilter? = nil,
            manifestOutputLocation: S3ControlClientTypes.S3ManifestOutputLocation? = nil,
            sourceBucket: Swift.String? = nil
        )
        {
            self.enableManifestOutput = enableManifestOutput
            self.expectedBucketOwner = expectedBucketOwner
            self.filter = filter
            self.manifestOutputLocation = manifestOutputLocation
            self.sourceBucket = sourceBucket
        }
    }

}

extension S3ControlClientTypes.S3ManifestOutputLocation: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case expectedManifestBucketOwner = "ExpectedManifestBucketOwner"
        case manifestEncryption = "ManifestEncryption"
        case manifestFormat = "ManifestFormat"
        case manifestPrefix = "ManifestPrefix"
    }

    static func writingClosure(_ value: S3ControlClientTypes.S3ManifestOutputLocation?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Bucket")].write(value.bucket)
        try writer[.init("ExpectedManifestBucketOwner")].write(value.expectedManifestBucketOwner)
        try writer[.init("ManifestEncryption")].write(value.manifestEncryption, writingClosure: S3ControlClientTypes.GeneratedManifestEncryption.writingClosure(_:to:))
        try writer[.init("ManifestFormat")].write(value.manifestFormat)
        try writer[.init("ManifestPrefix")].write(value.manifestPrefix)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expectedManifestBucketOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expectedManifestBucketOwner)
        expectedManifestBucketOwner = expectedManifestBucketOwnerDecoded
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let manifestPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestPrefix)
        manifestPrefix = manifestPrefixDecoded
        let manifestEncryptionDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.GeneratedManifestEncryption.self, forKey: .manifestEncryption)
        manifestEncryption = manifestEncryptionDecoded
        let manifestFormatDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.GeneratedManifestFormat.self, forKey: .manifestFormat)
        manifestFormat = manifestFormatDecoded
    }
}

extension S3ControlClientTypes {
    /// Location details for where the generated manifest should be written.
    public struct S3ManifestOutputLocation: Swift.Equatable {
        /// The bucket ARN the generated manifest should be written to. Directory buckets - Directory buckets aren't supported as the buckets to store the generated manifest.
        /// This member is required.
        public var bucket: Swift.String?
        /// The Account ID that owns the bucket the generated manifest is written to.
        public var expectedManifestBucketOwner: Swift.String?
        /// Specifies what encryption should be used when the generated manifest objects are written.
        public var manifestEncryption: S3ControlClientTypes.GeneratedManifestEncryption?
        /// The format of the generated manifest.
        /// This member is required.
        public var manifestFormat: S3ControlClientTypes.GeneratedManifestFormat?
        /// Prefix identifying one or more objects to which the manifest applies.
        public var manifestPrefix: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            expectedManifestBucketOwner: Swift.String? = nil,
            manifestEncryption: S3ControlClientTypes.GeneratedManifestEncryption? = nil,
            manifestFormat: S3ControlClientTypes.GeneratedManifestFormat? = nil,
            manifestPrefix: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.expectedManifestBucketOwner = expectedManifestBucketOwner
            self.manifestEncryption = manifestEncryption
            self.manifestFormat = manifestFormat
            self.manifestPrefix = manifestPrefix
        }
    }

}

extension S3ControlClientTypes {
    public enum S3MetadataDirective: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case copy
        case replace
        case sdkUnknown(Swift.String)

        public static var allCases: [S3MetadataDirective] {
            return [
                .copy,
                .replace,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .copy: return "COPY"
            case .replace: return "REPLACE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3MetadataDirective(rawValue: rawValue) ?? S3MetadataDirective.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.S3ObjectLockLegalHold: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    static func writingClosure(_ value: S3ControlClientTypes.S3ObjectLockLegalHold?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Status")].write(value.status)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3ObjectLockLegalHoldStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension S3ControlClientTypes {
    /// Whether S3 Object Lock legal hold will be applied to objects in an S3 Batch Operations job.
    public struct S3ObjectLockLegalHold: Swift.Equatable {
        /// The Object Lock legal hold status to be applied to all objects in the Batch Operations job.
        /// This member is required.
        public var status: S3ControlClientTypes.S3ObjectLockLegalHoldStatus?

        public init(
            status: S3ControlClientTypes.S3ObjectLockLegalHoldStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension S3ControlClientTypes {
    public enum S3ObjectLockLegalHoldStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case off
        case on
        case sdkUnknown(Swift.String)

        public static var allCases: [S3ObjectLockLegalHoldStatus] {
            return [
                .off,
                .on,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .off: return "OFF"
            case .on: return "ON"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3ObjectLockLegalHoldStatus(rawValue: rawValue) ?? S3ObjectLockLegalHoldStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum S3ObjectLockMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case compliance
        case governance
        case sdkUnknown(Swift.String)

        public static var allCases: [S3ObjectLockMode] {
            return [
                .compliance,
                .governance,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .compliance: return "COMPLIANCE"
            case .governance: return "GOVERNANCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3ObjectLockMode(rawValue: rawValue) ?? S3ObjectLockMode.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum S3ObjectLockRetentionMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case compliance
        case governance
        case sdkUnknown(Swift.String)

        public static var allCases: [S3ObjectLockRetentionMode] {
            return [
                .compliance,
                .governance,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .compliance: return "COMPLIANCE"
            case .governance: return "GOVERNANCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3ObjectLockRetentionMode(rawValue: rawValue) ?? S3ObjectLockRetentionMode.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.S3ObjectMetadata: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cacheControl = "CacheControl"
        case contentDisposition = "ContentDisposition"
        case contentEncoding = "ContentEncoding"
        case contentLanguage = "ContentLanguage"
        case contentLength = "ContentLength"
        case contentMD5 = "ContentMD5"
        case contentType = "ContentType"
        case httpExpiresDate = "HttpExpiresDate"
        case requesterCharged = "RequesterCharged"
        case sseAlgorithm = "SSEAlgorithm"
        case userMetadata = "UserMetadata"
    }

    static func writingClosure(_ value: S3ControlClientTypes.S3ObjectMetadata?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("CacheControl")].write(value.cacheControl)
        try writer[.init("ContentDisposition")].write(value.contentDisposition)
        try writer[.init("ContentEncoding")].write(value.contentEncoding)
        try writer[.init("ContentLanguage")].write(value.contentLanguage)
        try writer[.init("ContentLength")].write(value.contentLength)
        try writer[.init("ContentMD5")].write(value.contentMD5)
        try writer[.init("ContentType")].write(value.contentType)
        try writer[.init("HttpExpiresDate")].writeTimestamp(value.httpExpiresDate, format: .dateTime)
        try writer[.init("RequesterCharged")].write(value.requesterCharged)
        try writer[.init("SSEAlgorithm")].write(value.sseAlgorithm)
        try writer[.init("UserMetadata")].writeMap(value.userMetadata, valueWritingClosure: Swift.String.writingClosure(_:to:), keyNodeInfo: .init("key"), valueNodeInfo: .init("value"), isFlattened: false)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cacheControlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cacheControl)
        cacheControl = cacheControlDecoded
        let contentDispositionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentDisposition)
        contentDisposition = contentDispositionDecoded
        let contentEncodingDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentEncoding)
        contentEncoding = contentEncodingDecoded
        let contentLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentLanguage)
        contentLanguage = contentLanguageDecoded
        if containerValues.contains(.userMetadata) {
            struct KeyVal0{struct key{}; struct value{}}
            let userMetadataWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: ClientRuntime.MapEntry<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .userMetadata)
            if let userMetadataWrappedContainer = userMetadataWrappedContainer {
                let userMetadataContainer = try userMetadataWrappedContainer.decodeIfPresent([ClientRuntime.MapKeyValue<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var userMetadataBuffer: [Swift.String:Swift.String]? = nil
                if let userMetadataContainer = userMetadataContainer {
                    userMetadataBuffer = [Swift.String:Swift.String]()
                    for stringContainer0 in userMetadataContainer {
                        userMetadataBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                userMetadata = userMetadataBuffer
            } else {
                userMetadata = [:]
            }
        } else {
            userMetadata = nil
        }
        let contentLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .contentLength) ?? nil
        contentLength = contentLengthDecoded
        let contentMD5Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentMD5)
        contentMD5 = contentMD5Decoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let httpExpiresDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .httpExpiresDate)
        httpExpiresDate = httpExpiresDateDecoded
        let requesterChargedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requesterCharged) ?? false
        requesterCharged = requesterChargedDecoded
        let sseAlgorithmDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3SSEAlgorithm.self, forKey: .sseAlgorithm)
        sseAlgorithm = sseAlgorithmDecoded
    }
}

extension S3ControlClientTypes {
    ///
    public struct S3ObjectMetadata: Swift.Equatable {
        ///
        public var cacheControl: Swift.String?
        ///
        public var contentDisposition: Swift.String?
        ///
        public var contentEncoding: Swift.String?
        ///
        public var contentLanguage: Swift.String?
        /// This member has been deprecated.
        public var contentLength: Swift.Int?
        /// This member has been deprecated.
        public var contentMD5: Swift.String?
        ///
        public var contentType: Swift.String?
        ///
        public var httpExpiresDate: ClientRuntime.Date?
        /// This member has been deprecated.
        public var requesterCharged: Swift.Bool
        /// For directory buckets, only the server-side encryption with Amazon S3 managed keys (SSE-S3) (AES256) is supported.
        public var sseAlgorithm: S3ControlClientTypes.S3SSEAlgorithm?
        ///
        public var userMetadata: [Swift.String:Swift.String]?

        public init(
            cacheControl: Swift.String? = nil,
            contentDisposition: Swift.String? = nil,
            contentEncoding: Swift.String? = nil,
            contentLanguage: Swift.String? = nil,
            contentLength: Swift.Int? = nil,
            contentMD5: Swift.String? = nil,
            contentType: Swift.String? = nil,
            httpExpiresDate: ClientRuntime.Date? = nil,
            requesterCharged: Swift.Bool = false,
            sseAlgorithm: S3ControlClientTypes.S3SSEAlgorithm? = nil,
            userMetadata: [Swift.String:Swift.String]? = nil
        )
        {
            self.cacheControl = cacheControl
            self.contentDisposition = contentDisposition
            self.contentEncoding = contentEncoding
            self.contentLanguage = contentLanguage
            self.contentLength = contentLength
            self.contentMD5 = contentMD5
            self.contentType = contentType
            self.httpExpiresDate = httpExpiresDate
            self.requesterCharged = requesterCharged
            self.sseAlgorithm = sseAlgorithm
            self.userMetadata = userMetadata
        }
    }

}

extension S3ControlClientTypes.S3ObjectOwner: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case id = "ID"
    }

    static func writingClosure(_ value: S3ControlClientTypes.S3ObjectOwner?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("DisplayName")].write(value.displayName)
        try writer[.init("ID")].write(value.id)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension S3ControlClientTypes {
    ///
    public struct S3ObjectOwner: Swift.Equatable {
        ///
        public var displayName: Swift.String?
        ///
        public var id: Swift.String?

        public init(
            displayName: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.displayName = displayName
            self.id = id
        }
    }

}

extension S3ControlClientTypes {
    public enum S3Permission: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fullControl
        case read
        case readAcp
        case write
        case writeAcp
        case sdkUnknown(Swift.String)

        public static var allCases: [S3Permission] {
            return [
                .fullControl,
                .read,
                .readAcp,
                .write,
                .writeAcp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fullControl: return "FULL_CONTROL"
            case .read: return "READ"
            case .readAcp: return "READ_ACP"
            case .write: return "WRITE"
            case .writeAcp: return "WRITE_ACP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3Permission(rawValue: rawValue) ?? S3Permission.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum S3PrefixType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case object
        case sdkUnknown(Swift.String)

        public static var allCases: [S3PrefixType] {
            return [
                .object,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .object: return "Object"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3PrefixType(rawValue: rawValue) ?? S3PrefixType.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.S3ReplicateObjectOperation: Swift.Decodable {

    static func writingClosure(_ value: S3ControlClientTypes.S3ReplicateObjectOperation?, to writer: SmithyXML.Writer) throws {
        guard value != nil else { writer.detach(); return }
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension S3ControlClientTypes {
    /// Directs the specified job to invoke ReplicateObject on every object in the job's manifest.
    public struct S3ReplicateObjectOperation: Swift.Equatable {

        public init() { }
    }

}

extension S3ControlClientTypes.S3Retention: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mode = "Mode"
        case retainUntilDate = "RetainUntilDate"
    }

    static func writingClosure(_ value: S3ControlClientTypes.S3Retention?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Mode")].write(value.mode)
        try writer[.init("RetainUntilDate")].writeTimestamp(value.retainUntilDate, format: .dateTime)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retainUntilDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .retainUntilDate)
        retainUntilDate = retainUntilDateDecoded
        let modeDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3ObjectLockRetentionMode.self, forKey: .mode)
        mode = modeDecoded
    }
}

extension S3ControlClientTypes {
    /// Contains the S3 Object Lock retention mode to be applied to all objects in the S3 Batch Operations job. If you don't provide Mode and RetainUntilDate data types in your operation, you will remove the retention from your objects. For more information, see [Using S3 Object Lock retention with S3 Batch Operations](https://docs.aws.amazon.com/AmazonS3/latest/dev/batch-ops-retention-date.html) in the Amazon S3 User Guide.
    public struct S3Retention: Swift.Equatable {
        /// The Object Lock retention mode to be applied to all objects in the Batch Operations job.
        public var mode: S3ControlClientTypes.S3ObjectLockRetentionMode?
        /// The date when the applied Object Lock retention will expire on all objects set by the Batch Operations job.
        public var retainUntilDate: ClientRuntime.Date?

        public init(
            mode: S3ControlClientTypes.S3ObjectLockRetentionMode? = nil,
            retainUntilDate: ClientRuntime.Date? = nil
        )
        {
            self.mode = mode
            self.retainUntilDate = retainUntilDate
        }
    }

}

extension S3ControlClientTypes {
    public enum S3SSEAlgorithm: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aes256
        case kms
        case sdkUnknown(Swift.String)

        public static var allCases: [S3SSEAlgorithm] {
            return [
                .aes256,
                .kms,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aes256: return "AES256"
            case .kms: return "KMS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3SSEAlgorithm(rawValue: rawValue) ?? S3SSEAlgorithm.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.S3SetObjectAclOperation: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessControlPolicy = "AccessControlPolicy"
    }

    static func writingClosure(_ value: S3ControlClientTypes.S3SetObjectAclOperation?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("AccessControlPolicy")].write(value.accessControlPolicy, writingClosure: S3ControlClientTypes.S3AccessControlPolicy.writingClosure(_:to:))
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessControlPolicyDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3AccessControlPolicy.self, forKey: .accessControlPolicy)
        accessControlPolicy = accessControlPolicyDecoded
    }
}

extension S3ControlClientTypes {
    /// Contains the configuration parameters for a PUT Object ACL operation. S3 Batch Operations passes every object to the underlying PutObjectAcl API operation. For more information about the parameters for this operation, see [PutObjectAcl](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectPUTacl.html).
    public struct S3SetObjectAclOperation: Swift.Equatable {
        ///
        public var accessControlPolicy: S3ControlClientTypes.S3AccessControlPolicy?

        public init(
            accessControlPolicy: S3ControlClientTypes.S3AccessControlPolicy? = nil
        )
        {
            self.accessControlPolicy = accessControlPolicy
        }
    }

}

extension S3ControlClientTypes.S3SetObjectLegalHoldOperation: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case legalHold = "LegalHold"
    }

    static func writingClosure(_ value: S3ControlClientTypes.S3SetObjectLegalHoldOperation?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("LegalHold")].write(value.legalHold, writingClosure: S3ControlClientTypes.S3ObjectLockLegalHold.writingClosure(_:to:))
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let legalHoldDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3ObjectLockLegalHold.self, forKey: .legalHold)
        legalHold = legalHoldDecoded
    }
}

extension S3ControlClientTypes {
    /// Contains the configuration for an S3 Object Lock legal hold operation that an S3 Batch Operations job passes to every object to the underlying PutObjectLegalHold API operation. For more information, see [Using S3 Object Lock legal hold with S3 Batch Operations](https://docs.aws.amazon.com/AmazonS3/latest/dev/batch-ops-legal-hold.html) in the Amazon S3 User Guide. This functionality is not supported by directory buckets.
    public struct S3SetObjectLegalHoldOperation: Swift.Equatable {
        /// Contains the Object Lock legal hold status to be applied to all objects in the Batch Operations job.
        /// This member is required.
        public var legalHold: S3ControlClientTypes.S3ObjectLockLegalHold?

        public init(
            legalHold: S3ControlClientTypes.S3ObjectLockLegalHold? = nil
        )
        {
            self.legalHold = legalHold
        }
    }

}

extension S3ControlClientTypes.S3SetObjectRetentionOperation: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bypassGovernanceRetention = "BypassGovernanceRetention"
        case retention = "Retention"
    }

    static func writingClosure(_ value: S3ControlClientTypes.S3SetObjectRetentionOperation?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("BypassGovernanceRetention")].write(value.bypassGovernanceRetention)
        try writer[.init("Retention")].write(value.retention, writingClosure: S3ControlClientTypes.S3Retention.writingClosure(_:to:))
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bypassGovernanceRetentionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .bypassGovernanceRetention) ?? nil
        bypassGovernanceRetention = bypassGovernanceRetentionDecoded
        let retentionDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3Retention.self, forKey: .retention)
        retention = retentionDecoded
    }
}

extension S3ControlClientTypes {
    /// Contains the configuration parameters for the Object Lock retention action for an S3 Batch Operations job. Batch Operations passes every object to the underlying PutObjectRetention API operation. For more information, see [Using S3 Object Lock retention with S3 Batch Operations](https://docs.aws.amazon.com/AmazonS3/latest/dev/batch-ops-retention-date.html) in the Amazon S3 User Guide. This functionality is not supported by directory buckets.
    public struct S3SetObjectRetentionOperation: Swift.Equatable {
        /// Indicates if the action should be applied to objects in the Batch Operations job even if they have Object Lock  GOVERNANCE type in place.
        public var bypassGovernanceRetention: Swift.Bool?
        /// Contains the Object Lock retention mode to be applied to all objects in the Batch Operations job. For more information, see [Using S3 Object Lock retention with S3 Batch Operations](https://docs.aws.amazon.com/AmazonS3/latest/dev/batch-ops-retention-date.html) in the Amazon S3 User Guide.
        /// This member is required.
        public var retention: S3ControlClientTypes.S3Retention?

        public init(
            bypassGovernanceRetention: Swift.Bool? = nil,
            retention: S3ControlClientTypes.S3Retention? = nil
        )
        {
            self.bypassGovernanceRetention = bypassGovernanceRetention
            self.retention = retention
        }
    }

}

extension S3ControlClientTypes.S3SetObjectTaggingOperation: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagSet = "TagSet"
    }

    static func writingClosure(_ value: S3ControlClientTypes.S3SetObjectTaggingOperation?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("TagSet")].writeList(value.tagSet, memberWritingClosure: S3ControlClientTypes.S3Tag.writingClosure(_:to:), memberNodeInfo: .init("member"), isFlattened: false)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.tagSet) {
            struct KeyVal0{struct member{}}
            let tagSetWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tagSet)
            if let tagSetWrappedContainer = tagSetWrappedContainer {
                let tagSetContainer = try tagSetWrappedContainer.decodeIfPresent([S3ControlClientTypes.S3Tag].self, forKey: .member)
                var tagSetBuffer:[S3ControlClientTypes.S3Tag]? = nil
                if let tagSetContainer = tagSetContainer {
                    tagSetBuffer = [S3ControlClientTypes.S3Tag]()
                    for structureContainer0 in tagSetContainer {
                        tagSetBuffer?.append(structureContainer0)
                    }
                }
                tagSet = tagSetBuffer
            } else {
                tagSet = []
            }
        } else {
            tagSet = nil
        }
    }
}

extension S3ControlClientTypes {
    /// Contains the configuration parameters for a PUT Object Tagging operation. S3 Batch Operations passes every object to the underlying PutObjectTagging API operation. For more information about the parameters for this operation, see [PutObjectTagging](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectPUTtagging.html).
    public struct S3SetObjectTaggingOperation: Swift.Equatable {
        ///
        public var tagSet: [S3ControlClientTypes.S3Tag]?

        public init(
            tagSet: [S3ControlClientTypes.S3Tag]? = nil
        )
        {
            self.tagSet = tagSet
        }
    }

}

extension S3ControlClientTypes {
    public enum S3StorageClass: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deepArchive
        case glacier
        case glacierIr
        case intelligentTiering
        case onezoneIa
        case standard
        case standardIa
        case sdkUnknown(Swift.String)

        public static var allCases: [S3StorageClass] {
            return [
                .deepArchive,
                .glacier,
                .glacierIr,
                .intelligentTiering,
                .onezoneIa,
                .standard,
                .standardIa,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deepArchive: return "DEEP_ARCHIVE"
            case .glacier: return "GLACIER"
            case .glacierIr: return "GLACIER_IR"
            case .intelligentTiering: return "INTELLIGENT_TIERING"
            case .onezoneIa: return "ONEZONE_IA"
            case .standard: return "STANDARD"
            case .standardIa: return "STANDARD_IA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3StorageClass(rawValue: rawValue) ?? S3StorageClass.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.S3Tag: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    static func writingClosure(_ value: S3ControlClientTypes.S3Tag?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Key")].write(value.key)
        try writer[.init("Value")].write(value.value)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension S3ControlClientTypes {
    /// A container for a key-value name pair.
    public struct S3Tag: Swift.Equatable {
        /// Key of the tag
        /// This member is required.
        public var key: Swift.String?
        /// Value of the tag
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension S3ControlClientTypes.SSEKMS: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyId = "KeyId"
    }

    static func writingClosure(_ value: S3ControlClientTypes.SSEKMS?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("KeyId")].write(value.keyId)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyId)
        keyId = keyIdDecoded
    }
}

extension S3ControlClientTypes {
    ///
    public struct SSEKMS: Swift.Equatable {
        /// A container for the ARN of the SSE-KMS encryption. This property is read-only and follows the following format:  arn:aws:kms:us-east-1:example-account-id:key/example-9a73-4afc-8d29-8f5900cef44e
        /// This member is required.
        public var keyId: Swift.String?

        public init(
            keyId: Swift.String? = nil
        )
        {
            self.keyId = keyId
        }
    }

}

extension S3ControlClientTypes.SSEKMSEncryption: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyId = "KeyId"
    }

    static func writingClosure(_ value: S3ControlClientTypes.SSEKMSEncryption?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("KeyId")].write(value.keyId)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyId)
        keyId = keyIdDecoded
    }
}

extension S3ControlClientTypes {
    /// Configuration for the use of SSE-KMS to encrypt generated manifest objects.
    public struct SSEKMSEncryption: Swift.Equatable {
        /// Specifies the ID of the Amazon Web Services Key Management Service (Amazon Web Services KMS) symmetric encryption customer managed key to use for encrypting generated manifest objects.
        /// This member is required.
        public var keyId: Swift.String?

        public init(
            keyId: Swift.String? = nil
        )
        {
            self.keyId = keyId
        }
    }

}

extension S3ControlClientTypes.SSES3: Swift.Decodable {

    static func writingClosure(_ value: S3ControlClientTypes.SSES3?, to writer: SmithyXML.Writer) throws {
        guard value != nil else { writer.detach(); return }
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension S3ControlClientTypes {
    ///
    public struct SSES3: Swift.Equatable {

        public init() { }
    }

}

extension S3ControlClientTypes.SSES3Encryption: Swift.Decodable {

    static func writingClosure(_ value: S3ControlClientTypes.SSES3Encryption?, to writer: SmithyXML.Writer) throws {
        guard value != nil else { writer.detach(); return }
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension S3ControlClientTypes {
    /// Configuration for the use of SSE-S3 to encrypt generated manifest objects.
    public struct SSES3Encryption: Swift.Equatable {

        public init() { }
    }

}

extension S3ControlClientTypes.SelectionCriteria: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delimiter = "Delimiter"
        case maxDepth = "MaxDepth"
        case minStorageBytesPercentage = "MinStorageBytesPercentage"
    }

    static func writingClosure(_ value: S3ControlClientTypes.SelectionCriteria?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Delimiter")].write(value.delimiter)
        try writer[.init("MaxDepth")].write(value.maxDepth)
        try writer[.init("MinStorageBytesPercentage")].write(value.minStorageBytesPercentage)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let delimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .delimiter)
        delimiter = delimiterDecoded
        let maxDepthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxDepth)
        maxDepth = maxDepthDecoded
        let minStorageBytesPercentageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .minStorageBytesPercentage)
        minStorageBytesPercentage = minStorageBytesPercentageDecoded
    }
}

extension S3ControlClientTypes {
    ///
    public struct SelectionCriteria: Swift.Equatable {
        /// A container for the delimiter of the selection criteria being used.
        public var delimiter: Swift.String?
        /// The max depth of the selection criteria
        public var maxDepth: Swift.Int?
        /// The minimum number of storage bytes percentage whose metrics will be selected. You must choose a value greater than or equal to 1.0.
        public var minStorageBytesPercentage: Swift.Double?

        public init(
            delimiter: Swift.String? = nil,
            maxDepth: Swift.Int? = nil,
            minStorageBytesPercentage: Swift.Double? = nil
        )
        {
            self.delimiter = delimiter
            self.maxDepth = maxDepth
            self.minStorageBytesPercentage = minStorageBytesPercentage
        }
    }

}

extension S3ControlClientTypes.SourceSelectionCriteria: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicaModifications = "ReplicaModifications"
        case sseKmsEncryptedObjects = "SseKmsEncryptedObjects"
    }

    static func writingClosure(_ value: S3ControlClientTypes.SourceSelectionCriteria?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("ReplicaModifications")].write(value.replicaModifications, writingClosure: S3ControlClientTypes.ReplicaModifications.writingClosure(_:to:))
        try writer[.init("SseKmsEncryptedObjects")].write(value.sseKmsEncryptedObjects, writingClosure: S3ControlClientTypes.SseKmsEncryptedObjects.writingClosure(_:to:))
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sseKmsEncryptedObjectsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.SseKmsEncryptedObjects.self, forKey: .sseKmsEncryptedObjects)
        sseKmsEncryptedObjects = sseKmsEncryptedObjectsDecoded
        let replicaModificationsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ReplicaModifications.self, forKey: .replicaModifications)
        replicaModifications = replicaModificationsDecoded
    }
}

extension S3ControlClientTypes {
    /// A container that describes additional filters for identifying the source objects that you want to replicate. You can choose to enable or disable the replication of these objects.
    public struct SourceSelectionCriteria: Swift.Equatable {
        /// A filter that you can use to specify whether replica modification sync is enabled. S3 on Outposts replica modification sync can help you keep object metadata synchronized between replicas and source objects. By default, S3 on Outposts replicates metadata from the source objects to the replicas only. When replica modification sync is enabled, S3 on Outposts replicates metadata changes made to the replica copies back to the source object, making the replication bidirectional. To replicate object metadata modifications on replicas, you can specify this element and set the Status of this element to Enabled. You must enable replica modification sync on the source and destination buckets to replicate replica metadata changes between the source and the replicas.
        public var replicaModifications: S3ControlClientTypes.ReplicaModifications?
        /// A filter that you can use to select Amazon S3 objects that are encrypted with server-side encryption by using Key Management Service (KMS) keys. If you include SourceSelectionCriteria in the replication configuration, this element is required. This is not supported by Amazon S3 on Outposts buckets.
        public var sseKmsEncryptedObjects: S3ControlClientTypes.SseKmsEncryptedObjects?

        public init(
            replicaModifications: S3ControlClientTypes.ReplicaModifications? = nil,
            sseKmsEncryptedObjects: S3ControlClientTypes.SseKmsEncryptedObjects? = nil
        )
        {
            self.replicaModifications = replicaModifications
            self.sseKmsEncryptedObjects = sseKmsEncryptedObjects
        }
    }

}

extension S3ControlClientTypes.SseKmsEncryptedObjects: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    static func writingClosure(_ value: S3ControlClientTypes.SseKmsEncryptedObjects?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Status")].write(value.status)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.SseKmsEncryptedObjectsStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension S3ControlClientTypes {
    /// A container for filter information that you can use to select S3 objects that are encrypted with Key Management Service (KMS). This is not supported by Amazon S3 on Outposts buckets.
    public struct SseKmsEncryptedObjects: Swift.Equatable {
        /// Specifies whether Amazon S3 replicates objects that are created with server-side encryption by using an KMS key stored in Key Management Service.
        /// This member is required.
        public var status: S3ControlClientTypes.SseKmsEncryptedObjectsStatus?

        public init(
            status: S3ControlClientTypes.SseKmsEncryptedObjectsStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension S3ControlClientTypes {
    public enum SseKmsEncryptedObjectsStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [SseKmsEncryptedObjectsStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SseKmsEncryptedObjectsStatus(rawValue: rawValue) ?? SseKmsEncryptedObjectsStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.StorageLensAwsOrg: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    static func writingClosure(_ value: S3ControlClientTypes.StorageLensAwsOrg?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Arn")].write(value.arn)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension S3ControlClientTypes {
    /// The Amazon Web Services organization for your S3 Storage Lens.
    public struct StorageLensAwsOrg: Swift.Equatable {
        /// A container for the Amazon Resource Name (ARN) of the Amazon Web Services organization. This property is read-only and follows the following format:  arn:aws:organizations:us-east-1:example-account-id:organization/o-ex2l495dck
        /// This member is required.
        public var arn: Swift.String?

        public init(
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension S3ControlClientTypes.StorageLensConfiguration: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountLevel = "AccountLevel"
        case awsOrg = "AwsOrg"
        case dataExport = "DataExport"
        case exclude = "Exclude"
        case id = "Id"
        case include = "Include"
        case isEnabled = "IsEnabled"
        case storageLensArn = "StorageLensArn"
    }

    static func writingClosure(_ value: S3ControlClientTypes.StorageLensConfiguration?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("AccountLevel")].write(value.accountLevel, writingClosure: S3ControlClientTypes.AccountLevel.writingClosure(_:to:))
        try writer[.init("AwsOrg")].write(value.awsOrg, writingClosure: S3ControlClientTypes.StorageLensAwsOrg.writingClosure(_:to:))
        try writer[.init("DataExport")].write(value.dataExport, writingClosure: S3ControlClientTypes.StorageLensDataExport.writingClosure(_:to:))
        try writer[.init("Exclude")].write(value.exclude, writingClosure: S3ControlClientTypes.Exclude.writingClosure(_:to:))
        try writer[.init("Id")].write(value.id)
        try writer[.init("Include")].write(value.include, writingClosure: S3ControlClientTypes.Include.writingClosure(_:to:))
        try writer[.init("IsEnabled")].write(value.isEnabled)
        try writer[.init("StorageLensArn")].write(value.storageLensArn)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let accountLevelDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.AccountLevel.self, forKey: .accountLevel)
        accountLevel = accountLevelDecoded
        let includeDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.Include.self, forKey: .include)
        include = includeDecoded
        let excludeDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.Exclude.self, forKey: .exclude)
        exclude = excludeDecoded
        let dataExportDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.StorageLensDataExport.self, forKey: .dataExport)
        dataExport = dataExportDecoded
        let isEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isEnabled) ?? false
        isEnabled = isEnabledDecoded
        let awsOrgDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.StorageLensAwsOrg.self, forKey: .awsOrg)
        awsOrg = awsOrgDecoded
        let storageLensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageLensArn)
        storageLensArn = storageLensArnDecoded
    }
}

extension S3ControlClientTypes {
    /// A container for the Amazon S3 Storage Lens configuration.
    public struct StorageLensConfiguration: Swift.Equatable {
        /// A container for all the account-level configurations of your S3 Storage Lens configuration.
        /// This member is required.
        public var accountLevel: S3ControlClientTypes.AccountLevel?
        /// A container for the Amazon Web Services organization for this S3 Storage Lens configuration.
        public var awsOrg: S3ControlClientTypes.StorageLensAwsOrg?
        /// A container to specify the properties of your S3 Storage Lens metrics export including, the destination, schema and format.
        public var dataExport: S3ControlClientTypes.StorageLensDataExport?
        /// A container for what is excluded in this configuration. This container can only be valid if there is no Include container submitted, and it's not empty.
        public var exclude: S3ControlClientTypes.Exclude?
        /// A container for the Amazon S3 Storage Lens configuration ID.
        /// This member is required.
        public var id: Swift.String?
        /// A container for what is included in this configuration. This container can only be valid if there is no Exclude container submitted, and it's not empty.
        public var include: S3ControlClientTypes.Include?
        /// A container for whether the S3 Storage Lens configuration is enabled.
        /// This member is required.
        public var isEnabled: Swift.Bool
        /// The Amazon Resource Name (ARN) of the S3 Storage Lens configuration. This property is read-only and follows the following format:  arn:aws:s3:us-east-1:example-account-id:storage-lens/your-dashboard-name
        public var storageLensArn: Swift.String?

        public init(
            accountLevel: S3ControlClientTypes.AccountLevel? = nil,
            awsOrg: S3ControlClientTypes.StorageLensAwsOrg? = nil,
            dataExport: S3ControlClientTypes.StorageLensDataExport? = nil,
            exclude: S3ControlClientTypes.Exclude? = nil,
            id: Swift.String? = nil,
            include: S3ControlClientTypes.Include? = nil,
            isEnabled: Swift.Bool = false,
            storageLensArn: Swift.String? = nil
        )
        {
            self.accountLevel = accountLevel
            self.awsOrg = awsOrg
            self.dataExport = dataExport
            self.exclude = exclude
            self.id = id
            self.include = include
            self.isEnabled = isEnabled
            self.storageLensArn = storageLensArn
        }
    }

}

extension S3ControlClientTypes.StorageLensDataExport: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchMetrics = "CloudWatchMetrics"
        case s3BucketDestination = "S3BucketDestination"
    }

    static func writingClosure(_ value: S3ControlClientTypes.StorageLensDataExport?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("CloudWatchMetrics")].write(value.cloudWatchMetrics, writingClosure: S3ControlClientTypes.CloudWatchMetrics.writingClosure(_:to:))
        try writer[.init("S3BucketDestination")].write(value.s3BucketDestination, writingClosure: S3ControlClientTypes.S3BucketDestination.writingClosure(_:to:))
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDestinationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3BucketDestination.self, forKey: .s3BucketDestination)
        s3BucketDestination = s3BucketDestinationDecoded
        let cloudWatchMetricsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.CloudWatchMetrics.self, forKey: .cloudWatchMetrics)
        cloudWatchMetrics = cloudWatchMetricsDecoded
    }
}

extension S3ControlClientTypes {
    /// A container to specify the properties of your S3 Storage Lens metrics export, including the destination, schema, and format.
    public struct StorageLensDataExport: Swift.Equatable {
        /// A container for enabling Amazon CloudWatch publishing for S3 Storage Lens metrics.
        public var cloudWatchMetrics: S3ControlClientTypes.CloudWatchMetrics?
        /// A container for the bucket where the S3 Storage Lens metrics export will be located. This bucket must be located in the same Region as the storage lens configuration.
        public var s3BucketDestination: S3ControlClientTypes.S3BucketDestination?

        public init(
            cloudWatchMetrics: S3ControlClientTypes.CloudWatchMetrics? = nil,
            s3BucketDestination: S3ControlClientTypes.S3BucketDestination? = nil
        )
        {
            self.cloudWatchMetrics = cloudWatchMetrics
            self.s3BucketDestination = s3BucketDestination
        }
    }

}

extension S3ControlClientTypes.StorageLensDataExportEncryption: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ssekms = "SSE-KMS"
        case sses3 = "SSE-S3"
    }

    static func writingClosure(_ value: S3ControlClientTypes.StorageLensDataExportEncryption?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("SSE-KMS")].write(value.ssekms, writingClosure: S3ControlClientTypes.SSEKMS.writingClosure(_:to:))
        try writer[.init("SSE-S3")].write(value.sses3, writingClosure: S3ControlClientTypes.SSES3.writingClosure(_:to:))
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sses3Decoded = try containerValues.decodeIfPresent(S3ControlClientTypes.SSES3.self, forKey: .sses3)
        sses3 = sses3Decoded
        let ssekmsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.SSEKMS.self, forKey: .ssekms)
        ssekms = ssekmsDecoded
    }
}

extension S3ControlClientTypes {
    /// A container for the encryption of the S3 Storage Lens metrics exports.
    public struct StorageLensDataExportEncryption: Swift.Equatable {
        ///
        public var ssekms: S3ControlClientTypes.SSEKMS?
        ///
        public var sses3: S3ControlClientTypes.SSES3?

        public init(
            ssekms: S3ControlClientTypes.SSEKMS? = nil,
            sses3: S3ControlClientTypes.SSES3? = nil
        )
        {
            self.ssekms = ssekms
            self.sses3 = sses3
        }
    }

}

extension S3ControlClientTypes.StorageLensGroup: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case name = "Name"
        case storageLensGroupArn = "StorageLensGroupArn"
    }

    static func writingClosure(_ value: S3ControlClientTypes.StorageLensGroup?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Filter")].write(value.filter, writingClosure: S3ControlClientTypes.StorageLensGroupFilter.writingClosure(_:to:))
        try writer[.init("Name")].write(value.name)
        try writer[.init("StorageLensGroupArn")].write(value.storageLensGroupArn)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let filterDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.StorageLensGroupFilter.self, forKey: .filter)
        filter = filterDecoded
        let storageLensGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageLensGroupArn)
        storageLensGroupArn = storageLensGroupArnDecoded
    }
}

extension S3ControlClientTypes {
    /// A custom grouping of objects that include filters for prefixes, suffixes, object tags, object size, or object age. You can create an S3 Storage Lens group that includes a single filter or multiple filter conditions. To specify multiple filter conditions, you use AND or OR logical operators.
    public struct StorageLensGroup: Swift.Equatable {
        /// Sets the criteria for the Storage Lens group data that is displayed. For multiple filter conditions, the AND or OR logical operator is used.
        /// This member is required.
        public var filter: S3ControlClientTypes.StorageLensGroupFilter?
        /// Contains the name of the Storage Lens group.
        /// This member is required.
        public var name: Swift.String?
        /// Contains the Amazon Resource Name (ARN) of the Storage Lens group. This property is read-only.
        public var storageLensGroupArn: Swift.String?

        public init(
            filter: S3ControlClientTypes.StorageLensGroupFilter? = nil,
            name: Swift.String? = nil,
            storageLensGroupArn: Swift.String? = nil
        )
        {
            self.filter = filter
            self.name = name
            self.storageLensGroupArn = storageLensGroupArn
        }
    }

}

extension S3ControlClientTypes.StorageLensGroupAndOperator: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case matchAnyPrefix = "MatchAnyPrefix"
        case matchAnySuffix = "MatchAnySuffix"
        case matchAnyTag = "MatchAnyTag"
        case matchObjectAge = "MatchObjectAge"
        case matchObjectSize = "MatchObjectSize"
    }

    static func writingClosure(_ value: S3ControlClientTypes.StorageLensGroupAndOperator?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("MatchAnyPrefix")].writeList(value.matchAnyPrefix, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: .init("Prefix"), isFlattened: false)
        try writer[.init("MatchAnySuffix")].writeList(value.matchAnySuffix, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: .init("Suffix"), isFlattened: false)
        try writer[.init("MatchAnyTag")].writeList(value.matchAnyTag, memberWritingClosure: S3ControlClientTypes.S3Tag.writingClosure(_:to:), memberNodeInfo: .init("Tag"), isFlattened: false)
        try writer[.init("MatchObjectAge")].write(value.matchObjectAge, writingClosure: S3ControlClientTypes.MatchObjectAge.writingClosure(_:to:))
        try writer[.init("MatchObjectSize")].write(value.matchObjectSize, writingClosure: S3ControlClientTypes.MatchObjectSize.writingClosure(_:to:))
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.matchAnyPrefix) {
            struct KeyVal0{struct Prefix{}}
            let matchAnyPrefixWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Prefix>.CodingKeys.self, forKey: .matchAnyPrefix)
            if let matchAnyPrefixWrappedContainer = matchAnyPrefixWrappedContainer {
                let matchAnyPrefixContainer = try matchAnyPrefixWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var matchAnyPrefixBuffer:[Swift.String]? = nil
                if let matchAnyPrefixContainer = matchAnyPrefixContainer {
                    matchAnyPrefixBuffer = [Swift.String]()
                    for stringContainer0 in matchAnyPrefixContainer {
                        matchAnyPrefixBuffer?.append(stringContainer0)
                    }
                }
                matchAnyPrefix = matchAnyPrefixBuffer
            } else {
                matchAnyPrefix = []
            }
        } else {
            matchAnyPrefix = nil
        }
        if containerValues.contains(.matchAnySuffix) {
            struct KeyVal0{struct Suffix{}}
            let matchAnySuffixWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Suffix>.CodingKeys.self, forKey: .matchAnySuffix)
            if let matchAnySuffixWrappedContainer = matchAnySuffixWrappedContainer {
                let matchAnySuffixContainer = try matchAnySuffixWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var matchAnySuffixBuffer:[Swift.String]? = nil
                if let matchAnySuffixContainer = matchAnySuffixContainer {
                    matchAnySuffixBuffer = [Swift.String]()
                    for stringContainer0 in matchAnySuffixContainer {
                        matchAnySuffixBuffer?.append(stringContainer0)
                    }
                }
                matchAnySuffix = matchAnySuffixBuffer
            } else {
                matchAnySuffix = []
            }
        } else {
            matchAnySuffix = nil
        }
        if containerValues.contains(.matchAnyTag) {
            struct KeyVal0{struct Tag{}}
            let matchAnyTagWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .matchAnyTag)
            if let matchAnyTagWrappedContainer = matchAnyTagWrappedContainer {
                let matchAnyTagContainer = try matchAnyTagWrappedContainer.decodeIfPresent([S3ControlClientTypes.S3Tag].self, forKey: .member)
                var matchAnyTagBuffer:[S3ControlClientTypes.S3Tag]? = nil
                if let matchAnyTagContainer = matchAnyTagContainer {
                    matchAnyTagBuffer = [S3ControlClientTypes.S3Tag]()
                    for structureContainer0 in matchAnyTagContainer {
                        matchAnyTagBuffer?.append(structureContainer0)
                    }
                }
                matchAnyTag = matchAnyTagBuffer
            } else {
                matchAnyTag = []
            }
        } else {
            matchAnyTag = nil
        }
        let matchObjectAgeDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.MatchObjectAge.self, forKey: .matchObjectAge)
        matchObjectAge = matchObjectAgeDecoded
        let matchObjectSizeDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.MatchObjectSize.self, forKey: .matchObjectSize)
        matchObjectSize = matchObjectSizeDecoded
    }
}

extension S3ControlClientTypes {
    /// A logical operator that allows multiple filter conditions to be joined for more complex comparisons of Storage Lens group data.
    public struct StorageLensGroupAndOperator: Swift.Equatable {
        /// Contains a list of prefixes. At least one prefix must be specified. Up to 10 prefixes are allowed.
        public var matchAnyPrefix: [Swift.String]?
        /// Contains a list of suffixes. At least one suffix must be specified. Up to 10 suffixes are allowed.
        public var matchAnySuffix: [Swift.String]?
        /// Contains the list of object tags. At least one object tag must be specified. Up to 10 object tags are allowed.
        public var matchAnyTag: [S3ControlClientTypes.S3Tag]?
        /// Contains DaysGreaterThan and DaysLessThan to define the object age range (minimum and maximum number of days).
        public var matchObjectAge: S3ControlClientTypes.MatchObjectAge?
        /// Contains BytesGreaterThan and BytesLessThan to define the object size range (minimum and maximum number of Bytes).
        public var matchObjectSize: S3ControlClientTypes.MatchObjectSize?

        public init(
            matchAnyPrefix: [Swift.String]? = nil,
            matchAnySuffix: [Swift.String]? = nil,
            matchAnyTag: [S3ControlClientTypes.S3Tag]? = nil,
            matchObjectAge: S3ControlClientTypes.MatchObjectAge? = nil,
            matchObjectSize: S3ControlClientTypes.MatchObjectSize? = nil
        )
        {
            self.matchAnyPrefix = matchAnyPrefix
            self.matchAnySuffix = matchAnySuffix
            self.matchAnyTag = matchAnyTag
            self.matchObjectAge = matchObjectAge
            self.matchObjectSize = matchObjectSize
        }
    }

}

extension S3ControlClientTypes.StorageLensGroupFilter: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case and = "And"
        case matchAnyPrefix = "MatchAnyPrefix"
        case matchAnySuffix = "MatchAnySuffix"
        case matchAnyTag = "MatchAnyTag"
        case matchObjectAge = "MatchObjectAge"
        case matchObjectSize = "MatchObjectSize"
        case or = "Or"
    }

    static func writingClosure(_ value: S3ControlClientTypes.StorageLensGroupFilter?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("And")].write(value.and, writingClosure: S3ControlClientTypes.StorageLensGroupAndOperator.writingClosure(_:to:))
        try writer[.init("MatchAnyPrefix")].writeList(value.matchAnyPrefix, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: .init("Prefix"), isFlattened: false)
        try writer[.init("MatchAnySuffix")].writeList(value.matchAnySuffix, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: .init("Suffix"), isFlattened: false)
        try writer[.init("MatchAnyTag")].writeList(value.matchAnyTag, memberWritingClosure: S3ControlClientTypes.S3Tag.writingClosure(_:to:), memberNodeInfo: .init("Tag"), isFlattened: false)
        try writer[.init("MatchObjectAge")].write(value.matchObjectAge, writingClosure: S3ControlClientTypes.MatchObjectAge.writingClosure(_:to:))
        try writer[.init("MatchObjectSize")].write(value.matchObjectSize, writingClosure: S3ControlClientTypes.MatchObjectSize.writingClosure(_:to:))
        try writer[.init("Or")].write(value.or, writingClosure: S3ControlClientTypes.StorageLensGroupOrOperator.writingClosure(_:to:))
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.matchAnyPrefix) {
            struct KeyVal0{struct Prefix{}}
            let matchAnyPrefixWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Prefix>.CodingKeys.self, forKey: .matchAnyPrefix)
            if let matchAnyPrefixWrappedContainer = matchAnyPrefixWrappedContainer {
                let matchAnyPrefixContainer = try matchAnyPrefixWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var matchAnyPrefixBuffer:[Swift.String]? = nil
                if let matchAnyPrefixContainer = matchAnyPrefixContainer {
                    matchAnyPrefixBuffer = [Swift.String]()
                    for stringContainer0 in matchAnyPrefixContainer {
                        matchAnyPrefixBuffer?.append(stringContainer0)
                    }
                }
                matchAnyPrefix = matchAnyPrefixBuffer
            } else {
                matchAnyPrefix = []
            }
        } else {
            matchAnyPrefix = nil
        }
        if containerValues.contains(.matchAnySuffix) {
            struct KeyVal0{struct Suffix{}}
            let matchAnySuffixWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Suffix>.CodingKeys.self, forKey: .matchAnySuffix)
            if let matchAnySuffixWrappedContainer = matchAnySuffixWrappedContainer {
                let matchAnySuffixContainer = try matchAnySuffixWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var matchAnySuffixBuffer:[Swift.String]? = nil
                if let matchAnySuffixContainer = matchAnySuffixContainer {
                    matchAnySuffixBuffer = [Swift.String]()
                    for stringContainer0 in matchAnySuffixContainer {
                        matchAnySuffixBuffer?.append(stringContainer0)
                    }
                }
                matchAnySuffix = matchAnySuffixBuffer
            } else {
                matchAnySuffix = []
            }
        } else {
            matchAnySuffix = nil
        }
        if containerValues.contains(.matchAnyTag) {
            struct KeyVal0{struct Tag{}}
            let matchAnyTagWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .matchAnyTag)
            if let matchAnyTagWrappedContainer = matchAnyTagWrappedContainer {
                let matchAnyTagContainer = try matchAnyTagWrappedContainer.decodeIfPresent([S3ControlClientTypes.S3Tag].self, forKey: .member)
                var matchAnyTagBuffer:[S3ControlClientTypes.S3Tag]? = nil
                if let matchAnyTagContainer = matchAnyTagContainer {
                    matchAnyTagBuffer = [S3ControlClientTypes.S3Tag]()
                    for structureContainer0 in matchAnyTagContainer {
                        matchAnyTagBuffer?.append(structureContainer0)
                    }
                }
                matchAnyTag = matchAnyTagBuffer
            } else {
                matchAnyTag = []
            }
        } else {
            matchAnyTag = nil
        }
        let matchObjectAgeDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.MatchObjectAge.self, forKey: .matchObjectAge)
        matchObjectAge = matchObjectAgeDecoded
        let matchObjectSizeDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.MatchObjectSize.self, forKey: .matchObjectSize)
        matchObjectSize = matchObjectSizeDecoded
        let andDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.StorageLensGroupAndOperator.self, forKey: .and)
        and = andDecoded
        let orDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.StorageLensGroupOrOperator.self, forKey: .or)
        or = orDecoded
    }
}

extension S3ControlClientTypes {
    /// The filter element sets the criteria for the Storage Lens group data that is displayed. For multiple filter conditions, the AND or OR logical operator is used.
    public struct StorageLensGroupFilter: Swift.Equatable {
        /// A logical operator that allows multiple filter conditions to be joined for more complex comparisons of Storage Lens group data. Objects must match all of the listed filter conditions that are joined by the And logical operator. Only one of each filter condition is allowed.
        public var and: S3ControlClientTypes.StorageLensGroupAndOperator?
        /// Contains a list of prefixes. At least one prefix must be specified. Up to 10 prefixes are allowed.
        public var matchAnyPrefix: [Swift.String]?
        /// Contains a list of suffixes. At least one suffix must be specified. Up to 10 suffixes are allowed.
        public var matchAnySuffix: [Swift.String]?
        /// Contains the list of S3 object tags. At least one object tag must be specified. Up to 10 object tags are allowed.
        public var matchAnyTag: [S3ControlClientTypes.S3Tag]?
        /// Contains DaysGreaterThan and DaysLessThan to define the object age range (minimum and maximum number of days).
        public var matchObjectAge: S3ControlClientTypes.MatchObjectAge?
        /// Contains BytesGreaterThan and BytesLessThan to define the object size range (minimum and maximum number of Bytes).
        public var matchObjectSize: S3ControlClientTypes.MatchObjectSize?
        /// A single logical operator that allows multiple filter conditions to be joined. Objects can match any of the listed filter conditions, which are joined by the Or logical operator. Only one of each filter condition is allowed.
        public var or: S3ControlClientTypes.StorageLensGroupOrOperator?

        public init(
            and: S3ControlClientTypes.StorageLensGroupAndOperator? = nil,
            matchAnyPrefix: [Swift.String]? = nil,
            matchAnySuffix: [Swift.String]? = nil,
            matchAnyTag: [S3ControlClientTypes.S3Tag]? = nil,
            matchObjectAge: S3ControlClientTypes.MatchObjectAge? = nil,
            matchObjectSize: S3ControlClientTypes.MatchObjectSize? = nil,
            or: S3ControlClientTypes.StorageLensGroupOrOperator? = nil
        )
        {
            self.and = and
            self.matchAnyPrefix = matchAnyPrefix
            self.matchAnySuffix = matchAnySuffix
            self.matchAnyTag = matchAnyTag
            self.matchObjectAge = matchObjectAge
            self.matchObjectSize = matchObjectSize
            self.or = or
        }
    }

}

extension S3ControlClientTypes.StorageLensGroupLevel: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case selectionCriteria = "SelectionCriteria"
    }

    static func writingClosure(_ value: S3ControlClientTypes.StorageLensGroupLevel?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("SelectionCriteria")].write(value.selectionCriteria, writingClosure: S3ControlClientTypes.StorageLensGroupLevelSelectionCriteria.writingClosure(_:to:))
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectionCriteriaDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.StorageLensGroupLevelSelectionCriteria.self, forKey: .selectionCriteria)
        selectionCriteria = selectionCriteriaDecoded
    }
}

extension S3ControlClientTypes {
    /// Specifies the Storage Lens groups to include in the Storage Lens group aggregation.
    public struct StorageLensGroupLevel: Swift.Equatable {
        /// Indicates which Storage Lens group ARNs to include or exclude in the Storage Lens group aggregation. If this value is left null, then all Storage Lens groups are selected.
        public var selectionCriteria: S3ControlClientTypes.StorageLensGroupLevelSelectionCriteria?

        public init(
            selectionCriteria: S3ControlClientTypes.StorageLensGroupLevelSelectionCriteria? = nil
        )
        {
            self.selectionCriteria = selectionCriteria
        }
    }

}

extension S3ControlClientTypes.StorageLensGroupLevelSelectionCriteria: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exclude = "Exclude"
        case include = "Include"
    }

    static func writingClosure(_ value: S3ControlClientTypes.StorageLensGroupLevelSelectionCriteria?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Exclude")].writeList(value.exclude, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: .init("Arn"), isFlattened: false)
        try writer[.init("Include")].writeList(value.include, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: .init("Arn"), isFlattened: false)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.include) {
            struct KeyVal0{struct Arn{}}
            let includeWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Arn>.CodingKeys.self, forKey: .include)
            if let includeWrappedContainer = includeWrappedContainer {
                let includeContainer = try includeWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var includeBuffer:[Swift.String]? = nil
                if let includeContainer = includeContainer {
                    includeBuffer = [Swift.String]()
                    for stringContainer0 in includeContainer {
                        includeBuffer?.append(stringContainer0)
                    }
                }
                include = includeBuffer
            } else {
                include = []
            }
        } else {
            include = nil
        }
        if containerValues.contains(.exclude) {
            struct KeyVal0{struct Arn{}}
            let excludeWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Arn>.CodingKeys.self, forKey: .exclude)
            if let excludeWrappedContainer = excludeWrappedContainer {
                let excludeContainer = try excludeWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var excludeBuffer:[Swift.String]? = nil
                if let excludeContainer = excludeContainer {
                    excludeBuffer = [Swift.String]()
                    for stringContainer0 in excludeContainer {
                        excludeBuffer?.append(stringContainer0)
                    }
                }
                exclude = excludeBuffer
            } else {
                exclude = []
            }
        } else {
            exclude = nil
        }
    }
}

extension S3ControlClientTypes {
    /// Indicates which Storage Lens group ARNs to include or exclude in the Storage Lens group aggregation. You can only attach Storage Lens groups to your Storage Lens dashboard if they're included in your Storage Lens group aggregation. If this value is left null, then all Storage Lens groups are selected.
    public struct StorageLensGroupLevelSelectionCriteria: Swift.Equatable {
        /// Indicates which Storage Lens group ARNs to exclude from the Storage Lens group aggregation.
        public var exclude: [Swift.String]?
        /// Indicates which Storage Lens group ARNs to include in the Storage Lens group aggregation.
        public var include: [Swift.String]?

        public init(
            exclude: [Swift.String]? = nil,
            include: [Swift.String]? = nil
        )
        {
            self.exclude = exclude
            self.include = include
        }
    }

}

extension S3ControlClientTypes.StorageLensGroupOrOperator: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case matchAnyPrefix = "MatchAnyPrefix"
        case matchAnySuffix = "MatchAnySuffix"
        case matchAnyTag = "MatchAnyTag"
        case matchObjectAge = "MatchObjectAge"
        case matchObjectSize = "MatchObjectSize"
    }

    static func writingClosure(_ value: S3ControlClientTypes.StorageLensGroupOrOperator?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("MatchAnyPrefix")].writeList(value.matchAnyPrefix, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: .init("Prefix"), isFlattened: false)
        try writer[.init("MatchAnySuffix")].writeList(value.matchAnySuffix, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: .init("Suffix"), isFlattened: false)
        try writer[.init("MatchAnyTag")].writeList(value.matchAnyTag, memberWritingClosure: S3ControlClientTypes.S3Tag.writingClosure(_:to:), memberNodeInfo: .init("Tag"), isFlattened: false)
        try writer[.init("MatchObjectAge")].write(value.matchObjectAge, writingClosure: S3ControlClientTypes.MatchObjectAge.writingClosure(_:to:))
        try writer[.init("MatchObjectSize")].write(value.matchObjectSize, writingClosure: S3ControlClientTypes.MatchObjectSize.writingClosure(_:to:))
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.matchAnyPrefix) {
            struct KeyVal0{struct Prefix{}}
            let matchAnyPrefixWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Prefix>.CodingKeys.self, forKey: .matchAnyPrefix)
            if let matchAnyPrefixWrappedContainer = matchAnyPrefixWrappedContainer {
                let matchAnyPrefixContainer = try matchAnyPrefixWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var matchAnyPrefixBuffer:[Swift.String]? = nil
                if let matchAnyPrefixContainer = matchAnyPrefixContainer {
                    matchAnyPrefixBuffer = [Swift.String]()
                    for stringContainer0 in matchAnyPrefixContainer {
                        matchAnyPrefixBuffer?.append(stringContainer0)
                    }
                }
                matchAnyPrefix = matchAnyPrefixBuffer
            } else {
                matchAnyPrefix = []
            }
        } else {
            matchAnyPrefix = nil
        }
        if containerValues.contains(.matchAnySuffix) {
            struct KeyVal0{struct Suffix{}}
            let matchAnySuffixWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Suffix>.CodingKeys.self, forKey: .matchAnySuffix)
            if let matchAnySuffixWrappedContainer = matchAnySuffixWrappedContainer {
                let matchAnySuffixContainer = try matchAnySuffixWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var matchAnySuffixBuffer:[Swift.String]? = nil
                if let matchAnySuffixContainer = matchAnySuffixContainer {
                    matchAnySuffixBuffer = [Swift.String]()
                    for stringContainer0 in matchAnySuffixContainer {
                        matchAnySuffixBuffer?.append(stringContainer0)
                    }
                }
                matchAnySuffix = matchAnySuffixBuffer
            } else {
                matchAnySuffix = []
            }
        } else {
            matchAnySuffix = nil
        }
        if containerValues.contains(.matchAnyTag) {
            struct KeyVal0{struct Tag{}}
            let matchAnyTagWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .matchAnyTag)
            if let matchAnyTagWrappedContainer = matchAnyTagWrappedContainer {
                let matchAnyTagContainer = try matchAnyTagWrappedContainer.decodeIfPresent([S3ControlClientTypes.S3Tag].self, forKey: .member)
                var matchAnyTagBuffer:[S3ControlClientTypes.S3Tag]? = nil
                if let matchAnyTagContainer = matchAnyTagContainer {
                    matchAnyTagBuffer = [S3ControlClientTypes.S3Tag]()
                    for structureContainer0 in matchAnyTagContainer {
                        matchAnyTagBuffer?.append(structureContainer0)
                    }
                }
                matchAnyTag = matchAnyTagBuffer
            } else {
                matchAnyTag = []
            }
        } else {
            matchAnyTag = nil
        }
        let matchObjectAgeDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.MatchObjectAge.self, forKey: .matchObjectAge)
        matchObjectAge = matchObjectAgeDecoded
        let matchObjectSizeDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.MatchObjectSize.self, forKey: .matchObjectSize)
        matchObjectSize = matchObjectSizeDecoded
    }
}

extension S3ControlClientTypes {
    /// A container element for specifying Or rule conditions. The rule conditions determine the subset of objects to which the Or rule applies. Objects can match any of the listed filter conditions, which are joined by the Or logical operator. Only one of each filter condition is allowed.
    public struct StorageLensGroupOrOperator: Swift.Equatable {
        /// Filters objects that match any of the specified prefixes.
        public var matchAnyPrefix: [Swift.String]?
        /// Filters objects that match any of the specified suffixes.
        public var matchAnySuffix: [Swift.String]?
        /// Filters objects that match any of the specified S3 object tags.
        public var matchAnyTag: [S3ControlClientTypes.S3Tag]?
        /// Filters objects that match the specified object age range.
        public var matchObjectAge: S3ControlClientTypes.MatchObjectAge?
        /// Filters objects that match the specified object size range.
        public var matchObjectSize: S3ControlClientTypes.MatchObjectSize?

        public init(
            matchAnyPrefix: [Swift.String]? = nil,
            matchAnySuffix: [Swift.String]? = nil,
            matchAnyTag: [S3ControlClientTypes.S3Tag]? = nil,
            matchObjectAge: S3ControlClientTypes.MatchObjectAge? = nil,
            matchObjectSize: S3ControlClientTypes.MatchObjectSize? = nil
        )
        {
            self.matchAnyPrefix = matchAnyPrefix
            self.matchAnySuffix = matchAnySuffix
            self.matchAnyTag = matchAnyTag
            self.matchObjectAge = matchObjectAge
            self.matchObjectSize = matchObjectSize
        }
    }

}

extension S3ControlClientTypes.StorageLensTag: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    static func writingClosure(_ value: S3ControlClientTypes.StorageLensTag?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Key")].write(value.key)
        try writer[.init("Value")].write(value.value)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension S3ControlClientTypes {
    ///
    public struct StorageLensTag: Swift.Equatable {
        ///
        /// This member is required.
        public var key: Swift.String?
        ///
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension SubmitMultiRegionAccessPointRoutesInput {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case routeUpdates = "RouteUpdates"
    }

    static func writingClosure(_ value: SubmitMultiRegionAccessPointRoutesInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("RouteUpdates")].writeList(value.routeUpdates, memberWritingClosure: S3ControlClientTypes.MultiRegionAccessPointRoute.writingClosure(_:to:), memberNodeInfo: .init("Route"), isFlattened: false)
    }
}

extension SubmitMultiRegionAccessPointRoutesInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension SubmitMultiRegionAccessPointRoutesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let mrap = mrap else {
            return nil
        }
        return "/v20180820/mrap/instances/\(mrap.urlPercentEncoding(encodeForwardSlash: false))/routes"
    }
}

public struct SubmitMultiRegionAccessPointRoutesInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the owner of the Multi-Region Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The Multi-Region Access Point ARN.
    /// This member is required.
    public var mrap: Swift.String?
    /// The different routes that make up the new route configuration. Active routes return a value of 100, and passive routes return a value of 0.
    /// This member is required.
    public var routeUpdates: [S3ControlClientTypes.MultiRegionAccessPointRoute]?

    public init(
        accountId: Swift.String? = nil,
        mrap: Swift.String? = nil,
        routeUpdates: [S3ControlClientTypes.MultiRegionAccessPointRoute]? = nil
    )
    {
        self.accountId = accountId
        self.mrap = mrap
        self.routeUpdates = routeUpdates
    }
}

struct SubmitMultiRegionAccessPointRoutesInputBody: Swift.Equatable {
    let routeUpdates: [S3ControlClientTypes.MultiRegionAccessPointRoute]?
}

extension SubmitMultiRegionAccessPointRoutesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case routeUpdates = "RouteUpdates"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.routeUpdates) {
            struct KeyVal0{struct Route{}}
            let routeUpdatesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Route>.CodingKeys.self, forKey: .routeUpdates)
            if let routeUpdatesWrappedContainer = routeUpdatesWrappedContainer {
                let routeUpdatesContainer = try routeUpdatesWrappedContainer.decodeIfPresent([S3ControlClientTypes.MultiRegionAccessPointRoute].self, forKey: .member)
                var routeUpdatesBuffer:[S3ControlClientTypes.MultiRegionAccessPointRoute]? = nil
                if let routeUpdatesContainer = routeUpdatesContainer {
                    routeUpdatesBuffer = [S3ControlClientTypes.MultiRegionAccessPointRoute]()
                    for structureContainer0 in routeUpdatesContainer {
                        routeUpdatesBuffer?.append(structureContainer0)
                    }
                }
                routeUpdates = routeUpdatesBuffer
            } else {
                routeUpdates = []
            }
        } else {
            routeUpdates = nil
        }
    }
}

extension SubmitMultiRegionAccessPointRoutesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct SubmitMultiRegionAccessPointRoutesOutput: Swift.Equatable {

    public init() { }
}

enum SubmitMultiRegionAccessPointRoutesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension S3ControlClientTypes.Tag: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    static func writingClosure(_ value: S3ControlClientTypes.Tag?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Key")].write(value.key)
        try writer[.init("Value")].write(value.value)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension S3ControlClientTypes {
    /// An Amazon Web Services resource tag that's associated with your S3 resource. You can add tags to new objects when you upload them, or you can add object tags to existing objects. This operation is only supported for [S3 Storage Lens groups](https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage-lens-groups.html) and for [S3 Access Grants](https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-grants-tagging.html). The tagged resource can be an S3 Storage Lens group or S3 Access Grants instance, registered location, or grant.
    public struct Tag: Swift.Equatable {
        /// The key of the key-value pair of a tag added to your Amazon Web Services resource. A tag key can be up to 128 Unicode characters in length and is case-sensitive. System created tags that begin with aws: aren’t supported.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the key-value pair of a tag added to your Amazon Web Services resource. A tag value can be up to 256 Unicode characters in length and is case-sensitive.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    static func writingClosure(_ value: TagResourceInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Tags")].writeList(value.tags, memberWritingClosure: S3ControlClientTypes.Tag.writingClosure(_:to:), memberNodeInfo: .init("Tag"), isFlattened: false)
    }
}

extension TagResourceInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/v20180820/tags/\(resourceArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Web Services account ID that created the S3 resource that you're trying to add tags to or the requester's account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The Amazon Resource Name (ARN) of the S3 resource that you're trying to add tags to. The tagged resource can be an S3 Storage Lens group or S3 Access Grants instance, registered location, or grant.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The Amazon Web Services resource tags that you want to add to the specified S3 resource.
    /// This member is required.
    public var tags: [S3ControlClientTypes.Tag]?

    public init(
        accountId: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        tags: [S3ControlClientTypes.Tag]? = nil
    )
    {
        self.accountId = accountId
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [S3ControlClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([S3ControlClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[S3ControlClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [S3ControlClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension S3ControlClientTypes.Tagging: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagSet = "TagSet"
    }

    static func writingClosure(_ value: S3ControlClientTypes.Tagging?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("TagSet")].writeList(value.tagSet, memberWritingClosure: S3ControlClientTypes.S3Tag.writingClosure(_:to:), memberNodeInfo: .init("member"), isFlattened: false)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.tagSet) {
            struct KeyVal0{struct member{}}
            let tagSetWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tagSet)
            if let tagSetWrappedContainer = tagSetWrappedContainer {
                let tagSetContainer = try tagSetWrappedContainer.decodeIfPresent([S3ControlClientTypes.S3Tag].self, forKey: .member)
                var tagSetBuffer:[S3ControlClientTypes.S3Tag]? = nil
                if let tagSetContainer = tagSetContainer {
                    tagSetBuffer = [S3ControlClientTypes.S3Tag]()
                    for structureContainer0 in tagSetContainer {
                        tagSetBuffer?.append(structureContainer0)
                    }
                }
                tagSet = tagSetBuffer
            } else {
                tagSet = []
            }
        } else {
            tagSet = nil
        }
    }
}

extension S3ControlClientTypes {
    ///
    public struct Tagging: Swift.Equatable {
        /// A collection for a set of tags.
        /// This member is required.
        public var tagSet: [S3ControlClientTypes.S3Tag]?

        public init(
            tagSet: [S3ControlClientTypes.S3Tag]? = nil
        )
        {
            self.tagSet = tagSet
        }
    }

}

extension TooManyRequestsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyRequestsExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyTagsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyTagsExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Amazon S3 throws this exception if you have too many tags in your tag set.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension S3ControlClientTypes.Transition: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case date = "Date"
        case days = "Days"
        case storageClass = "StorageClass"
    }

    static func writingClosure(_ value: S3ControlClientTypes.Transition?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("Date")].writeTimestamp(value.date, format: .dateTime)
        try writer[.init("Days")].write(value.days)
        try writer[.init("StorageClass")].write(value.storageClass)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .date)
        date = dateDecoded
        let daysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .days) ?? 0
        days = daysDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.TransitionStorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
    }
}

extension S3ControlClientTypes {
    /// Specifies when an object transitions to a specified storage class. For more information about Amazon S3 Lifecycle configuration rules, see [ Transitioning objects using Amazon S3 Lifecycle](https://docs.aws.amazon.com/AmazonS3/latest/dev/lifecycle-transition-general-considerations.html) in the Amazon S3 User Guide.
    public struct Transition: Swift.Equatable {
        /// Indicates when objects are transitioned to the specified storage class. The date value must be in ISO 8601 format. The time is always midnight UTC.
        public var date: ClientRuntime.Date?
        /// Indicates the number of days after creation when objects are transitioned to the specified storage class. The value must be a positive integer.
        public var days: Swift.Int
        /// The storage class to which you want the object to transition.
        public var storageClass: S3ControlClientTypes.TransitionStorageClass?

        public init(
            date: ClientRuntime.Date? = nil,
            days: Swift.Int = 0,
            storageClass: S3ControlClientTypes.TransitionStorageClass? = nil
        )
        {
            self.date = date
            self.days = days
            self.storageClass = storageClass
        }
    }

}

extension S3ControlClientTypes {
    public enum TransitionStorageClass: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deepArchive
        case glacier
        case intelligentTiering
        case onezoneIa
        case standardIa
        case sdkUnknown(Swift.String)

        public static var allCases: [TransitionStorageClass] {
            return [
                .deepArchive,
                .glacier,
                .intelligentTiering,
                .onezoneIa,
                .standardIa,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deepArchive: return "DEEP_ARCHIVE"
            case .glacier: return "GLACIER"
            case .intelligentTiering: return "INTELLIGENT_TIERING"
            case .onezoneIa: return "ONEZONE_IA"
            case .standardIa: return "STANDARD_IA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TransitionStorageClass(rawValue: rawValue) ?? TransitionStorageClass.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/v20180820/tags/\(resourceArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Web Services account ID that owns the resource that you're trying to remove the tags from.
    /// This member is required.
    public var accountId: Swift.String?
    /// The Amazon Resource Name (ARN) of the S3 resource that you're trying to remove the tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The array of tag key-value pairs that you're trying to remove from of the S3 resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        accountId: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.accountId = accountId
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension UpdateAccessGrantsLocationInput {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamRoleArn = "IAMRoleArn"
    }

    static func writingClosure(_ value: UpdateAccessGrantsLocationInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("IAMRoleArn")].write(value.iamRoleArn)
    }
}

extension UpdateAccessGrantsLocationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension UpdateAccessGrantsLocationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accessGrantsLocationId = accessGrantsLocationId else {
            return nil
        }
        return "/v20180820/accessgrantsinstance/location/\(accessGrantsLocationId.urlPercentEncoding())"
    }
}

public struct UpdateAccessGrantsLocationInput: Swift.Equatable {
    /// The ID of the registered location that you are updating. S3 Access Grants assigns this ID when you register the location. S3 Access Grants assigns the ID default to the default location s3:// and assigns an auto-generated ID to other locations that you register. The ID of the registered location to which you are granting access. S3 Access Grants assigned this ID when you registered the location. S3 Access Grants assigns the ID default to the default location s3:// and assigns an auto-generated ID to other locations that you register. If you are passing the default location, you cannot create an access grant for the entire default location. You must also specify a bucket or a bucket and prefix in the Subprefix field.
    /// This member is required.
    public var accessGrantsLocationId: Swift.String?
    /// The ID of the Amazon Web Services account that is making this request.
    /// This member is required.
    public var accountId: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role for the registered location. S3 Access Grants assumes this role to manage access to the registered location.
    /// This member is required.
    public var iamRoleArn: Swift.String?

    public init(
        accessGrantsLocationId: Swift.String? = nil,
        accountId: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil
    )
    {
        self.accessGrantsLocationId = accessGrantsLocationId
        self.accountId = accountId
        self.iamRoleArn = iamRoleArn
    }
}

struct UpdateAccessGrantsLocationInputBody: Swift.Equatable {
    let iamRoleArn: Swift.String?
}

extension UpdateAccessGrantsLocationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamRoleArn = "IAMRoleArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
    }
}

extension UpdateAccessGrantsLocationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAccessGrantsLocationOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessGrantsLocationArn = output.accessGrantsLocationArn
            self.accessGrantsLocationId = output.accessGrantsLocationId
            self.createdAt = output.createdAt
            self.iamRoleArn = output.iamRoleArn
            self.locationScope = output.locationScope
        } else {
            self.accessGrantsLocationArn = nil
            self.accessGrantsLocationId = nil
            self.createdAt = nil
            self.iamRoleArn = nil
            self.locationScope = nil
        }
    }
}

public struct UpdateAccessGrantsLocationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the registered location that you are updating.
    public var accessGrantsLocationArn: Swift.String?
    /// The ID of the registered location to which you are granting access. S3 Access Grants assigned this ID when you registered the location. S3 Access Grants assigns the ID default to the default location s3:// and assigns an auto-generated ID to other locations that you register.
    public var accessGrantsLocationId: Swift.String?
    /// The date and time when you registered the location.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the IAM role of the registered location. S3 Access Grants assumes this role to manage access to the registered location.
    public var iamRoleArn: Swift.String?
    /// The S3 URI path of the location that you are updating. You cannot update the scope of the registered location. The location scope can be the default S3 location s3://, the S3 path to a bucket s3://, or the S3 path to a bucket and prefix s3:///.
    public var locationScope: Swift.String?

    public init(
        accessGrantsLocationArn: Swift.String? = nil,
        accessGrantsLocationId: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        iamRoleArn: Swift.String? = nil,
        locationScope: Swift.String? = nil
    )
    {
        self.accessGrantsLocationArn = accessGrantsLocationArn
        self.accessGrantsLocationId = accessGrantsLocationId
        self.createdAt = createdAt
        self.iamRoleArn = iamRoleArn
        self.locationScope = locationScope
    }
}

struct UpdateAccessGrantsLocationOutputBody: Swift.Equatable {
    let createdAt: ClientRuntime.Date?
    let accessGrantsLocationId: Swift.String?
    let accessGrantsLocationArn: Swift.String?
    let locationScope: Swift.String?
    let iamRoleArn: Swift.String?
}

extension UpdateAccessGrantsLocationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessGrantsLocationArn = "AccessGrantsLocationArn"
        case accessGrantsLocationId = "AccessGrantsLocationId"
        case createdAt = "CreatedAt"
        case iamRoleArn = "IAMRoleArn"
        case locationScope = "LocationScope"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let accessGrantsLocationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessGrantsLocationId)
        accessGrantsLocationId = accessGrantsLocationIdDecoded
        let accessGrantsLocationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessGrantsLocationArn)
        accessGrantsLocationArn = accessGrantsLocationArnDecoded
        let locationScopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locationScope)
        locationScope = locationScopeDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
    }
}

enum UpdateAccessGrantsLocationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension UpdateJobPriorityInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension UpdateJobPriorityInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let priority = priority else {
                let message = "Creating a URL Query Item failed. priority is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let priorityQueryItem = ClientRuntime.URLQueryItem(name: "priority".urlPercentEncoding(), value: Swift.String(priority).urlPercentEncoding())
            items.append(priorityQueryItem)
            return items
        }
    }
}

extension UpdateJobPriorityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/v20180820/jobs/\(jobId.urlPercentEncoding())/priority"
    }
}

public struct UpdateJobPriorityInput: Swift.Equatable {
    /// The Amazon Web Services account ID associated with the S3 Batch Operations job.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID for the job whose priority you want to update.
    /// This member is required.
    public var jobId: Swift.String?
    /// The priority you want to assign to this job.
    /// This member is required.
    public var priority: Swift.Int?

    public init(
        accountId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        priority: Swift.Int? = nil
    )
    {
        self.accountId = accountId
        self.jobId = jobId
        self.priority = priority
    }
}

extension UpdateJobPriorityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateJobPriorityOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
            self.priority = output.priority
        } else {
            self.jobId = nil
            self.priority = 0
        }
    }
}

public struct UpdateJobPriorityOutput: Swift.Equatable {
    /// The ID for the job whose priority Amazon S3 updated.
    /// This member is required.
    public var jobId: Swift.String?
    /// The new priority assigned to the specified job.
    /// This member is required.
    public var priority: Swift.Int

    public init(
        jobId: Swift.String? = nil,
        priority: Swift.Int = 0
    )
    {
        self.jobId = jobId
        self.priority = priority
    }
}

struct UpdateJobPriorityOutputBody: Swift.Equatable {
    let jobId: Swift.String?
    let priority: Swift.Int
}

extension UpdateJobPriorityOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
        case priority = "Priority"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority) ?? 0
        priority = priorityDecoded
    }
}

enum UpdateJobPriorityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension UpdateJobStatusInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension UpdateJobStatusInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let statusUpdateReason = statusUpdateReason {
                let statusUpdateReasonQueryItem = ClientRuntime.URLQueryItem(name: "statusUpdateReason".urlPercentEncoding(), value: Swift.String(statusUpdateReason).urlPercentEncoding())
                items.append(statusUpdateReasonQueryItem)
            }
            guard let requestedJobStatus = requestedJobStatus else {
                let message = "Creating a URL Query Item failed. requestedJobStatus is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let requestedJobStatusQueryItem = ClientRuntime.URLQueryItem(name: "requestedJobStatus".urlPercentEncoding(), value: Swift.String(requestedJobStatus.rawValue).urlPercentEncoding())
            items.append(requestedJobStatusQueryItem)
            return items
        }
    }
}

extension UpdateJobStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/v20180820/jobs/\(jobId.urlPercentEncoding())/status"
    }
}

public struct UpdateJobStatusInput: Swift.Equatable {
    /// The Amazon Web Services account ID associated with the S3 Batch Operations job.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID of the job whose status you want to update.
    /// This member is required.
    public var jobId: Swift.String?
    /// The status that you want to move the specified job to.
    /// This member is required.
    public var requestedJobStatus: S3ControlClientTypes.RequestedJobStatus?
    /// A description of the reason why you want to change the specified job's status. This field can be any string up to the maximum length.
    public var statusUpdateReason: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        requestedJobStatus: S3ControlClientTypes.RequestedJobStatus? = nil,
        statusUpdateReason: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.jobId = jobId
        self.requestedJobStatus = requestedJobStatus
        self.statusUpdateReason = statusUpdateReason
    }
}

extension UpdateJobStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateJobStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
            self.status = output.status
            self.statusUpdateReason = output.statusUpdateReason
        } else {
            self.jobId = nil
            self.status = nil
            self.statusUpdateReason = nil
        }
    }
}

public struct UpdateJobStatusOutput: Swift.Equatable {
    /// The ID for the job whose status was updated.
    public var jobId: Swift.String?
    /// The current status for the specified job.
    public var status: S3ControlClientTypes.JobStatus?
    /// The reason that the specified job's status was updated.
    public var statusUpdateReason: Swift.String?

    public init(
        jobId: Swift.String? = nil,
        status: S3ControlClientTypes.JobStatus? = nil,
        statusUpdateReason: Swift.String? = nil
    )
    {
        self.jobId = jobId
        self.status = status
        self.statusUpdateReason = statusUpdateReason
    }
}

struct UpdateJobStatusOutputBody: Swift.Equatable {
    let jobId: Swift.String?
    let status: S3ControlClientTypes.JobStatus?
    let statusUpdateReason: Swift.String?
}

extension UpdateJobStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
        case status = "Status"
        case statusUpdateReason = "StatusUpdateReason"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
        let statusUpdateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusUpdateReason)
        statusUpdateReason = statusUpdateReasonDecoded
    }
}

enum UpdateJobStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "JobStatusException": return try await JobStatusException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension UpdateStorageLensGroupInput {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case storageLensGroup = "StorageLensGroup"
    }

    static func writingClosure(_ value: UpdateStorageLensGroupInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("StorageLensGroup")].write(value.storageLensGroup, writingClosure: S3ControlClientTypes.StorageLensGroup.writingClosure(_:to:))
    }
}

extension UpdateStorageLensGroupInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension UpdateStorageLensGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v20180820/storagelensgroup/\(name.urlPercentEncoding())"
    }
}

public struct UpdateStorageLensGroupInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Storage Lens group owner.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the Storage Lens group that you want to update.
    /// This member is required.
    public var name: Swift.String?
    /// The JSON file that contains the Storage Lens group configuration.
    /// This member is required.
    public var storageLensGroup: S3ControlClientTypes.StorageLensGroup?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil,
        storageLensGroup: S3ControlClientTypes.StorageLensGroup? = nil
    )
    {
        self.accountId = accountId
        self.name = name
        self.storageLensGroup = storageLensGroup
    }
}

struct UpdateStorageLensGroupInputBody: Swift.Equatable {
    let storageLensGroup: S3ControlClientTypes.StorageLensGroup?
}

extension UpdateStorageLensGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case storageLensGroup = "StorageLensGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageLensGroupDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.StorageLensGroup.self, forKey: .storageLensGroup)
        storageLensGroup = storageLensGroupDecoded
    }
}

extension UpdateStorageLensGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateStorageLensGroupOutput: Swift.Equatable {

    public init() { }
}

enum UpdateStorageLensGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension S3ControlClientTypes.VersioningConfiguration: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mfaDelete = "MfaDelete"
        case status = "Status"
    }

    static func writingClosure(_ value: S3ControlClientTypes.VersioningConfiguration?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("MfaDelete")].write(value.mfaDelete)
        try writer[.init("Status")].write(value.status)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mfaDeleteDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.MFADelete.self, forKey: .mfaDelete)
        mfaDelete = mfaDeleteDecoded
        let statusDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.BucketVersioningStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension S3ControlClientTypes {
    /// Describes the versioning state of an Amazon S3 on Outposts bucket. For more information, see [PutBucketVersioning](https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_PutBucketVersioning.html).
    public struct VersioningConfiguration: Swift.Equatable {
        /// Specifies whether MFA delete is enabled or disabled in the bucket versioning configuration for the S3 on Outposts bucket.
        public var mfaDelete: S3ControlClientTypes.MFADelete?
        /// Sets the versioning state of the S3 on Outposts bucket.
        public var status: S3ControlClientTypes.BucketVersioningStatus?

        public init(
            mfaDelete: S3ControlClientTypes.MFADelete? = nil,
            status: S3ControlClientTypes.BucketVersioningStatus? = nil
        )
        {
            self.mfaDelete = mfaDelete
            self.status = status
        }
    }

}

extension S3ControlClientTypes.VpcConfiguration: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcId = "VpcId"
    }

    static func writingClosure(_ value: S3ControlClientTypes.VpcConfiguration?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer[.init("VpcId")].write(value.vpcId)
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension S3ControlClientTypes {
    /// The virtual private cloud (VPC) configuration for an access point.
    public struct VpcConfiguration: Swift.Equatable {
        /// If this field is specified, this access point will only allow connections from the specified VPC ID.
        /// This member is required.
        public var vpcId: Swift.String?

        public init(
            vpcId: Swift.String? = nil
        )
        {
            self.vpcId = vpcId
        }
    }

}
