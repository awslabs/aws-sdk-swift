// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime
import SmithyReadWrite
import SmithyXML

extension S3ControlClientTypes.AbortIncompleteMultipartUpload {

    static func writingClosure(_ value: S3ControlClientTypes.AbortIncompleteMultipartUpload?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["DaysAfterInitiation"].write(value.daysAfterInitiation)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.AbortIncompleteMultipartUpload, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.AbortIncompleteMultipartUpload()
            value.daysAfterInitiation = try reader["DaysAfterInitiation"].readIfPresent() ?? 0
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// The container for abort incomplete multipart upload
    public struct AbortIncompleteMultipartUpload: Swift.Equatable {
        /// Specifies the number of days after which Amazon S3 aborts an incomplete multipart upload to the Outposts bucket.
        public var daysAfterInitiation: Swift.Int

        public init(
            daysAfterInitiation: Swift.Int = 0
        )
        {
            self.daysAfterInitiation = daysAfterInitiation
        }
    }

}

extension S3ControlClientTypes.AccessControlTranslation {

    static func writingClosure(_ value: S3ControlClientTypes.AccessControlTranslation?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Owner"].write(value.owner)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.AccessControlTranslation, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.AccessControlTranslation()
            value.owner = try reader["Owner"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// A container for information about access control for replicas. This is not supported by Amazon S3 on Outposts buckets.
    public struct AccessControlTranslation: Swift.Equatable {
        /// Specifies the replica ownership.
        /// This member is required.
        public var owner: S3ControlClientTypes.OwnerOverride?

        public init(
            owner: S3ControlClientTypes.OwnerOverride? = nil
        )
        {
            self.owner = owner
        }
    }

}

extension S3ControlClientTypes.AccessGrantsLocationConfiguration {

    static func writingClosure(_ value: S3ControlClientTypes.AccessGrantsLocationConfiguration?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["S3SubPrefix"].write(value.s3SubPrefix)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.AccessGrantsLocationConfiguration, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.AccessGrantsLocationConfiguration()
            value.s3SubPrefix = try reader["S3SubPrefix"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// The configuration options of the S3 Access Grants location. It contains the S3SubPrefix field. The grant scope, the data to which you are granting access, is the result of appending the Subprefix field to the scope of the registered location.
    public struct AccessGrantsLocationConfiguration: Swift.Equatable {
        /// The S3SubPrefix is appended to the location scope creating the grant scope. Use this field to narrow the scope of the grant to a subset of the location scope. This field is required if the location scope is the default location s3:// because you cannot create a grant for all of your S3 data in the Region and must narrow the scope. For example, if the location scope is the default location s3://, the S3SubPrefx can be a /*, so the full grant scope path would be s3:///*. Or the S3SubPrefx can be /*, so the full grant scope path would be or s3:///*. If the S3SubPrefix includes a prefix, append the wildcard character * after the prefix to indicate that you want to include all object key names in the bucket that start with that prefix.
        public var s3SubPrefix: Swift.String?

        public init(
            s3SubPrefix: Swift.String? = nil
        )
        {
            self.s3SubPrefix = s3SubPrefix
        }
    }

}

extension S3ControlClientTypes.AccessPoint {

    static func writingClosure(_ value: S3ControlClientTypes.AccessPoint?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["AccessPointArn"].write(value.accessPointArn)
        try writer["Alias"].write(value.alias)
        try writer["Bucket"].write(value.bucket)
        try writer["BucketAccountId"].write(value.bucketAccountId)
        try writer["Name"].write(value.name)
        try writer["NetworkOrigin"].write(value.networkOrigin)
        try writer["VpcConfiguration"].write(value.vpcConfiguration, writingClosure: S3ControlClientTypes.VpcConfiguration.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.AccessPoint, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.AccessPoint()
            value.name = try reader["Name"].readIfPresent()
            value.networkOrigin = try reader["NetworkOrigin"].readIfPresent()
            value.vpcConfiguration = try reader["VpcConfiguration"].readIfPresent(readingClosure: S3ControlClientTypes.VpcConfiguration.readingClosure)
            value.bucket = try reader["Bucket"].readIfPresent()
            value.accessPointArn = try reader["AccessPointArn"].readIfPresent()
            value.alias = try reader["Alias"].readIfPresent()
            value.bucketAccountId = try reader["BucketAccountId"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// An access point used to access a bucket.
    public struct AccessPoint: Swift.Equatable {
        /// The ARN for the access point.
        public var accessPointArn: Swift.String?
        /// The name or alias of the access point.
        public var alias: Swift.String?
        /// The name of the bucket associated with this access point.
        /// This member is required.
        public var bucket: Swift.String?
        /// The Amazon Web Services account ID associated with the S3 bucket associated with this access point.
        public var bucketAccountId: Swift.String?
        /// The name of this access point.
        /// This member is required.
        public var name: Swift.String?
        /// Indicates whether this access point allows access from the public internet. If VpcConfiguration is specified for this access point, then NetworkOrigin is VPC, and the access point doesn't allow access from the public internet. Otherwise, NetworkOrigin is Internet, and the access point allows access from the public internet, subject to the access point and bucket access policies.
        /// This member is required.
        public var networkOrigin: S3ControlClientTypes.NetworkOrigin?
        /// The virtual private cloud (VPC) configuration for this access point, if one exists. This element is empty if this access point is an Amazon S3 on Outposts access point that is used by other Amazon Web Services.
        public var vpcConfiguration: S3ControlClientTypes.VpcConfiguration?

        public init(
            accessPointArn: Swift.String? = nil,
            alias: Swift.String? = nil,
            bucket: Swift.String? = nil,
            bucketAccountId: Swift.String? = nil,
            name: Swift.String? = nil,
            networkOrigin: S3ControlClientTypes.NetworkOrigin? = nil,
            vpcConfiguration: S3ControlClientTypes.VpcConfiguration? = nil
        )
        {
            self.accessPointArn = accessPointArn
            self.alias = alias
            self.bucket = bucket
            self.bucketAccountId = bucketAccountId
            self.name = name
            self.networkOrigin = networkOrigin
            self.vpcConfiguration = vpcConfiguration
        }
    }

}

extension S3ControlClientTypes.AccountLevel {

    static func writingClosure(_ value: S3ControlClientTypes.AccountLevel?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ActivityMetrics"].write(value.activityMetrics, writingClosure: S3ControlClientTypes.ActivityMetrics.writingClosure(_:to:))
        try writer["AdvancedCostOptimizationMetrics"].write(value.advancedCostOptimizationMetrics, writingClosure: S3ControlClientTypes.AdvancedCostOptimizationMetrics.writingClosure(_:to:))
        try writer["AdvancedDataProtectionMetrics"].write(value.advancedDataProtectionMetrics, writingClosure: S3ControlClientTypes.AdvancedDataProtectionMetrics.writingClosure(_:to:))
        try writer["BucketLevel"].write(value.bucketLevel, writingClosure: S3ControlClientTypes.BucketLevel.writingClosure(_:to:))
        try writer["DetailedStatusCodesMetrics"].write(value.detailedStatusCodesMetrics, writingClosure: S3ControlClientTypes.DetailedStatusCodesMetrics.writingClosure(_:to:))
        try writer["StorageLensGroupLevel"].write(value.storageLensGroupLevel, writingClosure: S3ControlClientTypes.StorageLensGroupLevel.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.AccountLevel, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.AccountLevel()
            value.activityMetrics = try reader["ActivityMetrics"].readIfPresent(readingClosure: S3ControlClientTypes.ActivityMetrics.readingClosure)
            value.bucketLevel = try reader["BucketLevel"].readIfPresent(readingClosure: S3ControlClientTypes.BucketLevel.readingClosure)
            value.advancedCostOptimizationMetrics = try reader["AdvancedCostOptimizationMetrics"].readIfPresent(readingClosure: S3ControlClientTypes.AdvancedCostOptimizationMetrics.readingClosure)
            value.advancedDataProtectionMetrics = try reader["AdvancedDataProtectionMetrics"].readIfPresent(readingClosure: S3ControlClientTypes.AdvancedDataProtectionMetrics.readingClosure)
            value.detailedStatusCodesMetrics = try reader["DetailedStatusCodesMetrics"].readIfPresent(readingClosure: S3ControlClientTypes.DetailedStatusCodesMetrics.readingClosure)
            value.storageLensGroupLevel = try reader["StorageLensGroupLevel"].readIfPresent(readingClosure: S3ControlClientTypes.StorageLensGroupLevel.readingClosure)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// A container element for the account-level Amazon S3 Storage Lens configuration. For more information about S3 Storage Lens, see [Assessing your storage activity and usage with S3 Storage Lens](https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage_lens.html) in the Amazon S3 User Guide. For a complete list of S3 Storage Lens metrics, see [S3 Storage Lens metrics glossary](https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage_lens_metrics_glossary.html) in the Amazon S3 User Guide.
    public struct AccountLevel: Swift.Equatable {
        /// A container element for S3 Storage Lens activity metrics.
        public var activityMetrics: S3ControlClientTypes.ActivityMetrics?
        /// A container element for S3 Storage Lens advanced cost-optimization metrics.
        public var advancedCostOptimizationMetrics: S3ControlClientTypes.AdvancedCostOptimizationMetrics?
        /// A container element for S3 Storage Lens advanced data-protection metrics.
        public var advancedDataProtectionMetrics: S3ControlClientTypes.AdvancedDataProtectionMetrics?
        /// A container element for the S3 Storage Lens bucket-level configuration.
        /// This member is required.
        public var bucketLevel: S3ControlClientTypes.BucketLevel?
        /// A container element for detailed status code metrics.
        public var detailedStatusCodesMetrics: S3ControlClientTypes.DetailedStatusCodesMetrics?
        /// A container element for S3 Storage Lens groups metrics.
        public var storageLensGroupLevel: S3ControlClientTypes.StorageLensGroupLevel?

        public init(
            activityMetrics: S3ControlClientTypes.ActivityMetrics? = nil,
            advancedCostOptimizationMetrics: S3ControlClientTypes.AdvancedCostOptimizationMetrics? = nil,
            advancedDataProtectionMetrics: S3ControlClientTypes.AdvancedDataProtectionMetrics? = nil,
            bucketLevel: S3ControlClientTypes.BucketLevel? = nil,
            detailedStatusCodesMetrics: S3ControlClientTypes.DetailedStatusCodesMetrics? = nil,
            storageLensGroupLevel: S3ControlClientTypes.StorageLensGroupLevel? = nil
        )
        {
            self.activityMetrics = activityMetrics
            self.advancedCostOptimizationMetrics = advancedCostOptimizationMetrics
            self.advancedDataProtectionMetrics = advancedDataProtectionMetrics
            self.bucketLevel = bucketLevel
            self.detailedStatusCodesMetrics = detailedStatusCodesMetrics
            self.storageLensGroupLevel = storageLensGroupLevel
        }
    }

}

extension S3ControlClientTypes.ActivityMetrics {

    static func writingClosure(_ value: S3ControlClientTypes.ActivityMetrics?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["IsEnabled"].write(value.isEnabled)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.ActivityMetrics, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.ActivityMetrics()
            value.isEnabled = try reader["IsEnabled"].readIfPresent() ?? false
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// The container element for Amazon S3 Storage Lens activity metrics. Activity metrics show details about how your storage is requested, such as requests (for example, All requests, Get requests, Put requests), bytes uploaded or downloaded, and errors. For more information about S3 Storage Lens, see [Assessing your storage activity and usage with S3 Storage Lens](https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage_lens.html) in the Amazon S3 User Guide. For a complete list of S3 Storage Lens metrics, see [S3 Storage Lens metrics glossary](https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage_lens_metrics_glossary.html) in the Amazon S3 User Guide.
    public struct ActivityMetrics: Swift.Equatable {
        /// A container that indicates whether activity metrics are enabled.
        public var isEnabled: Swift.Bool

        public init(
            isEnabled: Swift.Bool = false
        )
        {
            self.isEnabled = isEnabled
        }
    }

}

extension S3ControlClientTypes.AdvancedCostOptimizationMetrics {

    static func writingClosure(_ value: S3ControlClientTypes.AdvancedCostOptimizationMetrics?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["IsEnabled"].write(value.isEnabled)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.AdvancedCostOptimizationMetrics, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.AdvancedCostOptimizationMetrics()
            value.isEnabled = try reader["IsEnabled"].readIfPresent() ?? false
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// The container element for Amazon S3 Storage Lens advanced cost-optimization metrics. Advanced cost-optimization metrics provide insights that you can use to manage and optimize your storage costs, for example, lifecycle rule counts for transitions, expirations, and incomplete multipart uploads. For more information about S3 Storage Lens, see [Assessing your storage activity and usage with S3 Storage Lens](https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage_lens.html) in the Amazon S3 User Guide. For a complete list of S3 Storage Lens metrics, see [S3 Storage Lens metrics glossary](https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage_lens_metrics_glossary.html) in the Amazon S3 User Guide.
    public struct AdvancedCostOptimizationMetrics: Swift.Equatable {
        /// A container that indicates whether advanced cost-optimization metrics are enabled.
        public var isEnabled: Swift.Bool

        public init(
            isEnabled: Swift.Bool = false
        )
        {
            self.isEnabled = isEnabled
        }
    }

}

extension S3ControlClientTypes.AdvancedDataProtectionMetrics {

    static func writingClosure(_ value: S3ControlClientTypes.AdvancedDataProtectionMetrics?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["IsEnabled"].write(value.isEnabled)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.AdvancedDataProtectionMetrics, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.AdvancedDataProtectionMetrics()
            value.isEnabled = try reader["IsEnabled"].readIfPresent() ?? false
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// The container element for Amazon S3 Storage Lens advanced data-protection metrics. Advanced data-protection metrics provide insights that you can use to perform audits and protect your data, for example replication rule counts within and across Regions. For more information about S3 Storage Lens, see [Assessing your storage activity and usage with S3 Storage Lens](https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage_lens.html) in the Amazon S3 User Guide. For a complete list of S3 Storage Lens metrics, see [S3 Storage Lens metrics glossary](https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage_lens_metrics_glossary.html) in the Amazon S3 User Guide.
    public struct AdvancedDataProtectionMetrics: Swift.Equatable {
        /// A container that indicates whether advanced data-protection metrics are enabled.
        public var isEnabled: Swift.Bool

        public init(
            isEnabled: Swift.Bool = false
        )
        {
            self.isEnabled = isEnabled
        }
    }

}

extension AssociateAccessGrantsIdentityCenterInput {
    static func writingClosure(_ value: AssociateAccessGrantsIdentityCenterInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["IdentityCenterArn"].write(value.identityCenterArn)
    }
}

extension AssociateAccessGrantsIdentityCenterInput {

    static func headerProvider(_ value: AssociateAccessGrantsIdentityCenterInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension AssociateAccessGrantsIdentityCenterInput {

    static func urlPathProvider(_ value: AssociateAccessGrantsIdentityCenterInput) -> Swift.String? {
        return "/v20180820/accessgrantsinstance/identitycenter"
    }
}

public struct AssociateAccessGrantsIdentityCenterInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that is making this request.
    /// This member is required.
    public var accountId: Swift.String?
    /// The Amazon Resource Name (ARN) of the Amazon Web Services IAM Identity Center instance that you are associating with your S3 Access Grants instance. An IAM Identity Center instance is your corporate identity directory that you added to the IAM Identity Center. You can use the [ListInstances](https://docs.aws.amazon.com/singlesignon/latest/APIReference/API_ListInstances.html) API operation to retrieve a list of your Identity Center instances and their ARNs.
    /// This member is required.
    public var identityCenterArn: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        identityCenterArn: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.identityCenterArn = identityCenterArn
    }
}

extension AssociateAccessGrantsIdentityCenterOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<AssociateAccessGrantsIdentityCenterOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return AssociateAccessGrantsIdentityCenterOutput()
        }
    }
}

public struct AssociateAccessGrantsIdentityCenterOutput: Swift.Equatable {

    public init() { }
}

enum AssociateAccessGrantsIdentityCenterOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension S3ControlClientTypes.AsyncErrorDetails {

    static func writingClosure(_ value: S3ControlClientTypes.AsyncErrorDetails?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Code"].write(value.code)
        try writer["Message"].write(value.message)
        try writer["RequestId"].write(value.requestId)
        try writer["Resource"].write(value.resource)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.AsyncErrorDetails, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.AsyncErrorDetails()
            value.code = try reader["Code"].readIfPresent()
            value.message = try reader["Message"].readIfPresent()
            value.resource = try reader["Resource"].readIfPresent()
            value.requestId = try reader["RequestId"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// Error details for the failed asynchronous operation.
    public struct AsyncErrorDetails: Swift.Equatable {
        /// A string that uniquely identifies the error condition.
        public var code: Swift.String?
        /// A generic description of the error condition in English.
        public var message: Swift.String?
        /// The ID of the request associated with the error.
        public var requestId: Swift.String?
        /// The identifier of the resource associated with the error.
        public var resource: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil,
            requestId: Swift.String? = nil,
            resource: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
            self.requestId = requestId
            self.resource = resource
        }
    }

}

extension S3ControlClientTypes.AsyncOperation {

    static func writingClosure(_ value: S3ControlClientTypes.AsyncOperation?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["CreationTime"].writeTimestamp(value.creationTime, format: .dateTime)
        try writer["Operation"].write(value.operation)
        try writer["RequestParameters"].write(value.requestParameters, writingClosure: S3ControlClientTypes.AsyncRequestParameters.writingClosure(_:to:))
        try writer["RequestStatus"].write(value.requestStatus)
        try writer["RequestTokenARN"].write(value.requestTokenARN)
        try writer["ResponseDetails"].write(value.responseDetails, writingClosure: S3ControlClientTypes.AsyncResponseDetails.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.AsyncOperation, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.AsyncOperation()
            value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: .dateTime)
            value.operation = try reader["Operation"].readIfPresent()
            value.requestTokenARN = try reader["RequestTokenARN"].readIfPresent()
            value.requestParameters = try reader["RequestParameters"].readIfPresent(readingClosure: S3ControlClientTypes.AsyncRequestParameters.readingClosure)
            value.requestStatus = try reader["RequestStatus"].readIfPresent()
            value.responseDetails = try reader["ResponseDetails"].readIfPresent(readingClosure: S3ControlClientTypes.AsyncResponseDetails.readingClosure)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// A container for the information about an asynchronous operation.
    public struct AsyncOperation: Swift.Equatable {
        /// The time that the request was sent to the service.
        public var creationTime: ClientRuntime.Date?
        /// The specific operation for the asynchronous request.
        public var operation: S3ControlClientTypes.AsyncOperationName?
        /// The parameters associated with the request.
        public var requestParameters: S3ControlClientTypes.AsyncRequestParameters?
        /// The current status of the request.
        public var requestStatus: Swift.String?
        /// The request token associated with the request.
        public var requestTokenARN: Swift.String?
        /// The details of the response.
        public var responseDetails: S3ControlClientTypes.AsyncResponseDetails?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            operation: S3ControlClientTypes.AsyncOperationName? = nil,
            requestParameters: S3ControlClientTypes.AsyncRequestParameters? = nil,
            requestStatus: Swift.String? = nil,
            requestTokenARN: Swift.String? = nil,
            responseDetails: S3ControlClientTypes.AsyncResponseDetails? = nil
        )
        {
            self.creationTime = creationTime
            self.operation = operation
            self.requestParameters = requestParameters
            self.requestStatus = requestStatus
            self.requestTokenARN = requestTokenARN
            self.responseDetails = responseDetails
        }
    }

}

extension S3ControlClientTypes {
    public enum AsyncOperationName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createmultiregionaccesspoint
        case deletemultiregionaccesspoint
        case putmultiregionaccesspointpolicy
        case sdkUnknown(Swift.String)

        public static var allCases: [AsyncOperationName] {
            return [
                .createmultiregionaccesspoint,
                .deletemultiregionaccesspoint,
                .putmultiregionaccesspointpolicy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createmultiregionaccesspoint: return "CreateMultiRegionAccessPoint"
            case .deletemultiregionaccesspoint: return "DeleteMultiRegionAccessPoint"
            case .putmultiregionaccesspointpolicy: return "PutMultiRegionAccessPointPolicy"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AsyncOperationName(rawValue: rawValue) ?? AsyncOperationName.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.AsyncRequestParameters {

    static func writingClosure(_ value: S3ControlClientTypes.AsyncRequestParameters?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["CreateMultiRegionAccessPointRequest"].write(value.createMultiRegionAccessPointRequest, writingClosure: S3ControlClientTypes.CreateMultiRegionAccessPointInput.writingClosure(_:to:))
        try writer["DeleteMultiRegionAccessPointRequest"].write(value.deleteMultiRegionAccessPointRequest, writingClosure: S3ControlClientTypes.DeleteMultiRegionAccessPointInput.writingClosure(_:to:))
        try writer["PutMultiRegionAccessPointPolicyRequest"].write(value.putMultiRegionAccessPointPolicyRequest, writingClosure: S3ControlClientTypes.PutMultiRegionAccessPointPolicyInput.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.AsyncRequestParameters, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.AsyncRequestParameters()
            value.createMultiRegionAccessPointRequest = try reader["CreateMultiRegionAccessPointRequest"].readIfPresent(readingClosure: S3ControlClientTypes.CreateMultiRegionAccessPointInput.readingClosure)
            value.deleteMultiRegionAccessPointRequest = try reader["DeleteMultiRegionAccessPointRequest"].readIfPresent(readingClosure: S3ControlClientTypes.DeleteMultiRegionAccessPointInput.readingClosure)
            value.putMultiRegionAccessPointPolicyRequest = try reader["PutMultiRegionAccessPointPolicyRequest"].readIfPresent(readingClosure: S3ControlClientTypes.PutMultiRegionAccessPointPolicyInput.readingClosure)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// A container for the request parameters associated with an asynchronous request.
    public struct AsyncRequestParameters: Swift.Equatable {
        /// A container of the parameters for a [CreateMultiRegionAccessPoint](https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_CreateMultiRegionAccessPoint.html) request.
        public var createMultiRegionAccessPointRequest: S3ControlClientTypes.CreateMultiRegionAccessPointInput?
        /// A container of the parameters for a [DeleteMultiRegionAccessPoint](https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_DeleteMultiRegionAccessPoint.html) request.
        public var deleteMultiRegionAccessPointRequest: S3ControlClientTypes.DeleteMultiRegionAccessPointInput?
        /// A container of the parameters for a [PutMultiRegionAccessPoint](https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_PutMultiRegionAccessPoint.html) request.
        public var putMultiRegionAccessPointPolicyRequest: S3ControlClientTypes.PutMultiRegionAccessPointPolicyInput?

        public init(
            createMultiRegionAccessPointRequest: S3ControlClientTypes.CreateMultiRegionAccessPointInput? = nil,
            deleteMultiRegionAccessPointRequest: S3ControlClientTypes.DeleteMultiRegionAccessPointInput? = nil,
            putMultiRegionAccessPointPolicyRequest: S3ControlClientTypes.PutMultiRegionAccessPointPolicyInput? = nil
        )
        {
            self.createMultiRegionAccessPointRequest = createMultiRegionAccessPointRequest
            self.deleteMultiRegionAccessPointRequest = deleteMultiRegionAccessPointRequest
            self.putMultiRegionAccessPointPolicyRequest = putMultiRegionAccessPointPolicyRequest
        }
    }

}

extension S3ControlClientTypes.AsyncResponseDetails {

    static func writingClosure(_ value: S3ControlClientTypes.AsyncResponseDetails?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ErrorDetails"].write(value.errorDetails, writingClosure: S3ControlClientTypes.AsyncErrorDetails.writingClosure(_:to:))
        try writer["MultiRegionAccessPointDetails"].write(value.multiRegionAccessPointDetails, writingClosure: S3ControlClientTypes.MultiRegionAccessPointsAsyncResponse.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.AsyncResponseDetails, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.AsyncResponseDetails()
            value.multiRegionAccessPointDetails = try reader["MultiRegionAccessPointDetails"].readIfPresent(readingClosure: S3ControlClientTypes.MultiRegionAccessPointsAsyncResponse.readingClosure)
            value.errorDetails = try reader["ErrorDetails"].readIfPresent(readingClosure: S3ControlClientTypes.AsyncErrorDetails.readingClosure)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// A container for the response details that are returned when querying about an asynchronous request.
    public struct AsyncResponseDetails: Swift.Equatable {
        /// Error details for an asynchronous request.
        public var errorDetails: S3ControlClientTypes.AsyncErrorDetails?
        /// The details for the Multi-Region Access Point.
        public var multiRegionAccessPointDetails: S3ControlClientTypes.MultiRegionAccessPointsAsyncResponse?

        public init(
            errorDetails: S3ControlClientTypes.AsyncErrorDetails? = nil,
            multiRegionAccessPointDetails: S3ControlClientTypes.MultiRegionAccessPointsAsyncResponse? = nil
        )
        {
            self.errorDetails = errorDetails
            self.multiRegionAccessPointDetails = multiRegionAccessPointDetails
        }
    }

}

extension S3ControlClientTypes.AwsLambdaTransformation {

    static func writingClosure(_ value: S3ControlClientTypes.AwsLambdaTransformation?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["FunctionArn"].write(value.functionArn)
        try writer["FunctionPayload"].write(value.functionPayload)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.AwsLambdaTransformation, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.AwsLambdaTransformation()
            value.functionArn = try reader["FunctionArn"].readIfPresent()
            value.functionPayload = try reader["FunctionPayload"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// Lambda function used to transform objects through an Object Lambda Access Point.
    public struct AwsLambdaTransformation: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Lambda function.
        /// This member is required.
        public var functionArn: Swift.String?
        /// Additional JSON that provides supplemental data to the Lambda function used to transform objects.
        public var functionPayload: Swift.String?

        public init(
            functionArn: Swift.String? = nil,
            functionPayload: Swift.String? = nil
        )
        {
            self.functionArn = functionArn
            self.functionPayload = functionPayload
        }
    }

}

extension BadRequestException {

    static var readingClosure: SmithyReadWrite.ReadingClosure<BadRequestException, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = BadRequestException()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension BadRequestException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = BadRequestException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

///
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension BucketAlreadyExists {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = BucketAlreadyExists()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The requested Outposts bucket name is not available. The bucket namespace is shared by all users of the Outposts in this Region. Select a different name and try again.
public struct BucketAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {
    public static var typeName: Swift.String { "BucketAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init() { }
}

extension BucketAlreadyOwnedByYou {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = BucketAlreadyOwnedByYou()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The Outposts bucket you tried to create already exists, and you own it.
public struct BucketAlreadyOwnedByYou: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {
    public static var typeName: Swift.String { "BucketAlreadyOwnedByYou" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init() { }
}

extension S3ControlClientTypes {
    public enum BucketCannedACL: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case authenticatedRead
        case `private`
        case publicRead
        case publicReadWrite
        case sdkUnknown(Swift.String)

        public static var allCases: [BucketCannedACL] {
            return [
                .authenticatedRead,
                .private,
                .publicRead,
                .publicReadWrite,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .authenticatedRead: return "authenticated-read"
            case .private: return "private"
            case .publicRead: return "public-read"
            case .publicReadWrite: return "public-read-write"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BucketCannedACL(rawValue: rawValue) ?? BucketCannedACL.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.BucketLevel {

    static func writingClosure(_ value: S3ControlClientTypes.BucketLevel?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ActivityMetrics"].write(value.activityMetrics, writingClosure: S3ControlClientTypes.ActivityMetrics.writingClosure(_:to:))
        try writer["AdvancedCostOptimizationMetrics"].write(value.advancedCostOptimizationMetrics, writingClosure: S3ControlClientTypes.AdvancedCostOptimizationMetrics.writingClosure(_:to:))
        try writer["AdvancedDataProtectionMetrics"].write(value.advancedDataProtectionMetrics, writingClosure: S3ControlClientTypes.AdvancedDataProtectionMetrics.writingClosure(_:to:))
        try writer["DetailedStatusCodesMetrics"].write(value.detailedStatusCodesMetrics, writingClosure: S3ControlClientTypes.DetailedStatusCodesMetrics.writingClosure(_:to:))
        try writer["PrefixLevel"].write(value.prefixLevel, writingClosure: S3ControlClientTypes.PrefixLevel.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.BucketLevel, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.BucketLevel()
            value.activityMetrics = try reader["ActivityMetrics"].readIfPresent(readingClosure: S3ControlClientTypes.ActivityMetrics.readingClosure)
            value.prefixLevel = try reader["PrefixLevel"].readIfPresent(readingClosure: S3ControlClientTypes.PrefixLevel.readingClosure)
            value.advancedCostOptimizationMetrics = try reader["AdvancedCostOptimizationMetrics"].readIfPresent(readingClosure: S3ControlClientTypes.AdvancedCostOptimizationMetrics.readingClosure)
            value.advancedDataProtectionMetrics = try reader["AdvancedDataProtectionMetrics"].readIfPresent(readingClosure: S3ControlClientTypes.AdvancedDataProtectionMetrics.readingClosure)
            value.detailedStatusCodesMetrics = try reader["DetailedStatusCodesMetrics"].readIfPresent(readingClosure: S3ControlClientTypes.DetailedStatusCodesMetrics.readingClosure)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// A container for the bucket-level configuration for Amazon S3 Storage Lens. For more information about S3 Storage Lens, see [Assessing your storage activity and usage with S3 Storage Lens](https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage_lens.html) in the Amazon S3 User Guide.
    public struct BucketLevel: Swift.Equatable {
        /// A container for the bucket-level activity metrics for S3 Storage Lens.
        public var activityMetrics: S3ControlClientTypes.ActivityMetrics?
        /// A container for bucket-level advanced cost-optimization metrics for S3 Storage Lens.
        public var advancedCostOptimizationMetrics: S3ControlClientTypes.AdvancedCostOptimizationMetrics?
        /// A container for bucket-level advanced data-protection metrics for S3 Storage Lens.
        public var advancedDataProtectionMetrics: S3ControlClientTypes.AdvancedDataProtectionMetrics?
        /// A container for bucket-level detailed status code metrics for S3 Storage Lens.
        public var detailedStatusCodesMetrics: S3ControlClientTypes.DetailedStatusCodesMetrics?
        /// A container for the prefix-level metrics for S3 Storage Lens.
        public var prefixLevel: S3ControlClientTypes.PrefixLevel?

        public init(
            activityMetrics: S3ControlClientTypes.ActivityMetrics? = nil,
            advancedCostOptimizationMetrics: S3ControlClientTypes.AdvancedCostOptimizationMetrics? = nil,
            advancedDataProtectionMetrics: S3ControlClientTypes.AdvancedDataProtectionMetrics? = nil,
            detailedStatusCodesMetrics: S3ControlClientTypes.DetailedStatusCodesMetrics? = nil,
            prefixLevel: S3ControlClientTypes.PrefixLevel? = nil
        )
        {
            self.activityMetrics = activityMetrics
            self.advancedCostOptimizationMetrics = advancedCostOptimizationMetrics
            self.advancedDataProtectionMetrics = advancedDataProtectionMetrics
            self.detailedStatusCodesMetrics = detailedStatusCodesMetrics
            self.prefixLevel = prefixLevel
        }
    }

}

extension S3ControlClientTypes {
    public enum BucketLocationConstraint: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case eu
        case apNortheast1
        case apSouth1
        case apSoutheast1
        case apSoutheast2
        case cnNorth1
        case euCentral1
        case euWest1
        case saEast1
        case usWest1
        case usWest2
        case sdkUnknown(Swift.String)

        public static var allCases: [BucketLocationConstraint] {
            return [
                .eu,
                .apNortheast1,
                .apSouth1,
                .apSoutheast1,
                .apSoutheast2,
                .cnNorth1,
                .euCentral1,
                .euWest1,
                .saEast1,
                .usWest1,
                .usWest2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .eu: return "EU"
            case .apNortheast1: return "ap-northeast-1"
            case .apSouth1: return "ap-south-1"
            case .apSoutheast1: return "ap-southeast-1"
            case .apSoutheast2: return "ap-southeast-2"
            case .cnNorth1: return "cn-north-1"
            case .euCentral1: return "eu-central-1"
            case .euWest1: return "eu-west-1"
            case .saEast1: return "sa-east-1"
            case .usWest1: return "us-west-1"
            case .usWest2: return "us-west-2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BucketLocationConstraint(rawValue: rawValue) ?? BucketLocationConstraint.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum BucketVersioningStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enabled
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [BucketVersioningStatus] {
            return [
                .enabled,
                .suspended,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enabled: return "Enabled"
            case .suspended: return "Suspended"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BucketVersioningStatus(rawValue: rawValue) ?? BucketVersioningStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.CloudWatchMetrics {

    static func writingClosure(_ value: S3ControlClientTypes.CloudWatchMetrics?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["IsEnabled"].write(value.isEnabled)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.CloudWatchMetrics, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.CloudWatchMetrics()
            value.isEnabled = try reader["IsEnabled"].readIfPresent() ?? false
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// A container for enabling Amazon CloudWatch publishing for S3 Storage Lens metrics. For more information about publishing S3 Storage Lens metrics to CloudWatch, see [Monitor S3 Storage Lens metrics in CloudWatch](https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage_lens_view_metrics_cloudwatch.html) in the Amazon S3 User Guide.
    public struct CloudWatchMetrics: Swift.Equatable {
        /// A container that indicates whether CloudWatch publishing for S3 Storage Lens metrics is enabled. A value of true indicates that CloudWatch publishing for S3 Storage Lens metrics is enabled.
        /// This member is required.
        public var isEnabled: Swift.Bool

        public init(
            isEnabled: Swift.Bool = false
        )
        {
            self.isEnabled = isEnabled
        }
    }

}

extension CreateAccessGrantInput {
    static func writingClosure(_ value: CreateAccessGrantInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["AccessGrantsLocationConfiguration"].write(value.accessGrantsLocationConfiguration, writingClosure: S3ControlClientTypes.AccessGrantsLocationConfiguration.writingClosure(_:to:))
        try writer["AccessGrantsLocationId"].write(value.accessGrantsLocationId)
        try writer["ApplicationArn"].write(value.applicationArn)
        try writer["Grantee"].write(value.grantee, writingClosure: S3ControlClientTypes.Grantee.writingClosure(_:to:))
        try writer["Permission"].write(value.permission)
        try writer["S3PrefixType"].write(value.s3PrefixType)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: S3ControlClientTypes.Tag.writingClosure(_:to:), memberNodeInfo: "Tag", isFlattened: false)
    }
}

extension CreateAccessGrantInput {

    static func headerProvider(_ value: CreateAccessGrantInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension CreateAccessGrantInput {

    static func urlPathProvider(_ value: CreateAccessGrantInput) -> Swift.String? {
        return "/v20180820/accessgrantsinstance/grant"
    }
}

public struct CreateAccessGrantInput: Swift.Equatable {
    /// The configuration options of the grant location. The grant location is the S3 path to the data to which you are granting access. It contains the S3SubPrefix field. The grant scope is the result of appending the subprefix to the location scope of the registered location.
    public var accessGrantsLocationConfiguration: S3ControlClientTypes.AccessGrantsLocationConfiguration?
    /// The ID of the registered location to which you are granting access. S3 Access Grants assigns this ID when you register the location. S3 Access Grants assigns the ID default to the default location s3:// and assigns an auto-generated ID to other locations that you register. If you are passing the default location, you cannot create an access grant for the entire default location. You must also specify a bucket or a bucket and prefix in the Subprefix field.
    /// This member is required.
    public var accessGrantsLocationId: Swift.String?
    /// The ID of the Amazon Web Services account that is making this request.
    /// This member is required.
    public var accountId: Swift.String?
    /// The Amazon Resource Name (ARN) of an Amazon Web Services IAM Identity Center application associated with your Identity Center instance. If an application ARN is included in the request to create an access grant, the grantee can only access the S3 data through this application.
    public var applicationArn: Swift.String?
    /// The user, group, or role to which you are granting access. You can grant access to an IAM user or role. If you have added your corporate directory to Amazon Web Services IAM Identity Center and associated your Identity Center instance with your S3 Access Grants instance, the grantee can also be a corporate directory user or group.
    /// This member is required.
    public var grantee: S3ControlClientTypes.Grantee?
    /// The type of access that you are granting to your S3 data, which can be set to one of the following values:
    ///
    /// * READ – Grant read-only access to the S3 data.
    ///
    /// * WRITE – Grant write-only access to the S3 data.
    ///
    /// * READWRITE – Grant both read and write access to the S3 data.
    /// This member is required.
    public var permission: S3ControlClientTypes.Permission?
    /// The type of S3SubPrefix. The only possible value is Object. Pass this value if the access grant scope is an object. Do not pass this value if the access grant scope is a bucket or a bucket and a prefix.
    public var s3PrefixType: S3ControlClientTypes.S3PrefixType?
    /// The Amazon Web Services resource tags that you are adding to the access grant. Each tag is a label consisting of a user-defined key and value. Tags can help you manage, identify, organize, search for, and filter resources.
    public var tags: [S3ControlClientTypes.Tag]?

    public init(
        accessGrantsLocationConfiguration: S3ControlClientTypes.AccessGrantsLocationConfiguration? = nil,
        accessGrantsLocationId: Swift.String? = nil,
        accountId: Swift.String? = nil,
        applicationArn: Swift.String? = nil,
        grantee: S3ControlClientTypes.Grantee? = nil,
        permission: S3ControlClientTypes.Permission? = nil,
        s3PrefixType: S3ControlClientTypes.S3PrefixType? = nil,
        tags: [S3ControlClientTypes.Tag]? = nil
    )
    {
        self.accessGrantsLocationConfiguration = accessGrantsLocationConfiguration
        self.accessGrantsLocationId = accessGrantsLocationId
        self.accountId = accountId
        self.applicationArn = applicationArn
        self.grantee = grantee
        self.permission = permission
        self.s3PrefixType = s3PrefixType
        self.tags = tags
    }
}

extension CreateAccessGrantOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateAccessGrantOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = CreateAccessGrantOutput()
            value.accessGrantArn = try reader["AccessGrantArn"].readIfPresent()
            value.accessGrantId = try reader["AccessGrantId"].readIfPresent()
            value.accessGrantsLocationConfiguration = try reader["AccessGrantsLocationConfiguration"].readIfPresent(readingClosure: S3ControlClientTypes.AccessGrantsLocationConfiguration.readingClosure)
            value.accessGrantsLocationId = try reader["AccessGrantsLocationId"].readIfPresent()
            value.applicationArn = try reader["ApplicationArn"].readIfPresent()
            value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: .dateTime)
            value.grantScope = try reader["GrantScope"].readIfPresent()
            value.grantee = try reader["Grantee"].readIfPresent(readingClosure: S3ControlClientTypes.Grantee.readingClosure)
            value.permission = try reader["Permission"].readIfPresent()
            return value
        }
    }
}

public struct CreateAccessGrantOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the access grant.
    public var accessGrantArn: Swift.String?
    /// The ID of the access grant. S3 Access Grants auto-generates this ID when you create the access grant.
    public var accessGrantId: Swift.String?
    /// The configuration options of the grant location. The grant location is the S3 path to the data to which you are granting access.
    public var accessGrantsLocationConfiguration: S3ControlClientTypes.AccessGrantsLocationConfiguration?
    /// The ID of the registered location to which you are granting access. S3 Access Grants assigns this ID when you register the location. S3 Access Grants assigns the ID default to the default location s3:// and assigns an auto-generated ID to other locations that you register.
    public var accessGrantsLocationId: Swift.String?
    /// The Amazon Resource Name (ARN) of an Amazon Web Services IAM Identity Center application associated with your Identity Center instance. If the grant includes an application ARN, the grantee can only access the S3 data through this application.
    public var applicationArn: Swift.String?
    /// The date and time when you created the access grant.
    public var createdAt: ClientRuntime.Date?
    /// The S3 path of the data to which you are granting access. It is the result of appending the Subprefix to the location scope.
    public var grantScope: Swift.String?
    /// The user, group, or role to which you are granting access. You can grant access to an IAM user or role. If you have added your corporate directory to Amazon Web Services IAM Identity Center and associated your Identity Center instance with your S3 Access Grants instance, the grantee can also be a corporate directory user or group.
    public var grantee: S3ControlClientTypes.Grantee?
    /// The type of access that you are granting to your S3 data, which can be set to one of the following values:
    ///
    /// * READ – Grant read-only access to the S3 data.
    ///
    /// * WRITE – Grant write-only access to the S3 data.
    ///
    /// * READWRITE – Grant both read and write access to the S3 data.
    public var permission: S3ControlClientTypes.Permission?

    public init(
        accessGrantArn: Swift.String? = nil,
        accessGrantId: Swift.String? = nil,
        accessGrantsLocationConfiguration: S3ControlClientTypes.AccessGrantsLocationConfiguration? = nil,
        accessGrantsLocationId: Swift.String? = nil,
        applicationArn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        grantScope: Swift.String? = nil,
        grantee: S3ControlClientTypes.Grantee? = nil,
        permission: S3ControlClientTypes.Permission? = nil
    )
    {
        self.accessGrantArn = accessGrantArn
        self.accessGrantId = accessGrantId
        self.accessGrantsLocationConfiguration = accessGrantsLocationConfiguration
        self.accessGrantsLocationId = accessGrantsLocationId
        self.applicationArn = applicationArn
        self.createdAt = createdAt
        self.grantScope = grantScope
        self.grantee = grantee
        self.permission = permission
    }
}

enum CreateAccessGrantOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension CreateAccessGrantsInstanceInput {
    static func writingClosure(_ value: CreateAccessGrantsInstanceInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["IdentityCenterArn"].write(value.identityCenterArn)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: S3ControlClientTypes.Tag.writingClosure(_:to:), memberNodeInfo: "Tag", isFlattened: false)
    }
}

extension CreateAccessGrantsInstanceInput {

    static func headerProvider(_ value: CreateAccessGrantsInstanceInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension CreateAccessGrantsInstanceInput {

    static func urlPathProvider(_ value: CreateAccessGrantsInstanceInput) -> Swift.String? {
        return "/v20180820/accessgrantsinstance"
    }
}

public struct CreateAccessGrantsInstanceInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that is making this request.
    /// This member is required.
    public var accountId: Swift.String?
    /// If you would like to associate your S3 Access Grants instance with an Amazon Web Services IAM Identity Center instance, use this field to pass the Amazon Resource Name (ARN) of the Amazon Web Services IAM Identity Center instance that you are associating with your S3 Access Grants instance. An IAM Identity Center instance is your corporate identity directory that you added to the IAM Identity Center. You can use the [ListInstances](https://docs.aws.amazon.com/singlesignon/latest/APIReference/API_ListInstances.html) API operation to retrieve a list of your Identity Center instances and their ARNs.
    public var identityCenterArn: Swift.String?
    /// The Amazon Web Services resource tags that you are adding to the S3 Access Grants instance. Each tag is a label consisting of a user-defined key and value. Tags can help you manage, identify, organize, search for, and filter resources.
    public var tags: [S3ControlClientTypes.Tag]?

    public init(
        accountId: Swift.String? = nil,
        identityCenterArn: Swift.String? = nil,
        tags: [S3ControlClientTypes.Tag]? = nil
    )
    {
        self.accountId = accountId
        self.identityCenterArn = identityCenterArn
        self.tags = tags
    }
}

extension CreateAccessGrantsInstanceOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateAccessGrantsInstanceOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = CreateAccessGrantsInstanceOutput()
            value.accessGrantsInstanceArn = try reader["AccessGrantsInstanceArn"].readIfPresent()
            value.accessGrantsInstanceId = try reader["AccessGrantsInstanceId"].readIfPresent()
            value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: .dateTime)
            value.identityCenterArn = try reader["IdentityCenterArn"].readIfPresent()
            return value
        }
    }
}

public struct CreateAccessGrantsInstanceOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the S3 Access Grants instance.
    public var accessGrantsInstanceArn: Swift.String?
    /// The ID of the S3 Access Grants instance. The ID is default. You can have one S3 Access Grants instance per Region per account.
    public var accessGrantsInstanceId: Swift.String?
    /// The date and time when you created the S3 Access Grants instance.
    public var createdAt: ClientRuntime.Date?
    /// If you associated your S3 Access Grants instance with an Amazon Web Services IAM Identity Center instance, this field returns the Amazon Resource Name (ARN) of the IAM Identity Center instance application; a subresource of the original Identity Center instance passed in the request. S3 Access Grants creates this Identity Center application for this specific S3 Access Grants instance.
    public var identityCenterArn: Swift.String?

    public init(
        accessGrantsInstanceArn: Swift.String? = nil,
        accessGrantsInstanceId: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        identityCenterArn: Swift.String? = nil
    )
    {
        self.accessGrantsInstanceArn = accessGrantsInstanceArn
        self.accessGrantsInstanceId = accessGrantsInstanceId
        self.createdAt = createdAt
        self.identityCenterArn = identityCenterArn
    }
}

enum CreateAccessGrantsInstanceOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension CreateAccessGrantsLocationInput {
    static func writingClosure(_ value: CreateAccessGrantsLocationInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["IAMRoleArn"].write(value.iamRoleArn)
        try writer["LocationScope"].write(value.locationScope)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: S3ControlClientTypes.Tag.writingClosure(_:to:), memberNodeInfo: "Tag", isFlattened: false)
    }
}

extension CreateAccessGrantsLocationInput {

    static func headerProvider(_ value: CreateAccessGrantsLocationInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension CreateAccessGrantsLocationInput {

    static func urlPathProvider(_ value: CreateAccessGrantsLocationInput) -> Swift.String? {
        return "/v20180820/accessgrantsinstance/location"
    }
}

public struct CreateAccessGrantsLocationInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that is making this request.
    /// This member is required.
    public var accountId: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role for the registered location. S3 Access Grants assumes this role to manage access to the registered location.
    /// This member is required.
    public var iamRoleArn: Swift.String?
    /// The S3 path to the location that you are registering. The location scope can be the default S3 location s3://, the S3 path to a bucket s3://, or the S3 path to a bucket and prefix s3:///. A prefix in S3 is a string of characters at the beginning of an object key name used to organize the objects that you store in your S3 buckets. For example, object key names that start with the engineering/ prefix or object key names that start with the marketing/campaigns/ prefix.
    /// This member is required.
    public var locationScope: Swift.String?
    /// The Amazon Web Services resource tags that you are adding to the S3 Access Grants location. Each tag is a label consisting of a user-defined key and value. Tags can help you manage, identify, organize, search for, and filter resources.
    public var tags: [S3ControlClientTypes.Tag]?

    public init(
        accountId: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        locationScope: Swift.String? = nil,
        tags: [S3ControlClientTypes.Tag]? = nil
    )
    {
        self.accountId = accountId
        self.iamRoleArn = iamRoleArn
        self.locationScope = locationScope
        self.tags = tags
    }
}

extension CreateAccessGrantsLocationOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateAccessGrantsLocationOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = CreateAccessGrantsLocationOutput()
            value.accessGrantsLocationArn = try reader["AccessGrantsLocationArn"].readIfPresent()
            value.accessGrantsLocationId = try reader["AccessGrantsLocationId"].readIfPresent()
            value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: .dateTime)
            value.iamRoleArn = try reader["IAMRoleArn"].readIfPresent()
            value.locationScope = try reader["LocationScope"].readIfPresent()
            return value
        }
    }
}

public struct CreateAccessGrantsLocationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the location you are registering.
    public var accessGrantsLocationArn: Swift.String?
    /// The ID of the registered location to which you are granting access. S3 Access Grants assigns this ID when you register the location. S3 Access Grants assigns the ID default to the default location s3:// and assigns an auto-generated ID to other locations that you register.
    public var accessGrantsLocationId: Swift.String?
    /// The date and time when you registered the location.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the IAM role for the registered location. S3 Access Grants assumes this role to manage access to the registered location.
    public var iamRoleArn: Swift.String?
    /// The S3 URI path to the location that you are registering. The location scope can be the default S3 location s3://, the S3 path to a bucket, or the S3 path to a bucket and prefix. A prefix in S3 is a string of characters at the beginning of an object key name used to organize the objects that you store in your S3 buckets. For example, object key names that start with the engineering/ prefix or object key names that start with the marketing/campaigns/ prefix.
    public var locationScope: Swift.String?

    public init(
        accessGrantsLocationArn: Swift.String? = nil,
        accessGrantsLocationId: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        iamRoleArn: Swift.String? = nil,
        locationScope: Swift.String? = nil
    )
    {
        self.accessGrantsLocationArn = accessGrantsLocationArn
        self.accessGrantsLocationId = accessGrantsLocationId
        self.createdAt = createdAt
        self.iamRoleArn = iamRoleArn
        self.locationScope = locationScope
    }
}

enum CreateAccessGrantsLocationOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension CreateAccessPointForObjectLambdaInput {
    static func writingClosure(_ value: CreateAccessPointForObjectLambdaInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Configuration"].write(value.configuration, writingClosure: S3ControlClientTypes.ObjectLambdaConfiguration.writingClosure(_:to:))
    }
}

extension CreateAccessPointForObjectLambdaInput {

    static func headerProvider(_ value: CreateAccessPointForObjectLambdaInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension CreateAccessPointForObjectLambdaInput {

    static func urlPathProvider(_ value: CreateAccessPointForObjectLambdaInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/v20180820/accesspointforobjectlambda/\(name.urlPercentEncoding())"
    }
}

public struct CreateAccessPointForObjectLambdaInput: Swift.Equatable {
    /// The Amazon Web Services account ID for owner of the specified Object Lambda Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// Object Lambda Access Point configuration as a JSON document.
    /// This member is required.
    public var configuration: S3ControlClientTypes.ObjectLambdaConfiguration?
    /// The name you want to assign to this Object Lambda Access Point.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        configuration: S3ControlClientTypes.ObjectLambdaConfiguration? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.configuration = configuration
        self.name = name
    }
}

extension CreateAccessPointForObjectLambdaOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateAccessPointForObjectLambdaOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = CreateAccessPointForObjectLambdaOutput()
            value.alias = try reader["Alias"].readIfPresent(readingClosure: S3ControlClientTypes.ObjectLambdaAccessPointAlias.readingClosure)
            value.objectLambdaAccessPointArn = try reader["ObjectLambdaAccessPointArn"].readIfPresent()
            return value
        }
    }
}

public struct CreateAccessPointForObjectLambdaOutput: Swift.Equatable {
    /// The alias of the Object Lambda Access Point.
    public var alias: S3ControlClientTypes.ObjectLambdaAccessPointAlias?
    /// Specifies the ARN for the Object Lambda Access Point.
    public var objectLambdaAccessPointArn: Swift.String?

    public init(
        alias: S3ControlClientTypes.ObjectLambdaAccessPointAlias? = nil,
        objectLambdaAccessPointArn: Swift.String? = nil
    )
    {
        self.alias = alias
        self.objectLambdaAccessPointArn = objectLambdaAccessPointArn
    }
}

enum CreateAccessPointForObjectLambdaOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension CreateAccessPointInput {
    static func writingClosure(_ value: CreateAccessPointInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Bucket"].write(value.bucket)
        try writer["BucketAccountId"].write(value.bucketAccountId)
        try writer["PublicAccessBlockConfiguration"].write(value.publicAccessBlockConfiguration, writingClosure: S3ControlClientTypes.PublicAccessBlockConfiguration.writingClosure(_:to:))
        try writer["VpcConfiguration"].write(value.vpcConfiguration, writingClosure: S3ControlClientTypes.VpcConfiguration.writingClosure(_:to:))
    }
}

extension CreateAccessPointInput {

    static func headerProvider(_ value: CreateAccessPointInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension CreateAccessPointInput {

    static func urlPathProvider(_ value: CreateAccessPointInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/v20180820/accesspoint/\(name.urlPercentEncoding())"
    }
}

public struct CreateAccessPointInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the account that owns the specified access point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the bucket that you want to associate this access point with. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?
    /// The Amazon Web Services account ID associated with the S3 bucket associated with this access point.
    public var bucketAccountId: Swift.String?
    /// The name you want to assign to this access point.
    /// This member is required.
    public var name: Swift.String?
    /// The PublicAccessBlock configuration that you want to apply to the access point.
    public var publicAccessBlockConfiguration: S3ControlClientTypes.PublicAccessBlockConfiguration?
    /// If you include this field, Amazon S3 restricts access to this access point to requests from the specified virtual private cloud (VPC). This is required for creating an access point for Amazon S3 on Outposts buckets.
    public var vpcConfiguration: S3ControlClientTypes.VpcConfiguration?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil,
        bucketAccountId: Swift.String? = nil,
        name: Swift.String? = nil,
        publicAccessBlockConfiguration: S3ControlClientTypes.PublicAccessBlockConfiguration? = nil,
        vpcConfiguration: S3ControlClientTypes.VpcConfiguration? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
        self.bucketAccountId = bucketAccountId
        self.name = name
        self.publicAccessBlockConfiguration = publicAccessBlockConfiguration
        self.vpcConfiguration = vpcConfiguration
    }
}

extension CreateAccessPointOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateAccessPointOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = CreateAccessPointOutput()
            value.accessPointArn = try reader["AccessPointArn"].readIfPresent()
            value.alias = try reader["Alias"].readIfPresent()
            return value
        }
    }
}

public struct CreateAccessPointOutput: Swift.Equatable {
    /// The ARN of the access point. This is only supported by Amazon S3 on Outposts.
    public var accessPointArn: Swift.String?
    /// The name or alias of the access point.
    public var alias: Swift.String?

    public init(
        accessPointArn: Swift.String? = nil,
        alias: Swift.String? = nil
    )
    {
        self.accessPointArn = accessPointArn
        self.alias = alias
    }
}

enum CreateAccessPointOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension S3ControlClientTypes.CreateBucketConfiguration {

    static func writingClosure(_ value: S3ControlClientTypes.CreateBucketConfiguration?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["LocationConstraint"].write(value.locationConstraint)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.CreateBucketConfiguration, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.CreateBucketConfiguration()
            value.locationConstraint = try reader["LocationConstraint"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// The container for the bucket configuration. This is not supported by Amazon S3 on Outposts buckets.
    public struct CreateBucketConfiguration: Swift.Equatable {
        /// Specifies the Region where the bucket will be created. If you are creating a bucket on the US East (N. Virginia) Region (us-east-1), you do not need to specify the location. This is not supported by Amazon S3 on Outposts buckets.
        public var locationConstraint: S3ControlClientTypes.BucketLocationConstraint?

        public init(
            locationConstraint: S3ControlClientTypes.BucketLocationConstraint? = nil
        )
        {
            self.locationConstraint = locationConstraint
        }
    }

}

extension CreateBucketInput {
    static func writingClosure(_ value: CreateBucketInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["CreateBucketConfiguration"].write(value.createBucketConfiguration, writingClosure: S3ControlClientTypes.CreateBucketConfiguration.writingClosure(_:to:))
    }
}

extension CreateBucketInput {

    static func headerProvider(_ value: CreateBucketInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let acl = value.acl {
            items.add(Header(name: "x-amz-acl", value: Swift.String(acl.rawValue)))
        }
        if let grantFullControl = value.grantFullControl {
            items.add(Header(name: "x-amz-grant-full-control", value: Swift.String(grantFullControl)))
        }
        if let grantRead = value.grantRead {
            items.add(Header(name: "x-amz-grant-read", value: Swift.String(grantRead)))
        }
        if let grantReadACP = value.grantReadACP {
            items.add(Header(name: "x-amz-grant-read-acp", value: Swift.String(grantReadACP)))
        }
        if let grantWrite = value.grantWrite {
            items.add(Header(name: "x-amz-grant-write", value: Swift.String(grantWrite)))
        }
        if let grantWriteACP = value.grantWriteACP {
            items.add(Header(name: "x-amz-grant-write-acp", value: Swift.String(grantWriteACP)))
        }
        if let objectLockEnabledForBucket = value.objectLockEnabledForBucket {
            items.add(Header(name: "x-amz-bucket-object-lock-enabled", value: Swift.String(objectLockEnabledForBucket)))
        }
        if let outpostId = value.outpostId {
            items.add(Header(name: "x-amz-outpost-id", value: Swift.String(outpostId)))
        }
        return items
    }
}

extension CreateBucketInput {

    static func urlPathProvider(_ value: CreateBucketInput) -> Swift.String? {
        guard let bucket = value.bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())"
    }
}

public struct CreateBucketInput: Swift.Equatable {
    /// The canned ACL to apply to the bucket. This is not supported by Amazon S3 on Outposts buckets.
    public var acl: S3ControlClientTypes.BucketCannedACL?
    /// The name of the bucket.
    /// This member is required.
    public var bucket: Swift.String?
    /// The configuration information for the bucket. This is not supported by Amazon S3 on Outposts buckets.
    public var createBucketConfiguration: S3ControlClientTypes.CreateBucketConfiguration?
    /// Allows grantee the read, write, read ACP, and write ACP permissions on the bucket. This is not supported by Amazon S3 on Outposts buckets.
    public var grantFullControl: Swift.String?
    /// Allows grantee to list the objects in the bucket. This is not supported by Amazon S3 on Outposts buckets.
    public var grantRead: Swift.String?
    /// Allows grantee to read the bucket ACL. This is not supported by Amazon S3 on Outposts buckets.
    public var grantReadACP: Swift.String?
    /// Allows grantee to create, overwrite, and delete any object in the bucket. This is not supported by Amazon S3 on Outposts buckets.
    public var grantWrite: Swift.String?
    /// Allows grantee to write the ACL for the applicable bucket. This is not supported by Amazon S3 on Outposts buckets.
    public var grantWriteACP: Swift.String?
    /// Specifies whether you want S3 Object Lock to be enabled for the new bucket. This is not supported by Amazon S3 on Outposts buckets.
    public var objectLockEnabledForBucket: Swift.Bool?
    /// The ID of the Outposts where the bucket is being created. This ID is required by Amazon S3 on Outposts buckets.
    public var outpostId: Swift.String?

    public init(
        acl: S3ControlClientTypes.BucketCannedACL? = nil,
        bucket: Swift.String? = nil,
        createBucketConfiguration: S3ControlClientTypes.CreateBucketConfiguration? = nil,
        grantFullControl: Swift.String? = nil,
        grantRead: Swift.String? = nil,
        grantReadACP: Swift.String? = nil,
        grantWrite: Swift.String? = nil,
        grantWriteACP: Swift.String? = nil,
        objectLockEnabledForBucket: Swift.Bool? = nil,
        outpostId: Swift.String? = nil
    )
    {
        self.acl = acl
        self.bucket = bucket
        self.createBucketConfiguration = createBucketConfiguration
        self.grantFullControl = grantFullControl
        self.grantRead = grantRead
        self.grantReadACP = grantReadACP
        self.grantWrite = grantWrite
        self.grantWriteACP = grantWriteACP
        self.objectLockEnabledForBucket = objectLockEnabledForBucket
        self.outpostId = outpostId
    }
}

extension CreateBucketOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateBucketOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = CreateBucketOutput()
            if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
                value.location = locationHeaderValue
            }
            value.bucketArn = try reader["BucketArn"].readIfPresent()
            return value
        }
    }
}

public struct CreateBucketOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the bucket. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    public var bucketArn: Swift.String?
    /// The location of the bucket.
    public var location: Swift.String?

    public init(
        bucketArn: Swift.String? = nil,
        location: Swift.String? = nil
    )
    {
        self.bucketArn = bucketArn
        self.location = location
    }
}

enum CreateBucketOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "BucketAlreadyExists": return try await BucketAlreadyExists.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "BucketAlreadyOwnedByYou": return try await BucketAlreadyOwnedByYou.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension CreateJobInput {
    static func writingClosure(_ value: CreateJobInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["ConfirmationRequired"].write(value.confirmationRequired)
        try writer["Description"].write(value.description)
        try writer["Manifest"].write(value.manifest, writingClosure: S3ControlClientTypes.JobManifest.writingClosure(_:to:))
        try writer["ManifestGenerator"].write(value.manifestGenerator, writingClosure: S3ControlClientTypes.JobManifestGenerator.writingClosure(_:to:))
        try writer["Operation"].write(value.operation, writingClosure: S3ControlClientTypes.JobOperation.writingClosure(_:to:))
        try writer["Priority"].write(value.priority)
        try writer["Report"].write(value.report, writingClosure: S3ControlClientTypes.JobReport.writingClosure(_:to:))
        try writer["RoleArn"].write(value.roleArn)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: S3ControlClientTypes.S3Tag.writingClosure(_:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateJobInput {

    static func headerProvider(_ value: CreateJobInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension CreateJobInput {

    static func urlPathProvider(_ value: CreateJobInput) -> Swift.String? {
        return "/v20180820/jobs"
    }
}

public struct CreateJobInput: Swift.Equatable {
    /// The Amazon Web Services account ID that creates the job.
    /// This member is required.
    public var accountId: Swift.String?
    /// An idempotency token to ensure that you don't accidentally submit the same request twice. You can use any string up to the maximum length.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// Indicates whether confirmation is required before Amazon S3 runs the job. Confirmation is only required for jobs created through the Amazon S3 console.
    public var confirmationRequired: Swift.Bool?
    /// A description for this job. You can use any string within the permitted length. Descriptions don't need to be unique and can be used for multiple jobs.
    public var description: Swift.String?
    /// Configuration parameters for the manifest.
    public var manifest: S3ControlClientTypes.JobManifest?
    /// The attribute container for the ManifestGenerator details. Jobs must be created with either a manifest file or a ManifestGenerator, but not both.
    public var manifestGenerator: S3ControlClientTypes.JobManifestGenerator?
    /// The action that you want this job to perform on every object listed in the manifest. For more information about the available actions, see [Operations](https://docs.aws.amazon.com/AmazonS3/latest/dev/batch-ops-actions.html) in the Amazon S3 User Guide.
    /// This member is required.
    public var operation: S3ControlClientTypes.JobOperation?
    /// The numerical priority for this job. Higher numbers indicate higher priority.
    /// This member is required.
    public var priority: Swift.Int?
    /// Configuration parameters for the optional job-completion report.
    /// This member is required.
    public var report: S3ControlClientTypes.JobReport?
    /// The Amazon Resource Name (ARN) for the Identity and Access Management (IAM) role that Batch Operations will use to run this job's action on every object in the manifest.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A set of tags to associate with the S3 Batch Operations job. This is an optional parameter.
    public var tags: [S3ControlClientTypes.S3Tag]?

    public init(
        accountId: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        confirmationRequired: Swift.Bool? = nil,
        description: Swift.String? = nil,
        manifest: S3ControlClientTypes.JobManifest? = nil,
        manifestGenerator: S3ControlClientTypes.JobManifestGenerator? = nil,
        operation: S3ControlClientTypes.JobOperation? = nil,
        priority: Swift.Int? = nil,
        report: S3ControlClientTypes.JobReport? = nil,
        roleArn: Swift.String? = nil,
        tags: [S3ControlClientTypes.S3Tag]? = nil
    )
    {
        self.accountId = accountId
        self.clientRequestToken = clientRequestToken
        self.confirmationRequired = confirmationRequired
        self.description = description
        self.manifest = manifest
        self.manifestGenerator = manifestGenerator
        self.operation = operation
        self.priority = priority
        self.report = report
        self.roleArn = roleArn
        self.tags = tags
    }
}

extension CreateJobOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateJobOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = CreateJobOutput()
            value.jobId = try reader["JobId"].readIfPresent()
            return value
        }
    }
}

public struct CreateJobOutput: Swift.Equatable {
    /// The ID for this job. Amazon S3 generates this ID automatically and returns it after a successful Create Job request.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

enum CreateJobOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "BadRequestException": return try await BadRequestException.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "IdempotencyException": return try await IdempotencyException.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InternalServiceException": return try await InternalServiceException.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyRequestsException": return try await TooManyRequestsException.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension S3ControlClientTypes.CreateMultiRegionAccessPointInput {

    static func writingClosure(_ value: S3ControlClientTypes.CreateMultiRegionAccessPointInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Name"].write(value.name)
        try writer["PublicAccessBlock"].write(value.publicAccessBlock, writingClosure: S3ControlClientTypes.PublicAccessBlockConfiguration.writingClosure(_:to:))
        try writer["Regions"].writeList(value.regions, memberWritingClosure: S3ControlClientTypes.Region.writingClosure(_:to:), memberNodeInfo: "Region", isFlattened: false)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.CreateMultiRegionAccessPointInput, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.CreateMultiRegionAccessPointInput()
            value.name = try reader["Name"].readIfPresent()
            value.publicAccessBlock = try reader["PublicAccessBlock"].readIfPresent(readingClosure: S3ControlClientTypes.PublicAccessBlockConfiguration.readingClosure)
            value.regions = try reader["Regions"].readListIfPresent(memberReadingClosure: S3ControlClientTypes.Region.readingClosure, memberNodeInfo: "Region", isFlattened: false)
            return value
        }
    }
}

extension CreateMultiRegionAccessPointInput {
    static func writingClosure(_ value: CreateMultiRegionAccessPointInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["Details"].write(value.details, writingClosure: S3ControlClientTypes.CreateMultiRegionAccessPointInput.writingClosure(_:to:))
    }
}

extension CreateMultiRegionAccessPointInput {

    static func headerProvider(_ value: CreateMultiRegionAccessPointInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension CreateMultiRegionAccessPointInput {

    static func urlPathProvider(_ value: CreateMultiRegionAccessPointInput) -> Swift.String? {
        return "/v20180820/async-requests/mrap/create"
    }
}

extension S3ControlClientTypes {
    /// A container for the information associated with a [CreateMultiRegionAccessPoint](https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_CreateMultiRegionAccessPoint.html) request.
    public struct CreateMultiRegionAccessPointInput: Swift.Equatable {
        /// The name of the Multi-Region Access Point associated with this request.
        /// This member is required.
        public var name: Swift.String?
        /// The PublicAccessBlock configuration that you want to apply to this Amazon S3 account. You can enable the configuration options in any combination. For more information about when Amazon S3 considers a bucket or object public, see [The Meaning of "Public"](https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status) in the Amazon S3 User Guide. This data type is not supported for Amazon S3 on Outposts.
        public var publicAccessBlock: S3ControlClientTypes.PublicAccessBlockConfiguration?
        /// The buckets in different Regions that are associated with the Multi-Region Access Point.
        /// This member is required.
        public var regions: [S3ControlClientTypes.Region]?

        public init(
            name: Swift.String? = nil,
            publicAccessBlock: S3ControlClientTypes.PublicAccessBlockConfiguration? = nil,
            regions: [S3ControlClientTypes.Region]? = nil
        )
        {
            self.name = name
            self.publicAccessBlock = publicAccessBlock
            self.regions = regions
        }
    }

}

public struct CreateMultiRegionAccessPointInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the owner of the Multi-Region Access Point. The owner of the Multi-Region Access Point also must own the underlying buckets.
    /// This member is required.
    public var accountId: Swift.String?
    /// An idempotency token used to identify the request and guarantee that requests are unique.
    /// This member is required.
    public var clientToken: Swift.String?
    /// A container element containing details about the Multi-Region Access Point.
    /// This member is required.
    public var details: S3ControlClientTypes.CreateMultiRegionAccessPointInput?

    public init(
        accountId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        details: S3ControlClientTypes.CreateMultiRegionAccessPointInput? = nil
    )
    {
        self.accountId = accountId
        self.clientToken = clientToken
        self.details = details
    }
}

extension CreateMultiRegionAccessPointOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateMultiRegionAccessPointOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = CreateMultiRegionAccessPointOutput()
            value.requestTokenARN = try reader["RequestTokenARN"].readIfPresent()
            return value
        }
    }
}

public struct CreateMultiRegionAccessPointOutput: Swift.Equatable {
    /// The request token associated with the request. You can use this token with [DescribeMultiRegionAccessPointOperation](https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_DescribeMultiRegionAccessPointOperation.html) to determine the status of asynchronous requests.
    public var requestTokenARN: Swift.String?

    public init(
        requestTokenARN: Swift.String? = nil
    )
    {
        self.requestTokenARN = requestTokenARN
    }
}

enum CreateMultiRegionAccessPointOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension CreateStorageLensGroupInput {
    static func writingClosure(_ value: CreateStorageLensGroupInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["StorageLensGroup"].write(value.storageLensGroup, writingClosure: S3ControlClientTypes.StorageLensGroup.writingClosure(_:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: S3ControlClientTypes.Tag.writingClosure(_:to:), memberNodeInfo: "Tag", isFlattened: false)
    }
}

extension CreateStorageLensGroupInput {

    static func headerProvider(_ value: CreateStorageLensGroupInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension CreateStorageLensGroupInput {

    static func urlPathProvider(_ value: CreateStorageLensGroupInput) -> Swift.String? {
        return "/v20180820/storagelensgroup"
    }
}

public struct CreateStorageLensGroupInput: Swift.Equatable {
    /// The Amazon Web Services account ID that the Storage Lens group is created from and associated with.
    /// This member is required.
    public var accountId: Swift.String?
    /// The Storage Lens group configuration.
    /// This member is required.
    public var storageLensGroup: S3ControlClientTypes.StorageLensGroup?
    /// The Amazon Web Services resource tags that you're adding to your Storage Lens group. This parameter is optional.
    public var tags: [S3ControlClientTypes.Tag]?

    public init(
        accountId: Swift.String? = nil,
        storageLensGroup: S3ControlClientTypes.StorageLensGroup? = nil,
        tags: [S3ControlClientTypes.Tag]? = nil
    )
    {
        self.accountId = accountId
        self.storageLensGroup = storageLensGroup
        self.tags = tags
    }
}

extension CreateStorageLensGroupOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateStorageLensGroupOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return CreateStorageLensGroupOutput()
        }
    }
}

public struct CreateStorageLensGroupOutput: Swift.Equatable {

    public init() { }
}

enum CreateStorageLensGroupOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension S3ControlClientTypes.Credentials {

    static func writingClosure(_ value: S3ControlClientTypes.Credentials?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["AccessKeyId"].write(value.accessKeyId)
        try writer["Expiration"].writeTimestamp(value.expiration, format: .dateTime)
        try writer["SecretAccessKey"].write(value.secretAccessKey)
        try writer["SessionToken"].write(value.sessionToken)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.Credentials, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.Credentials()
            value.accessKeyId = try reader["AccessKeyId"].readIfPresent()
            value.secretAccessKey = try reader["SecretAccessKey"].readIfPresent()
            value.sessionToken = try reader["SessionToken"].readIfPresent()
            value.expiration = try reader["Expiration"].readTimestampIfPresent(format: .dateTime)
            return value
        }
    }
}

extension S3ControlClientTypes.Credentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension S3ControlClientTypes {
    /// The Amazon Web Services Security Token Service temporary credential that S3 Access Grants vends to grantees and client applications.
    public struct Credentials: Swift.Equatable {
        /// The unique access key ID of the Amazon Web Services STS temporary credential that S3 Access Grants vends to grantees and client applications.
        public var accessKeyId: Swift.String?
        /// The expiration date and time of the temporary credential that S3 Access Grants vends to grantees and client applications.
        public var expiration: ClientRuntime.Date?
        /// The secret access key of the Amazon Web Services STS temporary credential that S3 Access Grants vends to grantees and client applications.
        public var secretAccessKey: Swift.String?
        /// The Amazon Web Services STS temporary credential that S3 Access Grants vends to grantees and client applications.
        public var sessionToken: Swift.String?

        public init(
            accessKeyId: Swift.String? = nil,
            expiration: ClientRuntime.Date? = nil,
            secretAccessKey: Swift.String? = nil,
            sessionToken: Swift.String? = nil
        )
        {
            self.accessKeyId = accessKeyId
            self.expiration = expiration
            self.secretAccessKey = secretAccessKey
            self.sessionToken = sessionToken
        }
    }

}

extension DeleteAccessGrantInput {

    static func headerProvider(_ value: DeleteAccessGrantInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteAccessGrantInput {

    static func urlPathProvider(_ value: DeleteAccessGrantInput) -> Swift.String? {
        guard let accessGrantId = value.accessGrantId else {
            return nil
        }
        return "/v20180820/accessgrantsinstance/grant/\(accessGrantId.urlPercentEncoding())"
    }
}

public struct DeleteAccessGrantInput: Swift.Equatable {
    /// The ID of the access grant. S3 Access Grants auto-generates this ID when you create the access grant.
    /// This member is required.
    public var accessGrantId: Swift.String?
    /// The ID of the Amazon Web Services account that is making this request.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accessGrantId: Swift.String? = nil,
        accountId: Swift.String? = nil
    )
    {
        self.accessGrantId = accessGrantId
        self.accountId = accountId
    }
}

extension DeleteAccessGrantOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteAccessGrantOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteAccessGrantOutput()
        }
    }
}

public struct DeleteAccessGrantOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAccessGrantOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension DeleteAccessGrantsInstanceInput {

    static func headerProvider(_ value: DeleteAccessGrantsInstanceInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteAccessGrantsInstanceInput {

    static func urlPathProvider(_ value: DeleteAccessGrantsInstanceInput) -> Swift.String? {
        return "/v20180820/accessgrantsinstance"
    }
}

public struct DeleteAccessGrantsInstanceInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that is making this request.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

extension DeleteAccessGrantsInstanceOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteAccessGrantsInstanceOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteAccessGrantsInstanceOutput()
        }
    }
}

public struct DeleteAccessGrantsInstanceOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAccessGrantsInstanceOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension DeleteAccessGrantsInstanceResourcePolicyInput {

    static func headerProvider(_ value: DeleteAccessGrantsInstanceResourcePolicyInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteAccessGrantsInstanceResourcePolicyInput {

    static func urlPathProvider(_ value: DeleteAccessGrantsInstanceResourcePolicyInput) -> Swift.String? {
        return "/v20180820/accessgrantsinstance/resourcepolicy"
    }
}

public struct DeleteAccessGrantsInstanceResourcePolicyInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that is making this request.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

extension DeleteAccessGrantsInstanceResourcePolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteAccessGrantsInstanceResourcePolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteAccessGrantsInstanceResourcePolicyOutput()
        }
    }
}

public struct DeleteAccessGrantsInstanceResourcePolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAccessGrantsInstanceResourcePolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension DeleteAccessGrantsLocationInput {

    static func headerProvider(_ value: DeleteAccessGrantsLocationInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteAccessGrantsLocationInput {

    static func urlPathProvider(_ value: DeleteAccessGrantsLocationInput) -> Swift.String? {
        guard let accessGrantsLocationId = value.accessGrantsLocationId else {
            return nil
        }
        return "/v20180820/accessgrantsinstance/location/\(accessGrantsLocationId.urlPercentEncoding())"
    }
}

public struct DeleteAccessGrantsLocationInput: Swift.Equatable {
    /// The ID of the registered location that you are deregistering from your S3 Access Grants instance. S3 Access Grants assigned this ID when you registered the location. S3 Access Grants assigns the ID default to the default location s3:// and assigns an auto-generated ID to other locations that you register.
    /// This member is required.
    public var accessGrantsLocationId: Swift.String?
    /// The ID of the Amazon Web Services account that is making this request.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accessGrantsLocationId: Swift.String? = nil,
        accountId: Swift.String? = nil
    )
    {
        self.accessGrantsLocationId = accessGrantsLocationId
        self.accountId = accountId
    }
}

extension DeleteAccessGrantsLocationOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteAccessGrantsLocationOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteAccessGrantsLocationOutput()
        }
    }
}

public struct DeleteAccessGrantsLocationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAccessGrantsLocationOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension DeleteAccessPointForObjectLambdaInput {

    static func headerProvider(_ value: DeleteAccessPointForObjectLambdaInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteAccessPointForObjectLambdaInput {

    static func urlPathProvider(_ value: DeleteAccessPointForObjectLambdaInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/v20180820/accesspointforobjectlambda/\(name.urlPercentEncoding())"
    }
}

public struct DeleteAccessPointForObjectLambdaInput: Swift.Equatable {
    /// The account ID for the account that owns the specified Object Lambda Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the access point you want to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

extension DeleteAccessPointForObjectLambdaOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteAccessPointForObjectLambdaOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteAccessPointForObjectLambdaOutput()
        }
    }
}

public struct DeleteAccessPointForObjectLambdaOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAccessPointForObjectLambdaOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension DeleteAccessPointInput {

    static func headerProvider(_ value: DeleteAccessPointInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteAccessPointInput {

    static func urlPathProvider(_ value: DeleteAccessPointInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/v20180820/accesspoint/\(name.urlPercentEncoding())"
    }
}

public struct DeleteAccessPointInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the account that owns the specified access point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the access point you want to delete. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the access point accessed in the format arn:aws:s3-outposts:::outpost//accesspoint/. For example, to access the access point reports-ap through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/accesspoint/reports-ap. The value must be URL encoded.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

extension DeleteAccessPointOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteAccessPointOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteAccessPointOutput()
        }
    }
}

public struct DeleteAccessPointOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAccessPointOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension DeleteAccessPointPolicyForObjectLambdaInput {

    static func headerProvider(_ value: DeleteAccessPointPolicyForObjectLambdaInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteAccessPointPolicyForObjectLambdaInput {

    static func urlPathProvider(_ value: DeleteAccessPointPolicyForObjectLambdaInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/v20180820/accesspointforobjectlambda/\(name.urlPercentEncoding())/policy"
    }
}

public struct DeleteAccessPointPolicyForObjectLambdaInput: Swift.Equatable {
    /// The account ID for the account that owns the specified Object Lambda Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the Object Lambda Access Point you want to delete the policy for.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

extension DeleteAccessPointPolicyForObjectLambdaOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteAccessPointPolicyForObjectLambdaOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteAccessPointPolicyForObjectLambdaOutput()
        }
    }
}

public struct DeleteAccessPointPolicyForObjectLambdaOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAccessPointPolicyForObjectLambdaOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension DeleteAccessPointPolicyInput {

    static func headerProvider(_ value: DeleteAccessPointPolicyInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteAccessPointPolicyInput {

    static func urlPathProvider(_ value: DeleteAccessPointPolicyInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/v20180820/accesspoint/\(name.urlPercentEncoding())/policy"
    }
}

public struct DeleteAccessPointPolicyInput: Swift.Equatable {
    /// The account ID for the account that owns the specified access point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the access point whose policy you want to delete. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the access point accessed in the format arn:aws:s3-outposts:::outpost//accesspoint/. For example, to access the access point reports-ap through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/accesspoint/reports-ap. The value must be URL encoded.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

extension DeleteAccessPointPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteAccessPointPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteAccessPointPolicyOutput()
        }
    }
}

public struct DeleteAccessPointPolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAccessPointPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension DeleteBucketInput {

    static func headerProvider(_ value: DeleteBucketInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteBucketInput {

    static func urlPathProvider(_ value: DeleteBucketInput) -> Swift.String? {
        guard let bucket = value.bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())"
    }
}

public struct DeleteBucketInput: Swift.Equatable {
    /// The account ID that owns the Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    /// Specifies the bucket being deleted. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
    }
}

extension DeleteBucketLifecycleConfigurationInput {

    static func headerProvider(_ value: DeleteBucketLifecycleConfigurationInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteBucketLifecycleConfigurationInput {

    static func urlPathProvider(_ value: DeleteBucketLifecycleConfigurationInput) -> Swift.String? {
        guard let bucket = value.bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/lifecycleconfiguration"
    }
}

public struct DeleteBucketLifecycleConfigurationInput: Swift.Equatable {
    /// The account ID of the lifecycle configuration to delete.
    /// This member is required.
    public var accountId: Swift.String?
    /// Specifies the bucket. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
    }
}

extension DeleteBucketLifecycleConfigurationOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteBucketLifecycleConfigurationOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteBucketLifecycleConfigurationOutput()
        }
    }
}

public struct DeleteBucketLifecycleConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteBucketLifecycleConfigurationOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension DeleteBucketOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteBucketOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteBucketOutput()
        }
    }
}

public struct DeleteBucketOutput: Swift.Equatable {

    public init() { }
}

enum DeleteBucketOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension DeleteBucketPolicyInput {

    static func headerProvider(_ value: DeleteBucketPolicyInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteBucketPolicyInput {

    static func urlPathProvider(_ value: DeleteBucketPolicyInput) -> Swift.String? {
        guard let bucket = value.bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/policy"
    }
}

public struct DeleteBucketPolicyInput: Swift.Equatable {
    /// The account ID of the Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    /// Specifies the bucket. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
    }
}

extension DeleteBucketPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteBucketPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteBucketPolicyOutput()
        }
    }
}

public struct DeleteBucketPolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteBucketPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension DeleteBucketReplicationInput {

    static func headerProvider(_ value: DeleteBucketReplicationInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteBucketReplicationInput {

    static func urlPathProvider(_ value: DeleteBucketReplicationInput) -> Swift.String? {
        guard let bucket = value.bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/replication"
    }
}

public struct DeleteBucketReplicationInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Outposts bucket to delete the replication configuration for.
    /// This member is required.
    public var accountId: Swift.String?
    /// Specifies the S3 on Outposts bucket to delete the replication configuration for. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
    }
}

extension DeleteBucketReplicationOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteBucketReplicationOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteBucketReplicationOutput()
        }
    }
}

public struct DeleteBucketReplicationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteBucketReplicationOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension DeleteBucketTaggingInput {

    static func headerProvider(_ value: DeleteBucketTaggingInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteBucketTaggingInput {

    static func urlPathProvider(_ value: DeleteBucketTaggingInput) -> Swift.String? {
        guard let bucket = value.bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/tagging"
    }
}

public struct DeleteBucketTaggingInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Outposts bucket tag set to be removed.
    /// This member is required.
    public var accountId: Swift.String?
    /// The bucket ARN that has the tag set to be removed. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
    }
}

extension DeleteBucketTaggingOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteBucketTaggingOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteBucketTaggingOutput()
        }
    }
}

public struct DeleteBucketTaggingOutput: Swift.Equatable {

    public init() { }
}

enum DeleteBucketTaggingOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension DeleteJobTaggingInput {

    static func headerProvider(_ value: DeleteJobTaggingInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteJobTaggingInput {

    static func urlPathProvider(_ value: DeleteJobTaggingInput) -> Swift.String? {
        guard let jobId = value.jobId else {
            return nil
        }
        return "/v20180820/jobs/\(jobId.urlPercentEncoding())/tagging"
    }
}

public struct DeleteJobTaggingInput: Swift.Equatable {
    /// The Amazon Web Services account ID associated with the S3 Batch Operations job.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID for the S3 Batch Operations job whose tags you want to delete.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.jobId = jobId
    }
}

extension DeleteJobTaggingOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteJobTaggingOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteJobTaggingOutput()
        }
    }
}

public struct DeleteJobTaggingOutput: Swift.Equatable {

    public init() { }
}

enum DeleteJobTaggingOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "InternalServiceException": return try await InternalServiceException.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NotFoundException": return try await NotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyRequestsException": return try await TooManyRequestsException.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension S3ControlClientTypes.DeleteMarkerReplication {

    static func writingClosure(_ value: S3ControlClientTypes.DeleteMarkerReplication?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Status"].write(value.status)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.DeleteMarkerReplication, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.DeleteMarkerReplication()
            value.status = try reader["Status"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// Specifies whether S3 on Outposts replicates delete markers. If you specify a Filter element in your replication configuration, you must also include a DeleteMarkerReplication element. If your Filter includes a Tag element, the DeleteMarkerReplication element's Status child element must be set to Disabled, because S3 on Outposts does not support replicating delete markers for tag-based rules. For more information about delete marker replication, see [How delete operations affect replication](https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3OutpostsReplication.html#outposts-replication-what-is-replicated) in the Amazon S3 User Guide.
    public struct DeleteMarkerReplication: Swift.Equatable {
        /// Indicates whether to replicate delete markers.
        /// This member is required.
        public var status: S3ControlClientTypes.DeleteMarkerReplicationStatus?

        public init(
            status: S3ControlClientTypes.DeleteMarkerReplicationStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension S3ControlClientTypes {
    public enum DeleteMarkerReplicationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DeleteMarkerReplicationStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeleteMarkerReplicationStatus(rawValue: rawValue) ?? DeleteMarkerReplicationStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.DeleteMultiRegionAccessPointInput {

    static func writingClosure(_ value: S3ControlClientTypes.DeleteMultiRegionAccessPointInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Name"].write(value.name)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.DeleteMultiRegionAccessPointInput, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.DeleteMultiRegionAccessPointInput()
            value.name = try reader["Name"].readIfPresent()
            return value
        }
    }
}

extension DeleteMultiRegionAccessPointInput {
    static func writingClosure(_ value: DeleteMultiRegionAccessPointInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["Details"].write(value.details, writingClosure: S3ControlClientTypes.DeleteMultiRegionAccessPointInput.writingClosure(_:to:))
    }
}

extension DeleteMultiRegionAccessPointInput {

    static func headerProvider(_ value: DeleteMultiRegionAccessPointInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteMultiRegionAccessPointInput {

    static func urlPathProvider(_ value: DeleteMultiRegionAccessPointInput) -> Swift.String? {
        return "/v20180820/async-requests/mrap/delete"
    }
}

extension S3ControlClientTypes {
    /// A container for the information associated with a [DeleteMultiRegionAccessPoint](https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_DeleteMultiRegionAccessPoint.html) request.
    public struct DeleteMultiRegionAccessPointInput: Swift.Equatable {
        /// The name of the Multi-Region Access Point associated with this request.
        /// This member is required.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

public struct DeleteMultiRegionAccessPointInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the owner of the Multi-Region Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// An idempotency token used to identify the request and guarantee that requests are unique.
    /// This member is required.
    public var clientToken: Swift.String?
    /// A container element containing details about the Multi-Region Access Point.
    /// This member is required.
    public var details: S3ControlClientTypes.DeleteMultiRegionAccessPointInput?

    public init(
        accountId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        details: S3ControlClientTypes.DeleteMultiRegionAccessPointInput? = nil
    )
    {
        self.accountId = accountId
        self.clientToken = clientToken
        self.details = details
    }
}

extension DeleteMultiRegionAccessPointOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteMultiRegionAccessPointOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = DeleteMultiRegionAccessPointOutput()
            value.requestTokenARN = try reader["RequestTokenARN"].readIfPresent()
            return value
        }
    }
}

public struct DeleteMultiRegionAccessPointOutput: Swift.Equatable {
    /// The request token associated with the request. You can use this token with [DescribeMultiRegionAccessPointOperation](https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_DescribeMultiRegionAccessPointOperation.html) to determine the status of asynchronous requests.
    public var requestTokenARN: Swift.String?

    public init(
        requestTokenARN: Swift.String? = nil
    )
    {
        self.requestTokenARN = requestTokenARN
    }
}

enum DeleteMultiRegionAccessPointOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension DeletePublicAccessBlockInput {

    static func headerProvider(_ value: DeletePublicAccessBlockInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeletePublicAccessBlockInput {

    static func urlPathProvider(_ value: DeletePublicAccessBlockInput) -> Swift.String? {
        return "/v20180820/configuration/publicAccessBlock"
    }
}

public struct DeletePublicAccessBlockInput: Swift.Equatable {
    /// The account ID for the Amazon Web Services account whose PublicAccessBlock configuration you want to remove.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

extension DeletePublicAccessBlockOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeletePublicAccessBlockOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeletePublicAccessBlockOutput()
        }
    }
}

public struct DeletePublicAccessBlockOutput: Swift.Equatable {

    public init() { }
}

enum DeletePublicAccessBlockOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension DeleteStorageLensConfigurationInput {

    static func headerProvider(_ value: DeleteStorageLensConfigurationInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteStorageLensConfigurationInput {

    static func urlPathProvider(_ value: DeleteStorageLensConfigurationInput) -> Swift.String? {
        guard let configId = value.configId else {
            return nil
        }
        return "/v20180820/storagelens/\(configId.urlPercentEncoding())"
    }
}

public struct DeleteStorageLensConfigurationInput: Swift.Equatable {
    /// The account ID of the requester.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID of the S3 Storage Lens configuration.
    /// This member is required.
    public var configId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        configId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.configId = configId
    }
}

extension DeleteStorageLensConfigurationOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteStorageLensConfigurationOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteStorageLensConfigurationOutput()
        }
    }
}

public struct DeleteStorageLensConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteStorageLensConfigurationOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension DeleteStorageLensConfigurationTaggingInput {

    static func headerProvider(_ value: DeleteStorageLensConfigurationTaggingInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteStorageLensConfigurationTaggingInput {

    static func urlPathProvider(_ value: DeleteStorageLensConfigurationTaggingInput) -> Swift.String? {
        guard let configId = value.configId else {
            return nil
        }
        return "/v20180820/storagelens/\(configId.urlPercentEncoding())/tagging"
    }
}

public struct DeleteStorageLensConfigurationTaggingInput: Swift.Equatable {
    /// The account ID of the requester.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID of the S3 Storage Lens configuration.
    /// This member is required.
    public var configId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        configId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.configId = configId
    }
}

extension DeleteStorageLensConfigurationTaggingOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteStorageLensConfigurationTaggingOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteStorageLensConfigurationTaggingOutput()
        }
    }
}

public struct DeleteStorageLensConfigurationTaggingOutput: Swift.Equatable {

    public init() { }
}

enum DeleteStorageLensConfigurationTaggingOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension DeleteStorageLensGroupInput {

    static func headerProvider(_ value: DeleteStorageLensGroupInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteStorageLensGroupInput {

    static func urlPathProvider(_ value: DeleteStorageLensGroupInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/v20180820/storagelensgroup/\(name.urlPercentEncoding())"
    }
}

public struct DeleteStorageLensGroupInput: Swift.Equatable {
    /// The Amazon Web Services account ID used to create the Storage Lens group that you're trying to delete.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the Storage Lens group that you're trying to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

extension DeleteStorageLensGroupOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteStorageLensGroupOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteStorageLensGroupOutput()
        }
    }
}

public struct DeleteStorageLensGroupOutput: Swift.Equatable {

    public init() { }
}

enum DeleteStorageLensGroupOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension DescribeJobInput {

    static func headerProvider(_ value: DescribeJobInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DescribeJobInput {

    static func urlPathProvider(_ value: DescribeJobInput) -> Swift.String? {
        guard let jobId = value.jobId else {
            return nil
        }
        return "/v20180820/jobs/\(jobId.urlPercentEncoding())"
    }
}

public struct DescribeJobInput: Swift.Equatable {
    /// The Amazon Web Services account ID associated with the S3 Batch Operations job.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID for the job whose information you want to retrieve.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.jobId = jobId
    }
}

extension DescribeJobOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DescribeJobOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = DescribeJobOutput()
            value.job = try reader["Job"].readIfPresent(readingClosure: S3ControlClientTypes.JobDescriptor.readingClosure)
            return value
        }
    }
}

public struct DescribeJobOutput: Swift.Equatable {
    /// Contains the configuration parameters and status for the job specified in the Describe Job request.
    public var job: S3ControlClientTypes.JobDescriptor?

    public init(
        job: S3ControlClientTypes.JobDescriptor? = nil
    )
    {
        self.job = job
    }
}

enum DescribeJobOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "BadRequestException": return try await BadRequestException.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InternalServiceException": return try await InternalServiceException.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NotFoundException": return try await NotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyRequestsException": return try await TooManyRequestsException.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension DescribeMultiRegionAccessPointOperationInput {

    static func headerProvider(_ value: DescribeMultiRegionAccessPointOperationInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DescribeMultiRegionAccessPointOperationInput {

    static func urlPathProvider(_ value: DescribeMultiRegionAccessPointOperationInput) -> Swift.String? {
        guard let requestTokenARN = value.requestTokenARN else {
            return nil
        }
        return "/v20180820/async-requests/mrap/\(requestTokenARN.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct DescribeMultiRegionAccessPointOperationInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the owner of the Multi-Region Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The request token associated with the request you want to know about. This request token is returned as part of the response when you make an asynchronous request. You provide this token to query about the status of the asynchronous action.
    /// This member is required.
    public var requestTokenARN: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        requestTokenARN: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.requestTokenARN = requestTokenARN
    }
}

extension DescribeMultiRegionAccessPointOperationOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DescribeMultiRegionAccessPointOperationOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = DescribeMultiRegionAccessPointOperationOutput()
            value.asyncOperation = try reader["AsyncOperation"].readIfPresent(readingClosure: S3ControlClientTypes.AsyncOperation.readingClosure)
            return value
        }
    }
}

public struct DescribeMultiRegionAccessPointOperationOutput: Swift.Equatable {
    /// A container element containing the details of the asynchronous operation.
    public var asyncOperation: S3ControlClientTypes.AsyncOperation?

    public init(
        asyncOperation: S3ControlClientTypes.AsyncOperation? = nil
    )
    {
        self.asyncOperation = asyncOperation
    }
}

enum DescribeMultiRegionAccessPointOperationOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension S3ControlClientTypes.Destination {

    static func writingClosure(_ value: S3ControlClientTypes.Destination?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["AccessControlTranslation"].write(value.accessControlTranslation, writingClosure: S3ControlClientTypes.AccessControlTranslation.writingClosure(_:to:))
        try writer["Account"].write(value.account)
        try writer["Bucket"].write(value.bucket)
        try writer["EncryptionConfiguration"].write(value.encryptionConfiguration, writingClosure: S3ControlClientTypes.EncryptionConfiguration.writingClosure(_:to:))
        try writer["Metrics"].write(value.metrics, writingClosure: S3ControlClientTypes.Metrics.writingClosure(_:to:))
        try writer["ReplicationTime"].write(value.replicationTime, writingClosure: S3ControlClientTypes.ReplicationTime.writingClosure(_:to:))
        try writer["StorageClass"].write(value.storageClass)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.Destination, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.Destination()
            value.account = try reader["Account"].readIfPresent()
            value.bucket = try reader["Bucket"].readIfPresent()
            value.replicationTime = try reader["ReplicationTime"].readIfPresent(readingClosure: S3ControlClientTypes.ReplicationTime.readingClosure)
            value.accessControlTranslation = try reader["AccessControlTranslation"].readIfPresent(readingClosure: S3ControlClientTypes.AccessControlTranslation.readingClosure)
            value.encryptionConfiguration = try reader["EncryptionConfiguration"].readIfPresent(readingClosure: S3ControlClientTypes.EncryptionConfiguration.readingClosure)
            value.metrics = try reader["Metrics"].readIfPresent(readingClosure: S3ControlClientTypes.Metrics.readingClosure)
            value.storageClass = try reader["StorageClass"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// Specifies information about the replication destination bucket and its settings for an S3 on Outposts replication configuration.
    public struct Destination: Swift.Equatable {
        /// Specify this property only in a cross-account scenario (where the source and destination bucket owners are not the same), and you want to change replica ownership to the Amazon Web Services account that owns the destination bucket. If this property is not specified in the replication configuration, the replicas are owned by same Amazon Web Services account that owns the source object. This is not supported by Amazon S3 on Outposts buckets.
        public var accessControlTranslation: S3ControlClientTypes.AccessControlTranslation?
        /// The destination bucket owner's account ID.
        public var account: Swift.String?
        /// The Amazon Resource Name (ARN) of the access point for the destination bucket where you want S3 on Outposts to store the replication results.
        /// This member is required.
        public var bucket: Swift.String?
        /// A container that provides information about encryption. If SourceSelectionCriteria is specified, you must specify this element. This is not supported by Amazon S3 on Outposts buckets.
        public var encryptionConfiguration: S3ControlClientTypes.EncryptionConfiguration?
        /// A container that specifies replication metrics-related settings.
        public var metrics: S3ControlClientTypes.Metrics?
        /// A container that specifies S3 Replication Time Control (S3 RTC) settings, including whether S3 RTC is enabled and the time when all objects and operations on objects must be replicated. Must be specified together with a Metrics block. This is not supported by Amazon S3 on Outposts buckets.
        public var replicationTime: S3ControlClientTypes.ReplicationTime?
        /// The storage class to use when replicating objects. All objects stored on S3 on Outposts are stored in the OUTPOSTS storage class. S3 on Outposts uses the OUTPOSTS storage class to create the object replicas. Values other than OUTPOSTS aren't supported by Amazon S3 on Outposts.
        public var storageClass: S3ControlClientTypes.ReplicationStorageClass?

        public init(
            accessControlTranslation: S3ControlClientTypes.AccessControlTranslation? = nil,
            account: Swift.String? = nil,
            bucket: Swift.String? = nil,
            encryptionConfiguration: S3ControlClientTypes.EncryptionConfiguration? = nil,
            metrics: S3ControlClientTypes.Metrics? = nil,
            replicationTime: S3ControlClientTypes.ReplicationTime? = nil,
            storageClass: S3ControlClientTypes.ReplicationStorageClass? = nil
        )
        {
            self.accessControlTranslation = accessControlTranslation
            self.account = account
            self.bucket = bucket
            self.encryptionConfiguration = encryptionConfiguration
            self.metrics = metrics
            self.replicationTime = replicationTime
            self.storageClass = storageClass
        }
    }

}

extension S3ControlClientTypes.DetailedStatusCodesMetrics {

    static func writingClosure(_ value: S3ControlClientTypes.DetailedStatusCodesMetrics?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["IsEnabled"].write(value.isEnabled)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.DetailedStatusCodesMetrics, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.DetailedStatusCodesMetrics()
            value.isEnabled = try reader["IsEnabled"].readIfPresent() ?? false
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// The container element for Amazon S3 Storage Lens detailed status code metrics. Detailed status code metrics generate metrics for HTTP status codes, such as 200 OK, 403 Forbidden, 503 Service Unavailable and others. For more information about S3 Storage Lens, see [Assessing your storage activity and usage with S3 Storage Lens](https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage_lens.html) in the Amazon S3 User Guide. For a complete list of S3 Storage Lens metrics, see [S3 Storage Lens metrics glossary](https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage_lens_metrics_glossary.html) in the Amazon S3 User Guide.
    public struct DetailedStatusCodesMetrics: Swift.Equatable {
        /// A container that indicates whether detailed status code metrics are enabled.
        public var isEnabled: Swift.Bool

        public init(
            isEnabled: Swift.Bool = false
        )
        {
            self.isEnabled = isEnabled
        }
    }

}

extension DissociateAccessGrantsIdentityCenterInput {

    static func headerProvider(_ value: DissociateAccessGrantsIdentityCenterInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DissociateAccessGrantsIdentityCenterInput {

    static func urlPathProvider(_ value: DissociateAccessGrantsIdentityCenterInput) -> Swift.String? {
        return "/v20180820/accessgrantsinstance/identitycenter"
    }
}

public struct DissociateAccessGrantsIdentityCenterInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that is making this request.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

extension DissociateAccessGrantsIdentityCenterOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DissociateAccessGrantsIdentityCenterOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DissociateAccessGrantsIdentityCenterOutput()
        }
    }
}

public struct DissociateAccessGrantsIdentityCenterOutput: Swift.Equatable {

    public init() { }
}

enum DissociateAccessGrantsIdentityCenterOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension S3ControlClientTypes.EncryptionConfiguration {

    static func writingClosure(_ value: S3ControlClientTypes.EncryptionConfiguration?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ReplicaKmsKeyID"].write(value.replicaKmsKeyID)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.EncryptionConfiguration, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.EncryptionConfiguration()
            value.replicaKmsKeyID = try reader["ReplicaKmsKeyID"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// Specifies encryption-related information for an Amazon S3 bucket that is a destination for replicated objects. This is not supported by Amazon S3 on Outposts buckets.
    public struct EncryptionConfiguration: Swift.Equatable {
        /// Specifies the ID of the customer managed KMS key that's stored in Key Management Service (KMS) for the destination bucket. This ID is either the Amazon Resource Name (ARN) for the KMS key or the alias ARN for the KMS key. Amazon S3 uses this KMS key to encrypt replica objects. Amazon S3 supports only symmetric encryption KMS keys. For more information, see [Symmetric encryption KMS keys](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#symmetric-cmks) in the Amazon Web Services Key Management Service Developer Guide.
        public var replicaKmsKeyID: Swift.String?

        public init(
            replicaKmsKeyID: Swift.String? = nil
        )
        {
            self.replicaKmsKeyID = replicaKmsKeyID
        }
    }

}

extension S3ControlClientTypes.EstablishedMultiRegionAccessPointPolicy {

    static func writingClosure(_ value: S3ControlClientTypes.EstablishedMultiRegionAccessPointPolicy?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Policy"].write(value.policy)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.EstablishedMultiRegionAccessPointPolicy, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.EstablishedMultiRegionAccessPointPolicy()
            value.policy = try reader["Policy"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// The last established access control policy for a Multi-Region Access Point. When you update the policy, the update is first listed as the proposed policy. After the update is finished and all Regions have been updated, the proposed policy is listed as the established policy. If both policies have the same version number, the proposed policy is the established policy.
    public struct EstablishedMultiRegionAccessPointPolicy: Swift.Equatable {
        /// The details of the last established policy.
        public var policy: Swift.String?

        public init(
            policy: Swift.String? = nil
        )
        {
            self.policy = policy
        }
    }

}

extension S3ControlClientTypes.Exclude {

    static func writingClosure(_ value: S3ControlClientTypes.Exclude?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Buckets"].writeList(value.buckets, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: "Arn", isFlattened: false)
        try writer["Regions"].writeList(value.regions, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: "Region", isFlattened: false)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.Exclude, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.Exclude()
            value.buckets = try reader["Buckets"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "Arn", isFlattened: false)
            value.regions = try reader["Regions"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "Region", isFlattened: false)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// A container for what Amazon S3 Storage Lens will exclude.
    public struct Exclude: Swift.Equatable {
        /// A container for the S3 Storage Lens bucket excludes.
        public var buckets: [Swift.String]?
        /// A container for the S3 Storage Lens Region excludes.
        public var regions: [Swift.String]?

        public init(
            buckets: [Swift.String]? = nil,
            regions: [Swift.String]? = nil
        )
        {
            self.buckets = buckets
            self.regions = regions
        }
    }

}

extension S3ControlClientTypes.ExistingObjectReplication {

    static func writingClosure(_ value: S3ControlClientTypes.ExistingObjectReplication?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Status"].write(value.status)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.ExistingObjectReplication, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.ExistingObjectReplication()
            value.status = try reader["Status"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// An optional configuration to replicate existing source bucket objects. This is not supported by Amazon S3 on Outposts buckets.
    public struct ExistingObjectReplication: Swift.Equatable {
        /// Specifies whether Amazon S3 replicates existing source bucket objects.
        /// This member is required.
        public var status: S3ControlClientTypes.ExistingObjectReplicationStatus?

        public init(
            status: S3ControlClientTypes.ExistingObjectReplicationStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension S3ControlClientTypes {
    public enum ExistingObjectReplicationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ExistingObjectReplicationStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExistingObjectReplicationStatus(rawValue: rawValue) ?? ExistingObjectReplicationStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum ExpirationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ExpirationStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExpirationStatus(rawValue: rawValue) ?? ExpirationStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum Format: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case parquet
        case sdkUnknown(Swift.String)

        public static var allCases: [Format] {
            return [
                .csv,
                .parquet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .parquet: return "Parquet"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Format(rawValue: rawValue) ?? Format.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.GeneratedManifestEncryption {

    static func writingClosure(_ value: S3ControlClientTypes.GeneratedManifestEncryption?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["SSE-KMS"].write(value.ssekms, writingClosure: S3ControlClientTypes.SSEKMSEncryption.writingClosure(_:to:))
        try writer["SSE-S3"].write(value.sses3, writingClosure: S3ControlClientTypes.SSES3Encryption.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.GeneratedManifestEncryption, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.GeneratedManifestEncryption()
            value.sses3 = try reader["SSE-S3"].readIfPresent(readingClosure: S3ControlClientTypes.SSES3Encryption.readingClosure)
            value.ssekms = try reader["SSE-KMS"].readIfPresent(readingClosure: S3ControlClientTypes.SSEKMSEncryption.readingClosure)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// The encryption configuration to use when storing the generated manifest.
    public struct GeneratedManifestEncryption: Swift.Equatable {
        /// Configuration details on how SSE-KMS is used to encrypt generated manifest objects.
        public var ssekms: S3ControlClientTypes.SSEKMSEncryption?
        /// Specifies the use of SSE-S3 to encrypt generated manifest objects.
        public var sses3: S3ControlClientTypes.SSES3Encryption?

        public init(
            ssekms: S3ControlClientTypes.SSEKMSEncryption? = nil,
            sses3: S3ControlClientTypes.SSES3Encryption? = nil
        )
        {
            self.ssekms = ssekms
            self.sses3 = sses3
        }
    }

}

extension S3ControlClientTypes {
    public enum GeneratedManifestFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case s3inventoryreportCsv20211130
        case sdkUnknown(Swift.String)

        public static var allCases: [GeneratedManifestFormat] {
            return [
                .s3inventoryreportCsv20211130,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .s3inventoryreportCsv20211130: return "S3InventoryReport_CSV_20211130"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GeneratedManifestFormat(rawValue: rawValue) ?? GeneratedManifestFormat.sdkUnknown(rawValue)
        }
    }
}

extension GetAccessGrantInput {

    static func headerProvider(_ value: GetAccessGrantInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetAccessGrantInput {

    static func urlPathProvider(_ value: GetAccessGrantInput) -> Swift.String? {
        guard let accessGrantId = value.accessGrantId else {
            return nil
        }
        return "/v20180820/accessgrantsinstance/grant/\(accessGrantId.urlPercentEncoding())"
    }
}

public struct GetAccessGrantInput: Swift.Equatable {
    /// The ID of the access grant. S3 Access Grants auto-generates this ID when you create the access grant.
    /// This member is required.
    public var accessGrantId: Swift.String?
    /// The ID of the Amazon Web Services account that is making this request.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accessGrantId: Swift.String? = nil,
        accountId: Swift.String? = nil
    )
    {
        self.accessGrantId = accessGrantId
        self.accountId = accountId
    }
}

extension GetAccessGrantOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetAccessGrantOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetAccessGrantOutput()
            value.accessGrantArn = try reader["AccessGrantArn"].readIfPresent()
            value.accessGrantId = try reader["AccessGrantId"].readIfPresent()
            value.accessGrantsLocationConfiguration = try reader["AccessGrantsLocationConfiguration"].readIfPresent(readingClosure: S3ControlClientTypes.AccessGrantsLocationConfiguration.readingClosure)
            value.accessGrantsLocationId = try reader["AccessGrantsLocationId"].readIfPresent()
            value.applicationArn = try reader["ApplicationArn"].readIfPresent()
            value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: .dateTime)
            value.grantScope = try reader["GrantScope"].readIfPresent()
            value.grantee = try reader["Grantee"].readIfPresent(readingClosure: S3ControlClientTypes.Grantee.readingClosure)
            value.permission = try reader["Permission"].readIfPresent()
            return value
        }
    }
}

public struct GetAccessGrantOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the access grant.
    public var accessGrantArn: Swift.String?
    /// The ID of the access grant. S3 Access Grants auto-generates this ID when you create the access grant.
    public var accessGrantId: Swift.String?
    /// The configuration options of the grant location. The grant location is the S3 path to the data to which you are granting access.
    public var accessGrantsLocationConfiguration: S3ControlClientTypes.AccessGrantsLocationConfiguration?
    /// The ID of the registered location to which you are granting access. S3 Access Grants assigns this ID when you register the location. S3 Access Grants assigns the ID default to the default location s3:// and assigns an auto-generated ID to other locations that you register.
    public var accessGrantsLocationId: Swift.String?
    /// The Amazon Resource Name (ARN) of an Amazon Web Services IAM Identity Center application associated with your Identity Center instance. If the grant includes an application ARN, the grantee can only access the S3 data through this application.
    public var applicationArn: Swift.String?
    /// The date and time when you created the access grant.
    public var createdAt: ClientRuntime.Date?
    /// The S3 path of the data to which you are granting access. It is the result of appending the Subprefix to the location scope.
    public var grantScope: Swift.String?
    /// The user, group, or role to which you are granting access. You can grant access to an IAM user or role. If you have added a corporate directory to Amazon Web Services IAM Identity Center and associated this Identity Center instance with the S3 Access Grants instance, the grantee can also be a corporate directory user or group.
    public var grantee: S3ControlClientTypes.Grantee?
    /// The type of permission that was granted in the access grant. Can be one of the following values:
    ///
    /// * READ – Grant read-only access to the S3 data.
    ///
    /// * WRITE – Grant write-only access to the S3 data.
    ///
    /// * READWRITE – Grant both read and write access to the S3 data.
    public var permission: S3ControlClientTypes.Permission?

    public init(
        accessGrantArn: Swift.String? = nil,
        accessGrantId: Swift.String? = nil,
        accessGrantsLocationConfiguration: S3ControlClientTypes.AccessGrantsLocationConfiguration? = nil,
        accessGrantsLocationId: Swift.String? = nil,
        applicationArn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        grantScope: Swift.String? = nil,
        grantee: S3ControlClientTypes.Grantee? = nil,
        permission: S3ControlClientTypes.Permission? = nil
    )
    {
        self.accessGrantArn = accessGrantArn
        self.accessGrantId = accessGrantId
        self.accessGrantsLocationConfiguration = accessGrantsLocationConfiguration
        self.accessGrantsLocationId = accessGrantsLocationId
        self.applicationArn = applicationArn
        self.createdAt = createdAt
        self.grantScope = grantScope
        self.grantee = grantee
        self.permission = permission
    }
}

enum GetAccessGrantOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetAccessGrantsInstanceForPrefixInput {

    static func headerProvider(_ value: GetAccessGrantsInstanceForPrefixInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetAccessGrantsInstanceForPrefixInput {

    static func queryItemProvider(_ value: GetAccessGrantsInstanceForPrefixInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let s3Prefix = value.s3Prefix else {
            let message = "Creating a URL Query Item failed. s3Prefix is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let s3PrefixQueryItem = ClientRuntime.SDKURLQueryItem(name: "s3prefix".urlPercentEncoding(), value: Swift.String(s3Prefix).urlPercentEncoding())
        items.append(s3PrefixQueryItem)
        return items
    }
}

extension GetAccessGrantsInstanceForPrefixInput {

    static func urlPathProvider(_ value: GetAccessGrantsInstanceForPrefixInput) -> Swift.String? {
        return "/v20180820/accessgrantsinstance/prefix"
    }
}

public struct GetAccessGrantsInstanceForPrefixInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that is making this request.
    /// This member is required.
    public var accountId: Swift.String?
    /// The S3 prefix of the access grants that you would like to retrieve.
    /// This member is required.
    public var s3Prefix: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        s3Prefix: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.s3Prefix = s3Prefix
    }
}

extension GetAccessGrantsInstanceForPrefixOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetAccessGrantsInstanceForPrefixOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetAccessGrantsInstanceForPrefixOutput()
            value.accessGrantsInstanceArn = try reader["AccessGrantsInstanceArn"].readIfPresent()
            value.accessGrantsInstanceId = try reader["AccessGrantsInstanceId"].readIfPresent()
            return value
        }
    }
}

public struct GetAccessGrantsInstanceForPrefixOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the S3 Access Grants instance.
    public var accessGrantsInstanceArn: Swift.String?
    /// The ID of the S3 Access Grants instance. The ID is default. You can have one S3 Access Grants instance per Region per account.
    public var accessGrantsInstanceId: Swift.String?

    public init(
        accessGrantsInstanceArn: Swift.String? = nil,
        accessGrantsInstanceId: Swift.String? = nil
    )
    {
        self.accessGrantsInstanceArn = accessGrantsInstanceArn
        self.accessGrantsInstanceId = accessGrantsInstanceId
    }
}

enum GetAccessGrantsInstanceForPrefixOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetAccessGrantsInstanceInput {

    static func headerProvider(_ value: GetAccessGrantsInstanceInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetAccessGrantsInstanceInput {

    static func urlPathProvider(_ value: GetAccessGrantsInstanceInput) -> Swift.String? {
        return "/v20180820/accessgrantsinstance"
    }
}

public struct GetAccessGrantsInstanceInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that is making this request.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

extension GetAccessGrantsInstanceOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetAccessGrantsInstanceOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetAccessGrantsInstanceOutput()
            value.accessGrantsInstanceArn = try reader["AccessGrantsInstanceArn"].readIfPresent()
            value.accessGrantsInstanceId = try reader["AccessGrantsInstanceId"].readIfPresent()
            value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: .dateTime)
            value.identityCenterArn = try reader["IdentityCenterArn"].readIfPresent()
            return value
        }
    }
}

public struct GetAccessGrantsInstanceOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the S3 Access Grants instance.
    public var accessGrantsInstanceArn: Swift.String?
    /// The ID of the S3 Access Grants instance. The ID is default. You can have one S3 Access Grants instance per Region per account.
    public var accessGrantsInstanceId: Swift.String?
    /// The date and time when you created the S3 Access Grants instance.
    public var createdAt: ClientRuntime.Date?
    /// If you associated your S3 Access Grants instance with an Amazon Web Services IAM Identity Center instance, this field returns the Amazon Resource Name (ARN) of the Amazon Web Services IAM Identity Center instance application; a subresource of the original Identity Center instance. S3 Access Grants creates this Identity Center application for the specific S3 Access Grants instance.
    public var identityCenterArn: Swift.String?

    public init(
        accessGrantsInstanceArn: Swift.String? = nil,
        accessGrantsInstanceId: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        identityCenterArn: Swift.String? = nil
    )
    {
        self.accessGrantsInstanceArn = accessGrantsInstanceArn
        self.accessGrantsInstanceId = accessGrantsInstanceId
        self.createdAt = createdAt
        self.identityCenterArn = identityCenterArn
    }
}

enum GetAccessGrantsInstanceOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetAccessGrantsInstanceResourcePolicyInput {

    static func headerProvider(_ value: GetAccessGrantsInstanceResourcePolicyInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetAccessGrantsInstanceResourcePolicyInput {

    static func urlPathProvider(_ value: GetAccessGrantsInstanceResourcePolicyInput) -> Swift.String? {
        return "/v20180820/accessgrantsinstance/resourcepolicy"
    }
}

public struct GetAccessGrantsInstanceResourcePolicyInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that is making this request.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

extension GetAccessGrantsInstanceResourcePolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetAccessGrantsInstanceResourcePolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetAccessGrantsInstanceResourcePolicyOutput()
            value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: .dateTime)
            value.organization = try reader["Organization"].readIfPresent()
            value.policy = try reader["Policy"].readIfPresent()
            return value
        }
    }
}

public struct GetAccessGrantsInstanceResourcePolicyOutput: Swift.Equatable {
    /// The date and time when you created the S3 Access Grants instance resource policy.
    public var createdAt: ClientRuntime.Date?
    /// The Organization of the resource policy of the S3 Access Grants instance.
    public var organization: Swift.String?
    /// The resource policy of the S3 Access Grants instance.
    public var policy: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        organization: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.organization = organization
        self.policy = policy
    }
}

enum GetAccessGrantsInstanceResourcePolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetAccessGrantsLocationInput {

    static func headerProvider(_ value: GetAccessGrantsLocationInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetAccessGrantsLocationInput {

    static func urlPathProvider(_ value: GetAccessGrantsLocationInput) -> Swift.String? {
        guard let accessGrantsLocationId = value.accessGrantsLocationId else {
            return nil
        }
        return "/v20180820/accessgrantsinstance/location/\(accessGrantsLocationId.urlPercentEncoding())"
    }
}

public struct GetAccessGrantsLocationInput: Swift.Equatable {
    /// The ID of the registered location that you are retrieving. S3 Access Grants assigns this ID when you register the location. S3 Access Grants assigns the ID default to the default location s3:// and assigns an auto-generated ID to other locations that you register.
    /// This member is required.
    public var accessGrantsLocationId: Swift.String?
    /// The ID of the Amazon Web Services account that is making this request.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accessGrantsLocationId: Swift.String? = nil,
        accountId: Swift.String? = nil
    )
    {
        self.accessGrantsLocationId = accessGrantsLocationId
        self.accountId = accountId
    }
}

extension GetAccessGrantsLocationOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetAccessGrantsLocationOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetAccessGrantsLocationOutput()
            value.accessGrantsLocationArn = try reader["AccessGrantsLocationArn"].readIfPresent()
            value.accessGrantsLocationId = try reader["AccessGrantsLocationId"].readIfPresent()
            value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: .dateTime)
            value.iamRoleArn = try reader["IAMRoleArn"].readIfPresent()
            value.locationScope = try reader["LocationScope"].readIfPresent()
            return value
        }
    }
}

public struct GetAccessGrantsLocationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the registered location.
    public var accessGrantsLocationArn: Swift.String?
    /// The ID of the registered location to which you are granting access. S3 Access Grants assigns this ID when you register the location. S3 Access Grants assigns the ID default to the default location s3:// and assigns an auto-generated ID to other locations that you register.
    public var accessGrantsLocationId: Swift.String?
    /// The date and time when you registered the location.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the IAM role for the registered location. S3 Access Grants assumes this role to manage access to the registered location.
    public var iamRoleArn: Swift.String?
    /// The S3 URI path to the registered location. The location scope can be the default S3 location s3://, the S3 path to a bucket, or the S3 path to a bucket and prefix. A prefix in S3 is a string of characters at the beginning of an object key name used to organize the objects that you store in your S3 buckets. For example, object key names that start with the engineering/ prefix or object key names that start with the marketing/campaigns/ prefix.
    public var locationScope: Swift.String?

    public init(
        accessGrantsLocationArn: Swift.String? = nil,
        accessGrantsLocationId: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        iamRoleArn: Swift.String? = nil,
        locationScope: Swift.String? = nil
    )
    {
        self.accessGrantsLocationArn = accessGrantsLocationArn
        self.accessGrantsLocationId = accessGrantsLocationId
        self.createdAt = createdAt
        self.iamRoleArn = iamRoleArn
        self.locationScope = locationScope
    }
}

enum GetAccessGrantsLocationOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetAccessPointConfigurationForObjectLambdaInput {

    static func headerProvider(_ value: GetAccessPointConfigurationForObjectLambdaInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetAccessPointConfigurationForObjectLambdaInput {

    static func urlPathProvider(_ value: GetAccessPointConfigurationForObjectLambdaInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/v20180820/accesspointforobjectlambda/\(name.urlPercentEncoding())/configuration"
    }
}

public struct GetAccessPointConfigurationForObjectLambdaInput: Swift.Equatable {
    /// The account ID for the account that owns the specified Object Lambda Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the Object Lambda Access Point you want to return the configuration for.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

extension GetAccessPointConfigurationForObjectLambdaOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetAccessPointConfigurationForObjectLambdaOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetAccessPointConfigurationForObjectLambdaOutput()
            value.configuration = try reader["Configuration"].readIfPresent(readingClosure: S3ControlClientTypes.ObjectLambdaConfiguration.readingClosure)
            return value
        }
    }
}

public struct GetAccessPointConfigurationForObjectLambdaOutput: Swift.Equatable {
    /// Object Lambda Access Point configuration document.
    public var configuration: S3ControlClientTypes.ObjectLambdaConfiguration?

    public init(
        configuration: S3ControlClientTypes.ObjectLambdaConfiguration? = nil
    )
    {
        self.configuration = configuration
    }
}

enum GetAccessPointConfigurationForObjectLambdaOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetAccessPointForObjectLambdaInput {

    static func headerProvider(_ value: GetAccessPointForObjectLambdaInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetAccessPointForObjectLambdaInput {

    static func urlPathProvider(_ value: GetAccessPointForObjectLambdaInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/v20180820/accesspointforobjectlambda/\(name.urlPercentEncoding())"
    }
}

public struct GetAccessPointForObjectLambdaInput: Swift.Equatable {
    /// The account ID for the account that owns the specified Object Lambda Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the Object Lambda Access Point.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

extension GetAccessPointForObjectLambdaOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetAccessPointForObjectLambdaOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetAccessPointForObjectLambdaOutput()
            value.alias = try reader["Alias"].readIfPresent(readingClosure: S3ControlClientTypes.ObjectLambdaAccessPointAlias.readingClosure)
            value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: .dateTime)
            value.name = try reader["Name"].readIfPresent()
            value.publicAccessBlockConfiguration = try reader["PublicAccessBlockConfiguration"].readIfPresent(readingClosure: S3ControlClientTypes.PublicAccessBlockConfiguration.readingClosure)
            return value
        }
    }
}

public struct GetAccessPointForObjectLambdaOutput: Swift.Equatable {
    /// The alias of the Object Lambda Access Point.
    public var alias: S3ControlClientTypes.ObjectLambdaAccessPointAlias?
    /// The date and time when the specified Object Lambda Access Point was created.
    public var creationDate: ClientRuntime.Date?
    /// The name of the Object Lambda Access Point.
    public var name: Swift.String?
    /// Configuration to block all public access. This setting is turned on and can not be edited.
    public var publicAccessBlockConfiguration: S3ControlClientTypes.PublicAccessBlockConfiguration?

    public init(
        alias: S3ControlClientTypes.ObjectLambdaAccessPointAlias? = nil,
        creationDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        publicAccessBlockConfiguration: S3ControlClientTypes.PublicAccessBlockConfiguration? = nil
    )
    {
        self.alias = alias
        self.creationDate = creationDate
        self.name = name
        self.publicAccessBlockConfiguration = publicAccessBlockConfiguration
    }
}

enum GetAccessPointForObjectLambdaOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetAccessPointInput {

    static func headerProvider(_ value: GetAccessPointInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetAccessPointInput {

    static func urlPathProvider(_ value: GetAccessPointInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/v20180820/accesspoint/\(name.urlPercentEncoding())"
    }
}

public struct GetAccessPointInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the account that owns the specified access point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the access point whose configuration information you want to retrieve. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the access point accessed in the format arn:aws:s3-outposts:::outpost//accesspoint/. For example, to access the access point reports-ap through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/accesspoint/reports-ap. The value must be URL encoded.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

extension GetAccessPointOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetAccessPointOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetAccessPointOutput()
            value.accessPointArn = try reader["AccessPointArn"].readIfPresent()
            value.alias = try reader["Alias"].readIfPresent()
            value.bucket = try reader["Bucket"].readIfPresent()
            value.bucketAccountId = try reader["BucketAccountId"].readIfPresent()
            value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: .dateTime)
            value.endpoints = try reader["Endpoints"].readMapIfPresent(valueReadingClosure: Swift.String.readingClosure, keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
            value.name = try reader["Name"].readIfPresent()
            value.networkOrigin = try reader["NetworkOrigin"].readIfPresent()
            value.publicAccessBlockConfiguration = try reader["PublicAccessBlockConfiguration"].readIfPresent(readingClosure: S3ControlClientTypes.PublicAccessBlockConfiguration.readingClosure)
            value.vpcConfiguration = try reader["VpcConfiguration"].readIfPresent(readingClosure: S3ControlClientTypes.VpcConfiguration.readingClosure)
            return value
        }
    }
}

public struct GetAccessPointOutput: Swift.Equatable {
    /// The ARN of the access point.
    public var accessPointArn: Swift.String?
    /// The name or alias of the access point.
    public var alias: Swift.String?
    /// The name of the bucket associated with the specified access point.
    public var bucket: Swift.String?
    /// The Amazon Web Services account ID associated with the S3 bucket associated with this access point.
    public var bucketAccountId: Swift.String?
    /// The date and time when the specified access point was created.
    public var creationDate: ClientRuntime.Date?
    /// The VPC endpoint for the access point.
    public var endpoints: [Swift.String:Swift.String]?
    /// The name of the specified access point.
    public var name: Swift.String?
    /// Indicates whether this access point allows access from the public internet. If VpcConfiguration is specified for this access point, then NetworkOrigin is VPC, and the access point doesn't allow access from the public internet. Otherwise, NetworkOrigin is Internet, and the access point allows access from the public internet, subject to the access point and bucket access policies. This will always be true for an Amazon S3 on Outposts access point
    public var networkOrigin: S3ControlClientTypes.NetworkOrigin?
    /// The PublicAccessBlock configuration that you want to apply to this Amazon S3 account. You can enable the configuration options in any combination. For more information about when Amazon S3 considers a bucket or object public, see [The Meaning of "Public"](https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status) in the Amazon S3 User Guide. This data type is not supported for Amazon S3 on Outposts.
    public var publicAccessBlockConfiguration: S3ControlClientTypes.PublicAccessBlockConfiguration?
    /// Contains the virtual private cloud (VPC) configuration for the specified access point. This element is empty if this access point is an Amazon S3 on Outposts access point that is used by other Amazon Web Services.
    public var vpcConfiguration: S3ControlClientTypes.VpcConfiguration?

    public init(
        accessPointArn: Swift.String? = nil,
        alias: Swift.String? = nil,
        bucket: Swift.String? = nil,
        bucketAccountId: Swift.String? = nil,
        creationDate: ClientRuntime.Date? = nil,
        endpoints: [Swift.String:Swift.String]? = nil,
        name: Swift.String? = nil,
        networkOrigin: S3ControlClientTypes.NetworkOrigin? = nil,
        publicAccessBlockConfiguration: S3ControlClientTypes.PublicAccessBlockConfiguration? = nil,
        vpcConfiguration: S3ControlClientTypes.VpcConfiguration? = nil
    )
    {
        self.accessPointArn = accessPointArn
        self.alias = alias
        self.bucket = bucket
        self.bucketAccountId = bucketAccountId
        self.creationDate = creationDate
        self.endpoints = endpoints
        self.name = name
        self.networkOrigin = networkOrigin
        self.publicAccessBlockConfiguration = publicAccessBlockConfiguration
        self.vpcConfiguration = vpcConfiguration
    }
}

enum GetAccessPointOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetAccessPointPolicyForObjectLambdaInput {

    static func headerProvider(_ value: GetAccessPointPolicyForObjectLambdaInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetAccessPointPolicyForObjectLambdaInput {

    static func urlPathProvider(_ value: GetAccessPointPolicyForObjectLambdaInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/v20180820/accesspointforobjectlambda/\(name.urlPercentEncoding())/policy"
    }
}

public struct GetAccessPointPolicyForObjectLambdaInput: Swift.Equatable {
    /// The account ID for the account that owns the specified Object Lambda Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the Object Lambda Access Point.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

extension GetAccessPointPolicyForObjectLambdaOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetAccessPointPolicyForObjectLambdaOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetAccessPointPolicyForObjectLambdaOutput()
            value.policy = try reader["Policy"].readIfPresent()
            return value
        }
    }
}

public struct GetAccessPointPolicyForObjectLambdaOutput: Swift.Equatable {
    /// Object Lambda Access Point resource policy document.
    public var policy: Swift.String?

    public init(
        policy: Swift.String? = nil
    )
    {
        self.policy = policy
    }
}

enum GetAccessPointPolicyForObjectLambdaOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetAccessPointPolicyInput {

    static func headerProvider(_ value: GetAccessPointPolicyInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetAccessPointPolicyInput {

    static func urlPathProvider(_ value: GetAccessPointPolicyInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/v20180820/accesspoint/\(name.urlPercentEncoding())/policy"
    }
}

public struct GetAccessPointPolicyInput: Swift.Equatable {
    /// The account ID for the account that owns the specified access point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the access point whose policy you want to retrieve. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the access point accessed in the format arn:aws:s3-outposts:::outpost//accesspoint/. For example, to access the access point reports-ap through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/accesspoint/reports-ap. The value must be URL encoded.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

extension GetAccessPointPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetAccessPointPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetAccessPointPolicyOutput()
            value.policy = try reader["Policy"].readIfPresent()
            return value
        }
    }
}

public struct GetAccessPointPolicyOutput: Swift.Equatable {
    /// The access point policy associated with the specified access point.
    public var policy: Swift.String?

    public init(
        policy: Swift.String? = nil
    )
    {
        self.policy = policy
    }
}

enum GetAccessPointPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetAccessPointPolicyStatusForObjectLambdaInput {

    static func headerProvider(_ value: GetAccessPointPolicyStatusForObjectLambdaInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetAccessPointPolicyStatusForObjectLambdaInput {

    static func urlPathProvider(_ value: GetAccessPointPolicyStatusForObjectLambdaInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/v20180820/accesspointforobjectlambda/\(name.urlPercentEncoding())/policyStatus"
    }
}

public struct GetAccessPointPolicyStatusForObjectLambdaInput: Swift.Equatable {
    /// The account ID for the account that owns the specified Object Lambda Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the Object Lambda Access Point.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

extension GetAccessPointPolicyStatusForObjectLambdaOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetAccessPointPolicyStatusForObjectLambdaOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetAccessPointPolicyStatusForObjectLambdaOutput()
            value.policyStatus = try reader["PolicyStatus"].readIfPresent(readingClosure: S3ControlClientTypes.PolicyStatus.readingClosure)
            return value
        }
    }
}

public struct GetAccessPointPolicyStatusForObjectLambdaOutput: Swift.Equatable {
    /// Indicates whether this access point policy is public. For more information about how Amazon S3 evaluates policies to determine whether they are public, see [The Meaning of "Public"](https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status) in the Amazon S3 User Guide.
    public var policyStatus: S3ControlClientTypes.PolicyStatus?

    public init(
        policyStatus: S3ControlClientTypes.PolicyStatus? = nil
    )
    {
        self.policyStatus = policyStatus
    }
}

enum GetAccessPointPolicyStatusForObjectLambdaOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetAccessPointPolicyStatusInput {

    static func headerProvider(_ value: GetAccessPointPolicyStatusInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetAccessPointPolicyStatusInput {

    static func urlPathProvider(_ value: GetAccessPointPolicyStatusInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/v20180820/accesspoint/\(name.urlPercentEncoding())/policyStatus"
    }
}

public struct GetAccessPointPolicyStatusInput: Swift.Equatable {
    /// The account ID for the account that owns the specified access point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the access point whose policy status you want to retrieve.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

extension GetAccessPointPolicyStatusOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetAccessPointPolicyStatusOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetAccessPointPolicyStatusOutput()
            value.policyStatus = try reader["PolicyStatus"].readIfPresent(readingClosure: S3ControlClientTypes.PolicyStatus.readingClosure)
            return value
        }
    }
}

public struct GetAccessPointPolicyStatusOutput: Swift.Equatable {
    /// Indicates the current policy status of the specified access point.
    public var policyStatus: S3ControlClientTypes.PolicyStatus?

    public init(
        policyStatus: S3ControlClientTypes.PolicyStatus? = nil
    )
    {
        self.policyStatus = policyStatus
    }
}

enum GetAccessPointPolicyStatusOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetBucketInput {

    static func headerProvider(_ value: GetBucketInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetBucketInput {

    static func urlPathProvider(_ value: GetBucketInput) -> Swift.String? {
        guard let bucket = value.bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())"
    }
}

public struct GetBucketInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    /// Specifies the bucket. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
    }
}

extension GetBucketLifecycleConfigurationInput {

    static func headerProvider(_ value: GetBucketLifecycleConfigurationInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetBucketLifecycleConfigurationInput {

    static func urlPathProvider(_ value: GetBucketLifecycleConfigurationInput) -> Swift.String? {
        guard let bucket = value.bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/lifecycleconfiguration"
    }
}

public struct GetBucketLifecycleConfigurationInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    /// The Amazon Resource Name (ARN) of the bucket. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
    }
}

extension GetBucketLifecycleConfigurationOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetBucketLifecycleConfigurationOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetBucketLifecycleConfigurationOutput()
            value.rules = try reader["Rules"].readListIfPresent(memberReadingClosure: S3ControlClientTypes.LifecycleRule.readingClosure, memberNodeInfo: "Rule", isFlattened: false)
            return value
        }
    }
}

public struct GetBucketLifecycleConfigurationOutput: Swift.Equatable {
    /// Container for the lifecycle rule of the Outposts bucket.
    public var rules: [S3ControlClientTypes.LifecycleRule]?

    public init(
        rules: [S3ControlClientTypes.LifecycleRule]? = nil
    )
    {
        self.rules = rules
    }
}

enum GetBucketLifecycleConfigurationOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetBucketOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetBucketOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetBucketOutput()
            value.bucket = try reader["Bucket"].readIfPresent()
            value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: .dateTime)
            value.publicAccessBlockEnabled = try reader["PublicAccessBlockEnabled"].readIfPresent() ?? false
            return value
        }
    }
}

public struct GetBucketOutput: Swift.Equatable {
    /// The Outposts bucket requested.
    public var bucket: Swift.String?
    /// The creation date of the Outposts bucket.
    public var creationDate: ClientRuntime.Date?
    ///
    public var publicAccessBlockEnabled: Swift.Bool

    public init(
        bucket: Swift.String? = nil,
        creationDate: ClientRuntime.Date? = nil,
        publicAccessBlockEnabled: Swift.Bool = false
    )
    {
        self.bucket = bucket
        self.creationDate = creationDate
        self.publicAccessBlockEnabled = publicAccessBlockEnabled
    }
}

enum GetBucketOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetBucketPolicyInput {

    static func headerProvider(_ value: GetBucketPolicyInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetBucketPolicyInput {

    static func urlPathProvider(_ value: GetBucketPolicyInput) -> Swift.String? {
        guard let bucket = value.bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/policy"
    }
}

public struct GetBucketPolicyInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    /// Specifies the bucket. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
    }
}

extension GetBucketPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetBucketPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetBucketPolicyOutput()
            value.policy = try reader["Policy"].readIfPresent()
            return value
        }
    }
}

public struct GetBucketPolicyOutput: Swift.Equatable {
    /// The policy of the Outposts bucket.
    public var policy: Swift.String?

    public init(
        policy: Swift.String? = nil
    )
    {
        self.policy = policy
    }
}

enum GetBucketPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetBucketReplicationInput {

    static func headerProvider(_ value: GetBucketReplicationInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetBucketReplicationInput {

    static func urlPathProvider(_ value: GetBucketReplicationInput) -> Swift.String? {
        guard let bucket = value.bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/replication"
    }
}

public struct GetBucketReplicationInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    /// Specifies the bucket to get the replication information for. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
    }
}

extension GetBucketReplicationOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetBucketReplicationOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetBucketReplicationOutput()
            value.replicationConfiguration = try reader["ReplicationConfiguration"].readIfPresent(readingClosure: S3ControlClientTypes.ReplicationConfiguration.readingClosure)
            return value
        }
    }
}

public struct GetBucketReplicationOutput: Swift.Equatable {
    /// A container for one or more replication rules. A replication configuration must have at least one rule and you can add up to 100 rules. The maximum size of a replication configuration is 128 KB.
    public var replicationConfiguration: S3ControlClientTypes.ReplicationConfiguration?

    public init(
        replicationConfiguration: S3ControlClientTypes.ReplicationConfiguration? = nil
    )
    {
        self.replicationConfiguration = replicationConfiguration
    }
}

enum GetBucketReplicationOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetBucketTaggingInput {

    static func headerProvider(_ value: GetBucketTaggingInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetBucketTaggingInput {

    static func urlPathProvider(_ value: GetBucketTaggingInput) -> Swift.String? {
        guard let bucket = value.bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/tagging"
    }
}

public struct GetBucketTaggingInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    /// Specifies the bucket. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
    }
}

extension GetBucketTaggingOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetBucketTaggingOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetBucketTaggingOutput()
            value.tagSet = try reader["TagSet"].readListIfPresent(memberReadingClosure: S3ControlClientTypes.S3Tag.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

public struct GetBucketTaggingOutput: Swift.Equatable {
    /// The tags set of the Outposts bucket.
    /// This member is required.
    public var tagSet: [S3ControlClientTypes.S3Tag]?

    public init(
        tagSet: [S3ControlClientTypes.S3Tag]? = nil
    )
    {
        self.tagSet = tagSet
    }
}

enum GetBucketTaggingOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetBucketVersioningInput {

    static func headerProvider(_ value: GetBucketVersioningInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetBucketVersioningInput {

    static func urlPathProvider(_ value: GetBucketVersioningInput) -> Swift.String? {
        guard let bucket = value.bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/versioning"
    }
}

public struct GetBucketVersioningInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the S3 on Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    /// The S3 on Outposts bucket to return the versioning state for.
    /// This member is required.
    public var bucket: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
    }
}

extension GetBucketVersioningOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetBucketVersioningOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetBucketVersioningOutput()
            value.mfaDelete = try reader["MfaDelete"].readIfPresent()
            value.status = try reader["Status"].readIfPresent()
            return value
        }
    }
}

public struct GetBucketVersioningOutput: Swift.Equatable {
    /// Specifies whether MFA delete is enabled in the bucket versioning configuration. This element is returned only if the bucket has been configured with MFA delete. If MFA delete has never been configured for the bucket, this element is not returned.
    public var mfaDelete: S3ControlClientTypes.MFADeleteStatus?
    /// The versioning state of the S3 on Outposts bucket.
    public var status: S3ControlClientTypes.BucketVersioningStatus?

    public init(
        mfaDelete: S3ControlClientTypes.MFADeleteStatus? = nil,
        status: S3ControlClientTypes.BucketVersioningStatus? = nil
    )
    {
        self.mfaDelete = mfaDelete
        self.status = status
    }
}

enum GetBucketVersioningOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetDataAccessInput {

    static func headerProvider(_ value: GetDataAccessInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetDataAccessInput {

    static func queryItemProvider(_ value: GetDataAccessInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let target = value.target else {
            let message = "Creating a URL Query Item failed. target is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let targetQueryItem = ClientRuntime.SDKURLQueryItem(name: "target".urlPercentEncoding(), value: Swift.String(target).urlPercentEncoding())
        items.append(targetQueryItem)
        guard let permission = value.permission else {
            let message = "Creating a URL Query Item failed. permission is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let permissionQueryItem = ClientRuntime.SDKURLQueryItem(name: "permission".urlPercentEncoding(), value: Swift.String(permission.rawValue).urlPercentEncoding())
        items.append(permissionQueryItem)
        if let targetType = value.targetType {
            let targetTypeQueryItem = ClientRuntime.SDKURLQueryItem(name: "targetType".urlPercentEncoding(), value: Swift.String(targetType.rawValue).urlPercentEncoding())
            items.append(targetTypeQueryItem)
        }
        if let durationSeconds = value.durationSeconds {
            let durationSecondsQueryItem = ClientRuntime.SDKURLQueryItem(name: "durationSeconds".urlPercentEncoding(), value: Swift.String(durationSeconds).urlPercentEncoding())
            items.append(durationSecondsQueryItem)
        }
        if let privilege = value.privilege {
            let privilegeQueryItem = ClientRuntime.SDKURLQueryItem(name: "privilege".urlPercentEncoding(), value: Swift.String(privilege.rawValue).urlPercentEncoding())
            items.append(privilegeQueryItem)
        }
        return items
    }
}

extension GetDataAccessInput {

    static func urlPathProvider(_ value: GetDataAccessInput) -> Swift.String? {
        return "/v20180820/accessgrantsinstance/dataaccess"
    }
}

public struct GetDataAccessInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that is making this request.
    /// This member is required.
    public var accountId: Swift.String?
    /// The session duration, in seconds, of the temporary access credential that S3 Access Grants vends to the grantee or client application. The default value is 1 hour, but the grantee can specify a range from 900 seconds (15 minutes) up to 43200 seconds (12 hours). If the grantee requests a value higher than this maximum, the operation fails.
    public var durationSeconds: Swift.Int?
    /// The type of permission granted to your S3 data, which can be set to one of the following values:
    ///
    /// * READ – Grant read-only access to the S3 data.
    ///
    /// * WRITE – Grant write-only access to the S3 data.
    ///
    /// * READWRITE – Grant both read and write access to the S3 data.
    /// This member is required.
    public var permission: S3ControlClientTypes.Permission?
    /// The scope of the temporary access credential that S3 Access Grants vends to the grantee or client application.
    ///
    /// * Default – The scope of the returned temporary access token is the scope of the grant that is closest to the target scope.
    ///
    /// * Minimal – The scope of the returned temporary access token is the same as the requested target scope as long as the requested scope is the same as or a subset of the grant scope.
    public var privilege: S3ControlClientTypes.Privilege?
    /// The S3 URI path of the data to which you are requesting temporary access credentials. If the requesting account has an access grant for this data, S3 Access Grants vends temporary access credentials in the response.
    /// This member is required.
    public var target: Swift.String?
    /// The type of Target. The only possible value is Object. Pass this value if the target data that you would like to access is a path to an object. Do not pass this value if the target data is a bucket or a bucket and a prefix.
    public var targetType: S3ControlClientTypes.S3PrefixType?

    public init(
        accountId: Swift.String? = nil,
        durationSeconds: Swift.Int? = nil,
        permission: S3ControlClientTypes.Permission? = nil,
        privilege: S3ControlClientTypes.Privilege? = nil,
        target: Swift.String? = nil,
        targetType: S3ControlClientTypes.S3PrefixType? = nil
    )
    {
        self.accountId = accountId
        self.durationSeconds = durationSeconds
        self.permission = permission
        self.privilege = privilege
        self.target = target
        self.targetType = targetType
    }
}

extension GetDataAccessOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDataAccessOutput(matchedGrantTarget: \(Swift.String(describing: matchedGrantTarget)), credentials: \"CONTENT_REDACTED\")"}
}

extension GetDataAccessOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetDataAccessOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetDataAccessOutput()
            value.credentials = try reader["Credentials"].readIfPresent(readingClosure: S3ControlClientTypes.Credentials.readingClosure)
            value.matchedGrantTarget = try reader["MatchedGrantTarget"].readIfPresent()
            return value
        }
    }
}

public struct GetDataAccessOutput: Swift.Equatable {
    /// The temporary credential token that S3 Access Grants vends.
    public var credentials: S3ControlClientTypes.Credentials?
    /// The S3 URI path of the data to which you are being granted temporary access credentials.
    public var matchedGrantTarget: Swift.String?

    public init(
        credentials: S3ControlClientTypes.Credentials? = nil,
        matchedGrantTarget: Swift.String? = nil
    )
    {
        self.credentials = credentials
        self.matchedGrantTarget = matchedGrantTarget
    }
}

enum GetDataAccessOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetJobTaggingInput {

    static func headerProvider(_ value: GetJobTaggingInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetJobTaggingInput {

    static func urlPathProvider(_ value: GetJobTaggingInput) -> Swift.String? {
        guard let jobId = value.jobId else {
            return nil
        }
        return "/v20180820/jobs/\(jobId.urlPercentEncoding())/tagging"
    }
}

public struct GetJobTaggingInput: Swift.Equatable {
    /// The Amazon Web Services account ID associated with the S3 Batch Operations job.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID for the S3 Batch Operations job whose tags you want to retrieve.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.jobId = jobId
    }
}

extension GetJobTaggingOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetJobTaggingOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetJobTaggingOutput()
            value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: S3ControlClientTypes.S3Tag.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

public struct GetJobTaggingOutput: Swift.Equatable {
    /// The set of tags associated with the S3 Batch Operations job.
    public var tags: [S3ControlClientTypes.S3Tag]?

    public init(
        tags: [S3ControlClientTypes.S3Tag]? = nil
    )
    {
        self.tags = tags
    }
}

enum GetJobTaggingOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "InternalServiceException": return try await InternalServiceException.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NotFoundException": return try await NotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyRequestsException": return try await TooManyRequestsException.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetMultiRegionAccessPointInput {

    static func headerProvider(_ value: GetMultiRegionAccessPointInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetMultiRegionAccessPointInput {

    static func urlPathProvider(_ value: GetMultiRegionAccessPointInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/v20180820/mrap/instances/\(name.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct GetMultiRegionAccessPointInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the owner of the Multi-Region Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the Multi-Region Access Point whose configuration information you want to receive. The name of the Multi-Region Access Point is different from the alias. For more information about the distinction between the name and the alias of an Multi-Region Access Point, see [Managing Multi-Region Access Points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/CreatingMultiRegionAccessPoints.html#multi-region-access-point-naming) in the Amazon S3 User Guide.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

extension GetMultiRegionAccessPointOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetMultiRegionAccessPointOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetMultiRegionAccessPointOutput()
            value.accessPoint = try reader["AccessPoint"].readIfPresent(readingClosure: S3ControlClientTypes.MultiRegionAccessPointReport.readingClosure)
            return value
        }
    }
}

public struct GetMultiRegionAccessPointOutput: Swift.Equatable {
    /// A container element containing the details of the requested Multi-Region Access Point.
    public var accessPoint: S3ControlClientTypes.MultiRegionAccessPointReport?

    public init(
        accessPoint: S3ControlClientTypes.MultiRegionAccessPointReport? = nil
    )
    {
        self.accessPoint = accessPoint
    }
}

enum GetMultiRegionAccessPointOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetMultiRegionAccessPointPolicyInput {

    static func headerProvider(_ value: GetMultiRegionAccessPointPolicyInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetMultiRegionAccessPointPolicyInput {

    static func urlPathProvider(_ value: GetMultiRegionAccessPointPolicyInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/v20180820/mrap/instances/\(name.urlPercentEncoding(encodeForwardSlash: false))/policy"
    }
}

public struct GetMultiRegionAccessPointPolicyInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the owner of the Multi-Region Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// Specifies the Multi-Region Access Point. The name of the Multi-Region Access Point is different from the alias. For more information about the distinction between the name and the alias of an Multi-Region Access Point, see [Managing Multi-Region Access Points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/CreatingMultiRegionAccessPoints.html#multi-region-access-point-naming) in the Amazon S3 User Guide.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

extension GetMultiRegionAccessPointPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetMultiRegionAccessPointPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetMultiRegionAccessPointPolicyOutput()
            value.policy = try reader["Policy"].readIfPresent(readingClosure: S3ControlClientTypes.MultiRegionAccessPointPolicyDocument.readingClosure)
            return value
        }
    }
}

public struct GetMultiRegionAccessPointPolicyOutput: Swift.Equatable {
    /// The policy associated with the specified Multi-Region Access Point.
    public var policy: S3ControlClientTypes.MultiRegionAccessPointPolicyDocument?

    public init(
        policy: S3ControlClientTypes.MultiRegionAccessPointPolicyDocument? = nil
    )
    {
        self.policy = policy
    }
}

enum GetMultiRegionAccessPointPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetMultiRegionAccessPointPolicyStatusInput {

    static func headerProvider(_ value: GetMultiRegionAccessPointPolicyStatusInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetMultiRegionAccessPointPolicyStatusInput {

    static func urlPathProvider(_ value: GetMultiRegionAccessPointPolicyStatusInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/v20180820/mrap/instances/\(name.urlPercentEncoding(encodeForwardSlash: false))/policystatus"
    }
}

public struct GetMultiRegionAccessPointPolicyStatusInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the owner of the Multi-Region Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// Specifies the Multi-Region Access Point. The name of the Multi-Region Access Point is different from the alias. For more information about the distinction between the name and the alias of an Multi-Region Access Point, see [Managing Multi-Region Access Points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/CreatingMultiRegionAccessPoints.html#multi-region-access-point-naming) in the Amazon S3 User Guide.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

extension GetMultiRegionAccessPointPolicyStatusOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetMultiRegionAccessPointPolicyStatusOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetMultiRegionAccessPointPolicyStatusOutput()
            value.established = try reader["Established"].readIfPresent(readingClosure: S3ControlClientTypes.PolicyStatus.readingClosure)
            return value
        }
    }
}

public struct GetMultiRegionAccessPointPolicyStatusOutput: Swift.Equatable {
    /// Indicates whether this access point policy is public. For more information about how Amazon S3 evaluates policies to determine whether they are public, see [The Meaning of "Public"](https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status) in the Amazon S3 User Guide.
    public var established: S3ControlClientTypes.PolicyStatus?

    public init(
        established: S3ControlClientTypes.PolicyStatus? = nil
    )
    {
        self.established = established
    }
}

enum GetMultiRegionAccessPointPolicyStatusOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetMultiRegionAccessPointRoutesInput {

    static func headerProvider(_ value: GetMultiRegionAccessPointRoutesInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetMultiRegionAccessPointRoutesInput {

    static func urlPathProvider(_ value: GetMultiRegionAccessPointRoutesInput) -> Swift.String? {
        guard let mrap = value.mrap else {
            return nil
        }
        return "/v20180820/mrap/instances/\(mrap.urlPercentEncoding(encodeForwardSlash: false))/routes"
    }
}

public struct GetMultiRegionAccessPointRoutesInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the owner of the Multi-Region Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The Multi-Region Access Point ARN.
    /// This member is required.
    public var mrap: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        mrap: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.mrap = mrap
    }
}

extension GetMultiRegionAccessPointRoutesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetMultiRegionAccessPointRoutesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetMultiRegionAccessPointRoutesOutput()
            value.mrap = try reader["Mrap"].readIfPresent()
            value.routes = try reader["Routes"].readListIfPresent(memberReadingClosure: S3ControlClientTypes.MultiRegionAccessPointRoute.readingClosure, memberNodeInfo: "Route", isFlattened: false)
            return value
        }
    }
}

public struct GetMultiRegionAccessPointRoutesOutput: Swift.Equatable {
    /// The Multi-Region Access Point ARN.
    public var mrap: Swift.String?
    /// The different routes that make up the route configuration. Active routes return a value of 100, and passive routes return a value of 0.
    public var routes: [S3ControlClientTypes.MultiRegionAccessPointRoute]?

    public init(
        mrap: Swift.String? = nil,
        routes: [S3ControlClientTypes.MultiRegionAccessPointRoute]? = nil
    )
    {
        self.mrap = mrap
        self.routes = routes
    }
}

enum GetMultiRegionAccessPointRoutesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetPublicAccessBlockInput {

    static func headerProvider(_ value: GetPublicAccessBlockInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetPublicAccessBlockInput {

    static func urlPathProvider(_ value: GetPublicAccessBlockInput) -> Swift.String? {
        return "/v20180820/configuration/publicAccessBlock"
    }
}

public struct GetPublicAccessBlockInput: Swift.Equatable {
    /// The account ID for the Amazon Web Services account whose PublicAccessBlock configuration you want to retrieve.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

extension GetPublicAccessBlockOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetPublicAccessBlockOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetPublicAccessBlockOutput()
            value.publicAccessBlockConfiguration = try reader.readIfPresent(readingClosure: S3ControlClientTypes.PublicAccessBlockConfiguration.readingClosure)
            return value
        }
    }
}

public struct GetPublicAccessBlockOutput: Swift.Equatable {
    /// The PublicAccessBlock configuration currently in effect for this Amazon Web Services account.
    public var publicAccessBlockConfiguration: S3ControlClientTypes.PublicAccessBlockConfiguration?

    public init(
        publicAccessBlockConfiguration: S3ControlClientTypes.PublicAccessBlockConfiguration? = nil
    )
    {
        self.publicAccessBlockConfiguration = publicAccessBlockConfiguration
    }
}

enum GetPublicAccessBlockOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "NoSuchPublicAccessBlockConfiguration": return try await NoSuchPublicAccessBlockConfiguration.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetStorageLensConfigurationInput {

    static func headerProvider(_ value: GetStorageLensConfigurationInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetStorageLensConfigurationInput {

    static func urlPathProvider(_ value: GetStorageLensConfigurationInput) -> Swift.String? {
        guard let configId = value.configId else {
            return nil
        }
        return "/v20180820/storagelens/\(configId.urlPercentEncoding())"
    }
}

public struct GetStorageLensConfigurationInput: Swift.Equatable {
    /// The account ID of the requester.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID of the Amazon S3 Storage Lens configuration.
    /// This member is required.
    public var configId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        configId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.configId = configId
    }
}

extension GetStorageLensConfigurationOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetStorageLensConfigurationOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetStorageLensConfigurationOutput()
            value.storageLensConfiguration = try reader.readIfPresent(readingClosure: S3ControlClientTypes.StorageLensConfiguration.readingClosure)
            return value
        }
    }
}

public struct GetStorageLensConfigurationOutput: Swift.Equatable {
    /// The S3 Storage Lens configuration requested.
    public var storageLensConfiguration: S3ControlClientTypes.StorageLensConfiguration?

    public init(
        storageLensConfiguration: S3ControlClientTypes.StorageLensConfiguration? = nil
    )
    {
        self.storageLensConfiguration = storageLensConfiguration
    }
}

enum GetStorageLensConfigurationOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetStorageLensConfigurationTaggingInput {

    static func headerProvider(_ value: GetStorageLensConfigurationTaggingInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetStorageLensConfigurationTaggingInput {

    static func urlPathProvider(_ value: GetStorageLensConfigurationTaggingInput) -> Swift.String? {
        guard let configId = value.configId else {
            return nil
        }
        return "/v20180820/storagelens/\(configId.urlPercentEncoding())/tagging"
    }
}

public struct GetStorageLensConfigurationTaggingInput: Swift.Equatable {
    /// The account ID of the requester.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID of the Amazon S3 Storage Lens configuration.
    /// This member is required.
    public var configId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        configId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.configId = configId
    }
}

extension GetStorageLensConfigurationTaggingOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetStorageLensConfigurationTaggingOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetStorageLensConfigurationTaggingOutput()
            value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: S3ControlClientTypes.StorageLensTag.readingClosure, memberNodeInfo: "Tag", isFlattened: false)
            return value
        }
    }
}

public struct GetStorageLensConfigurationTaggingOutput: Swift.Equatable {
    /// The tags of S3 Storage Lens configuration requested.
    public var tags: [S3ControlClientTypes.StorageLensTag]?

    public init(
        tags: [S3ControlClientTypes.StorageLensTag]? = nil
    )
    {
        self.tags = tags
    }
}

enum GetStorageLensConfigurationTaggingOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetStorageLensGroupInput {

    static func headerProvider(_ value: GetStorageLensGroupInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetStorageLensGroupInput {

    static func urlPathProvider(_ value: GetStorageLensGroupInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/v20180820/storagelensgroup/\(name.urlPercentEncoding())"
    }
}

public struct GetStorageLensGroupInput: Swift.Equatable {
    /// The Amazon Web Services account ID associated with the Storage Lens group that you're trying to retrieve the details for.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the Storage Lens group that you're trying to retrieve the configuration details for.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

extension GetStorageLensGroupOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetStorageLensGroupOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetStorageLensGroupOutput()
            value.storageLensGroup = try reader.readIfPresent(readingClosure: S3ControlClientTypes.StorageLensGroup.readingClosure)
            return value
        }
    }
}

public struct GetStorageLensGroupOutput: Swift.Equatable {
    /// The name of the Storage Lens group that you're trying to retrieve the configuration details for.
    public var storageLensGroup: S3ControlClientTypes.StorageLensGroup?

    public init(
        storageLensGroup: S3ControlClientTypes.StorageLensGroup? = nil
    )
    {
        self.storageLensGroup = storageLensGroup
    }
}

enum GetStorageLensGroupOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension S3ControlClientTypes.Grantee {

    static func writingClosure(_ value: S3ControlClientTypes.Grantee?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["GranteeIdentifier"].write(value.granteeIdentifier)
        try writer["GranteeType"].write(value.granteeType)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.Grantee, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.Grantee()
            value.granteeType = try reader["GranteeType"].readIfPresent()
            value.granteeIdentifier = try reader["GranteeIdentifier"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// The user, group, or role to which you are granting access. You can grant access to an IAM user or role. If you have added your corporate directory to Amazon Web Services IAM Identity Center and associated your Identity Center instance with your S3 Access Grants instance, the grantee can also be a corporate directory user or group.
    public struct Grantee: Swift.Equatable {
        /// The unique identifier of the Grantee. If the grantee type is IAM, the identifier is the IAM Amazon Resource Name (ARN) of the user or role. If the grantee type is a directory user or group, the identifier is 128-bit universally unique identifier (UUID) in the format a1b2c3d4-5678-90ab-cdef-EXAMPLE11111. You can obtain this UUID from your Amazon Web Services IAM Identity Center instance.
        public var granteeIdentifier: Swift.String?
        /// The type of the grantee to which access has been granted. It can be one of the following values:
        ///
        /// * IAM - An IAM user or role.
        ///
        /// * DIRECTORY_USER - Your corporate directory user. You can use this option if you have added your corporate identity directory to IAM Identity Center and associated the IAM Identity Center instance with your S3 Access Grants instance.
        ///
        /// * DIRECTORY_GROUP - Your corporate directory group. You can use this option if you have added your corporate identity directory to IAM Identity Center and associated the IAM Identity Center instance with your S3 Access Grants instance.
        public var granteeType: S3ControlClientTypes.GranteeType?

        public init(
            granteeIdentifier: Swift.String? = nil,
            granteeType: S3ControlClientTypes.GranteeType? = nil
        )
        {
            self.granteeIdentifier = granteeIdentifier
            self.granteeType = granteeType
        }
    }

}

extension S3ControlClientTypes {
    public enum GranteeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case directoryGroup
        case directoryUser
        case iam
        case sdkUnknown(Swift.String)

        public static var allCases: [GranteeType] {
            return [
                .directoryGroup,
                .directoryUser,
                .iam,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .directoryGroup: return "DIRECTORY_GROUP"
            case .directoryUser: return "DIRECTORY_USER"
            case .iam: return "IAM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GranteeType(rawValue: rawValue) ?? GranteeType.sdkUnknown(rawValue)
        }
    }
}

extension IdempotencyException {

    static var readingClosure: SmithyReadWrite.ReadingClosure<IdempotencyException, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IdempotencyException()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension IdempotencyException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = IdempotencyException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

///
public struct IdempotencyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IdempotencyException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension S3ControlClientTypes.Include {

    static func writingClosure(_ value: S3ControlClientTypes.Include?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Buckets"].writeList(value.buckets, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: "Arn", isFlattened: false)
        try writer["Regions"].writeList(value.regions, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: "Region", isFlattened: false)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.Include, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.Include()
            value.buckets = try reader["Buckets"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "Arn", isFlattened: false)
            value.regions = try reader["Regions"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "Region", isFlattened: false)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// A container for what Amazon S3 Storage Lens configuration includes.
    public struct Include: Swift.Equatable {
        /// A container for the S3 Storage Lens bucket includes.
        public var buckets: [Swift.String]?
        /// A container for the S3 Storage Lens Region includes.
        public var regions: [Swift.String]?

        public init(
            buckets: [Swift.String]? = nil,
            regions: [Swift.String]? = nil
        )
        {
            self.buckets = buckets
            self.regions = regions
        }
    }

}

extension InternalServiceException {

    static var readingClosure: SmithyReadWrite.ReadingClosure<InternalServiceException, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = InternalServiceException()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension InternalServiceException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InternalServiceException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

///
public struct InternalServiceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServiceException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidNextTokenException {

    static var readingClosure: SmithyReadWrite.ReadingClosure<InvalidNextTokenException, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = InvalidNextTokenException()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension InvalidNextTokenException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidNextTokenException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

///
public struct InvalidNextTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNextTokenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidRequestException {

    static var readingClosure: SmithyReadWrite.ReadingClosure<InvalidRequestException, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = InvalidRequestException()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension InvalidRequestException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidRequestException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

///
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension S3ControlClientTypes.JobDescriptor {

    static func writingClosure(_ value: S3ControlClientTypes.JobDescriptor?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ConfirmationRequired"].write(value.confirmationRequired)
        try writer["CreationTime"].writeTimestamp(value.creationTime, format: .dateTime)
        try writer["Description"].write(value.description)
        try writer["FailureReasons"].writeList(value.failureReasons, memberWritingClosure: S3ControlClientTypes.JobFailure.writingClosure(_:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["GeneratedManifestDescriptor"].write(value.generatedManifestDescriptor, writingClosure: S3ControlClientTypes.S3GeneratedManifestDescriptor.writingClosure(_:to:))
        try writer["JobArn"].write(value.jobArn)
        try writer["JobId"].write(value.jobId)
        try writer["Manifest"].write(value.manifest, writingClosure: S3ControlClientTypes.JobManifest.writingClosure(_:to:))
        try writer["ManifestGenerator"].write(value.manifestGenerator, writingClosure: S3ControlClientTypes.JobManifestGenerator.writingClosure(_:to:))
        try writer["Operation"].write(value.operation, writingClosure: S3ControlClientTypes.JobOperation.writingClosure(_:to:))
        try writer["Priority"].write(value.priority)
        try writer["ProgressSummary"].write(value.progressSummary, writingClosure: S3ControlClientTypes.JobProgressSummary.writingClosure(_:to:))
        try writer["Report"].write(value.report, writingClosure: S3ControlClientTypes.JobReport.writingClosure(_:to:))
        try writer["RoleArn"].write(value.roleArn)
        try writer["Status"].write(value.status)
        try writer["StatusUpdateReason"].write(value.statusUpdateReason)
        try writer["SuspendedCause"].write(value.suspendedCause)
        try writer["SuspendedDate"].writeTimestamp(value.suspendedDate, format: .dateTime)
        try writer["TerminationDate"].writeTimestamp(value.terminationDate, format: .dateTime)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.JobDescriptor, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.JobDescriptor()
            value.jobId = try reader["JobId"].readIfPresent()
            value.confirmationRequired = try reader["ConfirmationRequired"].readIfPresent()
            value.description = try reader["Description"].readIfPresent()
            value.jobArn = try reader["JobArn"].readIfPresent()
            value.status = try reader["Status"].readIfPresent()
            value.manifest = try reader["Manifest"].readIfPresent(readingClosure: S3ControlClientTypes.JobManifest.readingClosure)
            value.operation = try reader["Operation"].readIfPresent(readingClosure: S3ControlClientTypes.JobOperation.readingClosure)
            value.priority = try reader["Priority"].readIfPresent() ?? 0
            value.progressSummary = try reader["ProgressSummary"].readIfPresent(readingClosure: S3ControlClientTypes.JobProgressSummary.readingClosure)
            value.statusUpdateReason = try reader["StatusUpdateReason"].readIfPresent()
            value.failureReasons = try reader["FailureReasons"].readListIfPresent(memberReadingClosure: S3ControlClientTypes.JobFailure.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.report = try reader["Report"].readIfPresent(readingClosure: S3ControlClientTypes.JobReport.readingClosure)
            value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: .dateTime)
            value.terminationDate = try reader["TerminationDate"].readTimestampIfPresent(format: .dateTime)
            value.roleArn = try reader["RoleArn"].readIfPresent()
            value.suspendedDate = try reader["SuspendedDate"].readTimestampIfPresent(format: .dateTime)
            value.suspendedCause = try reader["SuspendedCause"].readIfPresent()
            value.manifestGenerator = try reader["ManifestGenerator"].readIfPresent(readingClosure: S3ControlClientTypes.JobManifestGenerator.readingClosure)
            value.generatedManifestDescriptor = try reader["GeneratedManifestDescriptor"].readIfPresent(readingClosure: S3ControlClientTypes.S3GeneratedManifestDescriptor.readingClosure)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// A container element for the job configuration and status information returned by a Describe Job request.
    public struct JobDescriptor: Swift.Equatable {
        /// Indicates whether confirmation is required before Amazon S3 begins running the specified job. Confirmation is required only for jobs created through the Amazon S3 console.
        public var confirmationRequired: Swift.Bool?
        /// A timestamp indicating when this job was created.
        public var creationTime: ClientRuntime.Date?
        /// The description for this job, if one was provided in this job's Create Job request.
        public var description: Swift.String?
        /// If the specified job failed, this field contains information describing the failure.
        public var failureReasons: [S3ControlClientTypes.JobFailure]?
        /// The attribute of the JobDescriptor containing details about the job's generated manifest.
        public var generatedManifestDescriptor: S3ControlClientTypes.S3GeneratedManifestDescriptor?
        /// The Amazon Resource Name (ARN) for this job.
        public var jobArn: Swift.String?
        /// The ID for the specified job.
        public var jobId: Swift.String?
        /// The configuration information for the specified job's manifest object.
        public var manifest: S3ControlClientTypes.JobManifest?
        /// The manifest generator that was used to generate a job manifest for this job.
        public var manifestGenerator: S3ControlClientTypes.JobManifestGenerator?
        /// The operation that the specified job is configured to run on the objects listed in the manifest.
        public var operation: S3ControlClientTypes.JobOperation?
        /// The priority of the specified job.
        public var priority: Swift.Int
        /// Describes the total number of tasks that the specified job has run, the number of tasks that succeeded, and the number of tasks that failed.
        public var progressSummary: S3ControlClientTypes.JobProgressSummary?
        /// Contains the configuration information for the job-completion report if you requested one in the Create Job request.
        public var report: S3ControlClientTypes.JobReport?
        /// The Amazon Resource Name (ARN) for the Identity and Access Management (IAM) role assigned to run the tasks for this job.
        public var roleArn: Swift.String?
        /// The current status of the specified job.
        public var status: S3ControlClientTypes.JobStatus?
        /// The reason for updating the job.
        public var statusUpdateReason: Swift.String?
        /// The reason why the specified job was suspended. A job is only suspended if you create it through the Amazon S3 console. When you create the job, it enters the Suspended state to await confirmation before running. After you confirm the job, it automatically exits the Suspended state.
        public var suspendedCause: Swift.String?
        /// The timestamp when this job was suspended, if it has been suspended.
        public var suspendedDate: ClientRuntime.Date?
        /// A timestamp indicating when this job terminated. A job's termination date is the date and time when it succeeded, failed, or was canceled.
        public var terminationDate: ClientRuntime.Date?

        public init(
            confirmationRequired: Swift.Bool? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            failureReasons: [S3ControlClientTypes.JobFailure]? = nil,
            generatedManifestDescriptor: S3ControlClientTypes.S3GeneratedManifestDescriptor? = nil,
            jobArn: Swift.String? = nil,
            jobId: Swift.String? = nil,
            manifest: S3ControlClientTypes.JobManifest? = nil,
            manifestGenerator: S3ControlClientTypes.JobManifestGenerator? = nil,
            operation: S3ControlClientTypes.JobOperation? = nil,
            priority: Swift.Int = 0,
            progressSummary: S3ControlClientTypes.JobProgressSummary? = nil,
            report: S3ControlClientTypes.JobReport? = nil,
            roleArn: Swift.String? = nil,
            status: S3ControlClientTypes.JobStatus? = nil,
            statusUpdateReason: Swift.String? = nil,
            suspendedCause: Swift.String? = nil,
            suspendedDate: ClientRuntime.Date? = nil,
            terminationDate: ClientRuntime.Date? = nil
        )
        {
            self.confirmationRequired = confirmationRequired
            self.creationTime = creationTime
            self.description = description
            self.failureReasons = failureReasons
            self.generatedManifestDescriptor = generatedManifestDescriptor
            self.jobArn = jobArn
            self.jobId = jobId
            self.manifest = manifest
            self.manifestGenerator = manifestGenerator
            self.operation = operation
            self.priority = priority
            self.progressSummary = progressSummary
            self.report = report
            self.roleArn = roleArn
            self.status = status
            self.statusUpdateReason = statusUpdateReason
            self.suspendedCause = suspendedCause
            self.suspendedDate = suspendedDate
            self.terminationDate = terminationDate
        }
    }

}

extension S3ControlClientTypes.JobFailure {

    static func writingClosure(_ value: S3ControlClientTypes.JobFailure?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["FailureCode"].write(value.failureCode)
        try writer["FailureReason"].write(value.failureReason)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.JobFailure, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.JobFailure()
            value.failureCode = try reader["FailureCode"].readIfPresent()
            value.failureReason = try reader["FailureReason"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// If this job failed, this element indicates why the job failed.
    public struct JobFailure: Swift.Equatable {
        /// The failure code, if any, for the specified job.
        public var failureCode: Swift.String?
        /// The failure reason, if any, for the specified job.
        public var failureReason: Swift.String?

        public init(
            failureCode: Swift.String? = nil,
            failureReason: Swift.String? = nil
        )
        {
            self.failureCode = failureCode
            self.failureReason = failureReason
        }
    }

}

extension S3ControlClientTypes.JobListDescriptor {

    static func writingClosure(_ value: S3ControlClientTypes.JobListDescriptor?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["CreationTime"].writeTimestamp(value.creationTime, format: .dateTime)
        try writer["Description"].write(value.description)
        try writer["JobId"].write(value.jobId)
        try writer["Operation"].write(value.operation)
        try writer["Priority"].write(value.priority)
        try writer["ProgressSummary"].write(value.progressSummary, writingClosure: S3ControlClientTypes.JobProgressSummary.writingClosure(_:to:))
        try writer["Status"].write(value.status)
        try writer["TerminationDate"].writeTimestamp(value.terminationDate, format: .dateTime)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.JobListDescriptor, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.JobListDescriptor()
            value.jobId = try reader["JobId"].readIfPresent()
            value.description = try reader["Description"].readIfPresent()
            value.operation = try reader["Operation"].readIfPresent()
            value.priority = try reader["Priority"].readIfPresent() ?? 0
            value.status = try reader["Status"].readIfPresent()
            value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: .dateTime)
            value.terminationDate = try reader["TerminationDate"].readTimestampIfPresent(format: .dateTime)
            value.progressSummary = try reader["ProgressSummary"].readIfPresent(readingClosure: S3ControlClientTypes.JobProgressSummary.readingClosure)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// Contains the configuration and status information for a single job retrieved as part of a job list.
    public struct JobListDescriptor: Swift.Equatable {
        /// A timestamp indicating when the specified job was created.
        public var creationTime: ClientRuntime.Date?
        /// The user-specified description that was included in the specified job's Create Job request.
        public var description: Swift.String?
        /// The ID for the specified job.
        public var jobId: Swift.String?
        /// The operation that the specified job is configured to run on every object listed in the manifest.
        public var operation: S3ControlClientTypes.OperationName?
        /// The current priority for the specified job.
        public var priority: Swift.Int
        /// Describes the total number of tasks that the specified job has run, the number of tasks that succeeded, and the number of tasks that failed.
        public var progressSummary: S3ControlClientTypes.JobProgressSummary?
        /// The specified job's current status.
        public var status: S3ControlClientTypes.JobStatus?
        /// A timestamp indicating when the specified job terminated. A job's termination date is the date and time when it succeeded, failed, or was canceled.
        public var terminationDate: ClientRuntime.Date?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            jobId: Swift.String? = nil,
            operation: S3ControlClientTypes.OperationName? = nil,
            priority: Swift.Int = 0,
            progressSummary: S3ControlClientTypes.JobProgressSummary? = nil,
            status: S3ControlClientTypes.JobStatus? = nil,
            terminationDate: ClientRuntime.Date? = nil
        )
        {
            self.creationTime = creationTime
            self.description = description
            self.jobId = jobId
            self.operation = operation
            self.priority = priority
            self.progressSummary = progressSummary
            self.status = status
            self.terminationDate = terminationDate
        }
    }

}

extension S3ControlClientTypes.JobManifest {

    static func writingClosure(_ value: S3ControlClientTypes.JobManifest?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Location"].write(value.location, writingClosure: S3ControlClientTypes.JobManifestLocation.writingClosure(_:to:))
        try writer["Spec"].write(value.spec, writingClosure: S3ControlClientTypes.JobManifestSpec.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.JobManifest, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.JobManifest()
            value.spec = try reader["Spec"].readIfPresent(readingClosure: S3ControlClientTypes.JobManifestSpec.readingClosure)
            value.location = try reader["Location"].readIfPresent(readingClosure: S3ControlClientTypes.JobManifestLocation.readingClosure)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// Contains the configuration information for a job's manifest.
    public struct JobManifest: Swift.Equatable {
        /// Contains the information required to locate the specified job's manifest. Manifests can't be imported from directory buckets. For more information, see [Directory buckets](https://docs.aws.amazon.com/AmazonS3/latest/userguide/directory-buckets-overview.html).
        /// This member is required.
        public var location: S3ControlClientTypes.JobManifestLocation?
        /// Describes the format of the specified job's manifest. If the manifest is in CSV format, also describes the columns contained within the manifest.
        /// This member is required.
        public var spec: S3ControlClientTypes.JobManifestSpec?

        public init(
            location: S3ControlClientTypes.JobManifestLocation? = nil,
            spec: S3ControlClientTypes.JobManifestSpec? = nil
        )
        {
            self.location = location
            self.spec = spec
        }
    }

}

extension S3ControlClientTypes {
    public enum JobManifestFieldName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bucket
        case ignore
        case key
        case versionid
        case sdkUnknown(Swift.String)

        public static var allCases: [JobManifestFieldName] {
            return [
                .bucket,
                .ignore,
                .key,
                .versionid,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bucket: return "Bucket"
            case .ignore: return "Ignore"
            case .key: return "Key"
            case .versionid: return "VersionId"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobManifestFieldName(rawValue: rawValue) ?? JobManifestFieldName.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum JobManifestFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case s3batchoperationsCsv20180820
        case s3inventoryreportCsv20161130
        case sdkUnknown(Swift.String)

        public static var allCases: [JobManifestFormat] {
            return [
                .s3batchoperationsCsv20180820,
                .s3inventoryreportCsv20161130,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .s3batchoperationsCsv20180820: return "S3BatchOperations_CSV_20180820"
            case .s3inventoryreportCsv20161130: return "S3InventoryReport_CSV_20161130"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobManifestFormat(rawValue: rawValue) ?? JobManifestFormat.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.JobManifestGenerator {

    static func writingClosure(_ value: S3ControlClientTypes.JobManifestGenerator?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        switch value {
            case let .s3jobmanifestgenerator(s3jobmanifestgenerator):
                try writer["S3JobManifestGenerator"].write(s3jobmanifestgenerator, writingClosure: S3ControlClientTypes.S3JobManifestGenerator.writingClosure(_:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer[.init("sdkUnknown")].write(sdkUnknown)
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.JobManifestGenerator, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            let name = reader.children.first?.nodeInfo.name
            switch name {
                case "S3JobManifestGenerator":
                    return .s3jobmanifestgenerator(try reader["S3JobManifestGenerator"].read(readingClosure: S3ControlClientTypes.S3JobManifestGenerator.readingClosure))
                default:
                    return .sdkUnknown(name ?? "")
            }
        }
    }
}

extension S3ControlClientTypes {
    /// Configures the type of the job's ManifestGenerator.
    public enum JobManifestGenerator: Swift.Equatable {
        /// The S3 job ManifestGenerator's configuration details.
        case s3jobmanifestgenerator(S3ControlClientTypes.S3JobManifestGenerator)
        case sdkUnknown(Swift.String)
    }

}

extension S3ControlClientTypes.JobManifestGeneratorFilter {

    static func writingClosure(_ value: S3ControlClientTypes.JobManifestGeneratorFilter?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["CreatedAfter"].writeTimestamp(value.createdAfter, format: .dateTime)
        try writer["CreatedBefore"].writeTimestamp(value.createdBefore, format: .dateTime)
        try writer["EligibleForReplication"].write(value.eligibleForReplication)
        try writer["KeyNameConstraint"].write(value.keyNameConstraint, writingClosure: S3ControlClientTypes.KeyNameConstraint.writingClosure(_:to:))
        try writer["MatchAnyStorageClass"].writeList(value.matchAnyStorageClass, memberWritingClosure: S3ControlClientTypes.S3StorageClass.writingClosure(_:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ObjectReplicationStatuses"].writeList(value.objectReplicationStatuses, memberWritingClosure: S3ControlClientTypes.ReplicationStatus.writingClosure(_:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ObjectSizeGreaterThanBytes"].write(value.objectSizeGreaterThanBytes)
        try writer["ObjectSizeLessThanBytes"].write(value.objectSizeLessThanBytes)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.JobManifestGeneratorFilter, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.JobManifestGeneratorFilter()
            value.eligibleForReplication = try reader["EligibleForReplication"].readIfPresent()
            value.createdAfter = try reader["CreatedAfter"].readTimestampIfPresent(format: .dateTime)
            value.createdBefore = try reader["CreatedBefore"].readTimestampIfPresent(format: .dateTime)
            value.objectReplicationStatuses = try reader["ObjectReplicationStatuses"].readListIfPresent(memberReadingClosure: S3ControlClientTypes.ReplicationStatus.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.keyNameConstraint = try reader["KeyNameConstraint"].readIfPresent(readingClosure: S3ControlClientTypes.KeyNameConstraint.readingClosure)
            value.objectSizeGreaterThanBytes = try reader["ObjectSizeGreaterThanBytes"].readIfPresent()
            value.objectSizeLessThanBytes = try reader["ObjectSizeLessThanBytes"].readIfPresent()
            value.matchAnyStorageClass = try reader["MatchAnyStorageClass"].readListIfPresent(memberReadingClosure: S3ControlClientTypes.S3StorageClass.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// The filter used to describe a set of objects for the job's manifest.
    public struct JobManifestGeneratorFilter: Swift.Equatable {
        /// If provided, the generated manifest includes only source bucket objects that were created after this time.
        public var createdAfter: ClientRuntime.Date?
        /// If provided, the generated manifest includes only source bucket objects that were created before this time.
        public var createdBefore: ClientRuntime.Date?
        /// Include objects in the generated manifest only if they are eligible for replication according to the Replication configuration on the source bucket.
        public var eligibleForReplication: Swift.Bool?
        /// If provided, the generated manifest includes only source bucket objects whose object keys match the string constraints specified for MatchAnyPrefix, MatchAnySuffix, and MatchAnySubstring.
        public var keyNameConstraint: S3ControlClientTypes.KeyNameConstraint?
        /// If provided, the generated manifest includes only source bucket objects that are stored with the specified storage class.
        public var matchAnyStorageClass: [S3ControlClientTypes.S3StorageClass]?
        /// If provided, the generated manifest includes only source bucket objects that have one of the specified Replication statuses.
        public var objectReplicationStatuses: [S3ControlClientTypes.ReplicationStatus]?
        /// If provided, the generated manifest includes only source bucket objects whose file size is greater than the specified number of bytes.
        public var objectSizeGreaterThanBytes: Swift.Int?
        /// If provided, the generated manifest includes only source bucket objects whose file size is less than the specified number of bytes.
        public var objectSizeLessThanBytes: Swift.Int?

        public init(
            createdAfter: ClientRuntime.Date? = nil,
            createdBefore: ClientRuntime.Date? = nil,
            eligibleForReplication: Swift.Bool? = nil,
            keyNameConstraint: S3ControlClientTypes.KeyNameConstraint? = nil,
            matchAnyStorageClass: [S3ControlClientTypes.S3StorageClass]? = nil,
            objectReplicationStatuses: [S3ControlClientTypes.ReplicationStatus]? = nil,
            objectSizeGreaterThanBytes: Swift.Int? = nil,
            objectSizeLessThanBytes: Swift.Int? = nil
        )
        {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.eligibleForReplication = eligibleForReplication
            self.keyNameConstraint = keyNameConstraint
            self.matchAnyStorageClass = matchAnyStorageClass
            self.objectReplicationStatuses = objectReplicationStatuses
            self.objectSizeGreaterThanBytes = objectSizeGreaterThanBytes
            self.objectSizeLessThanBytes = objectSizeLessThanBytes
        }
    }

}

extension S3ControlClientTypes.JobManifestLocation {

    static func writingClosure(_ value: S3ControlClientTypes.JobManifestLocation?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ETag"].write(value.eTag)
        try writer["ObjectArn"].write(value.objectArn)
        try writer["ObjectVersionId"].write(value.objectVersionId)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.JobManifestLocation, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.JobManifestLocation()
            value.objectArn = try reader["ObjectArn"].readIfPresent()
            value.objectVersionId = try reader["ObjectVersionId"].readIfPresent()
            value.eTag = try reader["ETag"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// Contains the information required to locate a manifest object. Manifests can't be imported from directory buckets. For more information, see [Directory buckets](https://docs.aws.amazon.com/AmazonS3/latest/userguide/directory-buckets-overview.html).
    public struct JobManifestLocation: Swift.Equatable {
        /// The ETag for the specified manifest object.
        /// This member is required.
        public var eTag: Swift.String?
        /// The Amazon Resource Name (ARN) for a manifest object. When you're using XML requests, you must replace special characters (such as carriage returns) in object keys with their equivalent XML entity codes. For more information, see [ XML-related object key constraints](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints) in the Amazon S3 User Guide.
        /// This member is required.
        public var objectArn: Swift.String?
        /// The optional version ID to identify a specific version of the manifest object.
        public var objectVersionId: Swift.String?

        public init(
            eTag: Swift.String? = nil,
            objectArn: Swift.String? = nil,
            objectVersionId: Swift.String? = nil
        )
        {
            self.eTag = eTag
            self.objectArn = objectArn
            self.objectVersionId = objectVersionId
        }
    }

}

extension S3ControlClientTypes.JobManifestSpec {

    static func writingClosure(_ value: S3ControlClientTypes.JobManifestSpec?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Fields"].writeList(value.fields, memberWritingClosure: S3ControlClientTypes.JobManifestFieldName.writingClosure(_:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Format"].write(value.format)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.JobManifestSpec, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.JobManifestSpec()
            value.format = try reader["Format"].readIfPresent()
            value.fields = try reader["Fields"].readListIfPresent(memberReadingClosure: S3ControlClientTypes.JobManifestFieldName.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// Describes the format of a manifest. If the manifest is in CSV format, also describes the columns contained within the manifest.
    public struct JobManifestSpec: Swift.Equatable {
        /// If the specified manifest object is in the S3BatchOperations_CSV_20180820 format, this element describes which columns contain the required data.
        public var fields: [S3ControlClientTypes.JobManifestFieldName]?
        /// Indicates which of the available formats the specified manifest uses.
        /// This member is required.
        public var format: S3ControlClientTypes.JobManifestFormat?

        public init(
            fields: [S3ControlClientTypes.JobManifestFieldName]? = nil,
            format: S3ControlClientTypes.JobManifestFormat? = nil
        )
        {
            self.fields = fields
            self.format = format
        }
    }

}

extension S3ControlClientTypes.JobOperation {

    static func writingClosure(_ value: S3ControlClientTypes.JobOperation?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["LambdaInvoke"].write(value.lambdaInvoke, writingClosure: S3ControlClientTypes.LambdaInvokeOperation.writingClosure(_:to:))
        try writer["S3DeleteObjectTagging"].write(value.s3DeleteObjectTagging, writingClosure: S3ControlClientTypes.S3DeleteObjectTaggingOperation.writingClosure(_:to:))
        try writer["S3InitiateRestoreObject"].write(value.s3InitiateRestoreObject, writingClosure: S3ControlClientTypes.S3InitiateRestoreObjectOperation.writingClosure(_:to:))
        try writer["S3PutObjectAcl"].write(value.s3PutObjectAcl, writingClosure: S3ControlClientTypes.S3SetObjectAclOperation.writingClosure(_:to:))
        try writer["S3PutObjectCopy"].write(value.s3PutObjectCopy, writingClosure: S3ControlClientTypes.S3CopyObjectOperation.writingClosure(_:to:))
        try writer["S3PutObjectLegalHold"].write(value.s3PutObjectLegalHold, writingClosure: S3ControlClientTypes.S3SetObjectLegalHoldOperation.writingClosure(_:to:))
        try writer["S3PutObjectRetention"].write(value.s3PutObjectRetention, writingClosure: S3ControlClientTypes.S3SetObjectRetentionOperation.writingClosure(_:to:))
        try writer["S3PutObjectTagging"].write(value.s3PutObjectTagging, writingClosure: S3ControlClientTypes.S3SetObjectTaggingOperation.writingClosure(_:to:))
        try writer["S3ReplicateObject"].write(value.s3ReplicateObject, writingClosure: S3ControlClientTypes.S3ReplicateObjectOperation.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.JobOperation, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.JobOperation()
            value.lambdaInvoke = try reader["LambdaInvoke"].readIfPresent(readingClosure: S3ControlClientTypes.LambdaInvokeOperation.readingClosure)
            value.s3PutObjectCopy = try reader["S3PutObjectCopy"].readIfPresent(readingClosure: S3ControlClientTypes.S3CopyObjectOperation.readingClosure)
            value.s3PutObjectAcl = try reader["S3PutObjectAcl"].readIfPresent(readingClosure: S3ControlClientTypes.S3SetObjectAclOperation.readingClosure)
            value.s3PutObjectTagging = try reader["S3PutObjectTagging"].readIfPresent(readingClosure: S3ControlClientTypes.S3SetObjectTaggingOperation.readingClosure)
            value.s3DeleteObjectTagging = try reader["S3DeleteObjectTagging"].readIfPresent(readingClosure: S3ControlClientTypes.S3DeleteObjectTaggingOperation.readingClosure)
            value.s3InitiateRestoreObject = try reader["S3InitiateRestoreObject"].readIfPresent(readingClosure: S3ControlClientTypes.S3InitiateRestoreObjectOperation.readingClosure)
            value.s3PutObjectLegalHold = try reader["S3PutObjectLegalHold"].readIfPresent(readingClosure: S3ControlClientTypes.S3SetObjectLegalHoldOperation.readingClosure)
            value.s3PutObjectRetention = try reader["S3PutObjectRetention"].readIfPresent(readingClosure: S3ControlClientTypes.S3SetObjectRetentionOperation.readingClosure)
            value.s3ReplicateObject = try reader["S3ReplicateObject"].readIfPresent(readingClosure: S3ControlClientTypes.S3ReplicateObjectOperation.readingClosure)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// The operation that you want this job to perform on every object listed in the manifest. For more information about the available operations, see [Operations](https://docs.aws.amazon.com/AmazonS3/latest/dev/batch-ops-operations.html) in the Amazon S3 User Guide.
    public struct JobOperation: Swift.Equatable {
        /// Directs the specified job to invoke an Lambda function on every object in the manifest.
        public var lambdaInvoke: S3ControlClientTypes.LambdaInvokeOperation?
        /// Directs the specified job to execute a DELETE Object tagging call on every object in the manifest. This functionality is not supported by directory buckets.
        public var s3DeleteObjectTagging: S3ControlClientTypes.S3DeleteObjectTaggingOperation?
        /// Directs the specified job to initiate restore requests for every archived object in the manifest. This functionality is not supported by directory buckets.
        public var s3InitiateRestoreObject: S3ControlClientTypes.S3InitiateRestoreObjectOperation?
        /// Directs the specified job to run a PutObjectAcl call on every object in the manifest. This functionality is not supported by directory buckets.
        public var s3PutObjectAcl: S3ControlClientTypes.S3SetObjectAclOperation?
        /// Directs the specified job to run a PUT Copy object call on every object in the manifest.
        public var s3PutObjectCopy: S3ControlClientTypes.S3CopyObjectOperation?
        /// Contains the configuration for an S3 Object Lock legal hold operation that an S3 Batch Operations job passes to every object to the underlying PutObjectLegalHold API operation. For more information, see [Using S3 Object Lock legal hold with S3 Batch Operations](https://docs.aws.amazon.com/AmazonS3/latest/dev/batch-ops-legal-hold.html) in the Amazon S3 User Guide. This functionality is not supported by directory buckets.
        public var s3PutObjectLegalHold: S3ControlClientTypes.S3SetObjectLegalHoldOperation?
        /// Contains the configuration parameters for the Object Lock retention action for an S3 Batch Operations job. Batch Operations passes every object to the underlying PutObjectRetention API operation. For more information, see [Using S3 Object Lock retention with S3 Batch Operations](https://docs.aws.amazon.com/AmazonS3/latest/dev/batch-ops-retention-date.html) in the Amazon S3 User Guide. This functionality is not supported by directory buckets.
        public var s3PutObjectRetention: S3ControlClientTypes.S3SetObjectRetentionOperation?
        /// Directs the specified job to run a PUT Object tagging call on every object in the manifest. This functionality is not supported by directory buckets.
        public var s3PutObjectTagging: S3ControlClientTypes.S3SetObjectTaggingOperation?
        /// Directs the specified job to invoke ReplicateObject on every object in the job's manifest. This functionality is not supported by directory buckets.
        public var s3ReplicateObject: S3ControlClientTypes.S3ReplicateObjectOperation?

        public init(
            lambdaInvoke: S3ControlClientTypes.LambdaInvokeOperation? = nil,
            s3DeleteObjectTagging: S3ControlClientTypes.S3DeleteObjectTaggingOperation? = nil,
            s3InitiateRestoreObject: S3ControlClientTypes.S3InitiateRestoreObjectOperation? = nil,
            s3PutObjectAcl: S3ControlClientTypes.S3SetObjectAclOperation? = nil,
            s3PutObjectCopy: S3ControlClientTypes.S3CopyObjectOperation? = nil,
            s3PutObjectLegalHold: S3ControlClientTypes.S3SetObjectLegalHoldOperation? = nil,
            s3PutObjectRetention: S3ControlClientTypes.S3SetObjectRetentionOperation? = nil,
            s3PutObjectTagging: S3ControlClientTypes.S3SetObjectTaggingOperation? = nil,
            s3ReplicateObject: S3ControlClientTypes.S3ReplicateObjectOperation? = nil
        )
        {
            self.lambdaInvoke = lambdaInvoke
            self.s3DeleteObjectTagging = s3DeleteObjectTagging
            self.s3InitiateRestoreObject = s3InitiateRestoreObject
            self.s3PutObjectAcl = s3PutObjectAcl
            self.s3PutObjectCopy = s3PutObjectCopy
            self.s3PutObjectLegalHold = s3PutObjectLegalHold
            self.s3PutObjectRetention = s3PutObjectRetention
            self.s3PutObjectTagging = s3PutObjectTagging
            self.s3ReplicateObject = s3ReplicateObject
        }
    }

}

extension S3ControlClientTypes.JobProgressSummary {

    static func writingClosure(_ value: S3ControlClientTypes.JobProgressSummary?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["NumberOfTasksFailed"].write(value.numberOfTasksFailed)
        try writer["NumberOfTasksSucceeded"].write(value.numberOfTasksSucceeded)
        try writer["Timers"].write(value.timers, writingClosure: S3ControlClientTypes.JobTimers.writingClosure(_:to:))
        try writer["TotalNumberOfTasks"].write(value.totalNumberOfTasks)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.JobProgressSummary, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.JobProgressSummary()
            value.totalNumberOfTasks = try reader["TotalNumberOfTasks"].readIfPresent()
            value.numberOfTasksSucceeded = try reader["NumberOfTasksSucceeded"].readIfPresent()
            value.numberOfTasksFailed = try reader["NumberOfTasksFailed"].readIfPresent()
            value.timers = try reader["Timers"].readIfPresent(readingClosure: S3ControlClientTypes.JobTimers.readingClosure)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// Describes the total number of tasks that the specified job has started, the number of tasks that succeeded, and the number of tasks that failed.
    public struct JobProgressSummary: Swift.Equatable {
        ///
        public var numberOfTasksFailed: Swift.Int?
        ///
        public var numberOfTasksSucceeded: Swift.Int?
        /// The JobTimers attribute of a job's progress summary.
        public var timers: S3ControlClientTypes.JobTimers?
        ///
        public var totalNumberOfTasks: Swift.Int?

        public init(
            numberOfTasksFailed: Swift.Int? = nil,
            numberOfTasksSucceeded: Swift.Int? = nil,
            timers: S3ControlClientTypes.JobTimers? = nil,
            totalNumberOfTasks: Swift.Int? = nil
        )
        {
            self.numberOfTasksFailed = numberOfTasksFailed
            self.numberOfTasksSucceeded = numberOfTasksSucceeded
            self.timers = timers
            self.totalNumberOfTasks = totalNumberOfTasks
        }
    }

}

extension S3ControlClientTypes.JobReport {

    static func writingClosure(_ value: S3ControlClientTypes.JobReport?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Bucket"].write(value.bucket)
        try writer["Enabled"].write(value.enabled)
        try writer["Format"].write(value.format)
        try writer["Prefix"].write(value.`prefix`)
        try writer["ReportScope"].write(value.reportScope)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.JobReport, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.JobReport()
            value.bucket = try reader["Bucket"].readIfPresent()
            value.format = try reader["Format"].readIfPresent()
            value.enabled = try reader["Enabled"].readIfPresent() ?? false
            value.`prefix` = try reader["Prefix"].readIfPresent()
            value.reportScope = try reader["ReportScope"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// Contains the configuration parameters for a job-completion report.
    public struct JobReport: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the bucket where specified job-completion report will be stored. Directory buckets - Directory buckets aren't supported as a location for Batch Operations to store job completion reports.
        public var bucket: Swift.String?
        /// Indicates whether the specified job will generate a job-completion report.
        /// This member is required.
        public var enabled: Swift.Bool
        /// The format of the specified job-completion report.
        public var format: S3ControlClientTypes.JobReportFormat?
        /// An optional prefix to describe where in the specified bucket the job-completion report will be stored. Amazon S3 stores the job-completion report at /job-/report.json.
        public var `prefix`: Swift.String?
        /// Indicates whether the job-completion report will include details of all tasks or only failed tasks.
        public var reportScope: S3ControlClientTypes.JobReportScope?

        public init(
            bucket: Swift.String? = nil,
            enabled: Swift.Bool = false,
            format: S3ControlClientTypes.JobReportFormat? = nil,
            `prefix`: Swift.String? = nil,
            reportScope: S3ControlClientTypes.JobReportScope? = nil
        )
        {
            self.bucket = bucket
            self.enabled = enabled
            self.format = format
            self.`prefix` = `prefix`
            self.reportScope = reportScope
        }
    }

}

extension S3ControlClientTypes {
    public enum JobReportFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case reportCsv20180820
        case sdkUnknown(Swift.String)

        public static var allCases: [JobReportFormat] {
            return [
                .reportCsv20180820,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .reportCsv20180820: return "Report_CSV_20180820"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobReportFormat(rawValue: rawValue) ?? JobReportFormat.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum JobReportScope: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case alltasks
        case failedtasksonly
        case sdkUnknown(Swift.String)

        public static var allCases: [JobReportScope] {
            return [
                .alltasks,
                .failedtasksonly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .alltasks: return "AllTasks"
            case .failedtasksonly: return "FailedTasksOnly"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobReportScope(rawValue: rawValue) ?? JobReportScope.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum JobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case cancelled
        case cancelling
        case complete
        case completing
        case failed
        case failing
        case new
        case paused
        case pausing
        case preparing
        case ready
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .active,
                .cancelled,
                .cancelling,
                .complete,
                .completing,
                .failed,
                .failing,
                .new,
                .paused,
                .pausing,
                .preparing,
                .ready,
                .suspended,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .cancelled: return "Cancelled"
            case .cancelling: return "Cancelling"
            case .complete: return "Complete"
            case .completing: return "Completing"
            case .failed: return "Failed"
            case .failing: return "Failing"
            case .new: return "New"
            case .paused: return "Paused"
            case .pausing: return "Pausing"
            case .preparing: return "Preparing"
            case .ready: return "Ready"
            case .suspended: return "Suspended"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
        }
    }
}

extension JobStatusException {

    static var readingClosure: SmithyReadWrite.ReadingClosure<JobStatusException, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = JobStatusException()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension JobStatusException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = JobStatusException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

///
public struct JobStatusException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "JobStatusException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension S3ControlClientTypes.JobTimers {

    static func writingClosure(_ value: S3ControlClientTypes.JobTimers?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ElapsedTimeInActiveSeconds"].write(value.elapsedTimeInActiveSeconds)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.JobTimers, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.JobTimers()
            value.elapsedTimeInActiveSeconds = try reader["ElapsedTimeInActiveSeconds"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// Provides timing details for the job.
    public struct JobTimers: Swift.Equatable {
        /// Indicates the elapsed time in seconds the job has been in the Active job state.
        public var elapsedTimeInActiveSeconds: Swift.Int?

        public init(
            elapsedTimeInActiveSeconds: Swift.Int? = nil
        )
        {
            self.elapsedTimeInActiveSeconds = elapsedTimeInActiveSeconds
        }
    }

}

extension S3ControlClientTypes.KeyNameConstraint {

    static func writingClosure(_ value: S3ControlClientTypes.KeyNameConstraint?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["MatchAnyPrefix"].writeList(value.matchAnyPrefix, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MatchAnySubstring"].writeList(value.matchAnySubstring, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MatchAnySuffix"].writeList(value.matchAnySuffix, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.KeyNameConstraint, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.KeyNameConstraint()
            value.matchAnyPrefix = try reader["MatchAnyPrefix"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.matchAnySuffix = try reader["MatchAnySuffix"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.matchAnySubstring = try reader["MatchAnySubstring"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// If provided, the generated manifest includes only source bucket objects whose object keys match the string constraints specified for MatchAnyPrefix, MatchAnySuffix, and MatchAnySubstring.
    public struct KeyNameConstraint: Swift.Equatable {
        /// If provided, the generated manifest includes objects where the specified string appears at the start of the object key string.
        public var matchAnyPrefix: [Swift.String]?
        /// If provided, the generated manifest includes objects where the specified string appears anywhere within the object key string.
        public var matchAnySubstring: [Swift.String]?
        /// If provided, the generated manifest includes objects where the specified string appears at the end of the object key string.
        public var matchAnySuffix: [Swift.String]?

        public init(
            matchAnyPrefix: [Swift.String]? = nil,
            matchAnySubstring: [Swift.String]? = nil,
            matchAnySuffix: [Swift.String]? = nil
        )
        {
            self.matchAnyPrefix = matchAnyPrefix
            self.matchAnySubstring = matchAnySubstring
            self.matchAnySuffix = matchAnySuffix
        }
    }

}

extension S3ControlClientTypes.LambdaInvokeOperation {

    static func writingClosure(_ value: S3ControlClientTypes.LambdaInvokeOperation?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["FunctionArn"].write(value.functionArn)
        try writer["InvocationSchemaVersion"].write(value.invocationSchemaVersion)
        try writer["UserArguments"].writeMap(value.userArguments, valueWritingClosure: Swift.String.writingClosure(_:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.LambdaInvokeOperation, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.LambdaInvokeOperation()
            value.functionArn = try reader["FunctionArn"].readIfPresent()
            value.invocationSchemaVersion = try reader["InvocationSchemaVersion"].readIfPresent()
            value.userArguments = try reader["UserArguments"].readMapIfPresent(valueReadingClosure: Swift.String.readingClosure, keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// Contains the configuration parameters for a Lambda Invoke operation.
    public struct LambdaInvokeOperation: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the Lambda function that the specified job will invoke on every object in the manifest.
        public var functionArn: Swift.String?
        /// Specifies the schema version for the payload that Batch Operations sends when invoking an Lambda function. Version 1.0 is the default. Version 2.0 is required when you use Batch Operations to invoke Lambda functions that act on directory buckets, or if you need to specify UserArguments. For more information, see [Using Lambda with Amazon S3 Batch Operations and Amazon S3 Express One Zone](https://aws.amazon.com/blogs/storage/using-lambda-with-s3-batch-operations-and-s3-express-one-zone/) in the Amazon Web Services Storage Blog. Ensure that your Lambda function code expects InvocationSchemaVersion 2.0 and uses bucket name rather than bucket ARN. If the InvocationSchemaVersion does not match what your Lambda function expects, your function might not work as expected. Directory buckets - To initiate Amazon Web Services Lambda function to perform custom actions on objects in directory buckets, you must specify 2.0.
        public var invocationSchemaVersion: Swift.String?
        /// Key-value pairs that are passed in the payload that Batch Operations sends when invoking an Lambda function. You must specify InvocationSchemaVersion 2.0 for LambdaInvoke operations that include UserArguments. For more information, see [Using Lambda with Amazon S3 Batch Operations and Amazon S3 Express One Zone](https://aws.amazon.com/blogs/storage/using-lambda-with-s3-batch-operations-and-s3-express-one-zone/) in the Amazon Web Services Storage Blog.
        public var userArguments: [Swift.String:Swift.String]?

        public init(
            functionArn: Swift.String? = nil,
            invocationSchemaVersion: Swift.String? = nil,
            userArguments: [Swift.String:Swift.String]? = nil
        )
        {
            self.functionArn = functionArn
            self.invocationSchemaVersion = invocationSchemaVersion
            self.userArguments = userArguments
        }
    }

}

extension S3ControlClientTypes.LifecycleConfiguration {

    static func writingClosure(_ value: S3ControlClientTypes.LifecycleConfiguration?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Rules"].writeList(value.rules, memberWritingClosure: S3ControlClientTypes.LifecycleRule.writingClosure(_:to:), memberNodeInfo: "Rule", isFlattened: false)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.LifecycleConfiguration, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.LifecycleConfiguration()
            value.rules = try reader["Rules"].readListIfPresent(memberReadingClosure: S3ControlClientTypes.LifecycleRule.readingClosure, memberNodeInfo: "Rule", isFlattened: false)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// The container for the Outposts bucket lifecycle configuration.
    public struct LifecycleConfiguration: Swift.Equatable {
        /// A lifecycle rule for individual objects in an Outposts bucket.
        public var rules: [S3ControlClientTypes.LifecycleRule]?

        public init(
            rules: [S3ControlClientTypes.LifecycleRule]? = nil
        )
        {
            self.rules = rules
        }
    }

}

extension S3ControlClientTypes.LifecycleExpiration {

    static func writingClosure(_ value: S3ControlClientTypes.LifecycleExpiration?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Date"].writeTimestamp(value.date, format: .dateTime)
        try writer["Days"].write(value.days)
        try writer["ExpiredObjectDeleteMarker"].write(value.expiredObjectDeleteMarker)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.LifecycleExpiration, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.LifecycleExpiration()
            value.date = try reader["Date"].readTimestampIfPresent(format: .dateTime)
            value.days = try reader["Days"].readIfPresent() ?? 0
            value.expiredObjectDeleteMarker = try reader["ExpiredObjectDeleteMarker"].readIfPresent() ?? false
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// The container of the Outposts bucket lifecycle expiration.
    public struct LifecycleExpiration: Swift.Equatable {
        /// Indicates at what date the object is to be deleted. Should be in GMT ISO 8601 format.
        public var date: ClientRuntime.Date?
        /// Indicates the lifetime, in days, of the objects that are subject to the rule. The value must be a non-zero positive integer.
        public var days: Swift.Int
        /// Indicates whether Amazon S3 will remove a delete marker with no noncurrent versions. If set to true, the delete marker will be expired. If set to false, the policy takes no action. This cannot be specified with Days or Date in a Lifecycle Expiration Policy.
        public var expiredObjectDeleteMarker: Swift.Bool

        public init(
            date: ClientRuntime.Date? = nil,
            days: Swift.Int = 0,
            expiredObjectDeleteMarker: Swift.Bool = false
        )
        {
            self.date = date
            self.days = days
            self.expiredObjectDeleteMarker = expiredObjectDeleteMarker
        }
    }

}

extension S3ControlClientTypes.LifecycleRule {

    static func writingClosure(_ value: S3ControlClientTypes.LifecycleRule?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["AbortIncompleteMultipartUpload"].write(value.abortIncompleteMultipartUpload, writingClosure: S3ControlClientTypes.AbortIncompleteMultipartUpload.writingClosure(_:to:))
        try writer["Expiration"].write(value.expiration, writingClosure: S3ControlClientTypes.LifecycleExpiration.writingClosure(_:to:))
        try writer["Filter"].write(value.filter, writingClosure: S3ControlClientTypes.LifecycleRuleFilter.writingClosure(_:to:))
        try writer["ID"].write(value.id)
        try writer["NoncurrentVersionExpiration"].write(value.noncurrentVersionExpiration, writingClosure: S3ControlClientTypes.NoncurrentVersionExpiration.writingClosure(_:to:))
        try writer["NoncurrentVersionTransitions"].writeList(value.noncurrentVersionTransitions, memberWritingClosure: S3ControlClientTypes.NoncurrentVersionTransition.writingClosure(_:to:), memberNodeInfo: "NoncurrentVersionTransition", isFlattened: false)
        try writer["Status"].write(value.status)
        try writer["Transitions"].writeList(value.transitions, memberWritingClosure: S3ControlClientTypes.Transition.writingClosure(_:to:), memberNodeInfo: "Transition", isFlattened: false)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.LifecycleRule, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.LifecycleRule()
            value.expiration = try reader["Expiration"].readIfPresent(readingClosure: S3ControlClientTypes.LifecycleExpiration.readingClosure)
            value.id = try reader["ID"].readIfPresent()
            value.filter = try reader["Filter"].readIfPresent(readingClosure: S3ControlClientTypes.LifecycleRuleFilter.readingClosure)
            value.status = try reader["Status"].readIfPresent()
            value.transitions = try reader["Transitions"].readListIfPresent(memberReadingClosure: S3ControlClientTypes.Transition.readingClosure, memberNodeInfo: "Transition", isFlattened: false)
            value.noncurrentVersionTransitions = try reader["NoncurrentVersionTransitions"].readListIfPresent(memberReadingClosure: S3ControlClientTypes.NoncurrentVersionTransition.readingClosure, memberNodeInfo: "NoncurrentVersionTransition", isFlattened: false)
            value.noncurrentVersionExpiration = try reader["NoncurrentVersionExpiration"].readIfPresent(readingClosure: S3ControlClientTypes.NoncurrentVersionExpiration.readingClosure)
            value.abortIncompleteMultipartUpload = try reader["AbortIncompleteMultipartUpload"].readIfPresent(readingClosure: S3ControlClientTypes.AbortIncompleteMultipartUpload.readingClosure)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// The container for the Outposts bucket lifecycle rule.
    public struct LifecycleRule: Swift.Equatable {
        /// Specifies the days since the initiation of an incomplete multipart upload that Amazon S3 waits before permanently removing all parts of the upload. For more information, see [ Aborting Incomplete Multipart Uploads Using a Bucket Lifecycle Configuration](https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuoverview.html#mpu-abort-incomplete-mpu-lifecycle-config) in the Amazon S3 User Guide.
        public var abortIncompleteMultipartUpload: S3ControlClientTypes.AbortIncompleteMultipartUpload?
        /// Specifies the expiration for the lifecycle of the object in the form of date, days and, whether the object has a delete marker.
        public var expiration: S3ControlClientTypes.LifecycleExpiration?
        /// The container for the filter of lifecycle rule.
        public var filter: S3ControlClientTypes.LifecycleRuleFilter?
        /// Unique identifier for the rule. The value cannot be longer than 255 characters.
        public var id: Swift.String?
        /// The noncurrent version expiration of the lifecycle rule.
        public var noncurrentVersionExpiration: S3ControlClientTypes.NoncurrentVersionExpiration?
        /// Specifies the transition rule for the lifecycle rule that describes when noncurrent objects transition to a specific storage class. If your bucket is versioning-enabled (or versioning is suspended), you can set this action to request that Amazon S3 transition noncurrent object versions to a specific storage class at a set period in the object's lifetime. This is not supported by Amazon S3 on Outposts buckets.
        public var noncurrentVersionTransitions: [S3ControlClientTypes.NoncurrentVersionTransition]?
        /// If 'Enabled', the rule is currently being applied. If 'Disabled', the rule is not currently being applied.
        /// This member is required.
        public var status: S3ControlClientTypes.ExpirationStatus?
        /// Specifies when an Amazon S3 object transitions to a specified storage class. This is not supported by Amazon S3 on Outposts buckets.
        public var transitions: [S3ControlClientTypes.Transition]?

        public init(
            abortIncompleteMultipartUpload: S3ControlClientTypes.AbortIncompleteMultipartUpload? = nil,
            expiration: S3ControlClientTypes.LifecycleExpiration? = nil,
            filter: S3ControlClientTypes.LifecycleRuleFilter? = nil,
            id: Swift.String? = nil,
            noncurrentVersionExpiration: S3ControlClientTypes.NoncurrentVersionExpiration? = nil,
            noncurrentVersionTransitions: [S3ControlClientTypes.NoncurrentVersionTransition]? = nil,
            status: S3ControlClientTypes.ExpirationStatus? = nil,
            transitions: [S3ControlClientTypes.Transition]? = nil
        )
        {
            self.abortIncompleteMultipartUpload = abortIncompleteMultipartUpload
            self.expiration = expiration
            self.filter = filter
            self.id = id
            self.noncurrentVersionExpiration = noncurrentVersionExpiration
            self.noncurrentVersionTransitions = noncurrentVersionTransitions
            self.status = status
            self.transitions = transitions
        }
    }

}

extension S3ControlClientTypes.LifecycleRuleAndOperator {

    static func writingClosure(_ value: S3ControlClientTypes.LifecycleRuleAndOperator?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ObjectSizeGreaterThan"].write(value.objectSizeGreaterThan)
        try writer["ObjectSizeLessThan"].write(value.objectSizeLessThan)
        try writer["Prefix"].write(value.`prefix`)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: S3ControlClientTypes.S3Tag.writingClosure(_:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.LifecycleRuleAndOperator, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.LifecycleRuleAndOperator()
            value.`prefix` = try reader["Prefix"].readIfPresent()
            value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: S3ControlClientTypes.S3Tag.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.objectSizeGreaterThan = try reader["ObjectSizeGreaterThan"].readIfPresent()
            value.objectSizeLessThan = try reader["ObjectSizeLessThan"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// The container for the Outposts bucket lifecycle rule and operator.
    public struct LifecycleRuleAndOperator: Swift.Equatable {
        /// Minimum object size to which the rule applies.
        public var objectSizeGreaterThan: Swift.Int?
        /// Maximum object size to which the rule applies.
        public var objectSizeLessThan: Swift.Int?
        /// Prefix identifying one or more objects to which the rule applies.
        public var `prefix`: Swift.String?
        /// All of these tags must exist in the object's tag set in order for the rule to apply.
        public var tags: [S3ControlClientTypes.S3Tag]?

        public init(
            objectSizeGreaterThan: Swift.Int? = nil,
            objectSizeLessThan: Swift.Int? = nil,
            `prefix`: Swift.String? = nil,
            tags: [S3ControlClientTypes.S3Tag]? = nil
        )
        {
            self.objectSizeGreaterThan = objectSizeGreaterThan
            self.objectSizeLessThan = objectSizeLessThan
            self.`prefix` = `prefix`
            self.tags = tags
        }
    }

}

extension S3ControlClientTypes.LifecycleRuleFilter {

    static func writingClosure(_ value: S3ControlClientTypes.LifecycleRuleFilter?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["And"].write(value.and, writingClosure: S3ControlClientTypes.LifecycleRuleAndOperator.writingClosure(_:to:))
        try writer["ObjectSizeGreaterThan"].write(value.objectSizeGreaterThan)
        try writer["ObjectSizeLessThan"].write(value.objectSizeLessThan)
        try writer["Prefix"].write(value.`prefix`)
        try writer["Tag"].write(value.tag, writingClosure: S3ControlClientTypes.S3Tag.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.LifecycleRuleFilter, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.LifecycleRuleFilter()
            value.`prefix` = try reader["Prefix"].readIfPresent()
            value.tag = try reader["Tag"].readIfPresent(readingClosure: S3ControlClientTypes.S3Tag.readingClosure)
            value.and = try reader["And"].readIfPresent(readingClosure: S3ControlClientTypes.LifecycleRuleAndOperator.readingClosure)
            value.objectSizeGreaterThan = try reader["ObjectSizeGreaterThan"].readIfPresent()
            value.objectSizeLessThan = try reader["ObjectSizeLessThan"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// The container for the filter of the lifecycle rule.
    public struct LifecycleRuleFilter: Swift.Equatable {
        /// The container for the AND condition for the lifecycle rule.
        public var and: S3ControlClientTypes.LifecycleRuleAndOperator?
        /// Minimum object size to which the rule applies.
        public var objectSizeGreaterThan: Swift.Int?
        /// Maximum object size to which the rule applies.
        public var objectSizeLessThan: Swift.Int?
        /// Prefix identifying one or more objects to which the rule applies. When you're using XML requests, you must replace special characters (such as carriage returns) in object keys with their equivalent XML entity codes. For more information, see [ XML-related object key constraints](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints) in the Amazon S3 User Guide.
        public var `prefix`: Swift.String?
        /// A container for a key-value name pair.
        public var tag: S3ControlClientTypes.S3Tag?

        public init(
            and: S3ControlClientTypes.LifecycleRuleAndOperator? = nil,
            objectSizeGreaterThan: Swift.Int? = nil,
            objectSizeLessThan: Swift.Int? = nil,
            `prefix`: Swift.String? = nil,
            tag: S3ControlClientTypes.S3Tag? = nil
        )
        {
            self.and = and
            self.objectSizeGreaterThan = objectSizeGreaterThan
            self.objectSizeLessThan = objectSizeLessThan
            self.`prefix` = `prefix`
            self.tag = tag
        }
    }

}

extension S3ControlClientTypes.ListAccessGrantEntry {

    static func writingClosure(_ value: S3ControlClientTypes.ListAccessGrantEntry?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["AccessGrantArn"].write(value.accessGrantArn)
        try writer["AccessGrantId"].write(value.accessGrantId)
        try writer["AccessGrantsLocationConfiguration"].write(value.accessGrantsLocationConfiguration, writingClosure: S3ControlClientTypes.AccessGrantsLocationConfiguration.writingClosure(_:to:))
        try writer["AccessGrantsLocationId"].write(value.accessGrantsLocationId)
        try writer["ApplicationArn"].write(value.applicationArn)
        try writer["CreatedAt"].writeTimestamp(value.createdAt, format: .dateTime)
        try writer["GrantScope"].write(value.grantScope)
        try writer["Grantee"].write(value.grantee, writingClosure: S3ControlClientTypes.Grantee.writingClosure(_:to:))
        try writer["Permission"].write(value.permission)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.ListAccessGrantEntry, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.ListAccessGrantEntry()
            value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: .dateTime)
            value.accessGrantId = try reader["AccessGrantId"].readIfPresent()
            value.accessGrantArn = try reader["AccessGrantArn"].readIfPresent()
            value.grantee = try reader["Grantee"].readIfPresent(readingClosure: S3ControlClientTypes.Grantee.readingClosure)
            value.permission = try reader["Permission"].readIfPresent()
            value.accessGrantsLocationId = try reader["AccessGrantsLocationId"].readIfPresent()
            value.accessGrantsLocationConfiguration = try reader["AccessGrantsLocationConfiguration"].readIfPresent(readingClosure: S3ControlClientTypes.AccessGrantsLocationConfiguration.readingClosure)
            value.grantScope = try reader["GrantScope"].readIfPresent()
            value.applicationArn = try reader["ApplicationArn"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// Information about the access grant.
    public struct ListAccessGrantEntry: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the access grant.
        public var accessGrantArn: Swift.String?
        /// The ID of the access grant. S3 Access Grants auto-generates this ID when you create the access grant.
        public var accessGrantId: Swift.String?
        /// The configuration options of the grant location. The grant location is the S3 path to the data to which you are granting access.
        public var accessGrantsLocationConfiguration: S3ControlClientTypes.AccessGrantsLocationConfiguration?
        /// The ID of the registered location to which you are granting access. S3 Access Grants assigns this ID when you register the location. S3 Access Grants assigns the ID default to the default location s3:// and assigns an auto-generated ID to other locations that you register.
        public var accessGrantsLocationId: Swift.String?
        /// The Amazon Resource Name (ARN) of an Amazon Web Services IAM Identity Center application associated with your Identity Center instance. If the grant includes an application ARN, the grantee can only access the S3 data through this application.
        public var applicationArn: Swift.String?
        /// The date and time when you created the S3 Access Grants instance.
        public var createdAt: ClientRuntime.Date?
        /// The S3 path of the data to which you are granting access. It is the result of appending the Subprefix to the location scope.
        public var grantScope: Swift.String?
        /// The user, group, or role to which you are granting access. You can grant access to an IAM user or role. If you have added your corporate directory to Amazon Web Services IAM Identity Center and associated your Identity Center instance with your S3 Access Grants instance, the grantee can also be a corporate directory user or group.
        public var grantee: S3ControlClientTypes.Grantee?
        /// The type of access granted to your S3 data, which can be set to one of the following values:
        ///
        /// * READ – Grant read-only access to the S3 data.
        ///
        /// * WRITE – Grant write-only access to the S3 data.
        ///
        /// * READWRITE – Grant both read and write access to the S3 data.
        public var permission: S3ControlClientTypes.Permission?

        public init(
            accessGrantArn: Swift.String? = nil,
            accessGrantId: Swift.String? = nil,
            accessGrantsLocationConfiguration: S3ControlClientTypes.AccessGrantsLocationConfiguration? = nil,
            accessGrantsLocationId: Swift.String? = nil,
            applicationArn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            grantScope: Swift.String? = nil,
            grantee: S3ControlClientTypes.Grantee? = nil,
            permission: S3ControlClientTypes.Permission? = nil
        )
        {
            self.accessGrantArn = accessGrantArn
            self.accessGrantId = accessGrantId
            self.accessGrantsLocationConfiguration = accessGrantsLocationConfiguration
            self.accessGrantsLocationId = accessGrantsLocationId
            self.applicationArn = applicationArn
            self.createdAt = createdAt
            self.grantScope = grantScope
            self.grantee = grantee
            self.permission = permission
        }
    }

}

extension ListAccessGrantsInput {

    static func headerProvider(_ value: ListAccessGrantsInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension ListAccessGrantsInput {

    static func queryItemProvider(_ value: ListAccessGrantsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let grantScope = value.grantScope {
            let grantScopeQueryItem = ClientRuntime.SDKURLQueryItem(name: "grantscope".urlPercentEncoding(), value: Swift.String(grantScope).urlPercentEncoding())
            items.append(grantScopeQueryItem)
        }
        if let granteeType = value.granteeType {
            let granteeTypeQueryItem = ClientRuntime.SDKURLQueryItem(name: "granteetype".urlPercentEncoding(), value: Swift.String(granteeType.rawValue).urlPercentEncoding())
            items.append(granteeTypeQueryItem)
        }
        if let applicationArn = value.applicationArn {
            let applicationArnQueryItem = ClientRuntime.SDKURLQueryItem(name: "application_arn".urlPercentEncoding(), value: Swift.String(applicationArn).urlPercentEncoding())
            items.append(applicationArnQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let permission = value.permission {
            let permissionQueryItem = ClientRuntime.SDKURLQueryItem(name: "permission".urlPercentEncoding(), value: Swift.String(permission.rawValue).urlPercentEncoding())
            items.append(permissionQueryItem)
        }
        if let granteeIdentifier = value.granteeIdentifier {
            let granteeIdentifierQueryItem = ClientRuntime.SDKURLQueryItem(name: "granteeidentifier".urlPercentEncoding(), value: Swift.String(granteeIdentifier).urlPercentEncoding())
            items.append(granteeIdentifierQueryItem)
        }
        return items
    }
}

extension ListAccessGrantsInput {

    static func urlPathProvider(_ value: ListAccessGrantsInput) -> Swift.String? {
        return "/v20180820/accessgrantsinstance/grants"
    }
}

public struct ListAccessGrantsInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that is making this request.
    /// This member is required.
    public var accountId: Swift.String?
    /// The Amazon Resource Name (ARN) of an Amazon Web Services IAM Identity Center application associated with your Identity Center instance. If the grant includes an application ARN, the grantee can only access the S3 data through this application.
    public var applicationArn: Swift.String?
    /// The S3 path of the data to which you are granting access. It is the result of appending the Subprefix to the location scope.
    public var grantScope: Swift.String?
    /// The unique identifer of the Grantee. If the grantee type is IAM, the identifier is the IAM Amazon Resource Name (ARN) of the user or role. If the grantee type is a directory user or group, the identifier is 128-bit universally unique identifier (UUID) in the format a1b2c3d4-5678-90ab-cdef-EXAMPLE11111. You can obtain this UUID from your Amazon Web Services IAM Identity Center instance.
    public var granteeIdentifier: Swift.String?
    /// The type of the grantee to which access has been granted. It can be one of the following values:
    ///
    /// * IAM - An IAM user or role.
    ///
    /// * DIRECTORY_USER - Your corporate directory user. You can use this option if you have added your corporate identity directory to IAM Identity Center and associated the IAM Identity Center instance with your S3 Access Grants instance.
    ///
    /// * DIRECTORY_GROUP - Your corporate directory group. You can use this option if you have added your corporate identity directory to IAM Identity Center and associated the IAM Identity Center instance with your S3 Access Grants instance.
    public var granteeType: S3ControlClientTypes.GranteeType?
    /// The maximum number of access grants that you would like returned in the List Access Grants response. If the results include the pagination token NextToken, make another call using the NextToken to determine if there are more results.
    public var maxResults: Swift.Int?
    /// A pagination token to request the next page of results. Pass this value into a subsequent List Access Grants request in order to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The type of permission granted to your S3 data, which can be set to one of the following values:
    ///
    /// * READ – Grant read-only access to the S3 data.
    ///
    /// * WRITE – Grant write-only access to the S3 data.
    ///
    /// * READWRITE – Grant both read and write access to the S3 data.
    public var permission: S3ControlClientTypes.Permission?

    public init(
        accountId: Swift.String? = nil,
        applicationArn: Swift.String? = nil,
        grantScope: Swift.String? = nil,
        granteeIdentifier: Swift.String? = nil,
        granteeType: S3ControlClientTypes.GranteeType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        permission: S3ControlClientTypes.Permission? = nil
    )
    {
        self.accountId = accountId
        self.applicationArn = applicationArn
        self.grantScope = grantScope
        self.granteeIdentifier = granteeIdentifier
        self.granteeType = granteeType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.permission = permission
    }
}

extension S3ControlClientTypes.ListAccessGrantsInstanceEntry {

    static func writingClosure(_ value: S3ControlClientTypes.ListAccessGrantsInstanceEntry?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["AccessGrantsInstanceArn"].write(value.accessGrantsInstanceArn)
        try writer["AccessGrantsInstanceId"].write(value.accessGrantsInstanceId)
        try writer["CreatedAt"].writeTimestamp(value.createdAt, format: .dateTime)
        try writer["IdentityCenterArn"].write(value.identityCenterArn)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.ListAccessGrantsInstanceEntry, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.ListAccessGrantsInstanceEntry()
            value.accessGrantsInstanceId = try reader["AccessGrantsInstanceId"].readIfPresent()
            value.accessGrantsInstanceArn = try reader["AccessGrantsInstanceArn"].readIfPresent()
            value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: .dateTime)
            value.identityCenterArn = try reader["IdentityCenterArn"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// Information about the S3 Access Grants instance.
    public struct ListAccessGrantsInstanceEntry: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the S3 Access Grants instance.
        public var accessGrantsInstanceArn: Swift.String?
        /// The ID of the S3 Access Grants instance. The ID is default. You can have one S3 Access Grants instance per Region per account.
        public var accessGrantsInstanceId: Swift.String?
        /// The date and time when you created the S3 Access Grants instance.
        public var createdAt: ClientRuntime.Date?
        /// If you associated your S3 Access Grants instance with an Amazon Web Services IAM Identity Center instance, this field returns the Amazon Resource Name (ARN) of the IAM Identity Center instance application; a subresource of the original Identity Center instance. S3 Access Grants creates this Identity Center application for the specific S3 Access Grants instance.
        public var identityCenterArn: Swift.String?

        public init(
            accessGrantsInstanceArn: Swift.String? = nil,
            accessGrantsInstanceId: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            identityCenterArn: Swift.String? = nil
        )
        {
            self.accessGrantsInstanceArn = accessGrantsInstanceArn
            self.accessGrantsInstanceId = accessGrantsInstanceId
            self.createdAt = createdAt
            self.identityCenterArn = identityCenterArn
        }
    }

}

extension ListAccessGrantsInstancesInput {

    static func headerProvider(_ value: ListAccessGrantsInstancesInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension ListAccessGrantsInstancesInput {

    static func queryItemProvider(_ value: ListAccessGrantsInstancesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListAccessGrantsInstancesInput {

    static func urlPathProvider(_ value: ListAccessGrantsInstancesInput) -> Swift.String? {
        return "/v20180820/accessgrantsinstances"
    }
}

public struct ListAccessGrantsInstancesInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that is making this request.
    /// This member is required.
    public var accountId: Swift.String?
    /// The maximum number of access grants that you would like returned in the List Access Grants response. If the results include the pagination token NextToken, make another call using the NextToken to determine if there are more results.
    public var maxResults: Swift.Int?
    /// A pagination token to request the next page of results. Pass this value into a subsequent List Access Grants Instances request in order to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListAccessGrantsInstancesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListAccessGrantsInstancesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = ListAccessGrantsInstancesOutput()
            value.accessGrantsInstancesList = try reader["AccessGrantsInstancesList"].readListIfPresent(memberReadingClosure: S3ControlClientTypes.ListAccessGrantsInstanceEntry.readingClosure, memberNodeInfo: "AccessGrantsInstance", isFlattened: false)
            value.nextToken = try reader["NextToken"].readIfPresent()
            return value
        }
    }
}

public struct ListAccessGrantsInstancesOutput: Swift.Equatable {
    /// A container for a list of S3 Access Grants instances.
    public var accessGrantsInstancesList: [S3ControlClientTypes.ListAccessGrantsInstanceEntry]?
    /// A pagination token to request the next page of results. Pass this value into a subsequent List Access Grants Instances request in order to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        accessGrantsInstancesList: [S3ControlClientTypes.ListAccessGrantsInstanceEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accessGrantsInstancesList = accessGrantsInstancesList
        self.nextToken = nextToken
    }
}

enum ListAccessGrantsInstancesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension S3ControlClientTypes.ListAccessGrantsLocationsEntry {

    static func writingClosure(_ value: S3ControlClientTypes.ListAccessGrantsLocationsEntry?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["AccessGrantsLocationArn"].write(value.accessGrantsLocationArn)
        try writer["AccessGrantsLocationId"].write(value.accessGrantsLocationId)
        try writer["CreatedAt"].writeTimestamp(value.createdAt, format: .dateTime)
        try writer["IAMRoleArn"].write(value.iamRoleArn)
        try writer["LocationScope"].write(value.locationScope)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.ListAccessGrantsLocationsEntry, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.ListAccessGrantsLocationsEntry()
            value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: .dateTime)
            value.accessGrantsLocationId = try reader["AccessGrantsLocationId"].readIfPresent()
            value.accessGrantsLocationArn = try reader["AccessGrantsLocationArn"].readIfPresent()
            value.locationScope = try reader["LocationScope"].readIfPresent()
            value.iamRoleArn = try reader["IAMRoleArn"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// A container for information about the registered location.
    public struct ListAccessGrantsLocationsEntry: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the registered location.
        public var accessGrantsLocationArn: Swift.String?
        /// The ID of the registered location to which you are granting access. S3 Access Grants assigns this ID when you register the location. S3 Access Grants assigns the ID default to the default location s3:// and assigns an auto-generated ID to other locations that you register.
        public var accessGrantsLocationId: Swift.String?
        /// The date and time when you registered the location.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the IAM role for the registered location. S3 Access Grants assumes this role to manage access to the registered location.
        public var iamRoleArn: Swift.String?
        /// The S3 path to the location that you are registering. The location scope can be the default S3 location s3://, the S3 path to a bucket s3://, or the S3 path to a bucket and prefix s3:///. A prefix in S3 is a string of characters at the beginning of an object key name used to organize the objects that you store in your S3 buckets. For example, object key names that start with the engineering/ prefix or object key names that start with the marketing/campaigns/ prefix.
        public var locationScope: Swift.String?

        public init(
            accessGrantsLocationArn: Swift.String? = nil,
            accessGrantsLocationId: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            iamRoleArn: Swift.String? = nil,
            locationScope: Swift.String? = nil
        )
        {
            self.accessGrantsLocationArn = accessGrantsLocationArn
            self.accessGrantsLocationId = accessGrantsLocationId
            self.createdAt = createdAt
            self.iamRoleArn = iamRoleArn
            self.locationScope = locationScope
        }
    }

}

extension ListAccessGrantsLocationsInput {

    static func headerProvider(_ value: ListAccessGrantsLocationsInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension ListAccessGrantsLocationsInput {

    static func queryItemProvider(_ value: ListAccessGrantsLocationsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let locationScope = value.locationScope {
            let locationScopeQueryItem = ClientRuntime.SDKURLQueryItem(name: "locationscope".urlPercentEncoding(), value: Swift.String(locationScope).urlPercentEncoding())
            items.append(locationScopeQueryItem)
        }
        return items
    }
}

extension ListAccessGrantsLocationsInput {

    static func urlPathProvider(_ value: ListAccessGrantsLocationsInput) -> Swift.String? {
        return "/v20180820/accessgrantsinstance/locations"
    }
}

public struct ListAccessGrantsLocationsInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that is making this request.
    /// This member is required.
    public var accountId: Swift.String?
    /// The S3 path to the location that you are registering. The location scope can be the default S3 location s3://, the S3 path to a bucket s3://, or the S3 path to a bucket and prefix s3:///. A prefix in S3 is a string of characters at the beginning of an object key name used to organize the objects that you store in your S3 buckets. For example, object key names that start with the engineering/ prefix or object key names that start with the marketing/campaigns/ prefix.
    public var locationScope: Swift.String?
    /// The maximum number of access grants that you would like returned in the List Access Grants response. If the results include the pagination token NextToken, make another call using the NextToken to determine if there are more results.
    public var maxResults: Swift.Int?
    /// A pagination token to request the next page of results. Pass this value into a subsequent List Access Grants Locations request in order to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        locationScope: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.locationScope = locationScope
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListAccessGrantsLocationsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListAccessGrantsLocationsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = ListAccessGrantsLocationsOutput()
            value.accessGrantsLocationsList = try reader["AccessGrantsLocationsList"].readListIfPresent(memberReadingClosure: S3ControlClientTypes.ListAccessGrantsLocationsEntry.readingClosure, memberNodeInfo: "AccessGrantsLocation", isFlattened: false)
            value.nextToken = try reader["NextToken"].readIfPresent()
            return value
        }
    }
}

public struct ListAccessGrantsLocationsOutput: Swift.Equatable {
    /// A container for a list of registered locations in an S3 Access Grants instance.
    public var accessGrantsLocationsList: [S3ControlClientTypes.ListAccessGrantsLocationsEntry]?
    /// A pagination token to request the next page of results. Pass this value into a subsequent List Access Grants Locations request in order to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        accessGrantsLocationsList: [S3ControlClientTypes.ListAccessGrantsLocationsEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accessGrantsLocationsList = accessGrantsLocationsList
        self.nextToken = nextToken
    }
}

enum ListAccessGrantsLocationsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension ListAccessGrantsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListAccessGrantsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = ListAccessGrantsOutput()
            value.accessGrantsList = try reader["AccessGrantsList"].readListIfPresent(memberReadingClosure: S3ControlClientTypes.ListAccessGrantEntry.readingClosure, memberNodeInfo: "AccessGrant", isFlattened: false)
            value.nextToken = try reader["NextToken"].readIfPresent()
            return value
        }
    }
}

public struct ListAccessGrantsOutput: Swift.Equatable {
    /// A container for a list of grants in an S3 Access Grants instance.
    public var accessGrantsList: [S3ControlClientTypes.ListAccessGrantEntry]?
    /// A pagination token to request the next page of results. Pass this value into a subsequent List Access Grants request in order to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        accessGrantsList: [S3ControlClientTypes.ListAccessGrantEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accessGrantsList = accessGrantsList
        self.nextToken = nextToken
    }
}

enum ListAccessGrantsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension ListAccessPointsForObjectLambdaInput {

    static func headerProvider(_ value: ListAccessPointsForObjectLambdaInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension ListAccessPointsForObjectLambdaInput {

    static func queryItemProvider(_ value: ListAccessPointsForObjectLambdaInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListAccessPointsForObjectLambdaInput {

    static func urlPathProvider(_ value: ListAccessPointsForObjectLambdaInput) -> Swift.String? {
        return "/v20180820/accesspointforobjectlambda"
    }
}

public struct ListAccessPointsForObjectLambdaInput: Swift.Equatable {
    /// The account ID for the account that owns the specified Object Lambda Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The maximum number of access points that you want to include in the list. The response may contain fewer access points but will never contain more. If there are more than this number of access points, then the response will include a continuation token in the NextToken field that you can use to retrieve the next page of access points.
    public var maxResults: Swift.Int?
    /// If the list has more access points than can be returned in one call to this API, this field contains a continuation token that you can provide in subsequent calls to this API to retrieve additional access points.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListAccessPointsForObjectLambdaOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListAccessPointsForObjectLambdaOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = ListAccessPointsForObjectLambdaOutput()
            value.nextToken = try reader["NextToken"].readIfPresent()
            value.objectLambdaAccessPointList = try reader["ObjectLambdaAccessPointList"].readListIfPresent(memberReadingClosure: S3ControlClientTypes.ObjectLambdaAccessPoint.readingClosure, memberNodeInfo: "ObjectLambdaAccessPoint", isFlattened: false)
            return value
        }
    }
}

public struct ListAccessPointsForObjectLambdaOutput: Swift.Equatable {
    /// If the list has more access points than can be returned in one call to this API, this field contains a continuation token that you can provide in subsequent calls to this API to retrieve additional access points.
    public var nextToken: Swift.String?
    /// Returns list of Object Lambda Access Points.
    public var objectLambdaAccessPointList: [S3ControlClientTypes.ObjectLambdaAccessPoint]?

    public init(
        nextToken: Swift.String? = nil,
        objectLambdaAccessPointList: [S3ControlClientTypes.ObjectLambdaAccessPoint]? = nil
    )
    {
        self.nextToken = nextToken
        self.objectLambdaAccessPointList = objectLambdaAccessPointList
    }
}

enum ListAccessPointsForObjectLambdaOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension ListAccessPointsInput {

    static func headerProvider(_ value: ListAccessPointsInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension ListAccessPointsInput {

    static func queryItemProvider(_ value: ListAccessPointsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let bucket = value.bucket {
            let bucketQueryItem = ClientRuntime.SDKURLQueryItem(name: "bucket".urlPercentEncoding(), value: Swift.String(bucket).urlPercentEncoding())
            items.append(bucketQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListAccessPointsInput {

    static func urlPathProvider(_ value: ListAccessPointsInput) -> Swift.String? {
        return "/v20180820/accesspoint"
    }
}

public struct ListAccessPointsInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the account that owns the specified access points.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the bucket whose associated access points you want to list. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    public var bucket: Swift.String?
    /// The maximum number of access points that you want to include in the list. If the specified bucket has more than this number of access points, then the response will include a continuation token in the NextToken field that you can use to retrieve the next page of access points.
    public var maxResults: Swift.Int?
    /// A continuation token. If a previous call to ListAccessPoints returned a continuation token in the NextToken field, then providing that value here causes Amazon S3 to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListAccessPointsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListAccessPointsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = ListAccessPointsOutput()
            value.accessPointList = try reader["AccessPointList"].readListIfPresent(memberReadingClosure: S3ControlClientTypes.AccessPoint.readingClosure, memberNodeInfo: "AccessPoint", isFlattened: false)
            value.nextToken = try reader["NextToken"].readIfPresent()
            return value
        }
    }
}

public struct ListAccessPointsOutput: Swift.Equatable {
    /// Contains identification and configuration information for one or more access points associated with the specified bucket.
    public var accessPointList: [S3ControlClientTypes.AccessPoint]?
    /// If the specified bucket has more access points than can be returned in one call to this API, this field contains a continuation token that you can provide in subsequent calls to this API to retrieve additional access points.
    public var nextToken: Swift.String?

    public init(
        accessPointList: [S3ControlClientTypes.AccessPoint]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accessPointList = accessPointList
        self.nextToken = nextToken
    }
}

enum ListAccessPointsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension ListJobsInput {

    static func headerProvider(_ value: ListJobsInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension ListJobsInput {

    static func queryItemProvider(_ value: ListJobsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let jobStatuses = value.jobStatuses {
            jobStatuses.forEach { queryItemValue in
                let queryItem = ClientRuntime.SDKURLQueryItem(name: "jobStatuses".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListJobsInput {

    static func urlPathProvider(_ value: ListJobsInput) -> Swift.String? {
        return "/v20180820/jobs"
    }
}

public struct ListJobsInput: Swift.Equatable {
    /// The Amazon Web Services account ID associated with the S3 Batch Operations job.
    /// This member is required.
    public var accountId: Swift.String?
    /// The List Jobs request returns jobs that match the statuses listed in this element.
    public var jobStatuses: [S3ControlClientTypes.JobStatus]?
    /// The maximum number of jobs that Amazon S3 will include in the List Jobs response. If there are more jobs than this number, the response will include a pagination token in the NextToken field to enable you to retrieve the next page of results.
    public var maxResults: Swift.Int?
    /// A pagination token to request the next page of results. Use the token that Amazon S3 returned in the NextToken element of the ListJobsResult from the previous List Jobs request.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        jobStatuses: [S3ControlClientTypes.JobStatus]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.jobStatuses = jobStatuses
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListJobsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListJobsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = ListJobsOutput()
            value.jobs = try reader["Jobs"].readListIfPresent(memberReadingClosure: S3ControlClientTypes.JobListDescriptor.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.nextToken = try reader["NextToken"].readIfPresent()
            return value
        }
    }
}

public struct ListJobsOutput: Swift.Equatable {
    /// The list of current jobs and jobs that have ended within the last 30 days.
    public var jobs: [S3ControlClientTypes.JobListDescriptor]?
    /// If the List Jobs request produced more than the maximum number of results, you can pass this value into a subsequent List Jobs request in order to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        jobs: [S3ControlClientTypes.JobListDescriptor]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

enum ListJobsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "InternalServiceException": return try await InternalServiceException.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidNextTokenException": return try await InvalidNextTokenException.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidRequestException": return try await InvalidRequestException.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension ListMultiRegionAccessPointsInput {

    static func headerProvider(_ value: ListMultiRegionAccessPointsInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension ListMultiRegionAccessPointsInput {

    static func queryItemProvider(_ value: ListMultiRegionAccessPointsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListMultiRegionAccessPointsInput {

    static func urlPathProvider(_ value: ListMultiRegionAccessPointsInput) -> Swift.String? {
        return "/v20180820/mrap/instances"
    }
}

public struct ListMultiRegionAccessPointsInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the owner of the Multi-Region Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// Not currently used. Do not use this parameter.
    public var maxResults: Swift.Int?
    /// Not currently used. Do not use this parameter.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListMultiRegionAccessPointsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListMultiRegionAccessPointsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = ListMultiRegionAccessPointsOutput()
            value.accessPoints = try reader["AccessPoints"].readListIfPresent(memberReadingClosure: S3ControlClientTypes.MultiRegionAccessPointReport.readingClosure, memberNodeInfo: "AccessPoint", isFlattened: false)
            value.nextToken = try reader["NextToken"].readIfPresent()
            return value
        }
    }
}

public struct ListMultiRegionAccessPointsOutput: Swift.Equatable {
    /// The list of Multi-Region Access Points associated with the user.
    public var accessPoints: [S3ControlClientTypes.MultiRegionAccessPointReport]?
    /// If the specified bucket has more Multi-Region Access Points than can be returned in one call to this action, this field contains a continuation token. You can use this token tin subsequent calls to this action to retrieve additional Multi-Region Access Points.
    public var nextToken: Swift.String?

    public init(
        accessPoints: [S3ControlClientTypes.MultiRegionAccessPointReport]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accessPoints = accessPoints
        self.nextToken = nextToken
    }
}

enum ListMultiRegionAccessPointsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension ListRegionalBucketsInput {

    static func headerProvider(_ value: ListRegionalBucketsInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        if let outpostId = value.outpostId {
            items.add(Header(name: "x-amz-outpost-id", value: Swift.String(outpostId)))
        }
        return items
    }
}

extension ListRegionalBucketsInput {

    static func queryItemProvider(_ value: ListRegionalBucketsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListRegionalBucketsInput {

    static func urlPathProvider(_ value: ListRegionalBucketsInput) -> Swift.String? {
        return "/v20180820/bucket"
    }
}

public struct ListRegionalBucketsInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    ///
    public var maxResults: Swift.Int?
    ///
    public var nextToken: Swift.String?
    /// The ID of the Outposts resource. This ID is required by Amazon S3 on Outposts buckets.
    public var outpostId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        outpostId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.outpostId = outpostId
    }
}

extension ListRegionalBucketsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListRegionalBucketsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = ListRegionalBucketsOutput()
            value.nextToken = try reader["NextToken"].readIfPresent()
            value.regionalBucketList = try reader["RegionalBucketList"].readListIfPresent(memberReadingClosure: S3ControlClientTypes.RegionalBucket.readingClosure, memberNodeInfo: "RegionalBucket", isFlattened: false)
            return value
        }
    }
}

public struct ListRegionalBucketsOutput: Swift.Equatable {
    /// NextToken is sent when isTruncated is true, which means there are more buckets that can be listed. The next list requests to Amazon S3 can be continued with this NextToken. NextToken is obfuscated and is not a real key.
    public var nextToken: Swift.String?
    ///
    public var regionalBucketList: [S3ControlClientTypes.RegionalBucket]?

    public init(
        nextToken: Swift.String? = nil,
        regionalBucketList: [S3ControlClientTypes.RegionalBucket]? = nil
    )
    {
        self.nextToken = nextToken
        self.regionalBucketList = regionalBucketList
    }
}

enum ListRegionalBucketsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension S3ControlClientTypes.ListStorageLensConfigurationEntry {

    static func writingClosure(_ value: S3ControlClientTypes.ListStorageLensConfigurationEntry?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["HomeRegion"].write(value.homeRegion)
        try writer["Id"].write(value.id)
        try writer["IsEnabled"].write(value.isEnabled)
        try writer["StorageLensArn"].write(value.storageLensArn)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.ListStorageLensConfigurationEntry, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.ListStorageLensConfigurationEntry()
            value.id = try reader["Id"].readIfPresent()
            value.storageLensArn = try reader["StorageLensArn"].readIfPresent()
            value.homeRegion = try reader["HomeRegion"].readIfPresent()
            value.isEnabled = try reader["IsEnabled"].readIfPresent() ?? false
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// Part of ListStorageLensConfigurationResult. Each entry includes the description of the S3 Storage Lens configuration, its home Region, whether it is enabled, its Amazon Resource Name (ARN), and config ID.
    public struct ListStorageLensConfigurationEntry: Swift.Equatable {
        /// A container for the S3 Storage Lens home Region. Your metrics data is stored and retained in your designated S3 Storage Lens home Region.
        /// This member is required.
        public var homeRegion: Swift.String?
        /// A container for the S3 Storage Lens configuration ID.
        /// This member is required.
        public var id: Swift.String?
        /// A container for whether the S3 Storage Lens configuration is enabled. This property is required.
        public var isEnabled: Swift.Bool
        /// The ARN of the S3 Storage Lens configuration. This property is read-only.
        /// This member is required.
        public var storageLensArn: Swift.String?

        public init(
            homeRegion: Swift.String? = nil,
            id: Swift.String? = nil,
            isEnabled: Swift.Bool = false,
            storageLensArn: Swift.String? = nil
        )
        {
            self.homeRegion = homeRegion
            self.id = id
            self.isEnabled = isEnabled
            self.storageLensArn = storageLensArn
        }
    }

}

extension ListStorageLensConfigurationsInput {

    static func headerProvider(_ value: ListStorageLensConfigurationsInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension ListStorageLensConfigurationsInput {

    static func queryItemProvider(_ value: ListStorageLensConfigurationsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListStorageLensConfigurationsInput {

    static func urlPathProvider(_ value: ListStorageLensConfigurationsInput) -> Swift.String? {
        return "/v20180820/storagelens"
    }
}

public struct ListStorageLensConfigurationsInput: Swift.Equatable {
    /// The account ID of the requester.
    /// This member is required.
    public var accountId: Swift.String?
    /// A pagination token to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.nextToken = nextToken
    }
}

extension ListStorageLensConfigurationsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListStorageLensConfigurationsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = ListStorageLensConfigurationsOutput()
            value.nextToken = try reader["NextToken"].readIfPresent()
            value.storageLensConfigurationList = try reader["StorageLensConfigurationList"].readListIfPresent(memberReadingClosure: S3ControlClientTypes.ListStorageLensConfigurationEntry.readingClosure, memberNodeInfo: "StorageLensConfiguration", isFlattened: true)
            return value
        }
    }
}

public struct ListStorageLensConfigurationsOutput: Swift.Equatable {
    /// If the request produced more than the maximum number of S3 Storage Lens configuration results, you can pass this value into a subsequent request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// A list of S3 Storage Lens configurations.
    public var storageLensConfigurationList: [S3ControlClientTypes.ListStorageLensConfigurationEntry]?

    public init(
        nextToken: Swift.String? = nil,
        storageLensConfigurationList: [S3ControlClientTypes.ListStorageLensConfigurationEntry]? = nil
    )
    {
        self.nextToken = nextToken
        self.storageLensConfigurationList = storageLensConfigurationList
    }
}

enum ListStorageLensConfigurationsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension S3ControlClientTypes.ListStorageLensGroupEntry {

    static func writingClosure(_ value: S3ControlClientTypes.ListStorageLensGroupEntry?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["HomeRegion"].write(value.homeRegion)
        try writer["Name"].write(value.name)
        try writer["StorageLensGroupArn"].write(value.storageLensGroupArn)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.ListStorageLensGroupEntry, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.ListStorageLensGroupEntry()
            value.name = try reader["Name"].readIfPresent()
            value.storageLensGroupArn = try reader["StorageLensGroupArn"].readIfPresent()
            value.homeRegion = try reader["HomeRegion"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// Each entry contains a Storage Lens group that exists in the specified home Region.
    public struct ListStorageLensGroupEntry: Swift.Equatable {
        /// Contains the Amazon Web Services Region where the Storage Lens group was created.
        /// This member is required.
        public var homeRegion: Swift.String?
        /// Contains the name of the Storage Lens group that exists in the specified home Region.
        /// This member is required.
        public var name: Swift.String?
        /// Contains the Amazon Resource Name (ARN) of the Storage Lens group. This property is read-only.
        /// This member is required.
        public var storageLensGroupArn: Swift.String?

        public init(
            homeRegion: Swift.String? = nil,
            name: Swift.String? = nil,
            storageLensGroupArn: Swift.String? = nil
        )
        {
            self.homeRegion = homeRegion
            self.name = name
            self.storageLensGroupArn = storageLensGroupArn
        }
    }

}

extension ListStorageLensGroupsInput {

    static func headerProvider(_ value: ListStorageLensGroupsInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension ListStorageLensGroupsInput {

    static func queryItemProvider(_ value: ListStorageLensGroupsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListStorageLensGroupsInput {

    static func urlPathProvider(_ value: ListStorageLensGroupsInput) -> Swift.String? {
        return "/v20180820/storagelensgroup"
    }
}

public struct ListStorageLensGroupsInput: Swift.Equatable {
    /// The Amazon Web Services account ID that owns the Storage Lens groups.
    /// This member is required.
    public var accountId: Swift.String?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.nextToken = nextToken
    }
}

extension ListStorageLensGroupsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListStorageLensGroupsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = ListStorageLensGroupsOutput()
            value.nextToken = try reader["NextToken"].readIfPresent()
            value.storageLensGroupList = try reader["StorageLensGroupList"].readListIfPresent(memberReadingClosure: S3ControlClientTypes.ListStorageLensGroupEntry.readingClosure, memberNodeInfo: "StorageLensGroup", isFlattened: true)
            return value
        }
    }
}

public struct ListStorageLensGroupsOutput: Swift.Equatable {
    /// If NextToken is returned, there are more Storage Lens groups results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?
    /// The list of Storage Lens groups that exist in the specified home Region.
    public var storageLensGroupList: [S3ControlClientTypes.ListStorageLensGroupEntry]?

    public init(
        nextToken: Swift.String? = nil,
        storageLensGroupList: [S3ControlClientTypes.ListStorageLensGroupEntry]? = nil
    )
    {
        self.nextToken = nextToken
        self.storageLensGroupList = storageLensGroupList
    }
}

enum ListStorageLensGroupsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension ListTagsForResourceInput {

    static func headerProvider(_ value: ListTagsForResourceInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/v20180820/tags/\(resourceArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the resource owner.
    /// This member is required.
    public var accountId: Swift.String?
    /// The Amazon Resource Name (ARN) of the S3 resource that you want to list the tags for. The tagged resource can be an S3 Storage Lens group or S3 Access Grants instance, registered location, or grant.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.resourceArn = resourceArn
    }
}

extension ListTagsForResourceOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListTagsForResourceOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = ListTagsForResourceOutput()
            value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: S3ControlClientTypes.Tag.readingClosure, memberNodeInfo: "Tag", isFlattened: false)
            return value
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The Amazon Web Services resource tags that are associated with the resource.
    public var tags: [S3ControlClientTypes.Tag]?

    public init(
        tags: [S3ControlClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

enum ListTagsForResourceOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension S3ControlClientTypes {
    public enum MFADelete: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [MFADelete] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MFADelete(rawValue: rawValue) ?? MFADelete.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum MFADeleteStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [MFADeleteStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MFADeleteStatus(rawValue: rawValue) ?? MFADeleteStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.MatchObjectAge {

    static func writingClosure(_ value: S3ControlClientTypes.MatchObjectAge?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["DaysGreaterThan"].write(value.daysGreaterThan)
        try writer["DaysLessThan"].write(value.daysLessThan)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.MatchObjectAge, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.MatchObjectAge()
            value.daysGreaterThan = try reader["DaysGreaterThan"].readIfPresent() ?? 0
            value.daysLessThan = try reader["DaysLessThan"].readIfPresent() ?? 0
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// A filter condition that specifies the object age range of included objects in days. Only integers are supported.
    public struct MatchObjectAge: Swift.Equatable {
        /// Specifies the maximum object age in days. Must be a positive whole number, greater than the minimum object age and less than or equal to 2,147,483,647.
        public var daysGreaterThan: Swift.Int
        /// Specifies the minimum object age in days. The value must be a positive whole number, greater than 0 and less than or equal to 2,147,483,647.
        public var daysLessThan: Swift.Int

        public init(
            daysGreaterThan: Swift.Int = 0,
            daysLessThan: Swift.Int = 0
        )
        {
            self.daysGreaterThan = daysGreaterThan
            self.daysLessThan = daysLessThan
        }
    }

}

extension S3ControlClientTypes.MatchObjectSize {

    static func writingClosure(_ value: S3ControlClientTypes.MatchObjectSize?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["BytesGreaterThan"].write(value.bytesGreaterThan)
        try writer["BytesLessThan"].write(value.bytesLessThan)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.MatchObjectSize, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.MatchObjectSize()
            value.bytesGreaterThan = try reader["BytesGreaterThan"].readIfPresent() ?? 0
            value.bytesLessThan = try reader["BytesLessThan"].readIfPresent() ?? 0
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// A filter condition that specifies the object size range of included objects in bytes. Only integers are supported.
    public struct MatchObjectSize: Swift.Equatable {
        /// Specifies the minimum object size in Bytes. The value must be a positive number, greater than 0 and less than 5 TB.
        public var bytesGreaterThan: Swift.Int
        /// Specifies the maximum object size in Bytes. The value must be a positive number, greater than the minimum object size and less than 5 TB.
        public var bytesLessThan: Swift.Int

        public init(
            bytesGreaterThan: Swift.Int = 0,
            bytesLessThan: Swift.Int = 0
        )
        {
            self.bytesGreaterThan = bytesGreaterThan
            self.bytesLessThan = bytesLessThan
        }
    }

}

extension S3ControlClientTypes.Metrics {

    static func writingClosure(_ value: S3ControlClientTypes.Metrics?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["EventThreshold"].write(value.eventThreshold, writingClosure: S3ControlClientTypes.ReplicationTimeValue.writingClosure(_:to:))
        try writer["Status"].write(value.status)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.Metrics, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.Metrics()
            value.status = try reader["Status"].readIfPresent()
            value.eventThreshold = try reader["EventThreshold"].readIfPresent(readingClosure: S3ControlClientTypes.ReplicationTimeValue.readingClosure)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// A container that specifies replication metrics-related settings.
    public struct Metrics: Swift.Equatable {
        /// A container that specifies the time threshold for emitting the s3:Replication:OperationMissedThreshold event. This is not supported by Amazon S3 on Outposts buckets.
        public var eventThreshold: S3ControlClientTypes.ReplicationTimeValue?
        /// Specifies whether replication metrics are enabled.
        /// This member is required.
        public var status: S3ControlClientTypes.MetricsStatus?

        public init(
            eventThreshold: S3ControlClientTypes.ReplicationTimeValue? = nil,
            status: S3ControlClientTypes.MetricsStatus? = nil
        )
        {
            self.eventThreshold = eventThreshold
            self.status = status
        }
    }

}

extension S3ControlClientTypes {
    public enum MetricsStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [MetricsStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MetricsStatus(rawValue: rawValue) ?? MetricsStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.MultiRegionAccessPointPolicyDocument {

    static func writingClosure(_ value: S3ControlClientTypes.MultiRegionAccessPointPolicyDocument?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Established"].write(value.established, writingClosure: S3ControlClientTypes.EstablishedMultiRegionAccessPointPolicy.writingClosure(_:to:))
        try writer["Proposed"].write(value.proposed, writingClosure: S3ControlClientTypes.ProposedMultiRegionAccessPointPolicy.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.MultiRegionAccessPointPolicyDocument, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.MultiRegionAccessPointPolicyDocument()
            value.established = try reader["Established"].readIfPresent(readingClosure: S3ControlClientTypes.EstablishedMultiRegionAccessPointPolicy.readingClosure)
            value.proposed = try reader["Proposed"].readIfPresent(readingClosure: S3ControlClientTypes.ProposedMultiRegionAccessPointPolicy.readingClosure)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// The Multi-Region Access Point access control policy. When you update the policy, the update is first listed as the proposed policy. After the update is finished and all Regions have been updated, the proposed policy is listed as the established policy. If both policies have the same version number, the proposed policy is the established policy.
    public struct MultiRegionAccessPointPolicyDocument: Swift.Equatable {
        /// The last established policy for the Multi-Region Access Point.
        public var established: S3ControlClientTypes.EstablishedMultiRegionAccessPointPolicy?
        /// The proposed policy for the Multi-Region Access Point.
        public var proposed: S3ControlClientTypes.ProposedMultiRegionAccessPointPolicy?

        public init(
            established: S3ControlClientTypes.EstablishedMultiRegionAccessPointPolicy? = nil,
            proposed: S3ControlClientTypes.ProposedMultiRegionAccessPointPolicy? = nil
        )
        {
            self.established = established
            self.proposed = proposed
        }
    }

}

extension S3ControlClientTypes.MultiRegionAccessPointRegionalResponse {

    static func writingClosure(_ value: S3ControlClientTypes.MultiRegionAccessPointRegionalResponse?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Name"].write(value.name)
        try writer["RequestStatus"].write(value.requestStatus)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.MultiRegionAccessPointRegionalResponse, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.MultiRegionAccessPointRegionalResponse()
            value.name = try reader["Name"].readIfPresent()
            value.requestStatus = try reader["RequestStatus"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// Status information for a single Multi-Region Access Point Region.
    public struct MultiRegionAccessPointRegionalResponse: Swift.Equatable {
        /// The name of the Region in the Multi-Region Access Point.
        public var name: Swift.String?
        /// The current status of the Multi-Region Access Point in this Region.
        public var requestStatus: Swift.String?

        public init(
            name: Swift.String? = nil,
            requestStatus: Swift.String? = nil
        )
        {
            self.name = name
            self.requestStatus = requestStatus
        }
    }

}

extension S3ControlClientTypes.MultiRegionAccessPointReport {

    static func writingClosure(_ value: S3ControlClientTypes.MultiRegionAccessPointReport?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Alias"].write(value.alias)
        try writer["CreatedAt"].writeTimestamp(value.createdAt, format: .dateTime)
        try writer["Name"].write(value.name)
        try writer["PublicAccessBlock"].write(value.publicAccessBlock, writingClosure: S3ControlClientTypes.PublicAccessBlockConfiguration.writingClosure(_:to:))
        try writer["Regions"].writeList(value.regions, memberWritingClosure: S3ControlClientTypes.RegionReport.writingClosure(_:to:), memberNodeInfo: "Region", isFlattened: false)
        try writer["Status"].write(value.status)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.MultiRegionAccessPointReport, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.MultiRegionAccessPointReport()
            value.name = try reader["Name"].readIfPresent()
            value.alias = try reader["Alias"].readIfPresent()
            value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: .dateTime)
            value.publicAccessBlock = try reader["PublicAccessBlock"].readIfPresent(readingClosure: S3ControlClientTypes.PublicAccessBlockConfiguration.readingClosure)
            value.status = try reader["Status"].readIfPresent()
            value.regions = try reader["Regions"].readListIfPresent(memberReadingClosure: S3ControlClientTypes.RegionReport.readingClosure, memberNodeInfo: "Region", isFlattened: false)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// A collection of statuses for a Multi-Region Access Point in the various Regions it supports.
    public struct MultiRegionAccessPointReport: Swift.Equatable {
        /// The alias for the Multi-Region Access Point. For more information about the distinction between the name and the alias of an Multi-Region Access Point, see [Managing Multi-Region Access Points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/CreatingMultiRegionAccessPoints.html#multi-region-access-point-naming).
        public var alias: Swift.String?
        /// When the Multi-Region Access Point create request was received.
        public var createdAt: ClientRuntime.Date?
        /// The name of the Multi-Region Access Point.
        public var name: Swift.String?
        /// The PublicAccessBlock configuration that you want to apply to this Amazon S3 account. You can enable the configuration options in any combination. For more information about when Amazon S3 considers a bucket or object public, see [The Meaning of "Public"](https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status) in the Amazon S3 User Guide. This data type is not supported for Amazon S3 on Outposts.
        public var publicAccessBlock: S3ControlClientTypes.PublicAccessBlockConfiguration?
        /// A collection of the Regions and buckets associated with the Multi-Region Access Point.
        public var regions: [S3ControlClientTypes.RegionReport]?
        /// The current status of the Multi-Region Access Point. CREATING and DELETING are temporary states that exist while the request is propagating and being completed. If a Multi-Region Access Point has a status of PARTIALLY_CREATED, you can retry creation or send a request to delete the Multi-Region Access Point. If a Multi-Region Access Point has a status of PARTIALLY_DELETED, you can retry a delete request to finish the deletion of the Multi-Region Access Point.
        public var status: S3ControlClientTypes.MultiRegionAccessPointStatus?

        public init(
            alias: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            publicAccessBlock: S3ControlClientTypes.PublicAccessBlockConfiguration? = nil,
            regions: [S3ControlClientTypes.RegionReport]? = nil,
            status: S3ControlClientTypes.MultiRegionAccessPointStatus? = nil
        )
        {
            self.alias = alias
            self.createdAt = createdAt
            self.name = name
            self.publicAccessBlock = publicAccessBlock
            self.regions = regions
            self.status = status
        }
    }

}

extension S3ControlClientTypes.MultiRegionAccessPointRoute {

    static func writingClosure(_ value: S3ControlClientTypes.MultiRegionAccessPointRoute?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Bucket"].write(value.bucket)
        try writer["Region"].write(value.region)
        try writer["TrafficDialPercentage"].write(value.trafficDialPercentage)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.MultiRegionAccessPointRoute, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.MultiRegionAccessPointRoute()
            value.bucket = try reader["Bucket"].readIfPresent()
            value.region = try reader["Region"].readIfPresent()
            value.trafficDialPercentage = try reader["TrafficDialPercentage"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// A structure for a Multi-Region Access Point that indicates where Amazon S3 traffic can be routed. Routes can be either active or passive. Active routes can process Amazon S3 requests through the Multi-Region Access Point, but passive routes are not eligible to process Amazon S3 requests. Each route contains the Amazon S3 bucket name and the Amazon Web Services Region that the bucket is located in. The route also includes the TrafficDialPercentage value, which shows whether the bucket and Region are active (indicated by a value of 100) or passive (indicated by a value of 0).
    public struct MultiRegionAccessPointRoute: Swift.Equatable {
        /// The name of the Amazon S3 bucket for which you'll submit a routing configuration change. Either the Bucket or the Region value must be provided. If both are provided, the bucket must be in the specified Region.
        public var bucket: Swift.String?
        /// The Amazon Web Services Region to which you'll be submitting a routing configuration change. Either the Bucket or the Region value must be provided. If both are provided, the bucket must be in the specified Region.
        public var region: Swift.String?
        /// The traffic state for the specified bucket or Amazon Web Services Region. A value of 0 indicates a passive state, which means that no new traffic will be routed to the Region. A value of 100 indicates an active state, which means that traffic will be routed to the specified Region. When the routing configuration for a Region is changed from active to passive, any in-progress operations (uploads, copies, deletes, and so on) to the formerly active Region will continue to run to until a final success or failure status is reached. If all Regions in the routing configuration are designated as passive, you'll receive an InvalidRequest error.
        /// This member is required.
        public var trafficDialPercentage: Swift.Int?

        public init(
            bucket: Swift.String? = nil,
            region: Swift.String? = nil,
            trafficDialPercentage: Swift.Int? = nil
        )
        {
            self.bucket = bucket
            self.region = region
            self.trafficDialPercentage = trafficDialPercentage
        }
    }

}

extension S3ControlClientTypes {
    public enum MultiRegionAccessPointStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case creating
        case deleting
        case inconsistentAcrossRegions
        case partiallyCreated
        case partiallyDeleted
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [MultiRegionAccessPointStatus] {
            return [
                .creating,
                .deleting,
                .inconsistentAcrossRegions,
                .partiallyCreated,
                .partiallyDeleted,
                .ready,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .inconsistentAcrossRegions: return "INCONSISTENT_ACROSS_REGIONS"
            case .partiallyCreated: return "PARTIALLY_CREATED"
            case .partiallyDeleted: return "PARTIALLY_DELETED"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MultiRegionAccessPointStatus(rawValue: rawValue) ?? MultiRegionAccessPointStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.MultiRegionAccessPointsAsyncResponse {

    static func writingClosure(_ value: S3ControlClientTypes.MultiRegionAccessPointsAsyncResponse?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Regions"].writeList(value.regions, memberWritingClosure: S3ControlClientTypes.MultiRegionAccessPointRegionalResponse.writingClosure(_:to:), memberNodeInfo: "Region", isFlattened: false)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.MultiRegionAccessPointsAsyncResponse, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.MultiRegionAccessPointsAsyncResponse()
            value.regions = try reader["Regions"].readListIfPresent(memberReadingClosure: S3ControlClientTypes.MultiRegionAccessPointRegionalResponse.readingClosure, memberNodeInfo: "Region", isFlattened: false)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// The Multi-Region Access Point details that are returned when querying about an asynchronous request.
    public struct MultiRegionAccessPointsAsyncResponse: Swift.Equatable {
        /// A collection of status information for the different Regions that a Multi-Region Access Point supports.
        public var regions: [S3ControlClientTypes.MultiRegionAccessPointRegionalResponse]?

        public init(
            regions: [S3ControlClientTypes.MultiRegionAccessPointRegionalResponse]? = nil
        )
        {
            self.regions = regions
        }
    }

}

extension S3ControlClientTypes {
    public enum NetworkOrigin: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internet
        case vpc
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkOrigin] {
            return [
                .internet,
                .vpc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internet: return "Internet"
            case .vpc: return "VPC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NetworkOrigin(rawValue: rawValue) ?? NetworkOrigin.sdkUnknown(rawValue)
        }
    }
}

extension NoSuchPublicAccessBlockConfiguration {

    static var readingClosure: SmithyReadWrite.ReadingClosure<NoSuchPublicAccessBlockConfiguration, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = NoSuchPublicAccessBlockConfiguration()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension NoSuchPublicAccessBlockConfiguration {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = NoSuchPublicAccessBlockConfiguration()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Amazon S3 throws this exception if you make a GetPublicAccessBlock request against an account that doesn't have a PublicAccessBlockConfiguration set.
public struct NoSuchPublicAccessBlockConfiguration: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchPublicAccessBlockConfiguration" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension S3ControlClientTypes.NoncurrentVersionExpiration {

    static func writingClosure(_ value: S3ControlClientTypes.NoncurrentVersionExpiration?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["NewerNoncurrentVersions"].write(value.newerNoncurrentVersions)
        try writer["NoncurrentDays"].write(value.noncurrentDays)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.NoncurrentVersionExpiration, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.NoncurrentVersionExpiration()
            value.noncurrentDays = try reader["NoncurrentDays"].readIfPresent() ?? 0
            value.newerNoncurrentVersions = try reader["NewerNoncurrentVersions"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// The container of the noncurrent version expiration.
    public struct NoncurrentVersionExpiration: Swift.Equatable {
        /// Specifies how many noncurrent versions S3 on Outposts will retain. If there are this many more recent noncurrent versions, S3 on Outposts will take the associated action. For more information about noncurrent versions, see [Lifecycle configuration elements](https://docs.aws.amazon.com/AmazonS3/latest/userguide/intro-lifecycle-rules.html) in the Amazon S3 User Guide.
        public var newerNoncurrentVersions: Swift.Int?
        /// Specifies the number of days an object is noncurrent before Amazon S3 can perform the associated action. For information about the noncurrent days calculations, see [How Amazon S3 Calculates When an Object Became Noncurrent](https://docs.aws.amazon.com/AmazonS3/latest/dev/intro-lifecycle-rules.html#non-current-days-calculations) in the Amazon S3 User Guide.
        public var noncurrentDays: Swift.Int

        public init(
            newerNoncurrentVersions: Swift.Int? = nil,
            noncurrentDays: Swift.Int = 0
        )
        {
            self.newerNoncurrentVersions = newerNoncurrentVersions
            self.noncurrentDays = noncurrentDays
        }
    }

}

extension S3ControlClientTypes.NoncurrentVersionTransition {

    static func writingClosure(_ value: S3ControlClientTypes.NoncurrentVersionTransition?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["NoncurrentDays"].write(value.noncurrentDays)
        try writer["StorageClass"].write(value.storageClass)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.NoncurrentVersionTransition, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.NoncurrentVersionTransition()
            value.noncurrentDays = try reader["NoncurrentDays"].readIfPresent() ?? 0
            value.storageClass = try reader["StorageClass"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// The container for the noncurrent version transition.
    public struct NoncurrentVersionTransition: Swift.Equatable {
        /// Specifies the number of days an object is noncurrent before Amazon S3 can perform the associated action. For information about the noncurrent days calculations, see [ How Amazon S3 Calculates How Long an Object Has Been Noncurrent](https://docs.aws.amazon.com/AmazonS3/latest/dev/intro-lifecycle-rules.html#non-current-days-calculations) in the Amazon S3 User Guide.
        public var noncurrentDays: Swift.Int
        /// The class of storage used to store the object.
        public var storageClass: S3ControlClientTypes.TransitionStorageClass?

        public init(
            noncurrentDays: Swift.Int = 0,
            storageClass: S3ControlClientTypes.TransitionStorageClass? = nil
        )
        {
            self.noncurrentDays = noncurrentDays
            self.storageClass = storageClass
        }
    }

}

extension NotFoundException {

    static var readingClosure: SmithyReadWrite.ReadingClosure<NotFoundException, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = NotFoundException()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension NotFoundException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = NotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

///
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension S3ControlClientTypes.ObjectLambdaAccessPoint {

    static func writingClosure(_ value: S3ControlClientTypes.ObjectLambdaAccessPoint?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Alias"].write(value.alias, writingClosure: S3ControlClientTypes.ObjectLambdaAccessPointAlias.writingClosure(_:to:))
        try writer["Name"].write(value.name)
        try writer["ObjectLambdaAccessPointArn"].write(value.objectLambdaAccessPointArn)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.ObjectLambdaAccessPoint, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.ObjectLambdaAccessPoint()
            value.name = try reader["Name"].readIfPresent()
            value.objectLambdaAccessPointArn = try reader["ObjectLambdaAccessPointArn"].readIfPresent()
            value.alias = try reader["Alias"].readIfPresent(readingClosure: S3ControlClientTypes.ObjectLambdaAccessPointAlias.readingClosure)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// An access point with an attached Lambda function used to access transformed data from an Amazon S3 bucket.
    public struct ObjectLambdaAccessPoint: Swift.Equatable {
        /// The alias of the Object Lambda Access Point.
        public var alias: S3ControlClientTypes.ObjectLambdaAccessPointAlias?
        /// The name of the Object Lambda Access Point.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies the ARN for the Object Lambda Access Point.
        public var objectLambdaAccessPointArn: Swift.String?

        public init(
            alias: S3ControlClientTypes.ObjectLambdaAccessPointAlias? = nil,
            name: Swift.String? = nil,
            objectLambdaAccessPointArn: Swift.String? = nil
        )
        {
            self.alias = alias
            self.name = name
            self.objectLambdaAccessPointArn = objectLambdaAccessPointArn
        }
    }

}

extension S3ControlClientTypes.ObjectLambdaAccessPointAlias {

    static func writingClosure(_ value: S3ControlClientTypes.ObjectLambdaAccessPointAlias?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Status"].write(value.status)
        try writer["Value"].write(value.value)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.ObjectLambdaAccessPointAlias, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.ObjectLambdaAccessPointAlias()
            value.value = try reader["Value"].readIfPresent()
            value.status = try reader["Status"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// The alias of an Object Lambda Access Point. For more information, see [How to use a bucket-style alias for your S3 bucket Object Lambda Access Point](https://docs.aws.amazon.com/AmazonS3/latest/userguide/olap-use.html#ol-access-points-alias).
    public struct ObjectLambdaAccessPointAlias: Swift.Equatable {
        /// The status of the Object Lambda Access Point alias. If the status is PROVISIONING, the Object Lambda Access Point is provisioning the alias and the alias is not ready for use yet. If the status is READY, the Object Lambda Access Point alias is successfully provisioned and ready for use.
        public var status: S3ControlClientTypes.ObjectLambdaAccessPointAliasStatus?
        /// The alias value of the Object Lambda Access Point.
        public var value: Swift.String?

        public init(
            status: S3ControlClientTypes.ObjectLambdaAccessPointAliasStatus? = nil,
            value: Swift.String? = nil
        )
        {
            self.status = status
            self.value = value
        }
    }

}

extension S3ControlClientTypes {
    public enum ObjectLambdaAccessPointAliasStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case provisioning
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [ObjectLambdaAccessPointAliasStatus] {
            return [
                .provisioning,
                .ready,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .provisioning: return "PROVISIONING"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ObjectLambdaAccessPointAliasStatus(rawValue: rawValue) ?? ObjectLambdaAccessPointAliasStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum ObjectLambdaAllowedFeature: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case getobjectpartnumber
        case getobjectrange
        case headobjectpartnumber
        case headobjectrange
        case sdkUnknown(Swift.String)

        public static var allCases: [ObjectLambdaAllowedFeature] {
            return [
                .getobjectpartnumber,
                .getobjectrange,
                .headobjectpartnumber,
                .headobjectrange,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .getobjectpartnumber: return "GetObject-PartNumber"
            case .getobjectrange: return "GetObject-Range"
            case .headobjectpartnumber: return "HeadObject-PartNumber"
            case .headobjectrange: return "HeadObject-Range"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ObjectLambdaAllowedFeature(rawValue: rawValue) ?? ObjectLambdaAllowedFeature.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.ObjectLambdaConfiguration {

    static func writingClosure(_ value: S3ControlClientTypes.ObjectLambdaConfiguration?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["AllowedFeatures"].writeList(value.allowedFeatures, memberWritingClosure: S3ControlClientTypes.ObjectLambdaAllowedFeature.writingClosure(_:to:), memberNodeInfo: "AllowedFeature", isFlattened: false)
        try writer["CloudWatchMetricsEnabled"].write(value.cloudWatchMetricsEnabled)
        try writer["SupportingAccessPoint"].write(value.supportingAccessPoint)
        try writer["TransformationConfigurations"].writeList(value.transformationConfigurations, memberWritingClosure: S3ControlClientTypes.ObjectLambdaTransformationConfiguration.writingClosure(_:to:), memberNodeInfo: "TransformationConfiguration", isFlattened: false)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.ObjectLambdaConfiguration, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.ObjectLambdaConfiguration()
            value.supportingAccessPoint = try reader["SupportingAccessPoint"].readIfPresent()
            value.cloudWatchMetricsEnabled = try reader["CloudWatchMetricsEnabled"].readIfPresent() ?? false
            value.allowedFeatures = try reader["AllowedFeatures"].readListIfPresent(memberReadingClosure: S3ControlClientTypes.ObjectLambdaAllowedFeature.readingClosure, memberNodeInfo: "AllowedFeature", isFlattened: false)
            value.transformationConfigurations = try reader["TransformationConfigurations"].readListIfPresent(memberReadingClosure: S3ControlClientTypes.ObjectLambdaTransformationConfiguration.readingClosure, memberNodeInfo: "TransformationConfiguration", isFlattened: false)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// A configuration used when creating an Object Lambda Access Point.
    public struct ObjectLambdaConfiguration: Swift.Equatable {
        /// A container for allowed features. Valid inputs are GetObject-Range, GetObject-PartNumber, HeadObject-Range, and HeadObject-PartNumber.
        public var allowedFeatures: [S3ControlClientTypes.ObjectLambdaAllowedFeature]?
        /// A container for whether the CloudWatch metrics configuration is enabled.
        public var cloudWatchMetricsEnabled: Swift.Bool
        /// Standard access point associated with the Object Lambda Access Point.
        /// This member is required.
        public var supportingAccessPoint: Swift.String?
        /// A container for transformation configurations for an Object Lambda Access Point.
        /// This member is required.
        public var transformationConfigurations: [S3ControlClientTypes.ObjectLambdaTransformationConfiguration]?

        public init(
            allowedFeatures: [S3ControlClientTypes.ObjectLambdaAllowedFeature]? = nil,
            cloudWatchMetricsEnabled: Swift.Bool = false,
            supportingAccessPoint: Swift.String? = nil,
            transformationConfigurations: [S3ControlClientTypes.ObjectLambdaTransformationConfiguration]? = nil
        )
        {
            self.allowedFeatures = allowedFeatures
            self.cloudWatchMetricsEnabled = cloudWatchMetricsEnabled
            self.supportingAccessPoint = supportingAccessPoint
            self.transformationConfigurations = transformationConfigurations
        }
    }

}

extension S3ControlClientTypes.ObjectLambdaContentTransformation {

    static func writingClosure(_ value: S3ControlClientTypes.ObjectLambdaContentTransformation?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        switch value {
            case let .awslambda(awslambda):
                try writer["AwsLambda"].write(awslambda, writingClosure: S3ControlClientTypes.AwsLambdaTransformation.writingClosure(_:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer[.init("sdkUnknown")].write(sdkUnknown)
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.ObjectLambdaContentTransformation, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            let name = reader.children.first?.nodeInfo.name
            switch name {
                case "AwsLambda":
                    return .awslambda(try reader["AwsLambda"].read(readingClosure: S3ControlClientTypes.AwsLambdaTransformation.readingClosure))
                default:
                    return .sdkUnknown(name ?? "")
            }
        }
    }
}

extension S3ControlClientTypes {
    /// A container for AwsLambdaTransformation.
    public enum ObjectLambdaContentTransformation: Swift.Equatable {
        /// A container for an Lambda function.
        case awslambda(S3ControlClientTypes.AwsLambdaTransformation)
        case sdkUnknown(Swift.String)
    }

}

extension S3ControlClientTypes.ObjectLambdaTransformationConfiguration {

    static func writingClosure(_ value: S3ControlClientTypes.ObjectLambdaTransformationConfiguration?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Actions"].writeList(value.actions, memberWritingClosure: S3ControlClientTypes.ObjectLambdaTransformationConfigurationAction.writingClosure(_:to:), memberNodeInfo: "Action", isFlattened: false)
        try writer["ContentTransformation"].write(value.contentTransformation, writingClosure: S3ControlClientTypes.ObjectLambdaContentTransformation.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.ObjectLambdaTransformationConfiguration, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.ObjectLambdaTransformationConfiguration()
            value.actions = try reader["Actions"].readListIfPresent(memberReadingClosure: S3ControlClientTypes.ObjectLambdaTransformationConfigurationAction.readingClosure, memberNodeInfo: "Action", isFlattened: false)
            value.contentTransformation = try reader["ContentTransformation"].readIfPresent(readingClosure: S3ControlClientTypes.ObjectLambdaContentTransformation.readingClosure)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// A configuration used when creating an Object Lambda Access Point transformation.
    public struct ObjectLambdaTransformationConfiguration: Swift.Equatable {
        /// A container for the action of an Object Lambda Access Point configuration. Valid inputs are GetObject, ListObjects, HeadObject, and ListObjectsV2.
        /// This member is required.
        public var actions: [S3ControlClientTypes.ObjectLambdaTransformationConfigurationAction]?
        /// A container for the content transformation of an Object Lambda Access Point configuration.
        /// This member is required.
        public var contentTransformation: S3ControlClientTypes.ObjectLambdaContentTransformation?

        public init(
            actions: [S3ControlClientTypes.ObjectLambdaTransformationConfigurationAction]? = nil,
            contentTransformation: S3ControlClientTypes.ObjectLambdaContentTransformation? = nil
        )
        {
            self.actions = actions
            self.contentTransformation = contentTransformation
        }
    }

}

extension S3ControlClientTypes {
    public enum ObjectLambdaTransformationConfigurationAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case getobject
        case headobject
        case listobjects
        case listobjectsv2
        case sdkUnknown(Swift.String)

        public static var allCases: [ObjectLambdaTransformationConfigurationAction] {
            return [
                .getobject,
                .headobject,
                .listobjects,
                .listobjectsv2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .getobject: return "GetObject"
            case .headobject: return "HeadObject"
            case .listobjects: return "ListObjects"
            case .listobjectsv2: return "ListObjectsV2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ObjectLambdaTransformationConfigurationAction(rawValue: rawValue) ?? ObjectLambdaTransformationConfigurationAction.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum OperationName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lambdainvoke
        case s3deleteobjecttagging
        case s3initiaterestoreobject
        case s3putobjectacl
        case s3putobjectcopy
        case s3putobjectlegalhold
        case s3putobjectretention
        case s3putobjecttagging
        case s3replicateobject
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationName] {
            return [
                .lambdainvoke,
                .s3deleteobjecttagging,
                .s3initiaterestoreobject,
                .s3putobjectacl,
                .s3putobjectcopy,
                .s3putobjectlegalhold,
                .s3putobjectretention,
                .s3putobjecttagging,
                .s3replicateobject,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lambdainvoke: return "LambdaInvoke"
            case .s3deleteobjecttagging: return "S3DeleteObjectTagging"
            case .s3initiaterestoreobject: return "S3InitiateRestoreObject"
            case .s3putobjectacl: return "S3PutObjectAcl"
            case .s3putobjectcopy: return "S3PutObjectCopy"
            case .s3putobjectlegalhold: return "S3PutObjectLegalHold"
            case .s3putobjectretention: return "S3PutObjectRetention"
            case .s3putobjecttagging: return "S3PutObjectTagging"
            case .s3replicateobject: return "S3ReplicateObject"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperationName(rawValue: rawValue) ?? OperationName.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum OutputSchemaVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case v1
        case sdkUnknown(Swift.String)

        public static var allCases: [OutputSchemaVersion] {
            return [
                .v1,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .v1: return "V_1"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OutputSchemaVersion(rawValue: rawValue) ?? OutputSchemaVersion.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum OwnerOverride: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case destination
        case sdkUnknown(Swift.String)

        public static var allCases: [OwnerOverride] {
            return [
                .destination,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .destination: return "Destination"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OwnerOverride(rawValue: rawValue) ?? OwnerOverride.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum Permission: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case read
        case readwrite
        case write
        case sdkUnknown(Swift.String)

        public static var allCases: [Permission] {
            return [
                .read,
                .readwrite,
                .write,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .read: return "READ"
            case .readwrite: return "READWRITE"
            case .write: return "WRITE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Permission(rawValue: rawValue) ?? Permission.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.PolicyStatus {

    static func writingClosure(_ value: S3ControlClientTypes.PolicyStatus?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["IsPublic"].write(value.isPublic)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.PolicyStatus, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.PolicyStatus()
            value.isPublic = try reader["IsPublic"].readIfPresent() ?? false
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// Indicates whether this access point policy is public. For more information about how Amazon S3 evaluates policies to determine whether they are public, see [The Meaning of "Public"](https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status) in the Amazon S3 User Guide.
    public struct PolicyStatus: Swift.Equatable {
        ///
        public var isPublic: Swift.Bool

        public init(
            isPublic: Swift.Bool = false
        )
        {
            self.isPublic = isPublic
        }
    }

}

extension S3ControlClientTypes.PrefixLevel {

    static func writingClosure(_ value: S3ControlClientTypes.PrefixLevel?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["StorageMetrics"].write(value.storageMetrics, writingClosure: S3ControlClientTypes.PrefixLevelStorageMetrics.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.PrefixLevel, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.PrefixLevel()
            value.storageMetrics = try reader["StorageMetrics"].readIfPresent(readingClosure: S3ControlClientTypes.PrefixLevelStorageMetrics.readingClosure)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// A container for the prefix-level configuration.
    public struct PrefixLevel: Swift.Equatable {
        /// A container for the prefix-level storage metrics for S3 Storage Lens.
        /// This member is required.
        public var storageMetrics: S3ControlClientTypes.PrefixLevelStorageMetrics?

        public init(
            storageMetrics: S3ControlClientTypes.PrefixLevelStorageMetrics? = nil
        )
        {
            self.storageMetrics = storageMetrics
        }
    }

}

extension S3ControlClientTypes.PrefixLevelStorageMetrics {

    static func writingClosure(_ value: S3ControlClientTypes.PrefixLevelStorageMetrics?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["IsEnabled"].write(value.isEnabled)
        try writer["SelectionCriteria"].write(value.selectionCriteria, writingClosure: S3ControlClientTypes.SelectionCriteria.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.PrefixLevelStorageMetrics, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.PrefixLevelStorageMetrics()
            value.isEnabled = try reader["IsEnabled"].readIfPresent() ?? false
            value.selectionCriteria = try reader["SelectionCriteria"].readIfPresent(readingClosure: S3ControlClientTypes.SelectionCriteria.readingClosure)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// A container for the prefix-level storage metrics for S3 Storage Lens.
    public struct PrefixLevelStorageMetrics: Swift.Equatable {
        /// A container for whether prefix-level storage metrics are enabled.
        public var isEnabled: Swift.Bool
        ///
        public var selectionCriteria: S3ControlClientTypes.SelectionCriteria?

        public init(
            isEnabled: Swift.Bool = false,
            selectionCriteria: S3ControlClientTypes.SelectionCriteria? = nil
        )
        {
            self.isEnabled = isEnabled
            self.selectionCriteria = selectionCriteria
        }
    }

}

extension S3ControlClientTypes {
    public enum Privilege: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `default`
        case minimal
        case sdkUnknown(Swift.String)

        public static var allCases: [Privilege] {
            return [
                .default,
                .minimal,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .default: return "Default"
            case .minimal: return "Minimal"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Privilege(rawValue: rawValue) ?? Privilege.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.ProposedMultiRegionAccessPointPolicy {

    static func writingClosure(_ value: S3ControlClientTypes.ProposedMultiRegionAccessPointPolicy?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Policy"].write(value.policy)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.ProposedMultiRegionAccessPointPolicy, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.ProposedMultiRegionAccessPointPolicy()
            value.policy = try reader["Policy"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// The proposed access control policy for the Multi-Region Access Point. When you update the policy, the update is first listed as the proposed policy. After the update is finished and all Regions have been updated, the proposed policy is listed as the established policy. If both policies have the same version number, the proposed policy is the established policy.
    public struct ProposedMultiRegionAccessPointPolicy: Swift.Equatable {
        /// The details of the proposed policy.
        public var policy: Swift.String?

        public init(
            policy: Swift.String? = nil
        )
        {
            self.policy = policy
        }
    }

}

extension S3ControlClientTypes.PublicAccessBlockConfiguration {

    static func writingClosure(_ value: S3ControlClientTypes.PublicAccessBlockConfiguration?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["BlockPublicAcls"].write(value.blockPublicAcls)
        try writer["BlockPublicPolicy"].write(value.blockPublicPolicy)
        try writer["IgnorePublicAcls"].write(value.ignorePublicAcls)
        try writer["RestrictPublicBuckets"].write(value.restrictPublicBuckets)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.PublicAccessBlockConfiguration, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.PublicAccessBlockConfiguration()
            value.blockPublicAcls = try reader["BlockPublicAcls"].readIfPresent() ?? false
            value.ignorePublicAcls = try reader["IgnorePublicAcls"].readIfPresent() ?? false
            value.blockPublicPolicy = try reader["BlockPublicPolicy"].readIfPresent() ?? false
            value.restrictPublicBuckets = try reader["RestrictPublicBuckets"].readIfPresent() ?? false
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// The PublicAccessBlock configuration that you want to apply to this Amazon S3 account. You can enable the configuration options in any combination. For more information about when Amazon S3 considers a bucket or object public, see [The Meaning of "Public"](https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status) in the Amazon S3 User Guide. This data type is not supported for Amazon S3 on Outposts.
    public struct PublicAccessBlockConfiguration: Swift.Equatable {
        /// Specifies whether Amazon S3 should block public access control lists (ACLs) for buckets in this account. Setting this element to TRUE causes the following behavior:
        ///
        /// * PutBucketAcl and PutObjectAcl calls fail if the specified ACL is public.
        ///
        /// * PUT Object calls fail if the request includes a public ACL.
        ///
        /// * PUT Bucket calls fail if the request includes a public ACL.
        ///
        ///
        /// Enabling this setting doesn't affect existing policies or ACLs. This property is not supported for Amazon S3 on Outposts.
        public var blockPublicAcls: Swift.Bool
        /// Specifies whether Amazon S3 should block public bucket policies for buckets in this account. Setting this element to TRUE causes Amazon S3 to reject calls to PUT Bucket policy if the specified bucket policy allows public access. Enabling this setting doesn't affect existing bucket policies. This property is not supported for Amazon S3 on Outposts.
        public var blockPublicPolicy: Swift.Bool
        /// Specifies whether Amazon S3 should ignore public ACLs for buckets in this account. Setting this element to TRUE causes Amazon S3 to ignore all public ACLs on buckets in this account and any objects that they contain. Enabling this setting doesn't affect the persistence of any existing ACLs and doesn't prevent new public ACLs from being set. This property is not supported for Amazon S3 on Outposts.
        public var ignorePublicAcls: Swift.Bool
        /// Specifies whether Amazon S3 should restrict public bucket policies for buckets in this account. Setting this element to TRUE restricts access to buckets with public policies to only Amazon Web Service principals and authorized users within this account. Enabling this setting doesn't affect previously stored bucket policies, except that public and cross-account access within any public bucket policy, including non-public delegation to specific accounts, is blocked. This property is not supported for Amazon S3 on Outposts.
        public var restrictPublicBuckets: Swift.Bool

        public init(
            blockPublicAcls: Swift.Bool = false,
            blockPublicPolicy: Swift.Bool = false,
            ignorePublicAcls: Swift.Bool = false,
            restrictPublicBuckets: Swift.Bool = false
        )
        {
            self.blockPublicAcls = blockPublicAcls
            self.blockPublicPolicy = blockPublicPolicy
            self.ignorePublicAcls = ignorePublicAcls
            self.restrictPublicBuckets = restrictPublicBuckets
        }
    }

}

extension PutAccessGrantsInstanceResourcePolicyInput {
    static func writingClosure(_ value: PutAccessGrantsInstanceResourcePolicyInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Organization"].write(value.organization)
        try writer["Policy"].write(value.policy)
    }
}

extension PutAccessGrantsInstanceResourcePolicyInput {

    static func headerProvider(_ value: PutAccessGrantsInstanceResourcePolicyInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension PutAccessGrantsInstanceResourcePolicyInput {

    static func urlPathProvider(_ value: PutAccessGrantsInstanceResourcePolicyInput) -> Swift.String? {
        return "/v20180820/accessgrantsinstance/resourcepolicy"
    }
}

public struct PutAccessGrantsInstanceResourcePolicyInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that is making this request.
    /// This member is required.
    public var accountId: Swift.String?
    /// The Organization of the resource policy of the S3 Access Grants instance.
    public var organization: Swift.String?
    /// The resource policy of the S3 Access Grants instance that you are updating.
    /// This member is required.
    public var policy: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        organization: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.organization = organization
        self.policy = policy
    }
}

extension PutAccessGrantsInstanceResourcePolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<PutAccessGrantsInstanceResourcePolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = PutAccessGrantsInstanceResourcePolicyOutput()
            value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: .dateTime)
            value.organization = try reader["Organization"].readIfPresent()
            value.policy = try reader["Policy"].readIfPresent()
            return value
        }
    }
}

public struct PutAccessGrantsInstanceResourcePolicyOutput: Swift.Equatable {
    /// The date and time when you created the S3 Access Grants instance resource policy.
    public var createdAt: ClientRuntime.Date?
    /// The Organization of the resource policy of the S3 Access Grants instance.
    public var organization: Swift.String?
    /// The updated resource policy of the S3 Access Grants instance.
    public var policy: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        organization: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.organization = organization
        self.policy = policy
    }
}

enum PutAccessGrantsInstanceResourcePolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension PutAccessPointConfigurationForObjectLambdaInput {
    static func writingClosure(_ value: PutAccessPointConfigurationForObjectLambdaInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Configuration"].write(value.configuration, writingClosure: S3ControlClientTypes.ObjectLambdaConfiguration.writingClosure(_:to:))
    }
}

extension PutAccessPointConfigurationForObjectLambdaInput {

    static func headerProvider(_ value: PutAccessPointConfigurationForObjectLambdaInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension PutAccessPointConfigurationForObjectLambdaInput {

    static func urlPathProvider(_ value: PutAccessPointConfigurationForObjectLambdaInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/v20180820/accesspointforobjectlambda/\(name.urlPercentEncoding())/configuration"
    }
}

public struct PutAccessPointConfigurationForObjectLambdaInput: Swift.Equatable {
    /// The account ID for the account that owns the specified Object Lambda Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// Object Lambda Access Point configuration document.
    /// This member is required.
    public var configuration: S3ControlClientTypes.ObjectLambdaConfiguration?
    /// The name of the Object Lambda Access Point.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        configuration: S3ControlClientTypes.ObjectLambdaConfiguration? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.configuration = configuration
        self.name = name
    }
}

extension PutAccessPointConfigurationForObjectLambdaOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<PutAccessPointConfigurationForObjectLambdaOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return PutAccessPointConfigurationForObjectLambdaOutput()
        }
    }
}

public struct PutAccessPointConfigurationForObjectLambdaOutput: Swift.Equatable {

    public init() { }
}

enum PutAccessPointConfigurationForObjectLambdaOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension PutAccessPointPolicyForObjectLambdaInput {
    static func writingClosure(_ value: PutAccessPointPolicyForObjectLambdaInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Policy"].write(value.policy)
    }
}

extension PutAccessPointPolicyForObjectLambdaInput {

    static func headerProvider(_ value: PutAccessPointPolicyForObjectLambdaInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension PutAccessPointPolicyForObjectLambdaInput {

    static func urlPathProvider(_ value: PutAccessPointPolicyForObjectLambdaInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/v20180820/accesspointforobjectlambda/\(name.urlPercentEncoding())/policy"
    }
}

public struct PutAccessPointPolicyForObjectLambdaInput: Swift.Equatable {
    /// The account ID for the account that owns the specified Object Lambda Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the Object Lambda Access Point.
    /// This member is required.
    public var name: Swift.String?
    /// Object Lambda Access Point resource policy document.
    /// This member is required.
    public var policy: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
        self.policy = policy
    }
}

extension PutAccessPointPolicyForObjectLambdaOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<PutAccessPointPolicyForObjectLambdaOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return PutAccessPointPolicyForObjectLambdaOutput()
        }
    }
}

public struct PutAccessPointPolicyForObjectLambdaOutput: Swift.Equatable {

    public init() { }
}

enum PutAccessPointPolicyForObjectLambdaOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension PutAccessPointPolicyInput {
    static func writingClosure(_ value: PutAccessPointPolicyInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Policy"].write(value.policy)
    }
}

extension PutAccessPointPolicyInput {

    static func headerProvider(_ value: PutAccessPointPolicyInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension PutAccessPointPolicyInput {

    static func urlPathProvider(_ value: PutAccessPointPolicyInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/v20180820/accesspoint/\(name.urlPercentEncoding())/policy"
    }
}

public struct PutAccessPointPolicyInput: Swift.Equatable {
    /// The Amazon Web Services account ID for owner of the bucket associated with the specified access point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the access point that you want to associate with the specified policy. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the access point accessed in the format arn:aws:s3-outposts:::outpost//accesspoint/. For example, to access the access point reports-ap through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/accesspoint/reports-ap. The value must be URL encoded.
    /// This member is required.
    public var name: Swift.String?
    /// The policy that you want to apply to the specified access point. For more information about access point policies, see [Managing data access with Amazon S3 access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-points.html) in the Amazon S3 User Guide.
    /// This member is required.
    public var policy: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
        self.policy = policy
    }
}

extension PutAccessPointPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<PutAccessPointPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return PutAccessPointPolicyOutput()
        }
    }
}

public struct PutAccessPointPolicyOutput: Swift.Equatable {

    public init() { }
}

enum PutAccessPointPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension PutBucketLifecycleConfigurationInput {
    static func writingClosure(_ value: PutBucketLifecycleConfigurationInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["LifecycleConfiguration"].write(value.lifecycleConfiguration, writingClosure: S3ControlClientTypes.LifecycleConfiguration.writingClosure(_:to:))
    }
}

extension PutBucketLifecycleConfigurationInput {

    static func headerProvider(_ value: PutBucketLifecycleConfigurationInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension PutBucketLifecycleConfigurationInput {

    static func urlPathProvider(_ value: PutBucketLifecycleConfigurationInput) -> Swift.String? {
        guard let bucket = value.bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/lifecycleconfiguration"
    }
}

public struct PutBucketLifecycleConfigurationInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the bucket for which to set the configuration.
    /// This member is required.
    public var bucket: Swift.String?
    /// Container for lifecycle rules. You can add as many as 1,000 rules.
    public var lifecycleConfiguration: S3ControlClientTypes.LifecycleConfiguration?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil,
        lifecycleConfiguration: S3ControlClientTypes.LifecycleConfiguration? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
        self.lifecycleConfiguration = lifecycleConfiguration
    }
}

extension PutBucketLifecycleConfigurationOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<PutBucketLifecycleConfigurationOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return PutBucketLifecycleConfigurationOutput()
        }
    }
}

public struct PutBucketLifecycleConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum PutBucketLifecycleConfigurationOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension PutBucketPolicyInput {
    static func writingClosure(_ value: PutBucketPolicyInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Policy"].write(value.policy)
    }
}

extension PutBucketPolicyInput {

    static func headerProvider(_ value: PutBucketPolicyInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        if let confirmRemoveSelfBucketAccess = value.confirmRemoveSelfBucketAccess {
            items.add(Header(name: "x-amz-confirm-remove-self-bucket-access", value: Swift.String(confirmRemoveSelfBucketAccess)))
        }
        return items
    }
}

extension PutBucketPolicyInput {

    static func urlPathProvider(_ value: PutBucketPolicyInput) -> Swift.String? {
        guard let bucket = value.bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/policy"
    }
}

public struct PutBucketPolicyInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    /// Specifies the bucket. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?
    /// Set this parameter to true to confirm that you want to remove your permissions to change this bucket policy in the future. This is not supported by Amazon S3 on Outposts buckets.
    public var confirmRemoveSelfBucketAccess: Swift.Bool?
    /// The bucket policy as a JSON document.
    /// This member is required.
    public var policy: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil,
        confirmRemoveSelfBucketAccess: Swift.Bool? = nil,
        policy: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
        self.confirmRemoveSelfBucketAccess = confirmRemoveSelfBucketAccess
        self.policy = policy
    }
}

extension PutBucketPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<PutBucketPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return PutBucketPolicyOutput()
        }
    }
}

public struct PutBucketPolicyOutput: Swift.Equatable {

    public init() { }
}

enum PutBucketPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension PutBucketReplicationInput {
    static func writingClosure(_ value: PutBucketReplicationInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ReplicationConfiguration"].write(value.replicationConfiguration, writingClosure: S3ControlClientTypes.ReplicationConfiguration.writingClosure(_:to:))
    }
}

extension PutBucketReplicationInput {

    static func headerProvider(_ value: PutBucketReplicationInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension PutBucketReplicationInput {

    static func urlPathProvider(_ value: PutBucketReplicationInput) -> Swift.String? {
        guard let bucket = value.bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/replication"
    }
}

public struct PutBucketReplicationInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    /// Specifies the S3 on Outposts bucket to set the configuration for. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?
    ///
    /// This member is required.
    public var replicationConfiguration: S3ControlClientTypes.ReplicationConfiguration?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil,
        replicationConfiguration: S3ControlClientTypes.ReplicationConfiguration? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
        self.replicationConfiguration = replicationConfiguration
    }
}

extension PutBucketReplicationOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<PutBucketReplicationOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return PutBucketReplicationOutput()
        }
    }
}

public struct PutBucketReplicationOutput: Swift.Equatable {

    public init() { }
}

enum PutBucketReplicationOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension PutBucketTaggingInput {
    static func writingClosure(_ value: PutBucketTaggingInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Tagging"].write(value.tagging, writingClosure: S3ControlClientTypes.Tagging.writingClosure(_:to:))
    }
}

extension PutBucketTaggingInput {

    static func headerProvider(_ value: PutBucketTaggingInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension PutBucketTaggingInput {

    static func urlPathProvider(_ value: PutBucketTaggingInput) -> Swift.String? {
        guard let bucket = value.bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/tagging"
    }
}

public struct PutBucketTaggingInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    /// The Amazon Resource Name (ARN) of the bucket. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?
    ///
    /// This member is required.
    public var tagging: S3ControlClientTypes.Tagging?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil,
        tagging: S3ControlClientTypes.Tagging? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
        self.tagging = tagging
    }
}

extension PutBucketTaggingOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<PutBucketTaggingOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return PutBucketTaggingOutput()
        }
    }
}

public struct PutBucketTaggingOutput: Swift.Equatable {

    public init() { }
}

enum PutBucketTaggingOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension PutBucketVersioningInput {
    static func writingClosure(_ value: PutBucketVersioningInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["VersioningConfiguration"].write(value.versioningConfiguration, writingClosure: S3ControlClientTypes.VersioningConfiguration.writingClosure(_:to:))
    }
}

extension PutBucketVersioningInput {

    static func headerProvider(_ value: PutBucketVersioningInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        if let mfa = value.mfa {
            items.add(Header(name: "x-amz-mfa", value: Swift.String(mfa)))
        }
        return items
    }
}

extension PutBucketVersioningInput {

    static func urlPathProvider(_ value: PutBucketVersioningInput) -> Swift.String? {
        guard let bucket = value.bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/versioning"
    }
}

public struct PutBucketVersioningInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the S3 on Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    /// The S3 on Outposts bucket to set the versioning state for.
    /// This member is required.
    public var bucket: Swift.String?
    /// The concatenation of the authentication device's serial number, a space, and the value that is displayed on your authentication device.
    public var mfa: Swift.String?
    /// The root-level tag for the VersioningConfiguration parameters.
    /// This member is required.
    public var versioningConfiguration: S3ControlClientTypes.VersioningConfiguration?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil,
        mfa: Swift.String? = nil,
        versioningConfiguration: S3ControlClientTypes.VersioningConfiguration? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
        self.mfa = mfa
        self.versioningConfiguration = versioningConfiguration
    }
}

extension PutBucketVersioningOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<PutBucketVersioningOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return PutBucketVersioningOutput()
        }
    }
}

public struct PutBucketVersioningOutput: Swift.Equatable {

    public init() { }
}

enum PutBucketVersioningOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension PutJobTaggingInput {
    static func writingClosure(_ value: PutJobTaggingInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Tags"].writeList(value.tags, memberWritingClosure: S3ControlClientTypes.S3Tag.writingClosure(_:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PutJobTaggingInput {

    static func headerProvider(_ value: PutJobTaggingInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension PutJobTaggingInput {

    static func urlPathProvider(_ value: PutJobTaggingInput) -> Swift.String? {
        guard let jobId = value.jobId else {
            return nil
        }
        return "/v20180820/jobs/\(jobId.urlPercentEncoding())/tagging"
    }
}

public struct PutJobTaggingInput: Swift.Equatable {
    /// The Amazon Web Services account ID associated with the S3 Batch Operations job.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID for the S3 Batch Operations job whose tags you want to replace.
    /// This member is required.
    public var jobId: Swift.String?
    /// The set of tags to associate with the S3 Batch Operations job.
    /// This member is required.
    public var tags: [S3ControlClientTypes.S3Tag]?

    public init(
        accountId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        tags: [S3ControlClientTypes.S3Tag]? = nil
    )
    {
        self.accountId = accountId
        self.jobId = jobId
        self.tags = tags
    }
}

extension PutJobTaggingOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<PutJobTaggingOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return PutJobTaggingOutput()
        }
    }
}

public struct PutJobTaggingOutput: Swift.Equatable {

    public init() { }
}

enum PutJobTaggingOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "InternalServiceException": return try await InternalServiceException.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NotFoundException": return try await NotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyRequestsException": return try await TooManyRequestsException.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyTagsException": return try await TooManyTagsException.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension S3ControlClientTypes.PutMultiRegionAccessPointPolicyInput {

    static func writingClosure(_ value: S3ControlClientTypes.PutMultiRegionAccessPointPolicyInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Name"].write(value.name)
        try writer["Policy"].write(value.policy)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.PutMultiRegionAccessPointPolicyInput, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.PutMultiRegionAccessPointPolicyInput()
            value.name = try reader["Name"].readIfPresent()
            value.policy = try reader["Policy"].readIfPresent()
            return value
        }
    }
}

extension PutMultiRegionAccessPointPolicyInput {
    static func writingClosure(_ value: PutMultiRegionAccessPointPolicyInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["Details"].write(value.details, writingClosure: S3ControlClientTypes.PutMultiRegionAccessPointPolicyInput.writingClosure(_:to:))
    }
}

extension PutMultiRegionAccessPointPolicyInput {

    static func headerProvider(_ value: PutMultiRegionAccessPointPolicyInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension PutMultiRegionAccessPointPolicyInput {

    static func urlPathProvider(_ value: PutMultiRegionAccessPointPolicyInput) -> Swift.String? {
        return "/v20180820/async-requests/mrap/put-policy"
    }
}

public struct PutMultiRegionAccessPointPolicyInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the owner of the Multi-Region Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// An idempotency token used to identify the request and guarantee that requests are unique.
    /// This member is required.
    public var clientToken: Swift.String?
    /// A container element containing the details of the policy for the Multi-Region Access Point.
    /// This member is required.
    public var details: S3ControlClientTypes.PutMultiRegionAccessPointPolicyInput?

    public init(
        accountId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        details: S3ControlClientTypes.PutMultiRegionAccessPointPolicyInput? = nil
    )
    {
        self.accountId = accountId
        self.clientToken = clientToken
        self.details = details
    }
}

extension S3ControlClientTypes {
    /// A container for the information associated with a [PutMultiRegionAccessPoint](https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_PutMultiRegionAccessPoint.html) request.
    public struct PutMultiRegionAccessPointPolicyInput: Swift.Equatable {
        /// The name of the Multi-Region Access Point associated with the request.
        /// This member is required.
        public var name: Swift.String?
        /// The policy details for the PutMultiRegionAccessPoint request.
        /// This member is required.
        public var policy: Swift.String?

        public init(
            name: Swift.String? = nil,
            policy: Swift.String? = nil
        )
        {
            self.name = name
            self.policy = policy
        }
    }

}

extension PutMultiRegionAccessPointPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<PutMultiRegionAccessPointPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = PutMultiRegionAccessPointPolicyOutput()
            value.requestTokenARN = try reader["RequestTokenARN"].readIfPresent()
            return value
        }
    }
}

public struct PutMultiRegionAccessPointPolicyOutput: Swift.Equatable {
    /// The request token associated with the request. You can use this token with [DescribeMultiRegionAccessPointOperation](https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_DescribeMultiRegionAccessPointOperation.html) to determine the status of asynchronous requests.
    public var requestTokenARN: Swift.String?

    public init(
        requestTokenARN: Swift.String? = nil
    )
    {
        self.requestTokenARN = requestTokenARN
    }
}

enum PutMultiRegionAccessPointPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension PutPublicAccessBlockInput {
    static func writingClosure(_ value: PutPublicAccessBlockInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["PublicAccessBlockConfiguration"].write(value.publicAccessBlockConfiguration, writingClosure: S3ControlClientTypes.PublicAccessBlockConfiguration.writingClosure(_:to:))
    }
}

extension PutPublicAccessBlockInput {

    static func headerProvider(_ value: PutPublicAccessBlockInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension PutPublicAccessBlockInput {

    static func urlPathProvider(_ value: PutPublicAccessBlockInput) -> Swift.String? {
        return "/v20180820/configuration/publicAccessBlock"
    }
}

public struct PutPublicAccessBlockInput: Swift.Equatable {
    /// The account ID for the Amazon Web Services account whose PublicAccessBlock configuration you want to set.
    /// This member is required.
    public var accountId: Swift.String?
    /// The PublicAccessBlock configuration that you want to apply to the specified Amazon Web Services account.
    /// This member is required.
    public var publicAccessBlockConfiguration: S3ControlClientTypes.PublicAccessBlockConfiguration?

    public init(
        accountId: Swift.String? = nil,
        publicAccessBlockConfiguration: S3ControlClientTypes.PublicAccessBlockConfiguration? = nil
    )
    {
        self.accountId = accountId
        self.publicAccessBlockConfiguration = publicAccessBlockConfiguration
    }
}

extension PutPublicAccessBlockOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<PutPublicAccessBlockOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return PutPublicAccessBlockOutput()
        }
    }
}

public struct PutPublicAccessBlockOutput: Swift.Equatable {

    public init() { }
}

enum PutPublicAccessBlockOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension PutStorageLensConfigurationInput {
    static func writingClosure(_ value: PutStorageLensConfigurationInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["StorageLensConfiguration"].write(value.storageLensConfiguration, writingClosure: S3ControlClientTypes.StorageLensConfiguration.writingClosure(_:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: S3ControlClientTypes.StorageLensTag.writingClosure(_:to:), memberNodeInfo: "Tag", isFlattened: false)
    }
}

extension PutStorageLensConfigurationInput {

    static func headerProvider(_ value: PutStorageLensConfigurationInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension PutStorageLensConfigurationInput {

    static func urlPathProvider(_ value: PutStorageLensConfigurationInput) -> Swift.String? {
        guard let configId = value.configId else {
            return nil
        }
        return "/v20180820/storagelens/\(configId.urlPercentEncoding())"
    }
}

public struct PutStorageLensConfigurationInput: Swift.Equatable {
    /// The account ID of the requester.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID of the S3 Storage Lens configuration.
    /// This member is required.
    public var configId: Swift.String?
    /// The S3 Storage Lens configuration.
    /// This member is required.
    public var storageLensConfiguration: S3ControlClientTypes.StorageLensConfiguration?
    /// The tag set of the S3 Storage Lens configuration. You can set up to a maximum of 50 tags.
    public var tags: [S3ControlClientTypes.StorageLensTag]?

    public init(
        accountId: Swift.String? = nil,
        configId: Swift.String? = nil,
        storageLensConfiguration: S3ControlClientTypes.StorageLensConfiguration? = nil,
        tags: [S3ControlClientTypes.StorageLensTag]? = nil
    )
    {
        self.accountId = accountId
        self.configId = configId
        self.storageLensConfiguration = storageLensConfiguration
        self.tags = tags
    }
}

extension PutStorageLensConfigurationOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<PutStorageLensConfigurationOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return PutStorageLensConfigurationOutput()
        }
    }
}

public struct PutStorageLensConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum PutStorageLensConfigurationOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension PutStorageLensConfigurationTaggingInput {
    static func writingClosure(_ value: PutStorageLensConfigurationTaggingInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Tags"].writeList(value.tags, memberWritingClosure: S3ControlClientTypes.StorageLensTag.writingClosure(_:to:), memberNodeInfo: "Tag", isFlattened: false)
    }
}

extension PutStorageLensConfigurationTaggingInput {

    static func headerProvider(_ value: PutStorageLensConfigurationTaggingInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension PutStorageLensConfigurationTaggingInput {

    static func urlPathProvider(_ value: PutStorageLensConfigurationTaggingInput) -> Swift.String? {
        guard let configId = value.configId else {
            return nil
        }
        return "/v20180820/storagelens/\(configId.urlPercentEncoding())/tagging"
    }
}

public struct PutStorageLensConfigurationTaggingInput: Swift.Equatable {
    /// The account ID of the requester.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID of the S3 Storage Lens configuration.
    /// This member is required.
    public var configId: Swift.String?
    /// The tag set of the S3 Storage Lens configuration. You can set up to a maximum of 50 tags.
    /// This member is required.
    public var tags: [S3ControlClientTypes.StorageLensTag]?

    public init(
        accountId: Swift.String? = nil,
        configId: Swift.String? = nil,
        tags: [S3ControlClientTypes.StorageLensTag]? = nil
    )
    {
        self.accountId = accountId
        self.configId = configId
        self.tags = tags
    }
}

extension PutStorageLensConfigurationTaggingOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<PutStorageLensConfigurationTaggingOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return PutStorageLensConfigurationTaggingOutput()
        }
    }
}

public struct PutStorageLensConfigurationTaggingOutput: Swift.Equatable {

    public init() { }
}

enum PutStorageLensConfigurationTaggingOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension S3ControlClientTypes.Region {

    static func writingClosure(_ value: S3ControlClientTypes.Region?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Bucket"].write(value.bucket)
        try writer["BucketAccountId"].write(value.bucketAccountId)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.Region, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.Region()
            value.bucket = try reader["Bucket"].readIfPresent()
            value.bucketAccountId = try reader["BucketAccountId"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// A Region that supports a Multi-Region Access Point as well as the associated bucket for the Region.
    public struct Region: Swift.Equatable {
        /// The name of the associated bucket for the Region.
        /// This member is required.
        public var bucket: Swift.String?
        /// The Amazon Web Services account ID that owns the Amazon S3 bucket that's associated with this Multi-Region Access Point.
        public var bucketAccountId: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            bucketAccountId: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.bucketAccountId = bucketAccountId
        }
    }

}

extension S3ControlClientTypes.RegionReport {

    static func writingClosure(_ value: S3ControlClientTypes.RegionReport?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Bucket"].write(value.bucket)
        try writer["BucketAccountId"].write(value.bucketAccountId)
        try writer["Region"].write(value.region)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.RegionReport, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.RegionReport()
            value.bucket = try reader["Bucket"].readIfPresent()
            value.region = try reader["Region"].readIfPresent()
            value.bucketAccountId = try reader["BucketAccountId"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// A combination of a bucket and Region that's part of a Multi-Region Access Point.
    public struct RegionReport: Swift.Equatable {
        /// The name of the bucket.
        public var bucket: Swift.String?
        /// The Amazon Web Services account ID that owns the Amazon S3 bucket that's associated with this Multi-Region Access Point.
        public var bucketAccountId: Swift.String?
        /// The name of the Region.
        public var region: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            bucketAccountId: Swift.String? = nil,
            region: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.bucketAccountId = bucketAccountId
            self.region = region
        }
    }

}

extension S3ControlClientTypes.RegionalBucket {

    static func writingClosure(_ value: S3ControlClientTypes.RegionalBucket?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Bucket"].write(value.bucket)
        try writer["BucketArn"].write(value.bucketArn)
        try writer["CreationDate"].writeTimestamp(value.creationDate, format: .dateTime)
        try writer["OutpostId"].write(value.outpostId)
        try writer["PublicAccessBlockEnabled"].write(value.publicAccessBlockEnabled)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.RegionalBucket, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.RegionalBucket()
            value.bucket = try reader["Bucket"].readIfPresent()
            value.bucketArn = try reader["BucketArn"].readIfPresent()
            value.publicAccessBlockEnabled = try reader["PublicAccessBlockEnabled"].readIfPresent() ?? false
            value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: .dateTime)
            value.outpostId = try reader["OutpostId"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// The container for the regional bucket.
    public struct RegionalBucket: Swift.Equatable {
        ///
        /// This member is required.
        public var bucket: Swift.String?
        /// The Amazon Resource Name (ARN) for the regional bucket.
        public var bucketArn: Swift.String?
        /// The creation date of the regional bucket
        /// This member is required.
        public var creationDate: ClientRuntime.Date?
        /// The Outposts ID of the regional bucket.
        public var outpostId: Swift.String?
        ///
        /// This member is required.
        public var publicAccessBlockEnabled: Swift.Bool

        public init(
            bucket: Swift.String? = nil,
            bucketArn: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            outpostId: Swift.String? = nil,
            publicAccessBlockEnabled: Swift.Bool = false
        )
        {
            self.bucket = bucket
            self.bucketArn = bucketArn
            self.creationDate = creationDate
            self.outpostId = outpostId
            self.publicAccessBlockEnabled = publicAccessBlockEnabled
        }
    }

}

extension S3ControlClientTypes.ReplicaModifications {

    static func writingClosure(_ value: S3ControlClientTypes.ReplicaModifications?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Status"].write(value.status)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.ReplicaModifications, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.ReplicaModifications()
            value.status = try reader["Status"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// A filter that you can use to specify whether replica modification sync is enabled. S3 on Outposts replica modification sync can help you keep object metadata synchronized between replicas and source objects. By default, S3 on Outposts replicates metadata from the source objects to the replicas only. When replica modification sync is enabled, S3 on Outposts replicates metadata changes made to the replica copies back to the source object, making the replication bidirectional. To replicate object metadata modifications on replicas, you can specify this element and set the Status of this element to Enabled. You must enable replica modification sync on the source and destination buckets to replicate replica metadata changes between the source and the replicas.
    public struct ReplicaModifications: Swift.Equatable {
        /// Specifies whether S3 on Outposts replicates modifications to object metadata on replicas.
        /// This member is required.
        public var status: S3ControlClientTypes.ReplicaModificationsStatus?

        public init(
            status: S3ControlClientTypes.ReplicaModificationsStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension S3ControlClientTypes {
    public enum ReplicaModificationsStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicaModificationsStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicaModificationsStatus(rawValue: rawValue) ?? ReplicaModificationsStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.ReplicationConfiguration {

    static func writingClosure(_ value: S3ControlClientTypes.ReplicationConfiguration?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Role"].write(value.role)
        try writer["Rules"].writeList(value.rules, memberWritingClosure: S3ControlClientTypes.ReplicationRule.writingClosure(_:to:), memberNodeInfo: "Rule", isFlattened: false)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.ReplicationConfiguration, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.ReplicationConfiguration()
            value.role = try reader["Role"].readIfPresent()
            value.rules = try reader["Rules"].readListIfPresent(memberReadingClosure: S3ControlClientTypes.ReplicationRule.readingClosure, memberNodeInfo: "Rule", isFlattened: false)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// A container for one or more replication rules. A replication configuration must have at least one rule and you can add up to 100 rules. The maximum size of a replication configuration is 128 KB.
    public struct ReplicationConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that S3 on Outposts assumes when replicating objects. For information about S3 replication on Outposts configuration, see [Setting up replication](https://docs.aws.amazon.com/AmazonS3/latest/userguide/outposts-replication-how-setup.html) in the Amazon S3 User Guide.
        /// This member is required.
        public var role: Swift.String?
        /// A container for one or more replication rules. A replication configuration must have at least one rule and can contain an array of 100 rules at the most.
        /// This member is required.
        public var rules: [S3ControlClientTypes.ReplicationRule]?

        public init(
            role: Swift.String? = nil,
            rules: [S3ControlClientTypes.ReplicationRule]? = nil
        )
        {
            self.role = role
            self.rules = rules
        }
    }

}

extension S3ControlClientTypes.ReplicationRule {

    static func writingClosure(_ value: S3ControlClientTypes.ReplicationRule?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Bucket"].write(value.bucket)
        try writer["DeleteMarkerReplication"].write(value.deleteMarkerReplication, writingClosure: S3ControlClientTypes.DeleteMarkerReplication.writingClosure(_:to:))
        try writer["Destination"].write(value.destination, writingClosure: S3ControlClientTypes.Destination.writingClosure(_:to:))
        try writer["ExistingObjectReplication"].write(value.existingObjectReplication, writingClosure: S3ControlClientTypes.ExistingObjectReplication.writingClosure(_:to:))
        try writer["Filter"].write(value.filter, writingClosure: S3ControlClientTypes.ReplicationRuleFilter.writingClosure(_:to:))
        try writer["ID"].write(value.id)
        try writer["Prefix"].write(value.`prefix`)
        try writer["Priority"].write(value.priority)
        try writer["SourceSelectionCriteria"].write(value.sourceSelectionCriteria, writingClosure: S3ControlClientTypes.SourceSelectionCriteria.writingClosure(_:to:))
        try writer["Status"].write(value.status)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.ReplicationRule, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.ReplicationRule()
            value.id = try reader["ID"].readIfPresent()
            value.priority = try reader["Priority"].readIfPresent()
            value.`prefix` = try reader["Prefix"].readIfPresent()
            value.filter = try reader["Filter"].readIfPresent(readingClosure: S3ControlClientTypes.ReplicationRuleFilter.readingClosure)
            value.status = try reader["Status"].readIfPresent()
            value.sourceSelectionCriteria = try reader["SourceSelectionCriteria"].readIfPresent(readingClosure: S3ControlClientTypes.SourceSelectionCriteria.readingClosure)
            value.existingObjectReplication = try reader["ExistingObjectReplication"].readIfPresent(readingClosure: S3ControlClientTypes.ExistingObjectReplication.readingClosure)
            value.destination = try reader["Destination"].readIfPresent(readingClosure: S3ControlClientTypes.Destination.readingClosure)
            value.deleteMarkerReplication = try reader["DeleteMarkerReplication"].readIfPresent(readingClosure: S3ControlClientTypes.DeleteMarkerReplication.readingClosure)
            value.bucket = try reader["Bucket"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// Specifies which S3 on Outposts objects to replicate and where to store the replicas.
    public struct ReplicationRule: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the access point for the source Outposts bucket that you want S3 on Outposts to replicate the objects from.
        /// This member is required.
        public var bucket: Swift.String?
        /// Specifies whether S3 on Outposts replicates delete markers. If you specify a Filter element in your replication configuration, you must also include a DeleteMarkerReplication element. If your Filter includes a Tag element, the DeleteMarkerReplication element's Status child element must be set to Disabled, because S3 on Outposts doesn't support replicating delete markers for tag-based rules. For more information about delete marker replication, see [How delete operations affect replication](https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3OutpostsReplication.html#outposts-replication-what-is-replicated) in the Amazon S3 User Guide.
        public var deleteMarkerReplication: S3ControlClientTypes.DeleteMarkerReplication?
        /// A container for information about the replication destination and its configurations.
        /// This member is required.
        public var destination: S3ControlClientTypes.Destination?
        /// An optional configuration to replicate existing source bucket objects. This is not supported by Amazon S3 on Outposts buckets.
        public var existingObjectReplication: S3ControlClientTypes.ExistingObjectReplication?
        /// A filter that identifies the subset of objects to which the replication rule applies. A Filter element must specify exactly one Prefix, Tag, or And child element.
        public var filter: S3ControlClientTypes.ReplicationRuleFilter?
        /// A unique identifier for the rule. The maximum value is 255 characters.
        public var id: Swift.String?
        /// An object key name prefix that identifies the object or objects to which the rule applies. The maximum prefix length is 1,024 characters. To include all objects in an Outposts bucket, specify an empty string. When you're using XML requests, you must replace special characters (such as carriage returns) in object keys with their equivalent XML entity codes. For more information, see [ XML-related object key constraints](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints) in the Amazon S3 User Guide.
        @available(*, deprecated, message: "Prefix has been deprecated")
        public var `prefix`: Swift.String?
        /// The priority indicates which rule has precedence whenever two or more replication rules conflict. S3 on Outposts attempts to replicate objects according to all replication rules. However, if there are two or more rules with the same destination Outposts bucket, then objects will be replicated according to the rule with the highest priority. The higher the number, the higher the priority. For more information, see [Creating replication rules on Outposts](https://docs.aws.amazon.com/AmazonS3/latest/userguide/replication-between-outposts.html) in the Amazon S3 User Guide.
        public var priority: Swift.Int?
        /// A container that describes additional filters for identifying the source Outposts objects that you want to replicate. You can choose to enable or disable the replication of these objects.
        public var sourceSelectionCriteria: S3ControlClientTypes.SourceSelectionCriteria?
        /// Specifies whether the rule is enabled.
        /// This member is required.
        public var status: S3ControlClientTypes.ReplicationRuleStatus?

        public init(
            bucket: Swift.String? = nil,
            deleteMarkerReplication: S3ControlClientTypes.DeleteMarkerReplication? = nil,
            destination: S3ControlClientTypes.Destination? = nil,
            existingObjectReplication: S3ControlClientTypes.ExistingObjectReplication? = nil,
            filter: S3ControlClientTypes.ReplicationRuleFilter? = nil,
            id: Swift.String? = nil,
            `prefix`: Swift.String? = nil,
            priority: Swift.Int? = nil,
            sourceSelectionCriteria: S3ControlClientTypes.SourceSelectionCriteria? = nil,
            status: S3ControlClientTypes.ReplicationRuleStatus? = nil
        )
        {
            self.bucket = bucket
            self.deleteMarkerReplication = deleteMarkerReplication
            self.destination = destination
            self.existingObjectReplication = existingObjectReplication
            self.filter = filter
            self.id = id
            self.`prefix` = `prefix`
            self.priority = priority
            self.sourceSelectionCriteria = sourceSelectionCriteria
            self.status = status
        }
    }

}

extension S3ControlClientTypes.ReplicationRuleAndOperator {

    static func writingClosure(_ value: S3ControlClientTypes.ReplicationRuleAndOperator?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Prefix"].write(value.`prefix`)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: S3ControlClientTypes.S3Tag.writingClosure(_:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.ReplicationRuleAndOperator, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.ReplicationRuleAndOperator()
            value.`prefix` = try reader["Prefix"].readIfPresent()
            value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: S3ControlClientTypes.S3Tag.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// A container for specifying rule filters. The filters determine the subset of objects to which the rule applies. This element is required only if you specify more than one filter. For example:
    ///
    /// * If you specify both a Prefix and a Tag filter, wrap these filters in an And element.
    ///
    /// * If you specify a filter based on multiple tags, wrap the Tag elements in an And element.
    public struct ReplicationRuleAndOperator: Swift.Equatable {
        /// An object key name prefix that identifies the subset of objects that the rule applies to.
        public var `prefix`: Swift.String?
        /// An array of tags that contain key and value pairs.
        public var tags: [S3ControlClientTypes.S3Tag]?

        public init(
            `prefix`: Swift.String? = nil,
            tags: [S3ControlClientTypes.S3Tag]? = nil
        )
        {
            self.`prefix` = `prefix`
            self.tags = tags
        }
    }

}

extension S3ControlClientTypes.ReplicationRuleFilter {

    static func writingClosure(_ value: S3ControlClientTypes.ReplicationRuleFilter?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["And"].write(value.and, writingClosure: S3ControlClientTypes.ReplicationRuleAndOperator.writingClosure(_:to:))
        try writer["Prefix"].write(value.`prefix`)
        try writer["Tag"].write(value.tag, writingClosure: S3ControlClientTypes.S3Tag.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.ReplicationRuleFilter, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.ReplicationRuleFilter()
            value.`prefix` = try reader["Prefix"].readIfPresent()
            value.tag = try reader["Tag"].readIfPresent(readingClosure: S3ControlClientTypes.S3Tag.readingClosure)
            value.and = try reader["And"].readIfPresent(readingClosure: S3ControlClientTypes.ReplicationRuleAndOperator.readingClosure)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// A filter that identifies the subset of objects to which the replication rule applies. A Filter element must specify exactly one Prefix, Tag, or And child element.
    public struct ReplicationRuleFilter: Swift.Equatable {
        /// A container for specifying rule filters. The filters determine the subset of objects that the rule applies to. This element is required only if you specify more than one filter. For example:
        ///
        /// * If you specify both a Prefix and a Tag filter, wrap these filters in an And element.
        ///
        /// * If you specify a filter based on multiple tags, wrap the Tag elements in an And element.
        public var and: S3ControlClientTypes.ReplicationRuleAndOperator?
        /// An object key name prefix that identifies the subset of objects that the rule applies to. When you're using XML requests, you must replace special characters (such as carriage returns) in object keys with their equivalent XML entity codes. For more information, see [ XML-related object key constraints](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints) in the Amazon S3 User Guide.
        public var `prefix`: Swift.String?
        /// A container for a key-value name pair.
        public var tag: S3ControlClientTypes.S3Tag?

        public init(
            and: S3ControlClientTypes.ReplicationRuleAndOperator? = nil,
            `prefix`: Swift.String? = nil,
            tag: S3ControlClientTypes.S3Tag? = nil
        )
        {
            self.and = and
            self.`prefix` = `prefix`
            self.tag = tag
        }
    }

}

extension S3ControlClientTypes {
    public enum ReplicationRuleStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationRuleStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationRuleStatus(rawValue: rawValue) ?? ReplicationRuleStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum ReplicationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case `none`
        case replica
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationStatus] {
            return [
                .completed,
                .failed,
                .none,
                .replica,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .none: return "NONE"
            case .replica: return "REPLICA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationStatus(rawValue: rawValue) ?? ReplicationStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum ReplicationStorageClass: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deepArchive
        case glacier
        case glacierIr
        case intelligentTiering
        case onezoneIa
        case outposts
        case reducedRedundancy
        case standard
        case standardIa
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationStorageClass] {
            return [
                .deepArchive,
                .glacier,
                .glacierIr,
                .intelligentTiering,
                .onezoneIa,
                .outposts,
                .reducedRedundancy,
                .standard,
                .standardIa,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deepArchive: return "DEEP_ARCHIVE"
            case .glacier: return "GLACIER"
            case .glacierIr: return "GLACIER_IR"
            case .intelligentTiering: return "INTELLIGENT_TIERING"
            case .onezoneIa: return "ONEZONE_IA"
            case .outposts: return "OUTPOSTS"
            case .reducedRedundancy: return "REDUCED_REDUNDANCY"
            case .standard: return "STANDARD"
            case .standardIa: return "STANDARD_IA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationStorageClass(rawValue: rawValue) ?? ReplicationStorageClass.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.ReplicationTime {

    static func writingClosure(_ value: S3ControlClientTypes.ReplicationTime?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Status"].write(value.status)
        try writer["Time"].write(value.time, writingClosure: S3ControlClientTypes.ReplicationTimeValue.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.ReplicationTime, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.ReplicationTime()
            value.status = try reader["Status"].readIfPresent()
            value.time = try reader["Time"].readIfPresent(readingClosure: S3ControlClientTypes.ReplicationTimeValue.readingClosure)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// A container that specifies S3 Replication Time Control (S3 RTC) related information, including whether S3 RTC is enabled and the time when all objects and operations on objects must be replicated. This is not supported by Amazon S3 on Outposts buckets.
    public struct ReplicationTime: Swift.Equatable {
        /// Specifies whether S3 Replication Time Control (S3 RTC) is enabled.
        /// This member is required.
        public var status: S3ControlClientTypes.ReplicationTimeStatus?
        /// A container that specifies the time by which replication should be complete for all objects and operations on objects.
        /// This member is required.
        public var time: S3ControlClientTypes.ReplicationTimeValue?

        public init(
            status: S3ControlClientTypes.ReplicationTimeStatus? = nil,
            time: S3ControlClientTypes.ReplicationTimeValue? = nil
        )
        {
            self.status = status
            self.time = time
        }
    }

}

extension S3ControlClientTypes {
    public enum ReplicationTimeStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationTimeStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationTimeStatus(rawValue: rawValue) ?? ReplicationTimeStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.ReplicationTimeValue {

    static func writingClosure(_ value: S3ControlClientTypes.ReplicationTimeValue?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Minutes"].write(value.minutes)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.ReplicationTimeValue, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.ReplicationTimeValue()
            value.minutes = try reader["Minutes"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// A container that specifies the time value for S3 Replication Time Control (S3 RTC). This value is also used for the replication metrics EventThreshold element. This is not supported by Amazon S3 on Outposts buckets.
    public struct ReplicationTimeValue: Swift.Equatable {
        /// Contains an integer that specifies the time period in minutes. Valid value: 15
        public var minutes: Swift.Int?

        public init(
            minutes: Swift.Int? = nil
        )
        {
            self.minutes = minutes
        }
    }

}

extension S3ControlClientTypes {
    public enum RequestedJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [RequestedJobStatus] {
            return [
                .cancelled,
                .ready,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "Cancelled"
            case .ready: return "Ready"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RequestedJobStatus(rawValue: rawValue) ?? RequestedJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.S3AccessControlList {

    static func writingClosure(_ value: S3ControlClientTypes.S3AccessControlList?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Grants"].writeList(value.grants, memberWritingClosure: S3ControlClientTypes.S3Grant.writingClosure(_:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Owner"].write(value.owner, writingClosure: S3ControlClientTypes.S3ObjectOwner.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.S3AccessControlList, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.S3AccessControlList()
            value.owner = try reader["Owner"].readIfPresent(readingClosure: S3ControlClientTypes.S3ObjectOwner.readingClosure)
            value.grants = try reader["Grants"].readListIfPresent(memberReadingClosure: S3ControlClientTypes.S3Grant.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

extension S3ControlClientTypes {
    ///
    public struct S3AccessControlList: Swift.Equatable {
        ///
        public var grants: [S3ControlClientTypes.S3Grant]?
        ///
        /// This member is required.
        public var owner: S3ControlClientTypes.S3ObjectOwner?

        public init(
            grants: [S3ControlClientTypes.S3Grant]? = nil,
            owner: S3ControlClientTypes.S3ObjectOwner? = nil
        )
        {
            self.grants = grants
            self.owner = owner
        }
    }

}

extension S3ControlClientTypes.S3AccessControlPolicy {

    static func writingClosure(_ value: S3ControlClientTypes.S3AccessControlPolicy?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["AccessControlList"].write(value.accessControlList, writingClosure: S3ControlClientTypes.S3AccessControlList.writingClosure(_:to:))
        try writer["CannedAccessControlList"].write(value.cannedAccessControlList)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.S3AccessControlPolicy, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.S3AccessControlPolicy()
            value.accessControlList = try reader["AccessControlList"].readIfPresent(readingClosure: S3ControlClientTypes.S3AccessControlList.readingClosure)
            value.cannedAccessControlList = try reader["CannedAccessControlList"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    ///
    public struct S3AccessControlPolicy: Swift.Equatable {
        ///
        public var accessControlList: S3ControlClientTypes.S3AccessControlList?
        ///
        public var cannedAccessControlList: S3ControlClientTypes.S3CannedAccessControlList?

        public init(
            accessControlList: S3ControlClientTypes.S3AccessControlList? = nil,
            cannedAccessControlList: S3ControlClientTypes.S3CannedAccessControlList? = nil
        )
        {
            self.accessControlList = accessControlList
            self.cannedAccessControlList = cannedAccessControlList
        }
    }

}

extension S3ControlClientTypes.S3BucketDestination {

    static func writingClosure(_ value: S3ControlClientTypes.S3BucketDestination?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["AccountId"].write(value.accountId)
        try writer["Arn"].write(value.arn)
        try writer["Encryption"].write(value.encryption, writingClosure: S3ControlClientTypes.StorageLensDataExportEncryption.writingClosure(_:to:))
        try writer["Format"].write(value.format)
        try writer["OutputSchemaVersion"].write(value.outputSchemaVersion)
        try writer["Prefix"].write(value.`prefix`)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.S3BucketDestination, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.S3BucketDestination()
            value.format = try reader["Format"].readIfPresent()
            value.outputSchemaVersion = try reader["OutputSchemaVersion"].readIfPresent()
            value.accountId = try reader["AccountId"].readIfPresent()
            value.arn = try reader["Arn"].readIfPresent()
            value.`prefix` = try reader["Prefix"].readIfPresent()
            value.encryption = try reader["Encryption"].readIfPresent(readingClosure: S3ControlClientTypes.StorageLensDataExportEncryption.readingClosure)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// A container for the bucket where the Amazon S3 Storage Lens metrics export files are located.
    public struct S3BucketDestination: Swift.Equatable {
        /// The account ID of the owner of the S3 Storage Lens metrics export bucket.
        /// This member is required.
        public var accountId: Swift.String?
        /// The Amazon Resource Name (ARN) of the bucket. This property is read-only and follows the following format:  arn:aws:s3:us-east-1:example-account-id:bucket/your-destination-bucket-name
        /// This member is required.
        public var arn: Swift.String?
        /// The container for the type encryption of the metrics exports in this bucket.
        public var encryption: S3ControlClientTypes.StorageLensDataExportEncryption?
        ///
        /// This member is required.
        public var format: S3ControlClientTypes.Format?
        /// The schema version of the export file.
        /// This member is required.
        public var outputSchemaVersion: S3ControlClientTypes.OutputSchemaVersion?
        /// The prefix of the destination bucket where the metrics export will be delivered.
        public var `prefix`: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            arn: Swift.String? = nil,
            encryption: S3ControlClientTypes.StorageLensDataExportEncryption? = nil,
            format: S3ControlClientTypes.Format? = nil,
            outputSchemaVersion: S3ControlClientTypes.OutputSchemaVersion? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.arn = arn
            self.encryption = encryption
            self.format = format
            self.outputSchemaVersion = outputSchemaVersion
            self.`prefix` = `prefix`
        }
    }

}

extension S3ControlClientTypes {
    public enum S3CannedAccessControlList: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case authenticatedRead
        case awsExecRead
        case bucketOwnerFullControl
        case bucketOwnerRead
        case `private`
        case publicRead
        case publicReadWrite
        case sdkUnknown(Swift.String)

        public static var allCases: [S3CannedAccessControlList] {
            return [
                .authenticatedRead,
                .awsExecRead,
                .bucketOwnerFullControl,
                .bucketOwnerRead,
                .private,
                .publicRead,
                .publicReadWrite,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .authenticatedRead: return "authenticated-read"
            case .awsExecRead: return "aws-exec-read"
            case .bucketOwnerFullControl: return "bucket-owner-full-control"
            case .bucketOwnerRead: return "bucket-owner-read"
            case .private: return "private"
            case .publicRead: return "public-read"
            case .publicReadWrite: return "public-read-write"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3CannedAccessControlList(rawValue: rawValue) ?? S3CannedAccessControlList.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum S3ChecksumAlgorithm: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case crc32
        case crc32c
        case sha1
        case sha256
        case sdkUnknown(Swift.String)

        public static var allCases: [S3ChecksumAlgorithm] {
            return [
                .crc32,
                .crc32c,
                .sha1,
                .sha256,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .crc32: return "CRC32"
            case .crc32c: return "CRC32C"
            case .sha1: return "SHA1"
            case .sha256: return "SHA256"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3ChecksumAlgorithm(rawValue: rawValue) ?? S3ChecksumAlgorithm.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.S3CopyObjectOperation {

    static func writingClosure(_ value: S3ControlClientTypes.S3CopyObjectOperation?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["AccessControlGrants"].writeList(value.accessControlGrants, memberWritingClosure: S3ControlClientTypes.S3Grant.writingClosure(_:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["BucketKeyEnabled"].write(value.bucketKeyEnabled)
        try writer["CannedAccessControlList"].write(value.cannedAccessControlList)
        try writer["ChecksumAlgorithm"].write(value.checksumAlgorithm)
        try writer["MetadataDirective"].write(value.metadataDirective)
        try writer["ModifiedSinceConstraint"].writeTimestamp(value.modifiedSinceConstraint, format: .dateTime)
        try writer["NewObjectMetadata"].write(value.newObjectMetadata, writingClosure: S3ControlClientTypes.S3ObjectMetadata.writingClosure(_:to:))
        try writer["NewObjectTagging"].writeList(value.newObjectTagging, memberWritingClosure: S3ControlClientTypes.S3Tag.writingClosure(_:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ObjectLockLegalHoldStatus"].write(value.objectLockLegalHoldStatus)
        try writer["ObjectLockMode"].write(value.objectLockMode)
        try writer["ObjectLockRetainUntilDate"].writeTimestamp(value.objectLockRetainUntilDate, format: .dateTime)
        try writer["RedirectLocation"].write(value.redirectLocation)
        try writer["RequesterPays"].write(value.requesterPays)
        try writer["SSEAwsKmsKeyId"].write(value.sseAwsKmsKeyId)
        try writer["StorageClass"].write(value.storageClass)
        try writer["TargetKeyPrefix"].write(value.targetKeyPrefix)
        try writer["TargetResource"].write(value.targetResource)
        try writer["UnModifiedSinceConstraint"].writeTimestamp(value.unModifiedSinceConstraint, format: .dateTime)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.S3CopyObjectOperation, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.S3CopyObjectOperation()
            value.targetResource = try reader["TargetResource"].readIfPresent()
            value.cannedAccessControlList = try reader["CannedAccessControlList"].readIfPresent()
            value.accessControlGrants = try reader["AccessControlGrants"].readListIfPresent(memberReadingClosure: S3ControlClientTypes.S3Grant.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.metadataDirective = try reader["MetadataDirective"].readIfPresent()
            value.modifiedSinceConstraint = try reader["ModifiedSinceConstraint"].readTimestampIfPresent(format: .dateTime)
            value.newObjectMetadata = try reader["NewObjectMetadata"].readIfPresent(readingClosure: S3ControlClientTypes.S3ObjectMetadata.readingClosure)
            value.newObjectTagging = try reader["NewObjectTagging"].readListIfPresent(memberReadingClosure: S3ControlClientTypes.S3Tag.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.redirectLocation = try reader["RedirectLocation"].readIfPresent()
            value.requesterPays = try reader["RequesterPays"].readIfPresent() ?? false
            value.storageClass = try reader["StorageClass"].readIfPresent()
            value.unModifiedSinceConstraint = try reader["UnModifiedSinceConstraint"].readTimestampIfPresent(format: .dateTime)
            value.sseAwsKmsKeyId = try reader["SSEAwsKmsKeyId"].readIfPresent()
            value.targetKeyPrefix = try reader["TargetKeyPrefix"].readIfPresent()
            value.objectLockLegalHoldStatus = try reader["ObjectLockLegalHoldStatus"].readIfPresent()
            value.objectLockMode = try reader["ObjectLockMode"].readIfPresent()
            value.objectLockRetainUntilDate = try reader["ObjectLockRetainUntilDate"].readTimestampIfPresent(format: .dateTime)
            value.bucketKeyEnabled = try reader["BucketKeyEnabled"].readIfPresent() ?? false
            value.checksumAlgorithm = try reader["ChecksumAlgorithm"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// Contains the configuration parameters for a PUT Copy object operation. S3 Batch Operations passes every object to the underlying CopyObject API operation. For more information about the parameters for this operation, see [CopyObject](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectCOPY.html).
    public struct S3CopyObjectOperation: Swift.Equatable {
        /// This functionality is not supported by directory buckets.
        public var accessControlGrants: [S3ControlClientTypes.S3Grant]?
        /// Specifies whether Amazon S3 should use an S3 Bucket Key for object encryption with server-side encryption using Amazon Web Services KMS (SSE-KMS). Setting this header to true causes Amazon S3 to use an S3 Bucket Key for object encryption with SSE-KMS. Specifying this header with an object action doesn’t affect bucket-level settings for S3 Bucket Key. This functionality is not supported by directory buckets.
        public var bucketKeyEnabled: Swift.Bool
        /// This functionality is not supported by directory buckets.
        public var cannedAccessControlList: S3ControlClientTypes.S3CannedAccessControlList?
        /// Indicates the algorithm that you want Amazon S3 to use to create the checksum. For more information, see [ Checking object integrity](https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html) in the Amazon S3 User Guide.
        public var checksumAlgorithm: S3ControlClientTypes.S3ChecksumAlgorithm?
        ///
        public var metadataDirective: S3ControlClientTypes.S3MetadataDirective?
        ///
        public var modifiedSinceConstraint: ClientRuntime.Date?
        /// If you don't provide this parameter, Amazon S3 copies all the metadata from the original objects. If you specify an empty set, the new objects will have no tags. Otherwise, Amazon S3 assigns the supplied tags to the new objects.
        public var newObjectMetadata: S3ControlClientTypes.S3ObjectMetadata?
        /// Specifies a list of tags to add to the destination objects after they are copied. If NewObjectTagging is not specified, the tags of the source objects are copied to destination objects by default. Directory buckets - Tags aren't supported by directory buckets. If your source objects have tags and your destination bucket is a directory bucket, specify an empty tag set in the NewObjectTagging field to prevent copying the source object tags to the directory bucket.
        public var newObjectTagging: [S3ControlClientTypes.S3Tag]?
        /// The legal hold status to be applied to all objects in the Batch Operations job. This functionality is not supported by directory buckets.
        public var objectLockLegalHoldStatus: S3ControlClientTypes.S3ObjectLockLegalHoldStatus?
        /// The retention mode to be applied to all objects in the Batch Operations job. This functionality is not supported by directory buckets.
        public var objectLockMode: S3ControlClientTypes.S3ObjectLockMode?
        /// The date when the applied object retention configuration expires on all objects in the Batch Operations job. This functionality is not supported by directory buckets.
        public var objectLockRetainUntilDate: ClientRuntime.Date?
        /// If the destination bucket is configured as a website, specifies an optional metadata property for website redirects, x-amz-website-redirect-location. Allows webpage redirects if the object copy is accessed through a website endpoint. This functionality is not supported by directory buckets.
        public var redirectLocation: Swift.String?
        /// This functionality is not supported by directory buckets.
        public var requesterPays: Swift.Bool
        /// This functionality is not supported by directory buckets.
        public var sseAwsKmsKeyId: Swift.String?
        /// Specify the storage class for the destination objects in a Copy operation. Directory buckets - This functionality is not supported by directory buckets.
        public var storageClass: S3ControlClientTypes.S3StorageClass?
        /// Specifies the folder prefix that you want the objects to be copied into. For example, to copy objects into a folder named Folder1 in the destination bucket, set the TargetKeyPrefix property to Folder1.
        public var targetKeyPrefix: Swift.String?
        /// Specifies the destination bucket Amazon Resource Name (ARN) for the batch copy operation.
        ///
        /// * General purpose buckets - For example, to copy objects to a general purpose bucket named destinationBucket, set the TargetResource property to arn:aws:s3:::destinationBucket.
        ///
        /// * Directory buckets - For example, to copy objects to a directory bucket named destinationBucket in the Availability Zone; identified by the AZ ID usw2-az2, set the TargetResource property to arn:aws:s3express:region:account_id:/bucket/destination_bucket_base_name--usw2-az2--x-s3.
        public var targetResource: Swift.String?
        ///
        public var unModifiedSinceConstraint: ClientRuntime.Date?

        public init(
            accessControlGrants: [S3ControlClientTypes.S3Grant]? = nil,
            bucketKeyEnabled: Swift.Bool = false,
            cannedAccessControlList: S3ControlClientTypes.S3CannedAccessControlList? = nil,
            checksumAlgorithm: S3ControlClientTypes.S3ChecksumAlgorithm? = nil,
            metadataDirective: S3ControlClientTypes.S3MetadataDirective? = nil,
            modifiedSinceConstraint: ClientRuntime.Date? = nil,
            newObjectMetadata: S3ControlClientTypes.S3ObjectMetadata? = nil,
            newObjectTagging: [S3ControlClientTypes.S3Tag]? = nil,
            objectLockLegalHoldStatus: S3ControlClientTypes.S3ObjectLockLegalHoldStatus? = nil,
            objectLockMode: S3ControlClientTypes.S3ObjectLockMode? = nil,
            objectLockRetainUntilDate: ClientRuntime.Date? = nil,
            redirectLocation: Swift.String? = nil,
            requesterPays: Swift.Bool = false,
            sseAwsKmsKeyId: Swift.String? = nil,
            storageClass: S3ControlClientTypes.S3StorageClass? = nil,
            targetKeyPrefix: Swift.String? = nil,
            targetResource: Swift.String? = nil,
            unModifiedSinceConstraint: ClientRuntime.Date? = nil
        )
        {
            self.accessControlGrants = accessControlGrants
            self.bucketKeyEnabled = bucketKeyEnabled
            self.cannedAccessControlList = cannedAccessControlList
            self.checksumAlgorithm = checksumAlgorithm
            self.metadataDirective = metadataDirective
            self.modifiedSinceConstraint = modifiedSinceConstraint
            self.newObjectMetadata = newObjectMetadata
            self.newObjectTagging = newObjectTagging
            self.objectLockLegalHoldStatus = objectLockLegalHoldStatus
            self.objectLockMode = objectLockMode
            self.objectLockRetainUntilDate = objectLockRetainUntilDate
            self.redirectLocation = redirectLocation
            self.requesterPays = requesterPays
            self.sseAwsKmsKeyId = sseAwsKmsKeyId
            self.storageClass = storageClass
            self.targetKeyPrefix = targetKeyPrefix
            self.targetResource = targetResource
            self.unModifiedSinceConstraint = unModifiedSinceConstraint
        }
    }

}

extension S3ControlClientTypes.S3DeleteObjectTaggingOperation {

    static func writingClosure(_ value: S3ControlClientTypes.S3DeleteObjectTaggingOperation?, to writer: SmithyXML.Writer) throws {
        guard value != nil else { writer.detach(); return }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.S3DeleteObjectTaggingOperation, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            return S3ControlClientTypes.S3DeleteObjectTaggingOperation()
        }
    }
}

extension S3ControlClientTypes {
    /// Contains no configuration parameters because the DELETE Object tagging (DeleteObjectTagging) API operation accepts only the bucket name and key name as parameters, which are defined in the job's manifest.
    public struct S3DeleteObjectTaggingOperation: Swift.Equatable {

        public init() { }
    }

}

extension S3ControlClientTypes.S3GeneratedManifestDescriptor {

    static func writingClosure(_ value: S3ControlClientTypes.S3GeneratedManifestDescriptor?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Format"].write(value.format)
        try writer["Location"].write(value.location, writingClosure: S3ControlClientTypes.JobManifestLocation.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.S3GeneratedManifestDescriptor, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.S3GeneratedManifestDescriptor()
            value.format = try reader["Format"].readIfPresent()
            value.location = try reader["Location"].readIfPresent(readingClosure: S3ControlClientTypes.JobManifestLocation.readingClosure)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// Describes the specified job's generated manifest. Batch Operations jobs created with a ManifestGenerator populate details of this descriptor after execution of the ManifestGenerator.
    public struct S3GeneratedManifestDescriptor: Swift.Equatable {
        /// The format of the generated manifest.
        public var format: S3ControlClientTypes.GeneratedManifestFormat?
        /// Contains the information required to locate a manifest object. Manifests can't be imported from directory buckets. For more information, see [Directory buckets](https://docs.aws.amazon.com/AmazonS3/latest/userguide/directory-buckets-overview.html).
        public var location: S3ControlClientTypes.JobManifestLocation?

        public init(
            format: S3ControlClientTypes.GeneratedManifestFormat? = nil,
            location: S3ControlClientTypes.JobManifestLocation? = nil
        )
        {
            self.format = format
            self.location = location
        }
    }

}

extension S3ControlClientTypes {
    public enum S3GlacierJobTier: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bulk
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [S3GlacierJobTier] {
            return [
                .bulk,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bulk: return "BULK"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3GlacierJobTier(rawValue: rawValue) ?? S3GlacierJobTier.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.S3Grant {

    static func writingClosure(_ value: S3ControlClientTypes.S3Grant?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Grantee"].write(value.grantee, writingClosure: S3ControlClientTypes.S3Grantee.writingClosure(_:to:))
        try writer["Permission"].write(value.permission)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.S3Grant, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.S3Grant()
            value.grantee = try reader["Grantee"].readIfPresent(readingClosure: S3ControlClientTypes.S3Grantee.readingClosure)
            value.permission = try reader["Permission"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    ///
    public struct S3Grant: Swift.Equatable {
        ///
        public var grantee: S3ControlClientTypes.S3Grantee?
        ///
        public var permission: S3ControlClientTypes.S3Permission?

        public init(
            grantee: S3ControlClientTypes.S3Grantee? = nil,
            permission: S3ControlClientTypes.S3Permission? = nil
        )
        {
            self.grantee = grantee
            self.permission = permission
        }
    }

}

extension S3ControlClientTypes.S3Grantee {

    static func writingClosure(_ value: S3ControlClientTypes.S3Grantee?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["DisplayName"].write(value.displayName)
        try writer["Identifier"].write(value.identifier)
        try writer["TypeIdentifier"].write(value.typeIdentifier)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.S3Grantee, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.S3Grantee()
            value.typeIdentifier = try reader["TypeIdentifier"].readIfPresent()
            value.identifier = try reader["Identifier"].readIfPresent()
            value.displayName = try reader["DisplayName"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    ///
    public struct S3Grantee: Swift.Equatable {
        ///
        public var displayName: Swift.String?
        ///
        public var identifier: Swift.String?
        ///
        public var typeIdentifier: S3ControlClientTypes.S3GranteeTypeIdentifier?

        public init(
            displayName: Swift.String? = nil,
            identifier: Swift.String? = nil,
            typeIdentifier: S3ControlClientTypes.S3GranteeTypeIdentifier? = nil
        )
        {
            self.displayName = displayName
            self.identifier = identifier
            self.typeIdentifier = typeIdentifier
        }
    }

}

extension S3ControlClientTypes {
    public enum S3GranteeTypeIdentifier: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canonical
        case emailAddress
        case group
        case sdkUnknown(Swift.String)

        public static var allCases: [S3GranteeTypeIdentifier] {
            return [
                .canonical,
                .emailAddress,
                .group,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canonical: return "id"
            case .emailAddress: return "emailAddress"
            case .group: return "uri"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3GranteeTypeIdentifier(rawValue: rawValue) ?? S3GranteeTypeIdentifier.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.S3InitiateRestoreObjectOperation {

    static func writingClosure(_ value: S3ControlClientTypes.S3InitiateRestoreObjectOperation?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ExpirationInDays"].write(value.expirationInDays)
        try writer["GlacierJobTier"].write(value.glacierJobTier)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.S3InitiateRestoreObjectOperation, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.S3InitiateRestoreObjectOperation()
            value.expirationInDays = try reader["ExpirationInDays"].readIfPresent()
            value.glacierJobTier = try reader["GlacierJobTier"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// Contains the configuration parameters for a POST Object restore job. S3 Batch Operations passes every object to the underlying RestoreObject API operation. For more information about the parameters for this operation, see [RestoreObject](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectPOSTrestore.html#RESTObjectPOSTrestore-restore-request).
    public struct S3InitiateRestoreObjectOperation: Swift.Equatable {
        /// This argument specifies how long the S3 Glacier or S3 Glacier Deep Archive object remains available in Amazon S3. S3 Initiate Restore Object jobs that target S3 Glacier and S3 Glacier Deep Archive objects require ExpirationInDays set to 1 or greater. Conversely, do not set ExpirationInDays when creating S3 Initiate Restore Object jobs that target S3 Intelligent-Tiering Archive Access and Deep Archive Access tier objects. Objects in S3 Intelligent-Tiering archive access tiers are not subject to restore expiry, so specifying ExpirationInDays results in restore request failure. S3 Batch Operations jobs can operate either on S3 Glacier and S3 Glacier Deep Archive storage class objects or on S3 Intelligent-Tiering Archive Access and Deep Archive Access storage tier objects, but not both types in the same job. If you need to restore objects of both types you must create separate Batch Operations jobs.
        public var expirationInDays: Swift.Int?
        /// S3 Batch Operations supports STANDARD and BULK retrieval tiers, but not the EXPEDITED retrieval tier.
        public var glacierJobTier: S3ControlClientTypes.S3GlacierJobTier?

        public init(
            expirationInDays: Swift.Int? = nil,
            glacierJobTier: S3ControlClientTypes.S3GlacierJobTier? = nil
        )
        {
            self.expirationInDays = expirationInDays
            self.glacierJobTier = glacierJobTier
        }
    }

}

extension S3ControlClientTypes.S3JobManifestGenerator {

    static func writingClosure(_ value: S3ControlClientTypes.S3JobManifestGenerator?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["EnableManifestOutput"].write(value.enableManifestOutput)
        try writer["ExpectedBucketOwner"].write(value.expectedBucketOwner)
        try writer["Filter"].write(value.filter, writingClosure: S3ControlClientTypes.JobManifestGeneratorFilter.writingClosure(_:to:))
        try writer["ManifestOutputLocation"].write(value.manifestOutputLocation, writingClosure: S3ControlClientTypes.S3ManifestOutputLocation.writingClosure(_:to:))
        try writer["SourceBucket"].write(value.sourceBucket)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.S3JobManifestGenerator, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.S3JobManifestGenerator()
            value.expectedBucketOwner = try reader["ExpectedBucketOwner"].readIfPresent()
            value.sourceBucket = try reader["SourceBucket"].readIfPresent()
            value.manifestOutputLocation = try reader["ManifestOutputLocation"].readIfPresent(readingClosure: S3ControlClientTypes.S3ManifestOutputLocation.readingClosure)
            value.filter = try reader["Filter"].readIfPresent(readingClosure: S3ControlClientTypes.JobManifestGeneratorFilter.readingClosure)
            value.enableManifestOutput = try reader["EnableManifestOutput"].readIfPresent() ?? false
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// The container for the service that will create the S3 manifest.
    public struct S3JobManifestGenerator: Swift.Equatable {
        /// Determines whether or not to write the job's generated manifest to a bucket.
        /// This member is required.
        public var enableManifestOutput: Swift.Bool
        /// The Amazon Web Services account ID that owns the bucket the generated manifest is written to. If provided the generated manifest bucket's owner Amazon Web Services account ID must match this value, else the job fails.
        public var expectedBucketOwner: Swift.String?
        /// Specifies rules the S3JobManifestGenerator should use to decide whether an object in the source bucket should or should not be included in the generated job manifest.
        public var filter: S3ControlClientTypes.JobManifestGeneratorFilter?
        /// Specifies the location the generated manifest will be written to. Manifests can't be written to directory buckets. For more information, see [Directory buckets](https://docs.aws.amazon.com/AmazonS3/latest/userguide/directory-buckets-overview.html).
        public var manifestOutputLocation: S3ControlClientTypes.S3ManifestOutputLocation?
        /// The source bucket used by the ManifestGenerator. Directory buckets - Directory buckets aren't supported as the source buckets used by S3JobManifestGenerator to generate the job manifest.
        /// This member is required.
        public var sourceBucket: Swift.String?

        public init(
            enableManifestOutput: Swift.Bool = false,
            expectedBucketOwner: Swift.String? = nil,
            filter: S3ControlClientTypes.JobManifestGeneratorFilter? = nil,
            manifestOutputLocation: S3ControlClientTypes.S3ManifestOutputLocation? = nil,
            sourceBucket: Swift.String? = nil
        )
        {
            self.enableManifestOutput = enableManifestOutput
            self.expectedBucketOwner = expectedBucketOwner
            self.filter = filter
            self.manifestOutputLocation = manifestOutputLocation
            self.sourceBucket = sourceBucket
        }
    }

}

extension S3ControlClientTypes.S3ManifestOutputLocation {

    static func writingClosure(_ value: S3ControlClientTypes.S3ManifestOutputLocation?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Bucket"].write(value.bucket)
        try writer["ExpectedManifestBucketOwner"].write(value.expectedManifestBucketOwner)
        try writer["ManifestEncryption"].write(value.manifestEncryption, writingClosure: S3ControlClientTypes.GeneratedManifestEncryption.writingClosure(_:to:))
        try writer["ManifestFormat"].write(value.manifestFormat)
        try writer["ManifestPrefix"].write(value.manifestPrefix)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.S3ManifestOutputLocation, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.S3ManifestOutputLocation()
            value.expectedManifestBucketOwner = try reader["ExpectedManifestBucketOwner"].readIfPresent()
            value.bucket = try reader["Bucket"].readIfPresent()
            value.manifestPrefix = try reader["ManifestPrefix"].readIfPresent()
            value.manifestEncryption = try reader["ManifestEncryption"].readIfPresent(readingClosure: S3ControlClientTypes.GeneratedManifestEncryption.readingClosure)
            value.manifestFormat = try reader["ManifestFormat"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// Location details for where the generated manifest should be written.
    public struct S3ManifestOutputLocation: Swift.Equatable {
        /// The bucket ARN the generated manifest should be written to. Directory buckets - Directory buckets aren't supported as the buckets to store the generated manifest.
        /// This member is required.
        public var bucket: Swift.String?
        /// The Account ID that owns the bucket the generated manifest is written to.
        public var expectedManifestBucketOwner: Swift.String?
        /// Specifies what encryption should be used when the generated manifest objects are written.
        public var manifestEncryption: S3ControlClientTypes.GeneratedManifestEncryption?
        /// The format of the generated manifest.
        /// This member is required.
        public var manifestFormat: S3ControlClientTypes.GeneratedManifestFormat?
        /// Prefix identifying one or more objects to which the manifest applies.
        public var manifestPrefix: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            expectedManifestBucketOwner: Swift.String? = nil,
            manifestEncryption: S3ControlClientTypes.GeneratedManifestEncryption? = nil,
            manifestFormat: S3ControlClientTypes.GeneratedManifestFormat? = nil,
            manifestPrefix: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.expectedManifestBucketOwner = expectedManifestBucketOwner
            self.manifestEncryption = manifestEncryption
            self.manifestFormat = manifestFormat
            self.manifestPrefix = manifestPrefix
        }
    }

}

extension S3ControlClientTypes {
    public enum S3MetadataDirective: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case copy
        case replace
        case sdkUnknown(Swift.String)

        public static var allCases: [S3MetadataDirective] {
            return [
                .copy,
                .replace,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .copy: return "COPY"
            case .replace: return "REPLACE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3MetadataDirective(rawValue: rawValue) ?? S3MetadataDirective.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.S3ObjectLockLegalHold {

    static func writingClosure(_ value: S3ControlClientTypes.S3ObjectLockLegalHold?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Status"].write(value.status)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.S3ObjectLockLegalHold, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.S3ObjectLockLegalHold()
            value.status = try reader["Status"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// Whether S3 Object Lock legal hold will be applied to objects in an S3 Batch Operations job.
    public struct S3ObjectLockLegalHold: Swift.Equatable {
        /// The Object Lock legal hold status to be applied to all objects in the Batch Operations job.
        /// This member is required.
        public var status: S3ControlClientTypes.S3ObjectLockLegalHoldStatus?

        public init(
            status: S3ControlClientTypes.S3ObjectLockLegalHoldStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension S3ControlClientTypes {
    public enum S3ObjectLockLegalHoldStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case off
        case on
        case sdkUnknown(Swift.String)

        public static var allCases: [S3ObjectLockLegalHoldStatus] {
            return [
                .off,
                .on,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .off: return "OFF"
            case .on: return "ON"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3ObjectLockLegalHoldStatus(rawValue: rawValue) ?? S3ObjectLockLegalHoldStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum S3ObjectLockMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case compliance
        case governance
        case sdkUnknown(Swift.String)

        public static var allCases: [S3ObjectLockMode] {
            return [
                .compliance,
                .governance,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .compliance: return "COMPLIANCE"
            case .governance: return "GOVERNANCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3ObjectLockMode(rawValue: rawValue) ?? S3ObjectLockMode.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum S3ObjectLockRetentionMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case compliance
        case governance
        case sdkUnknown(Swift.String)

        public static var allCases: [S3ObjectLockRetentionMode] {
            return [
                .compliance,
                .governance,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .compliance: return "COMPLIANCE"
            case .governance: return "GOVERNANCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3ObjectLockRetentionMode(rawValue: rawValue) ?? S3ObjectLockRetentionMode.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.S3ObjectMetadata {

    static func writingClosure(_ value: S3ControlClientTypes.S3ObjectMetadata?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["CacheControl"].write(value.cacheControl)
        try writer["ContentDisposition"].write(value.contentDisposition)
        try writer["ContentEncoding"].write(value.contentEncoding)
        try writer["ContentLanguage"].write(value.contentLanguage)
        try writer["ContentLength"].write(value.contentLength)
        try writer["ContentMD5"].write(value.contentMD5)
        try writer["ContentType"].write(value.contentType)
        try writer["HttpExpiresDate"].writeTimestamp(value.httpExpiresDate, format: .dateTime)
        try writer["RequesterCharged"].write(value.requesterCharged)
        try writer["SSEAlgorithm"].write(value.sseAlgorithm)
        try writer["UserMetadata"].writeMap(value.userMetadata, valueWritingClosure: Swift.String.writingClosure(_:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.S3ObjectMetadata, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.S3ObjectMetadata()
            value.cacheControl = try reader["CacheControl"].readIfPresent()
            value.contentDisposition = try reader["ContentDisposition"].readIfPresent()
            value.contentEncoding = try reader["ContentEncoding"].readIfPresent()
            value.contentLanguage = try reader["ContentLanguage"].readIfPresent()
            value.userMetadata = try reader["UserMetadata"].readMapIfPresent(valueReadingClosure: Swift.String.readingClosure, keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
            value.contentLength = try reader["ContentLength"].readIfPresent()
            value.contentMD5 = try reader["ContentMD5"].readIfPresent()
            value.contentType = try reader["ContentType"].readIfPresent()
            value.httpExpiresDate = try reader["HttpExpiresDate"].readTimestampIfPresent(format: .dateTime)
            value.requesterCharged = try reader["RequesterCharged"].readIfPresent() ?? false
            value.sseAlgorithm = try reader["SSEAlgorithm"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    ///
    public struct S3ObjectMetadata: Swift.Equatable {
        ///
        public var cacheControl: Swift.String?
        ///
        public var contentDisposition: Swift.String?
        ///
        public var contentEncoding: Swift.String?
        ///
        public var contentLanguage: Swift.String?
        /// This member has been deprecated.
        public var contentLength: Swift.Int?
        /// This member has been deprecated.
        public var contentMD5: Swift.String?
        ///
        public var contentType: Swift.String?
        ///
        public var httpExpiresDate: ClientRuntime.Date?
        /// This member has been deprecated.
        public var requesterCharged: Swift.Bool
        /// For directory buckets, only the server-side encryption with Amazon S3 managed keys (SSE-S3) (AES256) is supported.
        public var sseAlgorithm: S3ControlClientTypes.S3SSEAlgorithm?
        ///
        public var userMetadata: [Swift.String:Swift.String]?

        public init(
            cacheControl: Swift.String? = nil,
            contentDisposition: Swift.String? = nil,
            contentEncoding: Swift.String? = nil,
            contentLanguage: Swift.String? = nil,
            contentLength: Swift.Int? = nil,
            contentMD5: Swift.String? = nil,
            contentType: Swift.String? = nil,
            httpExpiresDate: ClientRuntime.Date? = nil,
            requesterCharged: Swift.Bool = false,
            sseAlgorithm: S3ControlClientTypes.S3SSEAlgorithm? = nil,
            userMetadata: [Swift.String:Swift.String]? = nil
        )
        {
            self.cacheControl = cacheControl
            self.contentDisposition = contentDisposition
            self.contentEncoding = contentEncoding
            self.contentLanguage = contentLanguage
            self.contentLength = contentLength
            self.contentMD5 = contentMD5
            self.contentType = contentType
            self.httpExpiresDate = httpExpiresDate
            self.requesterCharged = requesterCharged
            self.sseAlgorithm = sseAlgorithm
            self.userMetadata = userMetadata
        }
    }

}

extension S3ControlClientTypes.S3ObjectOwner {

    static func writingClosure(_ value: S3ControlClientTypes.S3ObjectOwner?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["DisplayName"].write(value.displayName)
        try writer["ID"].write(value.id)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.S3ObjectOwner, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.S3ObjectOwner()
            value.id = try reader["ID"].readIfPresent()
            value.displayName = try reader["DisplayName"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    ///
    public struct S3ObjectOwner: Swift.Equatable {
        ///
        public var displayName: Swift.String?
        ///
        public var id: Swift.String?

        public init(
            displayName: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.displayName = displayName
            self.id = id
        }
    }

}

extension S3ControlClientTypes {
    public enum S3Permission: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fullControl
        case read
        case readAcp
        case write
        case writeAcp
        case sdkUnknown(Swift.String)

        public static var allCases: [S3Permission] {
            return [
                .fullControl,
                .read,
                .readAcp,
                .write,
                .writeAcp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fullControl: return "FULL_CONTROL"
            case .read: return "READ"
            case .readAcp: return "READ_ACP"
            case .write: return "WRITE"
            case .writeAcp: return "WRITE_ACP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3Permission(rawValue: rawValue) ?? S3Permission.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum S3PrefixType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case object
        case sdkUnknown(Swift.String)

        public static var allCases: [S3PrefixType] {
            return [
                .object,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .object: return "Object"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3PrefixType(rawValue: rawValue) ?? S3PrefixType.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.S3ReplicateObjectOperation {

    static func writingClosure(_ value: S3ControlClientTypes.S3ReplicateObjectOperation?, to writer: SmithyXML.Writer) throws {
        guard value != nil else { writer.detach(); return }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.S3ReplicateObjectOperation, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            return S3ControlClientTypes.S3ReplicateObjectOperation()
        }
    }
}

extension S3ControlClientTypes {
    /// Directs the specified job to invoke ReplicateObject on every object in the job's manifest.
    public struct S3ReplicateObjectOperation: Swift.Equatable {

        public init() { }
    }

}

extension S3ControlClientTypes.S3Retention {

    static func writingClosure(_ value: S3ControlClientTypes.S3Retention?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Mode"].write(value.mode)
        try writer["RetainUntilDate"].writeTimestamp(value.retainUntilDate, format: .dateTime)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.S3Retention, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.S3Retention()
            value.retainUntilDate = try reader["RetainUntilDate"].readTimestampIfPresent(format: .dateTime)
            value.mode = try reader["Mode"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// Contains the S3 Object Lock retention mode to be applied to all objects in the S3 Batch Operations job. If you don't provide Mode and RetainUntilDate data types in your operation, you will remove the retention from your objects. For more information, see [Using S3 Object Lock retention with S3 Batch Operations](https://docs.aws.amazon.com/AmazonS3/latest/dev/batch-ops-retention-date.html) in the Amazon S3 User Guide.
    public struct S3Retention: Swift.Equatable {
        /// The Object Lock retention mode to be applied to all objects in the Batch Operations job.
        public var mode: S3ControlClientTypes.S3ObjectLockRetentionMode?
        /// The date when the applied Object Lock retention will expire on all objects set by the Batch Operations job.
        public var retainUntilDate: ClientRuntime.Date?

        public init(
            mode: S3ControlClientTypes.S3ObjectLockRetentionMode? = nil,
            retainUntilDate: ClientRuntime.Date? = nil
        )
        {
            self.mode = mode
            self.retainUntilDate = retainUntilDate
        }
    }

}

extension S3ControlClientTypes {
    public enum S3SSEAlgorithm: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aes256
        case kms
        case sdkUnknown(Swift.String)

        public static var allCases: [S3SSEAlgorithm] {
            return [
                .aes256,
                .kms,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aes256: return "AES256"
            case .kms: return "KMS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3SSEAlgorithm(rawValue: rawValue) ?? S3SSEAlgorithm.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.S3SetObjectAclOperation {

    static func writingClosure(_ value: S3ControlClientTypes.S3SetObjectAclOperation?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["AccessControlPolicy"].write(value.accessControlPolicy, writingClosure: S3ControlClientTypes.S3AccessControlPolicy.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.S3SetObjectAclOperation, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.S3SetObjectAclOperation()
            value.accessControlPolicy = try reader["AccessControlPolicy"].readIfPresent(readingClosure: S3ControlClientTypes.S3AccessControlPolicy.readingClosure)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// Contains the configuration parameters for a PUT Object ACL operation. S3 Batch Operations passes every object to the underlying PutObjectAcl API operation. For more information about the parameters for this operation, see [PutObjectAcl](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectPUTacl.html).
    public struct S3SetObjectAclOperation: Swift.Equatable {
        ///
        public var accessControlPolicy: S3ControlClientTypes.S3AccessControlPolicy?

        public init(
            accessControlPolicy: S3ControlClientTypes.S3AccessControlPolicy? = nil
        )
        {
            self.accessControlPolicy = accessControlPolicy
        }
    }

}

extension S3ControlClientTypes.S3SetObjectLegalHoldOperation {

    static func writingClosure(_ value: S3ControlClientTypes.S3SetObjectLegalHoldOperation?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["LegalHold"].write(value.legalHold, writingClosure: S3ControlClientTypes.S3ObjectLockLegalHold.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.S3SetObjectLegalHoldOperation, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.S3SetObjectLegalHoldOperation()
            value.legalHold = try reader["LegalHold"].readIfPresent(readingClosure: S3ControlClientTypes.S3ObjectLockLegalHold.readingClosure)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// Contains the configuration for an S3 Object Lock legal hold operation that an S3 Batch Operations job passes to every object to the underlying PutObjectLegalHold API operation. For more information, see [Using S3 Object Lock legal hold with S3 Batch Operations](https://docs.aws.amazon.com/AmazonS3/latest/dev/batch-ops-legal-hold.html) in the Amazon S3 User Guide. This functionality is not supported by directory buckets.
    public struct S3SetObjectLegalHoldOperation: Swift.Equatable {
        /// Contains the Object Lock legal hold status to be applied to all objects in the Batch Operations job.
        /// This member is required.
        public var legalHold: S3ControlClientTypes.S3ObjectLockLegalHold?

        public init(
            legalHold: S3ControlClientTypes.S3ObjectLockLegalHold? = nil
        )
        {
            self.legalHold = legalHold
        }
    }

}

extension S3ControlClientTypes.S3SetObjectRetentionOperation {

    static func writingClosure(_ value: S3ControlClientTypes.S3SetObjectRetentionOperation?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["BypassGovernanceRetention"].write(value.bypassGovernanceRetention)
        try writer["Retention"].write(value.retention, writingClosure: S3ControlClientTypes.S3Retention.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.S3SetObjectRetentionOperation, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.S3SetObjectRetentionOperation()
            value.bypassGovernanceRetention = try reader["BypassGovernanceRetention"].readIfPresent()
            value.retention = try reader["Retention"].readIfPresent(readingClosure: S3ControlClientTypes.S3Retention.readingClosure)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// Contains the configuration parameters for the Object Lock retention action for an S3 Batch Operations job. Batch Operations passes every object to the underlying PutObjectRetention API operation. For more information, see [Using S3 Object Lock retention with S3 Batch Operations](https://docs.aws.amazon.com/AmazonS3/latest/dev/batch-ops-retention-date.html) in the Amazon S3 User Guide. This functionality is not supported by directory buckets.
    public struct S3SetObjectRetentionOperation: Swift.Equatable {
        /// Indicates if the action should be applied to objects in the Batch Operations job even if they have Object Lock  GOVERNANCE type in place.
        public var bypassGovernanceRetention: Swift.Bool?
        /// Contains the Object Lock retention mode to be applied to all objects in the Batch Operations job. For more information, see [Using S3 Object Lock retention with S3 Batch Operations](https://docs.aws.amazon.com/AmazonS3/latest/dev/batch-ops-retention-date.html) in the Amazon S3 User Guide.
        /// This member is required.
        public var retention: S3ControlClientTypes.S3Retention?

        public init(
            bypassGovernanceRetention: Swift.Bool? = nil,
            retention: S3ControlClientTypes.S3Retention? = nil
        )
        {
            self.bypassGovernanceRetention = bypassGovernanceRetention
            self.retention = retention
        }
    }

}

extension S3ControlClientTypes.S3SetObjectTaggingOperation {

    static func writingClosure(_ value: S3ControlClientTypes.S3SetObjectTaggingOperation?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["TagSet"].writeList(value.tagSet, memberWritingClosure: S3ControlClientTypes.S3Tag.writingClosure(_:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.S3SetObjectTaggingOperation, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.S3SetObjectTaggingOperation()
            value.tagSet = try reader["TagSet"].readListIfPresent(memberReadingClosure: S3ControlClientTypes.S3Tag.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// Contains the configuration parameters for a PUT Object Tagging operation. S3 Batch Operations passes every object to the underlying PutObjectTagging API operation. For more information about the parameters for this operation, see [PutObjectTagging](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectPUTtagging.html).
    public struct S3SetObjectTaggingOperation: Swift.Equatable {
        ///
        public var tagSet: [S3ControlClientTypes.S3Tag]?

        public init(
            tagSet: [S3ControlClientTypes.S3Tag]? = nil
        )
        {
            self.tagSet = tagSet
        }
    }

}

extension S3ControlClientTypes {
    public enum S3StorageClass: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deepArchive
        case glacier
        case glacierIr
        case intelligentTiering
        case onezoneIa
        case standard
        case standardIa
        case sdkUnknown(Swift.String)

        public static var allCases: [S3StorageClass] {
            return [
                .deepArchive,
                .glacier,
                .glacierIr,
                .intelligentTiering,
                .onezoneIa,
                .standard,
                .standardIa,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deepArchive: return "DEEP_ARCHIVE"
            case .glacier: return "GLACIER"
            case .glacierIr: return "GLACIER_IR"
            case .intelligentTiering: return "INTELLIGENT_TIERING"
            case .onezoneIa: return "ONEZONE_IA"
            case .standard: return "STANDARD"
            case .standardIa: return "STANDARD_IA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3StorageClass(rawValue: rawValue) ?? S3StorageClass.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.S3Tag {

    static func writingClosure(_ value: S3ControlClientTypes.S3Tag?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.S3Tag, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.S3Tag()
            value.key = try reader["Key"].readIfPresent()
            value.value = try reader["Value"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// A container for a key-value name pair.
    public struct S3Tag: Swift.Equatable {
        /// Key of the tag
        /// This member is required.
        public var key: Swift.String?
        /// Value of the tag
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension S3ControlClientTypes.SSEKMS {

    static func writingClosure(_ value: S3ControlClientTypes.SSEKMS?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["KeyId"].write(value.keyId)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.SSEKMS, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.SSEKMS()
            value.keyId = try reader["KeyId"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    ///
    public struct SSEKMS: Swift.Equatable {
        /// A container for the ARN of the SSE-KMS encryption. This property is read-only and follows the following format:  arn:aws:kms:us-east-1:example-account-id:key/example-9a73-4afc-8d29-8f5900cef44e
        /// This member is required.
        public var keyId: Swift.String?

        public init(
            keyId: Swift.String? = nil
        )
        {
            self.keyId = keyId
        }
    }

}

extension S3ControlClientTypes.SSEKMSEncryption {

    static func writingClosure(_ value: S3ControlClientTypes.SSEKMSEncryption?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["KeyId"].write(value.keyId)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.SSEKMSEncryption, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.SSEKMSEncryption()
            value.keyId = try reader["KeyId"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// Configuration for the use of SSE-KMS to encrypt generated manifest objects.
    public struct SSEKMSEncryption: Swift.Equatable {
        /// Specifies the ID of the Amazon Web Services Key Management Service (Amazon Web Services KMS) symmetric encryption customer managed key to use for encrypting generated manifest objects.
        /// This member is required.
        public var keyId: Swift.String?

        public init(
            keyId: Swift.String? = nil
        )
        {
            self.keyId = keyId
        }
    }

}

extension S3ControlClientTypes.SSES3 {

    static func writingClosure(_ value: S3ControlClientTypes.SSES3?, to writer: SmithyXML.Writer) throws {
        guard value != nil else { writer.detach(); return }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.SSES3, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            return S3ControlClientTypes.SSES3()
        }
    }
}

extension S3ControlClientTypes {
    ///
    public struct SSES3: Swift.Equatable {

        public init() { }
    }

}

extension S3ControlClientTypes.SSES3Encryption {

    static func writingClosure(_ value: S3ControlClientTypes.SSES3Encryption?, to writer: SmithyXML.Writer) throws {
        guard value != nil else { writer.detach(); return }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.SSES3Encryption, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            return S3ControlClientTypes.SSES3Encryption()
        }
    }
}

extension S3ControlClientTypes {
    /// Configuration for the use of SSE-S3 to encrypt generated manifest objects.
    public struct SSES3Encryption: Swift.Equatable {

        public init() { }
    }

}

extension S3ControlClientTypes.SelectionCriteria {

    static func writingClosure(_ value: S3ControlClientTypes.SelectionCriteria?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Delimiter"].write(value.delimiter)
        try writer["MaxDepth"].write(value.maxDepth)
        try writer["MinStorageBytesPercentage"].write(value.minStorageBytesPercentage)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.SelectionCriteria, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.SelectionCriteria()
            value.delimiter = try reader["Delimiter"].readIfPresent()
            value.maxDepth = try reader["MaxDepth"].readIfPresent()
            value.minStorageBytesPercentage = try reader["MinStorageBytesPercentage"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    ///
    public struct SelectionCriteria: Swift.Equatable {
        /// A container for the delimiter of the selection criteria being used.
        public var delimiter: Swift.String?
        /// The max depth of the selection criteria
        public var maxDepth: Swift.Int?
        /// The minimum number of storage bytes percentage whose metrics will be selected. You must choose a value greater than or equal to 1.0.
        public var minStorageBytesPercentage: Swift.Double?

        public init(
            delimiter: Swift.String? = nil,
            maxDepth: Swift.Int? = nil,
            minStorageBytesPercentage: Swift.Double? = nil
        )
        {
            self.delimiter = delimiter
            self.maxDepth = maxDepth
            self.minStorageBytesPercentage = minStorageBytesPercentage
        }
    }

}

extension S3ControlClientTypes.SourceSelectionCriteria {

    static func writingClosure(_ value: S3ControlClientTypes.SourceSelectionCriteria?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ReplicaModifications"].write(value.replicaModifications, writingClosure: S3ControlClientTypes.ReplicaModifications.writingClosure(_:to:))
        try writer["SseKmsEncryptedObjects"].write(value.sseKmsEncryptedObjects, writingClosure: S3ControlClientTypes.SseKmsEncryptedObjects.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.SourceSelectionCriteria, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.SourceSelectionCriteria()
            value.sseKmsEncryptedObjects = try reader["SseKmsEncryptedObjects"].readIfPresent(readingClosure: S3ControlClientTypes.SseKmsEncryptedObjects.readingClosure)
            value.replicaModifications = try reader["ReplicaModifications"].readIfPresent(readingClosure: S3ControlClientTypes.ReplicaModifications.readingClosure)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// A container that describes additional filters for identifying the source objects that you want to replicate. You can choose to enable or disable the replication of these objects.
    public struct SourceSelectionCriteria: Swift.Equatable {
        /// A filter that you can use to specify whether replica modification sync is enabled. S3 on Outposts replica modification sync can help you keep object metadata synchronized between replicas and source objects. By default, S3 on Outposts replicates metadata from the source objects to the replicas only. When replica modification sync is enabled, S3 on Outposts replicates metadata changes made to the replica copies back to the source object, making the replication bidirectional. To replicate object metadata modifications on replicas, you can specify this element and set the Status of this element to Enabled. You must enable replica modification sync on the source and destination buckets to replicate replica metadata changes between the source and the replicas.
        public var replicaModifications: S3ControlClientTypes.ReplicaModifications?
        /// A filter that you can use to select Amazon S3 objects that are encrypted with server-side encryption by using Key Management Service (KMS) keys. If you include SourceSelectionCriteria in the replication configuration, this element is required. This is not supported by Amazon S3 on Outposts buckets.
        public var sseKmsEncryptedObjects: S3ControlClientTypes.SseKmsEncryptedObjects?

        public init(
            replicaModifications: S3ControlClientTypes.ReplicaModifications? = nil,
            sseKmsEncryptedObjects: S3ControlClientTypes.SseKmsEncryptedObjects? = nil
        )
        {
            self.replicaModifications = replicaModifications
            self.sseKmsEncryptedObjects = sseKmsEncryptedObjects
        }
    }

}

extension S3ControlClientTypes.SseKmsEncryptedObjects {

    static func writingClosure(_ value: S3ControlClientTypes.SseKmsEncryptedObjects?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Status"].write(value.status)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.SseKmsEncryptedObjects, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.SseKmsEncryptedObjects()
            value.status = try reader["Status"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// A container for filter information that you can use to select S3 objects that are encrypted with Key Management Service (KMS). This is not supported by Amazon S3 on Outposts buckets.
    public struct SseKmsEncryptedObjects: Swift.Equatable {
        /// Specifies whether Amazon S3 replicates objects that are created with server-side encryption by using an KMS key stored in Key Management Service.
        /// This member is required.
        public var status: S3ControlClientTypes.SseKmsEncryptedObjectsStatus?

        public init(
            status: S3ControlClientTypes.SseKmsEncryptedObjectsStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension S3ControlClientTypes {
    public enum SseKmsEncryptedObjectsStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [SseKmsEncryptedObjectsStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SseKmsEncryptedObjectsStatus(rawValue: rawValue) ?? SseKmsEncryptedObjectsStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.StorageLensAwsOrg {

    static func writingClosure(_ value: S3ControlClientTypes.StorageLensAwsOrg?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Arn"].write(value.arn)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.StorageLensAwsOrg, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.StorageLensAwsOrg()
            value.arn = try reader["Arn"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// The Amazon Web Services organization for your S3 Storage Lens.
    public struct StorageLensAwsOrg: Swift.Equatable {
        /// A container for the Amazon Resource Name (ARN) of the Amazon Web Services organization. This property is read-only and follows the following format:  arn:aws:organizations:us-east-1:example-account-id:organization/o-ex2l495dck
        /// This member is required.
        public var arn: Swift.String?

        public init(
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension S3ControlClientTypes.StorageLensConfiguration {

    static func writingClosure(_ value: S3ControlClientTypes.StorageLensConfiguration?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["AccountLevel"].write(value.accountLevel, writingClosure: S3ControlClientTypes.AccountLevel.writingClosure(_:to:))
        try writer["AwsOrg"].write(value.awsOrg, writingClosure: S3ControlClientTypes.StorageLensAwsOrg.writingClosure(_:to:))
        try writer["DataExport"].write(value.dataExport, writingClosure: S3ControlClientTypes.StorageLensDataExport.writingClosure(_:to:))
        try writer["Exclude"].write(value.exclude, writingClosure: S3ControlClientTypes.Exclude.writingClosure(_:to:))
        try writer["Id"].write(value.id)
        try writer["Include"].write(value.include, writingClosure: S3ControlClientTypes.Include.writingClosure(_:to:))
        try writer["IsEnabled"].write(value.isEnabled)
        try writer["StorageLensArn"].write(value.storageLensArn)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.StorageLensConfiguration, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.StorageLensConfiguration()
            value.id = try reader["Id"].readIfPresent()
            value.accountLevel = try reader["AccountLevel"].readIfPresent(readingClosure: S3ControlClientTypes.AccountLevel.readingClosure)
            value.include = try reader["Include"].readIfPresent(readingClosure: S3ControlClientTypes.Include.readingClosure)
            value.exclude = try reader["Exclude"].readIfPresent(readingClosure: S3ControlClientTypes.Exclude.readingClosure)
            value.dataExport = try reader["DataExport"].readIfPresent(readingClosure: S3ControlClientTypes.StorageLensDataExport.readingClosure)
            value.isEnabled = try reader["IsEnabled"].readIfPresent() ?? false
            value.awsOrg = try reader["AwsOrg"].readIfPresent(readingClosure: S3ControlClientTypes.StorageLensAwsOrg.readingClosure)
            value.storageLensArn = try reader["StorageLensArn"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// A container for the Amazon S3 Storage Lens configuration.
    public struct StorageLensConfiguration: Swift.Equatable {
        /// A container for all the account-level configurations of your S3 Storage Lens configuration.
        /// This member is required.
        public var accountLevel: S3ControlClientTypes.AccountLevel?
        /// A container for the Amazon Web Services organization for this S3 Storage Lens configuration.
        public var awsOrg: S3ControlClientTypes.StorageLensAwsOrg?
        /// A container to specify the properties of your S3 Storage Lens metrics export including, the destination, schema and format.
        public var dataExport: S3ControlClientTypes.StorageLensDataExport?
        /// A container for what is excluded in this configuration. This container can only be valid if there is no Include container submitted, and it's not empty.
        public var exclude: S3ControlClientTypes.Exclude?
        /// A container for the Amazon S3 Storage Lens configuration ID.
        /// This member is required.
        public var id: Swift.String?
        /// A container for what is included in this configuration. This container can only be valid if there is no Exclude container submitted, and it's not empty.
        public var include: S3ControlClientTypes.Include?
        /// A container for whether the S3 Storage Lens configuration is enabled.
        /// This member is required.
        public var isEnabled: Swift.Bool
        /// The Amazon Resource Name (ARN) of the S3 Storage Lens configuration. This property is read-only and follows the following format:  arn:aws:s3:us-east-1:example-account-id:storage-lens/your-dashboard-name
        public var storageLensArn: Swift.String?

        public init(
            accountLevel: S3ControlClientTypes.AccountLevel? = nil,
            awsOrg: S3ControlClientTypes.StorageLensAwsOrg? = nil,
            dataExport: S3ControlClientTypes.StorageLensDataExport? = nil,
            exclude: S3ControlClientTypes.Exclude? = nil,
            id: Swift.String? = nil,
            include: S3ControlClientTypes.Include? = nil,
            isEnabled: Swift.Bool = false,
            storageLensArn: Swift.String? = nil
        )
        {
            self.accountLevel = accountLevel
            self.awsOrg = awsOrg
            self.dataExport = dataExport
            self.exclude = exclude
            self.id = id
            self.include = include
            self.isEnabled = isEnabled
            self.storageLensArn = storageLensArn
        }
    }

}

extension S3ControlClientTypes.StorageLensDataExport {

    static func writingClosure(_ value: S3ControlClientTypes.StorageLensDataExport?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["CloudWatchMetrics"].write(value.cloudWatchMetrics, writingClosure: S3ControlClientTypes.CloudWatchMetrics.writingClosure(_:to:))
        try writer["S3BucketDestination"].write(value.s3BucketDestination, writingClosure: S3ControlClientTypes.S3BucketDestination.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.StorageLensDataExport, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.StorageLensDataExport()
            value.s3BucketDestination = try reader["S3BucketDestination"].readIfPresent(readingClosure: S3ControlClientTypes.S3BucketDestination.readingClosure)
            value.cloudWatchMetrics = try reader["CloudWatchMetrics"].readIfPresent(readingClosure: S3ControlClientTypes.CloudWatchMetrics.readingClosure)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// A container to specify the properties of your S3 Storage Lens metrics export, including the destination, schema, and format.
    public struct StorageLensDataExport: Swift.Equatable {
        /// A container for enabling Amazon CloudWatch publishing for S3 Storage Lens metrics.
        public var cloudWatchMetrics: S3ControlClientTypes.CloudWatchMetrics?
        /// A container for the bucket where the S3 Storage Lens metrics export will be located. This bucket must be located in the same Region as the storage lens configuration.
        public var s3BucketDestination: S3ControlClientTypes.S3BucketDestination?

        public init(
            cloudWatchMetrics: S3ControlClientTypes.CloudWatchMetrics? = nil,
            s3BucketDestination: S3ControlClientTypes.S3BucketDestination? = nil
        )
        {
            self.cloudWatchMetrics = cloudWatchMetrics
            self.s3BucketDestination = s3BucketDestination
        }
    }

}

extension S3ControlClientTypes.StorageLensDataExportEncryption {

    static func writingClosure(_ value: S3ControlClientTypes.StorageLensDataExportEncryption?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["SSE-KMS"].write(value.ssekms, writingClosure: S3ControlClientTypes.SSEKMS.writingClosure(_:to:))
        try writer["SSE-S3"].write(value.sses3, writingClosure: S3ControlClientTypes.SSES3.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.StorageLensDataExportEncryption, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.StorageLensDataExportEncryption()
            value.sses3 = try reader["SSE-S3"].readIfPresent(readingClosure: S3ControlClientTypes.SSES3.readingClosure)
            value.ssekms = try reader["SSE-KMS"].readIfPresent(readingClosure: S3ControlClientTypes.SSEKMS.readingClosure)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// A container for the encryption of the S3 Storage Lens metrics exports.
    public struct StorageLensDataExportEncryption: Swift.Equatable {
        ///
        public var ssekms: S3ControlClientTypes.SSEKMS?
        ///
        public var sses3: S3ControlClientTypes.SSES3?

        public init(
            ssekms: S3ControlClientTypes.SSEKMS? = nil,
            sses3: S3ControlClientTypes.SSES3? = nil
        )
        {
            self.ssekms = ssekms
            self.sses3 = sses3
        }
    }

}

extension S3ControlClientTypes.StorageLensGroup {

    static func writingClosure(_ value: S3ControlClientTypes.StorageLensGroup?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Filter"].write(value.filter, writingClosure: S3ControlClientTypes.StorageLensGroupFilter.writingClosure(_:to:))
        try writer["Name"].write(value.name)
        try writer["StorageLensGroupArn"].write(value.storageLensGroupArn)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.StorageLensGroup, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.StorageLensGroup()
            value.name = try reader["Name"].readIfPresent()
            value.filter = try reader["Filter"].readIfPresent(readingClosure: S3ControlClientTypes.StorageLensGroupFilter.readingClosure)
            value.storageLensGroupArn = try reader["StorageLensGroupArn"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// A custom grouping of objects that include filters for prefixes, suffixes, object tags, object size, or object age. You can create an S3 Storage Lens group that includes a single filter or multiple filter conditions. To specify multiple filter conditions, you use AND or OR logical operators.
    public struct StorageLensGroup: Swift.Equatable {
        /// Sets the criteria for the Storage Lens group data that is displayed. For multiple filter conditions, the AND or OR logical operator is used.
        /// This member is required.
        public var filter: S3ControlClientTypes.StorageLensGroupFilter?
        /// Contains the name of the Storage Lens group.
        /// This member is required.
        public var name: Swift.String?
        /// Contains the Amazon Resource Name (ARN) of the Storage Lens group. This property is read-only.
        public var storageLensGroupArn: Swift.String?

        public init(
            filter: S3ControlClientTypes.StorageLensGroupFilter? = nil,
            name: Swift.String? = nil,
            storageLensGroupArn: Swift.String? = nil
        )
        {
            self.filter = filter
            self.name = name
            self.storageLensGroupArn = storageLensGroupArn
        }
    }

}

extension S3ControlClientTypes.StorageLensGroupAndOperator {

    static func writingClosure(_ value: S3ControlClientTypes.StorageLensGroupAndOperator?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["MatchAnyPrefix"].writeList(value.matchAnyPrefix, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: "Prefix", isFlattened: false)
        try writer["MatchAnySuffix"].writeList(value.matchAnySuffix, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: "Suffix", isFlattened: false)
        try writer["MatchAnyTag"].writeList(value.matchAnyTag, memberWritingClosure: S3ControlClientTypes.S3Tag.writingClosure(_:to:), memberNodeInfo: "Tag", isFlattened: false)
        try writer["MatchObjectAge"].write(value.matchObjectAge, writingClosure: S3ControlClientTypes.MatchObjectAge.writingClosure(_:to:))
        try writer["MatchObjectSize"].write(value.matchObjectSize, writingClosure: S3ControlClientTypes.MatchObjectSize.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.StorageLensGroupAndOperator, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.StorageLensGroupAndOperator()
            value.matchAnyPrefix = try reader["MatchAnyPrefix"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "Prefix", isFlattened: false)
            value.matchAnySuffix = try reader["MatchAnySuffix"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "Suffix", isFlattened: false)
            value.matchAnyTag = try reader["MatchAnyTag"].readListIfPresent(memberReadingClosure: S3ControlClientTypes.S3Tag.readingClosure, memberNodeInfo: "Tag", isFlattened: false)
            value.matchObjectAge = try reader["MatchObjectAge"].readIfPresent(readingClosure: S3ControlClientTypes.MatchObjectAge.readingClosure)
            value.matchObjectSize = try reader["MatchObjectSize"].readIfPresent(readingClosure: S3ControlClientTypes.MatchObjectSize.readingClosure)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// A logical operator that allows multiple filter conditions to be joined for more complex comparisons of Storage Lens group data.
    public struct StorageLensGroupAndOperator: Swift.Equatable {
        /// Contains a list of prefixes. At least one prefix must be specified. Up to 10 prefixes are allowed.
        public var matchAnyPrefix: [Swift.String]?
        /// Contains a list of suffixes. At least one suffix must be specified. Up to 10 suffixes are allowed.
        public var matchAnySuffix: [Swift.String]?
        /// Contains the list of object tags. At least one object tag must be specified. Up to 10 object tags are allowed.
        public var matchAnyTag: [S3ControlClientTypes.S3Tag]?
        /// Contains DaysGreaterThan and DaysLessThan to define the object age range (minimum and maximum number of days).
        public var matchObjectAge: S3ControlClientTypes.MatchObjectAge?
        /// Contains BytesGreaterThan and BytesLessThan to define the object size range (minimum and maximum number of Bytes).
        public var matchObjectSize: S3ControlClientTypes.MatchObjectSize?

        public init(
            matchAnyPrefix: [Swift.String]? = nil,
            matchAnySuffix: [Swift.String]? = nil,
            matchAnyTag: [S3ControlClientTypes.S3Tag]? = nil,
            matchObjectAge: S3ControlClientTypes.MatchObjectAge? = nil,
            matchObjectSize: S3ControlClientTypes.MatchObjectSize? = nil
        )
        {
            self.matchAnyPrefix = matchAnyPrefix
            self.matchAnySuffix = matchAnySuffix
            self.matchAnyTag = matchAnyTag
            self.matchObjectAge = matchObjectAge
            self.matchObjectSize = matchObjectSize
        }
    }

}

extension S3ControlClientTypes.StorageLensGroupFilter {

    static func writingClosure(_ value: S3ControlClientTypes.StorageLensGroupFilter?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["And"].write(value.and, writingClosure: S3ControlClientTypes.StorageLensGroupAndOperator.writingClosure(_:to:))
        try writer["MatchAnyPrefix"].writeList(value.matchAnyPrefix, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: "Prefix", isFlattened: false)
        try writer["MatchAnySuffix"].writeList(value.matchAnySuffix, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: "Suffix", isFlattened: false)
        try writer["MatchAnyTag"].writeList(value.matchAnyTag, memberWritingClosure: S3ControlClientTypes.S3Tag.writingClosure(_:to:), memberNodeInfo: "Tag", isFlattened: false)
        try writer["MatchObjectAge"].write(value.matchObjectAge, writingClosure: S3ControlClientTypes.MatchObjectAge.writingClosure(_:to:))
        try writer["MatchObjectSize"].write(value.matchObjectSize, writingClosure: S3ControlClientTypes.MatchObjectSize.writingClosure(_:to:))
        try writer["Or"].write(value.or, writingClosure: S3ControlClientTypes.StorageLensGroupOrOperator.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.StorageLensGroupFilter, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.StorageLensGroupFilter()
            value.matchAnyPrefix = try reader["MatchAnyPrefix"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "Prefix", isFlattened: false)
            value.matchAnySuffix = try reader["MatchAnySuffix"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "Suffix", isFlattened: false)
            value.matchAnyTag = try reader["MatchAnyTag"].readListIfPresent(memberReadingClosure: S3ControlClientTypes.S3Tag.readingClosure, memberNodeInfo: "Tag", isFlattened: false)
            value.matchObjectAge = try reader["MatchObjectAge"].readIfPresent(readingClosure: S3ControlClientTypes.MatchObjectAge.readingClosure)
            value.matchObjectSize = try reader["MatchObjectSize"].readIfPresent(readingClosure: S3ControlClientTypes.MatchObjectSize.readingClosure)
            value.and = try reader["And"].readIfPresent(readingClosure: S3ControlClientTypes.StorageLensGroupAndOperator.readingClosure)
            value.or = try reader["Or"].readIfPresent(readingClosure: S3ControlClientTypes.StorageLensGroupOrOperator.readingClosure)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// The filter element sets the criteria for the Storage Lens group data that is displayed. For multiple filter conditions, the AND or OR logical operator is used.
    public struct StorageLensGroupFilter: Swift.Equatable {
        /// A logical operator that allows multiple filter conditions to be joined for more complex comparisons of Storage Lens group data. Objects must match all of the listed filter conditions that are joined by the And logical operator. Only one of each filter condition is allowed.
        public var and: S3ControlClientTypes.StorageLensGroupAndOperator?
        /// Contains a list of prefixes. At least one prefix must be specified. Up to 10 prefixes are allowed.
        public var matchAnyPrefix: [Swift.String]?
        /// Contains a list of suffixes. At least one suffix must be specified. Up to 10 suffixes are allowed.
        public var matchAnySuffix: [Swift.String]?
        /// Contains the list of S3 object tags. At least one object tag must be specified. Up to 10 object tags are allowed.
        public var matchAnyTag: [S3ControlClientTypes.S3Tag]?
        /// Contains DaysGreaterThan and DaysLessThan to define the object age range (minimum and maximum number of days).
        public var matchObjectAge: S3ControlClientTypes.MatchObjectAge?
        /// Contains BytesGreaterThan and BytesLessThan to define the object size range (minimum and maximum number of Bytes).
        public var matchObjectSize: S3ControlClientTypes.MatchObjectSize?
        /// A single logical operator that allows multiple filter conditions to be joined. Objects can match any of the listed filter conditions, which are joined by the Or logical operator. Only one of each filter condition is allowed.
        public var or: S3ControlClientTypes.StorageLensGroupOrOperator?

        public init(
            and: S3ControlClientTypes.StorageLensGroupAndOperator? = nil,
            matchAnyPrefix: [Swift.String]? = nil,
            matchAnySuffix: [Swift.String]? = nil,
            matchAnyTag: [S3ControlClientTypes.S3Tag]? = nil,
            matchObjectAge: S3ControlClientTypes.MatchObjectAge? = nil,
            matchObjectSize: S3ControlClientTypes.MatchObjectSize? = nil,
            or: S3ControlClientTypes.StorageLensGroupOrOperator? = nil
        )
        {
            self.and = and
            self.matchAnyPrefix = matchAnyPrefix
            self.matchAnySuffix = matchAnySuffix
            self.matchAnyTag = matchAnyTag
            self.matchObjectAge = matchObjectAge
            self.matchObjectSize = matchObjectSize
            self.or = or
        }
    }

}

extension S3ControlClientTypes.StorageLensGroupLevel {

    static func writingClosure(_ value: S3ControlClientTypes.StorageLensGroupLevel?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["SelectionCriteria"].write(value.selectionCriteria, writingClosure: S3ControlClientTypes.StorageLensGroupLevelSelectionCriteria.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.StorageLensGroupLevel, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.StorageLensGroupLevel()
            value.selectionCriteria = try reader["SelectionCriteria"].readIfPresent(readingClosure: S3ControlClientTypes.StorageLensGroupLevelSelectionCriteria.readingClosure)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// Specifies the Storage Lens groups to include in the Storage Lens group aggregation.
    public struct StorageLensGroupLevel: Swift.Equatable {
        /// Indicates which Storage Lens group ARNs to include or exclude in the Storage Lens group aggregation. If this value is left null, then all Storage Lens groups are selected.
        public var selectionCriteria: S3ControlClientTypes.StorageLensGroupLevelSelectionCriteria?

        public init(
            selectionCriteria: S3ControlClientTypes.StorageLensGroupLevelSelectionCriteria? = nil
        )
        {
            self.selectionCriteria = selectionCriteria
        }
    }

}

extension S3ControlClientTypes.StorageLensGroupLevelSelectionCriteria {

    static func writingClosure(_ value: S3ControlClientTypes.StorageLensGroupLevelSelectionCriteria?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Exclude"].writeList(value.exclude, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: "Arn", isFlattened: false)
        try writer["Include"].writeList(value.include, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: "Arn", isFlattened: false)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.StorageLensGroupLevelSelectionCriteria, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.StorageLensGroupLevelSelectionCriteria()
            value.include = try reader["Include"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "Arn", isFlattened: false)
            value.exclude = try reader["Exclude"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "Arn", isFlattened: false)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// Indicates which Storage Lens group ARNs to include or exclude in the Storage Lens group aggregation. You can only attach Storage Lens groups to your Storage Lens dashboard if they're included in your Storage Lens group aggregation. If this value is left null, then all Storage Lens groups are selected.
    public struct StorageLensGroupLevelSelectionCriteria: Swift.Equatable {
        /// Indicates which Storage Lens group ARNs to exclude from the Storage Lens group aggregation.
        public var exclude: [Swift.String]?
        /// Indicates which Storage Lens group ARNs to include in the Storage Lens group aggregation.
        public var include: [Swift.String]?

        public init(
            exclude: [Swift.String]? = nil,
            include: [Swift.String]? = nil
        )
        {
            self.exclude = exclude
            self.include = include
        }
    }

}

extension S3ControlClientTypes.StorageLensGroupOrOperator {

    static func writingClosure(_ value: S3ControlClientTypes.StorageLensGroupOrOperator?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["MatchAnyPrefix"].writeList(value.matchAnyPrefix, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: "Prefix", isFlattened: false)
        try writer["MatchAnySuffix"].writeList(value.matchAnySuffix, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: "Suffix", isFlattened: false)
        try writer["MatchAnyTag"].writeList(value.matchAnyTag, memberWritingClosure: S3ControlClientTypes.S3Tag.writingClosure(_:to:), memberNodeInfo: "Tag", isFlattened: false)
        try writer["MatchObjectAge"].write(value.matchObjectAge, writingClosure: S3ControlClientTypes.MatchObjectAge.writingClosure(_:to:))
        try writer["MatchObjectSize"].write(value.matchObjectSize, writingClosure: S3ControlClientTypes.MatchObjectSize.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.StorageLensGroupOrOperator, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.StorageLensGroupOrOperator()
            value.matchAnyPrefix = try reader["MatchAnyPrefix"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "Prefix", isFlattened: false)
            value.matchAnySuffix = try reader["MatchAnySuffix"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "Suffix", isFlattened: false)
            value.matchAnyTag = try reader["MatchAnyTag"].readListIfPresent(memberReadingClosure: S3ControlClientTypes.S3Tag.readingClosure, memberNodeInfo: "Tag", isFlattened: false)
            value.matchObjectAge = try reader["MatchObjectAge"].readIfPresent(readingClosure: S3ControlClientTypes.MatchObjectAge.readingClosure)
            value.matchObjectSize = try reader["MatchObjectSize"].readIfPresent(readingClosure: S3ControlClientTypes.MatchObjectSize.readingClosure)
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// A container element for specifying Or rule conditions. The rule conditions determine the subset of objects to which the Or rule applies. Objects can match any of the listed filter conditions, which are joined by the Or logical operator. Only one of each filter condition is allowed.
    public struct StorageLensGroupOrOperator: Swift.Equatable {
        /// Filters objects that match any of the specified prefixes.
        public var matchAnyPrefix: [Swift.String]?
        /// Filters objects that match any of the specified suffixes.
        public var matchAnySuffix: [Swift.String]?
        /// Filters objects that match any of the specified S3 object tags.
        public var matchAnyTag: [S3ControlClientTypes.S3Tag]?
        /// Filters objects that match the specified object age range.
        public var matchObjectAge: S3ControlClientTypes.MatchObjectAge?
        /// Filters objects that match the specified object size range.
        public var matchObjectSize: S3ControlClientTypes.MatchObjectSize?

        public init(
            matchAnyPrefix: [Swift.String]? = nil,
            matchAnySuffix: [Swift.String]? = nil,
            matchAnyTag: [S3ControlClientTypes.S3Tag]? = nil,
            matchObjectAge: S3ControlClientTypes.MatchObjectAge? = nil,
            matchObjectSize: S3ControlClientTypes.MatchObjectSize? = nil
        )
        {
            self.matchAnyPrefix = matchAnyPrefix
            self.matchAnySuffix = matchAnySuffix
            self.matchAnyTag = matchAnyTag
            self.matchObjectAge = matchObjectAge
            self.matchObjectSize = matchObjectSize
        }
    }

}

extension S3ControlClientTypes.StorageLensTag {

    static func writingClosure(_ value: S3ControlClientTypes.StorageLensTag?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.StorageLensTag, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.StorageLensTag()
            value.key = try reader["Key"].readIfPresent()
            value.value = try reader["Value"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    ///
    public struct StorageLensTag: Swift.Equatable {
        ///
        /// This member is required.
        public var key: Swift.String?
        ///
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension SubmitMultiRegionAccessPointRoutesInput {
    static func writingClosure(_ value: SubmitMultiRegionAccessPointRoutesInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["RouteUpdates"].writeList(value.routeUpdates, memberWritingClosure: S3ControlClientTypes.MultiRegionAccessPointRoute.writingClosure(_:to:), memberNodeInfo: "Route", isFlattened: false)
    }
}

extension SubmitMultiRegionAccessPointRoutesInput {

    static func headerProvider(_ value: SubmitMultiRegionAccessPointRoutesInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension SubmitMultiRegionAccessPointRoutesInput {

    static func urlPathProvider(_ value: SubmitMultiRegionAccessPointRoutesInput) -> Swift.String? {
        guard let mrap = value.mrap else {
            return nil
        }
        return "/v20180820/mrap/instances/\(mrap.urlPercentEncoding(encodeForwardSlash: false))/routes"
    }
}

public struct SubmitMultiRegionAccessPointRoutesInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the owner of the Multi-Region Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The Multi-Region Access Point ARN.
    /// This member is required.
    public var mrap: Swift.String?
    /// The different routes that make up the new route configuration. Active routes return a value of 100, and passive routes return a value of 0.
    /// This member is required.
    public var routeUpdates: [S3ControlClientTypes.MultiRegionAccessPointRoute]?

    public init(
        accountId: Swift.String? = nil,
        mrap: Swift.String? = nil,
        routeUpdates: [S3ControlClientTypes.MultiRegionAccessPointRoute]? = nil
    )
    {
        self.accountId = accountId
        self.mrap = mrap
        self.routeUpdates = routeUpdates
    }
}

extension SubmitMultiRegionAccessPointRoutesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<SubmitMultiRegionAccessPointRoutesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return SubmitMultiRegionAccessPointRoutesOutput()
        }
    }
}

public struct SubmitMultiRegionAccessPointRoutesOutput: Swift.Equatable {

    public init() { }
}

enum SubmitMultiRegionAccessPointRoutesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension S3ControlClientTypes.Tag {

    static func writingClosure(_ value: S3ControlClientTypes.Tag?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.Tag, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.Tag()
            value.key = try reader["Key"].readIfPresent()
            value.value = try reader["Value"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// An Amazon Web Services resource tag that's associated with your S3 resource. You can add tags to new objects when you upload them, or you can add object tags to existing objects. This operation is only supported for [S3 Storage Lens groups](https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage-lens-groups.html) and for [S3 Access Grants](https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-grants-tagging.html). The tagged resource can be an S3 Storage Lens group or S3 Access Grants instance, registered location, or grant.
    public struct Tag: Swift.Equatable {
        /// The key of the key-value pair of a tag added to your Amazon Web Services resource. A tag key can be up to 128 Unicode characters in length and is case-sensitive. System created tags that begin with aws: aren’t supported.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the key-value pair of a tag added to your Amazon Web Services resource. A tag value can be up to 256 Unicode characters in length and is case-sensitive.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput {
    static func writingClosure(_ value: TagResourceInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Tags"].writeList(value.tags, memberWritingClosure: S3ControlClientTypes.Tag.writingClosure(_:to:), memberNodeInfo: "Tag", isFlattened: false)
    }
}

extension TagResourceInput {

    static func headerProvider(_ value: TagResourceInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/v20180820/tags/\(resourceArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Web Services account ID that created the S3 resource that you're trying to add tags to or the requester's account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The Amazon Resource Name (ARN) of the S3 resource that you're trying to add tags to. The tagged resource can be an S3 Storage Lens group or S3 Access Grants instance, registered location, or grant.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The Amazon Web Services resource tags that you want to add to the specified S3 resource.
    /// This member is required.
    public var tags: [S3ControlClientTypes.Tag]?

    public init(
        accountId: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        tags: [S3ControlClientTypes.Tag]? = nil
    )
    {
        self.accountId = accountId
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

extension TagResourceOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<TagResourceOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return TagResourceOutput()
        }
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension S3ControlClientTypes.Tagging {

    static func writingClosure(_ value: S3ControlClientTypes.Tagging?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["TagSet"].writeList(value.tagSet, memberWritingClosure: S3ControlClientTypes.S3Tag.writingClosure(_:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.Tagging, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.Tagging()
            value.tagSet = try reader["TagSet"].readListIfPresent(memberReadingClosure: S3ControlClientTypes.S3Tag.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

extension S3ControlClientTypes {
    ///
    public struct Tagging: Swift.Equatable {
        /// A collection for a set of tags.
        /// This member is required.
        public var tagSet: [S3ControlClientTypes.S3Tag]?

        public init(
            tagSet: [S3ControlClientTypes.S3Tag]? = nil
        )
        {
            self.tagSet = tagSet
        }
    }

}

extension TooManyRequestsException {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyRequestsException, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyRequestsException()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyRequestsException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyRequestsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

///
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyTagsException {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyTagsException, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyTagsException()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyTagsException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyTagsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Amazon S3 throws this exception if you have too many tags in your tag set.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension S3ControlClientTypes.Transition {

    static func writingClosure(_ value: S3ControlClientTypes.Transition?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Date"].writeTimestamp(value.date, format: .dateTime)
        try writer["Days"].write(value.days)
        try writer["StorageClass"].write(value.storageClass)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.Transition, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.Transition()
            value.date = try reader["Date"].readTimestampIfPresent(format: .dateTime)
            value.days = try reader["Days"].readIfPresent() ?? 0
            value.storageClass = try reader["StorageClass"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// Specifies when an object transitions to a specified storage class. For more information about Amazon S3 Lifecycle configuration rules, see [ Transitioning objects using Amazon S3 Lifecycle](https://docs.aws.amazon.com/AmazonS3/latest/dev/lifecycle-transition-general-considerations.html) in the Amazon S3 User Guide.
    public struct Transition: Swift.Equatable {
        /// Indicates when objects are transitioned to the specified storage class. The date value must be in ISO 8601 format. The time is always midnight UTC.
        public var date: ClientRuntime.Date?
        /// Indicates the number of days after creation when objects are transitioned to the specified storage class. The value must be a positive integer.
        public var days: Swift.Int
        /// The storage class to which you want the object to transition.
        public var storageClass: S3ControlClientTypes.TransitionStorageClass?

        public init(
            date: ClientRuntime.Date? = nil,
            days: Swift.Int = 0,
            storageClass: S3ControlClientTypes.TransitionStorageClass? = nil
        )
        {
            self.date = date
            self.days = days
            self.storageClass = storageClass
        }
    }

}

extension S3ControlClientTypes {
    public enum TransitionStorageClass: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deepArchive
        case glacier
        case intelligentTiering
        case onezoneIa
        case standardIa
        case sdkUnknown(Swift.String)

        public static var allCases: [TransitionStorageClass] {
            return [
                .deepArchive,
                .glacier,
                .intelligentTiering,
                .onezoneIa,
                .standardIa,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deepArchive: return "DEEP_ARCHIVE"
            case .glacier: return "GLACIER"
            case .intelligentTiering: return "INTELLIGENT_TIERING"
            case .onezoneIa: return "ONEZONE_IA"
            case .standardIa: return "STANDARD_IA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TransitionStorageClass(rawValue: rawValue) ?? TransitionStorageClass.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput {

    static func headerProvider(_ value: UntagResourceInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/v20180820/tags/\(resourceArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Web Services account ID that owns the resource that you're trying to remove the tags from.
    /// This member is required.
    public var accountId: Swift.String?
    /// The Amazon Resource Name (ARN) of the S3 resource that you're trying to remove the tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The array of tag key-value pairs that you're trying to remove from of the S3 resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        accountId: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.accountId = accountId
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

extension UntagResourceOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UntagResourceOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return UntagResourceOutput()
        }
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension UpdateAccessGrantsLocationInput {
    static func writingClosure(_ value: UpdateAccessGrantsLocationInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["IAMRoleArn"].write(value.iamRoleArn)
    }
}

extension UpdateAccessGrantsLocationInput {

    static func headerProvider(_ value: UpdateAccessGrantsLocationInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension UpdateAccessGrantsLocationInput {

    static func urlPathProvider(_ value: UpdateAccessGrantsLocationInput) -> Swift.String? {
        guard let accessGrantsLocationId = value.accessGrantsLocationId else {
            return nil
        }
        return "/v20180820/accessgrantsinstance/location/\(accessGrantsLocationId.urlPercentEncoding())"
    }
}

public struct UpdateAccessGrantsLocationInput: Swift.Equatable {
    /// The ID of the registered location that you are updating. S3 Access Grants assigns this ID when you register the location. S3 Access Grants assigns the ID default to the default location s3:// and assigns an auto-generated ID to other locations that you register. The ID of the registered location to which you are granting access. S3 Access Grants assigned this ID when you registered the location. S3 Access Grants assigns the ID default to the default location s3:// and assigns an auto-generated ID to other locations that you register. If you are passing the default location, you cannot create an access grant for the entire default location. You must also specify a bucket or a bucket and prefix in the Subprefix field.
    /// This member is required.
    public var accessGrantsLocationId: Swift.String?
    /// The ID of the Amazon Web Services account that is making this request.
    /// This member is required.
    public var accountId: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role for the registered location. S3 Access Grants assumes this role to manage access to the registered location.
    /// This member is required.
    public var iamRoleArn: Swift.String?

    public init(
        accessGrantsLocationId: Swift.String? = nil,
        accountId: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil
    )
    {
        self.accessGrantsLocationId = accessGrantsLocationId
        self.accountId = accountId
        self.iamRoleArn = iamRoleArn
    }
}

extension UpdateAccessGrantsLocationOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UpdateAccessGrantsLocationOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = UpdateAccessGrantsLocationOutput()
            value.accessGrantsLocationArn = try reader["AccessGrantsLocationArn"].readIfPresent()
            value.accessGrantsLocationId = try reader["AccessGrantsLocationId"].readIfPresent()
            value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: .dateTime)
            value.iamRoleArn = try reader["IAMRoleArn"].readIfPresent()
            value.locationScope = try reader["LocationScope"].readIfPresent()
            return value
        }
    }
}

public struct UpdateAccessGrantsLocationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the registered location that you are updating.
    public var accessGrantsLocationArn: Swift.String?
    /// The ID of the registered location to which you are granting access. S3 Access Grants assigned this ID when you registered the location. S3 Access Grants assigns the ID default to the default location s3:// and assigns an auto-generated ID to other locations that you register.
    public var accessGrantsLocationId: Swift.String?
    /// The date and time when you registered the location.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the IAM role of the registered location. S3 Access Grants assumes this role to manage access to the registered location.
    public var iamRoleArn: Swift.String?
    /// The S3 URI path of the location that you are updating. You cannot update the scope of the registered location. The location scope can be the default S3 location s3://, the S3 path to a bucket s3://, or the S3 path to a bucket and prefix s3:///.
    public var locationScope: Swift.String?

    public init(
        accessGrantsLocationArn: Swift.String? = nil,
        accessGrantsLocationId: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        iamRoleArn: Swift.String? = nil,
        locationScope: Swift.String? = nil
    )
    {
        self.accessGrantsLocationArn = accessGrantsLocationArn
        self.accessGrantsLocationId = accessGrantsLocationId
        self.createdAt = createdAt
        self.iamRoleArn = iamRoleArn
        self.locationScope = locationScope
    }
}

enum UpdateAccessGrantsLocationOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension UpdateJobPriorityInput {

    static func headerProvider(_ value: UpdateJobPriorityInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension UpdateJobPriorityInput {

    static func queryItemProvider(_ value: UpdateJobPriorityInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let priority = value.priority else {
            let message = "Creating a URL Query Item failed. priority is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let priorityQueryItem = ClientRuntime.SDKURLQueryItem(name: "priority".urlPercentEncoding(), value: Swift.String(priority).urlPercentEncoding())
        items.append(priorityQueryItem)
        return items
    }
}

extension UpdateJobPriorityInput {

    static func urlPathProvider(_ value: UpdateJobPriorityInput) -> Swift.String? {
        guard let jobId = value.jobId else {
            return nil
        }
        return "/v20180820/jobs/\(jobId.urlPercentEncoding())/priority"
    }
}

public struct UpdateJobPriorityInput: Swift.Equatable {
    /// The Amazon Web Services account ID associated with the S3 Batch Operations job.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID for the job whose priority you want to update.
    /// This member is required.
    public var jobId: Swift.String?
    /// The priority you want to assign to this job.
    /// This member is required.
    public var priority: Swift.Int?

    public init(
        accountId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        priority: Swift.Int? = nil
    )
    {
        self.accountId = accountId
        self.jobId = jobId
        self.priority = priority
    }
}

extension UpdateJobPriorityOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UpdateJobPriorityOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = UpdateJobPriorityOutput()
            value.jobId = try reader["JobId"].readIfPresent()
            value.priority = try reader["Priority"].readIfPresent() ?? 0
            return value
        }
    }
}

public struct UpdateJobPriorityOutput: Swift.Equatable {
    /// The ID for the job whose priority Amazon S3 updated.
    /// This member is required.
    public var jobId: Swift.String?
    /// The new priority assigned to the specified job.
    /// This member is required.
    public var priority: Swift.Int

    public init(
        jobId: Swift.String? = nil,
        priority: Swift.Int = 0
    )
    {
        self.jobId = jobId
        self.priority = priority
    }
}

enum UpdateJobPriorityOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "BadRequestException": return try await BadRequestException.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InternalServiceException": return try await InternalServiceException.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NotFoundException": return try await NotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyRequestsException": return try await TooManyRequestsException.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension UpdateJobStatusInput {

    static func headerProvider(_ value: UpdateJobStatusInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension UpdateJobStatusInput {

    static func queryItemProvider(_ value: UpdateJobStatusInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let statusUpdateReason = value.statusUpdateReason {
            let statusUpdateReasonQueryItem = ClientRuntime.SDKURLQueryItem(name: "statusUpdateReason".urlPercentEncoding(), value: Swift.String(statusUpdateReason).urlPercentEncoding())
            items.append(statusUpdateReasonQueryItem)
        }
        guard let requestedJobStatus = value.requestedJobStatus else {
            let message = "Creating a URL Query Item failed. requestedJobStatus is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let requestedJobStatusQueryItem = ClientRuntime.SDKURLQueryItem(name: "requestedJobStatus".urlPercentEncoding(), value: Swift.String(requestedJobStatus.rawValue).urlPercentEncoding())
        items.append(requestedJobStatusQueryItem)
        return items
    }
}

extension UpdateJobStatusInput {

    static func urlPathProvider(_ value: UpdateJobStatusInput) -> Swift.String? {
        guard let jobId = value.jobId else {
            return nil
        }
        return "/v20180820/jobs/\(jobId.urlPercentEncoding())/status"
    }
}

public struct UpdateJobStatusInput: Swift.Equatable {
    /// The Amazon Web Services account ID associated with the S3 Batch Operations job.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID of the job whose status you want to update.
    /// This member is required.
    public var jobId: Swift.String?
    /// The status that you want to move the specified job to.
    /// This member is required.
    public var requestedJobStatus: S3ControlClientTypes.RequestedJobStatus?
    /// A description of the reason why you want to change the specified job's status. This field can be any string up to the maximum length.
    public var statusUpdateReason: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        requestedJobStatus: S3ControlClientTypes.RequestedJobStatus? = nil,
        statusUpdateReason: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.jobId = jobId
        self.requestedJobStatus = requestedJobStatus
        self.statusUpdateReason = statusUpdateReason
    }
}

extension UpdateJobStatusOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UpdateJobStatusOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = UpdateJobStatusOutput()
            value.jobId = try reader["JobId"].readIfPresent()
            value.status = try reader["Status"].readIfPresent()
            value.statusUpdateReason = try reader["StatusUpdateReason"].readIfPresent()
            return value
        }
    }
}

public struct UpdateJobStatusOutput: Swift.Equatable {
    /// The ID for the job whose status was updated.
    public var jobId: Swift.String?
    /// The current status for the specified job.
    public var status: S3ControlClientTypes.JobStatus?
    /// The reason that the specified job's status was updated.
    public var statusUpdateReason: Swift.String?

    public init(
        jobId: Swift.String? = nil,
        status: S3ControlClientTypes.JobStatus? = nil,
        statusUpdateReason: Swift.String? = nil
    )
    {
        self.jobId = jobId
        self.status = status
        self.statusUpdateReason = statusUpdateReason
    }
}

enum UpdateJobStatusOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "BadRequestException": return try await BadRequestException.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InternalServiceException": return try await InternalServiceException.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "JobStatusException": return try await JobStatusException.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NotFoundException": return try await NotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyRequestsException": return try await TooManyRequestsException.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension UpdateStorageLensGroupInput {
    static func writingClosure(_ value: UpdateStorageLensGroupInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["StorageLensGroup"].write(value.storageLensGroup, writingClosure: S3ControlClientTypes.StorageLensGroup.writingClosure(_:to:))
    }
}

extension UpdateStorageLensGroupInput {

    static func headerProvider(_ value: UpdateStorageLensGroupInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = value.accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension UpdateStorageLensGroupInput {

    static func urlPathProvider(_ value: UpdateStorageLensGroupInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/v20180820/storagelensgroup/\(name.urlPercentEncoding())"
    }
}

public struct UpdateStorageLensGroupInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Storage Lens group owner.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the Storage Lens group that you want to update.
    /// This member is required.
    public var name: Swift.String?
    /// The JSON file that contains the Storage Lens group configuration.
    /// This member is required.
    public var storageLensGroup: S3ControlClientTypes.StorageLensGroup?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil,
        storageLensGroup: S3ControlClientTypes.StorageLensGroup? = nil
    )
    {
        self.accountId = accountId
        self.name = name
        self.storageLensGroup = storageLensGroup
    }
}

extension UpdateStorageLensGroupOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UpdateStorageLensGroupOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return UpdateStorageLensGroupOutput()
        }
    }
}

public struct UpdateStorageLensGroupOutput: Swift.Equatable {

    public init() { }
}

enum UpdateStorageLensGroupOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension S3ControlClientTypes.VersioningConfiguration {

    static func writingClosure(_ value: S3ControlClientTypes.VersioningConfiguration?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["MfaDelete"].write(value.mfaDelete)
        try writer["Status"].write(value.status)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.VersioningConfiguration, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.VersioningConfiguration()
            value.mfaDelete = try reader["MfaDelete"].readIfPresent()
            value.status = try reader["Status"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// Describes the versioning state of an Amazon S3 on Outposts bucket. For more information, see [PutBucketVersioning](https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_PutBucketVersioning.html).
    public struct VersioningConfiguration: Swift.Equatable {
        /// Specifies whether MFA delete is enabled or disabled in the bucket versioning configuration for the S3 on Outposts bucket.
        public var mfaDelete: S3ControlClientTypes.MFADelete?
        /// Sets the versioning state of the S3 on Outposts bucket.
        public var status: S3ControlClientTypes.BucketVersioningStatus?

        public init(
            mfaDelete: S3ControlClientTypes.MFADelete? = nil,
            status: S3ControlClientTypes.BucketVersioningStatus? = nil
        )
        {
            self.mfaDelete = mfaDelete
            self.status = status
        }
    }

}

extension S3ControlClientTypes.VpcConfiguration {

    static func writingClosure(_ value: S3ControlClientTypes.VpcConfiguration?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["VpcId"].write(value.vpcId)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<S3ControlClientTypes.VpcConfiguration, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = S3ControlClientTypes.VpcConfiguration()
            value.vpcId = try reader["VpcId"].readIfPresent()
            return value
        }
    }
}

extension S3ControlClientTypes {
    /// The virtual private cloud (VPC) configuration for an access point.
    public struct VpcConfiguration: Swift.Equatable {
        /// If this field is specified, this access point will only allow connections from the specified VPC ID.
        /// This member is required.
        public var vpcId: Swift.String?

        public init(
            vpcId: Swift.String? = nil
        )
        {
            self.vpcId = vpcId
        }
    }

}
