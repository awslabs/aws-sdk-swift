// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension S3ControlClientTypes.AbortIncompleteMultipartUpload: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case daysAfterInitiation = "DaysAfterInitiation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if daysAfterInitiation != 0 {
            try container.encode(daysAfterInitiation, forKey: ClientRuntime.Key("DaysAfterInitiation"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let daysAfterInitiationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .daysAfterInitiation) ?? 0
        daysAfterInitiation = daysAfterInitiationDecoded
    }
}

extension S3ControlClientTypes.AbortIncompleteMultipartUpload: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// The container for abort incomplete multipart upload
    public struct AbortIncompleteMultipartUpload: Swift.Equatable {
        /// Specifies the number of days after which Amazon S3 aborts an incomplete multipart upload to the Outposts bucket.
        public var daysAfterInitiation: Swift.Int

        public init(
            daysAfterInitiation: Swift.Int = 0
        )
        {
            self.daysAfterInitiation = daysAfterInitiation
        }
    }

}

extension S3ControlClientTypes.AccessControlTranslation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case owner = "Owner"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let owner = owner {
            try container.encode(owner, forKey: ClientRuntime.Key("Owner"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.OwnerOverride.self, forKey: .owner)
        owner = ownerDecoded
    }
}

extension S3ControlClientTypes.AccessControlTranslation: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// A container for information about access control for replicas. This is not supported by Amazon S3 on Outposts buckets.
    public struct AccessControlTranslation: Swift.Equatable {
        /// Specifies the replica ownership.
        /// This member is required.
        public var owner: S3ControlClientTypes.OwnerOverride?

        public init(
            owner: S3ControlClientTypes.OwnerOverride? = nil
        )
        {
            self.owner = owner
        }
    }

}

extension S3ControlClientTypes.AccessPoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPointArn = "AccessPointArn"
        case alias = "Alias"
        case bucket = "Bucket"
        case bucketAccountId = "BucketAccountId"
        case name = "Name"
        case networkOrigin = "NetworkOrigin"
        case vpcConfiguration = "VpcConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let accessPointArn = accessPointArn {
            try container.encode(accessPointArn, forKey: ClientRuntime.Key("AccessPointArn"))
        }
        if let alias = alias {
            try container.encode(alias, forKey: ClientRuntime.Key("Alias"))
        }
        if let bucket = bucket {
            try container.encode(bucket, forKey: ClientRuntime.Key("Bucket"))
        }
        if let bucketAccountId = bucketAccountId {
            try container.encode(bucketAccountId, forKey: ClientRuntime.Key("BucketAccountId"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let networkOrigin = networkOrigin {
            try container.encode(networkOrigin, forKey: ClientRuntime.Key("NetworkOrigin"))
        }
        if let vpcConfiguration = vpcConfiguration {
            try container.encode(vpcConfiguration, forKey: ClientRuntime.Key("VpcConfiguration"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let networkOriginDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.NetworkOrigin.self, forKey: .networkOrigin)
        networkOrigin = networkOriginDecoded
        let vpcConfigurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.VpcConfiguration.self, forKey: .vpcConfiguration)
        vpcConfiguration = vpcConfigurationDecoded
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let accessPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPointArn)
        accessPointArn = accessPointArnDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let bucketAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketAccountId)
        bucketAccountId = bucketAccountIdDecoded
    }
}

extension S3ControlClientTypes.AccessPoint: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// An access point used to access a bucket.
    public struct AccessPoint: Swift.Equatable {
        /// The ARN for the access point.
        public var accessPointArn: Swift.String?
        /// The name or alias of the access point.
        public var alias: Swift.String?
        /// The name of the bucket associated with this access point.
        /// This member is required.
        public var bucket: Swift.String?
        /// The Amazon Web Services account ID associated with the S3 bucket associated with this access point.
        public var bucketAccountId: Swift.String?
        /// The name of this access point.
        /// This member is required.
        public var name: Swift.String?
        /// Indicates whether this access point allows access from the public internet. If VpcConfiguration is specified for this access point, then NetworkOrigin is VPC, and the access point doesn't allow access from the public internet. Otherwise, NetworkOrigin is Internet, and the access point allows access from the public internet, subject to the access point and bucket access policies.
        /// This member is required.
        public var networkOrigin: S3ControlClientTypes.NetworkOrigin?
        /// The virtual private cloud (VPC) configuration for this access point, if one exists. This element is empty if this access point is an Amazon S3 on Outposts access point that is used by other Amazon Web Services.
        public var vpcConfiguration: S3ControlClientTypes.VpcConfiguration?

        public init(
            accessPointArn: Swift.String? = nil,
            alias: Swift.String? = nil,
            bucket: Swift.String? = nil,
            bucketAccountId: Swift.String? = nil,
            name: Swift.String? = nil,
            networkOrigin: S3ControlClientTypes.NetworkOrigin? = nil,
            vpcConfiguration: S3ControlClientTypes.VpcConfiguration? = nil
        )
        {
            self.accessPointArn = accessPointArn
            self.alias = alias
            self.bucket = bucket
            self.bucketAccountId = bucketAccountId
            self.name = name
            self.networkOrigin = networkOrigin
            self.vpcConfiguration = vpcConfiguration
        }
    }

}

extension S3ControlClientTypes.AccountLevel: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activityMetrics = "ActivityMetrics"
        case advancedCostOptimizationMetrics = "AdvancedCostOptimizationMetrics"
        case advancedDataProtectionMetrics = "AdvancedDataProtectionMetrics"
        case bucketLevel = "BucketLevel"
        case detailedStatusCodesMetrics = "DetailedStatusCodesMetrics"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let activityMetrics = activityMetrics {
            try container.encode(activityMetrics, forKey: ClientRuntime.Key("ActivityMetrics"))
        }
        if let advancedCostOptimizationMetrics = advancedCostOptimizationMetrics {
            try container.encode(advancedCostOptimizationMetrics, forKey: ClientRuntime.Key("AdvancedCostOptimizationMetrics"))
        }
        if let advancedDataProtectionMetrics = advancedDataProtectionMetrics {
            try container.encode(advancedDataProtectionMetrics, forKey: ClientRuntime.Key("AdvancedDataProtectionMetrics"))
        }
        if let bucketLevel = bucketLevel {
            try container.encode(bucketLevel, forKey: ClientRuntime.Key("BucketLevel"))
        }
        if let detailedStatusCodesMetrics = detailedStatusCodesMetrics {
            try container.encode(detailedStatusCodesMetrics, forKey: ClientRuntime.Key("DetailedStatusCodesMetrics"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activityMetricsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ActivityMetrics.self, forKey: .activityMetrics)
        activityMetrics = activityMetricsDecoded
        let bucketLevelDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.BucketLevel.self, forKey: .bucketLevel)
        bucketLevel = bucketLevelDecoded
        let advancedCostOptimizationMetricsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.AdvancedCostOptimizationMetrics.self, forKey: .advancedCostOptimizationMetrics)
        advancedCostOptimizationMetrics = advancedCostOptimizationMetricsDecoded
        let advancedDataProtectionMetricsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.AdvancedDataProtectionMetrics.self, forKey: .advancedDataProtectionMetrics)
        advancedDataProtectionMetrics = advancedDataProtectionMetricsDecoded
        let detailedStatusCodesMetricsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.DetailedStatusCodesMetrics.self, forKey: .detailedStatusCodesMetrics)
        detailedStatusCodesMetrics = detailedStatusCodesMetricsDecoded
    }
}

extension S3ControlClientTypes.AccountLevel: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// A container for the account-level Amazon S3 Storage Lens configuration. For more information about S3 Storage Lens, see [Assessing your storage activity and usage with S3 Storage Lens](https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage_lens.html) in the Amazon S3 User Guide. For a complete list of S3 Storage Lens metrics, see [S3 Storage Lens metrics glossary](https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage_lens_metrics_glossary.html) in the Amazon S3 User Guide.
    public struct AccountLevel: Swift.Equatable {
        /// A container for S3 Storage Lens activity metrics.
        public var activityMetrics: S3ControlClientTypes.ActivityMetrics?
        /// A container for S3 Storage Lens advanced cost-optimization metrics.
        public var advancedCostOptimizationMetrics: S3ControlClientTypes.AdvancedCostOptimizationMetrics?
        /// A container for S3 Storage Lens advanced data-protection metrics.
        public var advancedDataProtectionMetrics: S3ControlClientTypes.AdvancedDataProtectionMetrics?
        /// A container for the S3 Storage Lens bucket-level configuration.
        /// This member is required.
        public var bucketLevel: S3ControlClientTypes.BucketLevel?
        /// A container for detailed status code metrics.
        public var detailedStatusCodesMetrics: S3ControlClientTypes.DetailedStatusCodesMetrics?

        public init(
            activityMetrics: S3ControlClientTypes.ActivityMetrics? = nil,
            advancedCostOptimizationMetrics: S3ControlClientTypes.AdvancedCostOptimizationMetrics? = nil,
            advancedDataProtectionMetrics: S3ControlClientTypes.AdvancedDataProtectionMetrics? = nil,
            bucketLevel: S3ControlClientTypes.BucketLevel? = nil,
            detailedStatusCodesMetrics: S3ControlClientTypes.DetailedStatusCodesMetrics? = nil
        )
        {
            self.activityMetrics = activityMetrics
            self.advancedCostOptimizationMetrics = advancedCostOptimizationMetrics
            self.advancedDataProtectionMetrics = advancedDataProtectionMetrics
            self.bucketLevel = bucketLevel
            self.detailedStatusCodesMetrics = detailedStatusCodesMetrics
        }
    }

}

extension S3ControlClientTypes.ActivityMetrics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isEnabled = "IsEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if isEnabled != false {
            try container.encode(isEnabled, forKey: ClientRuntime.Key("IsEnabled"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isEnabled) ?? false
        isEnabled = isEnabledDecoded
    }
}

extension S3ControlClientTypes.ActivityMetrics: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// The container element for Amazon S3 Storage Lens activity metrics. Activity metrics show details about how your storage is requested, such as requests (for example, All requests, Get requests, Put requests), bytes uploaded or downloaded, and errors. For more information about S3 Storage Lens, see [Assessing your storage activity and usage with S3 Storage Lens](https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage_lens.html) in the Amazon S3 User Guide. For a complete list of S3 Storage Lens metrics, see [S3 Storage Lens metrics glossary](https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage_lens_metrics_glossary.html) in the Amazon S3 User Guide.
    public struct ActivityMetrics: Swift.Equatable {
        /// A container that indicates whether activity metrics are enabled.
        public var isEnabled: Swift.Bool

        public init(
            isEnabled: Swift.Bool = false
        )
        {
            self.isEnabled = isEnabled
        }
    }

}

extension S3ControlClientTypes.AdvancedCostOptimizationMetrics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isEnabled = "IsEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if isEnabled != false {
            try container.encode(isEnabled, forKey: ClientRuntime.Key("IsEnabled"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isEnabled) ?? false
        isEnabled = isEnabledDecoded
    }
}

extension S3ControlClientTypes.AdvancedCostOptimizationMetrics: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// The container element for Amazon S3 Storage Lens advanced cost-optimization metrics. Advanced cost-optimization metrics provide insights that you can use to manage and optimize your storage costs, for example, lifecycle rule counts for transitions, expirations, and incomplete multipart uploads. For more information about S3 Storage Lens, see [Assessing your storage activity and usage with S3 Storage Lens](https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage_lens.html) in the Amazon S3 User Guide. For a complete list of S3 Storage Lens metrics, see [S3 Storage Lens metrics glossary](https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage_lens_metrics_glossary.html) in the Amazon S3 User Guide.
    public struct AdvancedCostOptimizationMetrics: Swift.Equatable {
        /// A container that indicates whether advanced cost-optimization metrics are enabled.
        public var isEnabled: Swift.Bool

        public init(
            isEnabled: Swift.Bool = false
        )
        {
            self.isEnabled = isEnabled
        }
    }

}

extension S3ControlClientTypes.AdvancedDataProtectionMetrics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isEnabled = "IsEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if isEnabled != false {
            try container.encode(isEnabled, forKey: ClientRuntime.Key("IsEnabled"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isEnabled) ?? false
        isEnabled = isEnabledDecoded
    }
}

extension S3ControlClientTypes.AdvancedDataProtectionMetrics: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// The container element for Amazon S3 Storage Lens advanced data-protection metrics. Advanced data-protection metrics provide insights that you can use to perform audits and protect your data, for example replication rule counts within and across Regions. For more information about S3 Storage Lens, see [Assessing your storage activity and usage with S3 Storage Lens](https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage_lens.html) in the Amazon S3 User Guide. For a complete list of S3 Storage Lens metrics, see [S3 Storage Lens metrics glossary](https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage_lens_metrics_glossary.html) in the Amazon S3 User Guide.
    public struct AdvancedDataProtectionMetrics: Swift.Equatable {
        /// A container that indicates whether advanced data-protection metrics are enabled.
        public var isEnabled: Swift.Bool

        public init(
            isEnabled: Swift.Bool = false
        )
        {
            self.isEnabled = isEnabled
        }
    }

}

extension S3ControlClientTypes.AsyncErrorDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
        case resource = "Resource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let code = code {
            try container.encode(code, forKey: ClientRuntime.Key("Code"))
        }
        if let message = message {
            try container.encode(message, forKey: ClientRuntime.Key("Message"))
        }
        if let requestId = requestId {
            try container.encode(requestId, forKey: ClientRuntime.Key("RequestId"))
        }
        if let resource = resource {
            try container.encode(resource, forKey: ClientRuntime.Key("Resource"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resource)
        resource = resourceDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension S3ControlClientTypes.AsyncErrorDetails: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// Error details for the failed asynchronous operation.
    public struct AsyncErrorDetails: Swift.Equatable {
        /// A string that uniquely identifies the error condition.
        public var code: Swift.String?
        /// A generic description of the error condition in English.
        public var message: Swift.String?
        /// The ID of the request associated with the error.
        public var requestId: Swift.String?
        /// The identifier of the resource associated with the error.
        public var resource: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil,
            requestId: Swift.String? = nil,
            resource: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
            self.requestId = requestId
            self.resource = resource
        }
    }

}

extension S3ControlClientTypes.AsyncOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case operation = "Operation"
        case requestParameters = "RequestParameters"
        case requestStatus = "RequestStatus"
        case requestTokenARN = "RequestTokenARN"
        case responseDetails = "ResponseDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let creationTime = creationTime {
            try container.encodeTimestamp(creationTime, format: .dateTime, forKey: ClientRuntime.Key("CreationTime"))
        }
        if let operation = operation {
            try container.encode(operation, forKey: ClientRuntime.Key("Operation"))
        }
        if let requestParameters = requestParameters {
            try container.encode(requestParameters, forKey: ClientRuntime.Key("RequestParameters"))
        }
        if let requestStatus = requestStatus {
            try container.encode(requestStatus, forKey: ClientRuntime.Key("RequestStatus"))
        }
        if let requestTokenARN = requestTokenARN {
            try container.encode(requestTokenARN, forKey: ClientRuntime.Key("RequestTokenARN"))
        }
        if let responseDetails = responseDetails {
            try container.encode(responseDetails, forKey: ClientRuntime.Key("ResponseDetails"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let operationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.AsyncOperationName.self, forKey: .operation)
        operation = operationDecoded
        let requestTokenARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestTokenARN)
        requestTokenARN = requestTokenARNDecoded
        let requestParametersDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.AsyncRequestParameters.self, forKey: .requestParameters)
        requestParameters = requestParametersDecoded
        let requestStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestStatus)
        requestStatus = requestStatusDecoded
        let responseDetailsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.AsyncResponseDetails.self, forKey: .responseDetails)
        responseDetails = responseDetailsDecoded
    }
}

extension S3ControlClientTypes.AsyncOperation: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// A container for the information about an asynchronous operation.
    public struct AsyncOperation: Swift.Equatable {
        /// The time that the request was sent to the service.
        public var creationTime: ClientRuntime.Date?
        /// The specific operation for the asynchronous request.
        public var operation: S3ControlClientTypes.AsyncOperationName?
        /// The parameters associated with the request.
        public var requestParameters: S3ControlClientTypes.AsyncRequestParameters?
        /// The current status of the request.
        public var requestStatus: Swift.String?
        /// The request token associated with the request.
        public var requestTokenARN: Swift.String?
        /// The details of the response.
        public var responseDetails: S3ControlClientTypes.AsyncResponseDetails?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            operation: S3ControlClientTypes.AsyncOperationName? = nil,
            requestParameters: S3ControlClientTypes.AsyncRequestParameters? = nil,
            requestStatus: Swift.String? = nil,
            requestTokenARN: Swift.String? = nil,
            responseDetails: S3ControlClientTypes.AsyncResponseDetails? = nil
        )
        {
            self.creationTime = creationTime
            self.operation = operation
            self.requestParameters = requestParameters
            self.requestStatus = requestStatus
            self.requestTokenARN = requestTokenARN
            self.responseDetails = responseDetails
        }
    }

}

extension S3ControlClientTypes {
    public enum AsyncOperationName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createmultiregionaccesspoint
        case deletemultiregionaccesspoint
        case putmultiregionaccesspointpolicy
        case sdkUnknown(Swift.String)

        public static var allCases: [AsyncOperationName] {
            return [
                .createmultiregionaccesspoint,
                .deletemultiregionaccesspoint,
                .putmultiregionaccesspointpolicy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createmultiregionaccesspoint: return "CreateMultiRegionAccessPoint"
            case .deletemultiregionaccesspoint: return "DeleteMultiRegionAccessPoint"
            case .putmultiregionaccesspointpolicy: return "PutMultiRegionAccessPointPolicy"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AsyncOperationName(rawValue: rawValue) ?? AsyncOperationName.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.AsyncRequestParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createMultiRegionAccessPointRequest = "CreateMultiRegionAccessPointRequest"
        case deleteMultiRegionAccessPointRequest = "DeleteMultiRegionAccessPointRequest"
        case putMultiRegionAccessPointPolicyRequest = "PutMultiRegionAccessPointPolicyRequest"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let createMultiRegionAccessPointRequest = createMultiRegionAccessPointRequest {
            try container.encode(createMultiRegionAccessPointRequest, forKey: ClientRuntime.Key("CreateMultiRegionAccessPointRequest"))
        }
        if let deleteMultiRegionAccessPointRequest = deleteMultiRegionAccessPointRequest {
            try container.encode(deleteMultiRegionAccessPointRequest, forKey: ClientRuntime.Key("DeleteMultiRegionAccessPointRequest"))
        }
        if let putMultiRegionAccessPointPolicyRequest = putMultiRegionAccessPointPolicyRequest {
            try container.encode(putMultiRegionAccessPointPolicyRequest, forKey: ClientRuntime.Key("PutMultiRegionAccessPointPolicyRequest"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createMultiRegionAccessPointRequestDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.CreateMultiRegionAccessPointInput.self, forKey: .createMultiRegionAccessPointRequest)
        createMultiRegionAccessPointRequest = createMultiRegionAccessPointRequestDecoded
        let deleteMultiRegionAccessPointRequestDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.DeleteMultiRegionAccessPointInput.self, forKey: .deleteMultiRegionAccessPointRequest)
        deleteMultiRegionAccessPointRequest = deleteMultiRegionAccessPointRequestDecoded
        let putMultiRegionAccessPointPolicyRequestDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.PutMultiRegionAccessPointPolicyInput.self, forKey: .putMultiRegionAccessPointPolicyRequest)
        putMultiRegionAccessPointPolicyRequest = putMultiRegionAccessPointPolicyRequestDecoded
    }
}

extension S3ControlClientTypes.AsyncRequestParameters: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// A container for the request parameters associated with an asynchronous request.
    public struct AsyncRequestParameters: Swift.Equatable {
        /// A container of the parameters for a [CreateMultiRegionAccessPoint](https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_CreateMultiRegionAccessPoint.html) request.
        public var createMultiRegionAccessPointRequest: S3ControlClientTypes.CreateMultiRegionAccessPointInput?
        /// A container of the parameters for a [DeleteMultiRegionAccessPoint](https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_DeleteMultiRegionAccessPoint.html) request.
        public var deleteMultiRegionAccessPointRequest: S3ControlClientTypes.DeleteMultiRegionAccessPointInput?
        /// A container of the parameters for a [PutMultiRegionAccessPoint](https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_PutMultiRegionAccessPoint.html) request.
        public var putMultiRegionAccessPointPolicyRequest: S3ControlClientTypes.PutMultiRegionAccessPointPolicyInput?

        public init(
            createMultiRegionAccessPointRequest: S3ControlClientTypes.CreateMultiRegionAccessPointInput? = nil,
            deleteMultiRegionAccessPointRequest: S3ControlClientTypes.DeleteMultiRegionAccessPointInput? = nil,
            putMultiRegionAccessPointPolicyRequest: S3ControlClientTypes.PutMultiRegionAccessPointPolicyInput? = nil
        )
        {
            self.createMultiRegionAccessPointRequest = createMultiRegionAccessPointRequest
            self.deleteMultiRegionAccessPointRequest = deleteMultiRegionAccessPointRequest
            self.putMultiRegionAccessPointPolicyRequest = putMultiRegionAccessPointPolicyRequest
        }
    }

}

extension S3ControlClientTypes.AsyncResponseDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorDetails = "ErrorDetails"
        case multiRegionAccessPointDetails = "MultiRegionAccessPointDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let errorDetails = errorDetails {
            try container.encode(errorDetails, forKey: ClientRuntime.Key("ErrorDetails"))
        }
        if let multiRegionAccessPointDetails = multiRegionAccessPointDetails {
            try container.encode(multiRegionAccessPointDetails, forKey: ClientRuntime.Key("MultiRegionAccessPointDetails"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let multiRegionAccessPointDetailsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.MultiRegionAccessPointsAsyncResponse.self, forKey: .multiRegionAccessPointDetails)
        multiRegionAccessPointDetails = multiRegionAccessPointDetailsDecoded
        let errorDetailsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.AsyncErrorDetails.self, forKey: .errorDetails)
        errorDetails = errorDetailsDecoded
    }
}

extension S3ControlClientTypes.AsyncResponseDetails: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// A container for the response details that are returned when querying about an asynchronous request.
    public struct AsyncResponseDetails: Swift.Equatable {
        /// Error details for an asynchronous request.
        public var errorDetails: S3ControlClientTypes.AsyncErrorDetails?
        /// The details for the Multi-Region Access Point.
        public var multiRegionAccessPointDetails: S3ControlClientTypes.MultiRegionAccessPointsAsyncResponse?

        public init(
            errorDetails: S3ControlClientTypes.AsyncErrorDetails? = nil,
            multiRegionAccessPointDetails: S3ControlClientTypes.MultiRegionAccessPointsAsyncResponse? = nil
        )
        {
            self.errorDetails = errorDetails
            self.multiRegionAccessPointDetails = multiRegionAccessPointDetails
        }
    }

}

extension S3ControlClientTypes.AwsLambdaTransformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionArn = "FunctionArn"
        case functionPayload = "FunctionPayload"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let functionArn = functionArn {
            try container.encode(functionArn, forKey: ClientRuntime.Key("FunctionArn"))
        }
        if let functionPayload = functionPayload {
            try container.encode(functionPayload, forKey: ClientRuntime.Key("FunctionPayload"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let functionPayloadDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionPayload)
        functionPayload = functionPayloadDecoded
    }
}

extension S3ControlClientTypes.AwsLambdaTransformation: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// Lambda function used to transform objects through an Object Lambda Access Point.
    public struct AwsLambdaTransformation: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Lambda function.
        /// This member is required.
        public var functionArn: Swift.String?
        /// Additional JSON that provides supplemental data to the Lambda function used to transform objects.
        public var functionPayload: Swift.String?

        public init(
            functionArn: Swift.String? = nil,
            functionPayload: Swift.String? = nil
        )
        {
            self.functionArn = functionArn
            self.functionPayload = functionPayload
        }
    }

}

extension BadRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<BadRequestExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BucketAlreadyExists {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The requested Outposts bucket name is not available. The bucket namespace is shared by all users of the Outposts in this Region. Select a different name and try again.
public struct BucketAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {
    public static var typeName: Swift.String { "BucketAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init() { }
}

extension BucketAlreadyOwnedByYou {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The Outposts bucket you tried to create already exists, and you own it.
public struct BucketAlreadyOwnedByYou: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {
    public static var typeName: Swift.String { "BucketAlreadyOwnedByYou" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init() { }
}

extension S3ControlClientTypes {
    public enum BucketCannedACL: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case authenticatedRead
        case `private`
        case publicRead
        case publicReadWrite
        case sdkUnknown(Swift.String)

        public static var allCases: [BucketCannedACL] {
            return [
                .authenticatedRead,
                .private,
                .publicRead,
                .publicReadWrite,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .authenticatedRead: return "authenticated-read"
            case .private: return "private"
            case .publicRead: return "public-read"
            case .publicReadWrite: return "public-read-write"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BucketCannedACL(rawValue: rawValue) ?? BucketCannedACL.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.BucketLevel: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activityMetrics = "ActivityMetrics"
        case advancedCostOptimizationMetrics = "AdvancedCostOptimizationMetrics"
        case advancedDataProtectionMetrics = "AdvancedDataProtectionMetrics"
        case detailedStatusCodesMetrics = "DetailedStatusCodesMetrics"
        case prefixLevel = "PrefixLevel"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let activityMetrics = activityMetrics {
            try container.encode(activityMetrics, forKey: ClientRuntime.Key("ActivityMetrics"))
        }
        if let advancedCostOptimizationMetrics = advancedCostOptimizationMetrics {
            try container.encode(advancedCostOptimizationMetrics, forKey: ClientRuntime.Key("AdvancedCostOptimizationMetrics"))
        }
        if let advancedDataProtectionMetrics = advancedDataProtectionMetrics {
            try container.encode(advancedDataProtectionMetrics, forKey: ClientRuntime.Key("AdvancedDataProtectionMetrics"))
        }
        if let detailedStatusCodesMetrics = detailedStatusCodesMetrics {
            try container.encode(detailedStatusCodesMetrics, forKey: ClientRuntime.Key("DetailedStatusCodesMetrics"))
        }
        if let prefixLevel = prefixLevel {
            try container.encode(prefixLevel, forKey: ClientRuntime.Key("PrefixLevel"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activityMetricsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ActivityMetrics.self, forKey: .activityMetrics)
        activityMetrics = activityMetricsDecoded
        let prefixLevelDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.PrefixLevel.self, forKey: .prefixLevel)
        prefixLevel = prefixLevelDecoded
        let advancedCostOptimizationMetricsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.AdvancedCostOptimizationMetrics.self, forKey: .advancedCostOptimizationMetrics)
        advancedCostOptimizationMetrics = advancedCostOptimizationMetricsDecoded
        let advancedDataProtectionMetricsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.AdvancedDataProtectionMetrics.self, forKey: .advancedDataProtectionMetrics)
        advancedDataProtectionMetrics = advancedDataProtectionMetricsDecoded
        let detailedStatusCodesMetricsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.DetailedStatusCodesMetrics.self, forKey: .detailedStatusCodesMetrics)
        detailedStatusCodesMetrics = detailedStatusCodesMetricsDecoded
    }
}

extension S3ControlClientTypes.BucketLevel: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// A container for the bucket-level configuration for Amazon S3 Storage Lens. For more information about S3 Storage Lens, see [Assessing your storage activity and usage with S3 Storage Lens](https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage_lens.html) in the Amazon S3 User Guide.
    public struct BucketLevel: Swift.Equatable {
        /// A container for the bucket-level activity metrics for S3 Storage Lens.
        public var activityMetrics: S3ControlClientTypes.ActivityMetrics?
        /// A container for bucket-level advanced cost-optimization metrics for S3 Storage Lens.
        public var advancedCostOptimizationMetrics: S3ControlClientTypes.AdvancedCostOptimizationMetrics?
        /// A container for bucket-level advanced data-protection metrics for S3 Storage Lens.
        public var advancedDataProtectionMetrics: S3ControlClientTypes.AdvancedDataProtectionMetrics?
        /// A container for bucket-level detailed status code metrics for S3 Storage Lens.
        public var detailedStatusCodesMetrics: S3ControlClientTypes.DetailedStatusCodesMetrics?
        /// A container for the prefix-level metrics for S3 Storage Lens.
        public var prefixLevel: S3ControlClientTypes.PrefixLevel?

        public init(
            activityMetrics: S3ControlClientTypes.ActivityMetrics? = nil,
            advancedCostOptimizationMetrics: S3ControlClientTypes.AdvancedCostOptimizationMetrics? = nil,
            advancedDataProtectionMetrics: S3ControlClientTypes.AdvancedDataProtectionMetrics? = nil,
            detailedStatusCodesMetrics: S3ControlClientTypes.DetailedStatusCodesMetrics? = nil,
            prefixLevel: S3ControlClientTypes.PrefixLevel? = nil
        )
        {
            self.activityMetrics = activityMetrics
            self.advancedCostOptimizationMetrics = advancedCostOptimizationMetrics
            self.advancedDataProtectionMetrics = advancedDataProtectionMetrics
            self.detailedStatusCodesMetrics = detailedStatusCodesMetrics
            self.prefixLevel = prefixLevel
        }
    }

}

extension S3ControlClientTypes {
    public enum BucketLocationConstraint: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case eu
        case apNortheast1
        case apSouth1
        case apSoutheast1
        case apSoutheast2
        case cnNorth1
        case euCentral1
        case euWest1
        case saEast1
        case usWest1
        case usWest2
        case sdkUnknown(Swift.String)

        public static var allCases: [BucketLocationConstraint] {
            return [
                .eu,
                .apNortheast1,
                .apSouth1,
                .apSoutheast1,
                .apSoutheast2,
                .cnNorth1,
                .euCentral1,
                .euWest1,
                .saEast1,
                .usWest1,
                .usWest2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .eu: return "EU"
            case .apNortheast1: return "ap-northeast-1"
            case .apSouth1: return "ap-south-1"
            case .apSoutheast1: return "ap-southeast-1"
            case .apSoutheast2: return "ap-southeast-2"
            case .cnNorth1: return "cn-north-1"
            case .euCentral1: return "eu-central-1"
            case .euWest1: return "eu-west-1"
            case .saEast1: return "sa-east-1"
            case .usWest1: return "us-west-1"
            case .usWest2: return "us-west-2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BucketLocationConstraint(rawValue: rawValue) ?? BucketLocationConstraint.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum BucketVersioningStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enabled
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [BucketVersioningStatus] {
            return [
                .enabled,
                .suspended,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enabled: return "Enabled"
            case .suspended: return "Suspended"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BucketVersioningStatus(rawValue: rawValue) ?? BucketVersioningStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.CloudWatchMetrics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isEnabled = "IsEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if isEnabled != false {
            try container.encode(isEnabled, forKey: ClientRuntime.Key("IsEnabled"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isEnabled) ?? false
        isEnabled = isEnabledDecoded
    }
}

extension S3ControlClientTypes.CloudWatchMetrics: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// A container for enabling Amazon CloudWatch publishing for S3 Storage Lens metrics. For more information about publishing S3 Storage Lens metrics to CloudWatch, see [Monitor S3 Storage Lens metrics in CloudWatch](https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage_lens_view_metrics_cloudwatch.html) in the Amazon S3 User Guide.
    public struct CloudWatchMetrics: Swift.Equatable {
        /// A container that indicates whether CloudWatch publishing for S3 Storage Lens metrics is enabled. A value of true indicates that CloudWatch publishing for S3 Storage Lens metrics is enabled.
        /// This member is required.
        public var isEnabled: Swift.Bool

        public init(
            isEnabled: Swift.Bool = false
        )
        {
            self.isEnabled = isEnabled
        }
    }

}

extension CreateAccessPointForObjectLambdaInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateAccessPointForObjectLambdaInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let configuration = configuration {
            try container.encode(configuration, forKey: ClientRuntime.Key("Configuration"))
        }
    }
}

extension CreateAccessPointForObjectLambdaInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension CreateAccessPointForObjectLambdaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v20180820/accesspointforobjectlambda/\(name.urlPercentEncoding())"
    }
}

public struct CreateAccessPointForObjectLambdaInput: Swift.Equatable {
    /// The Amazon Web Services account ID for owner of the specified Object Lambda Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// Object Lambda Access Point configuration as a JSON document.
    /// This member is required.
    public var configuration: S3ControlClientTypes.ObjectLambdaConfiguration?
    /// The name you want to assign to this Object Lambda Access Point.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        configuration: S3ControlClientTypes.ObjectLambdaConfiguration? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.configuration = configuration
        self.name = name
    }
}

struct CreateAccessPointForObjectLambdaInputBody: Swift.Equatable {
    let configuration: S3ControlClientTypes.ObjectLambdaConfiguration?
}

extension CreateAccessPointForObjectLambdaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ObjectLambdaConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension CreateAccessPointForObjectLambdaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAccessPointForObjectLambdaOutputBody = try responseDecoder.decode(responseBody: data)
            self.alias = output.alias
            self.objectLambdaAccessPointArn = output.objectLambdaAccessPointArn
        } else {
            self.alias = nil
            self.objectLambdaAccessPointArn = nil
        }
    }
}

public struct CreateAccessPointForObjectLambdaOutput: Swift.Equatable {
    /// The alias of the Object Lambda Access Point.
    public var alias: S3ControlClientTypes.ObjectLambdaAccessPointAlias?
    /// Specifies the ARN for the Object Lambda Access Point.
    public var objectLambdaAccessPointArn: Swift.String?

    public init(
        alias: S3ControlClientTypes.ObjectLambdaAccessPointAlias? = nil,
        objectLambdaAccessPointArn: Swift.String? = nil
    )
    {
        self.alias = alias
        self.objectLambdaAccessPointArn = objectLambdaAccessPointArn
    }
}

struct CreateAccessPointForObjectLambdaOutputBody: Swift.Equatable {
    let objectLambdaAccessPointArn: Swift.String?
    let alias: S3ControlClientTypes.ObjectLambdaAccessPointAlias?
}

extension CreateAccessPointForObjectLambdaOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case objectLambdaAccessPointArn = "ObjectLambdaAccessPointArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectLambdaAccessPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectLambdaAccessPointArn)
        objectLambdaAccessPointArn = objectLambdaAccessPointArnDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ObjectLambdaAccessPointAlias.self, forKey: .alias)
        alias = aliasDecoded
    }
}

enum CreateAccessPointForObjectLambdaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension CreateAccessPointInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateAccessPointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case bucketAccountId = "BucketAccountId"
        case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
        case vpcConfiguration = "VpcConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let bucket = bucket {
            try container.encode(bucket, forKey: ClientRuntime.Key("Bucket"))
        }
        if let bucketAccountId = bucketAccountId {
            try container.encode(bucketAccountId, forKey: ClientRuntime.Key("BucketAccountId"))
        }
        if let publicAccessBlockConfiguration = publicAccessBlockConfiguration {
            try container.encode(publicAccessBlockConfiguration, forKey: ClientRuntime.Key("PublicAccessBlockConfiguration"))
        }
        if let vpcConfiguration = vpcConfiguration {
            try container.encode(vpcConfiguration, forKey: ClientRuntime.Key("VpcConfiguration"))
        }
    }
}

extension CreateAccessPointInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension CreateAccessPointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v20180820/accesspoint/\(name.urlPercentEncoding())"
    }
}

public struct CreateAccessPointInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the account that owns the specified access point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the bucket that you want to associate this access point with. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?
    /// The Amazon Web Services account ID associated with the S3 bucket associated with this access point.
    public var bucketAccountId: Swift.String?
    /// The name you want to assign to this access point.
    /// This member is required.
    public var name: Swift.String?
    /// The PublicAccessBlock configuration that you want to apply to the access point.
    public var publicAccessBlockConfiguration: S3ControlClientTypes.PublicAccessBlockConfiguration?
    /// If you include this field, Amazon S3 restricts access to this access point to requests from the specified virtual private cloud (VPC). This is required for creating an access point for Amazon S3 on Outposts buckets.
    public var vpcConfiguration: S3ControlClientTypes.VpcConfiguration?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil,
        bucketAccountId: Swift.String? = nil,
        name: Swift.String? = nil,
        publicAccessBlockConfiguration: S3ControlClientTypes.PublicAccessBlockConfiguration? = nil,
        vpcConfiguration: S3ControlClientTypes.VpcConfiguration? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
        self.bucketAccountId = bucketAccountId
        self.name = name
        self.publicAccessBlockConfiguration = publicAccessBlockConfiguration
        self.vpcConfiguration = vpcConfiguration
    }
}

struct CreateAccessPointInputBody: Swift.Equatable {
    let bucket: Swift.String?
    let vpcConfiguration: S3ControlClientTypes.VpcConfiguration?
    let publicAccessBlockConfiguration: S3ControlClientTypes.PublicAccessBlockConfiguration?
    let bucketAccountId: Swift.String?
}

extension CreateAccessPointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case bucketAccountId = "BucketAccountId"
        case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
        case vpcConfiguration = "VpcConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let vpcConfigurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.VpcConfiguration.self, forKey: .vpcConfiguration)
        vpcConfiguration = vpcConfigurationDecoded
        let publicAccessBlockConfigurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.PublicAccessBlockConfiguration.self, forKey: .publicAccessBlockConfiguration)
        publicAccessBlockConfiguration = publicAccessBlockConfigurationDecoded
        let bucketAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketAccountId)
        bucketAccountId = bucketAccountIdDecoded
    }
}

extension CreateAccessPointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAccessPointOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessPointArn = output.accessPointArn
            self.alias = output.alias
        } else {
            self.accessPointArn = nil
            self.alias = nil
        }
    }
}

public struct CreateAccessPointOutput: Swift.Equatable {
    /// The ARN of the access point. This is only supported by Amazon S3 on Outposts.
    public var accessPointArn: Swift.String?
    /// The name or alias of the access point.
    public var alias: Swift.String?

    public init(
        accessPointArn: Swift.String? = nil,
        alias: Swift.String? = nil
    )
    {
        self.accessPointArn = accessPointArn
        self.alias = alias
    }
}

struct CreateAccessPointOutputBody: Swift.Equatable {
    let accessPointArn: Swift.String?
    let alias: Swift.String?
}

extension CreateAccessPointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPointArn = "AccessPointArn"
        case alias = "Alias"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPointArn)
        accessPointArn = accessPointArnDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
    }
}

enum CreateAccessPointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension S3ControlClientTypes.CreateBucketConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case locationConstraint = "LocationConstraint"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let locationConstraint = locationConstraint {
            try container.encode(locationConstraint, forKey: ClientRuntime.Key("LocationConstraint"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationConstraintDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.BucketLocationConstraint.self, forKey: .locationConstraint)
        locationConstraint = locationConstraintDecoded
    }
}

extension S3ControlClientTypes.CreateBucketConfiguration: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// The container for the bucket configuration. This is not supported by Amazon S3 on Outposts buckets.
    public struct CreateBucketConfiguration: Swift.Equatable {
        /// Specifies the Region where the bucket will be created. If you are creating a bucket on the US East (N. Virginia) Region (us-east-1), you do not need to specify the location. This is not supported by Amazon S3 on Outposts buckets.
        public var locationConstraint: S3ControlClientTypes.BucketLocationConstraint?

        public init(
            locationConstraint: S3ControlClientTypes.BucketLocationConstraint? = nil
        )
        {
            self.locationConstraint = locationConstraint
        }
    }

}

public struct CreateBucketInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBucketInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBucketInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateBucketOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let createBucketConfiguration = input.operationInput.createBucketConfiguration {
                let xmlEncoder = encoder as! XMLEncoder
                let createBucketConfigurationData = try xmlEncoder.encode(createBucketConfiguration, withRootKey: "CreateBucketConfiguration")
                let createBucketConfigurationBody = ClientRuntime.HttpBody.data(createBucketConfigurationData)
                input.builder.withBody(createBucketConfigurationBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let createBucketConfigurationData = "{}".data(using: .utf8)!
                    let createBucketConfigurationBody = ClientRuntime.HttpBody.data(createBucketConfigurationData)
                    input.builder.withBody(createBucketConfigurationBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBucketInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBucketOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateBucketInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateBucketInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createBucketConfiguration = "CreateBucketConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let createBucketConfiguration = createBucketConfiguration {
            try container.encode(createBucketConfiguration, forKey: ClientRuntime.Key("CreateBucketConfiguration"))
        }
    }
}

extension CreateBucketInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let acl = acl {
            items.add(Header(name: "x-amz-acl", value: Swift.String(acl.rawValue)))
        }
        if let grantFullControl = grantFullControl {
            items.add(Header(name: "x-amz-grant-full-control", value: Swift.String(grantFullControl)))
        }
        if let grantRead = grantRead {
            items.add(Header(name: "x-amz-grant-read", value: Swift.String(grantRead)))
        }
        if let grantReadACP = grantReadACP {
            items.add(Header(name: "x-amz-grant-read-acp", value: Swift.String(grantReadACP)))
        }
        if let grantWrite = grantWrite {
            items.add(Header(name: "x-amz-grant-write", value: Swift.String(grantWrite)))
        }
        if let grantWriteACP = grantWriteACP {
            items.add(Header(name: "x-amz-grant-write-acp", value: Swift.String(grantWriteACP)))
        }
        if let objectLockEnabledForBucket = objectLockEnabledForBucket {
            items.add(Header(name: "x-amz-bucket-object-lock-enabled", value: Swift.String(objectLockEnabledForBucket)))
        }
        if let outpostId = outpostId {
            items.add(Header(name: "x-amz-outpost-id", value: Swift.String(outpostId)))
        }
        return items
    }
}

extension CreateBucketInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())"
    }
}

public struct CreateBucketInput: Swift.Equatable {
    /// The canned ACL to apply to the bucket. This is not supported by Amazon S3 on Outposts buckets.
    public var acl: S3ControlClientTypes.BucketCannedACL?
    /// The name of the bucket.
    /// This member is required.
    public var bucket: Swift.String?
    /// The configuration information for the bucket. This is not supported by Amazon S3 on Outposts buckets.
    public var createBucketConfiguration: S3ControlClientTypes.CreateBucketConfiguration?
    /// Allows grantee the read, write, read ACP, and write ACP permissions on the bucket. This is not supported by Amazon S3 on Outposts buckets.
    public var grantFullControl: Swift.String?
    /// Allows grantee to list the objects in the bucket. This is not supported by Amazon S3 on Outposts buckets.
    public var grantRead: Swift.String?
    /// Allows grantee to read the bucket ACL. This is not supported by Amazon S3 on Outposts buckets.
    public var grantReadACP: Swift.String?
    /// Allows grantee to create, overwrite, and delete any object in the bucket. This is not supported by Amazon S3 on Outposts buckets.
    public var grantWrite: Swift.String?
    /// Allows grantee to write the ACL for the applicable bucket. This is not supported by Amazon S3 on Outposts buckets.
    public var grantWriteACP: Swift.String?
    /// Specifies whether you want S3 Object Lock to be enabled for the new bucket. This is not supported by Amazon S3 on Outposts buckets.
    public var objectLockEnabledForBucket: Swift.Bool?
    /// The ID of the Outposts where the bucket is being created. This ID is required by Amazon S3 on Outposts buckets.
    public var outpostId: Swift.String?

    public init(
        acl: S3ControlClientTypes.BucketCannedACL? = nil,
        bucket: Swift.String? = nil,
        createBucketConfiguration: S3ControlClientTypes.CreateBucketConfiguration? = nil,
        grantFullControl: Swift.String? = nil,
        grantRead: Swift.String? = nil,
        grantReadACP: Swift.String? = nil,
        grantWrite: Swift.String? = nil,
        grantWriteACP: Swift.String? = nil,
        objectLockEnabledForBucket: Swift.Bool? = nil,
        outpostId: Swift.String? = nil
    )
    {
        self.acl = acl
        self.bucket = bucket
        self.createBucketConfiguration = createBucketConfiguration
        self.grantFullControl = grantFullControl
        self.grantRead = grantRead
        self.grantReadACP = grantReadACP
        self.grantWrite = grantWrite
        self.grantWriteACP = grantWriteACP
        self.objectLockEnabledForBucket = objectLockEnabledForBucket
        self.outpostId = outpostId
    }
}

struct CreateBucketInputBody: Swift.Equatable {
    let createBucketConfiguration: S3ControlClientTypes.CreateBucketConfiguration?
}

extension CreateBucketInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createBucketConfiguration = "CreateBucketConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createBucketConfigurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.CreateBucketConfiguration.self, forKey: .createBucketConfiguration)
        createBucketConfiguration = createBucketConfigurationDecoded
    }
}

extension CreateBucketOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateBucketOutputBody = try responseDecoder.decode(responseBody: data)
            self.bucketArn = output.bucketArn
        } else {
            self.bucketArn = nil
        }
    }
}

public struct CreateBucketOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the bucket. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    public var bucketArn: Swift.String?
    /// The location of the bucket.
    public var location: Swift.String?

    public init(
        bucketArn: Swift.String? = nil,
        location: Swift.String? = nil
    )
    {
        self.bucketArn = bucketArn
        self.location = location
    }
}

struct CreateBucketOutputBody: Swift.Equatable {
    let bucketArn: Swift.String?
}

extension CreateBucketOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketArn = "BucketArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketArn)
        bucketArn = bucketArnDecoded
    }
}

enum CreateBucketOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "BucketAlreadyExists": return try await BucketAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "BucketAlreadyOwnedByYou": return try await BucketAlreadyOwnedByYou(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension CreateJobInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case confirmationRequired = "ConfirmationRequired"
        case description = "Description"
        case manifest = "Manifest"
        case manifestGenerator = "ManifestGenerator"
        case operation = "Operation"
        case priority = "Priority"
        case report = "Report"
        case roleArn = "RoleArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let clientRequestToken = clientRequestToken {
            try container.encode(clientRequestToken, forKey: ClientRuntime.Key("ClientRequestToken"))
        }
        if let confirmationRequired = confirmationRequired {
            try container.encode(confirmationRequired, forKey: ClientRuntime.Key("ConfirmationRequired"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let manifest = manifest {
            try container.encode(manifest, forKey: ClientRuntime.Key("Manifest"))
        }
        if let manifestGenerator = manifestGenerator {
            try container.encode(manifestGenerator, forKey: ClientRuntime.Key("ManifestGenerator"))
        }
        if let operation = operation {
            try container.encode(operation, forKey: ClientRuntime.Key("Operation"))
        }
        if let priority = priority {
            try container.encode(priority, forKey: ClientRuntime.Key("Priority"))
        }
        if let report = report {
            try container.encode(report, forKey: ClientRuntime.Key("Report"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: ClientRuntime.Key("RoleArn"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for s3tag0 in tags {
                try tagsContainer.encode(s3tag0, forKey: ClientRuntime.Key("member"))
            }
        }
    }
}

extension CreateJobInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension CreateJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/jobs"
    }
}

public struct CreateJobInput: Swift.Equatable {
    /// The Amazon Web Services account ID that creates the job.
    /// This member is required.
    public var accountId: Swift.String?
    /// An idempotency token to ensure that you don't accidentally submit the same request twice. You can use any string up to the maximum length.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// Indicates whether confirmation is required before Amazon S3 runs the job. Confirmation is only required for jobs created through the Amazon S3 console.
    public var confirmationRequired: Swift.Bool?
    /// A description for this job. You can use any string within the permitted length. Descriptions don't need to be unique and can be used for multiple jobs.
    public var description: Swift.String?
    /// Configuration parameters for the manifest.
    public var manifest: S3ControlClientTypes.JobManifest?
    /// The attribute container for the ManifestGenerator details. Jobs must be created with either a manifest file or a ManifestGenerator, but not both.
    public var manifestGenerator: S3ControlClientTypes.JobManifestGenerator?
    /// The action that you want this job to perform on every object listed in the manifest. For more information about the available actions, see [Operations](https://docs.aws.amazon.com/AmazonS3/latest/dev/batch-ops-actions.html) in the Amazon S3 User Guide.
    /// This member is required.
    public var operation: S3ControlClientTypes.JobOperation?
    /// The numerical priority for this job. Higher numbers indicate higher priority.
    /// This member is required.
    public var priority: Swift.Int?
    /// Configuration parameters for the optional job-completion report.
    /// This member is required.
    public var report: S3ControlClientTypes.JobReport?
    /// The Amazon Resource Name (ARN) for the Identity and Access Management (IAM) role that Batch Operations will use to run this job's action on every object in the manifest.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A set of tags to associate with the S3 Batch Operations job. This is an optional parameter.
    public var tags: [S3ControlClientTypes.S3Tag]?

    public init(
        accountId: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        confirmationRequired: Swift.Bool? = nil,
        description: Swift.String? = nil,
        manifest: S3ControlClientTypes.JobManifest? = nil,
        manifestGenerator: S3ControlClientTypes.JobManifestGenerator? = nil,
        operation: S3ControlClientTypes.JobOperation? = nil,
        priority: Swift.Int? = nil,
        report: S3ControlClientTypes.JobReport? = nil,
        roleArn: Swift.String? = nil,
        tags: [S3ControlClientTypes.S3Tag]? = nil
    )
    {
        self.accountId = accountId
        self.clientRequestToken = clientRequestToken
        self.confirmationRequired = confirmationRequired
        self.description = description
        self.manifest = manifest
        self.manifestGenerator = manifestGenerator
        self.operation = operation
        self.priority = priority
        self.report = report
        self.roleArn = roleArn
        self.tags = tags
    }
}

struct CreateJobInputBody: Swift.Equatable {
    let confirmationRequired: Swift.Bool?
    let operation: S3ControlClientTypes.JobOperation?
    let report: S3ControlClientTypes.JobReport?
    let clientRequestToken: Swift.String?
    let manifest: S3ControlClientTypes.JobManifest?
    let description: Swift.String?
    let priority: Swift.Int?
    let roleArn: Swift.String?
    let tags: [S3ControlClientTypes.S3Tag]?
    let manifestGenerator: S3ControlClientTypes.JobManifestGenerator?
}

extension CreateJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case confirmationRequired = "ConfirmationRequired"
        case description = "Description"
        case manifest = "Manifest"
        case manifestGenerator = "ManifestGenerator"
        case operation = "Operation"
        case priority = "Priority"
        case report = "Report"
        case roleArn = "RoleArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let confirmationRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .confirmationRequired) ?? nil
        confirmationRequired = confirmationRequiredDecoded
        let operationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobOperation.self, forKey: .operation)
        operation = operationDecoded
        let reportDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobReport.self, forKey: .report)
        report = reportDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let manifestDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobManifest.self, forKey: .manifest)
        manifest = manifestDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority) ?? nil
        priority = priorityDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([S3ControlClientTypes.S3Tag].self, forKey: .member)
                var tagsBuffer:[S3ControlClientTypes.S3Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [S3ControlClientTypes.S3Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let manifestGeneratorDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobManifestGenerator.self, forKey: .manifestGenerator)
        manifestGenerator = manifestGeneratorDecoded
    }
}

extension CreateJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct CreateJobOutput: Swift.Equatable {
    /// The ID for this job. Amazon S3 generates this ID automatically and returns it after a successful Create Job request.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct CreateJobOutputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension CreateJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

enum CreateJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "IdempotencyException": return try await IdempotencyException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension S3ControlClientTypes.CreateMultiRegionAccessPointInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case publicAccessBlock = "PublicAccessBlock"
        case regions = "Regions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let publicAccessBlock = publicAccessBlock {
            try container.encode(publicAccessBlock, forKey: ClientRuntime.Key("PublicAccessBlock"))
        }
        if let regions = regions {
            var regionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Regions"))
            for region0 in regions {
                try regionsContainer.encode(region0, forKey: ClientRuntime.Key("Region"))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let publicAccessBlockDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.PublicAccessBlockConfiguration.self, forKey: .publicAccessBlock)
        publicAccessBlock = publicAccessBlockDecoded
        if containerValues.contains(.regions) {
            struct KeyVal0{struct Region{}}
            let regionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Region>.CodingKeys.self, forKey: .regions)
            if let regionsWrappedContainer = regionsWrappedContainer {
                let regionsContainer = try regionsWrappedContainer.decodeIfPresent([S3ControlClientTypes.Region].self, forKey: .member)
                var regionsBuffer:[S3ControlClientTypes.Region]? = nil
                if let regionsContainer = regionsContainer {
                    regionsBuffer = [S3ControlClientTypes.Region]()
                    for structureContainer0 in regionsContainer {
                        regionsBuffer?.append(structureContainer0)
                    }
                }
                regions = regionsBuffer
            } else {
                regions = []
            }
        } else {
            regions = nil
        }
    }
}

extension CreateMultiRegionAccessPointInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes.CreateMultiRegionAccessPointInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateMultiRegionAccessPointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case details = "Details"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let clientToken = clientToken {
            try container.encode(clientToken, forKey: ClientRuntime.Key("ClientToken"))
        }
        if let details = details {
            try container.encode(details, forKey: ClientRuntime.Key("Details"))
        }
    }
}

extension CreateMultiRegionAccessPointInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension CreateMultiRegionAccessPointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/async-requests/mrap/create"
    }
}

extension S3ControlClientTypes {
    /// A container for the information associated with a [CreateMultiRegionAccessPoint](https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_CreateMultiRegionAccessPoint.html) request.
    public struct CreateMultiRegionAccessPointInput: Swift.Equatable {
        /// The name of the Multi-Region Access Point associated with this request.
        /// This member is required.
        public var name: Swift.String?
        /// The PublicAccessBlock configuration that you want to apply to this Amazon S3 account. You can enable the configuration options in any combination. For more information about when Amazon S3 considers a bucket or object public, see [The Meaning of "Public"](https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status) in the Amazon S3 User Guide. This data type is not supported for Amazon S3 on Outposts.
        public var publicAccessBlock: S3ControlClientTypes.PublicAccessBlockConfiguration?
        /// The buckets in different Regions that are associated with the Multi-Region Access Point.
        /// This member is required.
        public var regions: [S3ControlClientTypes.Region]?

        public init(
            name: Swift.String? = nil,
            publicAccessBlock: S3ControlClientTypes.PublicAccessBlockConfiguration? = nil,
            regions: [S3ControlClientTypes.Region]? = nil
        )
        {
            self.name = name
            self.publicAccessBlock = publicAccessBlock
            self.regions = regions
        }
    }

}

public struct CreateMultiRegionAccessPointInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the owner of the Multi-Region Access Point. The owner of the Multi-Region Access Point also must own the underlying buckets.
    /// This member is required.
    public var accountId: Swift.String?
    /// An idempotency token used to identify the request and guarantee that requests are unique.
    /// This member is required.
    public var clientToken: Swift.String?
    /// A container element containing details about the Multi-Region Access Point.
    /// This member is required.
    public var details: S3ControlClientTypes.CreateMultiRegionAccessPointInput?

    public init(
        accountId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        details: S3ControlClientTypes.CreateMultiRegionAccessPointInput? = nil
    )
    {
        self.accountId = accountId
        self.clientToken = clientToken
        self.details = details
    }
}

struct CreateMultiRegionAccessPointInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let details: S3ControlClientTypes.CreateMultiRegionAccessPointInput?
}

extension CreateMultiRegionAccessPointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case details = "Details"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.CreateMultiRegionAccessPointInput.self, forKey: .details)
        details = detailsDecoded
    }
}

extension CreateMultiRegionAccessPointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateMultiRegionAccessPointOutputBody = try responseDecoder.decode(responseBody: data)
            self.requestTokenARN = output.requestTokenARN
        } else {
            self.requestTokenARN = nil
        }
    }
}

public struct CreateMultiRegionAccessPointOutput: Swift.Equatable {
    /// The request token associated with the request. You can use this token with [DescribeMultiRegionAccessPointOperation](https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_DescribeMultiRegionAccessPointOperation.html) to determine the status of asynchronous requests.
    public var requestTokenARN: Swift.String?

    public init(
        requestTokenARN: Swift.String? = nil
    )
    {
        self.requestTokenARN = requestTokenARN
    }
}

struct CreateMultiRegionAccessPointOutputBody: Swift.Equatable {
    let requestTokenARN: Swift.String?
}

extension CreateMultiRegionAccessPointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestTokenARN = "RequestTokenARN"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestTokenARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestTokenARN)
        requestTokenARN = requestTokenARNDecoded
    }
}

enum CreateMultiRegionAccessPointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteAccessPointForObjectLambdaInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteAccessPointForObjectLambdaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v20180820/accesspointforobjectlambda/\(name.urlPercentEncoding())"
    }
}

public struct DeleteAccessPointForObjectLambdaInput: Swift.Equatable {
    /// The account ID for the account that owns the specified Object Lambda Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the access point you want to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

struct DeleteAccessPointForObjectLambdaInputBody: Swift.Equatable {
}

extension DeleteAccessPointForObjectLambdaInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAccessPointForObjectLambdaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAccessPointForObjectLambdaOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAccessPointForObjectLambdaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteAccessPointInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteAccessPointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v20180820/accesspoint/\(name.urlPercentEncoding())"
    }
}

public struct DeleteAccessPointInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the account that owns the specified access point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the access point you want to delete. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the access point accessed in the format arn:aws:s3-outposts:::outpost//accesspoint/. For example, to access the access point reports-ap through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/accesspoint/reports-ap. The value must be URL encoded.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

struct DeleteAccessPointInputBody: Swift.Equatable {
}

extension DeleteAccessPointInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAccessPointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAccessPointOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAccessPointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteAccessPointPolicyForObjectLambdaInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteAccessPointPolicyForObjectLambdaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v20180820/accesspointforobjectlambda/\(name.urlPercentEncoding())/policy"
    }
}

public struct DeleteAccessPointPolicyForObjectLambdaInput: Swift.Equatable {
    /// The account ID for the account that owns the specified Object Lambda Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the Object Lambda Access Point you want to delete the policy for.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

struct DeleteAccessPointPolicyForObjectLambdaInputBody: Swift.Equatable {
}

extension DeleteAccessPointPolicyForObjectLambdaInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAccessPointPolicyForObjectLambdaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAccessPointPolicyForObjectLambdaOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAccessPointPolicyForObjectLambdaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteAccessPointPolicyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteAccessPointPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v20180820/accesspoint/\(name.urlPercentEncoding())/policy"
    }
}

public struct DeleteAccessPointPolicyInput: Swift.Equatable {
    /// The account ID for the account that owns the specified access point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the access point whose policy you want to delete. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the access point accessed in the format arn:aws:s3-outposts:::outpost//accesspoint/. For example, to access the access point reports-ap through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/accesspoint/reports-ap. The value must be URL encoded.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

struct DeleteAccessPointPolicyInputBody: Swift.Equatable {
}

extension DeleteAccessPointPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAccessPointPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAccessPointPolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAccessPointPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteBucketInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteBucketInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())"
    }
}

public struct DeleteBucketInput: Swift.Equatable {
    /// The account ID that owns the Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    /// Specifies the bucket being deleted. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
    }
}

struct DeleteBucketInputBody: Swift.Equatable {
}

extension DeleteBucketInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBucketLifecycleConfigurationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteBucketLifecycleConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/lifecycleconfiguration"
    }
}

public struct DeleteBucketLifecycleConfigurationInput: Swift.Equatable {
    /// The account ID of the lifecycle configuration to delete.
    /// This member is required.
    public var accountId: Swift.String?
    /// Specifies the bucket. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
    }
}

struct DeleteBucketLifecycleConfigurationInputBody: Swift.Equatable {
}

extension DeleteBucketLifecycleConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBucketLifecycleConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteBucketLifecycleConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteBucketLifecycleConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteBucketOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteBucketOutput: Swift.Equatable {

    public init() { }
}

enum DeleteBucketOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteBucketPolicyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteBucketPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/policy"
    }
}

public struct DeleteBucketPolicyInput: Swift.Equatable {
    /// The account ID of the Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    /// Specifies the bucket. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
    }
}

struct DeleteBucketPolicyInputBody: Swift.Equatable {
}

extension DeleteBucketPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBucketPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteBucketPolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteBucketPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteBucketReplicationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteBucketReplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/replication"
    }
}

public struct DeleteBucketReplicationInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Outposts bucket to delete the replication configuration for.
    /// This member is required.
    public var accountId: Swift.String?
    /// Specifies the S3 on Outposts bucket to delete the replication configuration for. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
    }
}

struct DeleteBucketReplicationInputBody: Swift.Equatable {
}

extension DeleteBucketReplicationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBucketReplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteBucketReplicationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteBucketReplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteBucketTaggingInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteBucketTaggingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/tagging"
    }
}

public struct DeleteBucketTaggingInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Outposts bucket tag set to be removed.
    /// This member is required.
    public var accountId: Swift.String?
    /// The bucket ARN that has the tag set to be removed. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
    }
}

struct DeleteBucketTaggingInputBody: Swift.Equatable {
}

extension DeleteBucketTaggingInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBucketTaggingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteBucketTaggingOutput: Swift.Equatable {

    public init() { }
}

enum DeleteBucketTaggingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteJobTaggingInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteJobTaggingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/v20180820/jobs/\(jobId.urlPercentEncoding())/tagging"
    }
}

public struct DeleteJobTaggingInput: Swift.Equatable {
    /// The Amazon Web Services account ID associated with the S3 Batch Operations job.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID for the S3 Batch Operations job whose tags you want to delete.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.jobId = jobId
    }
}

struct DeleteJobTaggingInputBody: Swift.Equatable {
}

extension DeleteJobTaggingInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteJobTaggingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteJobTaggingOutput: Swift.Equatable {

    public init() { }
}

enum DeleteJobTaggingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension S3ControlClientTypes.DeleteMarkerReplication: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.DeleteMarkerReplicationStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension S3ControlClientTypes.DeleteMarkerReplication: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// Specifies whether S3 on Outposts replicates delete markers. If you specify a Filter element in your replication configuration, you must also include a DeleteMarkerReplication element. If your Filter includes a Tag element, the DeleteMarkerReplication element's Status child element must be set to Disabled, because S3 on Outposts does not support replicating delete markers for tag-based rules. For more information about delete marker replication, see [How delete operations affect replication](https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3OutpostsReplication.html#outposts-replication-what-is-replicated) in the Amazon S3 User Guide.
    public struct DeleteMarkerReplication: Swift.Equatable {
        /// Indicates whether to replicate delete markers.
        /// This member is required.
        public var status: S3ControlClientTypes.DeleteMarkerReplicationStatus?

        public init(
            status: S3ControlClientTypes.DeleteMarkerReplicationStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension S3ControlClientTypes {
    public enum DeleteMarkerReplicationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DeleteMarkerReplicationStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeleteMarkerReplicationStatus(rawValue: rawValue) ?? DeleteMarkerReplicationStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.DeleteMultiRegionAccessPointInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteMultiRegionAccessPointInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes.DeleteMultiRegionAccessPointInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension DeleteMultiRegionAccessPointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case details = "Details"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let clientToken = clientToken {
            try container.encode(clientToken, forKey: ClientRuntime.Key("ClientToken"))
        }
        if let details = details {
            try container.encode(details, forKey: ClientRuntime.Key("Details"))
        }
    }
}

extension DeleteMultiRegionAccessPointInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteMultiRegionAccessPointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/async-requests/mrap/delete"
    }
}

extension S3ControlClientTypes {
    /// A container for the information associated with a [DeleteMultiRegionAccessPoint](https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_DeleteMultiRegionAccessPoint.html) request.
    public struct DeleteMultiRegionAccessPointInput: Swift.Equatable {
        /// The name of the Multi-Region Access Point associated with this request.
        /// This member is required.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

public struct DeleteMultiRegionAccessPointInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the owner of the Multi-Region Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// An idempotency token used to identify the request and guarantee that requests are unique.
    /// This member is required.
    public var clientToken: Swift.String?
    /// A container element containing details about the Multi-Region Access Point.
    /// This member is required.
    public var details: S3ControlClientTypes.DeleteMultiRegionAccessPointInput?

    public init(
        accountId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        details: S3ControlClientTypes.DeleteMultiRegionAccessPointInput? = nil
    )
    {
        self.accountId = accountId
        self.clientToken = clientToken
        self.details = details
    }
}

struct DeleteMultiRegionAccessPointInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let details: S3ControlClientTypes.DeleteMultiRegionAccessPointInput?
}

extension DeleteMultiRegionAccessPointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case details = "Details"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.DeleteMultiRegionAccessPointInput.self, forKey: .details)
        details = detailsDecoded
    }
}

extension DeleteMultiRegionAccessPointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteMultiRegionAccessPointOutputBody = try responseDecoder.decode(responseBody: data)
            self.requestTokenARN = output.requestTokenARN
        } else {
            self.requestTokenARN = nil
        }
    }
}

public struct DeleteMultiRegionAccessPointOutput: Swift.Equatable {
    /// The request token associated with the request. You can use this token with [DescribeMultiRegionAccessPointOperation](https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_DescribeMultiRegionAccessPointOperation.html) to determine the status of asynchronous requests.
    public var requestTokenARN: Swift.String?

    public init(
        requestTokenARN: Swift.String? = nil
    )
    {
        self.requestTokenARN = requestTokenARN
    }
}

struct DeleteMultiRegionAccessPointOutputBody: Swift.Equatable {
    let requestTokenARN: Swift.String?
}

extension DeleteMultiRegionAccessPointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestTokenARN = "RequestTokenARN"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestTokenARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestTokenARN)
        requestTokenARN = requestTokenARNDecoded
    }
}

enum DeleteMultiRegionAccessPointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeletePublicAccessBlockInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeletePublicAccessBlockInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/configuration/publicAccessBlock"
    }
}

public struct DeletePublicAccessBlockInput: Swift.Equatable {
    /// The account ID for the Amazon Web Services account whose PublicAccessBlock configuration you want to remove.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

struct DeletePublicAccessBlockInputBody: Swift.Equatable {
}

extension DeletePublicAccessBlockInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeletePublicAccessBlockOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeletePublicAccessBlockOutput: Swift.Equatable {

    public init() { }
}

enum DeletePublicAccessBlockOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteStorageLensConfigurationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteStorageLensConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configId = configId else {
            return nil
        }
        return "/v20180820/storagelens/\(configId.urlPercentEncoding())"
    }
}

public struct DeleteStorageLensConfigurationInput: Swift.Equatable {
    /// The account ID of the requester.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID of the S3 Storage Lens configuration.
    /// This member is required.
    public var configId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        configId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.configId = configId
    }
}

struct DeleteStorageLensConfigurationInputBody: Swift.Equatable {
}

extension DeleteStorageLensConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteStorageLensConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteStorageLensConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteStorageLensConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteStorageLensConfigurationTaggingInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DeleteStorageLensConfigurationTaggingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configId = configId else {
            return nil
        }
        return "/v20180820/storagelens/\(configId.urlPercentEncoding())/tagging"
    }
}

public struct DeleteStorageLensConfigurationTaggingInput: Swift.Equatable {
    /// The account ID of the requester.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID of the S3 Storage Lens configuration.
    /// This member is required.
    public var configId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        configId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.configId = configId
    }
}

struct DeleteStorageLensConfigurationTaggingInputBody: Swift.Equatable {
}

extension DeleteStorageLensConfigurationTaggingInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteStorageLensConfigurationTaggingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteStorageLensConfigurationTaggingOutput: Swift.Equatable {

    public init() { }
}

enum DeleteStorageLensConfigurationTaggingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DescribeJobInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DescribeJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/v20180820/jobs/\(jobId.urlPercentEncoding())"
    }
}

public struct DescribeJobInput: Swift.Equatable {
    /// The Amazon Web Services account ID associated with the S3 Batch Operations job.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID for the job whose information you want to retrieve.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.jobId = jobId
    }
}

struct DescribeJobInputBody: Swift.Equatable {
}

extension DescribeJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct DescribeJobOutput: Swift.Equatable {
    /// Contains the configuration parameters and status for the job specified in the Describe Job request.
    public var job: S3ControlClientTypes.JobDescriptor?

    public init(
        job: S3ControlClientTypes.JobDescriptor? = nil
    )
    {
        self.job = job
    }
}

struct DescribeJobOutputBody: Swift.Equatable {
    let job: S3ControlClientTypes.JobDescriptor?
}

extension DescribeJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job = "Job"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobDescriptor.self, forKey: .job)
        job = jobDecoded
    }
}

enum DescribeJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DescribeMultiRegionAccessPointOperationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension DescribeMultiRegionAccessPointOperationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let requestTokenARN = requestTokenARN else {
            return nil
        }
        return "/v20180820/async-requests/mrap/\(requestTokenARN.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct DescribeMultiRegionAccessPointOperationInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the owner of the Multi-Region Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The request token associated with the request you want to know about. This request token is returned as part of the response when you make an asynchronous request. You provide this token to query about the status of the asynchronous action.
    /// This member is required.
    public var requestTokenARN: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        requestTokenARN: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.requestTokenARN = requestTokenARN
    }
}

struct DescribeMultiRegionAccessPointOperationInputBody: Swift.Equatable {
}

extension DescribeMultiRegionAccessPointOperationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeMultiRegionAccessPointOperationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeMultiRegionAccessPointOperationOutputBody = try responseDecoder.decode(responseBody: data)
            self.asyncOperation = output.asyncOperation
        } else {
            self.asyncOperation = nil
        }
    }
}

public struct DescribeMultiRegionAccessPointOperationOutput: Swift.Equatable {
    /// A container element containing the details of the asynchronous operation.
    public var asyncOperation: S3ControlClientTypes.AsyncOperation?

    public init(
        asyncOperation: S3ControlClientTypes.AsyncOperation? = nil
    )
    {
        self.asyncOperation = asyncOperation
    }
}

struct DescribeMultiRegionAccessPointOperationOutputBody: Swift.Equatable {
    let asyncOperation: S3ControlClientTypes.AsyncOperation?
}

extension DescribeMultiRegionAccessPointOperationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case asyncOperation = "AsyncOperation"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let asyncOperationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.AsyncOperation.self, forKey: .asyncOperation)
        asyncOperation = asyncOperationDecoded
    }
}

enum DescribeMultiRegionAccessPointOperationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension S3ControlClientTypes.Destination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessControlTranslation = "AccessControlTranslation"
        case account = "Account"
        case bucket = "Bucket"
        case encryptionConfiguration = "EncryptionConfiguration"
        case metrics = "Metrics"
        case replicationTime = "ReplicationTime"
        case storageClass = "StorageClass"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let accessControlTranslation = accessControlTranslation {
            try container.encode(accessControlTranslation, forKey: ClientRuntime.Key("AccessControlTranslation"))
        }
        if let account = account {
            try container.encode(account, forKey: ClientRuntime.Key("Account"))
        }
        if let bucket = bucket {
            try container.encode(bucket, forKey: ClientRuntime.Key("Bucket"))
        }
        if let encryptionConfiguration = encryptionConfiguration {
            try container.encode(encryptionConfiguration, forKey: ClientRuntime.Key("EncryptionConfiguration"))
        }
        if let metrics = metrics {
            try container.encode(metrics, forKey: ClientRuntime.Key("Metrics"))
        }
        if let replicationTime = replicationTime {
            try container.encode(replicationTime, forKey: ClientRuntime.Key("ReplicationTime"))
        }
        if let storageClass = storageClass {
            try container.encode(storageClass, forKey: ClientRuntime.Key("StorageClass"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .account)
        account = accountDecoded
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let replicationTimeDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ReplicationTime.self, forKey: .replicationTime)
        replicationTime = replicationTimeDecoded
        let accessControlTranslationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.AccessControlTranslation.self, forKey: .accessControlTranslation)
        accessControlTranslation = accessControlTranslationDecoded
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.EncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
        let metricsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.Metrics.self, forKey: .metrics)
        metrics = metricsDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ReplicationStorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
    }
}

extension S3ControlClientTypes.Destination: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// Specifies information about the replication destination bucket and its settings for an S3 on Outposts replication configuration.
    public struct Destination: Swift.Equatable {
        /// Specify this property only in a cross-account scenario (where the source and destination bucket owners are not the same), and you want to change replica ownership to the Amazon Web Services account that owns the destination bucket. If this property is not specified in the replication configuration, the replicas are owned by same Amazon Web Services account that owns the source object. This is not supported by Amazon S3 on Outposts buckets.
        public var accessControlTranslation: S3ControlClientTypes.AccessControlTranslation?
        /// The destination bucket owner's account ID.
        public var account: Swift.String?
        /// The Amazon Resource Name (ARN) of the access point for the destination bucket where you want S3 on Outposts to store the replication results.
        /// This member is required.
        public var bucket: Swift.String?
        /// A container that provides information about encryption. If SourceSelectionCriteria is specified, you must specify this element. This is not supported by Amazon S3 on Outposts buckets.
        public var encryptionConfiguration: S3ControlClientTypes.EncryptionConfiguration?
        /// A container that specifies replication metrics-related settings.
        public var metrics: S3ControlClientTypes.Metrics?
        /// A container that specifies S3 Replication Time Control (S3 RTC) settings, including whether S3 RTC is enabled and the time when all objects and operations on objects must be replicated. Must be specified together with a Metrics block. This is not supported by Amazon S3 on Outposts buckets.
        public var replicationTime: S3ControlClientTypes.ReplicationTime?
        /// The storage class to use when replicating objects. All objects stored on S3 on Outposts are stored in the OUTPOSTS storage class. S3 on Outposts uses the OUTPOSTS storage class to create the object replicas. Values other than OUTPOSTS are not supported by Amazon S3 on Outposts.
        public var storageClass: S3ControlClientTypes.ReplicationStorageClass?

        public init(
            accessControlTranslation: S3ControlClientTypes.AccessControlTranslation? = nil,
            account: Swift.String? = nil,
            bucket: Swift.String? = nil,
            encryptionConfiguration: S3ControlClientTypes.EncryptionConfiguration? = nil,
            metrics: S3ControlClientTypes.Metrics? = nil,
            replicationTime: S3ControlClientTypes.ReplicationTime? = nil,
            storageClass: S3ControlClientTypes.ReplicationStorageClass? = nil
        )
        {
            self.accessControlTranslation = accessControlTranslation
            self.account = account
            self.bucket = bucket
            self.encryptionConfiguration = encryptionConfiguration
            self.metrics = metrics
            self.replicationTime = replicationTime
            self.storageClass = storageClass
        }
    }

}

extension S3ControlClientTypes.DetailedStatusCodesMetrics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isEnabled = "IsEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if isEnabled != false {
            try container.encode(isEnabled, forKey: ClientRuntime.Key("IsEnabled"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isEnabled) ?? false
        isEnabled = isEnabledDecoded
    }
}

extension S3ControlClientTypes.DetailedStatusCodesMetrics: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// The container element for Amazon S3 Storage Lens detailed status code metrics. Detailed status code metrics generate metrics for HTTP status codes, such as 200 OK, 403 Forbidden, 503 Service Unavailable and others. For more information about S3 Storage Lens, see [Assessing your storage activity and usage with S3 Storage Lens](https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage_lens.html) in the Amazon S3 User Guide. For a complete list of S3 Storage Lens metrics, see [S3 Storage Lens metrics glossary](https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage_lens_metrics_glossary.html) in the Amazon S3 User Guide.
    public struct DetailedStatusCodesMetrics: Swift.Equatable {
        /// A container that indicates whether detailed status code metrics are enabled.
        public var isEnabled: Swift.Bool

        public init(
            isEnabled: Swift.Bool = false
        )
        {
            self.isEnabled = isEnabled
        }
    }

}

extension S3ControlClientTypes.EncryptionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicaKmsKeyID = "ReplicaKmsKeyID"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let replicaKmsKeyID = replicaKmsKeyID {
            try container.encode(replicaKmsKeyID, forKey: ClientRuntime.Key("ReplicaKmsKeyID"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicaKmsKeyIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicaKmsKeyID)
        replicaKmsKeyID = replicaKmsKeyIDDecoded
    }
}

extension S3ControlClientTypes.EncryptionConfiguration: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// Specifies encryption-related information for an Amazon S3 bucket that is a destination for replicated objects. This is not supported by Amazon S3 on Outposts buckets.
    public struct EncryptionConfiguration: Swift.Equatable {
        /// Specifies the ID of the customer managed KMS key that's stored in Key Management Service (KMS) for the destination bucket. This ID is either the Amazon Resource Name (ARN) for the KMS key or the alias ARN for the KMS key. Amazon S3 uses this KMS key to encrypt replica objects. Amazon S3 supports only symmetric encryption KMS keys. For more information, see [Symmetric encryption KMS keys](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#symmetric-cmks) in the Amazon Web Services Key Management Service Developer Guide.
        public var replicaKmsKeyID: Swift.String?

        public init(
            replicaKmsKeyID: Swift.String? = nil
        )
        {
            self.replicaKmsKeyID = replicaKmsKeyID
        }
    }

}

extension S3ControlClientTypes.EstablishedMultiRegionAccessPointPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let policy = policy {
            try container.encode(policy, forKey: ClientRuntime.Key("Policy"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension S3ControlClientTypes.EstablishedMultiRegionAccessPointPolicy: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// The last established access control policy for a Multi-Region Access Point. When you update the policy, the update is first listed as the proposed policy. After the update is finished and all Regions have been updated, the proposed policy is listed as the established policy. If both policies have the same version number, the proposed policy is the established policy.
    public struct EstablishedMultiRegionAccessPointPolicy: Swift.Equatable {
        /// The details of the last established policy.
        public var policy: Swift.String?

        public init(
            policy: Swift.String? = nil
        )
        {
            self.policy = policy
        }
    }

}

extension S3ControlClientTypes.Exclude: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case buckets = "Buckets"
        case regions = "Regions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let buckets = buckets {
            var bucketsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Buckets"))
            for s3bucketarnstring0 in buckets {
                try bucketsContainer.encode(s3bucketarnstring0, forKey: ClientRuntime.Key("Arn"))
            }
        }
        if let regions = regions {
            var regionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Regions"))
            for s3awsregion0 in regions {
                try regionsContainer.encode(s3awsregion0, forKey: ClientRuntime.Key("Region"))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.buckets) {
            struct KeyVal0{struct Arn{}}
            let bucketsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Arn>.CodingKeys.self, forKey: .buckets)
            if let bucketsWrappedContainer = bucketsWrappedContainer {
                let bucketsContainer = try bucketsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var bucketsBuffer:[Swift.String]? = nil
                if let bucketsContainer = bucketsContainer {
                    bucketsBuffer = [Swift.String]()
                    for stringContainer0 in bucketsContainer {
                        bucketsBuffer?.append(stringContainer0)
                    }
                }
                buckets = bucketsBuffer
            } else {
                buckets = []
            }
        } else {
            buckets = nil
        }
        if containerValues.contains(.regions) {
            struct KeyVal0{struct Region{}}
            let regionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Region>.CodingKeys.self, forKey: .regions)
            if let regionsWrappedContainer = regionsWrappedContainer {
                let regionsContainer = try regionsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var regionsBuffer:[Swift.String]? = nil
                if let regionsContainer = regionsContainer {
                    regionsBuffer = [Swift.String]()
                    for stringContainer0 in regionsContainer {
                        regionsBuffer?.append(stringContainer0)
                    }
                }
                regions = regionsBuffer
            } else {
                regions = []
            }
        } else {
            regions = nil
        }
    }
}

extension S3ControlClientTypes.Exclude: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// A container for what Amazon S3 Storage Lens will exclude.
    public struct Exclude: Swift.Equatable {
        /// A container for the S3 Storage Lens bucket excludes.
        public var buckets: [Swift.String]?
        /// A container for the S3 Storage Lens Region excludes.
        public var regions: [Swift.String]?

        public init(
            buckets: [Swift.String]? = nil,
            regions: [Swift.String]? = nil
        )
        {
            self.buckets = buckets
            self.regions = regions
        }
    }

}

extension S3ControlClientTypes.ExistingObjectReplication: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ExistingObjectReplicationStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension S3ControlClientTypes.ExistingObjectReplication: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// An optional configuration to replicate existing source bucket objects. This is not supported by Amazon S3 on Outposts buckets.
    public struct ExistingObjectReplication: Swift.Equatable {
        /// Specifies whether Amazon S3 replicates existing source bucket objects.
        /// This member is required.
        public var status: S3ControlClientTypes.ExistingObjectReplicationStatus?

        public init(
            status: S3ControlClientTypes.ExistingObjectReplicationStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension S3ControlClientTypes {
    public enum ExistingObjectReplicationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ExistingObjectReplicationStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExistingObjectReplicationStatus(rawValue: rawValue) ?? ExistingObjectReplicationStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum ExpirationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ExpirationStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExpirationStatus(rawValue: rawValue) ?? ExpirationStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum Format: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case parquet
        case sdkUnknown(Swift.String)

        public static var allCases: [Format] {
            return [
                .csv,
                .parquet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .parquet: return "Parquet"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Format(rawValue: rawValue) ?? Format.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.GeneratedManifestEncryption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ssekms = "SSE-KMS"
        case sses3 = "SSE-S3"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let ssekms = ssekms {
            try container.encode(ssekms, forKey: ClientRuntime.Key("SSE-KMS"))
        }
        if let sses3 = sses3 {
            try container.encode(sses3, forKey: ClientRuntime.Key("SSE-S3"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sses3Decoded = try containerValues.decodeIfPresent(S3ControlClientTypes.SSES3Encryption.self, forKey: .sses3)
        sses3 = sses3Decoded
        let ssekmsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.SSEKMSEncryption.self, forKey: .ssekms)
        ssekms = ssekmsDecoded
    }
}

extension S3ControlClientTypes.GeneratedManifestEncryption: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// The encryption configuration to use when storing the generated manifest.
    public struct GeneratedManifestEncryption: Swift.Equatable {
        /// Configuration details on how SSE-KMS is used to encrypt generated manifest objects.
        public var ssekms: S3ControlClientTypes.SSEKMSEncryption?
        /// Specifies the use of SSE-S3 to encrypt generated manifest objects.
        public var sses3: S3ControlClientTypes.SSES3Encryption?

        public init(
            ssekms: S3ControlClientTypes.SSEKMSEncryption? = nil,
            sses3: S3ControlClientTypes.SSES3Encryption? = nil
        )
        {
            self.ssekms = ssekms
            self.sses3 = sses3
        }
    }

}

extension S3ControlClientTypes {
    public enum GeneratedManifestFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case s3inventoryreportCsv20211130
        case sdkUnknown(Swift.String)

        public static var allCases: [GeneratedManifestFormat] {
            return [
                .s3inventoryreportCsv20211130,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .s3inventoryreportCsv20211130: return "S3InventoryReport_CSV_20211130"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GeneratedManifestFormat(rawValue: rawValue) ?? GeneratedManifestFormat.sdkUnknown(rawValue)
        }
    }
}

extension GetAccessPointConfigurationForObjectLambdaInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetAccessPointConfigurationForObjectLambdaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v20180820/accesspointforobjectlambda/\(name.urlPercentEncoding())/configuration"
    }
}

public struct GetAccessPointConfigurationForObjectLambdaInput: Swift.Equatable {
    /// The account ID for the account that owns the specified Object Lambda Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the Object Lambda Access Point you want to return the configuration for.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

struct GetAccessPointConfigurationForObjectLambdaInputBody: Swift.Equatable {
}

extension GetAccessPointConfigurationForObjectLambdaInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAccessPointConfigurationForObjectLambdaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAccessPointConfigurationForObjectLambdaOutputBody = try responseDecoder.decode(responseBody: data)
            self.configuration = output.configuration
        } else {
            self.configuration = nil
        }
    }
}

public struct GetAccessPointConfigurationForObjectLambdaOutput: Swift.Equatable {
    /// Object Lambda Access Point configuration document.
    public var configuration: S3ControlClientTypes.ObjectLambdaConfiguration?

    public init(
        configuration: S3ControlClientTypes.ObjectLambdaConfiguration? = nil
    )
    {
        self.configuration = configuration
    }
}

struct GetAccessPointConfigurationForObjectLambdaOutputBody: Swift.Equatable {
    let configuration: S3ControlClientTypes.ObjectLambdaConfiguration?
}

extension GetAccessPointConfigurationForObjectLambdaOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ObjectLambdaConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

enum GetAccessPointConfigurationForObjectLambdaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetAccessPointForObjectLambdaInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetAccessPointForObjectLambdaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v20180820/accesspointforobjectlambda/\(name.urlPercentEncoding())"
    }
}

public struct GetAccessPointForObjectLambdaInput: Swift.Equatable {
    /// The account ID for the account that owns the specified Object Lambda Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the Object Lambda Access Point.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

struct GetAccessPointForObjectLambdaInputBody: Swift.Equatable {
}

extension GetAccessPointForObjectLambdaInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAccessPointForObjectLambdaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAccessPointForObjectLambdaOutputBody = try responseDecoder.decode(responseBody: data)
            self.alias = output.alias
            self.creationDate = output.creationDate
            self.name = output.name
            self.publicAccessBlockConfiguration = output.publicAccessBlockConfiguration
        } else {
            self.alias = nil
            self.creationDate = nil
            self.name = nil
            self.publicAccessBlockConfiguration = nil
        }
    }
}

public struct GetAccessPointForObjectLambdaOutput: Swift.Equatable {
    /// The alias of the Object Lambda Access Point.
    public var alias: S3ControlClientTypes.ObjectLambdaAccessPointAlias?
    /// The date and time when the specified Object Lambda Access Point was created.
    public var creationDate: ClientRuntime.Date?
    /// The name of the Object Lambda Access Point.
    public var name: Swift.String?
    /// Configuration to block all public access. This setting is turned on and can not be edited.
    public var publicAccessBlockConfiguration: S3ControlClientTypes.PublicAccessBlockConfiguration?

    public init(
        alias: S3ControlClientTypes.ObjectLambdaAccessPointAlias? = nil,
        creationDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        publicAccessBlockConfiguration: S3ControlClientTypes.PublicAccessBlockConfiguration? = nil
    )
    {
        self.alias = alias
        self.creationDate = creationDate
        self.name = name
        self.publicAccessBlockConfiguration = publicAccessBlockConfiguration
    }
}

struct GetAccessPointForObjectLambdaOutputBody: Swift.Equatable {
    let name: Swift.String?
    let publicAccessBlockConfiguration: S3ControlClientTypes.PublicAccessBlockConfiguration?
    let creationDate: ClientRuntime.Date?
    let alias: S3ControlClientTypes.ObjectLambdaAccessPointAlias?
}

extension GetAccessPointForObjectLambdaOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case creationDate = "CreationDate"
        case name = "Name"
        case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let publicAccessBlockConfigurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.PublicAccessBlockConfiguration.self, forKey: .publicAccessBlockConfiguration)
        publicAccessBlockConfiguration = publicAccessBlockConfigurationDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationDate)
        creationDate = creationDateDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ObjectLambdaAccessPointAlias.self, forKey: .alias)
        alias = aliasDecoded
    }
}

enum GetAccessPointForObjectLambdaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetAccessPointInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetAccessPointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v20180820/accesspoint/\(name.urlPercentEncoding())"
    }
}

public struct GetAccessPointInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the account that owns the specified access point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the access point whose configuration information you want to retrieve. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the access point accessed in the format arn:aws:s3-outposts:::outpost//accesspoint/. For example, to access the access point reports-ap through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/accesspoint/reports-ap. The value must be URL encoded.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

struct GetAccessPointInputBody: Swift.Equatable {
}

extension GetAccessPointInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAccessPointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAccessPointOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessPointArn = output.accessPointArn
            self.alias = output.alias
            self.bucket = output.bucket
            self.bucketAccountId = output.bucketAccountId
            self.creationDate = output.creationDate
            self.endpoints = output.endpoints
            self.name = output.name
            self.networkOrigin = output.networkOrigin
            self.publicAccessBlockConfiguration = output.publicAccessBlockConfiguration
            self.vpcConfiguration = output.vpcConfiguration
        } else {
            self.accessPointArn = nil
            self.alias = nil
            self.bucket = nil
            self.bucketAccountId = nil
            self.creationDate = nil
            self.endpoints = nil
            self.name = nil
            self.networkOrigin = nil
            self.publicAccessBlockConfiguration = nil
            self.vpcConfiguration = nil
        }
    }
}

public struct GetAccessPointOutput: Swift.Equatable {
    /// The ARN of the access point.
    public var accessPointArn: Swift.String?
    /// The name or alias of the access point.
    public var alias: Swift.String?
    /// The name of the bucket associated with the specified access point.
    public var bucket: Swift.String?
    /// The Amazon Web Services account ID associated with the S3 bucket associated with this access point.
    public var bucketAccountId: Swift.String?
    /// The date and time when the specified access point was created.
    public var creationDate: ClientRuntime.Date?
    /// The VPC endpoint for the access point.
    public var endpoints: [Swift.String:Swift.String]?
    /// The name of the specified access point.
    public var name: Swift.String?
    /// Indicates whether this access point allows access from the public internet. If VpcConfiguration is specified for this access point, then NetworkOrigin is VPC, and the access point doesn't allow access from the public internet. Otherwise, NetworkOrigin is Internet, and the access point allows access from the public internet, subject to the access point and bucket access policies. This will always be true for an Amazon S3 on Outposts access point
    public var networkOrigin: S3ControlClientTypes.NetworkOrigin?
    /// The PublicAccessBlock configuration that you want to apply to this Amazon S3 account. You can enable the configuration options in any combination. For more information about when Amazon S3 considers a bucket or object public, see [The Meaning of "Public"](https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status) in the Amazon S3 User Guide. This data type is not supported for Amazon S3 on Outposts.
    public var publicAccessBlockConfiguration: S3ControlClientTypes.PublicAccessBlockConfiguration?
    /// Contains the virtual private cloud (VPC) configuration for the specified access point. This element is empty if this access point is an Amazon S3 on Outposts access point that is used by other Amazon Web Services.
    public var vpcConfiguration: S3ControlClientTypes.VpcConfiguration?

    public init(
        accessPointArn: Swift.String? = nil,
        alias: Swift.String? = nil,
        bucket: Swift.String? = nil,
        bucketAccountId: Swift.String? = nil,
        creationDate: ClientRuntime.Date? = nil,
        endpoints: [Swift.String:Swift.String]? = nil,
        name: Swift.String? = nil,
        networkOrigin: S3ControlClientTypes.NetworkOrigin? = nil,
        publicAccessBlockConfiguration: S3ControlClientTypes.PublicAccessBlockConfiguration? = nil,
        vpcConfiguration: S3ControlClientTypes.VpcConfiguration? = nil
    )
    {
        self.accessPointArn = accessPointArn
        self.alias = alias
        self.bucket = bucket
        self.bucketAccountId = bucketAccountId
        self.creationDate = creationDate
        self.endpoints = endpoints
        self.name = name
        self.networkOrigin = networkOrigin
        self.publicAccessBlockConfiguration = publicAccessBlockConfiguration
        self.vpcConfiguration = vpcConfiguration
    }
}

struct GetAccessPointOutputBody: Swift.Equatable {
    let name: Swift.String?
    let bucket: Swift.String?
    let networkOrigin: S3ControlClientTypes.NetworkOrigin?
    let vpcConfiguration: S3ControlClientTypes.VpcConfiguration?
    let publicAccessBlockConfiguration: S3ControlClientTypes.PublicAccessBlockConfiguration?
    let creationDate: ClientRuntime.Date?
    let alias: Swift.String?
    let accessPointArn: Swift.String?
    let endpoints: [Swift.String:Swift.String]?
    let bucketAccountId: Swift.String?
}

extension GetAccessPointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPointArn = "AccessPointArn"
        case alias = "Alias"
        case bucket = "Bucket"
        case bucketAccountId = "BucketAccountId"
        case creationDate = "CreationDate"
        case endpoints = "Endpoints"
        case name = "Name"
        case networkOrigin = "NetworkOrigin"
        case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
        case vpcConfiguration = "VpcConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let networkOriginDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.NetworkOrigin.self, forKey: .networkOrigin)
        networkOrigin = networkOriginDecoded
        let vpcConfigurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.VpcConfiguration.self, forKey: .vpcConfiguration)
        vpcConfiguration = vpcConfigurationDecoded
        let publicAccessBlockConfigurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.PublicAccessBlockConfiguration.self, forKey: .publicAccessBlockConfiguration)
        publicAccessBlockConfiguration = publicAccessBlockConfigurationDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationDate)
        creationDate = creationDateDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let accessPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPointArn)
        accessPointArn = accessPointArnDecoded
        if containerValues.contains(.endpoints) {
            struct KeyVal0{struct key{}; struct value{}}
            let endpointsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: ClientRuntime.MapEntry<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .endpoints)
            if let endpointsWrappedContainer = endpointsWrappedContainer {
                let endpointsContainer = try endpointsWrappedContainer.decodeIfPresent([ClientRuntime.MapKeyValue<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var endpointsBuffer: [Swift.String:Swift.String]? = nil
                if let endpointsContainer = endpointsContainer {
                    endpointsBuffer = [Swift.String:Swift.String]()
                    for stringContainer0 in endpointsContainer {
                        endpointsBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                endpoints = endpointsBuffer
            } else {
                endpoints = [:]
            }
        } else {
            endpoints = nil
        }
        let bucketAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketAccountId)
        bucketAccountId = bucketAccountIdDecoded
    }
}

enum GetAccessPointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetAccessPointPolicyForObjectLambdaInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetAccessPointPolicyForObjectLambdaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v20180820/accesspointforobjectlambda/\(name.urlPercentEncoding())/policy"
    }
}

public struct GetAccessPointPolicyForObjectLambdaInput: Swift.Equatable {
    /// The account ID for the account that owns the specified Object Lambda Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the Object Lambda Access Point.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

struct GetAccessPointPolicyForObjectLambdaInputBody: Swift.Equatable {
}

extension GetAccessPointPolicyForObjectLambdaInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAccessPointPolicyForObjectLambdaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAccessPointPolicyForObjectLambdaOutputBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetAccessPointPolicyForObjectLambdaOutput: Swift.Equatable {
    /// Object Lambda Access Point resource policy document.
    public var policy: Swift.String?

    public init(
        policy: Swift.String? = nil
    )
    {
        self.policy = policy
    }
}

struct GetAccessPointPolicyForObjectLambdaOutputBody: Swift.Equatable {
    let policy: Swift.String?
}

extension GetAccessPointPolicyForObjectLambdaOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum GetAccessPointPolicyForObjectLambdaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetAccessPointPolicyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetAccessPointPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v20180820/accesspoint/\(name.urlPercentEncoding())/policy"
    }
}

public struct GetAccessPointPolicyInput: Swift.Equatable {
    /// The account ID for the account that owns the specified access point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the access point whose policy you want to retrieve. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the access point accessed in the format arn:aws:s3-outposts:::outpost//accesspoint/. For example, to access the access point reports-ap through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/accesspoint/reports-ap. The value must be URL encoded.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

struct GetAccessPointPolicyInputBody: Swift.Equatable {
}

extension GetAccessPointPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAccessPointPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAccessPointPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetAccessPointPolicyOutput: Swift.Equatable {
    /// The access point policy associated with the specified access point.
    public var policy: Swift.String?

    public init(
        policy: Swift.String? = nil
    )
    {
        self.policy = policy
    }
}

struct GetAccessPointPolicyOutputBody: Swift.Equatable {
    let policy: Swift.String?
}

extension GetAccessPointPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum GetAccessPointPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetAccessPointPolicyStatusForObjectLambdaInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetAccessPointPolicyStatusForObjectLambdaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v20180820/accesspointforobjectlambda/\(name.urlPercentEncoding())/policyStatus"
    }
}

public struct GetAccessPointPolicyStatusForObjectLambdaInput: Swift.Equatable {
    /// The account ID for the account that owns the specified Object Lambda Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the Object Lambda Access Point.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

struct GetAccessPointPolicyStatusForObjectLambdaInputBody: Swift.Equatable {
}

extension GetAccessPointPolicyStatusForObjectLambdaInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAccessPointPolicyStatusForObjectLambdaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAccessPointPolicyStatusForObjectLambdaOutputBody = try responseDecoder.decode(responseBody: data)
            self.policyStatus = output.policyStatus
        } else {
            self.policyStatus = nil
        }
    }
}

public struct GetAccessPointPolicyStatusForObjectLambdaOutput: Swift.Equatable {
    /// Indicates whether this access point policy is public. For more information about how Amazon S3 evaluates policies to determine whether they are public, see [The Meaning of "Public"](https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status) in the Amazon S3 User Guide.
    public var policyStatus: S3ControlClientTypes.PolicyStatus?

    public init(
        policyStatus: S3ControlClientTypes.PolicyStatus? = nil
    )
    {
        self.policyStatus = policyStatus
    }
}

struct GetAccessPointPolicyStatusForObjectLambdaOutputBody: Swift.Equatable {
    let policyStatus: S3ControlClientTypes.PolicyStatus?
}

extension GetAccessPointPolicyStatusForObjectLambdaOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyStatus = "PolicyStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyStatusDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.PolicyStatus.self, forKey: .policyStatus)
        policyStatus = policyStatusDecoded
    }
}

enum GetAccessPointPolicyStatusForObjectLambdaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetAccessPointPolicyStatusInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetAccessPointPolicyStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v20180820/accesspoint/\(name.urlPercentEncoding())/policyStatus"
    }
}

public struct GetAccessPointPolicyStatusInput: Swift.Equatable {
    /// The account ID for the account that owns the specified access point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the access point whose policy status you want to retrieve.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

struct GetAccessPointPolicyStatusInputBody: Swift.Equatable {
}

extension GetAccessPointPolicyStatusInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAccessPointPolicyStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAccessPointPolicyStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.policyStatus = output.policyStatus
        } else {
            self.policyStatus = nil
        }
    }
}

public struct GetAccessPointPolicyStatusOutput: Swift.Equatable {
    /// Indicates the current policy status of the specified access point.
    public var policyStatus: S3ControlClientTypes.PolicyStatus?

    public init(
        policyStatus: S3ControlClientTypes.PolicyStatus? = nil
    )
    {
        self.policyStatus = policyStatus
    }
}

struct GetAccessPointPolicyStatusOutputBody: Swift.Equatable {
    let policyStatus: S3ControlClientTypes.PolicyStatus?
}

extension GetAccessPointPolicyStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyStatus = "PolicyStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyStatusDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.PolicyStatus.self, forKey: .policyStatus)
        policyStatus = policyStatusDecoded
    }
}

enum GetAccessPointPolicyStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetBucketInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetBucketInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())"
    }
}

public struct GetBucketInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    /// Specifies the bucket. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
    }
}

struct GetBucketInputBody: Swift.Equatable {
}

extension GetBucketInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetBucketLifecycleConfigurationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetBucketLifecycleConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/lifecycleconfiguration"
    }
}

public struct GetBucketLifecycleConfigurationInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    /// The Amazon Resource Name (ARN) of the bucket. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
    }
}

struct GetBucketLifecycleConfigurationInputBody: Swift.Equatable {
}

extension GetBucketLifecycleConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetBucketLifecycleConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBucketLifecycleConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.rules = output.rules
        } else {
            self.rules = nil
        }
    }
}

public struct GetBucketLifecycleConfigurationOutput: Swift.Equatable {
    /// Container for the lifecycle rule of the Outposts bucket.
    public var rules: [S3ControlClientTypes.LifecycleRule]?

    public init(
        rules: [S3ControlClientTypes.LifecycleRule]? = nil
    )
    {
        self.rules = rules
    }
}

struct GetBucketLifecycleConfigurationOutputBody: Swift.Equatable {
    let rules: [S3ControlClientTypes.LifecycleRule]?
}

extension GetBucketLifecycleConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rules = "Rules"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.rules) {
            struct KeyVal0{struct Rule{}}
            let rulesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Rule>.CodingKeys.self, forKey: .rules)
            if let rulesWrappedContainer = rulesWrappedContainer {
                let rulesContainer = try rulesWrappedContainer.decodeIfPresent([S3ControlClientTypes.LifecycleRule].self, forKey: .member)
                var rulesBuffer:[S3ControlClientTypes.LifecycleRule]? = nil
                if let rulesContainer = rulesContainer {
                    rulesBuffer = [S3ControlClientTypes.LifecycleRule]()
                    for structureContainer0 in rulesContainer {
                        rulesBuffer?.append(structureContainer0)
                    }
                }
                rules = rulesBuffer
            } else {
                rules = []
            }
        } else {
            rules = nil
        }
    }
}

enum GetBucketLifecycleConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetBucketOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBucketOutputBody = try responseDecoder.decode(responseBody: data)
            self.bucket = output.bucket
            self.creationDate = output.creationDate
            self.publicAccessBlockEnabled = output.publicAccessBlockEnabled
        } else {
            self.bucket = nil
            self.creationDate = nil
            self.publicAccessBlockEnabled = false
        }
    }
}

public struct GetBucketOutput: Swift.Equatable {
    /// The Outposts bucket requested.
    public var bucket: Swift.String?
    /// The creation date of the Outposts bucket.
    public var creationDate: ClientRuntime.Date?
    ///
    public var publicAccessBlockEnabled: Swift.Bool

    public init(
        bucket: Swift.String? = nil,
        creationDate: ClientRuntime.Date? = nil,
        publicAccessBlockEnabled: Swift.Bool = false
    )
    {
        self.bucket = bucket
        self.creationDate = creationDate
        self.publicAccessBlockEnabled = publicAccessBlockEnabled
    }
}

struct GetBucketOutputBody: Swift.Equatable {
    let bucket: Swift.String?
    let publicAccessBlockEnabled: Swift.Bool
    let creationDate: ClientRuntime.Date?
}

extension GetBucketOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case creationDate = "CreationDate"
        case publicAccessBlockEnabled = "PublicAccessBlockEnabled"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let publicAccessBlockEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publicAccessBlockEnabled) ?? false
        publicAccessBlockEnabled = publicAccessBlockEnabledDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

enum GetBucketOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetBucketPolicyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetBucketPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/policy"
    }
}

public struct GetBucketPolicyInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    /// Specifies the bucket. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
    }
}

struct GetBucketPolicyInputBody: Swift.Equatable {
}

extension GetBucketPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetBucketPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBucketPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetBucketPolicyOutput: Swift.Equatable {
    /// The policy of the Outposts bucket.
    public var policy: Swift.String?

    public init(
        policy: Swift.String? = nil
    )
    {
        self.policy = policy
    }
}

struct GetBucketPolicyOutputBody: Swift.Equatable {
    let policy: Swift.String?
}

extension GetBucketPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum GetBucketPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetBucketReplicationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetBucketReplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/replication"
    }
}

public struct GetBucketReplicationInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    /// Specifies the bucket to get the replication information for. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
    }
}

struct GetBucketReplicationInputBody: Swift.Equatable {
}

extension GetBucketReplicationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetBucketReplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBucketReplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.replicationConfiguration = output.replicationConfiguration
        } else {
            self.replicationConfiguration = nil
        }
    }
}

public struct GetBucketReplicationOutput: Swift.Equatable {
    /// A container for one or more replication rules. A replication configuration must have at least one rule and you can add up to 100 rules. The maximum size of a replication configuration is 128 KB.
    public var replicationConfiguration: S3ControlClientTypes.ReplicationConfiguration?

    public init(
        replicationConfiguration: S3ControlClientTypes.ReplicationConfiguration? = nil
    )
    {
        self.replicationConfiguration = replicationConfiguration
    }
}

struct GetBucketReplicationOutputBody: Swift.Equatable {
    let replicationConfiguration: S3ControlClientTypes.ReplicationConfiguration?
}

extension GetBucketReplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationConfiguration = "ReplicationConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ReplicationConfiguration.self, forKey: .replicationConfiguration)
        replicationConfiguration = replicationConfigurationDecoded
    }
}

enum GetBucketReplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetBucketTaggingInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetBucketTaggingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/tagging"
    }
}

public struct GetBucketTaggingInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    /// Specifies the bucket. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
    }
}

struct GetBucketTaggingInputBody: Swift.Equatable {
}

extension GetBucketTaggingInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetBucketTaggingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBucketTaggingOutputBody = try responseDecoder.decode(responseBody: data)
            self.tagSet = output.tagSet
        } else {
            self.tagSet = nil
        }
    }
}

public struct GetBucketTaggingOutput: Swift.Equatable {
    /// The tags set of the Outposts bucket.
    /// This member is required.
    public var tagSet: [S3ControlClientTypes.S3Tag]?

    public init(
        tagSet: [S3ControlClientTypes.S3Tag]? = nil
    )
    {
        self.tagSet = tagSet
    }
}

struct GetBucketTaggingOutputBody: Swift.Equatable {
    let tagSet: [S3ControlClientTypes.S3Tag]?
}

extension GetBucketTaggingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagSet = "TagSet"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.tagSet) {
            struct KeyVal0{struct member{}}
            let tagSetWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tagSet)
            if let tagSetWrappedContainer = tagSetWrappedContainer {
                let tagSetContainer = try tagSetWrappedContainer.decodeIfPresent([S3ControlClientTypes.S3Tag].self, forKey: .member)
                var tagSetBuffer:[S3ControlClientTypes.S3Tag]? = nil
                if let tagSetContainer = tagSetContainer {
                    tagSetBuffer = [S3ControlClientTypes.S3Tag]()
                    for structureContainer0 in tagSetContainer {
                        tagSetBuffer?.append(structureContainer0)
                    }
                }
                tagSet = tagSetBuffer
            } else {
                tagSet = []
            }
        } else {
            tagSet = nil
        }
    }
}

enum GetBucketTaggingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetBucketVersioningInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetBucketVersioningInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/versioning"
    }
}

public struct GetBucketVersioningInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the S3 on Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    /// The S3 on Outposts bucket to return the versioning state for.
    /// This member is required.
    public var bucket: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
    }
}

struct GetBucketVersioningInputBody: Swift.Equatable {
}

extension GetBucketVersioningInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetBucketVersioningOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBucketVersioningOutputBody = try responseDecoder.decode(responseBody: data)
            self.mfaDelete = output.mfaDelete
            self.status = output.status
        } else {
            self.mfaDelete = nil
            self.status = nil
        }
    }
}

public struct GetBucketVersioningOutput: Swift.Equatable {
    /// Specifies whether MFA delete is enabled in the bucket versioning configuration. This element is returned only if the bucket has been configured with MFA delete. If MFA delete has never been configured for the bucket, this element is not returned.
    public var mfaDelete: S3ControlClientTypes.MFADeleteStatus?
    /// The versioning state of the S3 on Outposts bucket.
    public var status: S3ControlClientTypes.BucketVersioningStatus?

    public init(
        mfaDelete: S3ControlClientTypes.MFADeleteStatus? = nil,
        status: S3ControlClientTypes.BucketVersioningStatus? = nil
    )
    {
        self.mfaDelete = mfaDelete
        self.status = status
    }
}

struct GetBucketVersioningOutputBody: Swift.Equatable {
    let status: S3ControlClientTypes.BucketVersioningStatus?
    let mfaDelete: S3ControlClientTypes.MFADeleteStatus?
}

extension GetBucketVersioningOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mfaDelete = "MfaDelete"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.BucketVersioningStatus.self, forKey: .status)
        status = statusDecoded
        let mfaDeleteDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.MFADeleteStatus.self, forKey: .mfaDelete)
        mfaDelete = mfaDeleteDecoded
    }
}

enum GetBucketVersioningOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetJobTaggingInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetJobTaggingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/v20180820/jobs/\(jobId.urlPercentEncoding())/tagging"
    }
}

public struct GetJobTaggingInput: Swift.Equatable {
    /// The Amazon Web Services account ID associated with the S3 Batch Operations job.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID for the S3 Batch Operations job whose tags you want to retrieve.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.jobId = jobId
    }
}

struct GetJobTaggingInputBody: Swift.Equatable {
}

extension GetJobTaggingInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetJobTaggingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetJobTaggingOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct GetJobTaggingOutput: Swift.Equatable {
    /// The set of tags associated with the S3 Batch Operations job.
    public var tags: [S3ControlClientTypes.S3Tag]?

    public init(
        tags: [S3ControlClientTypes.S3Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct GetJobTaggingOutputBody: Swift.Equatable {
    let tags: [S3ControlClientTypes.S3Tag]?
}

extension GetJobTaggingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([S3ControlClientTypes.S3Tag].self, forKey: .member)
                var tagsBuffer:[S3ControlClientTypes.S3Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [S3ControlClientTypes.S3Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

enum GetJobTaggingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetMultiRegionAccessPointInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetMultiRegionAccessPointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v20180820/mrap/instances/\(name.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct GetMultiRegionAccessPointInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the owner of the Multi-Region Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the Multi-Region Access Point whose configuration information you want to receive. The name of the Multi-Region Access Point is different from the alias. For more information about the distinction between the name and the alias of an Multi-Region Access Point, see [Managing Multi-Region Access Points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/CreatingMultiRegionAccessPoints.html#multi-region-access-point-naming) in the Amazon S3 User Guide.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

struct GetMultiRegionAccessPointInputBody: Swift.Equatable {
}

extension GetMultiRegionAccessPointInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMultiRegionAccessPointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMultiRegionAccessPointOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessPoint = output.accessPoint
        } else {
            self.accessPoint = nil
        }
    }
}

public struct GetMultiRegionAccessPointOutput: Swift.Equatable {
    /// A container element containing the details of the requested Multi-Region Access Point.
    public var accessPoint: S3ControlClientTypes.MultiRegionAccessPointReport?

    public init(
        accessPoint: S3ControlClientTypes.MultiRegionAccessPointReport? = nil
    )
    {
        self.accessPoint = accessPoint
    }
}

struct GetMultiRegionAccessPointOutputBody: Swift.Equatable {
    let accessPoint: S3ControlClientTypes.MultiRegionAccessPointReport?
}

extension GetMultiRegionAccessPointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPoint = "AccessPoint"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPointDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.MultiRegionAccessPointReport.self, forKey: .accessPoint)
        accessPoint = accessPointDecoded
    }
}

enum GetMultiRegionAccessPointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetMultiRegionAccessPointPolicyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetMultiRegionAccessPointPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v20180820/mrap/instances/\(name.urlPercentEncoding(encodeForwardSlash: false))/policy"
    }
}

public struct GetMultiRegionAccessPointPolicyInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the owner of the Multi-Region Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// Specifies the Multi-Region Access Point. The name of the Multi-Region Access Point is different from the alias. For more information about the distinction between the name and the alias of an Multi-Region Access Point, see [Managing Multi-Region Access Points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/CreatingMultiRegionAccessPoints.html#multi-region-access-point-naming) in the Amazon S3 User Guide.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

struct GetMultiRegionAccessPointPolicyInputBody: Swift.Equatable {
}

extension GetMultiRegionAccessPointPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMultiRegionAccessPointPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMultiRegionAccessPointPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetMultiRegionAccessPointPolicyOutput: Swift.Equatable {
    /// The policy associated with the specified Multi-Region Access Point.
    public var policy: S3ControlClientTypes.MultiRegionAccessPointPolicyDocument?

    public init(
        policy: S3ControlClientTypes.MultiRegionAccessPointPolicyDocument? = nil
    )
    {
        self.policy = policy
    }
}

struct GetMultiRegionAccessPointPolicyOutputBody: Swift.Equatable {
    let policy: S3ControlClientTypes.MultiRegionAccessPointPolicyDocument?
}

extension GetMultiRegionAccessPointPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.MultiRegionAccessPointPolicyDocument.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum GetMultiRegionAccessPointPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetMultiRegionAccessPointPolicyStatusInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetMultiRegionAccessPointPolicyStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v20180820/mrap/instances/\(name.urlPercentEncoding(encodeForwardSlash: false))/policystatus"
    }
}

public struct GetMultiRegionAccessPointPolicyStatusInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the owner of the Multi-Region Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// Specifies the Multi-Region Access Point. The name of the Multi-Region Access Point is different from the alias. For more information about the distinction between the name and the alias of an Multi-Region Access Point, see [Managing Multi-Region Access Points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/CreatingMultiRegionAccessPoints.html#multi-region-access-point-naming) in the Amazon S3 User Guide.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
    }
}

struct GetMultiRegionAccessPointPolicyStatusInputBody: Swift.Equatable {
}

extension GetMultiRegionAccessPointPolicyStatusInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMultiRegionAccessPointPolicyStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMultiRegionAccessPointPolicyStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.established = output.established
        } else {
            self.established = nil
        }
    }
}

public struct GetMultiRegionAccessPointPolicyStatusOutput: Swift.Equatable {
    /// Indicates whether this access point policy is public. For more information about how Amazon S3 evaluates policies to determine whether they are public, see [The Meaning of "Public"](https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status) in the Amazon S3 User Guide.
    public var established: S3ControlClientTypes.PolicyStatus?

    public init(
        established: S3ControlClientTypes.PolicyStatus? = nil
    )
    {
        self.established = established
    }
}

struct GetMultiRegionAccessPointPolicyStatusOutputBody: Swift.Equatable {
    let established: S3ControlClientTypes.PolicyStatus?
}

extension GetMultiRegionAccessPointPolicyStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case established = "Established"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let establishedDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.PolicyStatus.self, forKey: .established)
        established = establishedDecoded
    }
}

enum GetMultiRegionAccessPointPolicyStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetMultiRegionAccessPointRoutesInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetMultiRegionAccessPointRoutesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let mrap = mrap else {
            return nil
        }
        return "/v20180820/mrap/instances/\(mrap.urlPercentEncoding(encodeForwardSlash: false))/routes"
    }
}

public struct GetMultiRegionAccessPointRoutesInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the owner of the Multi-Region Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The Multi-Region Access Point ARN.
    /// This member is required.
    public var mrap: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        mrap: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.mrap = mrap
    }
}

struct GetMultiRegionAccessPointRoutesInputBody: Swift.Equatable {
}

extension GetMultiRegionAccessPointRoutesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMultiRegionAccessPointRoutesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMultiRegionAccessPointRoutesOutputBody = try responseDecoder.decode(responseBody: data)
            self.mrap = output.mrap
            self.routes = output.routes
        } else {
            self.mrap = nil
            self.routes = nil
        }
    }
}

public struct GetMultiRegionAccessPointRoutesOutput: Swift.Equatable {
    /// The Multi-Region Access Point ARN.
    public var mrap: Swift.String?
    /// The different routes that make up the route configuration. Active routes return a value of 100, and passive routes return a value of 0.
    public var routes: [S3ControlClientTypes.MultiRegionAccessPointRoute]?

    public init(
        mrap: Swift.String? = nil,
        routes: [S3ControlClientTypes.MultiRegionAccessPointRoute]? = nil
    )
    {
        self.mrap = mrap
        self.routes = routes
    }
}

struct GetMultiRegionAccessPointRoutesOutputBody: Swift.Equatable {
    let mrap: Swift.String?
    let routes: [S3ControlClientTypes.MultiRegionAccessPointRoute]?
}

extension GetMultiRegionAccessPointRoutesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mrap = "Mrap"
        case routes = "Routes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mrapDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mrap)
        mrap = mrapDecoded
        if containerValues.contains(.routes) {
            struct KeyVal0{struct Route{}}
            let routesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Route>.CodingKeys.self, forKey: .routes)
            if let routesWrappedContainer = routesWrappedContainer {
                let routesContainer = try routesWrappedContainer.decodeIfPresent([S3ControlClientTypes.MultiRegionAccessPointRoute].self, forKey: .member)
                var routesBuffer:[S3ControlClientTypes.MultiRegionAccessPointRoute]? = nil
                if let routesContainer = routesContainer {
                    routesBuffer = [S3ControlClientTypes.MultiRegionAccessPointRoute]()
                    for structureContainer0 in routesContainer {
                        routesBuffer?.append(structureContainer0)
                    }
                }
                routes = routesBuffer
            } else {
                routes = []
            }
        } else {
            routes = nil
        }
    }
}

enum GetMultiRegionAccessPointRoutesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetPublicAccessBlockInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetPublicAccessBlockInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/configuration/publicAccessBlock"
    }
}

public struct GetPublicAccessBlockInput: Swift.Equatable {
    /// The account ID for the Amazon Web Services account whose PublicAccessBlock configuration you want to retrieve.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

struct GetPublicAccessBlockInputBody: Swift.Equatable {
}

extension GetPublicAccessBlockInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPublicAccessBlockOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: S3ControlClientTypes.PublicAccessBlockConfiguration = try responseDecoder.decode(responseBody: data)
            self.publicAccessBlockConfiguration = output
        } else {
            self.publicAccessBlockConfiguration = nil
        }
    }
}

public struct GetPublicAccessBlockOutput: Swift.Equatable {
    /// The PublicAccessBlock configuration currently in effect for this Amazon Web Services account.
    public var publicAccessBlockConfiguration: S3ControlClientTypes.PublicAccessBlockConfiguration?

    public init(
        publicAccessBlockConfiguration: S3ControlClientTypes.PublicAccessBlockConfiguration? = nil
    )
    {
        self.publicAccessBlockConfiguration = publicAccessBlockConfiguration
    }
}

struct GetPublicAccessBlockOutputBody: Swift.Equatable {
    let publicAccessBlockConfiguration: S3ControlClientTypes.PublicAccessBlockConfiguration?
}

extension GetPublicAccessBlockOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicAccessBlockConfigurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.PublicAccessBlockConfiguration.self, forKey: .publicAccessBlockConfiguration)
        publicAccessBlockConfiguration = publicAccessBlockConfigurationDecoded
    }
}

enum GetPublicAccessBlockOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchPublicAccessBlockConfiguration": return try await NoSuchPublicAccessBlockConfiguration(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetStorageLensConfigurationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetStorageLensConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configId = configId else {
            return nil
        }
        return "/v20180820/storagelens/\(configId.urlPercentEncoding())"
    }
}

public struct GetStorageLensConfigurationInput: Swift.Equatable {
    /// The account ID of the requester.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID of the Amazon S3 Storage Lens configuration.
    /// This member is required.
    public var configId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        configId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.configId = configId
    }
}

struct GetStorageLensConfigurationInputBody: Swift.Equatable {
}

extension GetStorageLensConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetStorageLensConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: S3ControlClientTypes.StorageLensConfiguration = try responseDecoder.decode(responseBody: data)
            self.storageLensConfiguration = output
        } else {
            self.storageLensConfiguration = nil
        }
    }
}

public struct GetStorageLensConfigurationOutput: Swift.Equatable {
    /// The S3 Storage Lens configuration requested.
    public var storageLensConfiguration: S3ControlClientTypes.StorageLensConfiguration?

    public init(
        storageLensConfiguration: S3ControlClientTypes.StorageLensConfiguration? = nil
    )
    {
        self.storageLensConfiguration = storageLensConfiguration
    }
}

struct GetStorageLensConfigurationOutputBody: Swift.Equatable {
    let storageLensConfiguration: S3ControlClientTypes.StorageLensConfiguration?
}

extension GetStorageLensConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case storageLensConfiguration = "StorageLensConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageLensConfigurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.StorageLensConfiguration.self, forKey: .storageLensConfiguration)
        storageLensConfiguration = storageLensConfigurationDecoded
    }
}

enum GetStorageLensConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetStorageLensConfigurationTaggingInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension GetStorageLensConfigurationTaggingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configId = configId else {
            return nil
        }
        return "/v20180820/storagelens/\(configId.urlPercentEncoding())/tagging"
    }
}

public struct GetStorageLensConfigurationTaggingInput: Swift.Equatable {
    /// The account ID of the requester.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID of the Amazon S3 Storage Lens configuration.
    /// This member is required.
    public var configId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        configId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.configId = configId
    }
}

struct GetStorageLensConfigurationTaggingInputBody: Swift.Equatable {
}

extension GetStorageLensConfigurationTaggingInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetStorageLensConfigurationTaggingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetStorageLensConfigurationTaggingOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct GetStorageLensConfigurationTaggingOutput: Swift.Equatable {
    /// The tags of S3 Storage Lens configuration requested.
    public var tags: [S3ControlClientTypes.StorageLensTag]?

    public init(
        tags: [S3ControlClientTypes.StorageLensTag]? = nil
    )
    {
        self.tags = tags
    }
}

struct GetStorageLensConfigurationTaggingOutputBody: Swift.Equatable {
    let tags: [S3ControlClientTypes.StorageLensTag]?
}

extension GetStorageLensConfigurationTaggingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([S3ControlClientTypes.StorageLensTag].self, forKey: .member)
                var tagsBuffer:[S3ControlClientTypes.StorageLensTag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [S3ControlClientTypes.StorageLensTag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

enum GetStorageLensConfigurationTaggingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension IdempotencyException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<IdempotencyExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct IdempotencyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IdempotencyException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct IdempotencyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension IdempotencyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension S3ControlClientTypes.Include: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case buckets = "Buckets"
        case regions = "Regions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let buckets = buckets {
            var bucketsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Buckets"))
            for s3bucketarnstring0 in buckets {
                try bucketsContainer.encode(s3bucketarnstring0, forKey: ClientRuntime.Key("Arn"))
            }
        }
        if let regions = regions {
            var regionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Regions"))
            for s3awsregion0 in regions {
                try regionsContainer.encode(s3awsregion0, forKey: ClientRuntime.Key("Region"))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.buckets) {
            struct KeyVal0{struct Arn{}}
            let bucketsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Arn>.CodingKeys.self, forKey: .buckets)
            if let bucketsWrappedContainer = bucketsWrappedContainer {
                let bucketsContainer = try bucketsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var bucketsBuffer:[Swift.String]? = nil
                if let bucketsContainer = bucketsContainer {
                    bucketsBuffer = [Swift.String]()
                    for stringContainer0 in bucketsContainer {
                        bucketsBuffer?.append(stringContainer0)
                    }
                }
                buckets = bucketsBuffer
            } else {
                buckets = []
            }
        } else {
            buckets = nil
        }
        if containerValues.contains(.regions) {
            struct KeyVal0{struct Region{}}
            let regionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Region>.CodingKeys.self, forKey: .regions)
            if let regionsWrappedContainer = regionsWrappedContainer {
                let regionsContainer = try regionsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var regionsBuffer:[Swift.String]? = nil
                if let regionsContainer = regionsContainer {
                    regionsBuffer = [Swift.String]()
                    for stringContainer0 in regionsContainer {
                        regionsBuffer?.append(stringContainer0)
                    }
                }
                regions = regionsBuffer
            } else {
                regions = []
            }
        } else {
            regions = nil
        }
    }
}

extension S3ControlClientTypes.Include: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// A container for what Amazon S3 Storage Lens configuration includes.
    public struct Include: Swift.Equatable {
        /// A container for the S3 Storage Lens bucket includes.
        public var buckets: [Swift.String]?
        /// A container for the S3 Storage Lens Region includes.
        public var regions: [Swift.String]?

        public init(
            buckets: [Swift.String]? = nil,
            regions: [Swift.String]? = nil
        )
        {
            self.buckets = buckets
            self.regions = regions
        }
    }

}

extension InternalServiceException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InternalServiceExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct InternalServiceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServiceException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServiceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServiceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidNextTokenExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct InvalidNextTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNextTokenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidRequestExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension S3ControlClientTypes.JobDescriptor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case confirmationRequired = "ConfirmationRequired"
        case creationTime = "CreationTime"
        case description = "Description"
        case failureReasons = "FailureReasons"
        case generatedManifestDescriptor = "GeneratedManifestDescriptor"
        case jobArn = "JobArn"
        case jobId = "JobId"
        case manifest = "Manifest"
        case manifestGenerator = "ManifestGenerator"
        case operation = "Operation"
        case priority = "Priority"
        case progressSummary = "ProgressSummary"
        case report = "Report"
        case roleArn = "RoleArn"
        case status = "Status"
        case statusUpdateReason = "StatusUpdateReason"
        case suspendedCause = "SuspendedCause"
        case suspendedDate = "SuspendedDate"
        case terminationDate = "TerminationDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let confirmationRequired = confirmationRequired {
            try container.encode(confirmationRequired, forKey: ClientRuntime.Key("ConfirmationRequired"))
        }
        if let creationTime = creationTime {
            try container.encodeTimestamp(creationTime, format: .dateTime, forKey: ClientRuntime.Key("CreationTime"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let failureReasons = failureReasons {
            var failureReasonsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("FailureReasons"))
            for jobfailure0 in failureReasons {
                try failureReasonsContainer.encode(jobfailure0, forKey: ClientRuntime.Key("member"))
            }
        }
        if let generatedManifestDescriptor = generatedManifestDescriptor {
            try container.encode(generatedManifestDescriptor, forKey: ClientRuntime.Key("GeneratedManifestDescriptor"))
        }
        if let jobArn = jobArn {
            try container.encode(jobArn, forKey: ClientRuntime.Key("JobArn"))
        }
        if let jobId = jobId {
            try container.encode(jobId, forKey: ClientRuntime.Key("JobId"))
        }
        if let manifest = manifest {
            try container.encode(manifest, forKey: ClientRuntime.Key("Manifest"))
        }
        if let manifestGenerator = manifestGenerator {
            try container.encode(manifestGenerator, forKey: ClientRuntime.Key("ManifestGenerator"))
        }
        if let operation = operation {
            try container.encode(operation, forKey: ClientRuntime.Key("Operation"))
        }
        if priority != 0 {
            try container.encode(priority, forKey: ClientRuntime.Key("Priority"))
        }
        if let progressSummary = progressSummary {
            try container.encode(progressSummary, forKey: ClientRuntime.Key("ProgressSummary"))
        }
        if let report = report {
            try container.encode(report, forKey: ClientRuntime.Key("Report"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: ClientRuntime.Key("RoleArn"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let statusUpdateReason = statusUpdateReason {
            try container.encode(statusUpdateReason, forKey: ClientRuntime.Key("StatusUpdateReason"))
        }
        if let suspendedCause = suspendedCause {
            try container.encode(suspendedCause, forKey: ClientRuntime.Key("SuspendedCause"))
        }
        if let suspendedDate = suspendedDate {
            try container.encodeTimestamp(suspendedDate, format: .dateTime, forKey: ClientRuntime.Key("SuspendedDate"))
        }
        if let terminationDate = terminationDate {
            try container.encodeTimestamp(terminationDate, format: .dateTime, forKey: ClientRuntime.Key("TerminationDate"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let confirmationRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .confirmationRequired) ?? nil
        confirmationRequired = confirmationRequiredDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let jobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobArn)
        jobArn = jobArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
        let manifestDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobManifest.self, forKey: .manifest)
        manifest = manifestDecoded
        let operationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobOperation.self, forKey: .operation)
        operation = operationDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority) ?? 0
        priority = priorityDecoded
        let progressSummaryDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobProgressSummary.self, forKey: .progressSummary)
        progressSummary = progressSummaryDecoded
        let statusUpdateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusUpdateReason)
        statusUpdateReason = statusUpdateReasonDecoded
        if containerValues.contains(.failureReasons) {
            struct KeyVal0{struct member{}}
            let failureReasonsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .failureReasons)
            if let failureReasonsWrappedContainer = failureReasonsWrappedContainer {
                let failureReasonsContainer = try failureReasonsWrappedContainer.decodeIfPresent([S3ControlClientTypes.JobFailure].self, forKey: .member)
                var failureReasonsBuffer:[S3ControlClientTypes.JobFailure]? = nil
                if let failureReasonsContainer = failureReasonsContainer {
                    failureReasonsBuffer = [S3ControlClientTypes.JobFailure]()
                    for structureContainer0 in failureReasonsContainer {
                        failureReasonsBuffer?.append(structureContainer0)
                    }
                }
                failureReasons = failureReasonsBuffer
            } else {
                failureReasons = []
            }
        } else {
            failureReasons = nil
        }
        let reportDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobReport.self, forKey: .report)
        report = reportDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let terminationDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .terminationDate)
        terminationDate = terminationDateDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let suspendedDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .suspendedDate)
        suspendedDate = suspendedDateDecoded
        let suspendedCauseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suspendedCause)
        suspendedCause = suspendedCauseDecoded
        let manifestGeneratorDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobManifestGenerator.self, forKey: .manifestGenerator)
        manifestGenerator = manifestGeneratorDecoded
        let generatedManifestDescriptorDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3GeneratedManifestDescriptor.self, forKey: .generatedManifestDescriptor)
        generatedManifestDescriptor = generatedManifestDescriptorDecoded
    }
}

extension S3ControlClientTypes.JobDescriptor: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// A container element for the job configuration and status information returned by a Describe Job request.
    public struct JobDescriptor: Swift.Equatable {
        /// Indicates whether confirmation is required before Amazon S3 begins running the specified job. Confirmation is required only for jobs created through the Amazon S3 console.
        public var confirmationRequired: Swift.Bool?
        /// A timestamp indicating when this job was created.
        public var creationTime: ClientRuntime.Date?
        /// The description for this job, if one was provided in this job's Create Job request.
        public var description: Swift.String?
        /// If the specified job failed, this field contains information describing the failure.
        public var failureReasons: [S3ControlClientTypes.JobFailure]?
        /// The attribute of the JobDescriptor containing details about the job's generated manifest.
        public var generatedManifestDescriptor: S3ControlClientTypes.S3GeneratedManifestDescriptor?
        /// The Amazon Resource Name (ARN) for this job.
        public var jobArn: Swift.String?
        /// The ID for the specified job.
        public var jobId: Swift.String?
        /// The configuration information for the specified job's manifest object.
        public var manifest: S3ControlClientTypes.JobManifest?
        /// The manifest generator that was used to generate a job manifest for this job.
        public var manifestGenerator: S3ControlClientTypes.JobManifestGenerator?
        /// The operation that the specified job is configured to run on the objects listed in the manifest.
        public var operation: S3ControlClientTypes.JobOperation?
        /// The priority of the specified job.
        public var priority: Swift.Int
        /// Describes the total number of tasks that the specified job has run, the number of tasks that succeeded, and the number of tasks that failed.
        public var progressSummary: S3ControlClientTypes.JobProgressSummary?
        /// Contains the configuration information for the job-completion report if you requested one in the Create Job request.
        public var report: S3ControlClientTypes.JobReport?
        /// The Amazon Resource Name (ARN) for the Identity and Access Management (IAM) role assigned to run the tasks for this job.
        public var roleArn: Swift.String?
        /// The current status of the specified job.
        public var status: S3ControlClientTypes.JobStatus?
        /// The reason for updating the job.
        public var statusUpdateReason: Swift.String?
        /// The reason why the specified job was suspended. A job is only suspended if you create it through the Amazon S3 console. When you create the job, it enters the Suspended state to await confirmation before running. After you confirm the job, it automatically exits the Suspended state.
        public var suspendedCause: Swift.String?
        /// The timestamp when this job was suspended, if it has been suspended.
        public var suspendedDate: ClientRuntime.Date?
        /// A timestamp indicating when this job terminated. A job's termination date is the date and time when it succeeded, failed, or was canceled.
        public var terminationDate: ClientRuntime.Date?

        public init(
            confirmationRequired: Swift.Bool? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            failureReasons: [S3ControlClientTypes.JobFailure]? = nil,
            generatedManifestDescriptor: S3ControlClientTypes.S3GeneratedManifestDescriptor? = nil,
            jobArn: Swift.String? = nil,
            jobId: Swift.String? = nil,
            manifest: S3ControlClientTypes.JobManifest? = nil,
            manifestGenerator: S3ControlClientTypes.JobManifestGenerator? = nil,
            operation: S3ControlClientTypes.JobOperation? = nil,
            priority: Swift.Int = 0,
            progressSummary: S3ControlClientTypes.JobProgressSummary? = nil,
            report: S3ControlClientTypes.JobReport? = nil,
            roleArn: Swift.String? = nil,
            status: S3ControlClientTypes.JobStatus? = nil,
            statusUpdateReason: Swift.String? = nil,
            suspendedCause: Swift.String? = nil,
            suspendedDate: ClientRuntime.Date? = nil,
            terminationDate: ClientRuntime.Date? = nil
        )
        {
            self.confirmationRequired = confirmationRequired
            self.creationTime = creationTime
            self.description = description
            self.failureReasons = failureReasons
            self.generatedManifestDescriptor = generatedManifestDescriptor
            self.jobArn = jobArn
            self.jobId = jobId
            self.manifest = manifest
            self.manifestGenerator = manifestGenerator
            self.operation = operation
            self.priority = priority
            self.progressSummary = progressSummary
            self.report = report
            self.roleArn = roleArn
            self.status = status
            self.statusUpdateReason = statusUpdateReason
            self.suspendedCause = suspendedCause
            self.suspendedDate = suspendedDate
            self.terminationDate = terminationDate
        }
    }

}

extension S3ControlClientTypes.JobFailure: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureCode = "FailureCode"
        case failureReason = "FailureReason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let failureCode = failureCode {
            try container.encode(failureCode, forKey: ClientRuntime.Key("FailureCode"))
        }
        if let failureReason = failureReason {
            try container.encode(failureReason, forKey: ClientRuntime.Key("FailureReason"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failureCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension S3ControlClientTypes.JobFailure: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// If this job failed, this element indicates why the job failed.
    public struct JobFailure: Swift.Equatable {
        /// The failure code, if any, for the specified job.
        public var failureCode: Swift.String?
        /// The failure reason, if any, for the specified job.
        public var failureReason: Swift.String?

        public init(
            failureCode: Swift.String? = nil,
            failureReason: Swift.String? = nil
        )
        {
            self.failureCode = failureCode
            self.failureReason = failureReason
        }
    }

}

extension S3ControlClientTypes.JobListDescriptor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case description = "Description"
        case jobId = "JobId"
        case operation = "Operation"
        case priority = "Priority"
        case progressSummary = "ProgressSummary"
        case status = "Status"
        case terminationDate = "TerminationDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let creationTime = creationTime {
            try container.encodeTimestamp(creationTime, format: .dateTime, forKey: ClientRuntime.Key("CreationTime"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let jobId = jobId {
            try container.encode(jobId, forKey: ClientRuntime.Key("JobId"))
        }
        if let operation = operation {
            try container.encode(operation, forKey: ClientRuntime.Key("Operation"))
        }
        if priority != 0 {
            try container.encode(priority, forKey: ClientRuntime.Key("Priority"))
        }
        if let progressSummary = progressSummary {
            try container.encode(progressSummary, forKey: ClientRuntime.Key("ProgressSummary"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let terminationDate = terminationDate {
            try container.encodeTimestamp(terminationDate, format: .dateTime, forKey: ClientRuntime.Key("TerminationDate"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let operationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.OperationName.self, forKey: .operation)
        operation = operationDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority) ?? 0
        priority = priorityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let terminationDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .terminationDate)
        terminationDate = terminationDateDecoded
        let progressSummaryDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobProgressSummary.self, forKey: .progressSummary)
        progressSummary = progressSummaryDecoded
    }
}

extension S3ControlClientTypes.JobListDescriptor: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// Contains the configuration and status information for a single job retrieved as part of a job list.
    public struct JobListDescriptor: Swift.Equatable {
        /// A timestamp indicating when the specified job was created.
        public var creationTime: ClientRuntime.Date?
        /// The user-specified description that was included in the specified job's Create Job request.
        public var description: Swift.String?
        /// The ID for the specified job.
        public var jobId: Swift.String?
        /// The operation that the specified job is configured to run on every object listed in the manifest.
        public var operation: S3ControlClientTypes.OperationName?
        /// The current priority for the specified job.
        public var priority: Swift.Int
        /// Describes the total number of tasks that the specified job has run, the number of tasks that succeeded, and the number of tasks that failed.
        public var progressSummary: S3ControlClientTypes.JobProgressSummary?
        /// The specified job's current status.
        public var status: S3ControlClientTypes.JobStatus?
        /// A timestamp indicating when the specified job terminated. A job's termination date is the date and time when it succeeded, failed, or was canceled.
        public var terminationDate: ClientRuntime.Date?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            jobId: Swift.String? = nil,
            operation: S3ControlClientTypes.OperationName? = nil,
            priority: Swift.Int = 0,
            progressSummary: S3ControlClientTypes.JobProgressSummary? = nil,
            status: S3ControlClientTypes.JobStatus? = nil,
            terminationDate: ClientRuntime.Date? = nil
        )
        {
            self.creationTime = creationTime
            self.description = description
            self.jobId = jobId
            self.operation = operation
            self.priority = priority
            self.progressSummary = progressSummary
            self.status = status
            self.terminationDate = terminationDate
        }
    }

}

extension S3ControlClientTypes.JobManifest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case location = "Location"
        case spec = "Spec"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let location = location {
            try container.encode(location, forKey: ClientRuntime.Key("Location"))
        }
        if let spec = spec {
            try container.encode(spec, forKey: ClientRuntime.Key("Spec"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let specDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobManifestSpec.self, forKey: .spec)
        spec = specDecoded
        let locationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobManifestLocation.self, forKey: .location)
        location = locationDecoded
    }
}

extension S3ControlClientTypes.JobManifest: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// Contains the configuration information for a job's manifest.
    public struct JobManifest: Swift.Equatable {
        /// Contains the information required to locate the specified job's manifest.
        /// This member is required.
        public var location: S3ControlClientTypes.JobManifestLocation?
        /// Describes the format of the specified job's manifest. If the manifest is in CSV format, also describes the columns contained within the manifest.
        /// This member is required.
        public var spec: S3ControlClientTypes.JobManifestSpec?

        public init(
            location: S3ControlClientTypes.JobManifestLocation? = nil,
            spec: S3ControlClientTypes.JobManifestSpec? = nil
        )
        {
            self.location = location
            self.spec = spec
        }
    }

}

extension S3ControlClientTypes {
    public enum JobManifestFieldName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bucket
        case ignore
        case key
        case versionid
        case sdkUnknown(Swift.String)

        public static var allCases: [JobManifestFieldName] {
            return [
                .bucket,
                .ignore,
                .key,
                .versionid,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bucket: return "Bucket"
            case .ignore: return "Ignore"
            case .key: return "Key"
            case .versionid: return "VersionId"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobManifestFieldName(rawValue: rawValue) ?? JobManifestFieldName.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum JobManifestFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case s3batchoperationsCsv20180820
        case s3inventoryreportCsv20161130
        case sdkUnknown(Swift.String)

        public static var allCases: [JobManifestFormat] {
            return [
                .s3batchoperationsCsv20180820,
                .s3inventoryreportCsv20161130,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .s3batchoperationsCsv20180820: return "S3BatchOperations_CSV_20180820"
            case .s3inventoryreportCsv20161130: return "S3InventoryReport_CSV_20161130"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobManifestFormat(rawValue: rawValue) ?? JobManifestFormat.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.JobManifestGenerator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3jobmanifestgenerator = "S3JobManifestGenerator"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        switch self {
            case let .s3jobmanifestgenerator(s3jobmanifestgenerator):
                try container.encode(s3jobmanifestgenerator, forKey: ClientRuntime.Key("S3JobManifestGenerator"))
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: ClientRuntime.Key("sdkUnknown"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let key = containerValues.allKeys.first
        switch key {
            case .s3jobmanifestgenerator:
                let s3jobmanifestgeneratorDecoded = try containerValues.decode(S3ControlClientTypes.S3JobManifestGenerator.self, forKey: .s3jobmanifestgenerator)
                self = .s3jobmanifestgenerator(s3jobmanifestgeneratorDecoded)
            default:
                self = .sdkUnknown("")
        }
    }
}

extension S3ControlClientTypes {
    /// Configures the type of the job's ManifestGenerator.
    public enum JobManifestGenerator: Swift.Equatable {
        /// The S3 job ManifestGenerator's configuration details.
        case s3jobmanifestgenerator(S3ControlClientTypes.S3JobManifestGenerator)
        case sdkUnknown(Swift.String)
    }

}

extension S3ControlClientTypes.JobManifestGeneratorFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAfter = "CreatedAfter"
        case createdBefore = "CreatedBefore"
        case eligibleForReplication = "EligibleForReplication"
        case objectReplicationStatuses = "ObjectReplicationStatuses"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let createdAfter = createdAfter {
            try container.encodeTimestamp(createdAfter, format: .dateTime, forKey: ClientRuntime.Key("CreatedAfter"))
        }
        if let createdBefore = createdBefore {
            try container.encodeTimestamp(createdBefore, format: .dateTime, forKey: ClientRuntime.Key("CreatedBefore"))
        }
        if let eligibleForReplication = eligibleForReplication {
            try container.encode(eligibleForReplication, forKey: ClientRuntime.Key("EligibleForReplication"))
        }
        if let objectReplicationStatuses = objectReplicationStatuses {
            var objectReplicationStatusesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ObjectReplicationStatuses"))
            for replicationstatus0 in objectReplicationStatuses {
                try objectReplicationStatusesContainer.encode(replicationstatus0, forKey: ClientRuntime.Key("member"))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eligibleForReplicationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .eligibleForReplication) ?? nil
        eligibleForReplication = eligibleForReplicationDecoded
        let createdAfterDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAfter)
        createdAfter = createdAfterDecoded
        let createdBeforeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdBefore)
        createdBefore = createdBeforeDecoded
        if containerValues.contains(.objectReplicationStatuses) {
            struct KeyVal0{struct member{}}
            let objectReplicationStatusesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .objectReplicationStatuses)
            if let objectReplicationStatusesWrappedContainer = objectReplicationStatusesWrappedContainer {
                let objectReplicationStatusesContainer = try objectReplicationStatusesWrappedContainer.decodeIfPresent([S3ControlClientTypes.ReplicationStatus].self, forKey: .member)
                var objectReplicationStatusesBuffer:[S3ControlClientTypes.ReplicationStatus]? = nil
                if let objectReplicationStatusesContainer = objectReplicationStatusesContainer {
                    objectReplicationStatusesBuffer = [S3ControlClientTypes.ReplicationStatus]()
                    for enumContainer0 in objectReplicationStatusesContainer {
                        objectReplicationStatusesBuffer?.append(enumContainer0)
                    }
                }
                objectReplicationStatuses = objectReplicationStatusesBuffer
            } else {
                objectReplicationStatuses = []
            }
        } else {
            objectReplicationStatuses = nil
        }
    }
}

extension S3ControlClientTypes.JobManifestGeneratorFilter: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// The filter used to describe a set of objects for the job's manifest.
    public struct JobManifestGeneratorFilter: Swift.Equatable {
        /// If provided, the generated manifest should include only source bucket objects that were created after this time.
        public var createdAfter: ClientRuntime.Date?
        /// If provided, the generated manifest should include only source bucket objects that were created before this time.
        public var createdBefore: ClientRuntime.Date?
        /// Include objects in the generated manifest only if they are eligible for replication according to the Replication configuration on the source bucket.
        public var eligibleForReplication: Swift.Bool?
        /// If provided, the generated manifest should include only source bucket objects that have one of the specified Replication statuses.
        public var objectReplicationStatuses: [S3ControlClientTypes.ReplicationStatus]?

        public init(
            createdAfter: ClientRuntime.Date? = nil,
            createdBefore: ClientRuntime.Date? = nil,
            eligibleForReplication: Swift.Bool? = nil,
            objectReplicationStatuses: [S3ControlClientTypes.ReplicationStatus]? = nil
        )
        {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.eligibleForReplication = eligibleForReplication
            self.objectReplicationStatuses = objectReplicationStatuses
        }
    }

}

extension S3ControlClientTypes.JobManifestLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eTag = "ETag"
        case objectArn = "ObjectArn"
        case objectVersionId = "ObjectVersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let eTag = eTag {
            try container.encode(eTag, forKey: ClientRuntime.Key("ETag"))
        }
        if let objectArn = objectArn {
            try container.encode(objectArn, forKey: ClientRuntime.Key("ObjectArn"))
        }
        if let objectVersionId = objectVersionId {
            try container.encode(objectVersionId, forKey: ClientRuntime.Key("ObjectVersionId"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectArn)
        objectArn = objectArnDecoded
        let objectVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectVersionId)
        objectVersionId = objectVersionIdDecoded
        let eTagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eTag)
        eTag = eTagDecoded
    }
}

extension S3ControlClientTypes.JobManifestLocation: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// Contains the information required to locate a manifest object.
    public struct JobManifestLocation: Swift.Equatable {
        /// The ETag for the specified manifest object.
        /// This member is required.
        public var eTag: Swift.String?
        /// The Amazon Resource Name (ARN) for a manifest object. When you're using XML requests, you must replace special characters (such as carriage returns) in object keys with their equivalent XML entity codes. For more information, see [ XML-related object key constraints](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints) in the Amazon S3 User Guide.
        /// This member is required.
        public var objectArn: Swift.String?
        /// The optional version ID to identify a specific version of the manifest object.
        public var objectVersionId: Swift.String?

        public init(
            eTag: Swift.String? = nil,
            objectArn: Swift.String? = nil,
            objectVersionId: Swift.String? = nil
        )
        {
            self.eTag = eTag
            self.objectArn = objectArn
            self.objectVersionId = objectVersionId
        }
    }

}

extension S3ControlClientTypes.JobManifestSpec: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields = "Fields"
        case format = "Format"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let fields = fields {
            var fieldsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Fields"))
            for jobmanifestfieldname0 in fields {
                try fieldsContainer.encode(jobmanifestfieldname0, forKey: ClientRuntime.Key("member"))
            }
        }
        if let format = format {
            try container.encode(format, forKey: ClientRuntime.Key("Format"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobManifestFormat.self, forKey: .format)
        format = formatDecoded
        if containerValues.contains(.fields) {
            struct KeyVal0{struct member{}}
            let fieldsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .fields)
            if let fieldsWrappedContainer = fieldsWrappedContainer {
                let fieldsContainer = try fieldsWrappedContainer.decodeIfPresent([S3ControlClientTypes.JobManifestFieldName].self, forKey: .member)
                var fieldsBuffer:[S3ControlClientTypes.JobManifestFieldName]? = nil
                if let fieldsContainer = fieldsContainer {
                    fieldsBuffer = [S3ControlClientTypes.JobManifestFieldName]()
                    for enumContainer0 in fieldsContainer {
                        fieldsBuffer?.append(enumContainer0)
                    }
                }
                fields = fieldsBuffer
            } else {
                fields = []
            }
        } else {
            fields = nil
        }
    }
}

extension S3ControlClientTypes.JobManifestSpec: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// Describes the format of a manifest. If the manifest is in CSV format, also describes the columns contained within the manifest.
    public struct JobManifestSpec: Swift.Equatable {
        /// If the specified manifest object is in the S3BatchOperations_CSV_20180820 format, this element describes which columns contain the required data.
        public var fields: [S3ControlClientTypes.JobManifestFieldName]?
        /// Indicates which of the available formats the specified manifest uses.
        /// This member is required.
        public var format: S3ControlClientTypes.JobManifestFormat?

        public init(
            fields: [S3ControlClientTypes.JobManifestFieldName]? = nil,
            format: S3ControlClientTypes.JobManifestFormat? = nil
        )
        {
            self.fields = fields
            self.format = format
        }
    }

}

extension S3ControlClientTypes.JobOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lambdaInvoke = "LambdaInvoke"
        case s3DeleteObjectTagging = "S3DeleteObjectTagging"
        case s3InitiateRestoreObject = "S3InitiateRestoreObject"
        case s3PutObjectAcl = "S3PutObjectAcl"
        case s3PutObjectCopy = "S3PutObjectCopy"
        case s3PutObjectLegalHold = "S3PutObjectLegalHold"
        case s3PutObjectRetention = "S3PutObjectRetention"
        case s3PutObjectTagging = "S3PutObjectTagging"
        case s3ReplicateObject = "S3ReplicateObject"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let lambdaInvoke = lambdaInvoke {
            try container.encode(lambdaInvoke, forKey: ClientRuntime.Key("LambdaInvoke"))
        }
        if let s3DeleteObjectTagging = s3DeleteObjectTagging {
            try container.encode(s3DeleteObjectTagging, forKey: ClientRuntime.Key("S3DeleteObjectTagging"))
        }
        if let s3InitiateRestoreObject = s3InitiateRestoreObject {
            try container.encode(s3InitiateRestoreObject, forKey: ClientRuntime.Key("S3InitiateRestoreObject"))
        }
        if let s3PutObjectAcl = s3PutObjectAcl {
            try container.encode(s3PutObjectAcl, forKey: ClientRuntime.Key("S3PutObjectAcl"))
        }
        if let s3PutObjectCopy = s3PutObjectCopy {
            try container.encode(s3PutObjectCopy, forKey: ClientRuntime.Key("S3PutObjectCopy"))
        }
        if let s3PutObjectLegalHold = s3PutObjectLegalHold {
            try container.encode(s3PutObjectLegalHold, forKey: ClientRuntime.Key("S3PutObjectLegalHold"))
        }
        if let s3PutObjectRetention = s3PutObjectRetention {
            try container.encode(s3PutObjectRetention, forKey: ClientRuntime.Key("S3PutObjectRetention"))
        }
        if let s3PutObjectTagging = s3PutObjectTagging {
            try container.encode(s3PutObjectTagging, forKey: ClientRuntime.Key("S3PutObjectTagging"))
        }
        if let s3ReplicateObject = s3ReplicateObject {
            try container.encode(s3ReplicateObject, forKey: ClientRuntime.Key("S3ReplicateObject"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaInvokeDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.LambdaInvokeOperation.self, forKey: .lambdaInvoke)
        lambdaInvoke = lambdaInvokeDecoded
        let s3PutObjectCopyDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3CopyObjectOperation.self, forKey: .s3PutObjectCopy)
        s3PutObjectCopy = s3PutObjectCopyDecoded
        let s3PutObjectAclDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3SetObjectAclOperation.self, forKey: .s3PutObjectAcl)
        s3PutObjectAcl = s3PutObjectAclDecoded
        let s3PutObjectTaggingDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3SetObjectTaggingOperation.self, forKey: .s3PutObjectTagging)
        s3PutObjectTagging = s3PutObjectTaggingDecoded
        let s3DeleteObjectTaggingDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3DeleteObjectTaggingOperation.self, forKey: .s3DeleteObjectTagging)
        s3DeleteObjectTagging = s3DeleteObjectTaggingDecoded
        let s3InitiateRestoreObjectDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3InitiateRestoreObjectOperation.self, forKey: .s3InitiateRestoreObject)
        s3InitiateRestoreObject = s3InitiateRestoreObjectDecoded
        let s3PutObjectLegalHoldDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3SetObjectLegalHoldOperation.self, forKey: .s3PutObjectLegalHold)
        s3PutObjectLegalHold = s3PutObjectLegalHoldDecoded
        let s3PutObjectRetentionDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3SetObjectRetentionOperation.self, forKey: .s3PutObjectRetention)
        s3PutObjectRetention = s3PutObjectRetentionDecoded
        let s3ReplicateObjectDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3ReplicateObjectOperation.self, forKey: .s3ReplicateObject)
        s3ReplicateObject = s3ReplicateObjectDecoded
    }
}

extension S3ControlClientTypes.JobOperation: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// The operation that you want this job to perform on every object listed in the manifest. For more information about the available operations, see [Operations](https://docs.aws.amazon.com/AmazonS3/latest/dev/batch-ops-operations.html) in the Amazon S3 User Guide.
    public struct JobOperation: Swift.Equatable {
        /// Directs the specified job to invoke an Lambda function on every object in the manifest.
        public var lambdaInvoke: S3ControlClientTypes.LambdaInvokeOperation?
        /// Directs the specified job to execute a DELETE Object tagging call on every object in the manifest.
        public var s3DeleteObjectTagging: S3ControlClientTypes.S3DeleteObjectTaggingOperation?
        /// Directs the specified job to initiate restore requests for every archived object in the manifest.
        public var s3InitiateRestoreObject: S3ControlClientTypes.S3InitiateRestoreObjectOperation?
        /// Directs the specified job to run a PutObjectAcl call on every object in the manifest.
        public var s3PutObjectAcl: S3ControlClientTypes.S3SetObjectAclOperation?
        /// Directs the specified job to run a PUT Copy object call on every object in the manifest.
        public var s3PutObjectCopy: S3ControlClientTypes.S3CopyObjectOperation?
        /// Contains the configuration for an S3 Object Lock legal hold operation that an S3 Batch Operations job passes to every object to the underlying PutObjectLegalHold API operation. For more information, see [Using S3 Object Lock legal hold with S3 Batch Operations](https://docs.aws.amazon.com/AmazonS3/latest/dev/batch-ops-legal-hold.html) in the Amazon S3 User Guide.
        public var s3PutObjectLegalHold: S3ControlClientTypes.S3SetObjectLegalHoldOperation?
        /// Contains the configuration parameters for the Object Lock retention action for an S3 Batch Operations job. Batch Operations passes every object to the underlying PutObjectRetention API operation. For more information, see [Using S3 Object Lock retention with S3 Batch Operations](https://docs.aws.amazon.com/AmazonS3/latest/dev/batch-ops-retention-date.html) in the Amazon S3 User Guide.
        public var s3PutObjectRetention: S3ControlClientTypes.S3SetObjectRetentionOperation?
        /// Directs the specified job to run a PUT Object tagging call on every object in the manifest.
        public var s3PutObjectTagging: S3ControlClientTypes.S3SetObjectTaggingOperation?
        /// Directs the specified job to invoke ReplicateObject on every object in the job's manifest.
        public var s3ReplicateObject: S3ControlClientTypes.S3ReplicateObjectOperation?

        public init(
            lambdaInvoke: S3ControlClientTypes.LambdaInvokeOperation? = nil,
            s3DeleteObjectTagging: S3ControlClientTypes.S3DeleteObjectTaggingOperation? = nil,
            s3InitiateRestoreObject: S3ControlClientTypes.S3InitiateRestoreObjectOperation? = nil,
            s3PutObjectAcl: S3ControlClientTypes.S3SetObjectAclOperation? = nil,
            s3PutObjectCopy: S3ControlClientTypes.S3CopyObjectOperation? = nil,
            s3PutObjectLegalHold: S3ControlClientTypes.S3SetObjectLegalHoldOperation? = nil,
            s3PutObjectRetention: S3ControlClientTypes.S3SetObjectRetentionOperation? = nil,
            s3PutObjectTagging: S3ControlClientTypes.S3SetObjectTaggingOperation? = nil,
            s3ReplicateObject: S3ControlClientTypes.S3ReplicateObjectOperation? = nil
        )
        {
            self.lambdaInvoke = lambdaInvoke
            self.s3DeleteObjectTagging = s3DeleteObjectTagging
            self.s3InitiateRestoreObject = s3InitiateRestoreObject
            self.s3PutObjectAcl = s3PutObjectAcl
            self.s3PutObjectCopy = s3PutObjectCopy
            self.s3PutObjectLegalHold = s3PutObjectLegalHold
            self.s3PutObjectRetention = s3PutObjectRetention
            self.s3PutObjectTagging = s3PutObjectTagging
            self.s3ReplicateObject = s3ReplicateObject
        }
    }

}

extension S3ControlClientTypes.JobProgressSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case numberOfTasksFailed = "NumberOfTasksFailed"
        case numberOfTasksSucceeded = "NumberOfTasksSucceeded"
        case timers = "Timers"
        case totalNumberOfTasks = "TotalNumberOfTasks"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let numberOfTasksFailed = numberOfTasksFailed {
            try container.encode(numberOfTasksFailed, forKey: ClientRuntime.Key("NumberOfTasksFailed"))
        }
        if let numberOfTasksSucceeded = numberOfTasksSucceeded {
            try container.encode(numberOfTasksSucceeded, forKey: ClientRuntime.Key("NumberOfTasksSucceeded"))
        }
        if let timers = timers {
            try container.encode(timers, forKey: ClientRuntime.Key("Timers"))
        }
        if let totalNumberOfTasks = totalNumberOfTasks {
            try container.encode(totalNumberOfTasks, forKey: ClientRuntime.Key("TotalNumberOfTasks"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalNumberOfTasksDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalNumberOfTasks) ?? nil
        totalNumberOfTasks = totalNumberOfTasksDecoded
        let numberOfTasksSucceededDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfTasksSucceeded) ?? nil
        numberOfTasksSucceeded = numberOfTasksSucceededDecoded
        let numberOfTasksFailedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfTasksFailed) ?? nil
        numberOfTasksFailed = numberOfTasksFailedDecoded
        let timersDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobTimers.self, forKey: .timers)
        timers = timersDecoded
    }
}

extension S3ControlClientTypes.JobProgressSummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// Describes the total number of tasks that the specified job has started, the number of tasks that succeeded, and the number of tasks that failed.
    public struct JobProgressSummary: Swift.Equatable {
        ///
        public var numberOfTasksFailed: Swift.Int?
        ///
        public var numberOfTasksSucceeded: Swift.Int?
        /// The JobTimers attribute of a job's progress summary.
        public var timers: S3ControlClientTypes.JobTimers?
        ///
        public var totalNumberOfTasks: Swift.Int?

        public init(
            numberOfTasksFailed: Swift.Int? = nil,
            numberOfTasksSucceeded: Swift.Int? = nil,
            timers: S3ControlClientTypes.JobTimers? = nil,
            totalNumberOfTasks: Swift.Int? = nil
        )
        {
            self.numberOfTasksFailed = numberOfTasksFailed
            self.numberOfTasksSucceeded = numberOfTasksSucceeded
            self.timers = timers
            self.totalNumberOfTasks = totalNumberOfTasks
        }
    }

}

extension S3ControlClientTypes.JobReport: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case enabled = "Enabled"
        case format = "Format"
        case `prefix` = "Prefix"
        case reportScope = "ReportScope"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let bucket = bucket {
            try container.encode(bucket, forKey: ClientRuntime.Key("Bucket"))
        }
        if enabled != false {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let format = format {
            try container.encode(format, forKey: ClientRuntime.Key("Format"))
        }
        if let `prefix` = `prefix` {
            try container.encode(`prefix`, forKey: ClientRuntime.Key("Prefix"))
        }
        if let reportScope = reportScope {
            try container.encode(reportScope, forKey: ClientRuntime.Key("ReportScope"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let formatDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobReportFormat.self, forKey: .format)
        format = formatDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        let reportScopeDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobReportScope.self, forKey: .reportScope)
        reportScope = reportScopeDecoded
    }
}

extension S3ControlClientTypes.JobReport: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// Contains the configuration parameters for a job-completion report.
    public struct JobReport: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the bucket where specified job-completion report will be stored.
        public var bucket: Swift.String?
        /// Indicates whether the specified job will generate a job-completion report.
        /// This member is required.
        public var enabled: Swift.Bool
        /// The format of the specified job-completion report.
        public var format: S3ControlClientTypes.JobReportFormat?
        /// An optional prefix to describe where in the specified bucket the job-completion report will be stored. Amazon S3 stores the job-completion report at /job-/report.json.
        public var `prefix`: Swift.String?
        /// Indicates whether the job-completion report will include details of all tasks or only failed tasks.
        public var reportScope: S3ControlClientTypes.JobReportScope?

        public init(
            bucket: Swift.String? = nil,
            enabled: Swift.Bool = false,
            format: S3ControlClientTypes.JobReportFormat? = nil,
            `prefix`: Swift.String? = nil,
            reportScope: S3ControlClientTypes.JobReportScope? = nil
        )
        {
            self.bucket = bucket
            self.enabled = enabled
            self.format = format
            self.`prefix` = `prefix`
            self.reportScope = reportScope
        }
    }

}

extension S3ControlClientTypes {
    public enum JobReportFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case reportCsv20180820
        case sdkUnknown(Swift.String)

        public static var allCases: [JobReportFormat] {
            return [
                .reportCsv20180820,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .reportCsv20180820: return "Report_CSV_20180820"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobReportFormat(rawValue: rawValue) ?? JobReportFormat.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum JobReportScope: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case alltasks
        case failedtasksonly
        case sdkUnknown(Swift.String)

        public static var allCases: [JobReportScope] {
            return [
                .alltasks,
                .failedtasksonly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .alltasks: return "AllTasks"
            case .failedtasksonly: return "FailedTasksOnly"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobReportScope(rawValue: rawValue) ?? JobReportScope.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum JobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case cancelled
        case cancelling
        case complete
        case completing
        case failed
        case failing
        case new
        case paused
        case pausing
        case preparing
        case ready
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .active,
                .cancelled,
                .cancelling,
                .complete,
                .completing,
                .failed,
                .failing,
                .new,
                .paused,
                .pausing,
                .preparing,
                .ready,
                .suspended,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .cancelled: return "Cancelled"
            case .cancelling: return "Cancelling"
            case .complete: return "Complete"
            case .completing: return "Completing"
            case .failed: return "Failed"
            case .failing: return "Failing"
            case .new: return "New"
            case .paused: return "Paused"
            case .pausing: return "Pausing"
            case .preparing: return "Preparing"
            case .ready: return "Ready"
            case .suspended: return "Suspended"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
        }
    }
}

extension JobStatusException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<JobStatusExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct JobStatusException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "JobStatusException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct JobStatusExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension JobStatusExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension S3ControlClientTypes.JobTimers: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elapsedTimeInActiveSeconds = "ElapsedTimeInActiveSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let elapsedTimeInActiveSeconds = elapsedTimeInActiveSeconds {
            try container.encode(elapsedTimeInActiveSeconds, forKey: ClientRuntime.Key("ElapsedTimeInActiveSeconds"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elapsedTimeInActiveSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .elapsedTimeInActiveSeconds) ?? nil
        elapsedTimeInActiveSeconds = elapsedTimeInActiveSecondsDecoded
    }
}

extension S3ControlClientTypes.JobTimers: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// Provides timing details for the job.
    public struct JobTimers: Swift.Equatable {
        /// Indicates the elapsed time in seconds the job has been in the Active job state.
        public var elapsedTimeInActiveSeconds: Swift.Int?

        public init(
            elapsedTimeInActiveSeconds: Swift.Int? = nil
        )
        {
            self.elapsedTimeInActiveSeconds = elapsedTimeInActiveSeconds
        }
    }

}

extension S3ControlClientTypes.LambdaInvokeOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionArn = "FunctionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let functionArn = functionArn {
            try container.encode(functionArn, forKey: ClientRuntime.Key("FunctionArn"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
    }
}

extension S3ControlClientTypes.LambdaInvokeOperation: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// Contains the configuration parameters for a Lambda Invoke operation.
    public struct LambdaInvokeOperation: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the Lambda function that the specified job will invoke on every object in the manifest.
        public var functionArn: Swift.String?

        public init(
            functionArn: Swift.String? = nil
        )
        {
            self.functionArn = functionArn
        }
    }

}

extension S3ControlClientTypes.LifecycleConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rules = "Rules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let rules = rules {
            var rulesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Rules"))
            for lifecyclerule0 in rules {
                try rulesContainer.encode(lifecyclerule0, forKey: ClientRuntime.Key("Rule"))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.rules) {
            struct KeyVal0{struct Rule{}}
            let rulesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Rule>.CodingKeys.self, forKey: .rules)
            if let rulesWrappedContainer = rulesWrappedContainer {
                let rulesContainer = try rulesWrappedContainer.decodeIfPresent([S3ControlClientTypes.LifecycleRule].self, forKey: .member)
                var rulesBuffer:[S3ControlClientTypes.LifecycleRule]? = nil
                if let rulesContainer = rulesContainer {
                    rulesBuffer = [S3ControlClientTypes.LifecycleRule]()
                    for structureContainer0 in rulesContainer {
                        rulesBuffer?.append(structureContainer0)
                    }
                }
                rules = rulesBuffer
            } else {
                rules = []
            }
        } else {
            rules = nil
        }
    }
}

extension S3ControlClientTypes.LifecycleConfiguration: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// The container for the Outposts bucket lifecycle configuration.
    public struct LifecycleConfiguration: Swift.Equatable {
        /// A lifecycle rule for individual objects in an Outposts bucket.
        public var rules: [S3ControlClientTypes.LifecycleRule]?

        public init(
            rules: [S3ControlClientTypes.LifecycleRule]? = nil
        )
        {
            self.rules = rules
        }
    }

}

extension S3ControlClientTypes.LifecycleExpiration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case date = "Date"
        case days = "Days"
        case expiredObjectDeleteMarker = "ExpiredObjectDeleteMarker"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let date = date {
            try container.encodeTimestamp(date, format: .dateTime, forKey: ClientRuntime.Key("Date"))
        }
        if days != 0 {
            try container.encode(days, forKey: ClientRuntime.Key("Days"))
        }
        if expiredObjectDeleteMarker != false {
            try container.encode(expiredObjectDeleteMarker, forKey: ClientRuntime.Key("ExpiredObjectDeleteMarker"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .date)
        date = dateDecoded
        let daysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .days) ?? 0
        days = daysDecoded
        let expiredObjectDeleteMarkerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .expiredObjectDeleteMarker) ?? false
        expiredObjectDeleteMarker = expiredObjectDeleteMarkerDecoded
    }
}

extension S3ControlClientTypes.LifecycleExpiration: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// The container of the Outposts bucket lifecycle expiration.
    public struct LifecycleExpiration: Swift.Equatable {
        /// Indicates at what date the object is to be deleted. Should be in GMT ISO 8601 format.
        public var date: ClientRuntime.Date?
        /// Indicates the lifetime, in days, of the objects that are subject to the rule. The value must be a non-zero positive integer.
        public var days: Swift.Int
        /// Indicates whether Amazon S3 will remove a delete marker with no noncurrent versions. If set to true, the delete marker will be expired. If set to false, the policy takes no action. This cannot be specified with Days or Date in a Lifecycle Expiration Policy.
        public var expiredObjectDeleteMarker: Swift.Bool

        public init(
            date: ClientRuntime.Date? = nil,
            days: Swift.Int = 0,
            expiredObjectDeleteMarker: Swift.Bool = false
        )
        {
            self.date = date
            self.days = days
            self.expiredObjectDeleteMarker = expiredObjectDeleteMarker
        }
    }

}

extension S3ControlClientTypes.LifecycleRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case abortIncompleteMultipartUpload = "AbortIncompleteMultipartUpload"
        case expiration = "Expiration"
        case filter = "Filter"
        case id = "ID"
        case noncurrentVersionExpiration = "NoncurrentVersionExpiration"
        case noncurrentVersionTransitions = "NoncurrentVersionTransitions"
        case status = "Status"
        case transitions = "Transitions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let abortIncompleteMultipartUpload = abortIncompleteMultipartUpload {
            try container.encode(abortIncompleteMultipartUpload, forKey: ClientRuntime.Key("AbortIncompleteMultipartUpload"))
        }
        if let expiration = expiration {
            try container.encode(expiration, forKey: ClientRuntime.Key("Expiration"))
        }
        if let filter = filter {
            try container.encode(filter, forKey: ClientRuntime.Key("Filter"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("ID"))
        }
        if let noncurrentVersionExpiration = noncurrentVersionExpiration {
            try container.encode(noncurrentVersionExpiration, forKey: ClientRuntime.Key("NoncurrentVersionExpiration"))
        }
        if let noncurrentVersionTransitions = noncurrentVersionTransitions {
            var noncurrentVersionTransitionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("NoncurrentVersionTransitions"))
            for noncurrentversiontransition0 in noncurrentVersionTransitions {
                try noncurrentVersionTransitionsContainer.encode(noncurrentversiontransition0, forKey: ClientRuntime.Key("NoncurrentVersionTransition"))
            }
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let transitions = transitions {
            var transitionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Transitions"))
            for transition0 in transitions {
                try transitionsContainer.encode(transition0, forKey: ClientRuntime.Key("Transition"))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expirationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.LifecycleExpiration.self, forKey: .expiration)
        expiration = expirationDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let filterDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.LifecycleRuleFilter.self, forKey: .filter)
        filter = filterDecoded
        let statusDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ExpirationStatus.self, forKey: .status)
        status = statusDecoded
        if containerValues.contains(.transitions) {
            struct KeyVal0{struct Transition{}}
            let transitionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Transition>.CodingKeys.self, forKey: .transitions)
            if let transitionsWrappedContainer = transitionsWrappedContainer {
                let transitionsContainer = try transitionsWrappedContainer.decodeIfPresent([S3ControlClientTypes.Transition].self, forKey: .member)
                var transitionsBuffer:[S3ControlClientTypes.Transition]? = nil
                if let transitionsContainer = transitionsContainer {
                    transitionsBuffer = [S3ControlClientTypes.Transition]()
                    for structureContainer0 in transitionsContainer {
                        transitionsBuffer?.append(structureContainer0)
                    }
                }
                transitions = transitionsBuffer
            } else {
                transitions = []
            }
        } else {
            transitions = nil
        }
        if containerValues.contains(.noncurrentVersionTransitions) {
            struct KeyVal0{struct NoncurrentVersionTransition{}}
            let noncurrentVersionTransitionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.NoncurrentVersionTransition>.CodingKeys.self, forKey: .noncurrentVersionTransitions)
            if let noncurrentVersionTransitionsWrappedContainer = noncurrentVersionTransitionsWrappedContainer {
                let noncurrentVersionTransitionsContainer = try noncurrentVersionTransitionsWrappedContainer.decodeIfPresent([S3ControlClientTypes.NoncurrentVersionTransition].self, forKey: .member)
                var noncurrentVersionTransitionsBuffer:[S3ControlClientTypes.NoncurrentVersionTransition]? = nil
                if let noncurrentVersionTransitionsContainer = noncurrentVersionTransitionsContainer {
                    noncurrentVersionTransitionsBuffer = [S3ControlClientTypes.NoncurrentVersionTransition]()
                    for structureContainer0 in noncurrentVersionTransitionsContainer {
                        noncurrentVersionTransitionsBuffer?.append(structureContainer0)
                    }
                }
                noncurrentVersionTransitions = noncurrentVersionTransitionsBuffer
            } else {
                noncurrentVersionTransitions = []
            }
        } else {
            noncurrentVersionTransitions = nil
        }
        let noncurrentVersionExpirationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.NoncurrentVersionExpiration.self, forKey: .noncurrentVersionExpiration)
        noncurrentVersionExpiration = noncurrentVersionExpirationDecoded
        let abortIncompleteMultipartUploadDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.AbortIncompleteMultipartUpload.self, forKey: .abortIncompleteMultipartUpload)
        abortIncompleteMultipartUpload = abortIncompleteMultipartUploadDecoded
    }
}

extension S3ControlClientTypes.LifecycleRule: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// The container for the Outposts bucket lifecycle rule.
    public struct LifecycleRule: Swift.Equatable {
        /// Specifies the days since the initiation of an incomplete multipart upload that Amazon S3 waits before permanently removing all parts of the upload. For more information, see [ Aborting Incomplete Multipart Uploads Using a Bucket Lifecycle Configuration](https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuoverview.html#mpu-abort-incomplete-mpu-lifecycle-config) in the Amazon S3 User Guide.
        public var abortIncompleteMultipartUpload: S3ControlClientTypes.AbortIncompleteMultipartUpload?
        /// Specifies the expiration for the lifecycle of the object in the form of date, days and, whether the object has a delete marker.
        public var expiration: S3ControlClientTypes.LifecycleExpiration?
        /// The container for the filter of lifecycle rule.
        public var filter: S3ControlClientTypes.LifecycleRuleFilter?
        /// Unique identifier for the rule. The value cannot be longer than 255 characters.
        public var id: Swift.String?
        /// The noncurrent version expiration of the lifecycle rule.
        public var noncurrentVersionExpiration: S3ControlClientTypes.NoncurrentVersionExpiration?
        /// Specifies the transition rule for the lifecycle rule that describes when noncurrent objects transition to a specific storage class. If your bucket is versioning-enabled (or versioning is suspended), you can set this action to request that Amazon S3 transition noncurrent object versions to a specific storage class at a set period in the object's lifetime. This is not supported by Amazon S3 on Outposts buckets.
        public var noncurrentVersionTransitions: [S3ControlClientTypes.NoncurrentVersionTransition]?
        /// If 'Enabled', the rule is currently being applied. If 'Disabled', the rule is not currently being applied.
        /// This member is required.
        public var status: S3ControlClientTypes.ExpirationStatus?
        /// Specifies when an Amazon S3 object transitions to a specified storage class. This is not supported by Amazon S3 on Outposts buckets.
        public var transitions: [S3ControlClientTypes.Transition]?

        public init(
            abortIncompleteMultipartUpload: S3ControlClientTypes.AbortIncompleteMultipartUpload? = nil,
            expiration: S3ControlClientTypes.LifecycleExpiration? = nil,
            filter: S3ControlClientTypes.LifecycleRuleFilter? = nil,
            id: Swift.String? = nil,
            noncurrentVersionExpiration: S3ControlClientTypes.NoncurrentVersionExpiration? = nil,
            noncurrentVersionTransitions: [S3ControlClientTypes.NoncurrentVersionTransition]? = nil,
            status: S3ControlClientTypes.ExpirationStatus? = nil,
            transitions: [S3ControlClientTypes.Transition]? = nil
        )
        {
            self.abortIncompleteMultipartUpload = abortIncompleteMultipartUpload
            self.expiration = expiration
            self.filter = filter
            self.id = id
            self.noncurrentVersionExpiration = noncurrentVersionExpiration
            self.noncurrentVersionTransitions = noncurrentVersionTransitions
            self.status = status
            self.transitions = transitions
        }
    }

}

extension S3ControlClientTypes.LifecycleRuleAndOperator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectSizeGreaterThan = "ObjectSizeGreaterThan"
        case objectSizeLessThan = "ObjectSizeLessThan"
        case `prefix` = "Prefix"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let objectSizeGreaterThan = objectSizeGreaterThan {
            try container.encode(objectSizeGreaterThan, forKey: ClientRuntime.Key("ObjectSizeGreaterThan"))
        }
        if let objectSizeLessThan = objectSizeLessThan {
            try container.encode(objectSizeLessThan, forKey: ClientRuntime.Key("ObjectSizeLessThan"))
        }
        if let `prefix` = `prefix` {
            try container.encode(`prefix`, forKey: ClientRuntime.Key("Prefix"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for s3tag0 in tags {
                try tagsContainer.encode(s3tag0, forKey: ClientRuntime.Key("member"))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([S3ControlClientTypes.S3Tag].self, forKey: .member)
                var tagsBuffer:[S3ControlClientTypes.S3Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [S3ControlClientTypes.S3Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let objectSizeGreaterThanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .objectSizeGreaterThan) ?? nil
        objectSizeGreaterThan = objectSizeGreaterThanDecoded
        let objectSizeLessThanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .objectSizeLessThan) ?? nil
        objectSizeLessThan = objectSizeLessThanDecoded
    }
}

extension S3ControlClientTypes.LifecycleRuleAndOperator: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// The container for the Outposts bucket lifecycle rule and operator.
    public struct LifecycleRuleAndOperator: Swift.Equatable {
        /// Minimum object size to which the rule applies.
        public var objectSizeGreaterThan: Swift.Int?
        /// Maximum object size to which the rule applies.
        public var objectSizeLessThan: Swift.Int?
        /// Prefix identifying one or more objects to which the rule applies.
        public var `prefix`: Swift.String?
        /// All of these tags must exist in the object's tag set in order for the rule to apply.
        public var tags: [S3ControlClientTypes.S3Tag]?

        public init(
            objectSizeGreaterThan: Swift.Int? = nil,
            objectSizeLessThan: Swift.Int? = nil,
            `prefix`: Swift.String? = nil,
            tags: [S3ControlClientTypes.S3Tag]? = nil
        )
        {
            self.objectSizeGreaterThan = objectSizeGreaterThan
            self.objectSizeLessThan = objectSizeLessThan
            self.`prefix` = `prefix`
            self.tags = tags
        }
    }

}

extension S3ControlClientTypes.LifecycleRuleFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case and = "And"
        case objectSizeGreaterThan = "ObjectSizeGreaterThan"
        case objectSizeLessThan = "ObjectSizeLessThan"
        case `prefix` = "Prefix"
        case tag = "Tag"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let and = and {
            try container.encode(and, forKey: ClientRuntime.Key("And"))
        }
        if let objectSizeGreaterThan = objectSizeGreaterThan {
            try container.encode(objectSizeGreaterThan, forKey: ClientRuntime.Key("ObjectSizeGreaterThan"))
        }
        if let objectSizeLessThan = objectSizeLessThan {
            try container.encode(objectSizeLessThan, forKey: ClientRuntime.Key("ObjectSizeLessThan"))
        }
        if let `prefix` = `prefix` {
            try container.encode(`prefix`, forKey: ClientRuntime.Key("Prefix"))
        }
        if let tag = tag {
            try container.encode(tag, forKey: ClientRuntime.Key("Tag"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        let tagDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3Tag.self, forKey: .tag)
        tag = tagDecoded
        let andDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.LifecycleRuleAndOperator.self, forKey: .and)
        and = andDecoded
        let objectSizeGreaterThanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .objectSizeGreaterThan) ?? nil
        objectSizeGreaterThan = objectSizeGreaterThanDecoded
        let objectSizeLessThanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .objectSizeLessThan) ?? nil
        objectSizeLessThan = objectSizeLessThanDecoded
    }
}

extension S3ControlClientTypes.LifecycleRuleFilter: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// The container for the filter of the lifecycle rule.
    public struct LifecycleRuleFilter: Swift.Equatable {
        /// The container for the AND condition for the lifecycle rule.
        public var and: S3ControlClientTypes.LifecycleRuleAndOperator?
        /// Minimum object size to which the rule applies.
        public var objectSizeGreaterThan: Swift.Int?
        /// Maximum object size to which the rule applies.
        public var objectSizeLessThan: Swift.Int?
        /// Prefix identifying one or more objects to which the rule applies. When you're using XML requests, you must replace special characters (such as carriage returns) in object keys with their equivalent XML entity codes. For more information, see [ XML-related object key constraints](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints) in the Amazon S3 User Guide.
        public var `prefix`: Swift.String?
        /// A container for a key-value name pair.
        public var tag: S3ControlClientTypes.S3Tag?

        public init(
            and: S3ControlClientTypes.LifecycleRuleAndOperator? = nil,
            objectSizeGreaterThan: Swift.Int? = nil,
            objectSizeLessThan: Swift.Int? = nil,
            `prefix`: Swift.String? = nil,
            tag: S3ControlClientTypes.S3Tag? = nil
        )
        {
            self.and = and
            self.objectSizeGreaterThan = objectSizeGreaterThan
            self.objectSizeLessThan = objectSizeLessThan
            self.`prefix` = `prefix`
            self.tag = tag
        }
    }

}

extension ListAccessPointsForObjectLambdaInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension ListAccessPointsForObjectLambdaInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAccessPointsForObjectLambdaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/accesspointforobjectlambda"
    }
}

public struct ListAccessPointsForObjectLambdaInput: Swift.Equatable {
    /// The account ID for the account that owns the specified Object Lambda Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The maximum number of access points that you want to include in the list. The response may contain fewer access points but will never contain more. If there are more than this number of access points, then the response will include a continuation token in the NextToken field that you can use to retrieve the next page of access points.
    public var maxResults: Swift.Int?
    /// If the list has more access points than can be returned in one call to this API, this field contains a continuation token that you can provide in subsequent calls to this API to retrieve additional access points.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAccessPointsForObjectLambdaInputBody: Swift.Equatable {
}

extension ListAccessPointsForObjectLambdaInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAccessPointsForObjectLambdaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAccessPointsForObjectLambdaOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.objectLambdaAccessPointList = output.objectLambdaAccessPointList
        } else {
            self.nextToken = nil
            self.objectLambdaAccessPointList = nil
        }
    }
}

public struct ListAccessPointsForObjectLambdaOutput: Swift.Equatable {
    /// If the list has more access points than can be returned in one call to this API, this field contains a continuation token that you can provide in subsequent calls to this API to retrieve additional access points.
    public var nextToken: Swift.String?
    /// Returns list of Object Lambda Access Points.
    public var objectLambdaAccessPointList: [S3ControlClientTypes.ObjectLambdaAccessPoint]?

    public init(
        nextToken: Swift.String? = nil,
        objectLambdaAccessPointList: [S3ControlClientTypes.ObjectLambdaAccessPoint]? = nil
    )
    {
        self.nextToken = nextToken
        self.objectLambdaAccessPointList = objectLambdaAccessPointList
    }
}

struct ListAccessPointsForObjectLambdaOutputBody: Swift.Equatable {
    let objectLambdaAccessPointList: [S3ControlClientTypes.ObjectLambdaAccessPoint]?
    let nextToken: Swift.String?
}

extension ListAccessPointsForObjectLambdaOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case objectLambdaAccessPointList = "ObjectLambdaAccessPointList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.objectLambdaAccessPointList) {
            struct KeyVal0{struct ObjectLambdaAccessPoint{}}
            let objectLambdaAccessPointListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ObjectLambdaAccessPoint>.CodingKeys.self, forKey: .objectLambdaAccessPointList)
            if let objectLambdaAccessPointListWrappedContainer = objectLambdaAccessPointListWrappedContainer {
                let objectLambdaAccessPointListContainer = try objectLambdaAccessPointListWrappedContainer.decodeIfPresent([S3ControlClientTypes.ObjectLambdaAccessPoint].self, forKey: .member)
                var objectLambdaAccessPointListBuffer:[S3ControlClientTypes.ObjectLambdaAccessPoint]? = nil
                if let objectLambdaAccessPointListContainer = objectLambdaAccessPointListContainer {
                    objectLambdaAccessPointListBuffer = [S3ControlClientTypes.ObjectLambdaAccessPoint]()
                    for structureContainer0 in objectLambdaAccessPointListContainer {
                        objectLambdaAccessPointListBuffer?.append(structureContainer0)
                    }
                }
                objectLambdaAccessPointList = objectLambdaAccessPointListBuffer
            } else {
                objectLambdaAccessPointList = []
            }
        } else {
            objectLambdaAccessPointList = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAccessPointsForObjectLambdaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListAccessPointsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension ListAccessPointsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let bucket = bucket {
                let bucketQueryItem = ClientRuntime.URLQueryItem(name: "bucket".urlPercentEncoding(), value: Swift.String(bucket).urlPercentEncoding())
                items.append(bucketQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAccessPointsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/accesspoint"
    }
}

public struct ListAccessPointsInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the account that owns the specified access points.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the bucket whose associated access points you want to list. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    public var bucket: Swift.String?
    /// The maximum number of access points that you want to include in the list. If the specified bucket has more than this number of access points, then the response will include a continuation token in the NextToken field that you can use to retrieve the next page of access points.
    public var maxResults: Swift.Int?
    /// A continuation token. If a previous call to ListAccessPoints returned a continuation token in the NextToken field, then providing that value here causes Amazon S3 to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAccessPointsInputBody: Swift.Equatable {
}

extension ListAccessPointsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAccessPointsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAccessPointsOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessPointList = output.accessPointList
            self.nextToken = output.nextToken
        } else {
            self.accessPointList = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccessPointsOutput: Swift.Equatable {
    /// Contains identification and configuration information for one or more access points associated with the specified bucket.
    public var accessPointList: [S3ControlClientTypes.AccessPoint]?
    /// If the specified bucket has more access points than can be returned in one call to this API, this field contains a continuation token that you can provide in subsequent calls to this API to retrieve additional access points.
    public var nextToken: Swift.String?

    public init(
        accessPointList: [S3ControlClientTypes.AccessPoint]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accessPointList = accessPointList
        self.nextToken = nextToken
    }
}

struct ListAccessPointsOutputBody: Swift.Equatable {
    let accessPointList: [S3ControlClientTypes.AccessPoint]?
    let nextToken: Swift.String?
}

extension ListAccessPointsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPointList = "AccessPointList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.accessPointList) {
            struct KeyVal0{struct AccessPoint{}}
            let accessPointListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AccessPoint>.CodingKeys.self, forKey: .accessPointList)
            if let accessPointListWrappedContainer = accessPointListWrappedContainer {
                let accessPointListContainer = try accessPointListWrappedContainer.decodeIfPresent([S3ControlClientTypes.AccessPoint].self, forKey: .member)
                var accessPointListBuffer:[S3ControlClientTypes.AccessPoint]? = nil
                if let accessPointListContainer = accessPointListContainer {
                    accessPointListBuffer = [S3ControlClientTypes.AccessPoint]()
                    for structureContainer0 in accessPointListContainer {
                        accessPointListBuffer?.append(structureContainer0)
                    }
                }
                accessPointList = accessPointListBuffer
            } else {
                accessPointList = []
            }
        } else {
            accessPointList = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAccessPointsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListJobsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension ListJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let jobStatuses = jobStatuses {
                jobStatuses.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "jobStatuses".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/jobs"
    }
}

public struct ListJobsInput: Swift.Equatable {
    /// The Amazon Web Services account ID associated with the S3 Batch Operations job.
    /// This member is required.
    public var accountId: Swift.String?
    /// The List Jobs request returns jobs that match the statuses listed in this element.
    public var jobStatuses: [S3ControlClientTypes.JobStatus]?
    /// The maximum number of jobs that Amazon S3 will include in the List Jobs response. If there are more jobs than this number, the response will include a pagination token in the NextToken field to enable you to retrieve the next page of results.
    public var maxResults: Swift.Int?
    /// A pagination token to request the next page of results. Use the token that Amazon S3 returned in the NextToken element of the ListJobsResult from the previous List Jobs request.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        jobStatuses: [S3ControlClientTypes.JobStatus]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.jobStatuses = jobStatuses
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListJobsInputBody: Swift.Equatable {
}

extension ListJobsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobs = output.jobs
            self.nextToken = output.nextToken
        } else {
            self.jobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListJobsOutput: Swift.Equatable {
    /// The list of current jobs and jobs that have ended within the last 30 days.
    public var jobs: [S3ControlClientTypes.JobListDescriptor]?
    /// If the List Jobs request produced more than the maximum number of results, you can pass this value into a subsequent List Jobs request in order to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        jobs: [S3ControlClientTypes.JobListDescriptor]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

struct ListJobsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let jobs: [S3ControlClientTypes.JobListDescriptor]?
}

extension ListJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobs = "Jobs"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        if containerValues.contains(.jobs) {
            struct KeyVal0{struct member{}}
            let jobsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .jobs)
            if let jobsWrappedContainer = jobsWrappedContainer {
                let jobsContainer = try jobsWrappedContainer.decodeIfPresent([S3ControlClientTypes.JobListDescriptor].self, forKey: .member)
                var jobsBuffer:[S3ControlClientTypes.JobListDescriptor]? = nil
                if let jobsContainer = jobsContainer {
                    jobsBuffer = [S3ControlClientTypes.JobListDescriptor]()
                    for structureContainer0 in jobsContainer {
                        jobsBuffer?.append(structureContainer0)
                    }
                }
                jobs = jobsBuffer
            } else {
                jobs = []
            }
        } else {
            jobs = nil
        }
    }
}

enum ListJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListMultiRegionAccessPointsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension ListMultiRegionAccessPointsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListMultiRegionAccessPointsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/mrap/instances"
    }
}

public struct ListMultiRegionAccessPointsInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the owner of the Multi-Region Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// Not currently used. Do not use this parameter.
    public var maxResults: Swift.Int?
    /// Not currently used. Do not use this parameter.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMultiRegionAccessPointsInputBody: Swift.Equatable {
}

extension ListMultiRegionAccessPointsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListMultiRegionAccessPointsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMultiRegionAccessPointsOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessPoints = output.accessPoints
            self.nextToken = output.nextToken
        } else {
            self.accessPoints = nil
            self.nextToken = nil
        }
    }
}

public struct ListMultiRegionAccessPointsOutput: Swift.Equatable {
    /// The list of Multi-Region Access Points associated with the user.
    public var accessPoints: [S3ControlClientTypes.MultiRegionAccessPointReport]?
    /// If the specified bucket has more Multi-Region Access Points than can be returned in one call to this action, this field contains a continuation token. You can use this token tin subsequent calls to this action to retrieve additional Multi-Region Access Points.
    public var nextToken: Swift.String?

    public init(
        accessPoints: [S3ControlClientTypes.MultiRegionAccessPointReport]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accessPoints = accessPoints
        self.nextToken = nextToken
    }
}

struct ListMultiRegionAccessPointsOutputBody: Swift.Equatable {
    let accessPoints: [S3ControlClientTypes.MultiRegionAccessPointReport]?
    let nextToken: Swift.String?
}

extension ListMultiRegionAccessPointsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPoints = "AccessPoints"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.accessPoints) {
            struct KeyVal0{struct AccessPoint{}}
            let accessPointsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AccessPoint>.CodingKeys.self, forKey: .accessPoints)
            if let accessPointsWrappedContainer = accessPointsWrappedContainer {
                let accessPointsContainer = try accessPointsWrappedContainer.decodeIfPresent([S3ControlClientTypes.MultiRegionAccessPointReport].self, forKey: .member)
                var accessPointsBuffer:[S3ControlClientTypes.MultiRegionAccessPointReport]? = nil
                if let accessPointsContainer = accessPointsContainer {
                    accessPointsBuffer = [S3ControlClientTypes.MultiRegionAccessPointReport]()
                    for structureContainer0 in accessPointsContainer {
                        accessPointsBuffer?.append(structureContainer0)
                    }
                }
                accessPoints = accessPointsBuffer
            } else {
                accessPoints = []
            }
        } else {
            accessPoints = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListMultiRegionAccessPointsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListRegionalBucketsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        if let outpostId = outpostId {
            items.add(Header(name: "x-amz-outpost-id", value: Swift.String(outpostId)))
        }
        return items
    }
}

extension ListRegionalBucketsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListRegionalBucketsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/bucket"
    }
}

public struct ListRegionalBucketsInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    ///
    public var maxResults: Swift.Int?
    ///
    public var nextToken: Swift.String?
    /// The ID of the Outposts resource. This ID is required by Amazon S3 on Outposts buckets.
    public var outpostId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        outpostId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.outpostId = outpostId
    }
}

struct ListRegionalBucketsInputBody: Swift.Equatable {
}

extension ListRegionalBucketsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListRegionalBucketsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRegionalBucketsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.regionalBucketList = output.regionalBucketList
        } else {
            self.nextToken = nil
            self.regionalBucketList = nil
        }
    }
}

public struct ListRegionalBucketsOutput: Swift.Equatable {
    /// NextToken is sent when isTruncated is true, which means there are more buckets that can be listed. The next list requests to Amazon S3 can be continued with this NextToken. NextToken is obfuscated and is not a real key.
    public var nextToken: Swift.String?
    ///
    public var regionalBucketList: [S3ControlClientTypes.RegionalBucket]?

    public init(
        nextToken: Swift.String? = nil,
        regionalBucketList: [S3ControlClientTypes.RegionalBucket]? = nil
    )
    {
        self.nextToken = nextToken
        self.regionalBucketList = regionalBucketList
    }
}

struct ListRegionalBucketsOutputBody: Swift.Equatable {
    let regionalBucketList: [S3ControlClientTypes.RegionalBucket]?
    let nextToken: Swift.String?
}

extension ListRegionalBucketsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case regionalBucketList = "RegionalBucketList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.regionalBucketList) {
            struct KeyVal0{struct RegionalBucket{}}
            let regionalBucketListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.RegionalBucket>.CodingKeys.self, forKey: .regionalBucketList)
            if let regionalBucketListWrappedContainer = regionalBucketListWrappedContainer {
                let regionalBucketListContainer = try regionalBucketListWrappedContainer.decodeIfPresent([S3ControlClientTypes.RegionalBucket].self, forKey: .member)
                var regionalBucketListBuffer:[S3ControlClientTypes.RegionalBucket]? = nil
                if let regionalBucketListContainer = regionalBucketListContainer {
                    regionalBucketListBuffer = [S3ControlClientTypes.RegionalBucket]()
                    for structureContainer0 in regionalBucketListContainer {
                        regionalBucketListBuffer?.append(structureContainer0)
                    }
                }
                regionalBucketList = regionalBucketListBuffer
            } else {
                regionalBucketList = []
            }
        } else {
            regionalBucketList = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRegionalBucketsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension S3ControlClientTypes.ListStorageLensConfigurationEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case homeRegion = "HomeRegion"
        case id = "Id"
        case isEnabled = "IsEnabled"
        case storageLensArn = "StorageLensArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let homeRegion = homeRegion {
            try container.encode(homeRegion, forKey: ClientRuntime.Key("HomeRegion"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if isEnabled != false {
            try container.encode(isEnabled, forKey: ClientRuntime.Key("IsEnabled"))
        }
        if let storageLensArn = storageLensArn {
            try container.encode(storageLensArn, forKey: ClientRuntime.Key("StorageLensArn"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let storageLensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageLensArn)
        storageLensArn = storageLensArnDecoded
        let homeRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
        let isEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isEnabled) ?? false
        isEnabled = isEnabledDecoded
    }
}

extension S3ControlClientTypes.ListStorageLensConfigurationEntry: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// Part of ListStorageLensConfigurationResult. Each entry includes the description of the S3 Storage Lens configuration, its home Region, whether it is enabled, its Amazon Resource Name (ARN), and config ID.
    public struct ListStorageLensConfigurationEntry: Swift.Equatable {
        /// A container for the S3 Storage Lens home Region. Your metrics data is stored and retained in your designated S3 Storage Lens home Region.
        /// This member is required.
        public var homeRegion: Swift.String?
        /// A container for the S3 Storage Lens configuration ID.
        /// This member is required.
        public var id: Swift.String?
        /// A container for whether the S3 Storage Lens configuration is enabled. This property is required.
        public var isEnabled: Swift.Bool
        /// The ARN of the S3 Storage Lens configuration. This property is read-only.
        /// This member is required.
        public var storageLensArn: Swift.String?

        public init(
            homeRegion: Swift.String? = nil,
            id: Swift.String? = nil,
            isEnabled: Swift.Bool = false,
            storageLensArn: Swift.String? = nil
        )
        {
            self.homeRegion = homeRegion
            self.id = id
            self.isEnabled = isEnabled
            self.storageLensArn = storageLensArn
        }
    }

}

extension ListStorageLensConfigurationsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension ListStorageLensConfigurationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListStorageLensConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/storagelens"
    }
}

public struct ListStorageLensConfigurationsInput: Swift.Equatable {
    /// The account ID of the requester.
    /// This member is required.
    public var accountId: Swift.String?
    /// A pagination token to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.nextToken = nextToken
    }
}

struct ListStorageLensConfigurationsInputBody: Swift.Equatable {
}

extension ListStorageLensConfigurationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListStorageLensConfigurationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListStorageLensConfigurationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.storageLensConfigurationList = output.storageLensConfigurationList
        } else {
            self.nextToken = nil
            self.storageLensConfigurationList = nil
        }
    }
}

public struct ListStorageLensConfigurationsOutput: Swift.Equatable {
    /// If the request produced more than the maximum number of S3 Storage Lens configuration results, you can pass this value into a subsequent request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// A list of S3 Storage Lens configurations.
    public var storageLensConfigurationList: [S3ControlClientTypes.ListStorageLensConfigurationEntry]?

    public init(
        nextToken: Swift.String? = nil,
        storageLensConfigurationList: [S3ControlClientTypes.ListStorageLensConfigurationEntry]? = nil
    )
    {
        self.nextToken = nextToken
        self.storageLensConfigurationList = storageLensConfigurationList
    }
}

struct ListStorageLensConfigurationsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let storageLensConfigurationList: [S3ControlClientTypes.ListStorageLensConfigurationEntry]?
}

extension ListStorageLensConfigurationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case storageLensConfigurationList = "StorageLensConfigurationList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        if containerValues.contains(.storageLensConfigurationList) {
            let storageLensConfigurationListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .storageLensConfigurationList)
            if storageLensConfigurationListWrappedContainer != nil {
                let storageLensConfigurationListContainer = try containerValues.decodeIfPresent([S3ControlClientTypes.ListStorageLensConfigurationEntry].self, forKey: .storageLensConfigurationList)
                var storageLensConfigurationListBuffer:[S3ControlClientTypes.ListStorageLensConfigurationEntry]? = nil
                if let storageLensConfigurationListContainer = storageLensConfigurationListContainer {
                    storageLensConfigurationListBuffer = [S3ControlClientTypes.ListStorageLensConfigurationEntry]()
                    for structureContainer0 in storageLensConfigurationListContainer {
                        storageLensConfigurationListBuffer?.append(structureContainer0)
                    }
                }
                storageLensConfigurationList = storageLensConfigurationListBuffer
            } else {
                storageLensConfigurationList = []
            }
        } else {
            storageLensConfigurationList = nil
        }
    }
}

enum ListStorageLensConfigurationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension S3ControlClientTypes {
    public enum MFADelete: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [MFADelete] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MFADelete(rawValue: rawValue) ?? MFADelete.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum MFADeleteStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [MFADeleteStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MFADeleteStatus(rawValue: rawValue) ?? MFADeleteStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.Metrics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventThreshold = "EventThreshold"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let eventThreshold = eventThreshold {
            try container.encode(eventThreshold, forKey: ClientRuntime.Key("EventThreshold"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.MetricsStatus.self, forKey: .status)
        status = statusDecoded
        let eventThresholdDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ReplicationTimeValue.self, forKey: .eventThreshold)
        eventThreshold = eventThresholdDecoded
    }
}

extension S3ControlClientTypes.Metrics: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// A container that specifies replication metrics-related settings.
    public struct Metrics: Swift.Equatable {
        /// A container that specifies the time threshold for emitting the s3:Replication:OperationMissedThreshold event. This is not supported by Amazon S3 on Outposts buckets.
        public var eventThreshold: S3ControlClientTypes.ReplicationTimeValue?
        /// Specifies whether replication metrics are enabled.
        /// This member is required.
        public var status: S3ControlClientTypes.MetricsStatus?

        public init(
            eventThreshold: S3ControlClientTypes.ReplicationTimeValue? = nil,
            status: S3ControlClientTypes.MetricsStatus? = nil
        )
        {
            self.eventThreshold = eventThreshold
            self.status = status
        }
    }

}

extension S3ControlClientTypes {
    public enum MetricsStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [MetricsStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MetricsStatus(rawValue: rawValue) ?? MetricsStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.MultiRegionAccessPointPolicyDocument: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case established = "Established"
        case proposed = "Proposed"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let established = established {
            try container.encode(established, forKey: ClientRuntime.Key("Established"))
        }
        if let proposed = proposed {
            try container.encode(proposed, forKey: ClientRuntime.Key("Proposed"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let establishedDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.EstablishedMultiRegionAccessPointPolicy.self, forKey: .established)
        established = establishedDecoded
        let proposedDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ProposedMultiRegionAccessPointPolicy.self, forKey: .proposed)
        proposed = proposedDecoded
    }
}

extension S3ControlClientTypes.MultiRegionAccessPointPolicyDocument: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// The Multi-Region Access Point access control policy. When you update the policy, the update is first listed as the proposed policy. After the update is finished and all Regions have been updated, the proposed policy is listed as the established policy. If both policies have the same version number, the proposed policy is the established policy.
    public struct MultiRegionAccessPointPolicyDocument: Swift.Equatable {
        /// The last established policy for the Multi-Region Access Point.
        public var established: S3ControlClientTypes.EstablishedMultiRegionAccessPointPolicy?
        /// The proposed policy for the Multi-Region Access Point.
        public var proposed: S3ControlClientTypes.ProposedMultiRegionAccessPointPolicy?

        public init(
            established: S3ControlClientTypes.EstablishedMultiRegionAccessPointPolicy? = nil,
            proposed: S3ControlClientTypes.ProposedMultiRegionAccessPointPolicy? = nil
        )
        {
            self.established = established
            self.proposed = proposed
        }
    }

}

extension S3ControlClientTypes.MultiRegionAccessPointRegionalResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case requestStatus = "RequestStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let requestStatus = requestStatus {
            try container.encode(requestStatus, forKey: ClientRuntime.Key("RequestStatus"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let requestStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestStatus)
        requestStatus = requestStatusDecoded
    }
}

extension S3ControlClientTypes.MultiRegionAccessPointRegionalResponse: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// Status information for a single Multi-Region Access Point Region.
    public struct MultiRegionAccessPointRegionalResponse: Swift.Equatable {
        /// The name of the Region in the Multi-Region Access Point.
        public var name: Swift.String?
        /// The current status of the Multi-Region Access Point in this Region.
        public var requestStatus: Swift.String?

        public init(
            name: Swift.String? = nil,
            requestStatus: Swift.String? = nil
        )
        {
            self.name = name
            self.requestStatus = requestStatus
        }
    }

}

extension S3ControlClientTypes.MultiRegionAccessPointReport: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case createdAt = "CreatedAt"
        case name = "Name"
        case publicAccessBlock = "PublicAccessBlock"
        case regions = "Regions"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let alias = alias {
            try container.encode(alias, forKey: ClientRuntime.Key("Alias"))
        }
        if let createdAt = createdAt {
            try container.encodeTimestamp(createdAt, format: .dateTime, forKey: ClientRuntime.Key("CreatedAt"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let publicAccessBlock = publicAccessBlock {
            try container.encode(publicAccessBlock, forKey: ClientRuntime.Key("PublicAccessBlock"))
        }
        if let regions = regions {
            var regionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Regions"))
            for regionreport0 in regions {
                try regionsContainer.encode(regionreport0, forKey: ClientRuntime.Key("Region"))
            }
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let publicAccessBlockDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.PublicAccessBlockConfiguration.self, forKey: .publicAccessBlock)
        publicAccessBlock = publicAccessBlockDecoded
        let statusDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.MultiRegionAccessPointStatus.self, forKey: .status)
        status = statusDecoded
        if containerValues.contains(.regions) {
            struct KeyVal0{struct Region{}}
            let regionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Region>.CodingKeys.self, forKey: .regions)
            if let regionsWrappedContainer = regionsWrappedContainer {
                let regionsContainer = try regionsWrappedContainer.decodeIfPresent([S3ControlClientTypes.RegionReport].self, forKey: .member)
                var regionsBuffer:[S3ControlClientTypes.RegionReport]? = nil
                if let regionsContainer = regionsContainer {
                    regionsBuffer = [S3ControlClientTypes.RegionReport]()
                    for structureContainer0 in regionsContainer {
                        regionsBuffer?.append(structureContainer0)
                    }
                }
                regions = regionsBuffer
            } else {
                regions = []
            }
        } else {
            regions = nil
        }
    }
}

extension S3ControlClientTypes.MultiRegionAccessPointReport: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// A collection of statuses for a Multi-Region Access Point in the various Regions it supports.
    public struct MultiRegionAccessPointReport: Swift.Equatable {
        /// The alias for the Multi-Region Access Point. For more information about the distinction between the name and the alias of an Multi-Region Access Point, see [Managing Multi-Region Access Points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/CreatingMultiRegionAccessPoints.html#multi-region-access-point-naming).
        public var alias: Swift.String?
        /// When the Multi-Region Access Point create request was received.
        public var createdAt: ClientRuntime.Date?
        /// The name of the Multi-Region Access Point.
        public var name: Swift.String?
        /// The PublicAccessBlock configuration that you want to apply to this Amazon S3 account. You can enable the configuration options in any combination. For more information about when Amazon S3 considers a bucket or object public, see [The Meaning of "Public"](https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status) in the Amazon S3 User Guide. This data type is not supported for Amazon S3 on Outposts.
        public var publicAccessBlock: S3ControlClientTypes.PublicAccessBlockConfiguration?
        /// A collection of the Regions and buckets associated with the Multi-Region Access Point.
        public var regions: [S3ControlClientTypes.RegionReport]?
        /// The current status of the Multi-Region Access Point. CREATING and DELETING are temporary states that exist while the request is propagating and being completed. If a Multi-Region Access Point has a status of PARTIALLY_CREATED, you can retry creation or send a request to delete the Multi-Region Access Point. If a Multi-Region Access Point has a status of PARTIALLY_DELETED, you can retry a delete request to finish the deletion of the Multi-Region Access Point.
        public var status: S3ControlClientTypes.MultiRegionAccessPointStatus?

        public init(
            alias: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            publicAccessBlock: S3ControlClientTypes.PublicAccessBlockConfiguration? = nil,
            regions: [S3ControlClientTypes.RegionReport]? = nil,
            status: S3ControlClientTypes.MultiRegionAccessPointStatus? = nil
        )
        {
            self.alias = alias
            self.createdAt = createdAt
            self.name = name
            self.publicAccessBlock = publicAccessBlock
            self.regions = regions
            self.status = status
        }
    }

}

extension S3ControlClientTypes.MultiRegionAccessPointRoute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case region = "Region"
        case trafficDialPercentage = "TrafficDialPercentage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let bucket = bucket {
            try container.encode(bucket, forKey: ClientRuntime.Key("Bucket"))
        }
        if let region = region {
            try container.encode(region, forKey: ClientRuntime.Key("Region"))
        }
        if let trafficDialPercentage = trafficDialPercentage {
            try container.encode(trafficDialPercentage, forKey: ClientRuntime.Key("TrafficDialPercentage"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let trafficDialPercentageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .trafficDialPercentage)
        trafficDialPercentage = trafficDialPercentageDecoded
    }
}

extension S3ControlClientTypes.MultiRegionAccessPointRoute: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// A structure for a Multi-Region Access Point that indicates where Amazon S3 traffic can be routed. Routes can be either active or passive. Active routes can process Amazon S3 requests through the Multi-Region Access Point, but passive routes are not eligible to process Amazon S3 requests. Each route contains the Amazon S3 bucket name and the Amazon Web Services Region that the bucket is located in. The route also includes the TrafficDialPercentage value, which shows whether the bucket and Region are active (indicated by a value of 100) or passive (indicated by a value of 0).
    public struct MultiRegionAccessPointRoute: Swift.Equatable {
        /// The name of the Amazon S3 bucket for which you'll submit a routing configuration change. Either the Bucket or the Region value must be provided. If both are provided, the bucket must be in the specified Region.
        public var bucket: Swift.String?
        /// The Amazon Web Services Region to which you'll be submitting a routing configuration change. Either the Bucket or the Region value must be provided. If both are provided, the bucket must be in the specified Region.
        public var region: Swift.String?
        /// The traffic state for the specified bucket or Amazon Web Services Region. A value of 0 indicates a passive state, which means that no new traffic will be routed to the Region. A value of 100 indicates an active state, which means that traffic will be routed to the specified Region. When the routing configuration for a Region is changed from active to passive, any in-progress operations (uploads, copies, deletes, and so on) to the formerly active Region will continue to run to until a final success or failure status is reached. If all Regions in the routing configuration are designated as passive, you'll receive an InvalidRequest error.
        /// This member is required.
        public var trafficDialPercentage: Swift.Int?

        public init(
            bucket: Swift.String? = nil,
            region: Swift.String? = nil,
            trafficDialPercentage: Swift.Int? = nil
        )
        {
            self.bucket = bucket
            self.region = region
            self.trafficDialPercentage = trafficDialPercentage
        }
    }

}

extension S3ControlClientTypes {
    public enum MultiRegionAccessPointStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case creating
        case deleting
        case inconsistentAcrossRegions
        case partiallyCreated
        case partiallyDeleted
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [MultiRegionAccessPointStatus] {
            return [
                .creating,
                .deleting,
                .inconsistentAcrossRegions,
                .partiallyCreated,
                .partiallyDeleted,
                .ready,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .inconsistentAcrossRegions: return "INCONSISTENT_ACROSS_REGIONS"
            case .partiallyCreated: return "PARTIALLY_CREATED"
            case .partiallyDeleted: return "PARTIALLY_DELETED"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MultiRegionAccessPointStatus(rawValue: rawValue) ?? MultiRegionAccessPointStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.MultiRegionAccessPointsAsyncResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case regions = "Regions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let regions = regions {
            var regionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Regions"))
            for multiregionaccesspointregionalresponse0 in regions {
                try regionsContainer.encode(multiregionaccesspointregionalresponse0, forKey: ClientRuntime.Key("Region"))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.regions) {
            struct KeyVal0{struct Region{}}
            let regionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Region>.CodingKeys.self, forKey: .regions)
            if let regionsWrappedContainer = regionsWrappedContainer {
                let regionsContainer = try regionsWrappedContainer.decodeIfPresent([S3ControlClientTypes.MultiRegionAccessPointRegionalResponse].self, forKey: .member)
                var regionsBuffer:[S3ControlClientTypes.MultiRegionAccessPointRegionalResponse]? = nil
                if let regionsContainer = regionsContainer {
                    regionsBuffer = [S3ControlClientTypes.MultiRegionAccessPointRegionalResponse]()
                    for structureContainer0 in regionsContainer {
                        regionsBuffer?.append(structureContainer0)
                    }
                }
                regions = regionsBuffer
            } else {
                regions = []
            }
        } else {
            regions = nil
        }
    }
}

extension S3ControlClientTypes.MultiRegionAccessPointsAsyncResponse: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// The Multi-Region Access Point details that are returned when querying about an asynchronous request.
    public struct MultiRegionAccessPointsAsyncResponse: Swift.Equatable {
        /// A collection of status information for the different Regions that a Multi-Region Access Point supports.
        public var regions: [S3ControlClientTypes.MultiRegionAccessPointRegionalResponse]?

        public init(
            regions: [S3ControlClientTypes.MultiRegionAccessPointRegionalResponse]? = nil
        )
        {
            self.regions = regions
        }
    }

}

extension S3ControlClientTypes {
    public enum NetworkOrigin: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internet
        case vpc
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkOrigin] {
            return [
                .internet,
                .vpc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internet: return "Internet"
            case .vpc: return "VPC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NetworkOrigin(rawValue: rawValue) ?? NetworkOrigin.sdkUnknown(rawValue)
        }
    }
}

extension NoSuchPublicAccessBlockConfiguration {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchPublicAccessBlockConfigurationBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Amazon S3 throws this exception if you make a GetPublicAccessBlock request against an account that doesn't have a PublicAccessBlockConfiguration set.
public struct NoSuchPublicAccessBlockConfiguration: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchPublicAccessBlockConfiguration" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NoSuchPublicAccessBlockConfigurationBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchPublicAccessBlockConfigurationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension S3ControlClientTypes.NoncurrentVersionExpiration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case newerNoncurrentVersions = "NewerNoncurrentVersions"
        case noncurrentDays = "NoncurrentDays"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let newerNoncurrentVersions = newerNoncurrentVersions {
            try container.encode(newerNoncurrentVersions, forKey: ClientRuntime.Key("NewerNoncurrentVersions"))
        }
        if noncurrentDays != 0 {
            try container.encode(noncurrentDays, forKey: ClientRuntime.Key("NoncurrentDays"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let noncurrentDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .noncurrentDays) ?? 0
        noncurrentDays = noncurrentDaysDecoded
        let newerNoncurrentVersionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .newerNoncurrentVersions) ?? nil
        newerNoncurrentVersions = newerNoncurrentVersionsDecoded
    }
}

extension S3ControlClientTypes.NoncurrentVersionExpiration: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// The container of the noncurrent version expiration.
    public struct NoncurrentVersionExpiration: Swift.Equatable {
        /// Specifies how many noncurrent versions S3 on Outposts will retain. If there are this many more recent noncurrent versions, S3 on Outposts will take the associated action. For more information about noncurrent versions, see [Lifecycle configuration elements](https://docs.aws.amazon.com/AmazonS3/latest/userguide/intro-lifecycle-rules.html) in the Amazon S3 User Guide.
        public var newerNoncurrentVersions: Swift.Int?
        /// Specifies the number of days an object is noncurrent before Amazon S3 can perform the associated action. For information about the noncurrent days calculations, see [How Amazon S3 Calculates When an Object Became Noncurrent](https://docs.aws.amazon.com/AmazonS3/latest/dev/intro-lifecycle-rules.html#non-current-days-calculations) in the Amazon S3 User Guide.
        public var noncurrentDays: Swift.Int

        public init(
            newerNoncurrentVersions: Swift.Int? = nil,
            noncurrentDays: Swift.Int = 0
        )
        {
            self.newerNoncurrentVersions = newerNoncurrentVersions
            self.noncurrentDays = noncurrentDays
        }
    }

}

extension S3ControlClientTypes.NoncurrentVersionTransition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case noncurrentDays = "NoncurrentDays"
        case storageClass = "StorageClass"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if noncurrentDays != 0 {
            try container.encode(noncurrentDays, forKey: ClientRuntime.Key("NoncurrentDays"))
        }
        if let storageClass = storageClass {
            try container.encode(storageClass, forKey: ClientRuntime.Key("StorageClass"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let noncurrentDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .noncurrentDays) ?? 0
        noncurrentDays = noncurrentDaysDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.TransitionStorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
    }
}

extension S3ControlClientTypes.NoncurrentVersionTransition: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// The container for the noncurrent version transition.
    public struct NoncurrentVersionTransition: Swift.Equatable {
        /// Specifies the number of days an object is noncurrent before Amazon S3 can perform the associated action. For information about the noncurrent days calculations, see [ How Amazon S3 Calculates How Long an Object Has Been Noncurrent](https://docs.aws.amazon.com/AmazonS3/latest/dev/intro-lifecycle-rules.html#non-current-days-calculations) in the Amazon S3 User Guide.
        public var noncurrentDays: Swift.Int
        /// The class of storage used to store the object.
        public var storageClass: S3ControlClientTypes.TransitionStorageClass?

        public init(
            noncurrentDays: Swift.Int = 0,
            storageClass: S3ControlClientTypes.TransitionStorageClass? = nil
        )
        {
            self.noncurrentDays = noncurrentDays
            self.storageClass = storageClass
        }
    }

}

extension NotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<NotFoundExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension S3ControlClientTypes.ObjectLambdaAccessPoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case name = "Name"
        case objectLambdaAccessPointArn = "ObjectLambdaAccessPointArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let alias = alias {
            try container.encode(alias, forKey: ClientRuntime.Key("Alias"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let objectLambdaAccessPointArn = objectLambdaAccessPointArn {
            try container.encode(objectLambdaAccessPointArn, forKey: ClientRuntime.Key("ObjectLambdaAccessPointArn"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let objectLambdaAccessPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectLambdaAccessPointArn)
        objectLambdaAccessPointArn = objectLambdaAccessPointArnDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ObjectLambdaAccessPointAlias.self, forKey: .alias)
        alias = aliasDecoded
    }
}

extension S3ControlClientTypes.ObjectLambdaAccessPoint: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// An access point with an attached Lambda function used to access transformed data from an Amazon S3 bucket.
    public struct ObjectLambdaAccessPoint: Swift.Equatable {
        /// The alias of the Object Lambda Access Point.
        public var alias: S3ControlClientTypes.ObjectLambdaAccessPointAlias?
        /// The name of the Object Lambda Access Point.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies the ARN for the Object Lambda Access Point.
        public var objectLambdaAccessPointArn: Swift.String?

        public init(
            alias: S3ControlClientTypes.ObjectLambdaAccessPointAlias? = nil,
            name: Swift.String? = nil,
            objectLambdaAccessPointArn: Swift.String? = nil
        )
        {
            self.alias = alias
            self.name = name
            self.objectLambdaAccessPointArn = objectLambdaAccessPointArn
        }
    }

}

extension S3ControlClientTypes.ObjectLambdaAccessPointAlias: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let value = value {
            try container.encode(value, forKey: ClientRuntime.Key("Value"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let statusDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ObjectLambdaAccessPointAliasStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension S3ControlClientTypes.ObjectLambdaAccessPointAlias: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// The alias of an Object Lambda Access Point. For more information, see [How to use a bucket-style alias for your S3 bucket Object Lambda Access Point](https://docs.aws.amazon.com/AmazonS3/latest/userguide/olap-use.html#ol-access-points-alias).
    public struct ObjectLambdaAccessPointAlias: Swift.Equatable {
        /// The status of the Object Lambda Access Point alias. If the status is PROVISIONING, the Object Lambda Access Point is provisioning the alias and the alias is not ready for use yet. If the status is READY, the Object Lambda Access Point alias is successfully provisioned and ready for use.
        public var status: S3ControlClientTypes.ObjectLambdaAccessPointAliasStatus?
        /// The alias value of the Object Lambda Access Point.
        public var value: Swift.String?

        public init(
            status: S3ControlClientTypes.ObjectLambdaAccessPointAliasStatus? = nil,
            value: Swift.String? = nil
        )
        {
            self.status = status
            self.value = value
        }
    }

}

extension S3ControlClientTypes {
    public enum ObjectLambdaAccessPointAliasStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case provisioning
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [ObjectLambdaAccessPointAliasStatus] {
            return [
                .provisioning,
                .ready,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .provisioning: return "PROVISIONING"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ObjectLambdaAccessPointAliasStatus(rawValue: rawValue) ?? ObjectLambdaAccessPointAliasStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum ObjectLambdaAllowedFeature: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case getobjectpartnumber
        case getobjectrange
        case headobjectpartnumber
        case headobjectrange
        case sdkUnknown(Swift.String)

        public static var allCases: [ObjectLambdaAllowedFeature] {
            return [
                .getobjectpartnumber,
                .getobjectrange,
                .headobjectpartnumber,
                .headobjectrange,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .getobjectpartnumber: return "GetObject-PartNumber"
            case .getobjectrange: return "GetObject-Range"
            case .headobjectpartnumber: return "HeadObject-PartNumber"
            case .headobjectrange: return "HeadObject-Range"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ObjectLambdaAllowedFeature(rawValue: rawValue) ?? ObjectLambdaAllowedFeature.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.ObjectLambdaConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedFeatures = "AllowedFeatures"
        case cloudWatchMetricsEnabled = "CloudWatchMetricsEnabled"
        case supportingAccessPoint = "SupportingAccessPoint"
        case transformationConfigurations = "TransformationConfigurations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let allowedFeatures = allowedFeatures {
            var allowedFeaturesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AllowedFeatures"))
            for objectlambdaallowedfeature0 in allowedFeatures {
                try allowedFeaturesContainer.encode(objectlambdaallowedfeature0, forKey: ClientRuntime.Key("AllowedFeature"))
            }
        }
        if cloudWatchMetricsEnabled != false {
            try container.encode(cloudWatchMetricsEnabled, forKey: ClientRuntime.Key("CloudWatchMetricsEnabled"))
        }
        if let supportingAccessPoint = supportingAccessPoint {
            try container.encode(supportingAccessPoint, forKey: ClientRuntime.Key("SupportingAccessPoint"))
        }
        if let transformationConfigurations = transformationConfigurations {
            var transformationConfigurationsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TransformationConfigurations"))
            for objectlambdatransformationconfiguration0 in transformationConfigurations {
                try transformationConfigurationsContainer.encode(objectlambdatransformationconfiguration0, forKey: ClientRuntime.Key("TransformationConfiguration"))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let supportingAccessPointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supportingAccessPoint)
        supportingAccessPoint = supportingAccessPointDecoded
        let cloudWatchMetricsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cloudWatchMetricsEnabled) ?? false
        cloudWatchMetricsEnabled = cloudWatchMetricsEnabledDecoded
        if containerValues.contains(.allowedFeatures) {
            struct KeyVal0{struct AllowedFeature{}}
            let allowedFeaturesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AllowedFeature>.CodingKeys.self, forKey: .allowedFeatures)
            if let allowedFeaturesWrappedContainer = allowedFeaturesWrappedContainer {
                let allowedFeaturesContainer = try allowedFeaturesWrappedContainer.decodeIfPresent([S3ControlClientTypes.ObjectLambdaAllowedFeature].self, forKey: .member)
                var allowedFeaturesBuffer:[S3ControlClientTypes.ObjectLambdaAllowedFeature]? = nil
                if let allowedFeaturesContainer = allowedFeaturesContainer {
                    allowedFeaturesBuffer = [S3ControlClientTypes.ObjectLambdaAllowedFeature]()
                    for enumContainer0 in allowedFeaturesContainer {
                        allowedFeaturesBuffer?.append(enumContainer0)
                    }
                }
                allowedFeatures = allowedFeaturesBuffer
            } else {
                allowedFeatures = []
            }
        } else {
            allowedFeatures = nil
        }
        if containerValues.contains(.transformationConfigurations) {
            struct KeyVal0{struct TransformationConfiguration{}}
            let transformationConfigurationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.TransformationConfiguration>.CodingKeys.self, forKey: .transformationConfigurations)
            if let transformationConfigurationsWrappedContainer = transformationConfigurationsWrappedContainer {
                let transformationConfigurationsContainer = try transformationConfigurationsWrappedContainer.decodeIfPresent([S3ControlClientTypes.ObjectLambdaTransformationConfiguration].self, forKey: .member)
                var transformationConfigurationsBuffer:[S3ControlClientTypes.ObjectLambdaTransformationConfiguration]? = nil
                if let transformationConfigurationsContainer = transformationConfigurationsContainer {
                    transformationConfigurationsBuffer = [S3ControlClientTypes.ObjectLambdaTransformationConfiguration]()
                    for structureContainer0 in transformationConfigurationsContainer {
                        transformationConfigurationsBuffer?.append(structureContainer0)
                    }
                }
                transformationConfigurations = transformationConfigurationsBuffer
            } else {
                transformationConfigurations = []
            }
        } else {
            transformationConfigurations = nil
        }
    }
}

extension S3ControlClientTypes.ObjectLambdaConfiguration: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// A configuration used when creating an Object Lambda Access Point.
    public struct ObjectLambdaConfiguration: Swift.Equatable {
        /// A container for allowed features. Valid inputs are GetObject-Range, GetObject-PartNumber, HeadObject-Range, and HeadObject-PartNumber.
        public var allowedFeatures: [S3ControlClientTypes.ObjectLambdaAllowedFeature]?
        /// A container for whether the CloudWatch metrics configuration is enabled.
        public var cloudWatchMetricsEnabled: Swift.Bool
        /// Standard access point associated with the Object Lambda Access Point.
        /// This member is required.
        public var supportingAccessPoint: Swift.String?
        /// A container for transformation configurations for an Object Lambda Access Point.
        /// This member is required.
        public var transformationConfigurations: [S3ControlClientTypes.ObjectLambdaTransformationConfiguration]?

        public init(
            allowedFeatures: [S3ControlClientTypes.ObjectLambdaAllowedFeature]? = nil,
            cloudWatchMetricsEnabled: Swift.Bool = false,
            supportingAccessPoint: Swift.String? = nil,
            transformationConfigurations: [S3ControlClientTypes.ObjectLambdaTransformationConfiguration]? = nil
        )
        {
            self.allowedFeatures = allowedFeatures
            self.cloudWatchMetricsEnabled = cloudWatchMetricsEnabled
            self.supportingAccessPoint = supportingAccessPoint
            self.transformationConfigurations = transformationConfigurations
        }
    }

}

extension S3ControlClientTypes.ObjectLambdaContentTransformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awslambda = "AwsLambda"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        switch self {
            case let .awslambda(awslambda):
                try container.encode(awslambda, forKey: ClientRuntime.Key("AwsLambda"))
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: ClientRuntime.Key("sdkUnknown"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let key = containerValues.allKeys.first
        switch key {
            case .awslambda:
                let awslambdaDecoded = try containerValues.decode(S3ControlClientTypes.AwsLambdaTransformation.self, forKey: .awslambda)
                self = .awslambda(awslambdaDecoded)
            default:
                self = .sdkUnknown("")
        }
    }
}

extension S3ControlClientTypes {
    /// A container for AwsLambdaTransformation.
    public enum ObjectLambdaContentTransformation: Swift.Equatable {
        /// A container for an Lambda function.
        case awslambda(S3ControlClientTypes.AwsLambdaTransformation)
        case sdkUnknown(Swift.String)
    }

}

extension S3ControlClientTypes.ObjectLambdaTransformationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case contentTransformation = "ContentTransformation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let actions = actions {
            var actionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Actions"))
            for objectlambdatransformationconfigurationaction0 in actions {
                try actionsContainer.encode(objectlambdatransformationconfigurationaction0, forKey: ClientRuntime.Key("Action"))
            }
        }
        if let contentTransformation = contentTransformation {
            try container.encode(contentTransformation, forKey: ClientRuntime.Key("ContentTransformation"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.actions) {
            struct KeyVal0{struct Action{}}
            let actionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Action>.CodingKeys.self, forKey: .actions)
            if let actionsWrappedContainer = actionsWrappedContainer {
                let actionsContainer = try actionsWrappedContainer.decodeIfPresent([S3ControlClientTypes.ObjectLambdaTransformationConfigurationAction].self, forKey: .member)
                var actionsBuffer:[S3ControlClientTypes.ObjectLambdaTransformationConfigurationAction]? = nil
                if let actionsContainer = actionsContainer {
                    actionsBuffer = [S3ControlClientTypes.ObjectLambdaTransformationConfigurationAction]()
                    for enumContainer0 in actionsContainer {
                        actionsBuffer?.append(enumContainer0)
                    }
                }
                actions = actionsBuffer
            } else {
                actions = []
            }
        } else {
            actions = nil
        }
        let contentTransformationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ObjectLambdaContentTransformation.self, forKey: .contentTransformation)
        contentTransformation = contentTransformationDecoded
    }
}

extension S3ControlClientTypes.ObjectLambdaTransformationConfiguration: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// A configuration used when creating an Object Lambda Access Point transformation.
    public struct ObjectLambdaTransformationConfiguration: Swift.Equatable {
        /// A container for the action of an Object Lambda Access Point configuration. Valid inputs are GetObject, ListObjects, HeadObject, and ListObjectsV2.
        /// This member is required.
        public var actions: [S3ControlClientTypes.ObjectLambdaTransformationConfigurationAction]?
        /// A container for the content transformation of an Object Lambda Access Point configuration.
        /// This member is required.
        public var contentTransformation: S3ControlClientTypes.ObjectLambdaContentTransformation?

        public init(
            actions: [S3ControlClientTypes.ObjectLambdaTransformationConfigurationAction]? = nil,
            contentTransformation: S3ControlClientTypes.ObjectLambdaContentTransformation? = nil
        )
        {
            self.actions = actions
            self.contentTransformation = contentTransformation
        }
    }

}

extension S3ControlClientTypes {
    public enum ObjectLambdaTransformationConfigurationAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case getobject
        case headobject
        case listobjects
        case listobjectsv2
        case sdkUnknown(Swift.String)

        public static var allCases: [ObjectLambdaTransformationConfigurationAction] {
            return [
                .getobject,
                .headobject,
                .listobjects,
                .listobjectsv2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .getobject: return "GetObject"
            case .headobject: return "HeadObject"
            case .listobjects: return "ListObjects"
            case .listobjectsv2: return "ListObjectsV2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ObjectLambdaTransformationConfigurationAction(rawValue: rawValue) ?? ObjectLambdaTransformationConfigurationAction.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum OperationName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lambdainvoke
        case s3deleteobjecttagging
        case s3initiaterestoreobject
        case s3putobjectacl
        case s3putobjectcopy
        case s3putobjectlegalhold
        case s3putobjectretention
        case s3putobjecttagging
        case s3replicateobject
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationName] {
            return [
                .lambdainvoke,
                .s3deleteobjecttagging,
                .s3initiaterestoreobject,
                .s3putobjectacl,
                .s3putobjectcopy,
                .s3putobjectlegalhold,
                .s3putobjectretention,
                .s3putobjecttagging,
                .s3replicateobject,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lambdainvoke: return "LambdaInvoke"
            case .s3deleteobjecttagging: return "S3DeleteObjectTagging"
            case .s3initiaterestoreobject: return "S3InitiateRestoreObject"
            case .s3putobjectacl: return "S3PutObjectAcl"
            case .s3putobjectcopy: return "S3PutObjectCopy"
            case .s3putobjectlegalhold: return "S3PutObjectLegalHold"
            case .s3putobjectretention: return "S3PutObjectRetention"
            case .s3putobjecttagging: return "S3PutObjectTagging"
            case .s3replicateobject: return "S3ReplicateObject"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperationName(rawValue: rawValue) ?? OperationName.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum OutputSchemaVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case v1
        case sdkUnknown(Swift.String)

        public static var allCases: [OutputSchemaVersion] {
            return [
                .v1,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .v1: return "V_1"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OutputSchemaVersion(rawValue: rawValue) ?? OutputSchemaVersion.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum OwnerOverride: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case destination
        case sdkUnknown(Swift.String)

        public static var allCases: [OwnerOverride] {
            return [
                .destination,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .destination: return "Destination"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OwnerOverride(rawValue: rawValue) ?? OwnerOverride.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.PolicyStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isPublic = "IsPublic"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if isPublic != false {
            try container.encode(isPublic, forKey: ClientRuntime.Key("IsPublic"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isPublicDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isPublic) ?? false
        isPublic = isPublicDecoded
    }
}

extension S3ControlClientTypes.PolicyStatus: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// Indicates whether this access point policy is public. For more information about how Amazon S3 evaluates policies to determine whether they are public, see [The Meaning of "Public"](https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status) in the Amazon S3 User Guide.
    public struct PolicyStatus: Swift.Equatable {
        ///
        public var isPublic: Swift.Bool

        public init(
            isPublic: Swift.Bool = false
        )
        {
            self.isPublic = isPublic
        }
    }

}

extension S3ControlClientTypes.PrefixLevel: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case storageMetrics = "StorageMetrics"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let storageMetrics = storageMetrics {
            try container.encode(storageMetrics, forKey: ClientRuntime.Key("StorageMetrics"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageMetricsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.PrefixLevelStorageMetrics.self, forKey: .storageMetrics)
        storageMetrics = storageMetricsDecoded
    }
}

extension S3ControlClientTypes.PrefixLevel: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// A container for the prefix-level configuration.
    public struct PrefixLevel: Swift.Equatable {
        /// A container for the prefix-level storage metrics for S3 Storage Lens.
        /// This member is required.
        public var storageMetrics: S3ControlClientTypes.PrefixLevelStorageMetrics?

        public init(
            storageMetrics: S3ControlClientTypes.PrefixLevelStorageMetrics? = nil
        )
        {
            self.storageMetrics = storageMetrics
        }
    }

}

extension S3ControlClientTypes.PrefixLevelStorageMetrics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isEnabled = "IsEnabled"
        case selectionCriteria = "SelectionCriteria"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if isEnabled != false {
            try container.encode(isEnabled, forKey: ClientRuntime.Key("IsEnabled"))
        }
        if let selectionCriteria = selectionCriteria {
            try container.encode(selectionCriteria, forKey: ClientRuntime.Key("SelectionCriteria"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isEnabled) ?? false
        isEnabled = isEnabledDecoded
        let selectionCriteriaDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.SelectionCriteria.self, forKey: .selectionCriteria)
        selectionCriteria = selectionCriteriaDecoded
    }
}

extension S3ControlClientTypes.PrefixLevelStorageMetrics: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// A container for the prefix-level storage metrics for S3 Storage Lens.
    public struct PrefixLevelStorageMetrics: Swift.Equatable {
        /// A container for whether prefix-level storage metrics are enabled.
        public var isEnabled: Swift.Bool
        ///
        public var selectionCriteria: S3ControlClientTypes.SelectionCriteria?

        public init(
            isEnabled: Swift.Bool = false,
            selectionCriteria: S3ControlClientTypes.SelectionCriteria? = nil
        )
        {
            self.isEnabled = isEnabled
            self.selectionCriteria = selectionCriteria
        }
    }

}

extension S3ControlClientTypes.ProposedMultiRegionAccessPointPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let policy = policy {
            try container.encode(policy, forKey: ClientRuntime.Key("Policy"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension S3ControlClientTypes.ProposedMultiRegionAccessPointPolicy: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// The proposed access control policy for the Multi-Region Access Point. When you update the policy, the update is first listed as the proposed policy. After the update is finished and all Regions have been updated, the proposed policy is listed as the established policy. If both policies have the same version number, the proposed policy is the established policy.
    public struct ProposedMultiRegionAccessPointPolicy: Swift.Equatable {
        /// The details of the proposed policy.
        public var policy: Swift.String?

        public init(
            policy: Swift.String? = nil
        )
        {
            self.policy = policy
        }
    }

}

extension S3ControlClientTypes.PublicAccessBlockConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockPublicAcls = "BlockPublicAcls"
        case blockPublicPolicy = "BlockPublicPolicy"
        case ignorePublicAcls = "IgnorePublicAcls"
        case restrictPublicBuckets = "RestrictPublicBuckets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if blockPublicAcls != false {
            try container.encode(blockPublicAcls, forKey: ClientRuntime.Key("BlockPublicAcls"))
        }
        if blockPublicPolicy != false {
            try container.encode(blockPublicPolicy, forKey: ClientRuntime.Key("BlockPublicPolicy"))
        }
        if ignorePublicAcls != false {
            try container.encode(ignorePublicAcls, forKey: ClientRuntime.Key("IgnorePublicAcls"))
        }
        if restrictPublicBuckets != false {
            try container.encode(restrictPublicBuckets, forKey: ClientRuntime.Key("RestrictPublicBuckets"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockPublicAclsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .blockPublicAcls) ?? false
        blockPublicAcls = blockPublicAclsDecoded
        let ignorePublicAclsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ignorePublicAcls) ?? false
        ignorePublicAcls = ignorePublicAclsDecoded
        let blockPublicPolicyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .blockPublicPolicy) ?? false
        blockPublicPolicy = blockPublicPolicyDecoded
        let restrictPublicBucketsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .restrictPublicBuckets) ?? false
        restrictPublicBuckets = restrictPublicBucketsDecoded
    }
}

extension S3ControlClientTypes.PublicAccessBlockConfiguration: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// The PublicAccessBlock configuration that you want to apply to this Amazon S3 account. You can enable the configuration options in any combination. For more information about when Amazon S3 considers a bucket or object public, see [The Meaning of "Public"](https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status) in the Amazon S3 User Guide. This data type is not supported for Amazon S3 on Outposts.
    public struct PublicAccessBlockConfiguration: Swift.Equatable {
        /// Specifies whether Amazon S3 should block public access control lists (ACLs) for buckets in this account. Setting this element to TRUE causes the following behavior:
        ///
        /// * PutBucketAcl and PutObjectAcl calls fail if the specified ACL is public.
        ///
        /// * PUT Object calls fail if the request includes a public ACL.
        ///
        /// * PUT Bucket calls fail if the request includes a public ACL.
        ///
        ///
        /// Enabling this setting doesn't affect existing policies or ACLs. This property is not supported for Amazon S3 on Outposts.
        public var blockPublicAcls: Swift.Bool
        /// Specifies whether Amazon S3 should block public bucket policies for buckets in this account. Setting this element to TRUE causes Amazon S3 to reject calls to PUT Bucket policy if the specified bucket policy allows public access. Enabling this setting doesn't affect existing bucket policies. This property is not supported for Amazon S3 on Outposts.
        public var blockPublicPolicy: Swift.Bool
        /// Specifies whether Amazon S3 should ignore public ACLs for buckets in this account. Setting this element to TRUE causes Amazon S3 to ignore all public ACLs on buckets in this account and any objects that they contain. Enabling this setting doesn't affect the persistence of any existing ACLs and doesn't prevent new public ACLs from being set. This property is not supported for Amazon S3 on Outposts.
        public var ignorePublicAcls: Swift.Bool
        /// Specifies whether Amazon S3 should restrict public bucket policies for buckets in this account. Setting this element to TRUE restricts access to buckets with public policies to only Amazon Web Service principals and authorized users within this account. Enabling this setting doesn't affect previously stored bucket policies, except that public and cross-account access within any public bucket policy, including non-public delegation to specific accounts, is blocked. This property is not supported for Amazon S3 on Outposts.
        public var restrictPublicBuckets: Swift.Bool

        public init(
            blockPublicAcls: Swift.Bool = false,
            blockPublicPolicy: Swift.Bool = false,
            ignorePublicAcls: Swift.Bool = false,
            restrictPublicBuckets: Swift.Bool = false
        )
        {
            self.blockPublicAcls = blockPublicAcls
            self.blockPublicPolicy = blockPublicPolicy
            self.ignorePublicAcls = ignorePublicAcls
            self.restrictPublicBuckets = restrictPublicBuckets
        }
    }

}

extension PutAccessPointConfigurationForObjectLambdaInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutAccessPointConfigurationForObjectLambdaInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let configuration = configuration {
            try container.encode(configuration, forKey: ClientRuntime.Key("Configuration"))
        }
    }
}

extension PutAccessPointConfigurationForObjectLambdaInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension PutAccessPointConfigurationForObjectLambdaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v20180820/accesspointforobjectlambda/\(name.urlPercentEncoding())/configuration"
    }
}

public struct PutAccessPointConfigurationForObjectLambdaInput: Swift.Equatable {
    /// The account ID for the account that owns the specified Object Lambda Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// Object Lambda Access Point configuration document.
    /// This member is required.
    public var configuration: S3ControlClientTypes.ObjectLambdaConfiguration?
    /// The name of the Object Lambda Access Point.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        configuration: S3ControlClientTypes.ObjectLambdaConfiguration? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.configuration = configuration
        self.name = name
    }
}

struct PutAccessPointConfigurationForObjectLambdaInputBody: Swift.Equatable {
    let configuration: S3ControlClientTypes.ObjectLambdaConfiguration?
}

extension PutAccessPointConfigurationForObjectLambdaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ObjectLambdaConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension PutAccessPointConfigurationForObjectLambdaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutAccessPointConfigurationForObjectLambdaOutput: Swift.Equatable {

    public init() { }
}

enum PutAccessPointConfigurationForObjectLambdaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension PutAccessPointPolicyForObjectLambdaInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutAccessPointPolicyForObjectLambdaInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let policy = policy {
            try container.encode(policy, forKey: ClientRuntime.Key("Policy"))
        }
    }
}

extension PutAccessPointPolicyForObjectLambdaInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension PutAccessPointPolicyForObjectLambdaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v20180820/accesspointforobjectlambda/\(name.urlPercentEncoding())/policy"
    }
}

public struct PutAccessPointPolicyForObjectLambdaInput: Swift.Equatable {
    /// The account ID for the account that owns the specified Object Lambda Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the Object Lambda Access Point.
    /// This member is required.
    public var name: Swift.String?
    /// Object Lambda Access Point resource policy document.
    /// This member is required.
    public var policy: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
        self.policy = policy
    }
}

struct PutAccessPointPolicyForObjectLambdaInputBody: Swift.Equatable {
    let policy: Swift.String?
}

extension PutAccessPointPolicyForObjectLambdaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutAccessPointPolicyForObjectLambdaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutAccessPointPolicyForObjectLambdaOutput: Swift.Equatable {

    public init() { }
}

enum PutAccessPointPolicyForObjectLambdaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension PutAccessPointPolicyInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutAccessPointPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let policy = policy {
            try container.encode(policy, forKey: ClientRuntime.Key("Policy"))
        }
    }
}

extension PutAccessPointPolicyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension PutAccessPointPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v20180820/accesspoint/\(name.urlPercentEncoding())/policy"
    }
}

public struct PutAccessPointPolicyInput: Swift.Equatable {
    /// The Amazon Web Services account ID for owner of the bucket associated with the specified access point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the access point that you want to associate with the specified policy. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the access point accessed in the format arn:aws:s3-outposts:::outpost//accesspoint/. For example, to access the access point reports-ap through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/accesspoint/reports-ap. The value must be URL encoded.
    /// This member is required.
    public var name: Swift.String?
    /// The policy that you want to apply to the specified access point. For more information about access point policies, see [Managing data access with Amazon S3 access points](https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-points.html) in the Amazon S3 User Guide.
    /// This member is required.
    public var policy: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
        self.policy = policy
    }
}

struct PutAccessPointPolicyInputBody: Swift.Equatable {
    let policy: Swift.String?
}

extension PutAccessPointPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutAccessPointPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutAccessPointPolicyOutput: Swift.Equatable {

    public init() { }
}

enum PutAccessPointPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

public struct PutBucketLifecycleConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutBucketLifecycleConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutBucketLifecycleConfigurationInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutBucketLifecycleConfigurationOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let lifecycleConfiguration = input.operationInput.lifecycleConfiguration {
                let xmlEncoder = encoder as! XMLEncoder
                let lifecycleConfigurationData = try xmlEncoder.encode(lifecycleConfiguration, withRootKey: "LifecycleConfiguration")
                let lifecycleConfigurationBody = ClientRuntime.HttpBody.data(lifecycleConfigurationData)
                input.builder.withBody(lifecycleConfigurationBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let lifecycleConfigurationData = "{}".data(using: .utf8)!
                    let lifecycleConfigurationBody = ClientRuntime.HttpBody.data(lifecycleConfigurationData)
                    input.builder.withBody(lifecycleConfigurationBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutBucketLifecycleConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutBucketLifecycleConfigurationOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutBucketLifecycleConfigurationInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketLifecycleConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecycleConfiguration = "LifecycleConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let lifecycleConfiguration = lifecycleConfiguration {
            try container.encode(lifecycleConfiguration, forKey: ClientRuntime.Key("LifecycleConfiguration"))
        }
    }
}

extension PutBucketLifecycleConfigurationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension PutBucketLifecycleConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/lifecycleconfiguration"
    }
}

public struct PutBucketLifecycleConfigurationInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the bucket for which to set the configuration.
    /// This member is required.
    public var bucket: Swift.String?
    /// Container for lifecycle rules. You can add as many as 1,000 rules.
    public var lifecycleConfiguration: S3ControlClientTypes.LifecycleConfiguration?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil,
        lifecycleConfiguration: S3ControlClientTypes.LifecycleConfiguration? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
        self.lifecycleConfiguration = lifecycleConfiguration
    }
}

struct PutBucketLifecycleConfigurationInputBody: Swift.Equatable {
    let lifecycleConfiguration: S3ControlClientTypes.LifecycleConfiguration?
}

extension PutBucketLifecycleConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecycleConfiguration = "LifecycleConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecycleConfigurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.LifecycleConfiguration.self, forKey: .lifecycleConfiguration)
        lifecycleConfiguration = lifecycleConfigurationDecoded
    }
}

extension PutBucketLifecycleConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutBucketLifecycleConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum PutBucketLifecycleConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension PutBucketPolicyInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let policy = policy {
            try container.encode(policy, forKey: ClientRuntime.Key("Policy"))
        }
    }
}

extension PutBucketPolicyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        if let confirmRemoveSelfBucketAccess = confirmRemoveSelfBucketAccess {
            items.add(Header(name: "x-amz-confirm-remove-self-bucket-access", value: Swift.String(confirmRemoveSelfBucketAccess)))
        }
        return items
    }
}

extension PutBucketPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/policy"
    }
}

public struct PutBucketPolicyInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    /// Specifies the bucket. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?
    /// Set this parameter to true to confirm that you want to remove your permissions to change this bucket policy in the future. This is not supported by Amazon S3 on Outposts buckets.
    public var confirmRemoveSelfBucketAccess: Swift.Bool?
    /// The bucket policy as a JSON document.
    /// This member is required.
    public var policy: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil,
        confirmRemoveSelfBucketAccess: Swift.Bool? = nil,
        policy: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
        self.confirmRemoveSelfBucketAccess = confirmRemoveSelfBucketAccess
        self.policy = policy
    }
}

struct PutBucketPolicyInputBody: Swift.Equatable {
    let policy: Swift.String?
}

extension PutBucketPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutBucketPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutBucketPolicyOutput: Swift.Equatable {

    public init() { }
}

enum PutBucketPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

public struct PutBucketReplicationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutBucketReplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutBucketReplicationInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutBucketReplicationOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let replicationConfiguration = input.operationInput.replicationConfiguration {
                let xmlEncoder = encoder as! XMLEncoder
                let replicationConfigurationData = try xmlEncoder.encode(replicationConfiguration, withRootKey: "ReplicationConfiguration")
                let replicationConfigurationBody = ClientRuntime.HttpBody.data(replicationConfigurationData)
                input.builder.withBody(replicationConfigurationBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let replicationConfigurationData = "{}".data(using: .utf8)!
                    let replicationConfigurationBody = ClientRuntime.HttpBody.data(replicationConfigurationData)
                    input.builder.withBody(replicationConfigurationBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutBucketReplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutBucketReplicationOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutBucketReplicationInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketReplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationConfiguration = "ReplicationConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let replicationConfiguration = replicationConfiguration {
            try container.encode(replicationConfiguration, forKey: ClientRuntime.Key("ReplicationConfiguration"))
        }
    }
}

extension PutBucketReplicationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension PutBucketReplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/replication"
    }
}

public struct PutBucketReplicationInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    /// Specifies the S3 on Outposts bucket to set the configuration for. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?
    ///
    /// This member is required.
    public var replicationConfiguration: S3ControlClientTypes.ReplicationConfiguration?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil,
        replicationConfiguration: S3ControlClientTypes.ReplicationConfiguration? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
        self.replicationConfiguration = replicationConfiguration
    }
}

struct PutBucketReplicationInputBody: Swift.Equatable {
    let replicationConfiguration: S3ControlClientTypes.ReplicationConfiguration?
}

extension PutBucketReplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationConfiguration = "ReplicationConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ReplicationConfiguration.self, forKey: .replicationConfiguration)
        replicationConfiguration = replicationConfigurationDecoded
    }
}

extension PutBucketReplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutBucketReplicationOutput: Swift.Equatable {

    public init() { }
}

enum PutBucketReplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

public struct PutBucketTaggingInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutBucketTaggingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutBucketTaggingInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutBucketTaggingOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let tagging = input.operationInput.tagging {
                let xmlEncoder = encoder as! XMLEncoder
                let taggingData = try xmlEncoder.encode(tagging, withRootKey: "Tagging")
                let taggingBody = ClientRuntime.HttpBody.data(taggingData)
                input.builder.withBody(taggingBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let taggingData = "{}".data(using: .utf8)!
                    let taggingBody = ClientRuntime.HttpBody.data(taggingData)
                    input.builder.withBody(taggingBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutBucketTaggingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutBucketTaggingOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutBucketTaggingInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketTaggingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagging = "Tagging"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let tagging = tagging {
            try container.encode(tagging, forKey: ClientRuntime.Key("Tagging"))
        }
    }
}

extension PutBucketTaggingInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension PutBucketTaggingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/tagging"
    }
}

public struct PutBucketTaggingInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    /// The Amazon Resource Name (ARN) of the bucket. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:::outpost//bucket/. For example, to access the bucket reports through Outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
    /// This member is required.
    public var bucket: Swift.String?
    ///
    /// This member is required.
    public var tagging: S3ControlClientTypes.Tagging?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil,
        tagging: S3ControlClientTypes.Tagging? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
        self.tagging = tagging
    }
}

struct PutBucketTaggingInputBody: Swift.Equatable {
    let tagging: S3ControlClientTypes.Tagging?
}

extension PutBucketTaggingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagging = "Tagging"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taggingDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.Tagging.self, forKey: .tagging)
        tagging = taggingDecoded
    }
}

extension PutBucketTaggingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutBucketTaggingOutput: Swift.Equatable {

    public init() { }
}

enum PutBucketTaggingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

public struct PutBucketVersioningInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutBucketVersioningInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutBucketVersioningInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutBucketVersioningOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let versioningConfiguration = input.operationInput.versioningConfiguration {
                let xmlEncoder = encoder as! XMLEncoder
                let versioningConfigurationData = try xmlEncoder.encode(versioningConfiguration, withRootKey: "VersioningConfiguration")
                let versioningConfigurationBody = ClientRuntime.HttpBody.data(versioningConfigurationData)
                input.builder.withBody(versioningConfigurationBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let versioningConfigurationData = "{}".data(using: .utf8)!
                    let versioningConfigurationBody = ClientRuntime.HttpBody.data(versioningConfigurationData)
                    input.builder.withBody(versioningConfigurationBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutBucketVersioningInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutBucketVersioningOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutBucketVersioningInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutBucketVersioningInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case versioningConfiguration = "VersioningConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let versioningConfiguration = versioningConfiguration {
            try container.encode(versioningConfiguration, forKey: ClientRuntime.Key("VersioningConfiguration"))
        }
    }
}

extension PutBucketVersioningInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        if let mfa = mfa {
            items.add(Header(name: "x-amz-mfa", value: Swift.String(mfa)))
        }
        return items
    }
}

extension PutBucketVersioningInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bucket = bucket else {
            return nil
        }
        return "/v20180820/bucket/\(bucket.urlPercentEncoding())/versioning"
    }
}

public struct PutBucketVersioningInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the S3 on Outposts bucket.
    /// This member is required.
    public var accountId: Swift.String?
    /// The S3 on Outposts bucket to set the versioning state for.
    /// This member is required.
    public var bucket: Swift.String?
    /// The concatenation of the authentication device's serial number, a space, and the value that is displayed on your authentication device.
    public var mfa: Swift.String?
    /// The root-level tag for the VersioningConfiguration parameters.
    /// This member is required.
    public var versioningConfiguration: S3ControlClientTypes.VersioningConfiguration?

    public init(
        accountId: Swift.String? = nil,
        bucket: Swift.String? = nil,
        mfa: Swift.String? = nil,
        versioningConfiguration: S3ControlClientTypes.VersioningConfiguration? = nil
    )
    {
        self.accountId = accountId
        self.bucket = bucket
        self.mfa = mfa
        self.versioningConfiguration = versioningConfiguration
    }
}

struct PutBucketVersioningInputBody: Swift.Equatable {
    let versioningConfiguration: S3ControlClientTypes.VersioningConfiguration?
}

extension PutBucketVersioningInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case versioningConfiguration = "VersioningConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versioningConfigurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.VersioningConfiguration.self, forKey: .versioningConfiguration)
        versioningConfiguration = versioningConfigurationDecoded
    }
}

extension PutBucketVersioningOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutBucketVersioningOutput: Swift.Equatable {

    public init() { }
}

enum PutBucketVersioningOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension PutJobTaggingInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutJobTaggingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for s3tag0 in tags {
                try tagsContainer.encode(s3tag0, forKey: ClientRuntime.Key("member"))
            }
        }
    }
}

extension PutJobTaggingInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension PutJobTaggingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/v20180820/jobs/\(jobId.urlPercentEncoding())/tagging"
    }
}

public struct PutJobTaggingInput: Swift.Equatable {
    /// The Amazon Web Services account ID associated with the S3 Batch Operations job.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID for the S3 Batch Operations job whose tags you want to replace.
    /// This member is required.
    public var jobId: Swift.String?
    /// The set of tags to associate with the S3 Batch Operations job.
    /// This member is required.
    public var tags: [S3ControlClientTypes.S3Tag]?

    public init(
        accountId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        tags: [S3ControlClientTypes.S3Tag]? = nil
    )
    {
        self.accountId = accountId
        self.jobId = jobId
        self.tags = tags
    }
}

struct PutJobTaggingInputBody: Swift.Equatable {
    let tags: [S3ControlClientTypes.S3Tag]?
}

extension PutJobTaggingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([S3ControlClientTypes.S3Tag].self, forKey: .member)
                var tagsBuffer:[S3ControlClientTypes.S3Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [S3ControlClientTypes.S3Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension PutJobTaggingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutJobTaggingOutput: Swift.Equatable {

    public init() { }
}

enum PutJobTaggingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension S3ControlClientTypes.PutMultiRegionAccessPointPolicyInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case policy = "Policy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let policy = policy {
            try container.encode(policy, forKey: ClientRuntime.Key("Policy"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutMultiRegionAccessPointPolicyInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes.PutMultiRegionAccessPointPolicyInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutMultiRegionAccessPointPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case details = "Details"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let clientToken = clientToken {
            try container.encode(clientToken, forKey: ClientRuntime.Key("ClientToken"))
        }
        if let details = details {
            try container.encode(details, forKey: ClientRuntime.Key("Details"))
        }
    }
}

extension PutMultiRegionAccessPointPolicyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension PutMultiRegionAccessPointPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/async-requests/mrap/put-policy"
    }
}

public struct PutMultiRegionAccessPointPolicyInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the owner of the Multi-Region Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// An idempotency token used to identify the request and guarantee that requests are unique.
    /// This member is required.
    public var clientToken: Swift.String?
    /// A container element containing the details of the policy for the Multi-Region Access Point.
    /// This member is required.
    public var details: S3ControlClientTypes.PutMultiRegionAccessPointPolicyInput?

    public init(
        accountId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        details: S3ControlClientTypes.PutMultiRegionAccessPointPolicyInput? = nil
    )
    {
        self.accountId = accountId
        self.clientToken = clientToken
        self.details = details
    }
}

extension S3ControlClientTypes {
    /// A container for the information associated with a [PutMultiRegionAccessPoint](https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_PutMultiRegionAccessPoint.html) request.
    public struct PutMultiRegionAccessPointPolicyInput: Swift.Equatable {
        /// The name of the Multi-Region Access Point associated with the request.
        /// This member is required.
        public var name: Swift.String?
        /// The policy details for the PutMultiRegionAccessPoint request.
        /// This member is required.
        public var policy: Swift.String?

        public init(
            name: Swift.String? = nil,
            policy: Swift.String? = nil
        )
        {
            self.name = name
            self.policy = policy
        }
    }

}

struct PutMultiRegionAccessPointPolicyInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let details: S3ControlClientTypes.PutMultiRegionAccessPointPolicyInput?
}

extension PutMultiRegionAccessPointPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case details = "Details"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.PutMultiRegionAccessPointPolicyInput.self, forKey: .details)
        details = detailsDecoded
    }
}

extension PutMultiRegionAccessPointPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutMultiRegionAccessPointPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.requestTokenARN = output.requestTokenARN
        } else {
            self.requestTokenARN = nil
        }
    }
}

public struct PutMultiRegionAccessPointPolicyOutput: Swift.Equatable {
    /// The request token associated with the request. You can use this token with [DescribeMultiRegionAccessPointOperation](https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_DescribeMultiRegionAccessPointOperation.html) to determine the status of asynchronous requests.
    public var requestTokenARN: Swift.String?

    public init(
        requestTokenARN: Swift.String? = nil
    )
    {
        self.requestTokenARN = requestTokenARN
    }
}

struct PutMultiRegionAccessPointPolicyOutputBody: Swift.Equatable {
    let requestTokenARN: Swift.String?
}

extension PutMultiRegionAccessPointPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestTokenARN = "RequestTokenARN"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestTokenARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestTokenARN)
        requestTokenARN = requestTokenARNDecoded
    }
}

enum PutMultiRegionAccessPointPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

public struct PutPublicAccessBlockInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutPublicAccessBlockInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutPublicAccessBlockInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutPublicAccessBlockOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let publicAccessBlockConfiguration = input.operationInput.publicAccessBlockConfiguration {
                let xmlEncoder = encoder as! XMLEncoder
                let publicAccessBlockConfigurationData = try xmlEncoder.encode(publicAccessBlockConfiguration, withRootKey: "PublicAccessBlockConfiguration")
                let publicAccessBlockConfigurationBody = ClientRuntime.HttpBody.data(publicAccessBlockConfigurationData)
                input.builder.withBody(publicAccessBlockConfigurationBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let publicAccessBlockConfigurationData = "{}".data(using: .utf8)!
                    let publicAccessBlockConfigurationBody = ClientRuntime.HttpBody.data(publicAccessBlockConfigurationData)
                    input.builder.withBody(publicAccessBlockConfigurationBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutPublicAccessBlockInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutPublicAccessBlockOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutPublicAccessBlockInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutPublicAccessBlockInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let publicAccessBlockConfiguration = publicAccessBlockConfiguration {
            try container.encode(publicAccessBlockConfiguration, forKey: ClientRuntime.Key("PublicAccessBlockConfiguration"))
        }
    }
}

extension PutPublicAccessBlockInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension PutPublicAccessBlockInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v20180820/configuration/publicAccessBlock"
    }
}

public struct PutPublicAccessBlockInput: Swift.Equatable {
    /// The account ID for the Amazon Web Services account whose PublicAccessBlock configuration you want to set.
    /// This member is required.
    public var accountId: Swift.String?
    /// The PublicAccessBlock configuration that you want to apply to the specified Amazon Web Services account.
    /// This member is required.
    public var publicAccessBlockConfiguration: S3ControlClientTypes.PublicAccessBlockConfiguration?

    public init(
        accountId: Swift.String? = nil,
        publicAccessBlockConfiguration: S3ControlClientTypes.PublicAccessBlockConfiguration? = nil
    )
    {
        self.accountId = accountId
        self.publicAccessBlockConfiguration = publicAccessBlockConfiguration
    }
}

struct PutPublicAccessBlockInputBody: Swift.Equatable {
    let publicAccessBlockConfiguration: S3ControlClientTypes.PublicAccessBlockConfiguration?
}

extension PutPublicAccessBlockInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicAccessBlockConfigurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.PublicAccessBlockConfiguration.self, forKey: .publicAccessBlockConfiguration)
        publicAccessBlockConfiguration = publicAccessBlockConfigurationDecoded
    }
}

extension PutPublicAccessBlockOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutPublicAccessBlockOutput: Swift.Equatable {

    public init() { }
}

enum PutPublicAccessBlockOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension PutStorageLensConfigurationInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutStorageLensConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case storageLensConfiguration = "StorageLensConfiguration"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let storageLensConfiguration = storageLensConfiguration {
            try container.encode(storageLensConfiguration, forKey: ClientRuntime.Key("StorageLensConfiguration"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for storagelenstag0 in tags {
                try tagsContainer.encode(storagelenstag0, forKey: ClientRuntime.Key("Tag"))
            }
        }
    }
}

extension PutStorageLensConfigurationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension PutStorageLensConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configId = configId else {
            return nil
        }
        return "/v20180820/storagelens/\(configId.urlPercentEncoding())"
    }
}

public struct PutStorageLensConfigurationInput: Swift.Equatable {
    /// The account ID of the requester.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID of the S3 Storage Lens configuration.
    /// This member is required.
    public var configId: Swift.String?
    /// The S3 Storage Lens configuration.
    /// This member is required.
    public var storageLensConfiguration: S3ControlClientTypes.StorageLensConfiguration?
    /// The tag set of the S3 Storage Lens configuration. You can set up to a maximum of 50 tags.
    public var tags: [S3ControlClientTypes.StorageLensTag]?

    public init(
        accountId: Swift.String? = nil,
        configId: Swift.String? = nil,
        storageLensConfiguration: S3ControlClientTypes.StorageLensConfiguration? = nil,
        tags: [S3ControlClientTypes.StorageLensTag]? = nil
    )
    {
        self.accountId = accountId
        self.configId = configId
        self.storageLensConfiguration = storageLensConfiguration
        self.tags = tags
    }
}

struct PutStorageLensConfigurationInputBody: Swift.Equatable {
    let storageLensConfiguration: S3ControlClientTypes.StorageLensConfiguration?
    let tags: [S3ControlClientTypes.StorageLensTag]?
}

extension PutStorageLensConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case storageLensConfiguration = "StorageLensConfiguration"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageLensConfigurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.StorageLensConfiguration.self, forKey: .storageLensConfiguration)
        storageLensConfiguration = storageLensConfigurationDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([S3ControlClientTypes.StorageLensTag].self, forKey: .member)
                var tagsBuffer:[S3ControlClientTypes.StorageLensTag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [S3ControlClientTypes.StorageLensTag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension PutStorageLensConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutStorageLensConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum PutStorageLensConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension PutStorageLensConfigurationTaggingInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension PutStorageLensConfigurationTaggingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for storagelenstag0 in tags {
                try tagsContainer.encode(storagelenstag0, forKey: ClientRuntime.Key("Tag"))
            }
        }
    }
}

extension PutStorageLensConfigurationTaggingInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension PutStorageLensConfigurationTaggingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configId = configId else {
            return nil
        }
        return "/v20180820/storagelens/\(configId.urlPercentEncoding())/tagging"
    }
}

public struct PutStorageLensConfigurationTaggingInput: Swift.Equatable {
    /// The account ID of the requester.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID of the S3 Storage Lens configuration.
    /// This member is required.
    public var configId: Swift.String?
    /// The tag set of the S3 Storage Lens configuration. You can set up to a maximum of 50 tags.
    /// This member is required.
    public var tags: [S3ControlClientTypes.StorageLensTag]?

    public init(
        accountId: Swift.String? = nil,
        configId: Swift.String? = nil,
        tags: [S3ControlClientTypes.StorageLensTag]? = nil
    )
    {
        self.accountId = accountId
        self.configId = configId
        self.tags = tags
    }
}

struct PutStorageLensConfigurationTaggingInputBody: Swift.Equatable {
    let tags: [S3ControlClientTypes.StorageLensTag]?
}

extension PutStorageLensConfigurationTaggingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([S3ControlClientTypes.StorageLensTag].self, forKey: .member)
                var tagsBuffer:[S3ControlClientTypes.StorageLensTag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [S3ControlClientTypes.StorageLensTag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension PutStorageLensConfigurationTaggingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutStorageLensConfigurationTaggingOutput: Swift.Equatable {

    public init() { }
}

enum PutStorageLensConfigurationTaggingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension S3ControlClientTypes.Region: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case bucketAccountId = "BucketAccountId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let bucket = bucket {
            try container.encode(bucket, forKey: ClientRuntime.Key("Bucket"))
        }
        if let bucketAccountId = bucketAccountId {
            try container.encode(bucketAccountId, forKey: ClientRuntime.Key("BucketAccountId"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let bucketAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketAccountId)
        bucketAccountId = bucketAccountIdDecoded
    }
}

extension S3ControlClientTypes.Region: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// A Region that supports a Multi-Region Access Point as well as the associated bucket for the Region.
    public struct Region: Swift.Equatable {
        /// The name of the associated bucket for the Region.
        /// This member is required.
        public var bucket: Swift.String?
        /// The Amazon Web Services account ID that owns the Amazon S3 bucket that's associated with this Multi-Region Access Point.
        public var bucketAccountId: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            bucketAccountId: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.bucketAccountId = bucketAccountId
        }
    }

}

extension S3ControlClientTypes.RegionReport: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case bucketAccountId = "BucketAccountId"
        case region = "Region"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let bucket = bucket {
            try container.encode(bucket, forKey: ClientRuntime.Key("Bucket"))
        }
        if let bucketAccountId = bucketAccountId {
            try container.encode(bucketAccountId, forKey: ClientRuntime.Key("BucketAccountId"))
        }
        if let region = region {
            try container.encode(region, forKey: ClientRuntime.Key("Region"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let bucketAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketAccountId)
        bucketAccountId = bucketAccountIdDecoded
    }
}

extension S3ControlClientTypes.RegionReport: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// A combination of a bucket and Region that's part of a Multi-Region Access Point.
    public struct RegionReport: Swift.Equatable {
        /// The name of the bucket.
        public var bucket: Swift.String?
        /// The Amazon Web Services account ID that owns the Amazon S3 bucket that's associated with this Multi-Region Access Point.
        public var bucketAccountId: Swift.String?
        /// The name of the Region.
        public var region: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            bucketAccountId: Swift.String? = nil,
            region: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.bucketAccountId = bucketAccountId
            self.region = region
        }
    }

}

extension S3ControlClientTypes.RegionalBucket: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case bucketArn = "BucketArn"
        case creationDate = "CreationDate"
        case outpostId = "OutpostId"
        case publicAccessBlockEnabled = "PublicAccessBlockEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let bucket = bucket {
            try container.encode(bucket, forKey: ClientRuntime.Key("Bucket"))
        }
        if let bucketArn = bucketArn {
            try container.encode(bucketArn, forKey: ClientRuntime.Key("BucketArn"))
        }
        if let creationDate = creationDate {
            try container.encodeTimestamp(creationDate, format: .dateTime, forKey: ClientRuntime.Key("CreationDate"))
        }
        if let outpostId = outpostId {
            try container.encode(outpostId, forKey: ClientRuntime.Key("OutpostId"))
        }
        if publicAccessBlockEnabled != false {
            try container.encode(publicAccessBlockEnabled, forKey: ClientRuntime.Key("PublicAccessBlockEnabled"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let bucketArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketArn)
        bucketArn = bucketArnDecoded
        let publicAccessBlockEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publicAccessBlockEnabled) ?? false
        publicAccessBlockEnabled = publicAccessBlockEnabledDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationDate)
        creationDate = creationDateDecoded
        let outpostIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outpostId)
        outpostId = outpostIdDecoded
    }
}

extension S3ControlClientTypes.RegionalBucket: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// The container for the regional bucket.
    public struct RegionalBucket: Swift.Equatable {
        ///
        /// This member is required.
        public var bucket: Swift.String?
        /// The Amazon Resource Name (ARN) for the regional bucket.
        public var bucketArn: Swift.String?
        /// The creation date of the regional bucket
        /// This member is required.
        public var creationDate: ClientRuntime.Date?
        /// The Outposts ID of the regional bucket.
        public var outpostId: Swift.String?
        ///
        /// This member is required.
        public var publicAccessBlockEnabled: Swift.Bool

        public init(
            bucket: Swift.String? = nil,
            bucketArn: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            outpostId: Swift.String? = nil,
            publicAccessBlockEnabled: Swift.Bool = false
        )
        {
            self.bucket = bucket
            self.bucketArn = bucketArn
            self.creationDate = creationDate
            self.outpostId = outpostId
            self.publicAccessBlockEnabled = publicAccessBlockEnabled
        }
    }

}

extension S3ControlClientTypes.ReplicaModifications: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ReplicaModificationsStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension S3ControlClientTypes.ReplicaModifications: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// A filter that you can use to specify whether replica modification sync is enabled. S3 on Outposts replica modification sync can help you keep object metadata synchronized between replicas and source objects. By default, S3 on Outposts replicates metadata from the source objects to the replicas only. When replica modification sync is enabled, S3 on Outposts replicates metadata changes made to the replica copies back to the source object, making the replication bidirectional. To replicate object metadata modifications on replicas, you can specify this element and set the Status of this element to Enabled. You must enable replica modification sync on the source and destination buckets to replicate replica metadata changes between the source and the replicas.
    public struct ReplicaModifications: Swift.Equatable {
        /// Specifies whether S3 on Outposts replicates modifications to object metadata on replicas.
        /// This member is required.
        public var status: S3ControlClientTypes.ReplicaModificationsStatus?

        public init(
            status: S3ControlClientTypes.ReplicaModificationsStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension S3ControlClientTypes {
    public enum ReplicaModificationsStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicaModificationsStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicaModificationsStatus(rawValue: rawValue) ?? ReplicaModificationsStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.ReplicationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case role = "Role"
        case rules = "Rules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let role = role {
            try container.encode(role, forKey: ClientRuntime.Key("Role"))
        }
        if let rules = rules {
            var rulesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Rules"))
            for replicationrule0 in rules {
                try rulesContainer.encode(replicationrule0, forKey: ClientRuntime.Key("Rule"))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        if containerValues.contains(.rules) {
            struct KeyVal0{struct Rule{}}
            let rulesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Rule>.CodingKeys.self, forKey: .rules)
            if let rulesWrappedContainer = rulesWrappedContainer {
                let rulesContainer = try rulesWrappedContainer.decodeIfPresent([S3ControlClientTypes.ReplicationRule].self, forKey: .member)
                var rulesBuffer:[S3ControlClientTypes.ReplicationRule]? = nil
                if let rulesContainer = rulesContainer {
                    rulesBuffer = [S3ControlClientTypes.ReplicationRule]()
                    for structureContainer0 in rulesContainer {
                        rulesBuffer?.append(structureContainer0)
                    }
                }
                rules = rulesBuffer
            } else {
                rules = []
            }
        } else {
            rules = nil
        }
    }
}

extension S3ControlClientTypes.ReplicationConfiguration: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// A container for one or more replication rules. A replication configuration must have at least one rule and you can add up to 100 rules. The maximum size of a replication configuration is 128 KB.
    public struct ReplicationConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that S3 on Outposts assumes when replicating objects. For information about S3 replication on Outposts configuration, see [Setting up replication](https://docs.aws.amazon.com/AmazonS3/latest/userguide/outposts-replication-how-setup.html) in the Amazon S3 User Guide.
        /// This member is required.
        public var role: Swift.String?
        /// A container for one or more replication rules. A replication configuration must have at least one rule and can contain an array of 100 rules at the most.
        /// This member is required.
        public var rules: [S3ControlClientTypes.ReplicationRule]?

        public init(
            role: Swift.String? = nil,
            rules: [S3ControlClientTypes.ReplicationRule]? = nil
        )
        {
            self.role = role
            self.rules = rules
        }
    }

}

extension S3ControlClientTypes.ReplicationRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case deleteMarkerReplication = "DeleteMarkerReplication"
        case destination = "Destination"
        case existingObjectReplication = "ExistingObjectReplication"
        case filter = "Filter"
        case id = "ID"
        case `prefix` = "Prefix"
        case priority = "Priority"
        case sourceSelectionCriteria = "SourceSelectionCriteria"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let bucket = bucket {
            try container.encode(bucket, forKey: ClientRuntime.Key("Bucket"))
        }
        if let deleteMarkerReplication = deleteMarkerReplication {
            try container.encode(deleteMarkerReplication, forKey: ClientRuntime.Key("DeleteMarkerReplication"))
        }
        if let destination = destination {
            try container.encode(destination, forKey: ClientRuntime.Key("Destination"))
        }
        if let existingObjectReplication = existingObjectReplication {
            try container.encode(existingObjectReplication, forKey: ClientRuntime.Key("ExistingObjectReplication"))
        }
        if let filter = filter {
            try container.encode(filter, forKey: ClientRuntime.Key("Filter"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("ID"))
        }
        if let `prefix` = `prefix` {
            try container.encode(`prefix`, forKey: ClientRuntime.Key("Prefix"))
        }
        if let priority = priority {
            try container.encode(priority, forKey: ClientRuntime.Key("Priority"))
        }
        if let sourceSelectionCriteria = sourceSelectionCriteria {
            try container.encode(sourceSelectionCriteria, forKey: ClientRuntime.Key("SourceSelectionCriteria"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority) ?? nil
        priority = priorityDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        let filterDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ReplicationRuleFilter.self, forKey: .filter)
        filter = filterDecoded
        let statusDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ReplicationRuleStatus.self, forKey: .status)
        status = statusDecoded
        let sourceSelectionCriteriaDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.SourceSelectionCriteria.self, forKey: .sourceSelectionCriteria)
        sourceSelectionCriteria = sourceSelectionCriteriaDecoded
        let existingObjectReplicationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ExistingObjectReplication.self, forKey: .existingObjectReplication)
        existingObjectReplication = existingObjectReplicationDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.Destination.self, forKey: .destination)
        destination = destinationDecoded
        let deleteMarkerReplicationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.DeleteMarkerReplication.self, forKey: .deleteMarkerReplication)
        deleteMarkerReplication = deleteMarkerReplicationDecoded
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
    }
}

extension S3ControlClientTypes.ReplicationRule: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// Specifies which S3 on Outposts objects to replicate and where to store the replicas.
    public struct ReplicationRule: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the access point for the source Outposts bucket that you want S3 on Outposts to replicate the objects from.
        /// This member is required.
        public var bucket: Swift.String?
        /// Specifies whether S3 on Outposts replicates delete markers. If you specify a Filter element in your replication configuration, you must also include a DeleteMarkerReplication element. If your Filter includes a Tag element, the DeleteMarkerReplication element's Status child element must be set to Disabled, because S3 on Outposts doesn't support replicating delete markers for tag-based rules. For more information about delete marker replication, see [How delete operations affect replication](https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3OutpostsReplication.html#outposts-replication-what-is-replicated) in the Amazon S3 User Guide.
        public var deleteMarkerReplication: S3ControlClientTypes.DeleteMarkerReplication?
        /// A container for information about the replication destination and its configurations.
        /// This member is required.
        public var destination: S3ControlClientTypes.Destination?
        /// An optional configuration to replicate existing source bucket objects. This is not supported by Amazon S3 on Outposts buckets.
        public var existingObjectReplication: S3ControlClientTypes.ExistingObjectReplication?
        /// A filter that identifies the subset of objects to which the replication rule applies. A Filter element must specify exactly one Prefix, Tag, or And child element.
        public var filter: S3ControlClientTypes.ReplicationRuleFilter?
        /// A unique identifier for the rule. The maximum value is 255 characters.
        public var id: Swift.String?
        /// An object key name prefix that identifies the object or objects to which the rule applies. The maximum prefix length is 1,024 characters. To include all objects in an Outposts bucket, specify an empty string. When you're using XML requests, you must replace special characters (such as carriage returns) in object keys with their equivalent XML entity codes. For more information, see [ XML-related object key constraints](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints) in the Amazon S3 User Guide.
        @available(*, deprecated, message: "Prefix has been deprecated")
        public var `prefix`: Swift.String?
        /// The priority indicates which rule has precedence whenever two or more replication rules conflict. S3 on Outposts attempts to replicate objects according to all replication rules. However, if there are two or more rules with the same destination Outposts bucket, then objects will be replicated according to the rule with the highest priority. The higher the number, the higher the priority. For more information, see [Creating replication rules on Outposts](https://docs.aws.amazon.com/AmazonS3/latest/userguide/replication-between-outposts.html) in the Amazon S3 User Guide.
        public var priority: Swift.Int?
        /// A container that describes additional filters for identifying the source Outposts objects that you want to replicate. You can choose to enable or disable the replication of these objects.
        public var sourceSelectionCriteria: S3ControlClientTypes.SourceSelectionCriteria?
        /// Specifies whether the rule is enabled.
        /// This member is required.
        public var status: S3ControlClientTypes.ReplicationRuleStatus?

        public init(
            bucket: Swift.String? = nil,
            deleteMarkerReplication: S3ControlClientTypes.DeleteMarkerReplication? = nil,
            destination: S3ControlClientTypes.Destination? = nil,
            existingObjectReplication: S3ControlClientTypes.ExistingObjectReplication? = nil,
            filter: S3ControlClientTypes.ReplicationRuleFilter? = nil,
            id: Swift.String? = nil,
            `prefix`: Swift.String? = nil,
            priority: Swift.Int? = nil,
            sourceSelectionCriteria: S3ControlClientTypes.SourceSelectionCriteria? = nil,
            status: S3ControlClientTypes.ReplicationRuleStatus? = nil
        )
        {
            self.bucket = bucket
            self.deleteMarkerReplication = deleteMarkerReplication
            self.destination = destination
            self.existingObjectReplication = existingObjectReplication
            self.filter = filter
            self.id = id
            self.`prefix` = `prefix`
            self.priority = priority
            self.sourceSelectionCriteria = sourceSelectionCriteria
            self.status = status
        }
    }

}

extension S3ControlClientTypes.ReplicationRuleAndOperator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case `prefix` = "Prefix"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let `prefix` = `prefix` {
            try container.encode(`prefix`, forKey: ClientRuntime.Key("Prefix"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for s3tag0 in tags {
                try tagsContainer.encode(s3tag0, forKey: ClientRuntime.Key("member"))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([S3ControlClientTypes.S3Tag].self, forKey: .member)
                var tagsBuffer:[S3ControlClientTypes.S3Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [S3ControlClientTypes.S3Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension S3ControlClientTypes.ReplicationRuleAndOperator: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// A container for specifying rule filters. The filters determine the subset of objects to which the rule applies. This element is required only if you specify more than one filter. For example:
    ///
    /// * If you specify both a Prefix and a Tag filter, wrap these filters in an And element.
    ///
    /// * If you specify a filter based on multiple tags, wrap the Tag elements in an And element.
    public struct ReplicationRuleAndOperator: Swift.Equatable {
        /// An object key name prefix that identifies the subset of objects that the rule applies to.
        public var `prefix`: Swift.String?
        /// An array of tags that contain key and value pairs.
        public var tags: [S3ControlClientTypes.S3Tag]?

        public init(
            `prefix`: Swift.String? = nil,
            tags: [S3ControlClientTypes.S3Tag]? = nil
        )
        {
            self.`prefix` = `prefix`
            self.tags = tags
        }
    }

}

extension S3ControlClientTypes.ReplicationRuleFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case and = "And"
        case `prefix` = "Prefix"
        case tag = "Tag"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let and = and {
            try container.encode(and, forKey: ClientRuntime.Key("And"))
        }
        if let `prefix` = `prefix` {
            try container.encode(`prefix`, forKey: ClientRuntime.Key("Prefix"))
        }
        if let tag = tag {
            try container.encode(tag, forKey: ClientRuntime.Key("Tag"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        let tagDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3Tag.self, forKey: .tag)
        tag = tagDecoded
        let andDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ReplicationRuleAndOperator.self, forKey: .and)
        and = andDecoded
    }
}

extension S3ControlClientTypes.ReplicationRuleFilter: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// A filter that identifies the subset of objects to which the replication rule applies. A Filter element must specify exactly one Prefix, Tag, or And child element.
    public struct ReplicationRuleFilter: Swift.Equatable {
        /// A container for specifying rule filters. The filters determine the subset of objects that the rule applies to. This element is required only if you specify more than one filter. For example:
        ///
        /// * If you specify both a Prefix and a Tag filter, wrap these filters in an And element.
        ///
        /// * If you specify a filter based on multiple tags, wrap the Tag elements in an And element.
        public var and: S3ControlClientTypes.ReplicationRuleAndOperator?
        /// An object key name prefix that identifies the subset of objects that the rule applies to. When you're using XML requests, you must replace special characters (such as carriage returns) in object keys with their equivalent XML entity codes. For more information, see [ XML-related object key constraints](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints) in the Amazon S3 User Guide.
        public var `prefix`: Swift.String?
        /// A container for a key-value name pair.
        public var tag: S3ControlClientTypes.S3Tag?

        public init(
            and: S3ControlClientTypes.ReplicationRuleAndOperator? = nil,
            `prefix`: Swift.String? = nil,
            tag: S3ControlClientTypes.S3Tag? = nil
        )
        {
            self.and = and
            self.`prefix` = `prefix`
            self.tag = tag
        }
    }

}

extension S3ControlClientTypes {
    public enum ReplicationRuleStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationRuleStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationRuleStatus(rawValue: rawValue) ?? ReplicationRuleStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum ReplicationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case `none`
        case replica
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationStatus] {
            return [
                .completed,
                .failed,
                .none,
                .replica,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .none: return "NONE"
            case .replica: return "REPLICA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationStatus(rawValue: rawValue) ?? ReplicationStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum ReplicationStorageClass: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deepArchive
        case glacier
        case glacierIr
        case intelligentTiering
        case onezoneIa
        case outposts
        case reducedRedundancy
        case standard
        case standardIa
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationStorageClass] {
            return [
                .deepArchive,
                .glacier,
                .glacierIr,
                .intelligentTiering,
                .onezoneIa,
                .outposts,
                .reducedRedundancy,
                .standard,
                .standardIa,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deepArchive: return "DEEP_ARCHIVE"
            case .glacier: return "GLACIER"
            case .glacierIr: return "GLACIER_IR"
            case .intelligentTiering: return "INTELLIGENT_TIERING"
            case .onezoneIa: return "ONEZONE_IA"
            case .outposts: return "OUTPOSTS"
            case .reducedRedundancy: return "REDUCED_REDUNDANCY"
            case .standard: return "STANDARD"
            case .standardIa: return "STANDARD_IA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationStorageClass(rawValue: rawValue) ?? ReplicationStorageClass.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.ReplicationTime: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
        case time = "Time"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let time = time {
            try container.encode(time, forKey: ClientRuntime.Key("Time"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ReplicationTimeStatus.self, forKey: .status)
        status = statusDecoded
        let timeDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ReplicationTimeValue.self, forKey: .time)
        time = timeDecoded
    }
}

extension S3ControlClientTypes.ReplicationTime: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// A container that specifies S3 Replication Time Control (S3 RTC) related information, including whether S3 RTC is enabled and the time when all objects and operations on objects must be replicated. This is not supported by Amazon S3 on Outposts buckets.
    public struct ReplicationTime: Swift.Equatable {
        /// Specifies whether S3 Replication Time Control (S3 RTC) is enabled.
        /// This member is required.
        public var status: S3ControlClientTypes.ReplicationTimeStatus?
        /// A container that specifies the time by which replication should be complete for all objects and operations on objects.
        /// This member is required.
        public var time: S3ControlClientTypes.ReplicationTimeValue?

        public init(
            status: S3ControlClientTypes.ReplicationTimeStatus? = nil,
            time: S3ControlClientTypes.ReplicationTimeValue? = nil
        )
        {
            self.status = status
            self.time = time
        }
    }

}

extension S3ControlClientTypes {
    public enum ReplicationTimeStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationTimeStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationTimeStatus(rawValue: rawValue) ?? ReplicationTimeStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.ReplicationTimeValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case minutes = "Minutes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let minutes = minutes {
            try container.encode(minutes, forKey: ClientRuntime.Key("Minutes"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minutes) ?? nil
        minutes = minutesDecoded
    }
}

extension S3ControlClientTypes.ReplicationTimeValue: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// A container that specifies the time value for S3 Replication Time Control (S3 RTC). This value is also used for the replication metrics EventThreshold element. This is not supported by Amazon S3 on Outposts buckets.
    public struct ReplicationTimeValue: Swift.Equatable {
        /// Contains an integer that specifies the time period in minutes. Valid value: 15
        public var minutes: Swift.Int?

        public init(
            minutes: Swift.Int? = nil
        )
        {
            self.minutes = minutes
        }
    }

}

extension S3ControlClientTypes {
    public enum RequestedJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [RequestedJobStatus] {
            return [
                .cancelled,
                .ready,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "Cancelled"
            case .ready: return "Ready"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RequestedJobStatus(rawValue: rawValue) ?? RequestedJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.S3AccessControlList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grants = "Grants"
        case owner = "Owner"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let grants = grants {
            var grantsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Grants"))
            for s3grant0 in grants {
                try grantsContainer.encode(s3grant0, forKey: ClientRuntime.Key("member"))
            }
        }
        if let owner = owner {
            try container.encode(owner, forKey: ClientRuntime.Key("Owner"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3ObjectOwner.self, forKey: .owner)
        owner = ownerDecoded
        if containerValues.contains(.grants) {
            struct KeyVal0{struct member{}}
            let grantsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .grants)
            if let grantsWrappedContainer = grantsWrappedContainer {
                let grantsContainer = try grantsWrappedContainer.decodeIfPresent([S3ControlClientTypes.S3Grant].self, forKey: .member)
                var grantsBuffer:[S3ControlClientTypes.S3Grant]? = nil
                if let grantsContainer = grantsContainer {
                    grantsBuffer = [S3ControlClientTypes.S3Grant]()
                    for structureContainer0 in grantsContainer {
                        grantsBuffer?.append(structureContainer0)
                    }
                }
                grants = grantsBuffer
            } else {
                grants = []
            }
        } else {
            grants = nil
        }
    }
}

extension S3ControlClientTypes.S3AccessControlList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    ///
    public struct S3AccessControlList: Swift.Equatable {
        ///
        public var grants: [S3ControlClientTypes.S3Grant]?
        ///
        /// This member is required.
        public var owner: S3ControlClientTypes.S3ObjectOwner?

        public init(
            grants: [S3ControlClientTypes.S3Grant]? = nil,
            owner: S3ControlClientTypes.S3ObjectOwner? = nil
        )
        {
            self.grants = grants
            self.owner = owner
        }
    }

}

extension S3ControlClientTypes.S3AccessControlPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessControlList = "AccessControlList"
        case cannedAccessControlList = "CannedAccessControlList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let accessControlList = accessControlList {
            try container.encode(accessControlList, forKey: ClientRuntime.Key("AccessControlList"))
        }
        if let cannedAccessControlList = cannedAccessControlList {
            try container.encode(cannedAccessControlList, forKey: ClientRuntime.Key("CannedAccessControlList"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessControlListDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3AccessControlList.self, forKey: .accessControlList)
        accessControlList = accessControlListDecoded
        let cannedAccessControlListDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3CannedAccessControlList.self, forKey: .cannedAccessControlList)
        cannedAccessControlList = cannedAccessControlListDecoded
    }
}

extension S3ControlClientTypes.S3AccessControlPolicy: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    ///
    public struct S3AccessControlPolicy: Swift.Equatable {
        ///
        public var accessControlList: S3ControlClientTypes.S3AccessControlList?
        ///
        public var cannedAccessControlList: S3ControlClientTypes.S3CannedAccessControlList?

        public init(
            accessControlList: S3ControlClientTypes.S3AccessControlList? = nil,
            cannedAccessControlList: S3ControlClientTypes.S3CannedAccessControlList? = nil
        )
        {
            self.accessControlList = accessControlList
            self.cannedAccessControlList = cannedAccessControlList
        }
    }

}

extension S3ControlClientTypes.S3BucketDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case arn = "Arn"
        case encryption = "Encryption"
        case format = "Format"
        case outputSchemaVersion = "OutputSchemaVersion"
        case `prefix` = "Prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let accountId = accountId {
            try container.encode(accountId, forKey: ClientRuntime.Key("AccountId"))
        }
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let encryption = encryption {
            try container.encode(encryption, forKey: ClientRuntime.Key("Encryption"))
        }
        if let format = format {
            try container.encode(format, forKey: ClientRuntime.Key("Format"))
        }
        if let outputSchemaVersion = outputSchemaVersion {
            try container.encode(outputSchemaVersion, forKey: ClientRuntime.Key("OutputSchemaVersion"))
        }
        if let `prefix` = `prefix` {
            try container.encode(`prefix`, forKey: ClientRuntime.Key("Prefix"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.Format.self, forKey: .format)
        format = formatDecoded
        let outputSchemaVersionDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.OutputSchemaVersion.self, forKey: .outputSchemaVersion)
        outputSchemaVersion = outputSchemaVersionDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.StorageLensDataExportEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
    }
}

extension S3ControlClientTypes.S3BucketDestination: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// A container for the bucket where the Amazon S3 Storage Lens metrics export files are located.
    public struct S3BucketDestination: Swift.Equatable {
        /// The account ID of the owner of the S3 Storage Lens metrics export bucket.
        /// This member is required.
        public var accountId: Swift.String?
        /// The Amazon Resource Name (ARN) of the bucket. This property is read-only and follows the following format:  arn:aws:s3:us-east-1:example-account-id:bucket/your-destination-bucket-name
        /// This member is required.
        public var arn: Swift.String?
        /// The container for the type encryption of the metrics exports in this bucket.
        public var encryption: S3ControlClientTypes.StorageLensDataExportEncryption?
        ///
        /// This member is required.
        public var format: S3ControlClientTypes.Format?
        /// The schema version of the export file.
        /// This member is required.
        public var outputSchemaVersion: S3ControlClientTypes.OutputSchemaVersion?
        /// The prefix of the destination bucket where the metrics export will be delivered.
        public var `prefix`: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            arn: Swift.String? = nil,
            encryption: S3ControlClientTypes.StorageLensDataExportEncryption? = nil,
            format: S3ControlClientTypes.Format? = nil,
            outputSchemaVersion: S3ControlClientTypes.OutputSchemaVersion? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.arn = arn
            self.encryption = encryption
            self.format = format
            self.outputSchemaVersion = outputSchemaVersion
            self.`prefix` = `prefix`
        }
    }

}

extension S3ControlClientTypes {
    public enum S3CannedAccessControlList: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case authenticatedRead
        case awsExecRead
        case bucketOwnerFullControl
        case bucketOwnerRead
        case `private`
        case publicRead
        case publicReadWrite
        case sdkUnknown(Swift.String)

        public static var allCases: [S3CannedAccessControlList] {
            return [
                .authenticatedRead,
                .awsExecRead,
                .bucketOwnerFullControl,
                .bucketOwnerRead,
                .private,
                .publicRead,
                .publicReadWrite,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .authenticatedRead: return "authenticated-read"
            case .awsExecRead: return "aws-exec-read"
            case .bucketOwnerFullControl: return "bucket-owner-full-control"
            case .bucketOwnerRead: return "bucket-owner-read"
            case .private: return "private"
            case .publicRead: return "public-read"
            case .publicReadWrite: return "public-read-write"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3CannedAccessControlList(rawValue: rawValue) ?? S3CannedAccessControlList.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum S3ChecksumAlgorithm: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case crc32
        case crc32c
        case sha1
        case sha256
        case sdkUnknown(Swift.String)

        public static var allCases: [S3ChecksumAlgorithm] {
            return [
                .crc32,
                .crc32c,
                .sha1,
                .sha256,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .crc32: return "CRC32"
            case .crc32c: return "CRC32C"
            case .sha1: return "SHA1"
            case .sha256: return "SHA256"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3ChecksumAlgorithm(rawValue: rawValue) ?? S3ChecksumAlgorithm.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.S3CopyObjectOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessControlGrants = "AccessControlGrants"
        case bucketKeyEnabled = "BucketKeyEnabled"
        case cannedAccessControlList = "CannedAccessControlList"
        case checksumAlgorithm = "ChecksumAlgorithm"
        case metadataDirective = "MetadataDirective"
        case modifiedSinceConstraint = "ModifiedSinceConstraint"
        case newObjectMetadata = "NewObjectMetadata"
        case newObjectTagging = "NewObjectTagging"
        case objectLockLegalHoldStatus = "ObjectLockLegalHoldStatus"
        case objectLockMode = "ObjectLockMode"
        case objectLockRetainUntilDate = "ObjectLockRetainUntilDate"
        case redirectLocation = "RedirectLocation"
        case requesterPays = "RequesterPays"
        case sseAwsKmsKeyId = "SSEAwsKmsKeyId"
        case storageClass = "StorageClass"
        case targetKeyPrefix = "TargetKeyPrefix"
        case targetResource = "TargetResource"
        case unModifiedSinceConstraint = "UnModifiedSinceConstraint"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let accessControlGrants = accessControlGrants {
            var accessControlGrantsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AccessControlGrants"))
            for s3grant0 in accessControlGrants {
                try accessControlGrantsContainer.encode(s3grant0, forKey: ClientRuntime.Key("member"))
            }
        }
        if bucketKeyEnabled != false {
            try container.encode(bucketKeyEnabled, forKey: ClientRuntime.Key("BucketKeyEnabled"))
        }
        if let cannedAccessControlList = cannedAccessControlList {
            try container.encode(cannedAccessControlList, forKey: ClientRuntime.Key("CannedAccessControlList"))
        }
        if let checksumAlgorithm = checksumAlgorithm {
            try container.encode(checksumAlgorithm, forKey: ClientRuntime.Key("ChecksumAlgorithm"))
        }
        if let metadataDirective = metadataDirective {
            try container.encode(metadataDirective, forKey: ClientRuntime.Key("MetadataDirective"))
        }
        if let modifiedSinceConstraint = modifiedSinceConstraint {
            try container.encodeTimestamp(modifiedSinceConstraint, format: .dateTime, forKey: ClientRuntime.Key("ModifiedSinceConstraint"))
        }
        if let newObjectMetadata = newObjectMetadata {
            try container.encode(newObjectMetadata, forKey: ClientRuntime.Key("NewObjectMetadata"))
        }
        if let newObjectTagging = newObjectTagging {
            var newObjectTaggingContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("NewObjectTagging"))
            for s3tag0 in newObjectTagging {
                try newObjectTaggingContainer.encode(s3tag0, forKey: ClientRuntime.Key("member"))
            }
        }
        if let objectLockLegalHoldStatus = objectLockLegalHoldStatus {
            try container.encode(objectLockLegalHoldStatus, forKey: ClientRuntime.Key("ObjectLockLegalHoldStatus"))
        }
        if let objectLockMode = objectLockMode {
            try container.encode(objectLockMode, forKey: ClientRuntime.Key("ObjectLockMode"))
        }
        if let objectLockRetainUntilDate = objectLockRetainUntilDate {
            try container.encodeTimestamp(objectLockRetainUntilDate, format: .dateTime, forKey: ClientRuntime.Key("ObjectLockRetainUntilDate"))
        }
        if let redirectLocation = redirectLocation {
            try container.encode(redirectLocation, forKey: ClientRuntime.Key("RedirectLocation"))
        }
        if requesterPays != false {
            try container.encode(requesterPays, forKey: ClientRuntime.Key("RequesterPays"))
        }
        if let sseAwsKmsKeyId = sseAwsKmsKeyId {
            try container.encode(sseAwsKmsKeyId, forKey: ClientRuntime.Key("SSEAwsKmsKeyId"))
        }
        if let storageClass = storageClass {
            try container.encode(storageClass, forKey: ClientRuntime.Key("StorageClass"))
        }
        if let targetKeyPrefix = targetKeyPrefix {
            try container.encode(targetKeyPrefix, forKey: ClientRuntime.Key("TargetKeyPrefix"))
        }
        if let targetResource = targetResource {
            try container.encode(targetResource, forKey: ClientRuntime.Key("TargetResource"))
        }
        if let unModifiedSinceConstraint = unModifiedSinceConstraint {
            try container.encodeTimestamp(unModifiedSinceConstraint, format: .dateTime, forKey: ClientRuntime.Key("UnModifiedSinceConstraint"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetResourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetResource)
        targetResource = targetResourceDecoded
        let cannedAccessControlListDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3CannedAccessControlList.self, forKey: .cannedAccessControlList)
        cannedAccessControlList = cannedAccessControlListDecoded
        if containerValues.contains(.accessControlGrants) {
            struct KeyVal0{struct member{}}
            let accessControlGrantsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .accessControlGrants)
            if let accessControlGrantsWrappedContainer = accessControlGrantsWrappedContainer {
                let accessControlGrantsContainer = try accessControlGrantsWrappedContainer.decodeIfPresent([S3ControlClientTypes.S3Grant].self, forKey: .member)
                var accessControlGrantsBuffer:[S3ControlClientTypes.S3Grant]? = nil
                if let accessControlGrantsContainer = accessControlGrantsContainer {
                    accessControlGrantsBuffer = [S3ControlClientTypes.S3Grant]()
                    for structureContainer0 in accessControlGrantsContainer {
                        accessControlGrantsBuffer?.append(structureContainer0)
                    }
                }
                accessControlGrants = accessControlGrantsBuffer
            } else {
                accessControlGrants = []
            }
        } else {
            accessControlGrants = nil
        }
        let metadataDirectiveDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3MetadataDirective.self, forKey: .metadataDirective)
        metadataDirective = metadataDirectiveDecoded
        let modifiedSinceConstraintDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .modifiedSinceConstraint)
        modifiedSinceConstraint = modifiedSinceConstraintDecoded
        let newObjectMetadataDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3ObjectMetadata.self, forKey: .newObjectMetadata)
        newObjectMetadata = newObjectMetadataDecoded
        if containerValues.contains(.newObjectTagging) {
            struct KeyVal0{struct member{}}
            let newObjectTaggingWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .newObjectTagging)
            if let newObjectTaggingWrappedContainer = newObjectTaggingWrappedContainer {
                let newObjectTaggingContainer = try newObjectTaggingWrappedContainer.decodeIfPresent([S3ControlClientTypes.S3Tag].self, forKey: .member)
                var newObjectTaggingBuffer:[S3ControlClientTypes.S3Tag]? = nil
                if let newObjectTaggingContainer = newObjectTaggingContainer {
                    newObjectTaggingBuffer = [S3ControlClientTypes.S3Tag]()
                    for structureContainer0 in newObjectTaggingContainer {
                        newObjectTaggingBuffer?.append(structureContainer0)
                    }
                }
                newObjectTagging = newObjectTaggingBuffer
            } else {
                newObjectTagging = []
            }
        } else {
            newObjectTagging = nil
        }
        let redirectLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .redirectLocation)
        redirectLocation = redirectLocationDecoded
        let requesterPaysDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requesterPays) ?? false
        requesterPays = requesterPaysDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3StorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
        let unModifiedSinceConstraintDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .unModifiedSinceConstraint)
        unModifiedSinceConstraint = unModifiedSinceConstraintDecoded
        let sseAwsKmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sseAwsKmsKeyId)
        sseAwsKmsKeyId = sseAwsKmsKeyIdDecoded
        let targetKeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetKeyPrefix)
        targetKeyPrefix = targetKeyPrefixDecoded
        let objectLockLegalHoldStatusDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3ObjectLockLegalHoldStatus.self, forKey: .objectLockLegalHoldStatus)
        objectLockLegalHoldStatus = objectLockLegalHoldStatusDecoded
        let objectLockModeDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3ObjectLockMode.self, forKey: .objectLockMode)
        objectLockMode = objectLockModeDecoded
        let objectLockRetainUntilDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .objectLockRetainUntilDate)
        objectLockRetainUntilDate = objectLockRetainUntilDateDecoded
        let bucketKeyEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .bucketKeyEnabled) ?? false
        bucketKeyEnabled = bucketKeyEnabledDecoded
        let checksumAlgorithmDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3ChecksumAlgorithm.self, forKey: .checksumAlgorithm)
        checksumAlgorithm = checksumAlgorithmDecoded
    }
}

extension S3ControlClientTypes.S3CopyObjectOperation: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// Contains the configuration parameters for a PUT Copy object operation. S3 Batch Operations passes every object to the underlying CopyObject API operation. For more information about the parameters for this operation, see [CopyObject](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectCOPY.html).
    public struct S3CopyObjectOperation: Swift.Equatable {
        ///
        public var accessControlGrants: [S3ControlClientTypes.S3Grant]?
        /// Specifies whether Amazon S3 should use an S3 Bucket Key for object encryption with server-side encryption using Amazon Web Services KMS (SSE-KMS). Setting this header to true causes Amazon S3 to use an S3 Bucket Key for object encryption with SSE-KMS. Specifying this header with an object action doesnt affect bucket-level settings for S3 Bucket Key.
        public var bucketKeyEnabled: Swift.Bool
        ///
        public var cannedAccessControlList: S3ControlClientTypes.S3CannedAccessControlList?
        /// Indicates the algorithm that you want Amazon S3 to use to create the checksum. For more information, see [ Checking object integrity](https://docs.aws.amazon.com/AmazonS3/latest/userguide/CheckingObjectIntegrity.xml) in the Amazon S3 User Guide.
        public var checksumAlgorithm: S3ControlClientTypes.S3ChecksumAlgorithm?
        ///
        public var metadataDirective: S3ControlClientTypes.S3MetadataDirective?
        ///
        public var modifiedSinceConstraint: ClientRuntime.Date?
        /// If you don't provide this parameter, Amazon S3 copies all the metadata from the original objects. If you specify an empty set, the new objects will have no tags. Otherwise, Amazon S3 assigns the supplied tags to the new objects.
        public var newObjectMetadata: S3ControlClientTypes.S3ObjectMetadata?
        ///
        public var newObjectTagging: [S3ControlClientTypes.S3Tag]?
        /// The legal hold status to be applied to all objects in the Batch Operations job.
        public var objectLockLegalHoldStatus: S3ControlClientTypes.S3ObjectLockLegalHoldStatus?
        /// The retention mode to be applied to all objects in the Batch Operations job.
        public var objectLockMode: S3ControlClientTypes.S3ObjectLockMode?
        /// The date when the applied object retention configuration expires on all objects in the Batch Operations job.
        public var objectLockRetainUntilDate: ClientRuntime.Date?
        /// Specifies an optional metadata property for website redirects, x-amz-website-redirect-location. Allows webpage redirects if the object is accessed through a website endpoint.
        public var redirectLocation: Swift.String?
        ///
        public var requesterPays: Swift.Bool
        ///
        public var sseAwsKmsKeyId: Swift.String?
        ///
        public var storageClass: S3ControlClientTypes.S3StorageClass?
        /// Specifies the folder prefix that you want the objects to be copied into. For example, to copy objects into a folder named Folder1 in the destination bucket, set the TargetKeyPrefix property to Folder1.
        public var targetKeyPrefix: Swift.String?
        /// Specifies the destination bucket Amazon Resource Name (ARN) for the batch copy operation. For example, to copy objects to a bucket named destinationBucket, set the TargetResource property to arn:aws:s3:::destinationBucket.
        public var targetResource: Swift.String?
        ///
        public var unModifiedSinceConstraint: ClientRuntime.Date?

        public init(
            accessControlGrants: [S3ControlClientTypes.S3Grant]? = nil,
            bucketKeyEnabled: Swift.Bool = false,
            cannedAccessControlList: S3ControlClientTypes.S3CannedAccessControlList? = nil,
            checksumAlgorithm: S3ControlClientTypes.S3ChecksumAlgorithm? = nil,
            metadataDirective: S3ControlClientTypes.S3MetadataDirective? = nil,
            modifiedSinceConstraint: ClientRuntime.Date? = nil,
            newObjectMetadata: S3ControlClientTypes.S3ObjectMetadata? = nil,
            newObjectTagging: [S3ControlClientTypes.S3Tag]? = nil,
            objectLockLegalHoldStatus: S3ControlClientTypes.S3ObjectLockLegalHoldStatus? = nil,
            objectLockMode: S3ControlClientTypes.S3ObjectLockMode? = nil,
            objectLockRetainUntilDate: ClientRuntime.Date? = nil,
            redirectLocation: Swift.String? = nil,
            requesterPays: Swift.Bool = false,
            sseAwsKmsKeyId: Swift.String? = nil,
            storageClass: S3ControlClientTypes.S3StorageClass? = nil,
            targetKeyPrefix: Swift.String? = nil,
            targetResource: Swift.String? = nil,
            unModifiedSinceConstraint: ClientRuntime.Date? = nil
        )
        {
            self.accessControlGrants = accessControlGrants
            self.bucketKeyEnabled = bucketKeyEnabled
            self.cannedAccessControlList = cannedAccessControlList
            self.checksumAlgorithm = checksumAlgorithm
            self.metadataDirective = metadataDirective
            self.modifiedSinceConstraint = modifiedSinceConstraint
            self.newObjectMetadata = newObjectMetadata
            self.newObjectTagging = newObjectTagging
            self.objectLockLegalHoldStatus = objectLockLegalHoldStatus
            self.objectLockMode = objectLockMode
            self.objectLockRetainUntilDate = objectLockRetainUntilDate
            self.redirectLocation = redirectLocation
            self.requesterPays = requesterPays
            self.sseAwsKmsKeyId = sseAwsKmsKeyId
            self.storageClass = storageClass
            self.targetKeyPrefix = targetKeyPrefix
            self.targetResource = targetResource
            self.unModifiedSinceConstraint = unModifiedSinceConstraint
        }
    }

}

extension S3ControlClientTypes.S3DeleteObjectTaggingOperation: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension S3ControlClientTypes {
    /// Contains no configuration parameters because the DELETE Object tagging (DeleteObjectTagging) API operation accepts only the bucket name and key name as parameters, which are defined in the job's manifest.
    public struct S3DeleteObjectTaggingOperation: Swift.Equatable {

        public init() { }
    }

}

extension S3ControlClientTypes.S3GeneratedManifestDescriptor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format = "Format"
        case location = "Location"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let format = format {
            try container.encode(format, forKey: ClientRuntime.Key("Format"))
        }
        if let location = location {
            try container.encode(location, forKey: ClientRuntime.Key("Location"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.GeneratedManifestFormat.self, forKey: .format)
        format = formatDecoded
        let locationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobManifestLocation.self, forKey: .location)
        location = locationDecoded
    }
}

extension S3ControlClientTypes.S3GeneratedManifestDescriptor: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// Describes the specified job's generated manifest. Batch Operations jobs created with a ManifestGenerator populate details of this descriptor after execution of the ManifestGenerator.
    public struct S3GeneratedManifestDescriptor: Swift.Equatable {
        /// The format of the generated manifest.
        public var format: S3ControlClientTypes.GeneratedManifestFormat?
        /// Contains the information required to locate a manifest object.
        public var location: S3ControlClientTypes.JobManifestLocation?

        public init(
            format: S3ControlClientTypes.GeneratedManifestFormat? = nil,
            location: S3ControlClientTypes.JobManifestLocation? = nil
        )
        {
            self.format = format
            self.location = location
        }
    }

}

extension S3ControlClientTypes {
    public enum S3GlacierJobTier: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bulk
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [S3GlacierJobTier] {
            return [
                .bulk,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bulk: return "BULK"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3GlacierJobTier(rawValue: rawValue) ?? S3GlacierJobTier.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.S3Grant: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantee = "Grantee"
        case permission = "Permission"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let grantee = grantee {
            try container.encode(grantee, forKey: ClientRuntime.Key("Grantee"))
        }
        if let permission = permission {
            try container.encode(permission, forKey: ClientRuntime.Key("Permission"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let granteeDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3Grantee.self, forKey: .grantee)
        grantee = granteeDecoded
        let permissionDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3Permission.self, forKey: .permission)
        permission = permissionDecoded
    }
}

extension S3ControlClientTypes.S3Grant: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    ///
    public struct S3Grant: Swift.Equatable {
        ///
        public var grantee: S3ControlClientTypes.S3Grantee?
        ///
        public var permission: S3ControlClientTypes.S3Permission?

        public init(
            grantee: S3ControlClientTypes.S3Grantee? = nil,
            permission: S3ControlClientTypes.S3Permission? = nil
        )
        {
            self.grantee = grantee
            self.permission = permission
        }
    }

}

extension S3ControlClientTypes.S3Grantee: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case identifier = "Identifier"
        case typeIdentifier = "TypeIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let displayName = displayName {
            try container.encode(displayName, forKey: ClientRuntime.Key("DisplayName"))
        }
        if let identifier = identifier {
            try container.encode(identifier, forKey: ClientRuntime.Key("Identifier"))
        }
        if let typeIdentifier = typeIdentifier {
            try container.encode(typeIdentifier, forKey: ClientRuntime.Key("TypeIdentifier"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeIdentifierDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3GranteeTypeIdentifier.self, forKey: .typeIdentifier)
        typeIdentifier = typeIdentifierDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension S3ControlClientTypes.S3Grantee: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    ///
    public struct S3Grantee: Swift.Equatable {
        ///
        public var displayName: Swift.String?
        ///
        public var identifier: Swift.String?
        ///
        public var typeIdentifier: S3ControlClientTypes.S3GranteeTypeIdentifier?

        public init(
            displayName: Swift.String? = nil,
            identifier: Swift.String? = nil,
            typeIdentifier: S3ControlClientTypes.S3GranteeTypeIdentifier? = nil
        )
        {
            self.displayName = displayName
            self.identifier = identifier
            self.typeIdentifier = typeIdentifier
        }
    }

}

extension S3ControlClientTypes {
    public enum S3GranteeTypeIdentifier: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canonical
        case emailAddress
        case group
        case sdkUnknown(Swift.String)

        public static var allCases: [S3GranteeTypeIdentifier] {
            return [
                .canonical,
                .emailAddress,
                .group,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canonical: return "id"
            case .emailAddress: return "emailAddress"
            case .group: return "uri"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3GranteeTypeIdentifier(rawValue: rawValue) ?? S3GranteeTypeIdentifier.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.S3InitiateRestoreObjectOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expirationInDays = "ExpirationInDays"
        case glacierJobTier = "GlacierJobTier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let expirationInDays = expirationInDays {
            try container.encode(expirationInDays, forKey: ClientRuntime.Key("ExpirationInDays"))
        }
        if let glacierJobTier = glacierJobTier {
            try container.encode(glacierJobTier, forKey: ClientRuntime.Key("GlacierJobTier"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expirationInDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expirationInDays) ?? nil
        expirationInDays = expirationInDaysDecoded
        let glacierJobTierDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3GlacierJobTier.self, forKey: .glacierJobTier)
        glacierJobTier = glacierJobTierDecoded
    }
}

extension S3ControlClientTypes.S3InitiateRestoreObjectOperation: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// Contains the configuration parameters for a POST Object restore job. S3 Batch Operations passes every object to the underlying RestoreObject API operation. For more information about the parameters for this operation, see [RestoreObject](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectPOSTrestore.html#RESTObjectPOSTrestore-restore-request).
    public struct S3InitiateRestoreObjectOperation: Swift.Equatable {
        /// This argument specifies how long the S3 Glacier or S3 Glacier Deep Archive object remains available in Amazon S3. S3 Initiate Restore Object jobs that target S3 Glacier and S3 Glacier Deep Archive objects require ExpirationInDays set to 1 or greater. Conversely, do not set ExpirationInDays when creating S3 Initiate Restore Object jobs that target S3 Intelligent-Tiering Archive Access and Deep Archive Access tier objects. Objects in S3 Intelligent-Tiering archive access tiers are not subject to restore expiry, so specifying ExpirationInDays results in restore request failure. S3 Batch Operations jobs can operate either on S3 Glacier and S3 Glacier Deep Archive storage class objects or on S3 Intelligent-Tiering Archive Access and Deep Archive Access storage tier objects, but not both types in the same job. If you need to restore objects of both types you must create separate Batch Operations jobs.
        public var expirationInDays: Swift.Int?
        /// S3 Batch Operations supports STANDARD and BULK retrieval tiers, but not the EXPEDITED retrieval tier.
        public var glacierJobTier: S3ControlClientTypes.S3GlacierJobTier?

        public init(
            expirationInDays: Swift.Int? = nil,
            glacierJobTier: S3ControlClientTypes.S3GlacierJobTier? = nil
        )
        {
            self.expirationInDays = expirationInDays
            self.glacierJobTier = glacierJobTier
        }
    }

}

extension S3ControlClientTypes.S3JobManifestGenerator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableManifestOutput = "EnableManifestOutput"
        case expectedBucketOwner = "ExpectedBucketOwner"
        case filter = "Filter"
        case manifestOutputLocation = "ManifestOutputLocation"
        case sourceBucket = "SourceBucket"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if enableManifestOutput != false {
            try container.encode(enableManifestOutput, forKey: ClientRuntime.Key("EnableManifestOutput"))
        }
        if let expectedBucketOwner = expectedBucketOwner {
            try container.encode(expectedBucketOwner, forKey: ClientRuntime.Key("ExpectedBucketOwner"))
        }
        if let filter = filter {
            try container.encode(filter, forKey: ClientRuntime.Key("Filter"))
        }
        if let manifestOutputLocation = manifestOutputLocation {
            try container.encode(manifestOutputLocation, forKey: ClientRuntime.Key("ManifestOutputLocation"))
        }
        if let sourceBucket = sourceBucket {
            try container.encode(sourceBucket, forKey: ClientRuntime.Key("SourceBucket"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expectedBucketOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expectedBucketOwner)
        expectedBucketOwner = expectedBucketOwnerDecoded
        let sourceBucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceBucket)
        sourceBucket = sourceBucketDecoded
        let manifestOutputLocationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3ManifestOutputLocation.self, forKey: .manifestOutputLocation)
        manifestOutputLocation = manifestOutputLocationDecoded
        let filterDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobManifestGeneratorFilter.self, forKey: .filter)
        filter = filterDecoded
        let enableManifestOutputDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableManifestOutput) ?? false
        enableManifestOutput = enableManifestOutputDecoded
    }
}

extension S3ControlClientTypes.S3JobManifestGenerator: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// The container for the service that will create the S3 manifest.
    public struct S3JobManifestGenerator: Swift.Equatable {
        /// Determines whether or not to write the job's generated manifest to a bucket.
        /// This member is required.
        public var enableManifestOutput: Swift.Bool
        /// The Amazon Web Services account ID that owns the bucket the generated manifest is written to. If provided the generated manifest bucket's owner Amazon Web Services account ID must match this value, else the job fails.
        public var expectedBucketOwner: Swift.String?
        /// Specifies rules the S3JobManifestGenerator should use to use to decide whether an object in the source bucket should or should not be included in the generated job manifest.
        public var filter: S3ControlClientTypes.JobManifestGeneratorFilter?
        /// Specifies the location the generated manifest will be written to.
        public var manifestOutputLocation: S3ControlClientTypes.S3ManifestOutputLocation?
        /// The source bucket used by the ManifestGenerator.
        /// This member is required.
        public var sourceBucket: Swift.String?

        public init(
            enableManifestOutput: Swift.Bool = false,
            expectedBucketOwner: Swift.String? = nil,
            filter: S3ControlClientTypes.JobManifestGeneratorFilter? = nil,
            manifestOutputLocation: S3ControlClientTypes.S3ManifestOutputLocation? = nil,
            sourceBucket: Swift.String? = nil
        )
        {
            self.enableManifestOutput = enableManifestOutput
            self.expectedBucketOwner = expectedBucketOwner
            self.filter = filter
            self.manifestOutputLocation = manifestOutputLocation
            self.sourceBucket = sourceBucket
        }
    }

}

extension S3ControlClientTypes.S3ManifestOutputLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case expectedManifestBucketOwner = "ExpectedManifestBucketOwner"
        case manifestEncryption = "ManifestEncryption"
        case manifestFormat = "ManifestFormat"
        case manifestPrefix = "ManifestPrefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let bucket = bucket {
            try container.encode(bucket, forKey: ClientRuntime.Key("Bucket"))
        }
        if let expectedManifestBucketOwner = expectedManifestBucketOwner {
            try container.encode(expectedManifestBucketOwner, forKey: ClientRuntime.Key("ExpectedManifestBucketOwner"))
        }
        if let manifestEncryption = manifestEncryption {
            try container.encode(manifestEncryption, forKey: ClientRuntime.Key("ManifestEncryption"))
        }
        if let manifestFormat = manifestFormat {
            try container.encode(manifestFormat, forKey: ClientRuntime.Key("ManifestFormat"))
        }
        if let manifestPrefix = manifestPrefix {
            try container.encode(manifestPrefix, forKey: ClientRuntime.Key("ManifestPrefix"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expectedManifestBucketOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expectedManifestBucketOwner)
        expectedManifestBucketOwner = expectedManifestBucketOwnerDecoded
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let manifestPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestPrefix)
        manifestPrefix = manifestPrefixDecoded
        let manifestEncryptionDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.GeneratedManifestEncryption.self, forKey: .manifestEncryption)
        manifestEncryption = manifestEncryptionDecoded
        let manifestFormatDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.GeneratedManifestFormat.self, forKey: .manifestFormat)
        manifestFormat = manifestFormatDecoded
    }
}

extension S3ControlClientTypes.S3ManifestOutputLocation: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// Location details for where the generated manifest should be written.
    public struct S3ManifestOutputLocation: Swift.Equatable {
        /// The bucket ARN the generated manifest should be written to.
        /// This member is required.
        public var bucket: Swift.String?
        /// The Account ID that owns the bucket the generated manifest is written to.
        public var expectedManifestBucketOwner: Swift.String?
        /// Specifies what encryption should be used when the generated manifest objects are written.
        public var manifestEncryption: S3ControlClientTypes.GeneratedManifestEncryption?
        /// The format of the generated manifest.
        /// This member is required.
        public var manifestFormat: S3ControlClientTypes.GeneratedManifestFormat?
        /// Prefix identifying one or more objects to which the manifest applies.
        public var manifestPrefix: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            expectedManifestBucketOwner: Swift.String? = nil,
            manifestEncryption: S3ControlClientTypes.GeneratedManifestEncryption? = nil,
            manifestFormat: S3ControlClientTypes.GeneratedManifestFormat? = nil,
            manifestPrefix: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.expectedManifestBucketOwner = expectedManifestBucketOwner
            self.manifestEncryption = manifestEncryption
            self.manifestFormat = manifestFormat
            self.manifestPrefix = manifestPrefix
        }
    }

}

extension S3ControlClientTypes {
    public enum S3MetadataDirective: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case copy
        case replace
        case sdkUnknown(Swift.String)

        public static var allCases: [S3MetadataDirective] {
            return [
                .copy,
                .replace,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .copy: return "COPY"
            case .replace: return "REPLACE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3MetadataDirective(rawValue: rawValue) ?? S3MetadataDirective.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.S3ObjectLockLegalHold: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3ObjectLockLegalHoldStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension S3ControlClientTypes.S3ObjectLockLegalHold: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// Whether S3 Object Lock legal hold will be applied to objects in an S3 Batch Operations job.
    public struct S3ObjectLockLegalHold: Swift.Equatable {
        /// The Object Lock legal hold status to be applied to all objects in the Batch Operations job.
        /// This member is required.
        public var status: S3ControlClientTypes.S3ObjectLockLegalHoldStatus?

        public init(
            status: S3ControlClientTypes.S3ObjectLockLegalHoldStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension S3ControlClientTypes {
    public enum S3ObjectLockLegalHoldStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case off
        case on
        case sdkUnknown(Swift.String)

        public static var allCases: [S3ObjectLockLegalHoldStatus] {
            return [
                .off,
                .on,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .off: return "OFF"
            case .on: return "ON"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3ObjectLockLegalHoldStatus(rawValue: rawValue) ?? S3ObjectLockLegalHoldStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum S3ObjectLockMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case compliance
        case governance
        case sdkUnknown(Swift.String)

        public static var allCases: [S3ObjectLockMode] {
            return [
                .compliance,
                .governance,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .compliance: return "COMPLIANCE"
            case .governance: return "GOVERNANCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3ObjectLockMode(rawValue: rawValue) ?? S3ObjectLockMode.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes {
    public enum S3ObjectLockRetentionMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case compliance
        case governance
        case sdkUnknown(Swift.String)

        public static var allCases: [S3ObjectLockRetentionMode] {
            return [
                .compliance,
                .governance,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .compliance: return "COMPLIANCE"
            case .governance: return "GOVERNANCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3ObjectLockRetentionMode(rawValue: rawValue) ?? S3ObjectLockRetentionMode.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.S3ObjectMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cacheControl = "CacheControl"
        case contentDisposition = "ContentDisposition"
        case contentEncoding = "ContentEncoding"
        case contentLanguage = "ContentLanguage"
        case contentLength = "ContentLength"
        case contentMD5 = "ContentMD5"
        case contentType = "ContentType"
        case httpExpiresDate = "HttpExpiresDate"
        case requesterCharged = "RequesterCharged"
        case sseAlgorithm = "SSEAlgorithm"
        case userMetadata = "UserMetadata"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cacheControl = cacheControl {
            try container.encode(cacheControl, forKey: ClientRuntime.Key("CacheControl"))
        }
        if let contentDisposition = contentDisposition {
            try container.encode(contentDisposition, forKey: ClientRuntime.Key("ContentDisposition"))
        }
        if let contentEncoding = contentEncoding {
            try container.encode(contentEncoding, forKey: ClientRuntime.Key("ContentEncoding"))
        }
        if let contentLanguage = contentLanguage {
            try container.encode(contentLanguage, forKey: ClientRuntime.Key("ContentLanguage"))
        }
        if let contentLength = contentLength {
            try container.encode(contentLength, forKey: ClientRuntime.Key("ContentLength"))
        }
        if let contentMD5 = contentMD5 {
            try container.encode(contentMD5, forKey: ClientRuntime.Key("ContentMD5"))
        }
        if let contentType = contentType {
            try container.encode(contentType, forKey: ClientRuntime.Key("ContentType"))
        }
        if let httpExpiresDate = httpExpiresDate {
            try container.encodeTimestamp(httpExpiresDate, format: .dateTime, forKey: ClientRuntime.Key("HttpExpiresDate"))
        }
        if requesterCharged != false {
            try container.encode(requesterCharged, forKey: ClientRuntime.Key("RequesterCharged"))
        }
        if let sseAlgorithm = sseAlgorithm {
            try container.encode(sseAlgorithm, forKey: ClientRuntime.Key("SSEAlgorithm"))
        }
        if let userMetadata = userMetadata {
            var UserMetadataContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("UserMetadata"))
            for (nonemptymaxlength1024stringKey0, maxlength1024stringValue0) in userMetadata {
                var entryContainer0 = UserMetadataContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("entry"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("key"))
                try keyContainer0.encode(nonemptymaxlength1024stringKey0, forKey: ClientRuntime.Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("value"))
                try valueContainer0.encode(maxlength1024stringValue0, forKey: ClientRuntime.Key(""))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cacheControlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cacheControl)
        cacheControl = cacheControlDecoded
        let contentDispositionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentDisposition)
        contentDisposition = contentDispositionDecoded
        let contentEncodingDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentEncoding)
        contentEncoding = contentEncodingDecoded
        let contentLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentLanguage)
        contentLanguage = contentLanguageDecoded
        if containerValues.contains(.userMetadata) {
            struct KeyVal0{struct key{}; struct value{}}
            let userMetadataWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: ClientRuntime.MapEntry<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .userMetadata)
            if let userMetadataWrappedContainer = userMetadataWrappedContainer {
                let userMetadataContainer = try userMetadataWrappedContainer.decodeIfPresent([ClientRuntime.MapKeyValue<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var userMetadataBuffer: [Swift.String:Swift.String]? = nil
                if let userMetadataContainer = userMetadataContainer {
                    userMetadataBuffer = [Swift.String:Swift.String]()
                    for stringContainer0 in userMetadataContainer {
                        userMetadataBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                userMetadata = userMetadataBuffer
            } else {
                userMetadata = [:]
            }
        } else {
            userMetadata = nil
        }
        let contentLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .contentLength) ?? nil
        contentLength = contentLengthDecoded
        let contentMD5Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentMD5)
        contentMD5 = contentMD5Decoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let httpExpiresDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .httpExpiresDate)
        httpExpiresDate = httpExpiresDateDecoded
        let requesterChargedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requesterCharged) ?? false
        requesterCharged = requesterChargedDecoded
        let sseAlgorithmDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3SSEAlgorithm.self, forKey: .sseAlgorithm)
        sseAlgorithm = sseAlgorithmDecoded
    }
}

extension S3ControlClientTypes.S3ObjectMetadata: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    ///
    public struct S3ObjectMetadata: Swift.Equatable {
        ///
        public var cacheControl: Swift.String?
        ///
        public var contentDisposition: Swift.String?
        ///
        public var contentEncoding: Swift.String?
        ///
        public var contentLanguage: Swift.String?
        ///
        public var contentLength: Swift.Int?
        ///
        public var contentMD5: Swift.String?
        ///
        public var contentType: Swift.String?
        ///
        public var httpExpiresDate: ClientRuntime.Date?
        ///
        public var requesterCharged: Swift.Bool
        ///
        public var sseAlgorithm: S3ControlClientTypes.S3SSEAlgorithm?
        ///
        public var userMetadata: [Swift.String:Swift.String]?

        public init(
            cacheControl: Swift.String? = nil,
            contentDisposition: Swift.String? = nil,
            contentEncoding: Swift.String? = nil,
            contentLanguage: Swift.String? = nil,
            contentLength: Swift.Int? = nil,
            contentMD5: Swift.String? = nil,
            contentType: Swift.String? = nil,
            httpExpiresDate: ClientRuntime.Date? = nil,
            requesterCharged: Swift.Bool = false,
            sseAlgorithm: S3ControlClientTypes.S3SSEAlgorithm? = nil,
            userMetadata: [Swift.String:Swift.String]? = nil
        )
        {
            self.cacheControl = cacheControl
            self.contentDisposition = contentDisposition
            self.contentEncoding = contentEncoding
            self.contentLanguage = contentLanguage
            self.contentLength = contentLength
            self.contentMD5 = contentMD5
            self.contentType = contentType
            self.httpExpiresDate = httpExpiresDate
            self.requesterCharged = requesterCharged
            self.sseAlgorithm = sseAlgorithm
            self.userMetadata = userMetadata
        }
    }

}

extension S3ControlClientTypes.S3ObjectOwner: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case id = "ID"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let displayName = displayName {
            try container.encode(displayName, forKey: ClientRuntime.Key("DisplayName"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("ID"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension S3ControlClientTypes.S3ObjectOwner: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    ///
    public struct S3ObjectOwner: Swift.Equatable {
        ///
        public var displayName: Swift.String?
        ///
        public var id: Swift.String?

        public init(
            displayName: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.displayName = displayName
            self.id = id
        }
    }

}

extension S3ControlClientTypes {
    public enum S3Permission: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fullControl
        case read
        case readAcp
        case write
        case writeAcp
        case sdkUnknown(Swift.String)

        public static var allCases: [S3Permission] {
            return [
                .fullControl,
                .read,
                .readAcp,
                .write,
                .writeAcp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fullControl: return "FULL_CONTROL"
            case .read: return "READ"
            case .readAcp: return "READ_ACP"
            case .write: return "WRITE"
            case .writeAcp: return "WRITE_ACP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3Permission(rawValue: rawValue) ?? S3Permission.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.S3ReplicateObjectOperation: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension S3ControlClientTypes {
    /// Directs the specified job to invoke ReplicateObject on every object in the job's manifest.
    public struct S3ReplicateObjectOperation: Swift.Equatable {

        public init() { }
    }

}

extension S3ControlClientTypes.S3Retention: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mode = "Mode"
        case retainUntilDate = "RetainUntilDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let mode = mode {
            try container.encode(mode, forKey: ClientRuntime.Key("Mode"))
        }
        if let retainUntilDate = retainUntilDate {
            try container.encodeTimestamp(retainUntilDate, format: .dateTime, forKey: ClientRuntime.Key("RetainUntilDate"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retainUntilDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .retainUntilDate)
        retainUntilDate = retainUntilDateDecoded
        let modeDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3ObjectLockRetentionMode.self, forKey: .mode)
        mode = modeDecoded
    }
}

extension S3ControlClientTypes.S3Retention: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// Contains the S3 Object Lock retention mode to be applied to all objects in the S3 Batch Operations job. If you don't provide Mode and RetainUntilDate data types in your operation, you will remove the retention from your objects. For more information, see [Using S3 Object Lock retention with S3 Batch Operations](https://docs.aws.amazon.com/AmazonS3/latest/dev/batch-ops-retention-date.html) in the Amazon S3 User Guide.
    public struct S3Retention: Swift.Equatable {
        /// The Object Lock retention mode to be applied to all objects in the Batch Operations job.
        public var mode: S3ControlClientTypes.S3ObjectLockRetentionMode?
        /// The date when the applied Object Lock retention will expire on all objects set by the Batch Operations job.
        public var retainUntilDate: ClientRuntime.Date?

        public init(
            mode: S3ControlClientTypes.S3ObjectLockRetentionMode? = nil,
            retainUntilDate: ClientRuntime.Date? = nil
        )
        {
            self.mode = mode
            self.retainUntilDate = retainUntilDate
        }
    }

}

extension S3ControlClientTypes {
    public enum S3SSEAlgorithm: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aes256
        case kms
        case sdkUnknown(Swift.String)

        public static var allCases: [S3SSEAlgorithm] {
            return [
                .aes256,
                .kms,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aes256: return "AES256"
            case .kms: return "KMS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3SSEAlgorithm(rawValue: rawValue) ?? S3SSEAlgorithm.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.S3SetObjectAclOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessControlPolicy = "AccessControlPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let accessControlPolicy = accessControlPolicy {
            try container.encode(accessControlPolicy, forKey: ClientRuntime.Key("AccessControlPolicy"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessControlPolicyDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3AccessControlPolicy.self, forKey: .accessControlPolicy)
        accessControlPolicy = accessControlPolicyDecoded
    }
}

extension S3ControlClientTypes.S3SetObjectAclOperation: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// Contains the configuration parameters for a PUT Object ACL operation. S3 Batch Operations passes every object to the underlying PutObjectAcl API operation. For more information about the parameters for this operation, see [PutObjectAcl](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectPUTacl.html).
    public struct S3SetObjectAclOperation: Swift.Equatable {
        ///
        public var accessControlPolicy: S3ControlClientTypes.S3AccessControlPolicy?

        public init(
            accessControlPolicy: S3ControlClientTypes.S3AccessControlPolicy? = nil
        )
        {
            self.accessControlPolicy = accessControlPolicy
        }
    }

}

extension S3ControlClientTypes.S3SetObjectLegalHoldOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case legalHold = "LegalHold"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let legalHold = legalHold {
            try container.encode(legalHold, forKey: ClientRuntime.Key("LegalHold"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let legalHoldDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3ObjectLockLegalHold.self, forKey: .legalHold)
        legalHold = legalHoldDecoded
    }
}

extension S3ControlClientTypes.S3SetObjectLegalHoldOperation: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// Contains the configuration for an S3 Object Lock legal hold operation that an S3 Batch Operations job passes to every object to the underlying PutObjectLegalHold API operation. For more information, see [Using S3 Object Lock legal hold with S3 Batch Operations](https://docs.aws.amazon.com/AmazonS3/latest/dev/batch-ops-legal-hold.html) in the Amazon S3 User Guide.
    public struct S3SetObjectLegalHoldOperation: Swift.Equatable {
        /// Contains the Object Lock legal hold status to be applied to all objects in the Batch Operations job.
        /// This member is required.
        public var legalHold: S3ControlClientTypes.S3ObjectLockLegalHold?

        public init(
            legalHold: S3ControlClientTypes.S3ObjectLockLegalHold? = nil
        )
        {
            self.legalHold = legalHold
        }
    }

}

extension S3ControlClientTypes.S3SetObjectRetentionOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bypassGovernanceRetention = "BypassGovernanceRetention"
        case retention = "Retention"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let bypassGovernanceRetention = bypassGovernanceRetention {
            try container.encode(bypassGovernanceRetention, forKey: ClientRuntime.Key("BypassGovernanceRetention"))
        }
        if let retention = retention {
            try container.encode(retention, forKey: ClientRuntime.Key("Retention"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bypassGovernanceRetentionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .bypassGovernanceRetention) ?? nil
        bypassGovernanceRetention = bypassGovernanceRetentionDecoded
        let retentionDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3Retention.self, forKey: .retention)
        retention = retentionDecoded
    }
}

extension S3ControlClientTypes.S3SetObjectRetentionOperation: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// Contains the configuration parameters for the Object Lock retention action for an S3 Batch Operations job. Batch Operations passes every object to the underlying PutObjectRetention API operation. For more information, see [Using S3 Object Lock retention with S3 Batch Operations](https://docs.aws.amazon.com/AmazonS3/latest/dev/batch-ops-retention-date.html) in the Amazon S3 User Guide.
    public struct S3SetObjectRetentionOperation: Swift.Equatable {
        /// Indicates if the action should be applied to objects in the Batch Operations job even if they have Object Lock  GOVERNANCE type in place.
        public var bypassGovernanceRetention: Swift.Bool?
        /// Contains the Object Lock retention mode to be applied to all objects in the Batch Operations job. For more information, see [Using S3 Object Lock retention with S3 Batch Operations](https://docs.aws.amazon.com/AmazonS3/latest/dev/batch-ops-retention-date.html) in the Amazon S3 User Guide.
        /// This member is required.
        public var retention: S3ControlClientTypes.S3Retention?

        public init(
            bypassGovernanceRetention: Swift.Bool? = nil,
            retention: S3ControlClientTypes.S3Retention? = nil
        )
        {
            self.bypassGovernanceRetention = bypassGovernanceRetention
            self.retention = retention
        }
    }

}

extension S3ControlClientTypes.S3SetObjectTaggingOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagSet = "TagSet"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let tagSet = tagSet {
            var tagSetContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagSet"))
            for s3tag0 in tagSet {
                try tagSetContainer.encode(s3tag0, forKey: ClientRuntime.Key("member"))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.tagSet) {
            struct KeyVal0{struct member{}}
            let tagSetWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tagSet)
            if let tagSetWrappedContainer = tagSetWrappedContainer {
                let tagSetContainer = try tagSetWrappedContainer.decodeIfPresent([S3ControlClientTypes.S3Tag].self, forKey: .member)
                var tagSetBuffer:[S3ControlClientTypes.S3Tag]? = nil
                if let tagSetContainer = tagSetContainer {
                    tagSetBuffer = [S3ControlClientTypes.S3Tag]()
                    for structureContainer0 in tagSetContainer {
                        tagSetBuffer?.append(structureContainer0)
                    }
                }
                tagSet = tagSetBuffer
            } else {
                tagSet = []
            }
        } else {
            tagSet = nil
        }
    }
}

extension S3ControlClientTypes.S3SetObjectTaggingOperation: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// Contains the configuration parameters for a PUT Object Tagging operation. S3 Batch Operations passes every object to the underlying PutObjectTagging API operation. For more information about the parameters for this operation, see [PutObjectTagging](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectPUTtagging.html).
    public struct S3SetObjectTaggingOperation: Swift.Equatable {
        ///
        public var tagSet: [S3ControlClientTypes.S3Tag]?

        public init(
            tagSet: [S3ControlClientTypes.S3Tag]? = nil
        )
        {
            self.tagSet = tagSet
        }
    }

}

extension S3ControlClientTypes {
    public enum S3StorageClass: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deepArchive
        case glacier
        case glacierIr
        case intelligentTiering
        case onezoneIa
        case standard
        case standardIa
        case sdkUnknown(Swift.String)

        public static var allCases: [S3StorageClass] {
            return [
                .deepArchive,
                .glacier,
                .glacierIr,
                .intelligentTiering,
                .onezoneIa,
                .standard,
                .standardIa,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deepArchive: return "DEEP_ARCHIVE"
            case .glacier: return "GLACIER"
            case .glacierIr: return "GLACIER_IR"
            case .intelligentTiering: return "INTELLIGENT_TIERING"
            case .onezoneIa: return "ONEZONE_IA"
            case .standard: return "STANDARD"
            case .standardIa: return "STANDARD_IA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3StorageClass(rawValue: rawValue) ?? S3StorageClass.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.S3Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let key = key {
            try container.encode(key, forKey: ClientRuntime.Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: ClientRuntime.Key("Value"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension S3ControlClientTypes.S3Tag: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// A container for a key-value name pair.
    public struct S3Tag: Swift.Equatable {
        /// Key of the tag
        /// This member is required.
        public var key: Swift.String?
        /// Value of the tag
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension S3ControlClientTypes.SSEKMS: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyId = "KeyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let keyId = keyId {
            try container.encode(keyId, forKey: ClientRuntime.Key("KeyId"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyId)
        keyId = keyIdDecoded
    }
}

extension S3ControlClientTypes.SSEKMS: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    ///
    public struct SSEKMS: Swift.Equatable {
        /// A container for the ARN of the SSE-KMS encryption. This property is read-only and follows the following format:  arn:aws:kms:us-east-1:example-account-id:key/example-9a73-4afc-8d29-8f5900cef44e
        /// This member is required.
        public var keyId: Swift.String?

        public init(
            keyId: Swift.String? = nil
        )
        {
            self.keyId = keyId
        }
    }

}

extension S3ControlClientTypes.SSEKMSEncryption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyId = "KeyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let keyId = keyId {
            try container.encode(keyId, forKey: ClientRuntime.Key("KeyId"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyId)
        keyId = keyIdDecoded
    }
}

extension S3ControlClientTypes.SSEKMSEncryption: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// Configuration for the use of SSE-KMS to encrypt generated manifest objects.
    public struct SSEKMSEncryption: Swift.Equatable {
        /// Specifies the ID of the Amazon Web Services Key Management Service (Amazon Web Services KMS) symmetric encryption customer managed key to use for encrypting generated manifest objects.
        /// This member is required.
        public var keyId: Swift.String?

        public init(
            keyId: Swift.String? = nil
        )
        {
            self.keyId = keyId
        }
    }

}

extension S3ControlClientTypes.SSES3: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension S3ControlClientTypes {
    ///
    public struct SSES3: Swift.Equatable {

        public init() { }
    }

}

extension S3ControlClientTypes.SSES3Encryption: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension S3ControlClientTypes {
    /// Configuration for the use of SSE-S3 to encrypt generated manifest objects.
    public struct SSES3Encryption: Swift.Equatable {

        public init() { }
    }

}

extension S3ControlClientTypes.SelectionCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delimiter = "Delimiter"
        case maxDepth = "MaxDepth"
        case minStorageBytesPercentage = "MinStorageBytesPercentage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let delimiter = delimiter {
            try container.encode(delimiter, forKey: ClientRuntime.Key("Delimiter"))
        }
        if maxDepth != 0 {
            try container.encode(maxDepth, forKey: ClientRuntime.Key("MaxDepth"))
        }
        if minStorageBytesPercentage != 0.0 {
            try container.encode(minStorageBytesPercentage, forKey: ClientRuntime.Key("MinStorageBytesPercentage"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let delimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .delimiter)
        delimiter = delimiterDecoded
        let maxDepthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxDepth) ?? 0
        maxDepth = maxDepthDecoded
        let minStorageBytesPercentageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .minStorageBytesPercentage) ?? 0
        minStorageBytesPercentage = minStorageBytesPercentageDecoded
    }
}

extension S3ControlClientTypes.SelectionCriteria: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    ///
    public struct SelectionCriteria: Swift.Equatable {
        /// A container for the delimiter of the selection criteria being used.
        public var delimiter: Swift.String?
        /// The max depth of the selection criteria
        public var maxDepth: Swift.Int
        /// The minimum number of storage bytes percentage whose metrics will be selected. You must choose a value greater than or equal to 1.0.
        public var minStorageBytesPercentage: Swift.Double

        public init(
            delimiter: Swift.String? = nil,
            maxDepth: Swift.Int = 0,
            minStorageBytesPercentage: Swift.Double = 0.0
        )
        {
            self.delimiter = delimiter
            self.maxDepth = maxDepth
            self.minStorageBytesPercentage = minStorageBytesPercentage
        }
    }

}

extension S3ControlClientTypes.SourceSelectionCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicaModifications = "ReplicaModifications"
        case sseKmsEncryptedObjects = "SseKmsEncryptedObjects"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let replicaModifications = replicaModifications {
            try container.encode(replicaModifications, forKey: ClientRuntime.Key("ReplicaModifications"))
        }
        if let sseKmsEncryptedObjects = sseKmsEncryptedObjects {
            try container.encode(sseKmsEncryptedObjects, forKey: ClientRuntime.Key("SseKmsEncryptedObjects"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sseKmsEncryptedObjectsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.SseKmsEncryptedObjects.self, forKey: .sseKmsEncryptedObjects)
        sseKmsEncryptedObjects = sseKmsEncryptedObjectsDecoded
        let replicaModificationsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.ReplicaModifications.self, forKey: .replicaModifications)
        replicaModifications = replicaModificationsDecoded
    }
}

extension S3ControlClientTypes.SourceSelectionCriteria: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// A container that describes additional filters for identifying the source objects that you want to replicate. You can choose to enable or disable the replication of these objects.
    public struct SourceSelectionCriteria: Swift.Equatable {
        /// A filter that you can use to specify whether replica modification sync is enabled. S3 on Outposts replica modification sync can help you keep object metadata synchronized between replicas and source objects. By default, S3 on Outposts replicates metadata from the source objects to the replicas only. When replica modification sync is enabled, S3 on Outposts replicates metadata changes made to the replica copies back to the source object, making the replication bidirectional. To replicate object metadata modifications on replicas, you can specify this element and set the Status of this element to Enabled. You must enable replica modification sync on the source and destination buckets to replicate replica metadata changes between the source and the replicas.
        public var replicaModifications: S3ControlClientTypes.ReplicaModifications?
        /// A filter that you can use to select Amazon S3 objects that are encrypted with server-side encryption by using Key Management Service (KMS) keys. If you include SourceSelectionCriteria in the replication configuration, this element is required. This is not supported by Amazon S3 on Outposts buckets.
        public var sseKmsEncryptedObjects: S3ControlClientTypes.SseKmsEncryptedObjects?

        public init(
            replicaModifications: S3ControlClientTypes.ReplicaModifications? = nil,
            sseKmsEncryptedObjects: S3ControlClientTypes.SseKmsEncryptedObjects? = nil
        )
        {
            self.replicaModifications = replicaModifications
            self.sseKmsEncryptedObjects = sseKmsEncryptedObjects
        }
    }

}

extension S3ControlClientTypes.SseKmsEncryptedObjects: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.SseKmsEncryptedObjectsStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension S3ControlClientTypes.SseKmsEncryptedObjects: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// A container for filter information that you can use to select S3 objects that are encrypted with Key Management Service (KMS). This is not supported by Amazon S3 on Outposts buckets.
    public struct SseKmsEncryptedObjects: Swift.Equatable {
        /// Specifies whether Amazon S3 replicates objects that are created with server-side encryption by using an KMS key stored in Key Management Service.
        /// This member is required.
        public var status: S3ControlClientTypes.SseKmsEncryptedObjectsStatus?

        public init(
            status: S3ControlClientTypes.SseKmsEncryptedObjectsStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension S3ControlClientTypes {
    public enum SseKmsEncryptedObjectsStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [SseKmsEncryptedObjectsStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SseKmsEncryptedObjectsStatus(rawValue: rawValue) ?? SseKmsEncryptedObjectsStatus.sdkUnknown(rawValue)
        }
    }
}

extension S3ControlClientTypes.StorageLensAwsOrg: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension S3ControlClientTypes.StorageLensAwsOrg: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// The Amazon Web Services organization for your S3 Storage Lens.
    public struct StorageLensAwsOrg: Swift.Equatable {
        /// A container for the Amazon Resource Name (ARN) of the Amazon Web Services organization. This property is read-only and follows the following format:  arn:aws:organizations:us-east-1:example-account-id:organization/o-ex2l495dck
        /// This member is required.
        public var arn: Swift.String?

        public init(
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension S3ControlClientTypes.StorageLensConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountLevel = "AccountLevel"
        case awsOrg = "AwsOrg"
        case dataExport = "DataExport"
        case exclude = "Exclude"
        case id = "Id"
        case include = "Include"
        case isEnabled = "IsEnabled"
        case storageLensArn = "StorageLensArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let accountLevel = accountLevel {
            try container.encode(accountLevel, forKey: ClientRuntime.Key("AccountLevel"))
        }
        if let awsOrg = awsOrg {
            try container.encode(awsOrg, forKey: ClientRuntime.Key("AwsOrg"))
        }
        if let dataExport = dataExport {
            try container.encode(dataExport, forKey: ClientRuntime.Key("DataExport"))
        }
        if let exclude = exclude {
            try container.encode(exclude, forKey: ClientRuntime.Key("Exclude"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let include = include {
            try container.encode(include, forKey: ClientRuntime.Key("Include"))
        }
        if isEnabled != false {
            try container.encode(isEnabled, forKey: ClientRuntime.Key("IsEnabled"))
        }
        if let storageLensArn = storageLensArn {
            try container.encode(storageLensArn, forKey: ClientRuntime.Key("StorageLensArn"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let accountLevelDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.AccountLevel.self, forKey: .accountLevel)
        accountLevel = accountLevelDecoded
        let includeDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.Include.self, forKey: .include)
        include = includeDecoded
        let excludeDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.Exclude.self, forKey: .exclude)
        exclude = excludeDecoded
        let dataExportDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.StorageLensDataExport.self, forKey: .dataExport)
        dataExport = dataExportDecoded
        let isEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isEnabled) ?? false
        isEnabled = isEnabledDecoded
        let awsOrgDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.StorageLensAwsOrg.self, forKey: .awsOrg)
        awsOrg = awsOrgDecoded
        let storageLensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageLensArn)
        storageLensArn = storageLensArnDecoded
    }
}

extension S3ControlClientTypes.StorageLensConfiguration: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// A container for the Amazon S3 Storage Lens configuration.
    public struct StorageLensConfiguration: Swift.Equatable {
        /// A container for all the account-level configurations of your S3 Storage Lens configuration.
        /// This member is required.
        public var accountLevel: S3ControlClientTypes.AccountLevel?
        /// A container for the Amazon Web Services organization for this S3 Storage Lens configuration.
        public var awsOrg: S3ControlClientTypes.StorageLensAwsOrg?
        /// A container to specify the properties of your S3 Storage Lens metrics export including, the destination, schema and format.
        public var dataExport: S3ControlClientTypes.StorageLensDataExport?
        /// A container for what is excluded in this configuration. This container can only be valid if there is no Include container submitted, and it's not empty.
        public var exclude: S3ControlClientTypes.Exclude?
        /// A container for the Amazon S3 Storage Lens configuration ID.
        /// This member is required.
        public var id: Swift.String?
        /// A container for what is included in this configuration. This container can only be valid if there is no Exclude container submitted, and it's not empty.
        public var include: S3ControlClientTypes.Include?
        /// A container for whether the S3 Storage Lens configuration is enabled.
        /// This member is required.
        public var isEnabled: Swift.Bool
        /// The Amazon Resource Name (ARN) of the S3 Storage Lens configuration. This property is read-only and follows the following format:  arn:aws:s3:us-east-1:example-account-id:storage-lens/your-dashboard-name
        public var storageLensArn: Swift.String?

        public init(
            accountLevel: S3ControlClientTypes.AccountLevel? = nil,
            awsOrg: S3ControlClientTypes.StorageLensAwsOrg? = nil,
            dataExport: S3ControlClientTypes.StorageLensDataExport? = nil,
            exclude: S3ControlClientTypes.Exclude? = nil,
            id: Swift.String? = nil,
            include: S3ControlClientTypes.Include? = nil,
            isEnabled: Swift.Bool = false,
            storageLensArn: Swift.String? = nil
        )
        {
            self.accountLevel = accountLevel
            self.awsOrg = awsOrg
            self.dataExport = dataExport
            self.exclude = exclude
            self.id = id
            self.include = include
            self.isEnabled = isEnabled
            self.storageLensArn = storageLensArn
        }
    }

}

extension S3ControlClientTypes.StorageLensDataExport: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchMetrics = "CloudWatchMetrics"
        case s3BucketDestination = "S3BucketDestination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cloudWatchMetrics = cloudWatchMetrics {
            try container.encode(cloudWatchMetrics, forKey: ClientRuntime.Key("CloudWatchMetrics"))
        }
        if let s3BucketDestination = s3BucketDestination {
            try container.encode(s3BucketDestination, forKey: ClientRuntime.Key("S3BucketDestination"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDestinationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3BucketDestination.self, forKey: .s3BucketDestination)
        s3BucketDestination = s3BucketDestinationDecoded
        let cloudWatchMetricsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.CloudWatchMetrics.self, forKey: .cloudWatchMetrics)
        cloudWatchMetrics = cloudWatchMetricsDecoded
    }
}

extension S3ControlClientTypes.StorageLensDataExport: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// A container to specify the properties of your S3 Storage Lens metrics export, including the destination, schema, and format.
    public struct StorageLensDataExport: Swift.Equatable {
        /// A container for enabling Amazon CloudWatch publishing for S3 Storage Lens metrics.
        public var cloudWatchMetrics: S3ControlClientTypes.CloudWatchMetrics?
        /// A container for the bucket where the S3 Storage Lens metrics export will be located. This bucket must be located in the same Region as the storage lens configuration.
        public var s3BucketDestination: S3ControlClientTypes.S3BucketDestination?

        public init(
            cloudWatchMetrics: S3ControlClientTypes.CloudWatchMetrics? = nil,
            s3BucketDestination: S3ControlClientTypes.S3BucketDestination? = nil
        )
        {
            self.cloudWatchMetrics = cloudWatchMetrics
            self.s3BucketDestination = s3BucketDestination
        }
    }

}

extension S3ControlClientTypes.StorageLensDataExportEncryption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ssekms = "SSE-KMS"
        case sses3 = "SSE-S3"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let ssekms = ssekms {
            try container.encode(ssekms, forKey: ClientRuntime.Key("SSE-KMS"))
        }
        if let sses3 = sses3 {
            try container.encode(sses3, forKey: ClientRuntime.Key("SSE-S3"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sses3Decoded = try containerValues.decodeIfPresent(S3ControlClientTypes.SSES3.self, forKey: .sses3)
        sses3 = sses3Decoded
        let ssekmsDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.SSEKMS.self, forKey: .ssekms)
        ssekms = ssekmsDecoded
    }
}

extension S3ControlClientTypes.StorageLensDataExportEncryption: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// A container for the encryption of the S3 Storage Lens metrics exports.
    public struct StorageLensDataExportEncryption: Swift.Equatable {
        ///
        public var ssekms: S3ControlClientTypes.SSEKMS?
        ///
        public var sses3: S3ControlClientTypes.SSES3?

        public init(
            ssekms: S3ControlClientTypes.SSEKMS? = nil,
            sses3: S3ControlClientTypes.SSES3? = nil
        )
        {
            self.ssekms = ssekms
            self.sses3 = sses3
        }
    }

}

extension S3ControlClientTypes.StorageLensTag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let key = key {
            try container.encode(key, forKey: ClientRuntime.Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: ClientRuntime.Key("Value"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension S3ControlClientTypes.StorageLensTag: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    ///
    public struct StorageLensTag: Swift.Equatable {
        ///
        /// This member is required.
        public var key: Swift.String?
        ///
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension SubmitMultiRegionAccessPointRoutesInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension SubmitMultiRegionAccessPointRoutesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case routeUpdates = "RouteUpdates"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let routeUpdates = routeUpdates {
            var routeUpdatesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("RouteUpdates"))
            for multiregionaccesspointroute0 in routeUpdates {
                try routeUpdatesContainer.encode(multiregionaccesspointroute0, forKey: ClientRuntime.Key("Route"))
            }
        }
    }
}

extension SubmitMultiRegionAccessPointRoutesInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension SubmitMultiRegionAccessPointRoutesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let mrap = mrap else {
            return nil
        }
        return "/v20180820/mrap/instances/\(mrap.urlPercentEncoding(encodeForwardSlash: false))/routes"
    }
}

public struct SubmitMultiRegionAccessPointRoutesInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the owner of the Multi-Region Access Point.
    /// This member is required.
    public var accountId: Swift.String?
    /// The Multi-Region Access Point ARN.
    /// This member is required.
    public var mrap: Swift.String?
    /// The different routes that make up the new route configuration. Active routes return a value of 100, and passive routes return a value of 0.
    /// This member is required.
    public var routeUpdates: [S3ControlClientTypes.MultiRegionAccessPointRoute]?

    public init(
        accountId: Swift.String? = nil,
        mrap: Swift.String? = nil,
        routeUpdates: [S3ControlClientTypes.MultiRegionAccessPointRoute]? = nil
    )
    {
        self.accountId = accountId
        self.mrap = mrap
        self.routeUpdates = routeUpdates
    }
}

struct SubmitMultiRegionAccessPointRoutesInputBody: Swift.Equatable {
    let routeUpdates: [S3ControlClientTypes.MultiRegionAccessPointRoute]?
}

extension SubmitMultiRegionAccessPointRoutesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case routeUpdates = "RouteUpdates"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.routeUpdates) {
            struct KeyVal0{struct Route{}}
            let routeUpdatesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Route>.CodingKeys.self, forKey: .routeUpdates)
            if let routeUpdatesWrappedContainer = routeUpdatesWrappedContainer {
                let routeUpdatesContainer = try routeUpdatesWrappedContainer.decodeIfPresent([S3ControlClientTypes.MultiRegionAccessPointRoute].self, forKey: .member)
                var routeUpdatesBuffer:[S3ControlClientTypes.MultiRegionAccessPointRoute]? = nil
                if let routeUpdatesContainer = routeUpdatesContainer {
                    routeUpdatesBuffer = [S3ControlClientTypes.MultiRegionAccessPointRoute]()
                    for structureContainer0 in routeUpdatesContainer {
                        routeUpdatesBuffer?.append(structureContainer0)
                    }
                }
                routeUpdates = routeUpdatesBuffer
            } else {
                routeUpdates = []
            }
        } else {
            routeUpdates = nil
        }
    }
}

extension SubmitMultiRegionAccessPointRoutesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct SubmitMultiRegionAccessPointRoutesOutput: Swift.Equatable {

    public init() { }
}

enum SubmitMultiRegionAccessPointRoutesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension S3ControlClientTypes.Tagging: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagSet = "TagSet"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let tagSet = tagSet {
            var tagSetContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagSet"))
            for s3tag0 in tagSet {
                try tagSetContainer.encode(s3tag0, forKey: ClientRuntime.Key("member"))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.tagSet) {
            struct KeyVal0{struct member{}}
            let tagSetWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tagSet)
            if let tagSetWrappedContainer = tagSetWrappedContainer {
                let tagSetContainer = try tagSetWrappedContainer.decodeIfPresent([S3ControlClientTypes.S3Tag].self, forKey: .member)
                var tagSetBuffer:[S3ControlClientTypes.S3Tag]? = nil
                if let tagSetContainer = tagSetContainer {
                    tagSetBuffer = [S3ControlClientTypes.S3Tag]()
                    for structureContainer0 in tagSetContainer {
                        tagSetBuffer?.append(structureContainer0)
                    }
                }
                tagSet = tagSetBuffer
            } else {
                tagSet = []
            }
        } else {
            tagSet = nil
        }
    }
}

extension S3ControlClientTypes.Tagging: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    ///
    public struct Tagging: Swift.Equatable {
        /// A collection for a set of tags.
        /// This member is required.
        public var tagSet: [S3ControlClientTypes.S3Tag]?

        public init(
            tagSet: [S3ControlClientTypes.S3Tag]? = nil
        )
        {
            self.tagSet = tagSet
        }
    }

}

extension TooManyRequestsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyRequestsExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyTagsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyTagsExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Amazon S3 throws this exception if you have too many tags in your tag set.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension S3ControlClientTypes.Transition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case date = "Date"
        case days = "Days"
        case storageClass = "StorageClass"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let date = date {
            try container.encodeTimestamp(date, format: .dateTime, forKey: ClientRuntime.Key("Date"))
        }
        if days != 0 {
            try container.encode(days, forKey: ClientRuntime.Key("Days"))
        }
        if let storageClass = storageClass {
            try container.encode(storageClass, forKey: ClientRuntime.Key("StorageClass"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .date)
        date = dateDecoded
        let daysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .days) ?? 0
        days = daysDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.TransitionStorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
    }
}

extension S3ControlClientTypes.Transition: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// Specifies when an object transitions to a specified storage class. For more information about Amazon S3 Lifecycle configuration rules, see [ Transitioning objects using Amazon S3 Lifecycle](https://docs.aws.amazon.com/AmazonS3/latest/dev/lifecycle-transition-general-considerations.html) in the Amazon S3 User Guide.
    public struct Transition: Swift.Equatable {
        /// Indicates when objects are transitioned to the specified storage class. The date value must be in ISO 8601 format. The time is always midnight UTC.
        public var date: ClientRuntime.Date?
        /// Indicates the number of days after creation when objects are transitioned to the specified storage class. The value must be a positive integer.
        public var days: Swift.Int
        /// The storage class to which you want the object to transition.
        public var storageClass: S3ControlClientTypes.TransitionStorageClass?

        public init(
            date: ClientRuntime.Date? = nil,
            days: Swift.Int = 0,
            storageClass: S3ControlClientTypes.TransitionStorageClass? = nil
        )
        {
            self.date = date
            self.days = days
            self.storageClass = storageClass
        }
    }

}

extension S3ControlClientTypes {
    public enum TransitionStorageClass: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deepArchive
        case glacier
        case intelligentTiering
        case onezoneIa
        case standardIa
        case sdkUnknown(Swift.String)

        public static var allCases: [TransitionStorageClass] {
            return [
                .deepArchive,
                .glacier,
                .intelligentTiering,
                .onezoneIa,
                .standardIa,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deepArchive: return "DEEP_ARCHIVE"
            case .glacier: return "GLACIER"
            case .intelligentTiering: return "INTELLIGENT_TIERING"
            case .onezoneIa: return "ONEZONE_IA"
            case .standardIa: return "STANDARD_IA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TransitionStorageClass(rawValue: rawValue) ?? TransitionStorageClass.sdkUnknown(rawValue)
        }
    }
}

extension UpdateJobPriorityInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension UpdateJobPriorityInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let priority = priority else {
                let message = "Creating a URL Query Item failed. priority is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let priorityQueryItem = ClientRuntime.URLQueryItem(name: "priority".urlPercentEncoding(), value: Swift.String(priority).urlPercentEncoding())
            items.append(priorityQueryItem)
            return items
        }
    }
}

extension UpdateJobPriorityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/v20180820/jobs/\(jobId.urlPercentEncoding())/priority"
    }
}

public struct UpdateJobPriorityInput: Swift.Equatable {
    /// The Amazon Web Services account ID associated with the S3 Batch Operations job.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID for the job whose priority you want to update.
    /// This member is required.
    public var jobId: Swift.String?
    /// The priority you want to assign to this job.
    /// This member is required.
    public var priority: Swift.Int?

    public init(
        accountId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        priority: Swift.Int? = nil
    )
    {
        self.accountId = accountId
        self.jobId = jobId
        self.priority = priority
    }
}

struct UpdateJobPriorityInputBody: Swift.Equatable {
}

extension UpdateJobPriorityInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UpdateJobPriorityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateJobPriorityOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
            self.priority = output.priority
        } else {
            self.jobId = nil
            self.priority = 0
        }
    }
}

public struct UpdateJobPriorityOutput: Swift.Equatable {
    /// The ID for the job whose priority Amazon S3 updated.
    /// This member is required.
    public var jobId: Swift.String?
    /// The new priority assigned to the specified job.
    /// This member is required.
    public var priority: Swift.Int

    public init(
        jobId: Swift.String? = nil,
        priority: Swift.Int = 0
    )
    {
        self.jobId = jobId
        self.priority = priority
    }
}

struct UpdateJobPriorityOutputBody: Swift.Equatable {
    let jobId: Swift.String?
    let priority: Swift.Int
}

extension UpdateJobPriorityOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
        case priority = "Priority"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority) ?? 0
        priority = priorityDecoded
    }
}

enum UpdateJobPriorityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension UpdateJobStatusInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accountId = accountId {
            items.add(Header(name: "x-amz-account-id", value: Swift.String(accountId)))
        }
        return items
    }
}

extension UpdateJobStatusInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let statusUpdateReason = statusUpdateReason {
                let statusUpdateReasonQueryItem = ClientRuntime.URLQueryItem(name: "statusUpdateReason".urlPercentEncoding(), value: Swift.String(statusUpdateReason).urlPercentEncoding())
                items.append(statusUpdateReasonQueryItem)
            }
            guard let requestedJobStatus = requestedJobStatus else {
                let message = "Creating a URL Query Item failed. requestedJobStatus is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let requestedJobStatusQueryItem = ClientRuntime.URLQueryItem(name: "requestedJobStatus".urlPercentEncoding(), value: Swift.String(requestedJobStatus.rawValue).urlPercentEncoding())
            items.append(requestedJobStatusQueryItem)
            return items
        }
    }
}

extension UpdateJobStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/v20180820/jobs/\(jobId.urlPercentEncoding())/status"
    }
}

public struct UpdateJobStatusInput: Swift.Equatable {
    /// The Amazon Web Services account ID associated with the S3 Batch Operations job.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ID of the job whose status you want to update.
    /// This member is required.
    public var jobId: Swift.String?
    /// The status that you want to move the specified job to.
    /// This member is required.
    public var requestedJobStatus: S3ControlClientTypes.RequestedJobStatus?
    /// A description of the reason why you want to change the specified job's status. This field can be any string up to the maximum length.
    public var statusUpdateReason: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        requestedJobStatus: S3ControlClientTypes.RequestedJobStatus? = nil,
        statusUpdateReason: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.jobId = jobId
        self.requestedJobStatus = requestedJobStatus
        self.statusUpdateReason = statusUpdateReason
    }
}

struct UpdateJobStatusInputBody: Swift.Equatable {
}

extension UpdateJobStatusInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UpdateJobStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateJobStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
            self.status = output.status
            self.statusUpdateReason = output.statusUpdateReason
        } else {
            self.jobId = nil
            self.status = nil
            self.statusUpdateReason = nil
        }
    }
}

public struct UpdateJobStatusOutput: Swift.Equatable {
    /// The ID for the job whose status was updated.
    public var jobId: Swift.String?
    /// The current status for the specified job.
    public var status: S3ControlClientTypes.JobStatus?
    /// The reason that the specified job's status was updated.
    public var statusUpdateReason: Swift.String?

    public init(
        jobId: Swift.String? = nil,
        status: S3ControlClientTypes.JobStatus? = nil,
        statusUpdateReason: Swift.String? = nil
    )
    {
        self.jobId = jobId
        self.status = status
        self.statusUpdateReason = statusUpdateReason
    }
}

struct UpdateJobStatusOutputBody: Swift.Equatable {
    let jobId: Swift.String?
    let status: S3ControlClientTypes.JobStatus?
    let statusUpdateReason: Swift.String?
}

extension UpdateJobStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
        case status = "Status"
        case statusUpdateReason = "StatusUpdateReason"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
        let statusUpdateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusUpdateReason)
        statusUpdateReason = statusUpdateReasonDecoded
    }
}

enum UpdateJobStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "JobStatusException": return try await JobStatusException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension S3ControlClientTypes.VersioningConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mfaDelete = "MfaDelete"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let mfaDelete = mfaDelete {
            try container.encode(mfaDelete, forKey: ClientRuntime.Key("MfaDelete"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mfaDeleteDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.MFADelete.self, forKey: .mfaDelete)
        mfaDelete = mfaDeleteDecoded
        let statusDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.BucketVersioningStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension S3ControlClientTypes.VersioningConfiguration: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// Describes the versioning state of an Amazon S3 on Outposts bucket. For more information, see [PutBucketVersioning](https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_PutBucketVersioning.html).
    public struct VersioningConfiguration: Swift.Equatable {
        /// Specifies whether MFA delete is enabled or disabled in the bucket versioning configuration for the S3 on Outposts bucket.
        public var mfaDelete: S3ControlClientTypes.MFADelete?
        /// Sets the versioning state of the S3 on Outposts bucket.
        public var status: S3ControlClientTypes.BucketVersioningStatus?

        public init(
            mfaDelete: S3ControlClientTypes.MFADelete? = nil,
            status: S3ControlClientTypes.BucketVersioningStatus? = nil
        )
        {
            self.mfaDelete = mfaDelete
            self.status = status
        }
    }

}

extension S3ControlClientTypes.VpcConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: ClientRuntime.Key("VpcId"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension S3ControlClientTypes.VpcConfiguration: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension S3ControlClientTypes {
    /// The virtual private cloud (VPC) configuration for an access point.
    public struct VpcConfiguration: Swift.Equatable {
        /// If this field is specified, this access point will only allow connections from the specified VPC ID.
        /// This member is required.
        public var vpcId: Swift.String?

        public init(
            vpcId: Swift.String? = nil
        )
        {
            self.vpcId = vpcId
        }
    }

}
