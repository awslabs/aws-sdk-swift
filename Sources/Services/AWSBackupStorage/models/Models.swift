// Code generated by smithy-swift-codegen. DO NOT EDIT!
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import AWSClientRuntime
import ClientRuntime
import SmithyJSON
import SmithyReadWrite

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDenied" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension BackupStorageClientTypes.BackupObject {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupStorageClientTypes.BackupObject {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupStorageClientTypes.BackupObject()
        value.name = try reader["Name"].readIfPresent()
        value.chunksCount = try reader["ChunksCount"].readIfPresent()
        value.metadataString = try reader["MetadataString"].readIfPresent()
        value.objectChecksum = try reader["ObjectChecksum"].readIfPresent()
        value.objectChecksumAlgorithm = try reader["ObjectChecksumAlgorithm"].readIfPresent()
        value.objectToken = try reader["ObjectToken"].readIfPresent()
        return value
    }
}

extension BackupStorageClientTypes {
    /// Object
    public struct BackupObject {
        /// Number of chunks in object
        public var chunksCount: Swift.Int?
        /// Metadata string associated with the Object
        public var metadataString: Swift.String?
        /// Object name
        /// This member is required.
        public var name: Swift.String?
        /// Object checksum
        /// This member is required.
        public var objectChecksum: Swift.String?
        /// Checksum algorithm
        /// This member is required.
        public var objectChecksumAlgorithm: BackupStorageClientTypes.SummaryChecksumAlgorithm?
        /// Object token
        /// This member is required.
        public var objectToken: Swift.String?

        public init(
            chunksCount: Swift.Int? = nil,
            metadataString: Swift.String? = nil,
            name: Swift.String? = nil,
            objectChecksum: Swift.String? = nil,
            objectChecksumAlgorithm: BackupStorageClientTypes.SummaryChecksumAlgorithm? = nil,
            objectToken: Swift.String? = nil
        )
        {
            self.chunksCount = chunksCount
            self.metadataString = metadataString
            self.name = name
            self.objectChecksum = objectChecksum
            self.objectChecksumAlgorithm = objectChecksumAlgorithm
            self.objectToken = objectToken
        }
    }

}

public enum BackupStorageClientTypes {}

extension BackupStorageClientTypes.Chunk {

    static func read(from reader: SmithyJSON.Reader) throws -> BackupStorageClientTypes.Chunk {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BackupStorageClientTypes.Chunk()
        value.index = try reader["Index"].readIfPresent() ?? 0
        value.length = try reader["Length"].readIfPresent() ?? 0
        value.checksum = try reader["Checksum"].readIfPresent()
        value.checksumAlgorithm = try reader["ChecksumAlgorithm"].readIfPresent()
        value.chunkToken = try reader["ChunkToken"].readIfPresent()
        return value
    }
}

extension BackupStorageClientTypes {
    /// Chunk
    public struct Chunk {
        /// Chunk checksum
        /// This member is required.
        public var checksum: Swift.String?
        /// Checksum algorithm
        /// This member is required.
        public var checksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm?
        /// Chunk token
        /// This member is required.
        public var chunkToken: Swift.String?
        /// Chunk index
        /// This member is required.
        public var index: Swift.Int
        /// Chunk length
        /// This member is required.
        public var length: Swift.Int

        public init(
            checksum: Swift.String? = nil,
            checksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm? = nil,
            chunkToken: Swift.String? = nil,
            index: Swift.Int = 0,
            length: Swift.Int = 0
        )
        {
            self.checksum = checksum
            self.checksumAlgorithm = checksumAlgorithm
            self.chunkToken = chunkToken
            self.index = index
            self.length = length
        }
    }

}

extension DataAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> DataAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = DataAlreadyExistsException()
        value.properties.checksum = try reader["Checksum"].readIfPresent()
        value.properties.checksumAlgorithm = try reader["ChecksumAlgorithm"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// Non-retryable exception. Attempted to create already existing object or chunk. This message contains a checksum of already presented data.
public struct DataAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Data checksum used
        public internal(set) var checksum: Swift.String? = nil
        /// Checksum algorithm used
        public internal(set) var checksumAlgorithm: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DataAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        checksum: Swift.String? = nil,
        checksumAlgorithm: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.checksum = checksum
        self.properties.checksumAlgorithm = checksumAlgorithm
        self.properties.message = message
    }
}

extension BackupStorageClientTypes {

    public enum DataChecksumAlgorithm: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case sha256
        case sdkUnknown(Swift.String)

        public static var allCases: [DataChecksumAlgorithm] {
            return [
                .sha256,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .sha256: return "SHA256"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeleteObjectInput {

    static func urlPathProvider(_ value: DeleteObjectInput) -> Swift.String? {
        guard let backupJobId = value.backupJobId else {
            return nil
        }
        guard let objectName = value.objectName else {
            return nil
        }
        return "/backup-jobs/\(backupJobId.urlPercentEncoding())/object/\(objectName.urlPercentEncoding())"
    }
}

public struct DeleteObjectInput {
    /// Backup job Id for the in-progress backup.
    /// This member is required.
    public var backupJobId: Swift.String?
    /// The name of the Object.
    /// This member is required.
    public var objectName: Swift.String?

    public init(
        backupJobId: Swift.String? = nil,
        objectName: Swift.String? = nil
    )
    {
        self.backupJobId = backupJobId
        self.objectName = objectName
    }
}

extension DeleteObjectOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteObjectOutput {
        return DeleteObjectOutput()
    }
}

public struct DeleteObjectOutput {

    public init() { }
}

enum DeleteObjectOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableException": return try RetryableException.makeError(baseError: baseError)
            case "ServiceInternalException": return try ServiceInternalException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetChunkInput {

    static func urlPathProvider(_ value: GetChunkInput) -> Swift.String? {
        guard let storageJobId = value.storageJobId else {
            return nil
        }
        guard let chunkToken = value.chunkToken else {
            return nil
        }
        return "/restore-jobs/\(storageJobId.urlPercentEncoding())/chunk/\(chunkToken.urlPercentEncoding())"
    }
}

public struct GetChunkInput {
    /// Chunk token
    /// This member is required.
    public var chunkToken: Swift.String?
    /// Storage job id
    /// This member is required.
    public var storageJobId: Swift.String?

    public init(
        chunkToken: Swift.String? = nil,
        storageJobId: Swift.String? = nil
    )
    {
        self.chunkToken = chunkToken
        self.storageJobId = storageJobId
    }
}

extension GetChunkOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetChunkOutput {
        var value = GetChunkOutput()
        if let checksumHeaderValue = httpResponse.headers.value(for: "x-amz-checksum") {
            value.checksum = checksumHeaderValue
        }
        if let checksumAlgorithmHeaderValue = httpResponse.headers.value(for: "x-amz-checksum-algorithm") {
            value.checksumAlgorithm = BackupStorageClientTypes.DataChecksumAlgorithm(rawValue: checksumAlgorithmHeaderValue)
        }
        if let lengthHeaderValue = httpResponse.headers.value(for: "x-amz-data-length") {
            value.length = Swift.Int(lengthHeaderValue) ?? 0
        }
        switch httpResponse.body {
        case .data(let data):
            value.data = .data(data)
        case .stream(let stream):
            value.data = .stream(stream)
        case .noStream:
            value.data = nil
        }
        return value
    }
}

public struct GetChunkOutput {
    /// Data checksum
    /// This member is required.
    public var checksum: Swift.String?
    /// Checksum algorithm
    /// This member is required.
    public var checksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm?
    /// Chunk data
    /// This member is required.
    public var data: ClientRuntime.ByteStream?
    /// Data length
    /// This member is required.
    public var length: Swift.Int

    public init(
        checksum: Swift.String? = nil,
        checksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm? = nil,
        data: ClientRuntime.ByteStream? = nil,
        length: Swift.Int = 0
    )
    {
        self.checksum = checksum
        self.checksumAlgorithm = checksumAlgorithm
        self.data = data
        self.length = length
    }
}

enum GetChunkOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "KMSInvalidKeyUsageException": return try KMSInvalidKeyUsageException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableException": return try RetryableException.makeError(baseError: baseError)
            case "ServiceInternalException": return try ServiceInternalException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetObjectMetadataInput {

    static func urlPathProvider(_ value: GetObjectMetadataInput) -> Swift.String? {
        guard let storageJobId = value.storageJobId else {
            return nil
        }
        guard let objectToken = value.objectToken else {
            return nil
        }
        return "/restore-jobs/\(storageJobId.urlPercentEncoding())/object/\(objectToken.urlPercentEncoding())/metadata"
    }
}

public struct GetObjectMetadataInput {
    /// Object token.
    /// This member is required.
    public var objectToken: Swift.String?
    /// Backup job id for the in-progress backup.
    /// This member is required.
    public var storageJobId: Swift.String?

    public init(
        objectToken: Swift.String? = nil,
        storageJobId: Swift.String? = nil
    )
    {
        self.objectToken = objectToken
        self.storageJobId = storageJobId
    }
}

extension GetObjectMetadataOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetObjectMetadataOutput {
        var value = GetObjectMetadataOutput()
        if let metadataBlobChecksumHeaderValue = httpResponse.headers.value(for: "x-amz-checksum") {
            value.metadataBlobChecksum = metadataBlobChecksumHeaderValue
        }
        if let metadataBlobChecksumAlgorithmHeaderValue = httpResponse.headers.value(for: "x-amz-checksum-algorithm") {
            value.metadataBlobChecksumAlgorithm = BackupStorageClientTypes.DataChecksumAlgorithm(rawValue: metadataBlobChecksumAlgorithmHeaderValue)
        }
        if let metadataBlobLengthHeaderValue = httpResponse.headers.value(for: "x-amz-data-length") {
            value.metadataBlobLength = Swift.Int(metadataBlobLengthHeaderValue) ?? 0
        }
        if let metadataStringHeaderValue = httpResponse.headers.value(for: "x-amz-metadata-string") {
            value.metadataString = metadataStringHeaderValue
        }
        switch httpResponse.body {
        case .data(let data):
            value.metadataBlob = .data(data)
        case .stream(let stream):
            value.metadataBlob = .stream(stream)
        case .noStream:
            value.metadataBlob = nil
        }
        return value
    }
}

public struct GetObjectMetadataOutput {
    /// Metadata blob.
    public var metadataBlob: ClientRuntime.ByteStream?
    /// MetadataBlob checksum.
    public var metadataBlobChecksum: Swift.String?
    /// Checksum algorithm.
    public var metadataBlobChecksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm?
    /// The size of MetadataBlob.
    public var metadataBlobLength: Swift.Int
    /// Metadata string.
    public var metadataString: Swift.String?

    public init(
        metadataBlob: ClientRuntime.ByteStream? = nil,
        metadataBlobChecksum: Swift.String? = nil,
        metadataBlobChecksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm? = nil,
        metadataBlobLength: Swift.Int = 0,
        metadataString: Swift.String? = nil
    )
    {
        self.metadataBlob = metadataBlob
        self.metadataBlobChecksum = metadataBlobChecksum
        self.metadataBlobChecksumAlgorithm = metadataBlobChecksumAlgorithm
        self.metadataBlobLength = metadataBlobLength
        self.metadataString = metadataString
    }
}

enum GetObjectMetadataOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "KMSInvalidKeyUsageException": return try KMSInvalidKeyUsageException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableException": return try RetryableException.makeError(baseError: baseError)
            case "ServiceInternalException": return try ServiceInternalException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension IllegalArgumentException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> IllegalArgumentException {
        let reader = baseError.errorBodyReader
        var value = IllegalArgumentException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// Non-retryable exception, indicates client error (wrong argument passed to API). See exception message for details.
public struct IllegalArgumentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IllegalArgumentException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension KMSInvalidKeyUsageException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> KMSInvalidKeyUsageException {
        let reader = baseError.errorBodyReader
        var value = KMSInvalidKeyUsageException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// Non-retryable exception. Indicates the KMS key usage is incorrect. See exception message for details.
public struct KMSInvalidKeyUsageException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSInvalidKeyUsageException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ListChunksInput {

    static func queryItemProvider(_ value: ListChunksInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListChunksInput {

    static func urlPathProvider(_ value: ListChunksInput) -> Swift.String? {
        guard let storageJobId = value.storageJobId else {
            return nil
        }
        guard let objectToken = value.objectToken else {
            return nil
        }
        return "/restore-jobs/\(storageJobId.urlPercentEncoding())/chunks/\(objectToken.urlPercentEncoding())/list"
    }
}

public struct ListChunksInput {
    /// Maximum number of chunks
    public var maxResults: Swift.Int?
    /// Pagination token
    public var nextToken: Swift.String?
    /// Object token
    /// This member is required.
    public var objectToken: Swift.String?
    /// Storage job id
    /// This member is required.
    public var storageJobId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        objectToken: Swift.String? = nil,
        storageJobId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectToken = objectToken
        self.storageJobId = storageJobId
    }
}

extension ListChunksOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListChunksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListChunksOutput()
        value.chunkList = try reader["ChunkList"].readListIfPresent(memberReadingClosure: BackupStorageClientTypes.Chunk.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListChunksOutput {
    /// List of chunks
    /// This member is required.
    public var chunkList: [BackupStorageClientTypes.Chunk]?
    /// Pagination token
    public var nextToken: Swift.String?

    public init(
        chunkList: [BackupStorageClientTypes.Chunk]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.chunkList = chunkList
        self.nextToken = nextToken
    }
}

enum ListChunksOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableException": return try RetryableException.makeError(baseError: baseError)
            case "ServiceInternalException": return try ServiceInternalException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListObjectsInput {

    static func queryItemProvider(_ value: ListObjectsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let startingObjectName = value.startingObjectName {
            let startingObjectNameQueryItem = ClientRuntime.SDKURLQueryItem(name: "starting-object-name".urlPercentEncoding(), value: Swift.String(startingObjectName).urlPercentEncoding())
            items.append(startingObjectNameQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let createdAfter = value.createdAfter {
            let createdAfterQueryItem = ClientRuntime.SDKURLQueryItem(name: "created-after".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: createdAfter)).urlPercentEncoding())
            items.append(createdAfterQueryItem)
        }
        if let startingObjectPrefix = value.startingObjectPrefix {
            let startingObjectPrefixQueryItem = ClientRuntime.SDKURLQueryItem(name: "starting-object-prefix".urlPercentEncoding(), value: Swift.String(startingObjectPrefix).urlPercentEncoding())
            items.append(startingObjectPrefixQueryItem)
        }
        if let createdBefore = value.createdBefore {
            let createdBeforeQueryItem = ClientRuntime.SDKURLQueryItem(name: "created-before".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: createdBefore)).urlPercentEncoding())
            items.append(createdBeforeQueryItem)
        }
        return items
    }
}

extension ListObjectsInput {

    static func urlPathProvider(_ value: ListObjectsInput) -> Swift.String? {
        guard let storageJobId = value.storageJobId else {
            return nil
        }
        return "/restore-jobs/\(storageJobId.urlPercentEncoding())/objects/list"
    }
}

public struct ListObjectsInput {
    /// (Optional) Created after filter
    public var createdAfter: ClientRuntime.Date?
    /// (Optional) Created before filter
    public var createdBefore: ClientRuntime.Date?
    /// Maximum objects count
    public var maxResults: Swift.Int?
    /// Pagination token
    public var nextToken: Swift.String?
    /// Optional, specifies the starting Object name to list from. Ignored if NextToken is not NULL
    public var startingObjectName: Swift.String?
    /// Optional, specifies the starting Object prefix to list from. Ignored if NextToken is not NULL
    public var startingObjectPrefix: Swift.String?
    /// Storage job id
    /// This member is required.
    public var storageJobId: Swift.String?

    public init(
        createdAfter: ClientRuntime.Date? = nil,
        createdBefore: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startingObjectName: Swift.String? = nil,
        startingObjectPrefix: Swift.String? = nil,
        storageJobId: Swift.String? = nil
    )
    {
        self.createdAfter = createdAfter
        self.createdBefore = createdBefore
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startingObjectName = startingObjectName
        self.startingObjectPrefix = startingObjectPrefix
        self.storageJobId = storageJobId
    }
}

extension ListObjectsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListObjectsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListObjectsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.objectList = try reader["ObjectList"].readListIfPresent(memberReadingClosure: BackupStorageClientTypes.BackupObject.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListObjectsOutput {
    /// Pagination token
    public var nextToken: Swift.String?
    /// Object list
    /// This member is required.
    public var objectList: [BackupStorageClientTypes.BackupObject]?

    public init(
        nextToken: Swift.String? = nil,
        objectList: [BackupStorageClientTypes.BackupObject]? = nil
    )
    {
        self.nextToken = nextToken
        self.objectList = objectList
    }
}

enum ListObjectsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "KMSInvalidKeyUsageException": return try KMSInvalidKeyUsageException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableException": return try RetryableException.makeError(baseError: baseError)
            case "ServiceInternalException": return try ServiceInternalException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension NotReadableInputStreamException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> NotReadableInputStreamException {
        let reader = baseError.errorBodyReader
        var value = NotReadableInputStreamException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// Retryalble exception. Indicated issues while reading an input stream due to the networking issues or connection drop on the client side.
public struct NotReadableInputStreamException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotReadableInputStreamException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension NotifyObjectCompleteInput {

    static func queryItemProvider(_ value: NotifyObjectCompleteInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let objectChecksum = value.objectChecksum else {
            let message = "Creating a URL Query Item failed. objectChecksum is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let objectChecksumQueryItem = ClientRuntime.SDKURLQueryItem(name: "checksum".urlPercentEncoding(), value: Swift.String(objectChecksum).urlPercentEncoding())
        items.append(objectChecksumQueryItem)
        guard let objectChecksumAlgorithm = value.objectChecksumAlgorithm else {
            let message = "Creating a URL Query Item failed. objectChecksumAlgorithm is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let objectChecksumAlgorithmQueryItem = ClientRuntime.SDKURLQueryItem(name: "checksum-algorithm".urlPercentEncoding(), value: Swift.String(objectChecksumAlgorithm.rawValue).urlPercentEncoding())
        items.append(objectChecksumAlgorithmQueryItem)
        if let metadataBlobLength = value.metadataBlobLength {
            let metadataBlobLengthQueryItem = ClientRuntime.SDKURLQueryItem(name: "metadata-blob-length".urlPercentEncoding(), value: Swift.String(metadataBlobLength).urlPercentEncoding())
            items.append(metadataBlobLengthQueryItem)
        }
        if let metadataBlobChecksum = value.metadataBlobChecksum {
            let metadataBlobChecksumQueryItem = ClientRuntime.SDKURLQueryItem(name: "metadata-checksum".urlPercentEncoding(), value: Swift.String(metadataBlobChecksum).urlPercentEncoding())
            items.append(metadataBlobChecksumQueryItem)
        }
        if let metadataBlobChecksumAlgorithm = value.metadataBlobChecksumAlgorithm {
            let metadataBlobChecksumAlgorithmQueryItem = ClientRuntime.SDKURLQueryItem(name: "metadata-checksum-algorithm".urlPercentEncoding(), value: Swift.String(metadataBlobChecksumAlgorithm.rawValue).urlPercentEncoding())
            items.append(metadataBlobChecksumAlgorithmQueryItem)
        }
        if let metadataString = value.metadataString {
            let metadataStringQueryItem = ClientRuntime.SDKURLQueryItem(name: "metadata-string".urlPercentEncoding(), value: Swift.String(metadataString).urlPercentEncoding())
            items.append(metadataStringQueryItem)
        }
        return items
    }
}

extension NotifyObjectCompleteInput {

    static func urlPathProvider(_ value: NotifyObjectCompleteInput) -> Swift.String? {
        guard let backupJobId = value.backupJobId else {
            return nil
        }
        guard let uploadId = value.uploadId else {
            return nil
        }
        return "/backup-jobs/\(backupJobId.urlPercentEncoding())/object/\(uploadId.urlPercentEncoding())/complete"
    }
}

extension NotifyObjectCompleteInput {

    static func write(value: NotifyObjectCompleteInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MetadataBlob"].write(value.metadataBlob)
    }
}

public struct NotifyObjectCompleteInput {
    /// Backup job Id for the in-progress backup
    /// This member is required.
    public var backupJobId: Swift.String?
    /// Optional metadata associated with an Object. Maximum length is 4MB.
    public var metadataBlob: ClientRuntime.ByteStream?
    /// Checksum of MetadataBlob.
    public var metadataBlobChecksum: Swift.String?
    /// Checksum algorithm.
    public var metadataBlobChecksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm?
    /// The size of MetadataBlob.
    public var metadataBlobLength: Swift.Int?
    /// Optional metadata associated with an Object. Maximum string length is 256 bytes.
    public var metadataString: Swift.String?
    /// Object checksum
    /// This member is required.
    public var objectChecksum: Swift.String?
    /// Checksum algorithm
    /// This member is required.
    public var objectChecksumAlgorithm: BackupStorageClientTypes.SummaryChecksumAlgorithm?
    /// Upload Id for the in-progress upload
    /// This member is required.
    public var uploadId: Swift.String?

    public init(
        backupJobId: Swift.String? = nil,
        metadataBlob: ClientRuntime.ByteStream? = nil,
        metadataBlobChecksum: Swift.String? = nil,
        metadataBlobChecksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm? = nil,
        metadataBlobLength: Swift.Int? = nil,
        metadataString: Swift.String? = nil,
        objectChecksum: Swift.String? = nil,
        objectChecksumAlgorithm: BackupStorageClientTypes.SummaryChecksumAlgorithm? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.backupJobId = backupJobId
        self.metadataBlob = metadataBlob
        self.metadataBlobChecksum = metadataBlobChecksum
        self.metadataBlobChecksumAlgorithm = metadataBlobChecksumAlgorithm
        self.metadataBlobLength = metadataBlobLength
        self.metadataString = metadataString
        self.objectChecksum = objectChecksum
        self.objectChecksumAlgorithm = objectChecksumAlgorithm
        self.uploadId = uploadId
    }
}

extension NotifyObjectCompleteOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> NotifyObjectCompleteOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = NotifyObjectCompleteOutput()
        value.objectChecksum = try reader["ObjectChecksum"].readIfPresent()
        value.objectChecksumAlgorithm = try reader["ObjectChecksumAlgorithm"].readIfPresent()
        return value
    }
}

public struct NotifyObjectCompleteOutput {
    /// Object checksum
    /// This member is required.
    public var objectChecksum: Swift.String?
    /// Checksum algorithm
    /// This member is required.
    public var objectChecksumAlgorithm: BackupStorageClientTypes.SummaryChecksumAlgorithm?

    public init(
        objectChecksum: Swift.String? = nil,
        objectChecksumAlgorithm: BackupStorageClientTypes.SummaryChecksumAlgorithm? = nil
    )
    {
        self.objectChecksum = objectChecksum
        self.objectChecksumAlgorithm = objectChecksumAlgorithm
    }
}

enum NotifyObjectCompleteOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "KMSInvalidKeyUsageException": return try KMSInvalidKeyUsageException.makeError(baseError: baseError)
            case "NotReadableInputStreamException": return try NotReadableInputStreamException.makeError(baseError: baseError)
            case "RetryableException": return try RetryableException.makeError(baseError: baseError)
            case "ServiceInternalException": return try ServiceInternalException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension PutChunkInput {

    static func queryItemProvider(_ value: PutChunkInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let length = value.length else {
            let message = "Creating a URL Query Item failed. length is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let lengthQueryItem = ClientRuntime.SDKURLQueryItem(name: "length".urlPercentEncoding(), value: Swift.String(length).urlPercentEncoding())
        items.append(lengthQueryItem)
        guard let checksum = value.checksum else {
            let message = "Creating a URL Query Item failed. checksum is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let checksumQueryItem = ClientRuntime.SDKURLQueryItem(name: "checksum".urlPercentEncoding(), value: Swift.String(checksum).urlPercentEncoding())
        items.append(checksumQueryItem)
        guard let checksumAlgorithm = value.checksumAlgorithm else {
            let message = "Creating a URL Query Item failed. checksumAlgorithm is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let checksumAlgorithmQueryItem = ClientRuntime.SDKURLQueryItem(name: "checksum-algorithm".urlPercentEncoding(), value: Swift.String(checksumAlgorithm.rawValue).urlPercentEncoding())
        items.append(checksumAlgorithmQueryItem)
        return items
    }
}

extension PutChunkInput {

    static func urlPathProvider(_ value: PutChunkInput) -> Swift.String? {
        guard let backupJobId = value.backupJobId else {
            return nil
        }
        guard let uploadId = value.uploadId else {
            return nil
        }
        guard let chunkIndex = value.chunkIndex else {
            return nil
        }
        return "/backup-jobs/\(backupJobId.urlPercentEncoding())/chunk/\(uploadId.urlPercentEncoding())/\(chunkIndex)"
    }
}

extension PutChunkInput {

    static func write(value: PutChunkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Data"].write(value.data)
    }
}

public struct PutChunkInput {
    /// Backup job Id for the in-progress backup.
    /// This member is required.
    public var backupJobId: Swift.String?
    /// Data checksum
    /// This member is required.
    public var checksum: Swift.String?
    /// Checksum algorithm
    /// This member is required.
    public var checksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm?
    /// Describes this chunk's position relative to the other chunks
    /// This member is required.
    public var chunkIndex: Swift.Int?
    /// Data to be uploaded
    /// This member is required.
    public var data: ClientRuntime.ByteStream?
    /// Data length
    /// This member is required.
    public var length: Swift.Int?
    /// Upload Id for the in-progress upload.
    /// This member is required.
    public var uploadId: Swift.String?

    public init(
        backupJobId: Swift.String? = nil,
        checksum: Swift.String? = nil,
        checksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm? = nil,
        chunkIndex: Swift.Int? = nil,
        data: ClientRuntime.ByteStream? = nil,
        length: Swift.Int? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.backupJobId = backupJobId
        self.checksum = checksum
        self.checksumAlgorithm = checksumAlgorithm
        self.chunkIndex = chunkIndex
        self.data = data
        self.length = length
        self.uploadId = uploadId
    }
}

extension PutChunkOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> PutChunkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutChunkOutput()
        value.chunkChecksum = try reader["ChunkChecksum"].readIfPresent()
        value.chunkChecksumAlgorithm = try reader["ChunkChecksumAlgorithm"].readIfPresent()
        return value
    }
}

public struct PutChunkOutput {
    /// Chunk checksum
    /// This member is required.
    public var chunkChecksum: Swift.String?
    /// Checksum algorithm
    /// This member is required.
    public var chunkChecksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm?

    public init(
        chunkChecksum: Swift.String? = nil,
        chunkChecksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm? = nil
    )
    {
        self.chunkChecksum = chunkChecksum
        self.chunkChecksumAlgorithm = chunkChecksumAlgorithm
    }
}

enum PutChunkOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "KMSInvalidKeyUsageException": return try KMSInvalidKeyUsageException.makeError(baseError: baseError)
            case "NotReadableInputStreamException": return try NotReadableInputStreamException.makeError(baseError: baseError)
            case "RetryableException": return try RetryableException.makeError(baseError: baseError)
            case "ServiceInternalException": return try ServiceInternalException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension PutObjectInput {

    static func queryItemProvider(_ value: PutObjectInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let inlineChunkChecksum = value.inlineChunkChecksum {
            let inlineChunkChecksumQueryItem = ClientRuntime.SDKURLQueryItem(name: "checksum".urlPercentEncoding(), value: Swift.String(inlineChunkChecksum).urlPercentEncoding())
            items.append(inlineChunkChecksumQueryItem)
        }
        if let objectChecksum = value.objectChecksum {
            let objectChecksumQueryItem = ClientRuntime.SDKURLQueryItem(name: "object-checksum".urlPercentEncoding(), value: Swift.String(objectChecksum).urlPercentEncoding())
            items.append(objectChecksumQueryItem)
        }
        if let objectChecksumAlgorithm = value.objectChecksumAlgorithm {
            let objectChecksumAlgorithmQueryItem = ClientRuntime.SDKURLQueryItem(name: "object-checksum-algorithm".urlPercentEncoding(), value: Swift.String(objectChecksumAlgorithm.rawValue).urlPercentEncoding())
            items.append(objectChecksumAlgorithmQueryItem)
        }
        if let inlineChunkLength = value.inlineChunkLength {
            let inlineChunkLengthQueryItem = ClientRuntime.SDKURLQueryItem(name: "length".urlPercentEncoding(), value: Swift.String(inlineChunkLength).urlPercentEncoding())
            items.append(inlineChunkLengthQueryItem)
        }
        if let inlineChunkChecksumAlgorithm = value.inlineChunkChecksumAlgorithm {
            let inlineChunkChecksumAlgorithmQueryItem = ClientRuntime.SDKURLQueryItem(name: "checksum-algorithm".urlPercentEncoding(), value: Swift.String(inlineChunkChecksumAlgorithm).urlPercentEncoding())
            items.append(inlineChunkChecksumAlgorithmQueryItem)
        }
        if let metadataString = value.metadataString {
            let metadataStringQueryItem = ClientRuntime.SDKURLQueryItem(name: "metadata-string".urlPercentEncoding(), value: Swift.String(metadataString).urlPercentEncoding())
            items.append(metadataStringQueryItem)
        }
        if let throwOnDuplicate = value.throwOnDuplicate {
            let throwOnDuplicateQueryItem = ClientRuntime.SDKURLQueryItem(name: "throwOnDuplicate".urlPercentEncoding(), value: Swift.String(throwOnDuplicate).urlPercentEncoding())
            items.append(throwOnDuplicateQueryItem)
        }
        return items
    }
}

extension PutObjectInput {

    static func urlPathProvider(_ value: PutObjectInput) -> Swift.String? {
        guard let backupJobId = value.backupJobId else {
            return nil
        }
        guard let objectName = value.objectName else {
            return nil
        }
        return "/backup-jobs/\(backupJobId.urlPercentEncoding())/object/\(objectName.urlPercentEncoding())/put-object"
    }
}

extension PutObjectInput {

    static func write(value: PutObjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InlineChunk"].write(value.inlineChunk)
    }
}

public struct PutObjectInput {
    /// Backup job Id for the in-progress backup.
    /// This member is required.
    public var backupJobId: Swift.String?
    /// Inline chunk data to be uploaded.
    public var inlineChunk: ClientRuntime.ByteStream?
    /// Inline chunk checksum
    public var inlineChunkChecksum: Swift.String?
    /// Inline chunk checksum algorithm
    public var inlineChunkChecksumAlgorithm: Swift.String?
    /// Length of the inline chunk data.
    public var inlineChunkLength: Swift.Int?
    /// Store user defined metadata like backup checksum, disk ids, restore metadata etc.
    public var metadataString: Swift.String?
    /// object checksum
    public var objectChecksum: Swift.String?
    /// object checksum algorithm
    public var objectChecksumAlgorithm: BackupStorageClientTypes.SummaryChecksumAlgorithm?
    /// The name of the Object to be uploaded.
    /// This member is required.
    public var objectName: Swift.String?
    /// Throw an exception if Object name is already exist.
    public var throwOnDuplicate: Swift.Bool?

    public init(
        backupJobId: Swift.String? = nil,
        inlineChunk: ClientRuntime.ByteStream? = nil,
        inlineChunkChecksum: Swift.String? = nil,
        inlineChunkChecksumAlgorithm: Swift.String? = nil,
        inlineChunkLength: Swift.Int? = nil,
        metadataString: Swift.String? = nil,
        objectChecksum: Swift.String? = nil,
        objectChecksumAlgorithm: BackupStorageClientTypes.SummaryChecksumAlgorithm? = nil,
        objectName: Swift.String? = nil,
        throwOnDuplicate: Swift.Bool? = nil
    )
    {
        self.backupJobId = backupJobId
        self.inlineChunk = inlineChunk
        self.inlineChunkChecksum = inlineChunkChecksum
        self.inlineChunkChecksumAlgorithm = inlineChunkChecksumAlgorithm
        self.inlineChunkLength = inlineChunkLength
        self.metadataString = metadataString
        self.objectChecksum = objectChecksum
        self.objectChecksumAlgorithm = objectChecksumAlgorithm
        self.objectName = objectName
        self.throwOnDuplicate = throwOnDuplicate
    }
}

extension PutObjectOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> PutObjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutObjectOutput()
        value.inlineChunkChecksum = try reader["InlineChunkChecksum"].readIfPresent()
        value.inlineChunkChecksumAlgorithm = try reader["InlineChunkChecksumAlgorithm"].readIfPresent()
        value.objectChecksum = try reader["ObjectChecksum"].readIfPresent()
        value.objectChecksumAlgorithm = try reader["ObjectChecksumAlgorithm"].readIfPresent()
        return value
    }
}

public struct PutObjectOutput {
    /// Inline chunk checksum
    /// This member is required.
    public var inlineChunkChecksum: Swift.String?
    /// Inline chunk checksum algorithm
    /// This member is required.
    public var inlineChunkChecksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm?
    /// object checksum
    /// This member is required.
    public var objectChecksum: Swift.String?
    /// object checksum algorithm
    /// This member is required.
    public var objectChecksumAlgorithm: BackupStorageClientTypes.SummaryChecksumAlgorithm?

    public init(
        inlineChunkChecksum: Swift.String? = nil,
        inlineChunkChecksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm? = nil,
        objectChecksum: Swift.String? = nil,
        objectChecksumAlgorithm: BackupStorageClientTypes.SummaryChecksumAlgorithm? = nil
    )
    {
        self.inlineChunkChecksum = inlineChunkChecksum
        self.inlineChunkChecksumAlgorithm = inlineChunkChecksumAlgorithm
        self.objectChecksum = objectChecksum
        self.objectChecksumAlgorithm = objectChecksumAlgorithm
    }
}

enum PutObjectOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "KMSInvalidKeyUsageException": return try KMSInvalidKeyUsageException.makeError(baseError: baseError)
            case "NotReadableInputStreamException": return try NotReadableInputStreamException.makeError(baseError: baseError)
            case "RetryableException": return try RetryableException.makeError(baseError: baseError)
            case "ServiceInternalException": return try ServiceInternalException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// Non-retryable exception. Attempted to make an operation on non-existing or expired resource.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension RetryableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> RetryableException {
        let reader = baseError.errorBodyReader
        var value = RetryableException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// Retryable exception. In general indicates internal failure that can be fixed by retry.
public struct RetryableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RetryableException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ServiceInternalException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceInternalException {
        let reader = baseError.errorBodyReader
        var value = ServiceInternalException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// Deprecated. To be removed from the model.
public struct ServiceInternalException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceInternalException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ServiceUnavailableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceUnavailableException {
        let reader = baseError.errorBodyReader
        var value = ServiceUnavailableException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// Retryable exception, indicates internal server error.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension StartObjectInput {

    static func urlPathProvider(_ value: StartObjectInput) -> Swift.String? {
        guard let backupJobId = value.backupJobId else {
            return nil
        }
        guard let objectName = value.objectName else {
            return nil
        }
        return "/backup-jobs/\(backupJobId.urlPercentEncoding())/object/\(objectName.urlPercentEncoding())"
    }
}

extension StartObjectInput {

    static func write(value: StartObjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ThrowOnDuplicate"].write(value.throwOnDuplicate)
    }
}

public struct StartObjectInput {
    /// Backup job Id for the in-progress backup
    /// This member is required.
    public var backupJobId: Swift.String?
    /// Name for the object.
    /// This member is required.
    public var objectName: Swift.String?
    /// Throw an exception if Object name is already exist.
    public var throwOnDuplicate: Swift.Bool?

    public init(
        backupJobId: Swift.String? = nil,
        objectName: Swift.String? = nil,
        throwOnDuplicate: Swift.Bool? = nil
    )
    {
        self.backupJobId = backupJobId
        self.objectName = objectName
        self.throwOnDuplicate = throwOnDuplicate
    }
}

extension StartObjectOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> StartObjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartObjectOutput()
        value.uploadId = try reader["UploadId"].readIfPresent()
        return value
    }
}

public struct StartObjectOutput {
    /// Upload Id for a given upload.
    /// This member is required.
    public var uploadId: Swift.String?

    public init(
        uploadId: Swift.String? = nil
    )
    {
        self.uploadId = uploadId
    }
}

enum StartObjectOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "DataAlreadyExistsException": return try DataAlreadyExistsException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableException": return try RetryableException.makeError(baseError: baseError)
            case "ServiceInternalException": return try ServiceInternalException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension BackupStorageClientTypes {

    public enum SummaryChecksumAlgorithm: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case summary
        case sdkUnknown(Swift.String)

        public static var allCases: [SummaryChecksumAlgorithm] {
            return [
                .summary,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .summary: return "SUMMARY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// Increased rate over throttling limits. Can be retried with exponential backoff.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}
