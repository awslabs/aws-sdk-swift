// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BackupStorageClientTypes.BackupObject: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chunksCount = "ChunksCount"
        case metadataString = "MetadataString"
        case name = "Name"
        case objectChecksum = "ObjectChecksum"
        case objectChecksumAlgorithm = "ObjectChecksumAlgorithm"
        case objectToken = "ObjectToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chunksCount = self.chunksCount {
            try encodeContainer.encode(chunksCount, forKey: .chunksCount)
        }
        if let metadataString = self.metadataString {
            try encodeContainer.encode(metadataString, forKey: .metadataString)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let objectChecksum = self.objectChecksum {
            try encodeContainer.encode(objectChecksum, forKey: .objectChecksum)
        }
        if let objectChecksumAlgorithm = self.objectChecksumAlgorithm {
            try encodeContainer.encode(objectChecksumAlgorithm.rawValue, forKey: .objectChecksumAlgorithm)
        }
        if let objectToken = self.objectToken {
            try encodeContainer.encode(objectToken, forKey: .objectToken)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let chunksCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .chunksCount)
        chunksCount = chunksCountDecoded
        let metadataStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadataString)
        metadataString = metadataStringDecoded
        let objectChecksumDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectChecksum)
        objectChecksum = objectChecksumDecoded
        let objectChecksumAlgorithmDecoded = try containerValues.decodeIfPresent(BackupStorageClientTypes.SummaryChecksumAlgorithm.self, forKey: .objectChecksumAlgorithm)
        objectChecksumAlgorithm = objectChecksumAlgorithmDecoded
        let objectTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectToken)
        objectToken = objectTokenDecoded
    }
}

extension BackupStorageClientTypes {
    /// Object
    public struct BackupObject: Swift.Equatable {
        /// Number of chunks in object
        public var chunksCount: Swift.Int?
        /// Metadata string associated with the Object
        public var metadataString: Swift.String?
        /// Object name
        /// This member is required.
        public var name: Swift.String?
        /// Object checksum
        /// This member is required.
        public var objectChecksum: Swift.String?
        /// Checksum algorithm
        /// This member is required.
        public var objectChecksumAlgorithm: BackupStorageClientTypes.SummaryChecksumAlgorithm?
        /// Object token
        /// This member is required.
        public var objectToken: Swift.String?

        public init (
            chunksCount: Swift.Int? = nil,
            metadataString: Swift.String? = nil,
            name: Swift.String? = nil,
            objectChecksum: Swift.String? = nil,
            objectChecksumAlgorithm: BackupStorageClientTypes.SummaryChecksumAlgorithm? = nil,
            objectToken: Swift.String? = nil
        )
        {
            self.chunksCount = chunksCount
            self.metadataString = metadataString
            self.name = name
            self.objectChecksum = objectChecksum
            self.objectChecksumAlgorithm = objectChecksumAlgorithm
            self.objectToken = objectToken
        }
    }

}

extension BackupStorageClientTypes.Chunk: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checksum = "Checksum"
        case checksumAlgorithm = "ChecksumAlgorithm"
        case chunkToken = "ChunkToken"
        case index = "Index"
        case length = "Length"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checksum = self.checksum {
            try encodeContainer.encode(checksum, forKey: .checksum)
        }
        if let checksumAlgorithm = self.checksumAlgorithm {
            try encodeContainer.encode(checksumAlgorithm.rawValue, forKey: .checksumAlgorithm)
        }
        if let chunkToken = self.chunkToken {
            try encodeContainer.encode(chunkToken, forKey: .chunkToken)
        }
        if index != 0 {
            try encodeContainer.encode(index, forKey: .index)
        }
        if length != 0 {
            try encodeContainer.encode(length, forKey: .length)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .index) ?? 0
        index = indexDecoded
        let lengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .length) ?? 0
        length = lengthDecoded
        let checksumDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .checksum)
        checksum = checksumDecoded
        let checksumAlgorithmDecoded = try containerValues.decodeIfPresent(BackupStorageClientTypes.DataChecksumAlgorithm.self, forKey: .checksumAlgorithm)
        checksumAlgorithm = checksumAlgorithmDecoded
        let chunkTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .chunkToken)
        chunkToken = chunkTokenDecoded
    }
}

extension BackupStorageClientTypes {
    /// Chunk
    public struct Chunk: Swift.Equatable {
        /// Chunk checksum
        /// This member is required.
        public var checksum: Swift.String?
        /// Checksum algorithm
        /// This member is required.
        public var checksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm?
        /// Chunk token
        /// This member is required.
        public var chunkToken: Swift.String?
        /// Chunk index
        /// This member is required.
        public var index: Swift.Int
        /// Chunk length
        /// This member is required.
        public var length: Swift.Int

        public init (
            checksum: Swift.String? = nil,
            checksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm? = nil,
            chunkToken: Swift.String? = nil,
            index: Swift.Int = 0,
            length: Swift.Int = 0
        )
        {
            self.checksum = checksum
            self.checksumAlgorithm = checksumAlgorithm
            self.chunkToken = chunkToken
            self.index = index
            self.length = length
        }
    }

}

extension DataAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DataAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.checksum = output.checksum
            self.checksumAlgorithm = output.checksumAlgorithm
            self.message = output.message
        } else {
            self.checksum = nil
            self.checksumAlgorithm = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Non-retryable exception. Attempted to create already existing object or chunk. This message contains a checksum of already presented data.
public struct DataAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Data checksum used
    public var checksum: Swift.String?
    /// Checksum algorithm used
    public var checksumAlgorithm: Swift.String?
    public var message: Swift.String?

    public init (
        checksum: Swift.String? = nil,
        checksumAlgorithm: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.checksum = checksum
        self.checksumAlgorithm = checksumAlgorithm
        self.message = message
    }
}

struct DataAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let checksum: Swift.String?
    let checksumAlgorithm: Swift.String?
}

extension DataAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checksum = "Checksum"
        case checksumAlgorithm = "ChecksumAlgorithm"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let checksumDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .checksum)
        checksum = checksumDecoded
        let checksumAlgorithmDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .checksumAlgorithm)
        checksumAlgorithm = checksumAlgorithmDecoded
    }
}

extension BackupStorageClientTypes {
    public enum DataChecksumAlgorithm: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sha256
        case sdkUnknown(Swift.String)

        public static var allCases: [DataChecksumAlgorithm] {
            return [
                .sha256,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sha256: return "SHA256"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataChecksumAlgorithm(rawValue: rawValue) ?? DataChecksumAlgorithm.sdkUnknown(rawValue)
        }
    }
}

extension DeleteObjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupJobId = backupJobId else {
            return nil
        }
        guard let objectName = objectName else {
            return nil
        }
        return "/backup-jobs/\(backupJobId.urlPercentEncoding())/object/\(objectName.urlPercentEncoding())"
    }
}

public struct DeleteObjectInput: Swift.Equatable {
    /// Backup job Id for the in-progress backup.
    /// This member is required.
    public var backupJobId: Swift.String?
    /// The name of the Object.
    /// This member is required.
    public var objectName: Swift.String?

    public init (
        backupJobId: Swift.String? = nil,
        objectName: Swift.String? = nil
    )
    {
        self.backupJobId = backupJobId
        self.objectName = objectName
    }
}

struct DeleteObjectInputBody: Swift.Equatable {
}

extension DeleteObjectInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteObjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteObjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalArgumentException" : self = .illegalArgumentException(try IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableException" : self = .retryableException(try RetryableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceInternalException" : self = .serviceInternalException(try ServiceInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteObjectOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case illegalArgumentException(IllegalArgumentException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableException(RetryableException)
    case serviceInternalException(ServiceInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteObjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteObjectOutputResponse: Swift.Equatable {

    public init () { }
}

extension GetChunkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let storageJobId = storageJobId else {
            return nil
        }
        guard let chunkToken = chunkToken else {
            return nil
        }
        return "/restore-jobs/\(storageJobId.urlPercentEncoding())/chunk/\(chunkToken.urlPercentEncoding())"
    }
}

public struct GetChunkInput: Swift.Equatable {
    /// Chunk token
    /// This member is required.
    public var chunkToken: Swift.String?
    /// Storage job id
    /// This member is required.
    public var storageJobId: Swift.String?

    public init (
        chunkToken: Swift.String? = nil,
        storageJobId: Swift.String? = nil
    )
    {
        self.chunkToken = chunkToken
        self.storageJobId = storageJobId
    }
}

struct GetChunkInputBody: Swift.Equatable {
}

extension GetChunkInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetChunkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetChunkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalArgumentException" : self = .illegalArgumentException(try IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidKeyUsageException" : self = .kMSInvalidKeyUsageException(try KMSInvalidKeyUsageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableException" : self = .retryableException(try RetryableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceInternalException" : self = .serviceInternalException(try ServiceInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetChunkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case illegalArgumentException(IllegalArgumentException)
    case kMSInvalidKeyUsageException(KMSInvalidKeyUsageException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableException(RetryableException)
    case serviceInternalException(ServiceInternalException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetChunkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let checksumHeaderValue = httpResponse.headers.value(for: "x-amz-checksum") {
            self.checksum = checksumHeaderValue
        } else {
            self.checksum = nil
        }
        if let checksumAlgorithmHeaderValue = httpResponse.headers.value(for: "x-amz-checksum-algorithm") {
            self.checksumAlgorithm = BackupStorageClientTypes.DataChecksumAlgorithm(rawValue: checksumAlgorithmHeaderValue)
        } else {
            self.checksumAlgorithm = nil
        }
        if let lengthHeaderValue = httpResponse.headers.value(for: "x-amz-data-length") {
            self.length = Swift.Int(lengthHeaderValue) ?? 0
        } else {
            self.length = 0
        }
        if let data = httpResponse.body.toBytes()?.getData() {
            self.data = ByteStream.from(data: data)
        } else {
            self.data = nil
        }
    }
}

public struct GetChunkOutputResponse: Swift.Equatable {
    /// Data checksum
    /// This member is required.
    public var checksum: Swift.String?
    /// Checksum algorithm
    /// This member is required.
    public var checksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm?
    /// Chunk data
    /// This member is required.
    public var data: ClientRuntime.ByteStream?
    /// Data length
    /// This member is required.
    public var length: Swift.Int

    public init (
        checksum: Swift.String? = nil,
        checksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm? = nil,
        data: ClientRuntime.ByteStream? = nil,
        length: Swift.Int = 0
    )
    {
        self.checksum = checksum
        self.checksumAlgorithm = checksumAlgorithm
        self.data = data
        self.length = length
    }
}

struct GetChunkOutputResponseBody: Swift.Equatable {
    let data: ClientRuntime.ByteStream?
}

extension GetChunkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case data = "Data"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .data)
        data = dataDecoded
    }
}

extension GetObjectMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let storageJobId = storageJobId else {
            return nil
        }
        guard let objectToken = objectToken else {
            return nil
        }
        return "/restore-jobs/\(storageJobId.urlPercentEncoding())/object/\(objectToken.urlPercentEncoding())/metadata"
    }
}

public struct GetObjectMetadataInput: Swift.Equatable {
    /// Object token.
    /// This member is required.
    public var objectToken: Swift.String?
    /// Backup job id for the in-progress backup.
    /// This member is required.
    public var storageJobId: Swift.String?

    public init (
        objectToken: Swift.String? = nil,
        storageJobId: Swift.String? = nil
    )
    {
        self.objectToken = objectToken
        self.storageJobId = storageJobId
    }
}

struct GetObjectMetadataInputBody: Swift.Equatable {
}

extension GetObjectMetadataInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetObjectMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetObjectMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalArgumentException" : self = .illegalArgumentException(try IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidKeyUsageException" : self = .kMSInvalidKeyUsageException(try KMSInvalidKeyUsageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableException" : self = .retryableException(try RetryableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceInternalException" : self = .serviceInternalException(try ServiceInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetObjectMetadataOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case illegalArgumentException(IllegalArgumentException)
    case kMSInvalidKeyUsageException(KMSInvalidKeyUsageException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableException(RetryableException)
    case serviceInternalException(ServiceInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetObjectMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let metadataBlobChecksumHeaderValue = httpResponse.headers.value(for: "x-amz-checksum") {
            self.metadataBlobChecksum = metadataBlobChecksumHeaderValue
        } else {
            self.metadataBlobChecksum = nil
        }
        if let metadataBlobChecksumAlgorithmHeaderValue = httpResponse.headers.value(for: "x-amz-checksum-algorithm") {
            self.metadataBlobChecksumAlgorithm = BackupStorageClientTypes.DataChecksumAlgorithm(rawValue: metadataBlobChecksumAlgorithmHeaderValue)
        } else {
            self.metadataBlobChecksumAlgorithm = nil
        }
        if let metadataBlobLengthHeaderValue = httpResponse.headers.value(for: "x-amz-data-length") {
            self.metadataBlobLength = Swift.Int(metadataBlobLengthHeaderValue) ?? 0
        } else {
            self.metadataBlobLength = 0
        }
        if let metadataStringHeaderValue = httpResponse.headers.value(for: "x-amz-metadata-string") {
            self.metadataString = metadataStringHeaderValue
        } else {
            self.metadataString = nil
        }
        if let data = httpResponse.body.toBytes()?.getData() {
            self.metadataBlob = ByteStream.from(data: data)
        } else {
            self.metadataBlob = nil
        }
    }
}

public struct GetObjectMetadataOutputResponse: Swift.Equatable {
    /// Metadata blob.
    public var metadataBlob: ClientRuntime.ByteStream?
    /// MetadataBlob checksum.
    public var metadataBlobChecksum: Swift.String?
    /// Checksum algorithm.
    public var metadataBlobChecksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm?
    /// The size of MetadataBlob.
    public var metadataBlobLength: Swift.Int
    /// Metadata string.
    public var metadataString: Swift.String?

    public init (
        metadataBlob: ClientRuntime.ByteStream? = nil,
        metadataBlobChecksum: Swift.String? = nil,
        metadataBlobChecksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm? = nil,
        metadataBlobLength: Swift.Int = 0,
        metadataString: Swift.String? = nil
    )
    {
        self.metadataBlob = metadataBlob
        self.metadataBlobChecksum = metadataBlobChecksum
        self.metadataBlobChecksumAlgorithm = metadataBlobChecksumAlgorithm
        self.metadataBlobLength = metadataBlobLength
        self.metadataString = metadataString
    }
}

struct GetObjectMetadataOutputResponseBody: Swift.Equatable {
    let metadataBlob: ClientRuntime.ByteStream?
}

extension GetObjectMetadataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadataBlob = "MetadataBlob"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataBlobDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .metadataBlob)
        metadataBlob = metadataBlobDecoded
    }
}

extension IllegalArgumentException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: IllegalArgumentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Non-retryable exception, indicates client error (wrong argument passed to API). See exception message for details.
public struct IllegalArgumentException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IllegalArgumentExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension IllegalArgumentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSInvalidKeyUsageException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: KMSInvalidKeyUsageExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Non-retryable exception. Indicates the KMS key usage is incorrect. See exception message for details.
public struct KMSInvalidKeyUsageException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KMSInvalidKeyUsageExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension KMSInvalidKeyUsageExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListChunksInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListChunksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let storageJobId = storageJobId else {
            return nil
        }
        guard let objectToken = objectToken else {
            return nil
        }
        return "/restore-jobs/\(storageJobId.urlPercentEncoding())/chunks/\(objectToken.urlPercentEncoding())/list"
    }
}

public struct ListChunksInput: Swift.Equatable {
    /// Maximum number of chunks
    public var maxResults: Swift.Int
    /// Pagination token
    public var nextToken: Swift.String?
    /// Object token
    /// This member is required.
    public var objectToken: Swift.String?
    /// Storage job id
    /// This member is required.
    public var storageJobId: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        objectToken: Swift.String? = nil,
        storageJobId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectToken = objectToken
        self.storageJobId = storageJobId
    }
}

struct ListChunksInputBody: Swift.Equatable {
}

extension ListChunksInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListChunksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChunksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalArgumentException" : self = .illegalArgumentException(try IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableException" : self = .retryableException(try RetryableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceInternalException" : self = .serviceInternalException(try ServiceInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListChunksOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case illegalArgumentException(IllegalArgumentException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableException(RetryableException)
    case serviceInternalException(ServiceInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChunksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListChunksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.chunkList = output.chunkList
            self.nextToken = output.nextToken
        } else {
            self.chunkList = nil
            self.nextToken = nil
        }
    }
}

public struct ListChunksOutputResponse: Swift.Equatable {
    /// List of chunks
    /// This member is required.
    public var chunkList: [BackupStorageClientTypes.Chunk]?
    /// Pagination token
    public var nextToken: Swift.String?

    public init (
        chunkList: [BackupStorageClientTypes.Chunk]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.chunkList = chunkList
        self.nextToken = nextToken
    }
}

struct ListChunksOutputResponseBody: Swift.Equatable {
    let chunkList: [BackupStorageClientTypes.Chunk]?
    let nextToken: Swift.String?
}

extension ListChunksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chunkList = "ChunkList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let chunkListContainer = try containerValues.decodeIfPresent([BackupStorageClientTypes.Chunk?].self, forKey: .chunkList)
        var chunkListDecoded0:[BackupStorageClientTypes.Chunk]? = nil
        if let chunkListContainer = chunkListContainer {
            chunkListDecoded0 = [BackupStorageClientTypes.Chunk]()
            for structure0 in chunkListContainer {
                if let structure0 = structure0 {
                    chunkListDecoded0?.append(structure0)
                }
            }
        }
        chunkList = chunkListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListObjectsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let startingObjectName = startingObjectName {
                let startingObjectNameQueryItem = ClientRuntime.URLQueryItem(name: "starting-object-name".urlPercentEncoding(), value: Swift.String(startingObjectName).urlPercentEncoding())
                items.append(startingObjectNameQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let createdAfter = createdAfter {
                let createdAfterQueryItem = ClientRuntime.URLQueryItem(name: "created-after".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: createdAfter)).urlPercentEncoding())
                items.append(createdAfterQueryItem)
            }
            if let startingObjectPrefix = startingObjectPrefix {
                let startingObjectPrefixQueryItem = ClientRuntime.URLQueryItem(name: "starting-object-prefix".urlPercentEncoding(), value: Swift.String(startingObjectPrefix).urlPercentEncoding())
                items.append(startingObjectPrefixQueryItem)
            }
            if let createdBefore = createdBefore {
                let createdBeforeQueryItem = ClientRuntime.URLQueryItem(name: "created-before".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: createdBefore)).urlPercentEncoding())
                items.append(createdBeforeQueryItem)
            }
            return items
        }
    }
}

extension ListObjectsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let storageJobId = storageJobId else {
            return nil
        }
        return "/restore-jobs/\(storageJobId.urlPercentEncoding())/objects/list"
    }
}

public struct ListObjectsInput: Swift.Equatable {
    /// (Optional) Created after filter
    public var createdAfter: ClientRuntime.Date?
    /// (Optional) Created before filter
    public var createdBefore: ClientRuntime.Date?
    /// Maximum objects count
    public var maxResults: Swift.Int
    /// Pagination token
    public var nextToken: Swift.String?
    /// Optional, specifies the starting Object name to list from. Ignored if NextToken is not NULL
    public var startingObjectName: Swift.String?
    /// Optional, specifies the starting Object prefix to list from. Ignored if NextToken is not NULL
    public var startingObjectPrefix: Swift.String?
    /// Storage job id
    /// This member is required.
    public var storageJobId: Swift.String?

    public init (
        createdAfter: ClientRuntime.Date? = nil,
        createdBefore: ClientRuntime.Date? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        startingObjectName: Swift.String? = nil,
        startingObjectPrefix: Swift.String? = nil,
        storageJobId: Swift.String? = nil
    )
    {
        self.createdAfter = createdAfter
        self.createdBefore = createdBefore
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startingObjectName = startingObjectName
        self.startingObjectPrefix = startingObjectPrefix
        self.storageJobId = storageJobId
    }
}

struct ListObjectsInputBody: Swift.Equatable {
}

extension ListObjectsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListObjectsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListObjectsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalArgumentException" : self = .illegalArgumentException(try IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidKeyUsageException" : self = .kMSInvalidKeyUsageException(try KMSInvalidKeyUsageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableException" : self = .retryableException(try RetryableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceInternalException" : self = .serviceInternalException(try ServiceInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListObjectsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case illegalArgumentException(IllegalArgumentException)
    case kMSInvalidKeyUsageException(KMSInvalidKeyUsageException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableException(RetryableException)
    case serviceInternalException(ServiceInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListObjectsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListObjectsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.objectList = output.objectList
        } else {
            self.nextToken = nil
            self.objectList = nil
        }
    }
}

public struct ListObjectsOutputResponse: Swift.Equatable {
    /// Pagination token
    public var nextToken: Swift.String?
    /// Object list
    /// This member is required.
    public var objectList: [BackupStorageClientTypes.BackupObject]?

    public init (
        nextToken: Swift.String? = nil,
        objectList: [BackupStorageClientTypes.BackupObject]? = nil
    )
    {
        self.nextToken = nextToken
        self.objectList = objectList
    }
}

struct ListObjectsOutputResponseBody: Swift.Equatable {
    let objectList: [BackupStorageClientTypes.BackupObject]?
    let nextToken: Swift.String?
}

extension ListObjectsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case objectList = "ObjectList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectListContainer = try containerValues.decodeIfPresent([BackupStorageClientTypes.BackupObject?].self, forKey: .objectList)
        var objectListDecoded0:[BackupStorageClientTypes.BackupObject]? = nil
        if let objectListContainer = objectListContainer {
            objectListDecoded0 = [BackupStorageClientTypes.BackupObject]()
            for structure0 in objectListContainer {
                if let structure0 = structure0 {
                    objectListDecoded0?.append(structure0)
                }
            }
        }
        objectList = objectListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension NotReadableInputStreamException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NotReadableInputStreamExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Retryalble exception. Indicated issues while reading an input stream due to the networking issues or connection drop on the client side.
public struct NotReadableInputStreamException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotReadableInputStreamExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotReadableInputStreamExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct NotifyObjectCompleteInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "NotifyObjectCompleteInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<NotifyObjectCompleteInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<NotifyObjectCompleteOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let metadataBlob = input.operationInput.metadataBlob {
            let metadataBlobdata = metadataBlob
            let metadataBlobbody = ClientRuntime.HttpBody.stream(metadataBlobdata)
            input.builder.withBody(metadataBlobbody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<NotifyObjectCompleteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<NotifyObjectCompleteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension NotifyObjectCompleteInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadataBlob = "MetadataBlob"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadataBlob = self.metadataBlob {
            try encodeContainer.encode(metadataBlob.toBytes().getData(), forKey: .metadataBlob)
        }
    }
}

extension NotifyObjectCompleteInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let objectChecksum = objectChecksum else {
                let message = "Creating a URL Query Item failed. objectChecksum is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let objectChecksumQueryItem = ClientRuntime.URLQueryItem(name: "checksum".urlPercentEncoding(), value: Swift.String(objectChecksum).urlPercentEncoding())
            items.append(objectChecksumQueryItem)
            guard let objectChecksumAlgorithm = objectChecksumAlgorithm else {
                let message = "Creating a URL Query Item failed. objectChecksumAlgorithm is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let objectChecksumAlgorithmQueryItem = ClientRuntime.URLQueryItem(name: "checksum-algorithm".urlPercentEncoding(), value: Swift.String(objectChecksumAlgorithm.rawValue).urlPercentEncoding())
            items.append(objectChecksumAlgorithmQueryItem)
            if metadataBlobLength != 0 {
                let metadataBlobLengthQueryItem = ClientRuntime.URLQueryItem(name: "metadata-blob-length".urlPercentEncoding(), value: Swift.String(metadataBlobLength).urlPercentEncoding())
                items.append(metadataBlobLengthQueryItem)
            }
            if let metadataBlobChecksum = metadataBlobChecksum {
                let metadataBlobChecksumQueryItem = ClientRuntime.URLQueryItem(name: "metadata-checksum".urlPercentEncoding(), value: Swift.String(metadataBlobChecksum).urlPercentEncoding())
                items.append(metadataBlobChecksumQueryItem)
            }
            if let metadataBlobChecksumAlgorithm = metadataBlobChecksumAlgorithm {
                let metadataBlobChecksumAlgorithmQueryItem = ClientRuntime.URLQueryItem(name: "metadata-checksum-algorithm".urlPercentEncoding(), value: Swift.String(metadataBlobChecksumAlgorithm.rawValue).urlPercentEncoding())
                items.append(metadataBlobChecksumAlgorithmQueryItem)
            }
            if let metadataString = metadataString {
                let metadataStringQueryItem = ClientRuntime.URLQueryItem(name: "metadata-string".urlPercentEncoding(), value: Swift.String(metadataString).urlPercentEncoding())
                items.append(metadataStringQueryItem)
            }
            return items
        }
    }
}

extension NotifyObjectCompleteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupJobId = backupJobId else {
            return nil
        }
        guard let uploadId = uploadId else {
            return nil
        }
        return "/backup-jobs/\(backupJobId.urlPercentEncoding())/object/\(uploadId.urlPercentEncoding())/complete"
    }
}

public struct NotifyObjectCompleteInput: Swift.Equatable {
    /// Backup job Id for the in-progress backup
    /// This member is required.
    public var backupJobId: Swift.String?
    /// Optional metadata associated with an Object. Maximum length is 4MB.
    public var metadataBlob: ClientRuntime.ByteStream?
    /// Checksum of MetadataBlob.
    public var metadataBlobChecksum: Swift.String?
    /// Checksum algorithm.
    public var metadataBlobChecksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm?
    /// The size of MetadataBlob.
    public var metadataBlobLength: Swift.Int
    /// Optional metadata associated with an Object. Maximum string length is 256 bytes.
    public var metadataString: Swift.String?
    /// Object checksum
    /// This member is required.
    public var objectChecksum: Swift.String?
    /// Checksum algorithm
    /// This member is required.
    public var objectChecksumAlgorithm: BackupStorageClientTypes.SummaryChecksumAlgorithm?
    /// Upload Id for the in-progress upload
    /// This member is required.
    public var uploadId: Swift.String?

    public init (
        backupJobId: Swift.String? = nil,
        metadataBlob: ClientRuntime.ByteStream? = nil,
        metadataBlobChecksum: Swift.String? = nil,
        metadataBlobChecksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm? = nil,
        metadataBlobLength: Swift.Int = 0,
        metadataString: Swift.String? = nil,
        objectChecksum: Swift.String? = nil,
        objectChecksumAlgorithm: BackupStorageClientTypes.SummaryChecksumAlgorithm? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.backupJobId = backupJobId
        self.metadataBlob = metadataBlob
        self.metadataBlobChecksum = metadataBlobChecksum
        self.metadataBlobChecksumAlgorithm = metadataBlobChecksumAlgorithm
        self.metadataBlobLength = metadataBlobLength
        self.metadataString = metadataString
        self.objectChecksum = objectChecksum
        self.objectChecksumAlgorithm = objectChecksumAlgorithm
        self.uploadId = uploadId
    }
}

struct NotifyObjectCompleteInputBody: Swift.Equatable {
    let metadataBlob: ClientRuntime.ByteStream?
}

extension NotifyObjectCompleteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadataBlob = "MetadataBlob"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataBlobDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .metadataBlob)
        metadataBlob = metadataBlobDecoded
    }
}

extension NotifyObjectCompleteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension NotifyObjectCompleteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalArgumentException" : self = .illegalArgumentException(try IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidKeyUsageException" : self = .kMSInvalidKeyUsageException(try KMSInvalidKeyUsageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotReadableInputStreamException" : self = .notReadableInputStreamException(try NotReadableInputStreamException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableException" : self = .retryableException(try RetryableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceInternalException" : self = .serviceInternalException(try ServiceInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum NotifyObjectCompleteOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case illegalArgumentException(IllegalArgumentException)
    case kMSInvalidKeyUsageException(KMSInvalidKeyUsageException)
    case notReadableInputStreamException(NotReadableInputStreamException)
    case retryableException(RetryableException)
    case serviceInternalException(ServiceInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension NotifyObjectCompleteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NotifyObjectCompleteOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.objectChecksum = output.objectChecksum
            self.objectChecksumAlgorithm = output.objectChecksumAlgorithm
        } else {
            self.objectChecksum = nil
            self.objectChecksumAlgorithm = nil
        }
    }
}

public struct NotifyObjectCompleteOutputResponse: Swift.Equatable {
    /// Object checksum
    /// This member is required.
    public var objectChecksum: Swift.String?
    /// Checksum algorithm
    /// This member is required.
    public var objectChecksumAlgorithm: BackupStorageClientTypes.SummaryChecksumAlgorithm?

    public init (
        objectChecksum: Swift.String? = nil,
        objectChecksumAlgorithm: BackupStorageClientTypes.SummaryChecksumAlgorithm? = nil
    )
    {
        self.objectChecksum = objectChecksum
        self.objectChecksumAlgorithm = objectChecksumAlgorithm
    }
}

struct NotifyObjectCompleteOutputResponseBody: Swift.Equatable {
    let objectChecksum: Swift.String?
    let objectChecksumAlgorithm: BackupStorageClientTypes.SummaryChecksumAlgorithm?
}

extension NotifyObjectCompleteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectChecksum = "ObjectChecksum"
        case objectChecksumAlgorithm = "ObjectChecksumAlgorithm"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectChecksumDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectChecksum)
        objectChecksum = objectChecksumDecoded
        let objectChecksumAlgorithmDecoded = try containerValues.decodeIfPresent(BackupStorageClientTypes.SummaryChecksumAlgorithm.self, forKey: .objectChecksumAlgorithm)
        objectChecksumAlgorithm = objectChecksumAlgorithmDecoded
    }
}

public struct PutChunkInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutChunkInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutChunkInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutChunkOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let data = input.operationInput.data {
            let datadata = data
            let databody = ClientRuntime.HttpBody.stream(datadata)
            input.builder.withBody(databody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutChunkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutChunkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutChunkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case data = "Data"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = self.data {
            try encodeContainer.encode(data.toBytes().getData(), forKey: .data)
        }
    }
}

extension PutChunkInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            let lengthQueryItem = ClientRuntime.URLQueryItem(name: "length".urlPercentEncoding(), value: Swift.String(length).urlPercentEncoding())
            items.append(lengthQueryItem)
            guard let checksum = checksum else {
                let message = "Creating a URL Query Item failed. checksum is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let checksumQueryItem = ClientRuntime.URLQueryItem(name: "checksum".urlPercentEncoding(), value: Swift.String(checksum).urlPercentEncoding())
            items.append(checksumQueryItem)
            guard let checksumAlgorithm = checksumAlgorithm else {
                let message = "Creating a URL Query Item failed. checksumAlgorithm is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let checksumAlgorithmQueryItem = ClientRuntime.URLQueryItem(name: "checksum-algorithm".urlPercentEncoding(), value: Swift.String(checksumAlgorithm.rawValue).urlPercentEncoding())
            items.append(checksumAlgorithmQueryItem)
            return items
        }
    }
}

extension PutChunkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupJobId = backupJobId else {
            return nil
        }
        guard let uploadId = uploadId else {
            return nil
        }
        return "/backup-jobs/\(backupJobId.urlPercentEncoding())/chunk/\(uploadId.urlPercentEncoding())/\(chunkIndex)"
    }
}

public struct PutChunkInput: Swift.Equatable {
    /// Backup job Id for the in-progress backup.
    /// This member is required.
    public var backupJobId: Swift.String?
    /// Data checksum
    /// This member is required.
    public var checksum: Swift.String?
    /// Checksum algorithm
    /// This member is required.
    public var checksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm?
    /// Describes this chunk's position relative to the other chunks
    /// This member is required.
    public var chunkIndex: Swift.Int
    /// Data to be uploaded
    /// This member is required.
    public var data: ClientRuntime.ByteStream?
    /// Data length
    /// This member is required.
    public var length: Swift.Int
    /// Upload Id for the in-progress upload.
    /// This member is required.
    public var uploadId: Swift.String?

    public init (
        backupJobId: Swift.String? = nil,
        checksum: Swift.String? = nil,
        checksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm? = nil,
        chunkIndex: Swift.Int = 0,
        data: ClientRuntime.ByteStream? = nil,
        length: Swift.Int = 0,
        uploadId: Swift.String? = nil
    )
    {
        self.backupJobId = backupJobId
        self.checksum = checksum
        self.checksumAlgorithm = checksumAlgorithm
        self.chunkIndex = chunkIndex
        self.data = data
        self.length = length
        self.uploadId = uploadId
    }
}

struct PutChunkInputBody: Swift.Equatable {
    let data: ClientRuntime.ByteStream?
}

extension PutChunkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case data = "Data"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .data)
        data = dataDecoded
    }
}

extension PutChunkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutChunkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalArgumentException" : self = .illegalArgumentException(try IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidKeyUsageException" : self = .kMSInvalidKeyUsageException(try KMSInvalidKeyUsageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotReadableInputStreamException" : self = .notReadableInputStreamException(try NotReadableInputStreamException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableException" : self = .retryableException(try RetryableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceInternalException" : self = .serviceInternalException(try ServiceInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutChunkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case illegalArgumentException(IllegalArgumentException)
    case kMSInvalidKeyUsageException(KMSInvalidKeyUsageException)
    case notReadableInputStreamException(NotReadableInputStreamException)
    case retryableException(RetryableException)
    case serviceInternalException(ServiceInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutChunkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutChunkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.chunkChecksum = output.chunkChecksum
            self.chunkChecksumAlgorithm = output.chunkChecksumAlgorithm
        } else {
            self.chunkChecksum = nil
            self.chunkChecksumAlgorithm = nil
        }
    }
}

public struct PutChunkOutputResponse: Swift.Equatable {
    /// Chunk checksum
    /// This member is required.
    public var chunkChecksum: Swift.String?
    /// Checksum algorithm
    /// This member is required.
    public var chunkChecksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm?

    public init (
        chunkChecksum: Swift.String? = nil,
        chunkChecksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm? = nil
    )
    {
        self.chunkChecksum = chunkChecksum
        self.chunkChecksumAlgorithm = chunkChecksumAlgorithm
    }
}

struct PutChunkOutputResponseBody: Swift.Equatable {
    let chunkChecksum: Swift.String?
    let chunkChecksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm?
}

extension PutChunkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chunkChecksum = "ChunkChecksum"
        case chunkChecksumAlgorithm = "ChunkChecksumAlgorithm"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let chunkChecksumDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .chunkChecksum)
        chunkChecksum = chunkChecksumDecoded
        let chunkChecksumAlgorithmDecoded = try containerValues.decodeIfPresent(BackupStorageClientTypes.DataChecksumAlgorithm.self, forKey: .chunkChecksumAlgorithm)
        chunkChecksumAlgorithm = chunkChecksumAlgorithmDecoded
    }
}

public struct PutObjectInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutObjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutObjectInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutObjectOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let inlineChunk = input.operationInput.inlineChunk {
            let inlineChunkdata = inlineChunk
            let inlineChunkbody = ClientRuntime.HttpBody.stream(inlineChunkdata)
            input.builder.withBody(inlineChunkbody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutObjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutObjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inlineChunk = "InlineChunk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inlineChunk = self.inlineChunk {
            try encodeContainer.encode(inlineChunk.toBytes().getData(), forKey: .inlineChunk)
        }
    }
}

extension PutObjectInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let inlineChunkChecksum = inlineChunkChecksum {
                let inlineChunkChecksumQueryItem = ClientRuntime.URLQueryItem(name: "checksum".urlPercentEncoding(), value: Swift.String(inlineChunkChecksum).urlPercentEncoding())
                items.append(inlineChunkChecksumQueryItem)
            }
            if let objectChecksum = objectChecksum {
                let objectChecksumQueryItem = ClientRuntime.URLQueryItem(name: "object-checksum".urlPercentEncoding(), value: Swift.String(objectChecksum).urlPercentEncoding())
                items.append(objectChecksumQueryItem)
            }
            if let objectChecksumAlgorithm = objectChecksumAlgorithm {
                let objectChecksumAlgorithmQueryItem = ClientRuntime.URLQueryItem(name: "object-checksum-algorithm".urlPercentEncoding(), value: Swift.String(objectChecksumAlgorithm.rawValue).urlPercentEncoding())
                items.append(objectChecksumAlgorithmQueryItem)
            }
            if inlineChunkLength != 0 {
                let inlineChunkLengthQueryItem = ClientRuntime.URLQueryItem(name: "length".urlPercentEncoding(), value: Swift.String(inlineChunkLength).urlPercentEncoding())
                items.append(inlineChunkLengthQueryItem)
            }
            if let inlineChunkChecksumAlgorithm = inlineChunkChecksumAlgorithm {
                let inlineChunkChecksumAlgorithmQueryItem = ClientRuntime.URLQueryItem(name: "checksum-algorithm".urlPercentEncoding(), value: Swift.String(inlineChunkChecksumAlgorithm).urlPercentEncoding())
                items.append(inlineChunkChecksumAlgorithmQueryItem)
            }
            if let metadataString = metadataString {
                let metadataStringQueryItem = ClientRuntime.URLQueryItem(name: "metadata-string".urlPercentEncoding(), value: Swift.String(metadataString).urlPercentEncoding())
                items.append(metadataStringQueryItem)
            }
            if throwOnDuplicate != false {
                let throwOnDuplicateQueryItem = ClientRuntime.URLQueryItem(name: "throwOnDuplicate".urlPercentEncoding(), value: Swift.String(throwOnDuplicate).urlPercentEncoding())
                items.append(throwOnDuplicateQueryItem)
            }
            return items
        }
    }
}

extension PutObjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupJobId = backupJobId else {
            return nil
        }
        guard let objectName = objectName else {
            return nil
        }
        return "/backup-jobs/\(backupJobId.urlPercentEncoding())/object/\(objectName.urlPercentEncoding())/put-object"
    }
}

public struct PutObjectInput: Swift.Equatable {
    /// Backup job Id for the in-progress backup.
    /// This member is required.
    public var backupJobId: Swift.String?
    /// Inline chunk data to be uploaded.
    public var inlineChunk: ClientRuntime.ByteStream?
    /// Inline chunk checksum
    public var inlineChunkChecksum: Swift.String?
    /// Inline chunk checksum algorithm
    public var inlineChunkChecksumAlgorithm: Swift.String?
    /// Length of the inline chunk data.
    public var inlineChunkLength: Swift.Int
    /// Store user defined metadata like backup checksum, disk ids, restore metadata etc.
    public var metadataString: Swift.String?
    /// object checksum
    public var objectChecksum: Swift.String?
    /// object checksum algorithm
    public var objectChecksumAlgorithm: BackupStorageClientTypes.SummaryChecksumAlgorithm?
    /// The name of the Object to be uploaded.
    /// This member is required.
    public var objectName: Swift.String?
    /// Throw an exception if Object name is already exist.
    public var throwOnDuplicate: Swift.Bool

    public init (
        backupJobId: Swift.String? = nil,
        inlineChunk: ClientRuntime.ByteStream? = nil,
        inlineChunkChecksum: Swift.String? = nil,
        inlineChunkChecksumAlgorithm: Swift.String? = nil,
        inlineChunkLength: Swift.Int = 0,
        metadataString: Swift.String? = nil,
        objectChecksum: Swift.String? = nil,
        objectChecksumAlgorithm: BackupStorageClientTypes.SummaryChecksumAlgorithm? = nil,
        objectName: Swift.String? = nil,
        throwOnDuplicate: Swift.Bool = false
    )
    {
        self.backupJobId = backupJobId
        self.inlineChunk = inlineChunk
        self.inlineChunkChecksum = inlineChunkChecksum
        self.inlineChunkChecksumAlgorithm = inlineChunkChecksumAlgorithm
        self.inlineChunkLength = inlineChunkLength
        self.metadataString = metadataString
        self.objectChecksum = objectChecksum
        self.objectChecksumAlgorithm = objectChecksumAlgorithm
        self.objectName = objectName
        self.throwOnDuplicate = throwOnDuplicate
    }
}

struct PutObjectInputBody: Swift.Equatable {
    let inlineChunk: ClientRuntime.ByteStream?
}

extension PutObjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inlineChunk = "InlineChunk"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inlineChunkDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .inlineChunk)
        inlineChunk = inlineChunkDecoded
    }
}

extension PutObjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutObjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalArgumentException" : self = .illegalArgumentException(try IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidKeyUsageException" : self = .kMSInvalidKeyUsageException(try KMSInvalidKeyUsageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotReadableInputStreamException" : self = .notReadableInputStreamException(try NotReadableInputStreamException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableException" : self = .retryableException(try RetryableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceInternalException" : self = .serviceInternalException(try ServiceInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutObjectOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case illegalArgumentException(IllegalArgumentException)
    case kMSInvalidKeyUsageException(KMSInvalidKeyUsageException)
    case notReadableInputStreamException(NotReadableInputStreamException)
    case retryableException(RetryableException)
    case serviceInternalException(ServiceInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutObjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutObjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.inlineChunkChecksum = output.inlineChunkChecksum
            self.inlineChunkChecksumAlgorithm = output.inlineChunkChecksumAlgorithm
            self.objectChecksum = output.objectChecksum
            self.objectChecksumAlgorithm = output.objectChecksumAlgorithm
        } else {
            self.inlineChunkChecksum = nil
            self.inlineChunkChecksumAlgorithm = nil
            self.objectChecksum = nil
            self.objectChecksumAlgorithm = nil
        }
    }
}

public struct PutObjectOutputResponse: Swift.Equatable {
    /// Inline chunk checksum
    /// This member is required.
    public var inlineChunkChecksum: Swift.String?
    /// Inline chunk checksum algorithm
    /// This member is required.
    public var inlineChunkChecksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm?
    /// object checksum
    /// This member is required.
    public var objectChecksum: Swift.String?
    /// object checksum algorithm
    /// This member is required.
    public var objectChecksumAlgorithm: BackupStorageClientTypes.SummaryChecksumAlgorithm?

    public init (
        inlineChunkChecksum: Swift.String? = nil,
        inlineChunkChecksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm? = nil,
        objectChecksum: Swift.String? = nil,
        objectChecksumAlgorithm: BackupStorageClientTypes.SummaryChecksumAlgorithm? = nil
    )
    {
        self.inlineChunkChecksum = inlineChunkChecksum
        self.inlineChunkChecksumAlgorithm = inlineChunkChecksumAlgorithm
        self.objectChecksum = objectChecksum
        self.objectChecksumAlgorithm = objectChecksumAlgorithm
    }
}

struct PutObjectOutputResponseBody: Swift.Equatable {
    let inlineChunkChecksum: Swift.String?
    let inlineChunkChecksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm?
    let objectChecksum: Swift.String?
    let objectChecksumAlgorithm: BackupStorageClientTypes.SummaryChecksumAlgorithm?
}

extension PutObjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inlineChunkChecksum = "InlineChunkChecksum"
        case inlineChunkChecksumAlgorithm = "InlineChunkChecksumAlgorithm"
        case objectChecksum = "ObjectChecksum"
        case objectChecksumAlgorithm = "ObjectChecksumAlgorithm"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inlineChunkChecksumDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inlineChunkChecksum)
        inlineChunkChecksum = inlineChunkChecksumDecoded
        let inlineChunkChecksumAlgorithmDecoded = try containerValues.decodeIfPresent(BackupStorageClientTypes.DataChecksumAlgorithm.self, forKey: .inlineChunkChecksumAlgorithm)
        inlineChunkChecksumAlgorithm = inlineChunkChecksumAlgorithmDecoded
        let objectChecksumDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectChecksum)
        objectChecksum = objectChecksumDecoded
        let objectChecksumAlgorithmDecoded = try containerValues.decodeIfPresent(BackupStorageClientTypes.SummaryChecksumAlgorithm.self, forKey: .objectChecksumAlgorithm)
        objectChecksumAlgorithm = objectChecksumAlgorithmDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Non-retryable exception. Attempted to make an operation on non-existing or expired resource.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RetryableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RetryableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Retryable exception. In general indicates internal failure that can be fixed by retry.
public struct RetryableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RetryableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RetryableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceInternalException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceInternalExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Deprecated. To be removed from the model.
public struct ServiceInternalException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceInternalExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceInternalExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Retryable exception, indicates internal server error.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StartObjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case throwOnDuplicate = "ThrowOnDuplicate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if throwOnDuplicate != false {
            try encodeContainer.encode(throwOnDuplicate, forKey: .throwOnDuplicate)
        }
    }
}

extension StartObjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupJobId = backupJobId else {
            return nil
        }
        guard let objectName = objectName else {
            return nil
        }
        return "/backup-jobs/\(backupJobId.urlPercentEncoding())/object/\(objectName.urlPercentEncoding())"
    }
}

public struct StartObjectInput: Swift.Equatable {
    /// Backup job Id for the in-progress backup
    /// This member is required.
    public var backupJobId: Swift.String?
    /// Name for the object.
    /// This member is required.
    public var objectName: Swift.String?
    /// Throw an exception if Object name is already exist.
    public var throwOnDuplicate: Swift.Bool

    public init (
        backupJobId: Swift.String? = nil,
        objectName: Swift.String? = nil,
        throwOnDuplicate: Swift.Bool = false
    )
    {
        self.backupJobId = backupJobId
        self.objectName = objectName
        self.throwOnDuplicate = throwOnDuplicate
    }
}

struct StartObjectInputBody: Swift.Equatable {
    let throwOnDuplicate: Swift.Bool
}

extension StartObjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case throwOnDuplicate = "ThrowOnDuplicate"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let throwOnDuplicateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .throwOnDuplicate) ?? false
        throwOnDuplicate = throwOnDuplicateDecoded
    }
}

extension StartObjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartObjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataAlreadyExistsException" : self = .dataAlreadyExistsException(try DataAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalArgumentException" : self = .illegalArgumentException(try IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RetryableException" : self = .retryableException(try RetryableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceInternalException" : self = .serviceInternalException(try ServiceInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartObjectOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case dataAlreadyExistsException(DataAlreadyExistsException)
    case illegalArgumentException(IllegalArgumentException)
    case resourceNotFoundException(ResourceNotFoundException)
    case retryableException(RetryableException)
    case serviceInternalException(ServiceInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartObjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartObjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.uploadId = output.uploadId
        } else {
            self.uploadId = nil
        }
    }
}

public struct StartObjectOutputResponse: Swift.Equatable {
    /// Upload Id for a given upload.
    /// This member is required.
    public var uploadId: Swift.String?

    public init (
        uploadId: Swift.String? = nil
    )
    {
        self.uploadId = uploadId
    }
}

struct StartObjectOutputResponseBody: Swift.Equatable {
    let uploadId: Swift.String?
}

extension StartObjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case uploadId = "UploadId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
    }
}

extension BackupStorageClientTypes {
    public enum SummaryChecksumAlgorithm: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case summary
        case sdkUnknown(Swift.String)

        public static var allCases: [SummaryChecksumAlgorithm] {
            return [
                .summary,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .summary: return "SUMMARY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SummaryChecksumAlgorithm(rawValue: rawValue) ?? SummaryChecksumAlgorithm.sdkUnknown(rawValue)
        }
    }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Increased rate over throttling limits. Can be retried with exponential backoff.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
