// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDenied" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BackupStorageClientTypes.BackupObject: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chunksCount = "ChunksCount"
        case metadataString = "MetadataString"
        case name = "Name"
        case objectChecksum = "ObjectChecksum"
        case objectChecksumAlgorithm = "ObjectChecksumAlgorithm"
        case objectToken = "ObjectToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chunksCount = self.chunksCount {
            try encodeContainer.encode(chunksCount, forKey: .chunksCount)
        }
        if let metadataString = self.metadataString {
            try encodeContainer.encode(metadataString, forKey: .metadataString)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let objectChecksum = self.objectChecksum {
            try encodeContainer.encode(objectChecksum, forKey: .objectChecksum)
        }
        if let objectChecksumAlgorithm = self.objectChecksumAlgorithm {
            try encodeContainer.encode(objectChecksumAlgorithm.rawValue, forKey: .objectChecksumAlgorithm)
        }
        if let objectToken = self.objectToken {
            try encodeContainer.encode(objectToken, forKey: .objectToken)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let chunksCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .chunksCount)
        chunksCount = chunksCountDecoded
        let metadataStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadataString)
        metadataString = metadataStringDecoded
        let objectChecksumDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectChecksum)
        objectChecksum = objectChecksumDecoded
        let objectChecksumAlgorithmDecoded = try containerValues.decodeIfPresent(BackupStorageClientTypes.SummaryChecksumAlgorithm.self, forKey: .objectChecksumAlgorithm)
        objectChecksumAlgorithm = objectChecksumAlgorithmDecoded
        let objectTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectToken)
        objectToken = objectTokenDecoded
    }
}

extension BackupStorageClientTypes {
    /// Object
    public struct BackupObject: Swift.Equatable {
        /// Number of chunks in object
        public var chunksCount: Swift.Int?
        /// Metadata string associated with the Object
        public var metadataString: Swift.String?
        /// Object name
        /// This member is required.
        public var name: Swift.String?
        /// Object checksum
        /// This member is required.
        public var objectChecksum: Swift.String?
        /// Checksum algorithm
        /// This member is required.
        public var objectChecksumAlgorithm: BackupStorageClientTypes.SummaryChecksumAlgorithm?
        /// Object token
        /// This member is required.
        public var objectToken: Swift.String?

        public init(
            chunksCount: Swift.Int? = nil,
            metadataString: Swift.String? = nil,
            name: Swift.String? = nil,
            objectChecksum: Swift.String? = nil,
            objectChecksumAlgorithm: BackupStorageClientTypes.SummaryChecksumAlgorithm? = nil,
            objectToken: Swift.String? = nil
        )
        {
            self.chunksCount = chunksCount
            self.metadataString = metadataString
            self.name = name
            self.objectChecksum = objectChecksum
            self.objectChecksumAlgorithm = objectChecksumAlgorithm
            self.objectToken = objectToken
        }
    }

}

extension BackupStorageClientTypes.Chunk: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checksum = "Checksum"
        case checksumAlgorithm = "ChecksumAlgorithm"
        case chunkToken = "ChunkToken"
        case index = "Index"
        case length = "Length"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checksum = self.checksum {
            try encodeContainer.encode(checksum, forKey: .checksum)
        }
        if let checksumAlgorithm = self.checksumAlgorithm {
            try encodeContainer.encode(checksumAlgorithm.rawValue, forKey: .checksumAlgorithm)
        }
        if let chunkToken = self.chunkToken {
            try encodeContainer.encode(chunkToken, forKey: .chunkToken)
        }
        if index != 0 {
            try encodeContainer.encode(index, forKey: .index)
        }
        if length != 0 {
            try encodeContainer.encode(length, forKey: .length)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .index) ?? 0
        index = indexDecoded
        let lengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .length) ?? 0
        length = lengthDecoded
        let checksumDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .checksum)
        checksum = checksumDecoded
        let checksumAlgorithmDecoded = try containerValues.decodeIfPresent(BackupStorageClientTypes.DataChecksumAlgorithm.self, forKey: .checksumAlgorithm)
        checksumAlgorithm = checksumAlgorithmDecoded
        let chunkTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .chunkToken)
        chunkToken = chunkTokenDecoded
    }
}

extension BackupStorageClientTypes {
    /// Chunk
    public struct Chunk: Swift.Equatable {
        /// Chunk checksum
        /// This member is required.
        public var checksum: Swift.String?
        /// Checksum algorithm
        /// This member is required.
        public var checksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm?
        /// Chunk token
        /// This member is required.
        public var chunkToken: Swift.String?
        /// Chunk index
        /// This member is required.
        public var index: Swift.Int
        /// Chunk length
        /// This member is required.
        public var length: Swift.Int

        public init(
            checksum: Swift.String? = nil,
            checksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm? = nil,
            chunkToken: Swift.String? = nil,
            index: Swift.Int = 0,
            length: Swift.Int = 0
        )
        {
            self.checksum = checksum
            self.checksumAlgorithm = checksumAlgorithm
            self.chunkToken = chunkToken
            self.index = index
            self.length = length
        }
    }

}

extension DataAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DataAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.checksum = output.checksum
            self.properties.checksumAlgorithm = output.checksumAlgorithm
            self.properties.message = output.message
        } else {
            self.properties.checksum = nil
            self.properties.checksumAlgorithm = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Non-retryable exception. Attempted to create already existing object or chunk. This message contains a checksum of already presented data.
public struct DataAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Data checksum used
        public internal(set) var checksum: Swift.String? = nil
        /// Checksum algorithm used
        public internal(set) var checksumAlgorithm: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DataAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        checksum: Swift.String? = nil,
        checksumAlgorithm: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.checksum = checksum
        self.properties.checksumAlgorithm = checksumAlgorithm
        self.properties.message = message
    }
}

struct DataAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let checksum: Swift.String?
    let checksumAlgorithm: Swift.String?
}

extension DataAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checksum = "Checksum"
        case checksumAlgorithm = "ChecksumAlgorithm"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let checksumDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .checksum)
        checksum = checksumDecoded
        let checksumAlgorithmDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .checksumAlgorithm)
        checksumAlgorithm = checksumAlgorithmDecoded
    }
}

extension BackupStorageClientTypes {
    public enum DataChecksumAlgorithm: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sha256
        case sdkUnknown(Swift.String)

        public static var allCases: [DataChecksumAlgorithm] {
            return [
                .sha256,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sha256: return "SHA256"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataChecksumAlgorithm(rawValue: rawValue) ?? DataChecksumAlgorithm.sdkUnknown(rawValue)
        }
    }
}

extension DeleteObjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupJobId = backupJobId else {
            return nil
        }
        guard let objectName = objectName else {
            return nil
        }
        return "/backup-jobs/\(backupJobId.urlPercentEncoding())/object/\(objectName.urlPercentEncoding())"
    }
}

public struct DeleteObjectInput: Swift.Equatable {
    /// Backup job Id for the in-progress backup.
    /// This member is required.
    public var backupJobId: Swift.String?
    /// The name of the Object.
    /// This member is required.
    public var objectName: Swift.String?

    public init(
        backupJobId: Swift.String? = nil,
        objectName: Swift.String? = nil
    )
    {
        self.backupJobId = backupJobId
        self.objectName = objectName
    }
}

struct DeleteObjectInputBody: Swift.Equatable {
}

extension DeleteObjectInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteObjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteObjectOutput: Swift.Equatable {

    public init() { }
}

enum DeleteObjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableException": return try await RetryableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceInternalException": return try await ServiceInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetChunkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let storageJobId = storageJobId else {
            return nil
        }
        guard let chunkToken = chunkToken else {
            return nil
        }
        return "/restore-jobs/\(storageJobId.urlPercentEncoding())/chunk/\(chunkToken.urlPercentEncoding())"
    }
}

public struct GetChunkInput: Swift.Equatable {
    /// Chunk token
    /// This member is required.
    public var chunkToken: Swift.String?
    /// Storage job id
    /// This member is required.
    public var storageJobId: Swift.String?

    public init(
        chunkToken: Swift.String? = nil,
        storageJobId: Swift.String? = nil
    )
    {
        self.chunkToken = chunkToken
        self.storageJobId = storageJobId
    }
}

struct GetChunkInputBody: Swift.Equatable {
}

extension GetChunkInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetChunkOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let checksumHeaderValue = httpResponse.headers.value(for: "x-amz-checksum") {
            self.checksum = checksumHeaderValue
        } else {
            self.checksum = nil
        }
        if let checksumAlgorithmHeaderValue = httpResponse.headers.value(for: "x-amz-checksum-algorithm") {
            self.checksumAlgorithm = BackupStorageClientTypes.DataChecksumAlgorithm(rawValue: checksumAlgorithmHeaderValue)
        } else {
            self.checksumAlgorithm = nil
        }
        if let lengthHeaderValue = httpResponse.headers.value(for: "x-amz-data-length") {
            self.length = Swift.Int(lengthHeaderValue) ?? 0
        } else {
            self.length = 0
        }
        switch httpResponse.body {
        case .data(let data):
            self.data = .data(data)
        case .stream(let stream):
            self.data = .stream(stream)
        case .none:
            self.data = nil
        }
    }
}

public struct GetChunkOutput: Swift.Equatable {
    /// Data checksum
    /// This member is required.
    public var checksum: Swift.String?
    /// Checksum algorithm
    /// This member is required.
    public var checksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm?
    /// Chunk data
    /// This member is required.
    public var data: ClientRuntime.ByteStream?
    /// Data length
    /// This member is required.
    public var length: Swift.Int

    public init(
        checksum: Swift.String? = nil,
        checksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm? = nil,
        data: ClientRuntime.ByteStream? = nil,
        length: Swift.Int = 0
    )
    {
        self.checksum = checksum
        self.checksumAlgorithm = checksumAlgorithm
        self.data = data
        self.length = length
    }
}

struct GetChunkOutputBody: Swift.Equatable {
    let data: ClientRuntime.ByteStream?
}

extension GetChunkOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case data = "Data"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .data)
        data = dataDecoded
    }
}

enum GetChunkOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSInvalidKeyUsageException": return try await KMSInvalidKeyUsageException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableException": return try await RetryableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceInternalException": return try await ServiceInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetObjectMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let storageJobId = storageJobId else {
            return nil
        }
        guard let objectToken = objectToken else {
            return nil
        }
        return "/restore-jobs/\(storageJobId.urlPercentEncoding())/object/\(objectToken.urlPercentEncoding())/metadata"
    }
}

public struct GetObjectMetadataInput: Swift.Equatable {
    /// Object token.
    /// This member is required.
    public var objectToken: Swift.String?
    /// Backup job id for the in-progress backup.
    /// This member is required.
    public var storageJobId: Swift.String?

    public init(
        objectToken: Swift.String? = nil,
        storageJobId: Swift.String? = nil
    )
    {
        self.objectToken = objectToken
        self.storageJobId = storageJobId
    }
}

struct GetObjectMetadataInputBody: Swift.Equatable {
}

extension GetObjectMetadataInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetObjectMetadataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let metadataBlobChecksumHeaderValue = httpResponse.headers.value(for: "x-amz-checksum") {
            self.metadataBlobChecksum = metadataBlobChecksumHeaderValue
        } else {
            self.metadataBlobChecksum = nil
        }
        if let metadataBlobChecksumAlgorithmHeaderValue = httpResponse.headers.value(for: "x-amz-checksum-algorithm") {
            self.metadataBlobChecksumAlgorithm = BackupStorageClientTypes.DataChecksumAlgorithm(rawValue: metadataBlobChecksumAlgorithmHeaderValue)
        } else {
            self.metadataBlobChecksumAlgorithm = nil
        }
        if let metadataBlobLengthHeaderValue = httpResponse.headers.value(for: "x-amz-data-length") {
            self.metadataBlobLength = Swift.Int(metadataBlobLengthHeaderValue) ?? 0
        } else {
            self.metadataBlobLength = 0
        }
        if let metadataStringHeaderValue = httpResponse.headers.value(for: "x-amz-metadata-string") {
            self.metadataString = metadataStringHeaderValue
        } else {
            self.metadataString = nil
        }
        switch httpResponse.body {
        case .data(let data):
            self.metadataBlob = .data(data)
        case .stream(let stream):
            self.metadataBlob = .stream(stream)
        case .none:
            self.metadataBlob = nil
        }
    }
}

public struct GetObjectMetadataOutput: Swift.Equatable {
    /// Metadata blob.
    public var metadataBlob: ClientRuntime.ByteStream?
    /// MetadataBlob checksum.
    public var metadataBlobChecksum: Swift.String?
    /// Checksum algorithm.
    public var metadataBlobChecksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm?
    /// The size of MetadataBlob.
    public var metadataBlobLength: Swift.Int
    /// Metadata string.
    public var metadataString: Swift.String?

    public init(
        metadataBlob: ClientRuntime.ByteStream? = nil,
        metadataBlobChecksum: Swift.String? = nil,
        metadataBlobChecksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm? = nil,
        metadataBlobLength: Swift.Int = 0,
        metadataString: Swift.String? = nil
    )
    {
        self.metadataBlob = metadataBlob
        self.metadataBlobChecksum = metadataBlobChecksum
        self.metadataBlobChecksumAlgorithm = metadataBlobChecksumAlgorithm
        self.metadataBlobLength = metadataBlobLength
        self.metadataString = metadataString
    }
}

struct GetObjectMetadataOutputBody: Swift.Equatable {
    let metadataBlob: ClientRuntime.ByteStream?
}

extension GetObjectMetadataOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadataBlob = "MetadataBlob"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataBlobDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .metadataBlob)
        metadataBlob = metadataBlobDecoded
    }
}

enum GetObjectMetadataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSInvalidKeyUsageException": return try await KMSInvalidKeyUsageException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableException": return try await RetryableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceInternalException": return try await ServiceInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IllegalArgumentException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: IllegalArgumentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Non-retryable exception, indicates client error (wrong argument passed to API). See exception message for details.
public struct IllegalArgumentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IllegalArgumentException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct IllegalArgumentExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension IllegalArgumentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSInvalidKeyUsageException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: KMSInvalidKeyUsageExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Non-retryable exception. Indicates the KMS key usage is incorrect. See exception message for details.
public struct KMSInvalidKeyUsageException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSInvalidKeyUsageException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct KMSInvalidKeyUsageExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension KMSInvalidKeyUsageExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListChunksInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListChunksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let storageJobId = storageJobId else {
            return nil
        }
        guard let objectToken = objectToken else {
            return nil
        }
        return "/restore-jobs/\(storageJobId.urlPercentEncoding())/chunks/\(objectToken.urlPercentEncoding())/list"
    }
}

public struct ListChunksInput: Swift.Equatable {
    /// Maximum number of chunks
    public var maxResults: Swift.Int?
    /// Pagination token
    public var nextToken: Swift.String?
    /// Object token
    /// This member is required.
    public var objectToken: Swift.String?
    /// Storage job id
    /// This member is required.
    public var storageJobId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        objectToken: Swift.String? = nil,
        storageJobId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectToken = objectToken
        self.storageJobId = storageJobId
    }
}

struct ListChunksInputBody: Swift.Equatable {
}

extension ListChunksInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListChunksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListChunksOutputBody = try responseDecoder.decode(responseBody: data)
            self.chunkList = output.chunkList
            self.nextToken = output.nextToken
        } else {
            self.chunkList = nil
            self.nextToken = nil
        }
    }
}

public struct ListChunksOutput: Swift.Equatable {
    /// List of chunks
    /// This member is required.
    public var chunkList: [BackupStorageClientTypes.Chunk]?
    /// Pagination token
    public var nextToken: Swift.String?

    public init(
        chunkList: [BackupStorageClientTypes.Chunk]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.chunkList = chunkList
        self.nextToken = nextToken
    }
}

struct ListChunksOutputBody: Swift.Equatable {
    let chunkList: [BackupStorageClientTypes.Chunk]?
    let nextToken: Swift.String?
}

extension ListChunksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chunkList = "ChunkList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let chunkListContainer = try containerValues.decodeIfPresent([BackupStorageClientTypes.Chunk?].self, forKey: .chunkList)
        var chunkListDecoded0:[BackupStorageClientTypes.Chunk]? = nil
        if let chunkListContainer = chunkListContainer {
            chunkListDecoded0 = [BackupStorageClientTypes.Chunk]()
            for structure0 in chunkListContainer {
                if let structure0 = structure0 {
                    chunkListDecoded0?.append(structure0)
                }
            }
        }
        chunkList = chunkListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListChunksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableException": return try await RetryableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceInternalException": return try await ServiceInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListObjectsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let startingObjectName = startingObjectName {
                let startingObjectNameQueryItem = ClientRuntime.URLQueryItem(name: "starting-object-name".urlPercentEncoding(), value: Swift.String(startingObjectName).urlPercentEncoding())
                items.append(startingObjectNameQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let createdAfter = createdAfter {
                let createdAfterQueryItem = ClientRuntime.URLQueryItem(name: "created-after".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: createdAfter)).urlPercentEncoding())
                items.append(createdAfterQueryItem)
            }
            if let startingObjectPrefix = startingObjectPrefix {
                let startingObjectPrefixQueryItem = ClientRuntime.URLQueryItem(name: "starting-object-prefix".urlPercentEncoding(), value: Swift.String(startingObjectPrefix).urlPercentEncoding())
                items.append(startingObjectPrefixQueryItem)
            }
            if let createdBefore = createdBefore {
                let createdBeforeQueryItem = ClientRuntime.URLQueryItem(name: "created-before".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: createdBefore)).urlPercentEncoding())
                items.append(createdBeforeQueryItem)
            }
            return items
        }
    }
}

extension ListObjectsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let storageJobId = storageJobId else {
            return nil
        }
        return "/restore-jobs/\(storageJobId.urlPercentEncoding())/objects/list"
    }
}

public struct ListObjectsInput: Swift.Equatable {
    /// (Optional) Created after filter
    public var createdAfter: ClientRuntime.Date?
    /// (Optional) Created before filter
    public var createdBefore: ClientRuntime.Date?
    /// Maximum objects count
    public var maxResults: Swift.Int?
    /// Pagination token
    public var nextToken: Swift.String?
    /// Optional, specifies the starting Object name to list from. Ignored if NextToken is not NULL
    public var startingObjectName: Swift.String?
    /// Optional, specifies the starting Object prefix to list from. Ignored if NextToken is not NULL
    public var startingObjectPrefix: Swift.String?
    /// Storage job id
    /// This member is required.
    public var storageJobId: Swift.String?

    public init(
        createdAfter: ClientRuntime.Date? = nil,
        createdBefore: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startingObjectName: Swift.String? = nil,
        startingObjectPrefix: Swift.String? = nil,
        storageJobId: Swift.String? = nil
    )
    {
        self.createdAfter = createdAfter
        self.createdBefore = createdBefore
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startingObjectName = startingObjectName
        self.startingObjectPrefix = startingObjectPrefix
        self.storageJobId = storageJobId
    }
}

struct ListObjectsInputBody: Swift.Equatable {
}

extension ListObjectsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListObjectsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListObjectsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.objectList = output.objectList
        } else {
            self.nextToken = nil
            self.objectList = nil
        }
    }
}

public struct ListObjectsOutput: Swift.Equatable {
    /// Pagination token
    public var nextToken: Swift.String?
    /// Object list
    /// This member is required.
    public var objectList: [BackupStorageClientTypes.BackupObject]?

    public init(
        nextToken: Swift.String? = nil,
        objectList: [BackupStorageClientTypes.BackupObject]? = nil
    )
    {
        self.nextToken = nextToken
        self.objectList = objectList
    }
}

struct ListObjectsOutputBody: Swift.Equatable {
    let objectList: [BackupStorageClientTypes.BackupObject]?
    let nextToken: Swift.String?
}

extension ListObjectsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case objectList = "ObjectList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectListContainer = try containerValues.decodeIfPresent([BackupStorageClientTypes.BackupObject?].self, forKey: .objectList)
        var objectListDecoded0:[BackupStorageClientTypes.BackupObject]? = nil
        if let objectListContainer = objectListContainer {
            objectListDecoded0 = [BackupStorageClientTypes.BackupObject]()
            for structure0 in objectListContainer {
                if let structure0 = structure0 {
                    objectListDecoded0?.append(structure0)
                }
            }
        }
        objectList = objectListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListObjectsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSInvalidKeyUsageException": return try await KMSInvalidKeyUsageException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableException": return try await RetryableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceInternalException": return try await ServiceInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension NotReadableInputStreamException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NotReadableInputStreamExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Retryalble exception. Indicated issues while reading an input stream due to the networking issues or connection drop on the client side.
public struct NotReadableInputStreamException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotReadableInputStreamException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NotReadableInputStreamExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotReadableInputStreamExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct NotifyObjectCompleteInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "NotifyObjectCompleteInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<NotifyObjectCompleteInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<NotifyObjectCompleteOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let metadataBlob = input.operationInput.metadataBlob {
            let metadataBlobBody = ClientRuntime.HttpBody(byteStream: metadataBlob)
            input.builder.withBody(metadataBlobBody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<NotifyObjectCompleteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<NotifyObjectCompleteOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension NotifyObjectCompleteInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadataBlob = "MetadataBlob"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadataBlob = self.metadataBlob {
            try encodeContainer.encode(metadataBlob, forKey: .metadataBlob)
        }
    }
}

extension NotifyObjectCompleteInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let objectChecksum = objectChecksum else {
                let message = "Creating a URL Query Item failed. objectChecksum is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let objectChecksumQueryItem = ClientRuntime.URLQueryItem(name: "checksum".urlPercentEncoding(), value: Swift.String(objectChecksum).urlPercentEncoding())
            items.append(objectChecksumQueryItem)
            guard let objectChecksumAlgorithm = objectChecksumAlgorithm else {
                let message = "Creating a URL Query Item failed. objectChecksumAlgorithm is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let objectChecksumAlgorithmQueryItem = ClientRuntime.URLQueryItem(name: "checksum-algorithm".urlPercentEncoding(), value: Swift.String(objectChecksumAlgorithm.rawValue).urlPercentEncoding())
            items.append(objectChecksumAlgorithmQueryItem)
            if let metadataBlobLength = metadataBlobLength {
                let metadataBlobLengthQueryItem = ClientRuntime.URLQueryItem(name: "metadata-blob-length".urlPercentEncoding(), value: Swift.String(metadataBlobLength).urlPercentEncoding())
                items.append(metadataBlobLengthQueryItem)
            }
            if let metadataBlobChecksum = metadataBlobChecksum {
                let metadataBlobChecksumQueryItem = ClientRuntime.URLQueryItem(name: "metadata-checksum".urlPercentEncoding(), value: Swift.String(metadataBlobChecksum).urlPercentEncoding())
                items.append(metadataBlobChecksumQueryItem)
            }
            if let metadataBlobChecksumAlgorithm = metadataBlobChecksumAlgorithm {
                let metadataBlobChecksumAlgorithmQueryItem = ClientRuntime.URLQueryItem(name: "metadata-checksum-algorithm".urlPercentEncoding(), value: Swift.String(metadataBlobChecksumAlgorithm.rawValue).urlPercentEncoding())
                items.append(metadataBlobChecksumAlgorithmQueryItem)
            }
            if let metadataString = metadataString {
                let metadataStringQueryItem = ClientRuntime.URLQueryItem(name: "metadata-string".urlPercentEncoding(), value: Swift.String(metadataString).urlPercentEncoding())
                items.append(metadataStringQueryItem)
            }
            return items
        }
    }
}

extension NotifyObjectCompleteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupJobId = backupJobId else {
            return nil
        }
        guard let uploadId = uploadId else {
            return nil
        }
        return "/backup-jobs/\(backupJobId.urlPercentEncoding())/object/\(uploadId.urlPercentEncoding())/complete"
    }
}

public struct NotifyObjectCompleteInput: Swift.Equatable {
    /// Backup job Id for the in-progress backup
    /// This member is required.
    public var backupJobId: Swift.String?
    /// Optional metadata associated with an Object. Maximum length is 4MB.
    public var metadataBlob: ClientRuntime.ByteStream?
    /// Checksum of MetadataBlob.
    public var metadataBlobChecksum: Swift.String?
    /// Checksum algorithm.
    public var metadataBlobChecksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm?
    /// The size of MetadataBlob.
    public var metadataBlobLength: Swift.Int?
    /// Optional metadata associated with an Object. Maximum string length is 256 bytes.
    public var metadataString: Swift.String?
    /// Object checksum
    /// This member is required.
    public var objectChecksum: Swift.String?
    /// Checksum algorithm
    /// This member is required.
    public var objectChecksumAlgorithm: BackupStorageClientTypes.SummaryChecksumAlgorithm?
    /// Upload Id for the in-progress upload
    /// This member is required.
    public var uploadId: Swift.String?

    public init(
        backupJobId: Swift.String? = nil,
        metadataBlob: ClientRuntime.ByteStream? = nil,
        metadataBlobChecksum: Swift.String? = nil,
        metadataBlobChecksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm? = nil,
        metadataBlobLength: Swift.Int? = nil,
        metadataString: Swift.String? = nil,
        objectChecksum: Swift.String? = nil,
        objectChecksumAlgorithm: BackupStorageClientTypes.SummaryChecksumAlgorithm? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.backupJobId = backupJobId
        self.metadataBlob = metadataBlob
        self.metadataBlobChecksum = metadataBlobChecksum
        self.metadataBlobChecksumAlgorithm = metadataBlobChecksumAlgorithm
        self.metadataBlobLength = metadataBlobLength
        self.metadataString = metadataString
        self.objectChecksum = objectChecksum
        self.objectChecksumAlgorithm = objectChecksumAlgorithm
        self.uploadId = uploadId
    }
}

struct NotifyObjectCompleteInputBody: Swift.Equatable {
    let metadataBlob: ClientRuntime.ByteStream?
}

extension NotifyObjectCompleteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadataBlob = "MetadataBlob"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataBlobDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .metadataBlob)
        metadataBlob = metadataBlobDecoded
    }
}

extension NotifyObjectCompleteOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NotifyObjectCompleteOutputBody = try responseDecoder.decode(responseBody: data)
            self.objectChecksum = output.objectChecksum
            self.objectChecksumAlgorithm = output.objectChecksumAlgorithm
        } else {
            self.objectChecksum = nil
            self.objectChecksumAlgorithm = nil
        }
    }
}

public struct NotifyObjectCompleteOutput: Swift.Equatable {
    /// Object checksum
    /// This member is required.
    public var objectChecksum: Swift.String?
    /// Checksum algorithm
    /// This member is required.
    public var objectChecksumAlgorithm: BackupStorageClientTypes.SummaryChecksumAlgorithm?

    public init(
        objectChecksum: Swift.String? = nil,
        objectChecksumAlgorithm: BackupStorageClientTypes.SummaryChecksumAlgorithm? = nil
    )
    {
        self.objectChecksum = objectChecksum
        self.objectChecksumAlgorithm = objectChecksumAlgorithm
    }
}

struct NotifyObjectCompleteOutputBody: Swift.Equatable {
    let objectChecksum: Swift.String?
    let objectChecksumAlgorithm: BackupStorageClientTypes.SummaryChecksumAlgorithm?
}

extension NotifyObjectCompleteOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectChecksum = "ObjectChecksum"
        case objectChecksumAlgorithm = "ObjectChecksumAlgorithm"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectChecksumDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectChecksum)
        objectChecksum = objectChecksumDecoded
        let objectChecksumAlgorithmDecoded = try containerValues.decodeIfPresent(BackupStorageClientTypes.SummaryChecksumAlgorithm.self, forKey: .objectChecksumAlgorithm)
        objectChecksumAlgorithm = objectChecksumAlgorithmDecoded
    }
}

enum NotifyObjectCompleteOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSInvalidKeyUsageException": return try await KMSInvalidKeyUsageException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotReadableInputStreamException": return try await NotReadableInputStreamException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableException": return try await RetryableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceInternalException": return try await ServiceInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

public struct PutChunkInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutChunkInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutChunkInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutChunkOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let data = input.operationInput.data {
            let dataBody = ClientRuntime.HttpBody(byteStream: data)
            input.builder.withBody(dataBody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutChunkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutChunkOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutChunkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case data = "Data"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = self.data {
            try encodeContainer.encode(data, forKey: .data)
        }
    }
}

extension PutChunkInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let length = length else {
                let message = "Creating a URL Query Item failed. length is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let lengthQueryItem = ClientRuntime.URLQueryItem(name: "length".urlPercentEncoding(), value: Swift.String(length).urlPercentEncoding())
            items.append(lengthQueryItem)
            guard let checksum = checksum else {
                let message = "Creating a URL Query Item failed. checksum is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let checksumQueryItem = ClientRuntime.URLQueryItem(name: "checksum".urlPercentEncoding(), value: Swift.String(checksum).urlPercentEncoding())
            items.append(checksumQueryItem)
            guard let checksumAlgorithm = checksumAlgorithm else {
                let message = "Creating a URL Query Item failed. checksumAlgorithm is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let checksumAlgorithmQueryItem = ClientRuntime.URLQueryItem(name: "checksum-algorithm".urlPercentEncoding(), value: Swift.String(checksumAlgorithm.rawValue).urlPercentEncoding())
            items.append(checksumAlgorithmQueryItem)
            return items
        }
    }
}

extension PutChunkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupJobId = backupJobId else {
            return nil
        }
        guard let uploadId = uploadId else {
            return nil
        }
        guard let chunkIndex = chunkIndex else {
            return nil
        }
        return "/backup-jobs/\(backupJobId.urlPercentEncoding())/chunk/\(uploadId.urlPercentEncoding())/\(chunkIndex)"
    }
}

public struct PutChunkInput: Swift.Equatable {
    /// Backup job Id for the in-progress backup.
    /// This member is required.
    public var backupJobId: Swift.String?
    /// Data checksum
    /// This member is required.
    public var checksum: Swift.String?
    /// Checksum algorithm
    /// This member is required.
    public var checksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm?
    /// Describes this chunk's position relative to the other chunks
    /// This member is required.
    public var chunkIndex: Swift.Int?
    /// Data to be uploaded
    /// This member is required.
    public var data: ClientRuntime.ByteStream?
    /// Data length
    /// This member is required.
    public var length: Swift.Int?
    /// Upload Id for the in-progress upload.
    /// This member is required.
    public var uploadId: Swift.String?

    public init(
        backupJobId: Swift.String? = nil,
        checksum: Swift.String? = nil,
        checksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm? = nil,
        chunkIndex: Swift.Int? = nil,
        data: ClientRuntime.ByteStream? = nil,
        length: Swift.Int? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.backupJobId = backupJobId
        self.checksum = checksum
        self.checksumAlgorithm = checksumAlgorithm
        self.chunkIndex = chunkIndex
        self.data = data
        self.length = length
        self.uploadId = uploadId
    }
}

struct PutChunkInputBody: Swift.Equatable {
    let data: ClientRuntime.ByteStream?
}

extension PutChunkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case data = "Data"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .data)
        data = dataDecoded
    }
}

extension PutChunkOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutChunkOutputBody = try responseDecoder.decode(responseBody: data)
            self.chunkChecksum = output.chunkChecksum
            self.chunkChecksumAlgorithm = output.chunkChecksumAlgorithm
        } else {
            self.chunkChecksum = nil
            self.chunkChecksumAlgorithm = nil
        }
    }
}

public struct PutChunkOutput: Swift.Equatable {
    /// Chunk checksum
    /// This member is required.
    public var chunkChecksum: Swift.String?
    /// Checksum algorithm
    /// This member is required.
    public var chunkChecksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm?

    public init(
        chunkChecksum: Swift.String? = nil,
        chunkChecksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm? = nil
    )
    {
        self.chunkChecksum = chunkChecksum
        self.chunkChecksumAlgorithm = chunkChecksumAlgorithm
    }
}

struct PutChunkOutputBody: Swift.Equatable {
    let chunkChecksum: Swift.String?
    let chunkChecksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm?
}

extension PutChunkOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chunkChecksum = "ChunkChecksum"
        case chunkChecksumAlgorithm = "ChunkChecksumAlgorithm"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let chunkChecksumDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .chunkChecksum)
        chunkChecksum = chunkChecksumDecoded
        let chunkChecksumAlgorithmDecoded = try containerValues.decodeIfPresent(BackupStorageClientTypes.DataChecksumAlgorithm.self, forKey: .chunkChecksumAlgorithm)
        chunkChecksumAlgorithm = chunkChecksumAlgorithmDecoded
    }
}

enum PutChunkOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSInvalidKeyUsageException": return try await KMSInvalidKeyUsageException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotReadableInputStreamException": return try await NotReadableInputStreamException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableException": return try await RetryableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceInternalException": return try await ServiceInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

public struct PutObjectInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutObjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutObjectInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutObjectOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let inlineChunk = input.operationInput.inlineChunk {
            let inlineChunkBody = ClientRuntime.HttpBody(byteStream: inlineChunk)
            input.builder.withBody(inlineChunkBody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutObjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutObjectOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutObjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inlineChunk = "InlineChunk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inlineChunk = self.inlineChunk {
            try encodeContainer.encode(inlineChunk, forKey: .inlineChunk)
        }
    }
}

extension PutObjectInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let inlineChunkChecksum = inlineChunkChecksum {
                let inlineChunkChecksumQueryItem = ClientRuntime.URLQueryItem(name: "checksum".urlPercentEncoding(), value: Swift.String(inlineChunkChecksum).urlPercentEncoding())
                items.append(inlineChunkChecksumQueryItem)
            }
            if let objectChecksum = objectChecksum {
                let objectChecksumQueryItem = ClientRuntime.URLQueryItem(name: "object-checksum".urlPercentEncoding(), value: Swift.String(objectChecksum).urlPercentEncoding())
                items.append(objectChecksumQueryItem)
            }
            if let objectChecksumAlgorithm = objectChecksumAlgorithm {
                let objectChecksumAlgorithmQueryItem = ClientRuntime.URLQueryItem(name: "object-checksum-algorithm".urlPercentEncoding(), value: Swift.String(objectChecksumAlgorithm.rawValue).urlPercentEncoding())
                items.append(objectChecksumAlgorithmQueryItem)
            }
            if let inlineChunkLength = inlineChunkLength {
                let inlineChunkLengthQueryItem = ClientRuntime.URLQueryItem(name: "length".urlPercentEncoding(), value: Swift.String(inlineChunkLength).urlPercentEncoding())
                items.append(inlineChunkLengthQueryItem)
            }
            if let inlineChunkChecksumAlgorithm = inlineChunkChecksumAlgorithm {
                let inlineChunkChecksumAlgorithmQueryItem = ClientRuntime.URLQueryItem(name: "checksum-algorithm".urlPercentEncoding(), value: Swift.String(inlineChunkChecksumAlgorithm).urlPercentEncoding())
                items.append(inlineChunkChecksumAlgorithmQueryItem)
            }
            if let metadataString = metadataString {
                let metadataStringQueryItem = ClientRuntime.URLQueryItem(name: "metadata-string".urlPercentEncoding(), value: Swift.String(metadataString).urlPercentEncoding())
                items.append(metadataStringQueryItem)
            }
            if let throwOnDuplicate = throwOnDuplicate {
                let throwOnDuplicateQueryItem = ClientRuntime.URLQueryItem(name: "throwOnDuplicate".urlPercentEncoding(), value: Swift.String(throwOnDuplicate).urlPercentEncoding())
                items.append(throwOnDuplicateQueryItem)
            }
            return items
        }
    }
}

extension PutObjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupJobId = backupJobId else {
            return nil
        }
        guard let objectName = objectName else {
            return nil
        }
        return "/backup-jobs/\(backupJobId.urlPercentEncoding())/object/\(objectName.urlPercentEncoding())/put-object"
    }
}

public struct PutObjectInput: Swift.Equatable {
    /// Backup job Id for the in-progress backup.
    /// This member is required.
    public var backupJobId: Swift.String?
    /// Inline chunk data to be uploaded.
    public var inlineChunk: ClientRuntime.ByteStream?
    /// Inline chunk checksum
    public var inlineChunkChecksum: Swift.String?
    /// Inline chunk checksum algorithm
    public var inlineChunkChecksumAlgorithm: Swift.String?
    /// Length of the inline chunk data.
    public var inlineChunkLength: Swift.Int?
    /// Store user defined metadata like backup checksum, disk ids, restore metadata etc.
    public var metadataString: Swift.String?
    /// object checksum
    public var objectChecksum: Swift.String?
    /// object checksum algorithm
    public var objectChecksumAlgorithm: BackupStorageClientTypes.SummaryChecksumAlgorithm?
    /// The name of the Object to be uploaded.
    /// This member is required.
    public var objectName: Swift.String?
    /// Throw an exception if Object name is already exist.
    public var throwOnDuplicate: Swift.Bool?

    public init(
        backupJobId: Swift.String? = nil,
        inlineChunk: ClientRuntime.ByteStream? = nil,
        inlineChunkChecksum: Swift.String? = nil,
        inlineChunkChecksumAlgorithm: Swift.String? = nil,
        inlineChunkLength: Swift.Int? = nil,
        metadataString: Swift.String? = nil,
        objectChecksum: Swift.String? = nil,
        objectChecksumAlgorithm: BackupStorageClientTypes.SummaryChecksumAlgorithm? = nil,
        objectName: Swift.String? = nil,
        throwOnDuplicate: Swift.Bool? = nil
    )
    {
        self.backupJobId = backupJobId
        self.inlineChunk = inlineChunk
        self.inlineChunkChecksum = inlineChunkChecksum
        self.inlineChunkChecksumAlgorithm = inlineChunkChecksumAlgorithm
        self.inlineChunkLength = inlineChunkLength
        self.metadataString = metadataString
        self.objectChecksum = objectChecksum
        self.objectChecksumAlgorithm = objectChecksumAlgorithm
        self.objectName = objectName
        self.throwOnDuplicate = throwOnDuplicate
    }
}

struct PutObjectInputBody: Swift.Equatable {
    let inlineChunk: ClientRuntime.ByteStream?
}

extension PutObjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inlineChunk = "InlineChunk"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inlineChunkDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .inlineChunk)
        inlineChunk = inlineChunkDecoded
    }
}

extension PutObjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutObjectOutputBody = try responseDecoder.decode(responseBody: data)
            self.inlineChunkChecksum = output.inlineChunkChecksum
            self.inlineChunkChecksumAlgorithm = output.inlineChunkChecksumAlgorithm
            self.objectChecksum = output.objectChecksum
            self.objectChecksumAlgorithm = output.objectChecksumAlgorithm
        } else {
            self.inlineChunkChecksum = nil
            self.inlineChunkChecksumAlgorithm = nil
            self.objectChecksum = nil
            self.objectChecksumAlgorithm = nil
        }
    }
}

public struct PutObjectOutput: Swift.Equatable {
    /// Inline chunk checksum
    /// This member is required.
    public var inlineChunkChecksum: Swift.String?
    /// Inline chunk checksum algorithm
    /// This member is required.
    public var inlineChunkChecksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm?
    /// object checksum
    /// This member is required.
    public var objectChecksum: Swift.String?
    /// object checksum algorithm
    /// This member is required.
    public var objectChecksumAlgorithm: BackupStorageClientTypes.SummaryChecksumAlgorithm?

    public init(
        inlineChunkChecksum: Swift.String? = nil,
        inlineChunkChecksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm? = nil,
        objectChecksum: Swift.String? = nil,
        objectChecksumAlgorithm: BackupStorageClientTypes.SummaryChecksumAlgorithm? = nil
    )
    {
        self.inlineChunkChecksum = inlineChunkChecksum
        self.inlineChunkChecksumAlgorithm = inlineChunkChecksumAlgorithm
        self.objectChecksum = objectChecksum
        self.objectChecksumAlgorithm = objectChecksumAlgorithm
    }
}

struct PutObjectOutputBody: Swift.Equatable {
    let inlineChunkChecksum: Swift.String?
    let inlineChunkChecksumAlgorithm: BackupStorageClientTypes.DataChecksumAlgorithm?
    let objectChecksum: Swift.String?
    let objectChecksumAlgorithm: BackupStorageClientTypes.SummaryChecksumAlgorithm?
}

extension PutObjectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inlineChunkChecksum = "InlineChunkChecksum"
        case inlineChunkChecksumAlgorithm = "InlineChunkChecksumAlgorithm"
        case objectChecksum = "ObjectChecksum"
        case objectChecksumAlgorithm = "ObjectChecksumAlgorithm"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inlineChunkChecksumDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inlineChunkChecksum)
        inlineChunkChecksum = inlineChunkChecksumDecoded
        let inlineChunkChecksumAlgorithmDecoded = try containerValues.decodeIfPresent(BackupStorageClientTypes.DataChecksumAlgorithm.self, forKey: .inlineChunkChecksumAlgorithm)
        inlineChunkChecksumAlgorithm = inlineChunkChecksumAlgorithmDecoded
        let objectChecksumDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectChecksum)
        objectChecksum = objectChecksumDecoded
        let objectChecksumAlgorithmDecoded = try containerValues.decodeIfPresent(BackupStorageClientTypes.SummaryChecksumAlgorithm.self, forKey: .objectChecksumAlgorithm)
        objectChecksumAlgorithm = objectChecksumAlgorithmDecoded
    }
}

enum PutObjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSInvalidKeyUsageException": return try await KMSInvalidKeyUsageException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotReadableInputStreamException": return try await NotReadableInputStreamException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableException": return try await RetryableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceInternalException": return try await ServiceInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Non-retryable exception. Attempted to make an operation on non-existing or expired resource.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RetryableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RetryableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Retryable exception. In general indicates internal failure that can be fixed by retry.
public struct RetryableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RetryableException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct RetryableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RetryableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceInternalException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceInternalExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Deprecated. To be removed from the model.
public struct ServiceInternalException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceInternalException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceInternalExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceInternalExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceUnavailableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Retryable exception, indicates internal server error.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StartObjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case throwOnDuplicate = "ThrowOnDuplicate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let throwOnDuplicate = self.throwOnDuplicate {
            try encodeContainer.encode(throwOnDuplicate, forKey: .throwOnDuplicate)
        }
    }
}

extension StartObjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let backupJobId = backupJobId else {
            return nil
        }
        guard let objectName = objectName else {
            return nil
        }
        return "/backup-jobs/\(backupJobId.urlPercentEncoding())/object/\(objectName.urlPercentEncoding())"
    }
}

public struct StartObjectInput: Swift.Equatable {
    /// Backup job Id for the in-progress backup
    /// This member is required.
    public var backupJobId: Swift.String?
    /// Name for the object.
    /// This member is required.
    public var objectName: Swift.String?
    /// Throw an exception if Object name is already exist.
    public var throwOnDuplicate: Swift.Bool?

    public init(
        backupJobId: Swift.String? = nil,
        objectName: Swift.String? = nil,
        throwOnDuplicate: Swift.Bool? = nil
    )
    {
        self.backupJobId = backupJobId
        self.objectName = objectName
        self.throwOnDuplicate = throwOnDuplicate
    }
}

struct StartObjectInputBody: Swift.Equatable {
    let throwOnDuplicate: Swift.Bool?
}

extension StartObjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case throwOnDuplicate = "ThrowOnDuplicate"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let throwOnDuplicateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .throwOnDuplicate)
        throwOnDuplicate = throwOnDuplicateDecoded
    }
}

extension StartObjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartObjectOutputBody = try responseDecoder.decode(responseBody: data)
            self.uploadId = output.uploadId
        } else {
            self.uploadId = nil
        }
    }
}

public struct StartObjectOutput: Swift.Equatable {
    /// Upload Id for a given upload.
    /// This member is required.
    public var uploadId: Swift.String?

    public init(
        uploadId: Swift.String? = nil
    )
    {
        self.uploadId = uploadId
    }
}

struct StartObjectOutputBody: Swift.Equatable {
    let uploadId: Swift.String?
}

extension StartObjectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case uploadId = "UploadId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
    }
}

enum StartObjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DataAlreadyExistsException": return try await DataAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IllegalArgumentException": return try await IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableException": return try await RetryableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceInternalException": return try await ServiceInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BackupStorageClientTypes {
    public enum SummaryChecksumAlgorithm: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case summary
        case sdkUnknown(Swift.String)

        public static var allCases: [SummaryChecksumAlgorithm] {
            return [
                .summary,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .summary: return "SUMMARY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SummaryChecksumAlgorithm(rawValue: rawValue) ?? SummaryChecksumAlgorithm.sdkUnknown(rawValue)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Increased rate over throttling limits. Can be retried with exponential backoff.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
