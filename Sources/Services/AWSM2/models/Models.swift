// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The account or role doesn't have the right permissions to make the request.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension M2ClientTypes.AlternateKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowDuplicates
        case length
        case name
        case offset
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allowDuplicates != false {
            try encodeContainer.encode(allowDuplicates, forKey: .allowDuplicates)
        }
        if length != 0 {
            try encodeContainer.encode(length, forKey: .length)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if offset != 0 {
            try encodeContainer.encode(offset, forKey: .offset)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let offsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .offset) ?? 0
        offset = offsetDecoded
        let lengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .length) ?? 0
        length = lengthDecoded
        let allowDuplicatesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowDuplicates) ?? false
        allowDuplicates = allowDuplicatesDecoded
    }
}

extension M2ClientTypes {
    /// Defines an alternate key. This value is optional. A legacy data set might not have any alternate key defined but if those alternate keys definitions exist, provide them, as some applications will make use of them.
    public struct AlternateKey: Swift.Equatable {
        /// Indicates whether the alternate key values are supposed to be unique for the given data set.
        public var allowDuplicates: Swift.Bool
        /// A strictly positive integer value representing the length of the alternate key.
        /// This member is required.
        public var length: Swift.Int
        /// The name of the alternate key.
        public var name: Swift.String?
        /// A positive integer value representing the offset to mark the start of the alternate key part in the record byte array.
        /// This member is required.
        public var offset: Swift.Int

        public init(
            allowDuplicates: Swift.Bool = false,
            length: Swift.Int = 0,
            name: Swift.String? = nil,
            offset: Swift.Int = 0
        )
        {
            self.allowDuplicates = allowDuplicates
            self.length = length
            self.name = name
            self.offset = offset
        }
    }

}

extension M2ClientTypes {
    public enum ApplicationDeploymentLifecycle: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deployed
        case deploying
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationDeploymentLifecycle] {
            return [
                .deployed,
                .deploying,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deployed: return "Deployed"
            case .deploying: return "Deploying"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationDeploymentLifecycle(rawValue: rawValue) ?? ApplicationDeploymentLifecycle.sdkUnknown(rawValue)
        }
    }
}

extension M2ClientTypes {
    public enum ApplicationLifecycle: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case created
        case creating
        case deleting
        case deletingFromEnvironment
        case failed
        case ready
        case running
        case starting
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationLifecycle] {
            return [
                .available,
                .created,
                .creating,
                .deleting,
                .deletingFromEnvironment,
                .failed,
                .ready,
                .running,
                .starting,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "Available"
            case .created: return "Created"
            case .creating: return "Creating"
            case .deleting: return "Deleting"
            case .deletingFromEnvironment: return "Deleting From Environment"
            case .failed: return "Failed"
            case .ready: return "Ready"
            case .running: return "Running"
            case .starting: return "Starting"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationLifecycle(rawValue: rawValue) ?? ApplicationLifecycle.sdkUnknown(rawValue)
        }
    }
}

extension M2ClientTypes.ApplicationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn
        case applicationId
        case applicationVersion
        case creationTime
        case deploymentStatus
        case description
        case engineType
        case environmentId
        case lastStartTime
        case name
        case roleArn
        case status
        case versionStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationArn = self.applicationArn {
            try encodeContainer.encode(applicationArn, forKey: .applicationArn)
        }
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let applicationVersion = self.applicationVersion {
            try encodeContainer.encode(applicationVersion, forKey: .applicationVersion)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let deploymentStatus = self.deploymentStatus {
            try encodeContainer.encode(deploymentStatus.rawValue, forKey: .deploymentStatus)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let engineType = self.engineType {
            try encodeContainer.encode(engineType.rawValue, forKey: .engineType)
        }
        if let environmentId = self.environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
        if let lastStartTime = self.lastStartTime {
            try encodeContainer.encodeTimestamp(lastStartTime, format: .epochSeconds, forKey: .lastStartTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let versionStatus = self.versionStatus {
            try encodeContainer.encode(versionStatus.rawValue, forKey: .versionStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let applicationVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .applicationVersion)
        applicationVersion = applicationVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(M2ClientTypes.ApplicationLifecycle.self, forKey: .status)
        status = statusDecoded
        let engineTypeDecoded = try containerValues.decodeIfPresent(M2ClientTypes.EngineType.self, forKey: .engineType)
        engineType = engineTypeDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let lastStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastStartTime)
        lastStartTime = lastStartTimeDecoded
        let versionStatusDecoded = try containerValues.decodeIfPresent(M2ClientTypes.ApplicationVersionLifecycle.self, forKey: .versionStatus)
        versionStatus = versionStatusDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(M2ClientTypes.ApplicationDeploymentLifecycle.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension M2ClientTypes {
    /// A subset of the possible application attributes. Used in the application list.
    public struct ApplicationSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the application.
        /// This member is required.
        public var applicationArn: Swift.String?
        /// The unique identifier of the application.
        /// This member is required.
        public var applicationId: Swift.String?
        /// The version of the application.
        /// This member is required.
        public var applicationVersion: Swift.Int?
        /// The timestamp when the application was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// Indicates either an ongoing deployment or if the application has ever deployed successfully.
        public var deploymentStatus: M2ClientTypes.ApplicationDeploymentLifecycle?
        /// The description of the application.
        public var description: Swift.String?
        /// The type of the target platform for this application.
        /// This member is required.
        public var engineType: M2ClientTypes.EngineType?
        /// The unique identifier of the runtime environment that hosts this application.
        public var environmentId: Swift.String?
        /// The timestamp when you last started the application. Null until the application runs for the first time.
        public var lastStartTime: ClientRuntime.Date?
        /// The name of the application.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the role associated with the application.
        public var roleArn: Swift.String?
        /// The status of the application.
        /// This member is required.
        public var status: M2ClientTypes.ApplicationLifecycle?
        /// Indicates the status of the latest version of the application.
        public var versionStatus: M2ClientTypes.ApplicationVersionLifecycle?

        public init(
            applicationArn: Swift.String? = nil,
            applicationId: Swift.String? = nil,
            applicationVersion: Swift.Int? = nil,
            creationTime: ClientRuntime.Date? = nil,
            deploymentStatus: M2ClientTypes.ApplicationDeploymentLifecycle? = nil,
            description: Swift.String? = nil,
            engineType: M2ClientTypes.EngineType? = nil,
            environmentId: Swift.String? = nil,
            lastStartTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            status: M2ClientTypes.ApplicationLifecycle? = nil,
            versionStatus: M2ClientTypes.ApplicationVersionLifecycle? = nil
        )
        {
            self.applicationArn = applicationArn
            self.applicationId = applicationId
            self.applicationVersion = applicationVersion
            self.creationTime = creationTime
            self.deploymentStatus = deploymentStatus
            self.description = description
            self.engineType = engineType
            self.environmentId = environmentId
            self.lastStartTime = lastStartTime
            self.name = name
            self.roleArn = roleArn
            self.status = status
            self.versionStatus = versionStatus
        }
    }

}

extension M2ClientTypes {
    public enum ApplicationVersionLifecycle: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case creating
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationVersionLifecycle] {
            return [
                .available,
                .creating,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "Available"
            case .creating: return "Creating"
            case .failed: return "Failed"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationVersionLifecycle(rawValue: rawValue) ?? ApplicationVersionLifecycle.sdkUnknown(rawValue)
        }
    }
}

extension M2ClientTypes.ApplicationVersionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationVersion
        case creationTime
        case status
        case statusReason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationVersion = self.applicationVersion {
            try encodeContainer.encode(applicationVersion, forKey: .applicationVersion)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .applicationVersion)
        applicationVersion = applicationVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(M2ClientTypes.ApplicationVersionLifecycle.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension M2ClientTypes {
    /// Defines an application version summary.
    public struct ApplicationVersionSummary: Swift.Equatable {
        /// The application version.
        /// This member is required.
        public var applicationVersion: Swift.Int?
        /// The timestamp when the application version was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The status of the application.
        /// This member is required.
        public var status: M2ClientTypes.ApplicationVersionLifecycle?
        /// The reason for the reported status.
        public var statusReason: Swift.String?

        public init(
            applicationVersion: Swift.Int? = nil,
            creationTime: ClientRuntime.Date? = nil,
            status: M2ClientTypes.ApplicationVersionLifecycle? = nil,
            statusReason: Swift.String? = nil
        )
        {
            self.applicationVersion = applicationVersion
            self.creationTime = creationTime
            self.status = status
            self.statusReason = statusReason
        }
    }

}

extension M2ClientTypes.BatchJobDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filebatchjobdefinition = "fileBatchJobDefinition"
        case scriptbatchjobdefinition = "scriptBatchJobDefinition"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .filebatchjobdefinition(filebatchjobdefinition):
                try container.encode(filebatchjobdefinition, forKey: .filebatchjobdefinition)
            case let .scriptbatchjobdefinition(scriptbatchjobdefinition):
                try container.encode(scriptbatchjobdefinition, forKey: .scriptbatchjobdefinition)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let filebatchjobdefinitionDecoded = try values.decodeIfPresent(M2ClientTypes.FileBatchJobDefinition.self, forKey: .filebatchjobdefinition)
        if let filebatchjobdefinition = filebatchjobdefinitionDecoded {
            self = .filebatchjobdefinition(filebatchjobdefinition)
            return
        }
        let scriptbatchjobdefinitionDecoded = try values.decodeIfPresent(M2ClientTypes.ScriptBatchJobDefinition.self, forKey: .scriptbatchjobdefinition)
        if let scriptbatchjobdefinition = scriptbatchjobdefinitionDecoded {
            self = .scriptbatchjobdefinition(scriptbatchjobdefinition)
            return
        }
        self = .sdkUnknown("")
    }
}

extension M2ClientTypes {
    /// Defines the details of a batch job.
    public enum BatchJobDefinition: Swift.Equatable {
        /// Specifies a file containing a batch job definition.
        case filebatchjobdefinition(M2ClientTypes.FileBatchJobDefinition)
        /// A script containing a batch job definition.
        case scriptbatchjobdefinition(M2ClientTypes.ScriptBatchJobDefinition)
        case sdkUnknown(Swift.String)
    }

}

extension M2ClientTypes {
    public enum BatchJobExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case cancelling
        case dispatch
        case failed
        case holding
        case running
        case submitting
        case succeeded
        case succeededWithWarning
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchJobExecutionStatus] {
            return [
                .cancelled,
                .cancelling,
                .dispatch,
                .failed,
                .holding,
                .running,
                .submitting,
                .succeeded,
                .succeededWithWarning,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "Cancelled"
            case .cancelling: return "Cancelling"
            case .dispatch: return "Dispatching"
            case .failed: return "Failed"
            case .holding: return "Holding"
            case .running: return "Running"
            case .submitting: return "Submitting"
            case .succeeded: return "Succeeded"
            case .succeededWithWarning: return "Succeeded With Warning"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BatchJobExecutionStatus(rawValue: rawValue) ?? BatchJobExecutionStatus.sdkUnknown(rawValue)
        }
    }
}

extension M2ClientTypes.BatchJobExecutionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId
        case batchJobIdentifier
        case endTime
        case executionId
        case jobId
        case jobName
        case jobType
        case returnCode
        case startTime
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let batchJobIdentifier = self.batchJobIdentifier {
            try encodeContainer.encode(batchJobIdentifier, forKey: .batchJobIdentifier)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let executionId = self.executionId {
            try encodeContainer.encode(executionId, forKey: .executionId)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobType = self.jobType {
            try encodeContainer.encode(jobType.rawValue, forKey: .jobType)
        }
        if let returnCode = self.returnCode {
            try encodeContainer.encode(returnCode, forKey: .returnCode)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobTypeDecoded = try containerValues.decodeIfPresent(M2ClientTypes.BatchJobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(M2ClientTypes.BatchJobExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let returnCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .returnCode)
        returnCode = returnCodeDecoded
        let batchJobIdentifierDecoded = try containerValues.decodeIfPresent(M2ClientTypes.BatchJobIdentifier.self, forKey: .batchJobIdentifier)
        batchJobIdentifier = batchJobIdentifierDecoded
    }
}

extension M2ClientTypes {
    /// A subset of the possible batch job attributes. Used in the batch job list.
    public struct BatchJobExecutionSummary: Swift.Equatable {
        /// The unique identifier of the application that hosts this batch job.
        /// This member is required.
        public var applicationId: Swift.String?
        /// The unique identifier of this batch job.
        public var batchJobIdentifier: M2ClientTypes.BatchJobIdentifier?
        /// The timestamp when this batch job execution ended.
        public var endTime: ClientRuntime.Date?
        /// The unique identifier of this execution of the batch job.
        /// This member is required.
        public var executionId: Swift.String?
        /// The unique identifier of a particular batch job.
        public var jobId: Swift.String?
        /// The name of a particular batch job.
        public var jobName: Swift.String?
        /// The type of a particular batch job execution.
        public var jobType: M2ClientTypes.BatchJobType?
        /// The batch job return code from either the Blu Age or Micro Focus runtime engines. For more information, see [Batch return codes](https://www.ibm.com/docs/en/was/8.5.5?topic=model-batch-return-codes) in the IBM WebSphere Application Server documentation.
        public var returnCode: Swift.String?
        /// The timestamp when a particular batch job execution started.
        /// This member is required.
        public var startTime: ClientRuntime.Date?
        /// The status of a particular batch job execution.
        /// This member is required.
        public var status: M2ClientTypes.BatchJobExecutionStatus?

        public init(
            applicationId: Swift.String? = nil,
            batchJobIdentifier: M2ClientTypes.BatchJobIdentifier? = nil,
            endTime: ClientRuntime.Date? = nil,
            executionId: Swift.String? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobType: M2ClientTypes.BatchJobType? = nil,
            returnCode: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: M2ClientTypes.BatchJobExecutionStatus? = nil
        )
        {
            self.applicationId = applicationId
            self.batchJobIdentifier = batchJobIdentifier
            self.endTime = endTime
            self.executionId = executionId
            self.jobId = jobId
            self.jobName = jobName
            self.jobType = jobType
            self.returnCode = returnCode
            self.startTime = startTime
            self.status = status
        }
    }

}

extension M2ClientTypes.BatchJobIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filebatchjobidentifier = "fileBatchJobIdentifier"
        case scriptbatchjobidentifier = "scriptBatchJobIdentifier"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .filebatchjobidentifier(filebatchjobidentifier):
                try container.encode(filebatchjobidentifier, forKey: .filebatchjobidentifier)
            case let .scriptbatchjobidentifier(scriptbatchjobidentifier):
                try container.encode(scriptbatchjobidentifier, forKey: .scriptbatchjobidentifier)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let filebatchjobidentifierDecoded = try values.decodeIfPresent(M2ClientTypes.FileBatchJobIdentifier.self, forKey: .filebatchjobidentifier)
        if let filebatchjobidentifier = filebatchjobidentifierDecoded {
            self = .filebatchjobidentifier(filebatchjobidentifier)
            return
        }
        let scriptbatchjobidentifierDecoded = try values.decodeIfPresent(M2ClientTypes.ScriptBatchJobIdentifier.self, forKey: .scriptbatchjobidentifier)
        if let scriptbatchjobidentifier = scriptbatchjobidentifierDecoded {
            self = .scriptbatchjobidentifier(scriptbatchjobidentifier)
            return
        }
        self = .sdkUnknown("")
    }
}

extension M2ClientTypes {
    /// Identifies a specific batch job.
    public enum BatchJobIdentifier: Swift.Equatable {
        /// Specifies a file associated with a specific batch job.
        case filebatchjobidentifier(M2ClientTypes.FileBatchJobIdentifier)
        /// A batch job identifier in which the batch job to run is identified by the script name.
        case scriptbatchjobidentifier(M2ClientTypes.ScriptBatchJobIdentifier)
        case sdkUnknown(Swift.String)
    }

}

extension M2ClientTypes {
    public enum BatchJobType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case jes2
        case jes3
        case vse
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchJobType] {
            return [
                .jes2,
                .jes3,
                .vse,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .jes2: return "JES2"
            case .jes3: return "JES3"
            case .vse: return "VSE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BatchJobType(rawValue: rawValue) ?? BatchJobType.sdkUnknown(rawValue)
        }
    }
}

extension CancelBatchJobExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let executionId = executionId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/batch-job-executions/\(executionId.urlPercentEncoding())/cancel"
    }
}

public struct CancelBatchJobExecutionInput: Swift.Equatable {
    /// The unique identifier of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The unique identifier of the batch job execution.
    /// This member is required.
    public var executionId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        executionId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.executionId = executionId
    }
}

struct CancelBatchJobExecutionInputBody: Swift.Equatable {
}

extension CancelBatchJobExecutionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CancelBatchJobExecutionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CancelBatchJobExecutionOutput: Swift.Equatable {

    public init() { }
}

enum CancelBatchJobExecutionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The parameters provided in the request conflict with existing resources.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the conflicting resource.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the conflicting resource.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CreateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case definition
        case description
        case engineType
        case kmsKeyId
        case name
        case roleArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let engineType = self.engineType {
            try encodeContainer.encode(engineType.rawValue, forKey: .engineType)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/applications"
    }
}

public struct CreateApplicationInput: Swift.Equatable {
    /// Unique, case-sensitive identifier the service generates to ensure the idempotency of the request to create an application. The service generates the clientToken when the API call is triggered. The token expires after one hour, so if you retry the API within this timeframe with the same clientToken, you will get the same response. The service also handles deleting the clientToken after it expires.
    public var clientToken: Swift.String?
    /// The application definition for this application. You can specify either inline JSON or an S3 bucket location.
    /// This member is required.
    public var definition: M2ClientTypes.Definition?
    /// The description of the application.
    public var description: Swift.String?
    /// The type of the target platform for this application.
    /// This member is required.
    public var engineType: M2ClientTypes.EngineType?
    /// The identifier of a customer managed key.
    public var kmsKeyId: Swift.String?
    /// The unique identifier of the application.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) that identifies a role that the application uses to access Amazon Web Services resources that are not part of the application or are in a different Amazon Web Services account.
    public var roleArn: Swift.String?
    /// A list of tags to apply to the application.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        definition: M2ClientTypes.Definition? = nil,
        description: Swift.String? = nil,
        engineType: M2ClientTypes.EngineType? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.definition = definition
        self.description = description
        self.engineType = engineType
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.roleArn = roleArn
        self.tags = tags
    }
}

struct CreateApplicationInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let engineType: M2ClientTypes.EngineType?
    let definition: M2ClientTypes.Definition?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
    let kmsKeyId: Swift.String?
    let roleArn: Swift.String?
}

extension CreateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case definition
        case description
        case engineType
        case kmsKeyId
        case name
        case roleArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let engineTypeDecoded = try containerValues.decodeIfPresent(M2ClientTypes.EngineType.self, forKey: .engineType)
        engineType = engineTypeDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(M2ClientTypes.Definition.self, forKey: .definition)
        definition = definitionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension CreateApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationArn = output.applicationArn
            self.applicationId = output.applicationId
            self.applicationVersion = output.applicationVersion
        } else {
            self.applicationArn = nil
            self.applicationId = nil
            self.applicationVersion = nil
        }
    }
}

public struct CreateApplicationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// The unique application identifier.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The version number of the application.
    /// This member is required.
    public var applicationVersion: Swift.Int?

    public init(
        applicationArn: Swift.String? = nil,
        applicationId: Swift.String? = nil,
        applicationVersion: Swift.Int? = nil
    )
    {
        self.applicationArn = applicationArn
        self.applicationId = applicationId
        self.applicationVersion = applicationVersion
    }
}

struct CreateApplicationOutputBody: Swift.Equatable {
    let applicationArn: Swift.String?
    let applicationId: Swift.String?
    let applicationVersion: Swift.Int?
}

extension CreateApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn
        case applicationId
        case applicationVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let applicationVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .applicationVersion)
        applicationVersion = applicationVersionDecoded
    }
}

enum CreateApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDataSetImportTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case importConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let importConfig = self.importConfig {
            try encodeContainer.encode(importConfig, forKey: .importConfig)
        }
    }
}

extension CreateDataSetImportTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/dataset-import-task"
    }
}

public struct CreateDataSetImportTaskInput: Swift.Equatable {
    /// The unique identifier of the application for which you want to import data sets.
    /// This member is required.
    public var applicationId: Swift.String?
    /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request to create a data set import. The service generates the clientToken when the API call is triggered. The token expires after one hour, so if you retry the API within this timeframe with the same clientToken, you will get the same response. The service also handles deleting the clientToken after it expires.
    public var clientToken: Swift.String?
    /// The data set import task configuration.
    /// This member is required.
    public var importConfig: M2ClientTypes.DataSetImportConfig?

    public init(
        applicationId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        importConfig: M2ClientTypes.DataSetImportConfig? = nil
    )
    {
        self.applicationId = applicationId
        self.clientToken = clientToken
        self.importConfig = importConfig
    }
}

struct CreateDataSetImportTaskInputBody: Swift.Equatable {
    let importConfig: M2ClientTypes.DataSetImportConfig?
    let clientToken: Swift.String?
}

extension CreateDataSetImportTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case importConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importConfigDecoded = try containerValues.decodeIfPresent(M2ClientTypes.DataSetImportConfig.self, forKey: .importConfig)
        importConfig = importConfigDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateDataSetImportTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDataSetImportTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.taskId = output.taskId
        } else {
            self.taskId = nil
        }
    }
}

public struct CreateDataSetImportTaskOutput: Swift.Equatable {
    /// The task identifier. This operation is asynchronous. Use this identifier with the [GetDataSetImportTask] operation to obtain the status of this task.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

struct CreateDataSetImportTaskOutputBody: Swift.Equatable {
    let taskId: Swift.String?
}

extension CreateDataSetImportTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case taskId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
    }
}

enum CreateDataSetImportTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDeploymentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationVersion
        case clientToken
        case environmentId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationVersion = self.applicationVersion {
            try encodeContainer.encode(applicationVersion, forKey: .applicationVersion)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let environmentId = self.environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
    }
}

extension CreateDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/deployments"
    }
}

public struct CreateDeploymentInput: Swift.Equatable {
    /// The application identifier.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The version of the application to deploy.
    /// This member is required.
    public var applicationVersion: Swift.Int?
    /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request to create a deployment. The service generates the clientToken when the API call is triggered. The token expires after one hour, so if you retry the API within this timeframe with the same clientToken, you will get the same response. The service also handles deleting the clientToken after it expires.
    public var clientToken: Swift.String?
    /// The identifier of the runtime environment where you want to deploy this application.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        applicationVersion: Swift.Int? = nil,
        clientToken: Swift.String? = nil,
        environmentId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.applicationVersion = applicationVersion
        self.clientToken = clientToken
        self.environmentId = environmentId
    }
}

struct CreateDeploymentInputBody: Swift.Equatable {
    let environmentId: Swift.String?
    let applicationVersion: Swift.Int?
    let clientToken: Swift.String?
}

extension CreateDeploymentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationVersion
        case clientToken
        case environmentId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let applicationVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .applicationVersion)
        applicationVersion = applicationVersionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateDeploymentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDeploymentOutputBody = try responseDecoder.decode(responseBody: data)
            self.deploymentId = output.deploymentId
        } else {
            self.deploymentId = nil
        }
    }
}

public struct CreateDeploymentOutput: Swift.Equatable {
    /// The unique identifier of the deployment.
    /// This member is required.
    public var deploymentId: Swift.String?

    public init(
        deploymentId: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
    }
}

struct CreateDeploymentOutputBody: Swift.Equatable {
    let deploymentId: Swift.String?
}

extension CreateDeploymentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
    }
}

enum CreateDeploymentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateEnvironmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case engineType
        case engineVersion
        case highAvailabilityConfig
        case instanceType
        case kmsKeyId
        case name
        case preferredMaintenanceWindow
        case publiclyAccessible
        case securityGroupIds
        case storageConfigurations
        case subnetIds
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let engineType = self.engineType {
            try encodeContainer.encode(engineType.rawValue, forKey: .engineType)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let highAvailabilityConfig = self.highAvailabilityConfig {
            try encodeContainer.encode(highAvailabilityConfig, forKey: .highAvailabilityConfig)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let preferredMaintenanceWindow = self.preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if publiclyAccessible != false {
            try encodeContainer.encode(publiclyAccessible, forKey: .publiclyAccessible)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for string500 in securityGroupIds {
                try securityGroupIdsContainer.encode(string500)
            }
        }
        if let storageConfigurations = storageConfigurations {
            var storageConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .storageConfigurations)
            for storageconfiguration0 in storageConfigurations {
                try storageConfigurationsContainer.encode(storageconfiguration0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for string500 in subnetIds {
                try subnetIdsContainer.encode(string500)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/environments"
    }
}

public struct CreateEnvironmentInput: Swift.Equatable {
    /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request to create an environment. The service generates the clientToken when the API call is triggered. The token expires after one hour, so if you retry the API within this timeframe with the same clientToken, you will get the same response. The service also handles deleting the clientToken after it expires.
    public var clientToken: Swift.String?
    /// The description of the runtime environment.
    public var description: Swift.String?
    /// The engine type for the runtime environment.
    /// This member is required.
    public var engineType: M2ClientTypes.EngineType?
    /// The version of the engine type for the runtime environment.
    public var engineVersion: Swift.String?
    /// The details of a high availability configuration for this runtime environment.
    public var highAvailabilityConfig: M2ClientTypes.HighAvailabilityConfig?
    /// The type of instance for the runtime environment.
    /// This member is required.
    public var instanceType: Swift.String?
    /// The identifier of a customer managed key.
    public var kmsKeyId: Swift.String?
    /// The name of the runtime environment. Must be unique within the account.
    /// This member is required.
    public var name: Swift.String?
    /// Configures the maintenance window you want for the runtime environment. If you do not provide a value, a random system-generated value will be assigned.
    public var preferredMaintenanceWindow: Swift.String?
    /// Specifies whether the runtime environment is publicly accessible.
    public var publiclyAccessible: Swift.Bool
    /// The list of security groups for the VPC associated with this runtime environment.
    public var securityGroupIds: [Swift.String]?
    /// Optional. The storage configurations for this runtime environment.
    public var storageConfigurations: [M2ClientTypes.StorageConfiguration]?
    /// The list of subnets associated with the VPC for this runtime environment.
    public var subnetIds: [Swift.String]?
    /// The tags for the runtime environment.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        engineType: M2ClientTypes.EngineType? = nil,
        engineVersion: Swift.String? = nil,
        highAvailabilityConfig: M2ClientTypes.HighAvailabilityConfig? = nil,
        instanceType: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        publiclyAccessible: Swift.Bool = false,
        securityGroupIds: [Swift.String]? = nil,
        storageConfigurations: [M2ClientTypes.StorageConfiguration]? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.engineType = engineType
        self.engineVersion = engineVersion
        self.highAvailabilityConfig = highAvailabilityConfig
        self.instanceType = instanceType
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.publiclyAccessible = publiclyAccessible
        self.securityGroupIds = securityGroupIds
        self.storageConfigurations = storageConfigurations
        self.subnetIds = subnetIds
        self.tags = tags
    }
}

struct CreateEnvironmentInputBody: Swift.Equatable {
    let name: Swift.String?
    let instanceType: Swift.String?
    let description: Swift.String?
    let engineType: M2ClientTypes.EngineType?
    let engineVersion: Swift.String?
    let subnetIds: [Swift.String]?
    let securityGroupIds: [Swift.String]?
    let storageConfigurations: [M2ClientTypes.StorageConfiguration]?
    let publiclyAccessible: Swift.Bool
    let highAvailabilityConfig: M2ClientTypes.HighAvailabilityConfig?
    let tags: [Swift.String:Swift.String]?
    let preferredMaintenanceWindow: Swift.String?
    let clientToken: Swift.String?
    let kmsKeyId: Swift.String?
}

extension CreateEnvironmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case engineType
        case engineVersion
        case highAvailabilityConfig
        case instanceType
        case kmsKeyId
        case name
        case preferredMaintenanceWindow
        case publiclyAccessible
        case securityGroupIds
        case storageConfigurations
        case subnetIds
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let engineTypeDecoded = try containerValues.decodeIfPresent(M2ClientTypes.EngineType.self, forKey: .engineType)
        engineType = engineTypeDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let storageConfigurationsContainer = try containerValues.decodeIfPresent([M2ClientTypes.StorageConfiguration?].self, forKey: .storageConfigurations)
        var storageConfigurationsDecoded0:[M2ClientTypes.StorageConfiguration]? = nil
        if let storageConfigurationsContainer = storageConfigurationsContainer {
            storageConfigurationsDecoded0 = [M2ClientTypes.StorageConfiguration]()
            for union0 in storageConfigurationsContainer {
                if let union0 = union0 {
                    storageConfigurationsDecoded0?.append(union0)
                }
            }
        }
        storageConfigurations = storageConfigurationsDecoded0
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible) ?? false
        publiclyAccessible = publiclyAccessibleDecoded
        let highAvailabilityConfigDecoded = try containerValues.decodeIfPresent(M2ClientTypes.HighAvailabilityConfig.self, forKey: .highAvailabilityConfig)
        highAvailabilityConfig = highAvailabilityConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension CreateEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateEnvironmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.environmentId = output.environmentId
        } else {
            self.environmentId = nil
        }
    }
}

public struct CreateEnvironmentOutput: Swift.Equatable {
    /// The unique identifier of the runtime environment.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        environmentId: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
    }
}

struct CreateEnvironmentOutputBody: Swift.Equatable {
    let environmentId: Swift.String?
}

extension CreateEnvironmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
    }
}

enum CreateEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension M2ClientTypes.DataSet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetName
        case datasetOrg
        case recordLength
        case relativePath
        case storageType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetName = self.datasetName {
            try encodeContainer.encode(datasetName, forKey: .datasetName)
        }
        if let datasetOrg = self.datasetOrg {
            try encodeContainer.encode(datasetOrg, forKey: .datasetOrg)
        }
        if let recordLength = self.recordLength {
            try encodeContainer.encode(recordLength, forKey: .recordLength)
        }
        if let relativePath = self.relativePath {
            try encodeContainer.encode(relativePath, forKey: .relativePath)
        }
        if let storageType = self.storageType {
            try encodeContainer.encode(storageType, forKey: .storageType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let datasetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let datasetOrgDecoded = try containerValues.decodeIfPresent(M2ClientTypes.DatasetOrgAttributes.self, forKey: .datasetOrg)
        datasetOrg = datasetOrgDecoded
        let relativePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relativePath)
        relativePath = relativePathDecoded
        let recordLengthDecoded = try containerValues.decodeIfPresent(M2ClientTypes.RecordLength.self, forKey: .recordLength)
        recordLength = recordLengthDecoded
    }
}

extension M2ClientTypes {
    /// Defines a data set.
    public struct DataSet: Swift.Equatable {
        /// The logical identifier for a specific data set (in mainframe format).
        /// This member is required.
        public var datasetName: Swift.String?
        /// The type of dataset. The only supported value is VSAM.
        /// This member is required.
        public var datasetOrg: M2ClientTypes.DatasetOrgAttributes?
        /// The length of a record.
        /// This member is required.
        public var recordLength: M2ClientTypes.RecordLength?
        /// The relative location of the data set in the database or file system.
        public var relativePath: Swift.String?
        /// The storage type of the data set: database or file system. For Micro Focus, database corresponds to datastore and file system corresponds to EFS/FSX. For Blu Age, there is no support of file system and database corresponds to Blusam.
        public var storageType: Swift.String?

        public init(
            datasetName: Swift.String? = nil,
            datasetOrg: M2ClientTypes.DatasetOrgAttributes? = nil,
            recordLength: M2ClientTypes.RecordLength? = nil,
            relativePath: Swift.String? = nil,
            storageType: Swift.String? = nil
        )
        {
            self.datasetName = datasetName
            self.datasetOrg = datasetOrg
            self.recordLength = recordLength
            self.relativePath = relativePath
            self.storageType = storageType
        }
    }

}

extension M2ClientTypes.DataSetImportConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasets = "dataSets"
        case s3location = "s3Location"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .datasets(datasets):
                var datasetsContainer = container.nestedUnkeyedContainer(forKey: .datasets)
                for datasetimportitem0 in datasets {
                    try datasetsContainer.encode(datasetimportitem0)
                }
            case let .s3location(s3location):
                try container.encode(s3location, forKey: .s3location)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let s3locationDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .s3location)
        if let s3location = s3locationDecoded {
            self = .s3location(s3location)
            return
        }
        let datasetsContainer = try values.decodeIfPresent([M2ClientTypes.DataSetImportItem?].self, forKey: .datasets)
        var datasetsDecoded0:[M2ClientTypes.DataSetImportItem]? = nil
        if let datasetsContainer = datasetsContainer {
            datasetsDecoded0 = [M2ClientTypes.DataSetImportItem]()
            for structure0 in datasetsContainer {
                if let structure0 = structure0 {
                    datasetsDecoded0?.append(structure0)
                }
            }
        }
        if let datasets = datasetsDecoded0 {
            self = .datasets(datasets)
            return
        }
        self = .sdkUnknown("")
    }
}

extension M2ClientTypes {
    /// Identifies one or more data sets you want to import with the [CreateDataSetImportTask] operation.
    public enum DataSetImportConfig: Swift.Equatable {
        /// The Amazon S3 location of the data sets.
        case s3location(Swift.String)
        /// The data sets.
        case datasets([M2ClientTypes.DataSetImportItem])
        case sdkUnknown(Swift.String)
    }

}

extension M2ClientTypes.DataSetImportItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSet
        case externalLocation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSet = self.dataSet {
            try encodeContainer.encode(dataSet, forKey: .dataSet)
        }
        if let externalLocation = self.externalLocation {
            try encodeContainer.encode(externalLocation, forKey: .externalLocation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetDecoded = try containerValues.decodeIfPresent(M2ClientTypes.DataSet.self, forKey: .dataSet)
        dataSet = dataSetDecoded
        let externalLocationDecoded = try containerValues.decodeIfPresent(M2ClientTypes.ExternalLocation.self, forKey: .externalLocation)
        externalLocation = externalLocationDecoded
    }
}

extension M2ClientTypes {
    /// Identifies a specific data set to import from an external location.
    public struct DataSetImportItem: Swift.Equatable {
        /// The data set.
        /// This member is required.
        public var dataSet: M2ClientTypes.DataSet?
        /// The location of the data set.
        /// This member is required.
        public var externalLocation: M2ClientTypes.ExternalLocation?

        public init(
            dataSet: M2ClientTypes.DataSet? = nil,
            externalLocation: M2ClientTypes.ExternalLocation? = nil
        )
        {
            self.dataSet = dataSet
            self.externalLocation = externalLocation
        }
    }

}

extension M2ClientTypes.DataSetImportSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failed
        case inProgress
        case pending
        case succeeded
        case total
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if failed != 0 {
            try encodeContainer.encode(failed, forKey: .failed)
        }
        if inProgress != 0 {
            try encodeContainer.encode(inProgress, forKey: .inProgress)
        }
        if pending != 0 {
            try encodeContainer.encode(pending, forKey: .pending)
        }
        if succeeded != 0 {
            try encodeContainer.encode(succeeded, forKey: .succeeded)
        }
        if total != 0 {
            try encodeContainer.encode(total, forKey: .total)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .total) ?? 0
        total = totalDecoded
        let succeededDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .succeeded) ?? 0
        succeeded = succeededDecoded
        let failedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failed) ?? 0
        failed = failedDecoded
        let pendingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pending) ?? 0
        pending = pendingDecoded
        let inProgressDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inProgress) ?? 0
        inProgress = inProgressDecoded
    }
}

extension M2ClientTypes {
    /// Represents a summary of data set imports.
    public struct DataSetImportSummary: Swift.Equatable {
        /// The number of data set imports that have failed.
        /// This member is required.
        public var failed: Swift.Int
        /// The number of data set imports that are in progress.
        /// This member is required.
        public var inProgress: Swift.Int
        /// The number of data set imports that are pending.
        /// This member is required.
        public var pending: Swift.Int
        /// The number of data set imports that have succeeded.
        /// This member is required.
        public var succeeded: Swift.Int
        /// The total number of data set imports.
        /// This member is required.
        public var total: Swift.Int

        public init(
            failed: Swift.Int = 0,
            inProgress: Swift.Int = 0,
            pending: Swift.Int = 0,
            succeeded: Swift.Int = 0,
            total: Swift.Int = 0
        )
        {
            self.failed = failed
            self.inProgress = inProgress
            self.pending = pending
            self.succeeded = succeeded
            self.total = total
        }
    }

}

extension M2ClientTypes.DataSetImportTask: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
        case summary
        case taskId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let summary = self.summary {
            try encodeContainer.encode(summary, forKey: .summary)
        }
        if let taskId = self.taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(M2ClientTypes.DataSetTaskLifecycle.self, forKey: .status)
        status = statusDecoded
        let summaryDecoded = try containerValues.decodeIfPresent(M2ClientTypes.DataSetImportSummary.self, forKey: .summary)
        summary = summaryDecoded
    }
}

extension M2ClientTypes {
    /// Contains information about a data set import task.
    public struct DataSetImportTask: Swift.Equatable {
        /// The status of the data set import task.
        /// This member is required.
        public var status: M2ClientTypes.DataSetTaskLifecycle?
        /// A summary of the data set import task.
        /// This member is required.
        public var summary: M2ClientTypes.DataSetImportSummary?
        /// The identifier of the data set import task.
        /// This member is required.
        public var taskId: Swift.String?

        public init(
            status: M2ClientTypes.DataSetTaskLifecycle? = nil,
            summary: M2ClientTypes.DataSetImportSummary? = nil,
            taskId: Swift.String? = nil
        )
        {
            self.status = status
            self.summary = summary
            self.taskId = taskId
        }
    }

}

extension M2ClientTypes.DataSetSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case dataSetName
        case dataSetOrg
        case format
        case lastReferencedTime
        case lastUpdatedTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let dataSetName = self.dataSetName {
            try encodeContainer.encode(dataSetName, forKey: .dataSetName)
        }
        if let dataSetOrg = self.dataSetOrg {
            try encodeContainer.encode(dataSetOrg, forKey: .dataSetOrg)
        }
        if let format = self.format {
            try encodeContainer.encode(format, forKey: .format)
        }
        if let lastReferencedTime = self.lastReferencedTime {
            try encodeContainer.encodeTimestamp(lastReferencedTime, format: .epochSeconds, forKey: .lastReferencedTime)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetName)
        dataSetName = dataSetNameDecoded
        let dataSetOrgDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetOrg)
        dataSetOrg = dataSetOrgDecoded
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let lastReferencedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastReferencedTime)
        lastReferencedTime = lastReferencedTimeDecoded
    }
}

extension M2ClientTypes {
    /// A subset of the possible data set attributes.
    public struct DataSetSummary: Swift.Equatable {
        /// The timestamp when the data set was created.
        public var creationTime: ClientRuntime.Date?
        /// The name of the data set.
        /// This member is required.
        public var dataSetName: Swift.String?
        /// The type of data set. The only supported value is VSAM.
        public var dataSetOrg: Swift.String?
        /// The format of the data set.
        public var format: Swift.String?
        /// The last time the data set was referenced.
        public var lastReferencedTime: ClientRuntime.Date?
        /// The last time the data set was updated.
        public var lastUpdatedTime: ClientRuntime.Date?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            dataSetName: Swift.String? = nil,
            dataSetOrg: Swift.String? = nil,
            format: Swift.String? = nil,
            lastReferencedTime: ClientRuntime.Date? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil
        )
        {
            self.creationTime = creationTime
            self.dataSetName = dataSetName
            self.dataSetOrg = dataSetOrg
            self.format = format
            self.lastReferencedTime = lastReferencedTime
            self.lastUpdatedTime = lastUpdatedTime
        }
    }

}

extension M2ClientTypes {
    public enum DataSetTaskLifecycle: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case creating
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSetTaskLifecycle] {
            return [
                .completed,
                .creating,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .creating: return "Creating"
            case .running: return "Running"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataSetTaskLifecycle(rawValue: rawValue) ?? DataSetTaskLifecycle.sdkUnknown(rawValue)
        }
    }
}

extension M2ClientTypes.DatasetDetailOrgAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gdg
        case po
        case ps
        case sdkUnknown
        case vsam
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .gdg(gdg):
                try container.encode(gdg, forKey: .gdg)
            case let .po(po):
                try container.encode(po, forKey: .po)
            case let .ps(ps):
                try container.encode(ps, forKey: .ps)
            case let .vsam(vsam):
                try container.encode(vsam, forKey: .vsam)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let vsamDecoded = try values.decodeIfPresent(M2ClientTypes.VsamDetailAttributes.self, forKey: .vsam)
        if let vsam = vsamDecoded {
            self = .vsam(vsam)
            return
        }
        let gdgDecoded = try values.decodeIfPresent(M2ClientTypes.GdgDetailAttributes.self, forKey: .gdg)
        if let gdg = gdgDecoded {
            self = .gdg(gdg)
            return
        }
        let poDecoded = try values.decodeIfPresent(M2ClientTypes.PoDetailAttributes.self, forKey: .po)
        if let po = poDecoded {
            self = .po(po)
            return
        }
        let psDecoded = try values.decodeIfPresent(M2ClientTypes.PsDetailAttributes.self, forKey: .ps)
        if let ps = psDecoded {
            self = .ps(ps)
            return
        }
        self = .sdkUnknown("")
    }
}

extension M2ClientTypes {
    /// Additional details about the data set. Different attributes correspond to different data set organizations. The values are populated based on datasetOrg, storageType and backend (Blu Age or Micro Focus).
    public enum DatasetDetailOrgAttributes: Swift.Equatable {
        /// The details of a VSAM data set.
        case vsam(M2ClientTypes.VsamDetailAttributes)
        /// The generation data group of the data set.
        case gdg(M2ClientTypes.GdgDetailAttributes)
        /// The details of a PO type data set.
        case po(M2ClientTypes.PoDetailAttributes)
        /// The details of a PS type data set.
        case ps(M2ClientTypes.PsDetailAttributes)
        case sdkUnknown(Swift.String)
    }

}

extension M2ClientTypes.DatasetOrgAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gdg
        case po
        case ps
        case sdkUnknown
        case vsam
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .gdg(gdg):
                try container.encode(gdg, forKey: .gdg)
            case let .po(po):
                try container.encode(po, forKey: .po)
            case let .ps(ps):
                try container.encode(ps, forKey: .ps)
            case let .vsam(vsam):
                try container.encode(vsam, forKey: .vsam)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let vsamDecoded = try values.decodeIfPresent(M2ClientTypes.VsamAttributes.self, forKey: .vsam)
        if let vsam = vsamDecoded {
            self = .vsam(vsam)
            return
        }
        let gdgDecoded = try values.decodeIfPresent(M2ClientTypes.GdgAttributes.self, forKey: .gdg)
        if let gdg = gdgDecoded {
            self = .gdg(gdg)
            return
        }
        let poDecoded = try values.decodeIfPresent(M2ClientTypes.PoAttributes.self, forKey: .po)
        if let po = poDecoded {
            self = .po(po)
            return
        }
        let psDecoded = try values.decodeIfPresent(M2ClientTypes.PsAttributes.self, forKey: .ps)
        if let ps = psDecoded {
            self = .ps(ps)
            return
        }
        self = .sdkUnknown("")
    }
}

extension M2ClientTypes {
    /// Additional details about the data set. Different attributes correspond to different data set organizations. The values are populated based on datasetOrg, storageType and backend (Blu Age or Micro Focus).
    public enum DatasetOrgAttributes: Swift.Equatable {
        /// The details of a VSAM data set.
        case vsam(M2ClientTypes.VsamAttributes)
        /// The generation data group of the data set.
        case gdg(M2ClientTypes.GdgAttributes)
        /// The details of a PO type data set.
        case po(M2ClientTypes.PoAttributes)
        /// The details of a PS type data set.
        case ps(M2ClientTypes.PsAttributes)
        case sdkUnknown(Swift.String)
    }

}

extension M2ClientTypes.Definition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
        case s3location = "s3Location"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .content(content):
                try container.encode(content, forKey: .content)
            case let .s3location(s3location):
                try container.encode(s3location, forKey: .s3location)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let s3locationDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .s3location)
        if let s3location = s3locationDecoded {
            self = .s3location(s3location)
            return
        }
        let contentDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .content)
        if let content = contentDecoded {
            self = .content(content)
            return
        }
        self = .sdkUnknown("")
    }
}

extension M2ClientTypes {
    /// The application definition for a particular application.
    public enum Definition: Swift.Equatable {
        /// The S3 bucket that contains the application definition.
        case s3location(Swift.String)
        /// The content of the application definition. This is a JSON object that contains the resource configuration/definitions that identify an application.
        case content(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension DeleteApplicationFromEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let environmentId = environmentId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/environment/\(environmentId.urlPercentEncoding())"
    }
}

public struct DeleteApplicationFromEnvironmentInput: Swift.Equatable {
    /// The unique identifier of the application you want to delete.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The unique identifier of the runtime environment where the application was previously deployed.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        environmentId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.environmentId = environmentId
    }
}

struct DeleteApplicationFromEnvironmentInputBody: Swift.Equatable {
}

extension DeleteApplicationFromEnvironmentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteApplicationFromEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteApplicationFromEnvironmentOutput: Swift.Equatable {

    public init() { }
}

enum DeleteApplicationFromEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())"
    }
}

public struct DeleteApplicationInput: Swift.Equatable {
    /// The unique identifier of the application you want to delete.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct DeleteApplicationInputBody: Swift.Equatable {
}

extension DeleteApplicationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteApplicationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let environmentId = environmentId else {
            return nil
        }
        return "/environments/\(environmentId.urlPercentEncoding())"
    }
}

public struct DeleteEnvironmentInput: Swift.Equatable {
    /// The unique identifier of the runtime environment you want to delete.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        environmentId: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
    }
}

struct DeleteEnvironmentInputBody: Swift.Equatable {
}

extension DeleteEnvironmentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteEnvironmentOutput: Swift.Equatable {

    public init() { }
}

enum DeleteEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension M2ClientTypes.DeployedVersionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationVersion
        case status
        case statusReason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationVersion = self.applicationVersion {
            try encodeContainer.encode(applicationVersion, forKey: .applicationVersion)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .applicationVersion)
        applicationVersion = applicationVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(M2ClientTypes.DeploymentLifecycle.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
    }
}

extension M2ClientTypes {
    /// Contains a summary of a deployed application.
    public struct DeployedVersionSummary: Swift.Equatable {
        /// The version of the deployed application.
        /// This member is required.
        public var applicationVersion: Swift.Int?
        /// The status of the deployment.
        /// This member is required.
        public var status: M2ClientTypes.DeploymentLifecycle?
        /// The reason for the reported status.
        public var statusReason: Swift.String?

        public init(
            applicationVersion: Swift.Int? = nil,
            status: M2ClientTypes.DeploymentLifecycle? = nil,
            statusReason: Swift.String? = nil
        )
        {
            self.applicationVersion = applicationVersion
            self.status = status
            self.statusReason = statusReason
        }
    }

}

extension M2ClientTypes {
    public enum DeploymentLifecycle: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deploying
        case failed
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentLifecycle] {
            return [
                .deploying,
                .failed,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deploying: return "Deploying"
            case .failed: return "Failed"
            case .succeeded: return "Succeeded"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentLifecycle(rawValue: rawValue) ?? DeploymentLifecycle.sdkUnknown(rawValue)
        }
    }
}

extension M2ClientTypes.DeploymentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId
        case applicationVersion
        case creationTime
        case deploymentId
        case environmentId
        case status
        case statusReason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let applicationVersion = self.applicationVersion {
            try encodeContainer.encode(applicationVersion, forKey: .applicationVersion)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let deploymentId = self.deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let environmentId = self.environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let applicationVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .applicationVersion)
        applicationVersion = applicationVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(M2ClientTypes.DeploymentLifecycle.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
    }
}

extension M2ClientTypes {
    /// A subset of information about a specific deployment.
    public struct DeploymentSummary: Swift.Equatable {
        /// The unique identifier of the application.
        /// This member is required.
        public var applicationId: Swift.String?
        /// The version of the application.
        /// This member is required.
        public var applicationVersion: Swift.Int?
        /// The timestamp when the deployment was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The unique identifier of the deployment.
        /// This member is required.
        public var deploymentId: Swift.String?
        /// The unique identifier of the runtime environment.
        /// This member is required.
        public var environmentId: Swift.String?
        /// The current status of the deployment.
        /// This member is required.
        public var status: M2ClientTypes.DeploymentLifecycle?
        /// The reason for the reported status.
        public var statusReason: Swift.String?

        public init(
            applicationId: Swift.String? = nil,
            applicationVersion: Swift.Int? = nil,
            creationTime: ClientRuntime.Date? = nil,
            deploymentId: Swift.String? = nil,
            environmentId: Swift.String? = nil,
            status: M2ClientTypes.DeploymentLifecycle? = nil,
            statusReason: Swift.String? = nil
        )
        {
            self.applicationId = applicationId
            self.applicationVersion = applicationVersion
            self.creationTime = creationTime
            self.deploymentId = deploymentId
            self.environmentId = environmentId
            self.status = status
            self.statusReason = statusReason
        }
    }

}

extension M2ClientTypes.EfsStorageConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystemId = "file-system-id"
        case mountPoint = "mount-point"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileSystemId = self.fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
        if let mountPoint = self.mountPoint {
            try encodeContainer.encode(mountPoint, forKey: .mountPoint)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let mountPointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mountPoint)
        mountPoint = mountPointDecoded
    }
}

extension M2ClientTypes {
    /// Defines the storage configuration for an Amazon EFS file system.
    public struct EfsStorageConfiguration: Swift.Equatable {
        /// The file system identifier.
        /// This member is required.
        public var fileSystemId: Swift.String?
        /// The mount point for the file system.
        /// This member is required.
        public var mountPoint: Swift.String?

        public init(
            fileSystemId: Swift.String? = nil,
            mountPoint: Swift.String? = nil
        )
        {
            self.fileSystemId = fileSystemId
            self.mountPoint = mountPoint
        }
    }

}

extension M2ClientTypes {
    public enum EngineType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bluage
        case microfocus
        case sdkUnknown(Swift.String)

        public static var allCases: [EngineType] {
            return [
                .bluage,
                .microfocus,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bluage: return "bluage"
            case .microfocus: return "microfocus"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EngineType(rawValue: rawValue) ?? EngineType.sdkUnknown(rawValue)
        }
    }
}

extension M2ClientTypes.EngineVersionsSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineType
        case engineVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engineType = self.engineType {
            try encodeContainer.encode(engineType, forKey: .engineType)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineType)
        engineType = engineTypeDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
    }
}

extension M2ClientTypes {
    /// A subset of information about the engine version for a specific application.
    public struct EngineVersionsSummary: Swift.Equatable {
        /// The type of target platform for the application.
        /// This member is required.
        public var engineType: Swift.String?
        /// The version of the engine type used by the application.
        /// This member is required.
        public var engineVersion: Swift.String?

        public init(
            engineType: Swift.String? = nil,
            engineVersion: Swift.String? = nil
        )
        {
            self.engineType = engineType
            self.engineVersion = engineVersion
        }
    }

}

extension M2ClientTypes {
    public enum EnvironmentLifecycle: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case creating
        case deleting
        case failed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [EnvironmentLifecycle] {
            return [
                .available,
                .creating,
                .deleting,
                .failed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "Available"
            case .creating: return "Creating"
            case .deleting: return "Deleting"
            case .failed: return "Failed"
            case .updating: return "Updating"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EnvironmentLifecycle(rawValue: rawValue) ?? EnvironmentLifecycle.sdkUnknown(rawValue)
        }
    }
}

extension M2ClientTypes.EnvironmentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case engineType
        case engineVersion
        case environmentArn
        case environmentId
        case instanceType
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let engineType = self.engineType {
            try encodeContainer.encode(engineType.rawValue, forKey: .engineType)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let environmentArn = self.environmentArn {
            try encodeContainer.encode(environmentArn, forKey: .environmentArn)
        }
        if let environmentId = self.environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let environmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentArn)
        environmentArn = environmentArnDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(M2ClientTypes.EnvironmentLifecycle.self, forKey: .status)
        status = statusDecoded
        let engineTypeDecoded = try containerValues.decodeIfPresent(M2ClientTypes.EngineType.self, forKey: .engineType)
        engineType = engineTypeDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension M2ClientTypes {
    /// Contains a subset of the possible runtime environment attributes. Used in the environment list.
    public struct EnvironmentSummary: Swift.Equatable {
        /// The timestamp when the runtime environment was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The target platform for the runtime environment.
        /// This member is required.
        public var engineType: M2ClientTypes.EngineType?
        /// The version of the runtime engine.
        /// This member is required.
        public var engineVersion: Swift.String?
        /// The Amazon Resource Name (ARN) of a particular runtime environment.
        /// This member is required.
        public var environmentArn: Swift.String?
        /// The unique identifier of a particular runtime environment.
        /// This member is required.
        public var environmentId: Swift.String?
        /// The instance type of the runtime environment.
        /// This member is required.
        public var instanceType: Swift.String?
        /// The name of the runtime environment.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the runtime environment
        /// This member is required.
        public var status: M2ClientTypes.EnvironmentLifecycle?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            engineType: M2ClientTypes.EngineType? = nil,
            engineVersion: Swift.String? = nil,
            environmentArn: Swift.String? = nil,
            environmentId: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            name: Swift.String? = nil,
            status: M2ClientTypes.EnvironmentLifecycle? = nil
        )
        {
            self.creationTime = creationTime
            self.engineType = engineType
            self.engineVersion = engineVersion
            self.environmentArn = environmentArn
            self.environmentId = environmentId
            self.instanceType = instanceType
            self.name = name
            self.status = status
        }
    }

}

extension M2ClientTypes.ExternalLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3location = "s3Location"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .s3location(s3location):
                try container.encode(s3location, forKey: .s3location)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let s3locationDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .s3location)
        if let s3location = s3locationDecoded {
            self = .s3location(s3location)
            return
        }
        self = .sdkUnknown("")
    }
}

extension M2ClientTypes {
    /// Defines an external storage location.
    public enum ExternalLocation: Swift.Equatable {
        /// The URI of the Amazon S3 bucket.
        case s3location(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension M2ClientTypes.FileBatchJobDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileName
        case folderPath
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileName = self.fileName {
            try encodeContainer.encode(fileName, forKey: .fileName)
        }
        if let folderPath = self.folderPath {
            try encodeContainer.encode(folderPath, forKey: .folderPath)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileName)
        fileName = fileNameDecoded
        let folderPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .folderPath)
        folderPath = folderPathDecoded
    }
}

extension M2ClientTypes {
    /// A file containing a batch job definition.
    public struct FileBatchJobDefinition: Swift.Equatable {
        /// The name of the file containing the batch job definition.
        /// This member is required.
        public var fileName: Swift.String?
        /// The path to the file containing the batch job definition.
        public var folderPath: Swift.String?

        public init(
            fileName: Swift.String? = nil,
            folderPath: Swift.String? = nil
        )
        {
            self.fileName = fileName
            self.folderPath = folderPath
        }
    }

}

extension M2ClientTypes.FileBatchJobIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileName
        case folderPath
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileName = self.fileName {
            try encodeContainer.encode(fileName, forKey: .fileName)
        }
        if let folderPath = self.folderPath {
            try encodeContainer.encode(folderPath, forKey: .folderPath)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileName)
        fileName = fileNameDecoded
        let folderPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .folderPath)
        folderPath = folderPathDecoded
    }
}

extension M2ClientTypes {
    /// A batch job identifier in which the batch job to run is identified by the file name and the relative path to the file name.
    public struct FileBatchJobIdentifier: Swift.Equatable {
        /// The file name for the batch job identifier.
        /// This member is required.
        public var fileName: Swift.String?
        /// The relative path to the file name for the batch job identifier.
        public var folderPath: Swift.String?

        public init(
            fileName: Swift.String? = nil,
            folderPath: Swift.String? = nil
        )
        {
            self.fileName = fileName
            self.folderPath = folderPath
        }
    }

}

extension M2ClientTypes.FsxStorageConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystemId = "file-system-id"
        case mountPoint = "mount-point"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileSystemId = self.fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
        if let mountPoint = self.mountPoint {
            try encodeContainer.encode(mountPoint, forKey: .mountPoint)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let mountPointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mountPoint)
        mountPoint = mountPointDecoded
    }
}

extension M2ClientTypes {
    /// Defines the storage configuration for an Amazon FSx file system.
    public struct FsxStorageConfiguration: Swift.Equatable {
        /// The file system identifier.
        /// This member is required.
        public var fileSystemId: Swift.String?
        /// The mount point for the file system.
        /// This member is required.
        public var mountPoint: Swift.String?

        public init(
            fileSystemId: Swift.String? = nil,
            mountPoint: Swift.String? = nil
        )
        {
            self.fileSystemId = fileSystemId
            self.mountPoint = mountPoint
        }
    }

}

extension M2ClientTypes.GdgAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit
        case rollDisposition
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let rollDisposition = self.rollDisposition {
            try encodeContainer.encode(rollDisposition, forKey: .rollDisposition)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
        let rollDispositionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rollDisposition)
        rollDisposition = rollDispositionDecoded
    }
}

extension M2ClientTypes {
    /// The required attributes for a generation data group data set. A generation data set is one of a collection of successive, historically related, catalogued data sets that together are known as a generation data group (GDG). Use this structure when you want to import a GDG. For more information on GDG, see [Generation data sets](https://www.ibm.com/docs/en/zos/2.3.0?topic=guide-generation-data-sets).
    public struct GdgAttributes: Swift.Equatable {
        /// The maximum number of generation data sets, up to 255, in a GDG.
        public var limit: Swift.Int
        /// The disposition of the data set in the catalog.
        public var rollDisposition: Swift.String?

        public init(
            limit: Swift.Int = 0,
            rollDisposition: Swift.String? = nil
        )
        {
            self.limit = limit
            self.rollDisposition = rollDisposition
        }
    }

}

extension M2ClientTypes.GdgDetailAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit
        case rollDisposition
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let rollDisposition = self.rollDisposition {
            try encodeContainer.encode(rollDisposition, forKey: .rollDisposition)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
        let rollDispositionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rollDisposition)
        rollDisposition = rollDispositionDecoded
    }
}

extension M2ClientTypes {
    /// The required attributes for a generation data group data set. A generation data set is one of a collection of successive, historically related, catalogued data sets that together are known as a generation data group (GDG). Use this structure when you want to import a GDG. For more information on GDG, see [Generation data sets](https://www.ibm.com/docs/en/zos/2.3.0?topic=guide-generation-data-sets).
    public struct GdgDetailAttributes: Swift.Equatable {
        /// The maximum number of generation data sets, up to 255, in a GDG.
        public var limit: Swift.Int
        /// The disposition of the data set in the catalog.
        public var rollDisposition: Swift.String?

        public init(
            limit: Swift.Int = 0,
            rollDisposition: Swift.String? = nil
        )
        {
            self.limit = limit
            self.rollDisposition = rollDisposition
        }
    }

}

extension GetApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())"
    }
}

public struct GetApplicationInput: Swift.Equatable {
    /// The identifier of the application.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct GetApplicationInputBody: Swift.Equatable {
}

extension GetApplicationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationArn = output.applicationArn
            self.applicationId = output.applicationId
            self.creationTime = output.creationTime
            self.deployedVersion = output.deployedVersion
            self.description = output.description
            self.engineType = output.engineType
            self.environmentId = output.environmentId
            self.kmsKeyId = output.kmsKeyId
            self.lastStartTime = output.lastStartTime
            self.latestVersion = output.latestVersion
            self.listenerArns = output.listenerArns
            self.listenerPorts = output.listenerPorts
            self.loadBalancerDnsName = output.loadBalancerDnsName
            self.logGroups = output.logGroups
            self.name = output.name
            self.roleArn = output.roleArn
            self.status = output.status
            self.statusReason = output.statusReason
            self.tags = output.tags
            self.targetGroupArns = output.targetGroupArns
        } else {
            self.applicationArn = nil
            self.applicationId = nil
            self.creationTime = nil
            self.deployedVersion = nil
            self.description = nil
            self.engineType = nil
            self.environmentId = nil
            self.kmsKeyId = nil
            self.lastStartTime = nil
            self.latestVersion = nil
            self.listenerArns = nil
            self.listenerPorts = nil
            self.loadBalancerDnsName = nil
            self.logGroups = nil
            self.name = nil
            self.roleArn = nil
            self.status = nil
            self.statusReason = nil
            self.tags = nil
            self.targetGroupArns = nil
        }
    }
}

public struct GetApplicationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// The identifier of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The timestamp when this application was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The version of the application that is deployed.
    public var deployedVersion: M2ClientTypes.DeployedVersionSummary?
    /// The description of the application.
    public var description: Swift.String?
    /// The type of the target platform for the application.
    /// This member is required.
    public var engineType: M2ClientTypes.EngineType?
    /// The identifier of the runtime environment where you want to deploy the application.
    public var environmentId: Swift.String?
    /// The identifier of a customer managed key.
    public var kmsKeyId: Swift.String?
    /// The timestamp when you last started the application. Null until the application runs for the first time.
    public var lastStartTime: ClientRuntime.Date?
    /// The latest version of the application.
    /// This member is required.
    public var latestVersion: M2ClientTypes.ApplicationVersionSummary?
    /// The Amazon Resource Name (ARN) for the network load balancer listener created in your Amazon Web Services account. Amazon Web Services Mainframe Modernization creates this listener for you the first time you deploy an application.
    public var listenerArns: [Swift.String]?
    /// The port associated with the network load balancer listener created in your Amazon Web Services account.
    public var listenerPorts: [Swift.Int]?
    /// The public DNS name of the load balancer created in your Amazon Web Services account.
    public var loadBalancerDnsName: Swift.String?
    /// The list of log summaries. Each log summary includes the log type as well as the log group identifier. These are CloudWatch logs. Amazon Web Services Mainframe Modernization pushes the application log to CloudWatch under the customer's account.
    public var logGroups: [M2ClientTypes.LogGroupSummary]?
    /// The unique identifier of the application.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the role associated with the application.
    public var roleArn: Swift.String?
    /// The status of the application.
    /// This member is required.
    public var status: M2ClientTypes.ApplicationLifecycle?
    /// The reason for the reported status.
    public var statusReason: Swift.String?
    /// A list of tags associated with the application.
    public var tags: [Swift.String:Swift.String]?
    /// Returns the Amazon Resource Names (ARNs) of the target groups that are attached to the network load balancer.
    public var targetGroupArns: [Swift.String]?

    public init(
        applicationArn: Swift.String? = nil,
        applicationId: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        deployedVersion: M2ClientTypes.DeployedVersionSummary? = nil,
        description: Swift.String? = nil,
        engineType: M2ClientTypes.EngineType? = nil,
        environmentId: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        lastStartTime: ClientRuntime.Date? = nil,
        latestVersion: M2ClientTypes.ApplicationVersionSummary? = nil,
        listenerArns: [Swift.String]? = nil,
        listenerPorts: [Swift.Int]? = nil,
        loadBalancerDnsName: Swift.String? = nil,
        logGroups: [M2ClientTypes.LogGroupSummary]? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        status: M2ClientTypes.ApplicationLifecycle? = nil,
        statusReason: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        targetGroupArns: [Swift.String]? = nil
    )
    {
        self.applicationArn = applicationArn
        self.applicationId = applicationId
        self.creationTime = creationTime
        self.deployedVersion = deployedVersion
        self.description = description
        self.engineType = engineType
        self.environmentId = environmentId
        self.kmsKeyId = kmsKeyId
        self.lastStartTime = lastStartTime
        self.latestVersion = latestVersion
        self.listenerArns = listenerArns
        self.listenerPorts = listenerPorts
        self.loadBalancerDnsName = loadBalancerDnsName
        self.logGroups = logGroups
        self.name = name
        self.roleArn = roleArn
        self.status = status
        self.statusReason = statusReason
        self.tags = tags
        self.targetGroupArns = targetGroupArns
    }
}

struct GetApplicationOutputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let applicationId: Swift.String?
    let applicationArn: Swift.String?
    let status: M2ClientTypes.ApplicationLifecycle?
    let latestVersion: M2ClientTypes.ApplicationVersionSummary?
    let deployedVersion: M2ClientTypes.DeployedVersionSummary?
    let engineType: M2ClientTypes.EngineType?
    let logGroups: [M2ClientTypes.LogGroupSummary]?
    let creationTime: ClientRuntime.Date?
    let lastStartTime: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
    let environmentId: Swift.String?
    let targetGroupArns: [Swift.String]?
    let listenerArns: [Swift.String]?
    let listenerPorts: [Swift.Int]?
    let loadBalancerDnsName: Swift.String?
    let statusReason: Swift.String?
    let kmsKeyId: Swift.String?
    let roleArn: Swift.String?
}

extension GetApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn
        case applicationId
        case creationTime
        case deployedVersion
        case description
        case engineType
        case environmentId
        case kmsKeyId
        case lastStartTime
        case latestVersion
        case listenerArns
        case listenerPorts
        case loadBalancerDnsName
        case logGroups
        case name
        case roleArn
        case status
        case statusReason
        case tags
        case targetGroupArns
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(M2ClientTypes.ApplicationLifecycle.self, forKey: .status)
        status = statusDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(M2ClientTypes.ApplicationVersionSummary.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let deployedVersionDecoded = try containerValues.decodeIfPresent(M2ClientTypes.DeployedVersionSummary.self, forKey: .deployedVersion)
        deployedVersion = deployedVersionDecoded
        let engineTypeDecoded = try containerValues.decodeIfPresent(M2ClientTypes.EngineType.self, forKey: .engineType)
        engineType = engineTypeDecoded
        let logGroupsContainer = try containerValues.decodeIfPresent([M2ClientTypes.LogGroupSummary?].self, forKey: .logGroups)
        var logGroupsDecoded0:[M2ClientTypes.LogGroupSummary]? = nil
        if let logGroupsContainer = logGroupsContainer {
            logGroupsDecoded0 = [M2ClientTypes.LogGroupSummary]()
            for structure0 in logGroupsContainer {
                if let structure0 = structure0 {
                    logGroupsDecoded0?.append(structure0)
                }
            }
        }
        logGroups = logGroupsDecoded0
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastStartTime)
        lastStartTime = lastStartTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let targetGroupArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetGroupArns)
        var targetGroupArnsDecoded0:[Swift.String]? = nil
        if let targetGroupArnsContainer = targetGroupArnsContainer {
            targetGroupArnsDecoded0 = [Swift.String]()
            for string0 in targetGroupArnsContainer {
                if let string0 = string0 {
                    targetGroupArnsDecoded0?.append(string0)
                }
            }
        }
        targetGroupArns = targetGroupArnsDecoded0
        let listenerArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .listenerArns)
        var listenerArnsDecoded0:[Swift.String]? = nil
        if let listenerArnsContainer = listenerArnsContainer {
            listenerArnsDecoded0 = [Swift.String]()
            for string0 in listenerArnsContainer {
                if let string0 = string0 {
                    listenerArnsDecoded0?.append(string0)
                }
            }
        }
        listenerArns = listenerArnsDecoded0
        let listenerPortsContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .listenerPorts)
        var listenerPortsDecoded0:[Swift.Int]? = nil
        if let listenerPortsContainer = listenerPortsContainer {
            listenerPortsDecoded0 = [Swift.Int]()
            for integer0 in listenerPortsContainer {
                if let integer0 = integer0 {
                    listenerPortsDecoded0?.append(integer0)
                }
            }
        }
        listenerPorts = listenerPortsDecoded0
        let loadBalancerDnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loadBalancerDnsName)
        loadBalancerDnsName = loadBalancerDnsNameDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

enum GetApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetApplicationVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let applicationVersion = applicationVersion else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/versions/\(applicationVersion)"
    }
}

public struct GetApplicationVersionInput: Swift.Equatable {
    /// The unique identifier of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The specific version of the application.
    /// This member is required.
    public var applicationVersion: Swift.Int?

    public init(
        applicationId: Swift.String? = nil,
        applicationVersion: Swift.Int? = nil
    )
    {
        self.applicationId = applicationId
        self.applicationVersion = applicationVersion
    }
}

struct GetApplicationVersionInputBody: Swift.Equatable {
}

extension GetApplicationVersionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetApplicationVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetApplicationVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationVersion = output.applicationVersion
            self.creationTime = output.creationTime
            self.definitionContent = output.definitionContent
            self.description = output.description
            self.name = output.name
            self.status = output.status
            self.statusReason = output.statusReason
        } else {
            self.applicationVersion = nil
            self.creationTime = nil
            self.definitionContent = nil
            self.description = nil
            self.name = nil
            self.status = nil
            self.statusReason = nil
        }
    }
}

public struct GetApplicationVersionOutput: Swift.Equatable {
    /// The specific version of the application.
    /// This member is required.
    public var applicationVersion: Swift.Int?
    /// The timestamp when the application version was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The content of the application definition. This is a JSON object that contains the resource configuration and definitions that identify an application.
    /// This member is required.
    public var definitionContent: Swift.String?
    /// The application description.
    public var description: Swift.String?
    /// The name of the application version.
    /// This member is required.
    public var name: Swift.String?
    /// The status of the application version.
    /// This member is required.
    public var status: M2ClientTypes.ApplicationVersionLifecycle?
    /// The reason for the reported status.
    public var statusReason: Swift.String?

    public init(
        applicationVersion: Swift.Int? = nil,
        creationTime: ClientRuntime.Date? = nil,
        definitionContent: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        status: M2ClientTypes.ApplicationVersionLifecycle? = nil,
        statusReason: Swift.String? = nil
    )
    {
        self.applicationVersion = applicationVersion
        self.creationTime = creationTime
        self.definitionContent = definitionContent
        self.description = description
        self.name = name
        self.status = status
        self.statusReason = statusReason
    }
}

struct GetApplicationVersionOutputBody: Swift.Equatable {
    let name: Swift.String?
    let applicationVersion: Swift.Int?
    let description: Swift.String?
    let definitionContent: Swift.String?
    let status: M2ClientTypes.ApplicationVersionLifecycle?
    let creationTime: ClientRuntime.Date?
    let statusReason: Swift.String?
}

extension GetApplicationVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationVersion
        case creationTime
        case definitionContent
        case description
        case name
        case status
        case statusReason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let applicationVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .applicationVersion)
        applicationVersion = applicationVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let definitionContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .definitionContent)
        definitionContent = definitionContentDecoded
        let statusDecoded = try containerValues.decodeIfPresent(M2ClientTypes.ApplicationVersionLifecycle.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
    }
}

enum GetApplicationVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetBatchJobExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let executionId = executionId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/batch-job-executions/\(executionId.urlPercentEncoding())"
    }
}

public struct GetBatchJobExecutionInput: Swift.Equatable {
    /// The identifier of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The unique identifier of the batch job execution.
    /// This member is required.
    public var executionId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        executionId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.executionId = executionId
    }
}

struct GetBatchJobExecutionInputBody: Swift.Equatable {
}

extension GetBatchJobExecutionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetBatchJobExecutionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBatchJobExecutionOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.batchJobIdentifier = output.batchJobIdentifier
            self.endTime = output.endTime
            self.executionId = output.executionId
            self.jobId = output.jobId
            self.jobName = output.jobName
            self.jobType = output.jobType
            self.jobUser = output.jobUser
            self.returnCode = output.returnCode
            self.startTime = output.startTime
            self.status = output.status
            self.statusReason = output.statusReason
        } else {
            self.applicationId = nil
            self.batchJobIdentifier = nil
            self.endTime = nil
            self.executionId = nil
            self.jobId = nil
            self.jobName = nil
            self.jobType = nil
            self.jobUser = nil
            self.returnCode = nil
            self.startTime = nil
            self.status = nil
            self.statusReason = nil
        }
    }
}

public struct GetBatchJobExecutionOutput: Swift.Equatable {
    /// The identifier of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The unique identifier of this batch job.
    public var batchJobIdentifier: M2ClientTypes.BatchJobIdentifier?
    /// The timestamp when the batch job execution ended.
    public var endTime: ClientRuntime.Date?
    /// The unique identifier for this batch job execution.
    /// This member is required.
    public var executionId: Swift.String?
    /// The unique identifier for this batch job.
    public var jobId: Swift.String?
    /// The name of this batch job.
    public var jobName: Swift.String?
    /// The type of job.
    public var jobType: M2ClientTypes.BatchJobType?
    /// The user for the job.
    public var jobUser: Swift.String?
    /// The batch job return code from either the Blu Age or Micro Focus runtime engines. For more information, see [Batch return codes](https://www.ibm.com/docs/en/was/8.5.5?topic=model-batch-return-codes) in the IBM WebSphere Application Server documentation.
    public var returnCode: Swift.String?
    /// The timestamp when the batch job execution started.
    /// This member is required.
    public var startTime: ClientRuntime.Date?
    /// The status of the batch job execution.
    /// This member is required.
    public var status: M2ClientTypes.BatchJobExecutionStatus?
    /// The reason for the reported status.
    public var statusReason: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        batchJobIdentifier: M2ClientTypes.BatchJobIdentifier? = nil,
        endTime: ClientRuntime.Date? = nil,
        executionId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        jobName: Swift.String? = nil,
        jobType: M2ClientTypes.BatchJobType? = nil,
        jobUser: Swift.String? = nil,
        returnCode: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        status: M2ClientTypes.BatchJobExecutionStatus? = nil,
        statusReason: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.batchJobIdentifier = batchJobIdentifier
        self.endTime = endTime
        self.executionId = executionId
        self.jobId = jobId
        self.jobName = jobName
        self.jobType = jobType
        self.jobUser = jobUser
        self.returnCode = returnCode
        self.startTime = startTime
        self.status = status
        self.statusReason = statusReason
    }
}

struct GetBatchJobExecutionOutputBody: Swift.Equatable {
    let executionId: Swift.String?
    let applicationId: Swift.String?
    let jobId: Swift.String?
    let jobName: Swift.String?
    let jobUser: Swift.String?
    let jobType: M2ClientTypes.BatchJobType?
    let status: M2ClientTypes.BatchJobExecutionStatus?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let statusReason: Swift.String?
    let returnCode: Swift.String?
    let batchJobIdentifier: M2ClientTypes.BatchJobIdentifier?
}

extension GetBatchJobExecutionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId
        case batchJobIdentifier
        case endTime
        case executionId
        case jobId
        case jobName
        case jobType
        case jobUser
        case returnCode
        case startTime
        case status
        case statusReason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobUser)
        jobUser = jobUserDecoded
        let jobTypeDecoded = try containerValues.decodeIfPresent(M2ClientTypes.BatchJobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(M2ClientTypes.BatchJobExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let returnCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .returnCode)
        returnCode = returnCodeDecoded
        let batchJobIdentifierDecoded = try containerValues.decodeIfPresent(M2ClientTypes.BatchJobIdentifier.self, forKey: .batchJobIdentifier)
        batchJobIdentifier = batchJobIdentifierDecoded
    }
}

enum GetBatchJobExecutionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDataSetDetailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let dataSetName = dataSetName else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/datasets/\(dataSetName.urlPercentEncoding())"
    }
}

public struct GetDataSetDetailsInput: Swift.Equatable {
    /// The unique identifier of the application that this data set is associated with.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The name of the data set.
    /// This member is required.
    public var dataSetName: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        dataSetName: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.dataSetName = dataSetName
    }
}

struct GetDataSetDetailsInputBody: Swift.Equatable {
}

extension GetDataSetDetailsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDataSetDetailsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDataSetDetailsOutputBody = try responseDecoder.decode(responseBody: data)
            self.blocksize = output.blocksize
            self.creationTime = output.creationTime
            self.dataSetName = output.dataSetName
            self.dataSetOrg = output.dataSetOrg
            self.lastReferencedTime = output.lastReferencedTime
            self.lastUpdatedTime = output.lastUpdatedTime
            self.location = output.location
            self.recordLength = output.recordLength
        } else {
            self.blocksize = nil
            self.creationTime = nil
            self.dataSetName = nil
            self.dataSetOrg = nil
            self.lastReferencedTime = nil
            self.lastUpdatedTime = nil
            self.location = nil
            self.recordLength = nil
        }
    }
}

public struct GetDataSetDetailsOutput: Swift.Equatable {
    /// The size of the block on disk.
    public var blocksize: Swift.Int?
    /// The timestamp when the data set was created.
    public var creationTime: ClientRuntime.Date?
    /// The name of the data set.
    /// This member is required.
    public var dataSetName: Swift.String?
    /// The type of data set. The only supported value is VSAM.
    public var dataSetOrg: M2ClientTypes.DatasetDetailOrgAttributes?
    /// The last time the data set was referenced.
    public var lastReferencedTime: ClientRuntime.Date?
    /// The last time the data set was updated.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The location where the data set is stored.
    public var location: Swift.String?
    /// The length of records in the data set.
    public var recordLength: Swift.Int?

    public init(
        blocksize: Swift.Int? = nil,
        creationTime: ClientRuntime.Date? = nil,
        dataSetName: Swift.String? = nil,
        dataSetOrg: M2ClientTypes.DatasetDetailOrgAttributes? = nil,
        lastReferencedTime: ClientRuntime.Date? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        location: Swift.String? = nil,
        recordLength: Swift.Int? = nil
    )
    {
        self.blocksize = blocksize
        self.creationTime = creationTime
        self.dataSetName = dataSetName
        self.dataSetOrg = dataSetOrg
        self.lastReferencedTime = lastReferencedTime
        self.lastUpdatedTime = lastUpdatedTime
        self.location = location
        self.recordLength = recordLength
    }
}

struct GetDataSetDetailsOutputBody: Swift.Equatable {
    let dataSetName: Swift.String?
    let dataSetOrg: M2ClientTypes.DatasetDetailOrgAttributes?
    let recordLength: Swift.Int?
    let location: Swift.String?
    let blocksize: Swift.Int?
    let creationTime: ClientRuntime.Date?
    let lastUpdatedTime: ClientRuntime.Date?
    let lastReferencedTime: ClientRuntime.Date?
}

extension GetDataSetDetailsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blocksize
        case creationTime
        case dataSetName
        case dataSetOrg
        case lastReferencedTime
        case lastUpdatedTime
        case location
        case recordLength
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetName)
        dataSetName = dataSetNameDecoded
        let dataSetOrgDecoded = try containerValues.decodeIfPresent(M2ClientTypes.DatasetDetailOrgAttributes.self, forKey: .dataSetOrg)
        dataSetOrg = dataSetOrgDecoded
        let recordLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recordLength)
        recordLength = recordLengthDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let blocksizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .blocksize)
        blocksize = blocksizeDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let lastReferencedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastReferencedTime)
        lastReferencedTime = lastReferencedTimeDecoded
    }
}

enum GetDataSetDetailsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDataSetImportTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let taskId = taskId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/dataset-import-tasks/\(taskId.urlPercentEncoding())"
    }
}

public struct GetDataSetImportTaskInput: Swift.Equatable {
    /// The application identifier.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The task identifier returned by the [CreateDataSetImportTask] operation.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.taskId = taskId
    }
}

struct GetDataSetImportTaskInputBody: Swift.Equatable {
}

extension GetDataSetImportTaskInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDataSetImportTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDataSetImportTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
            self.summary = output.summary
            self.taskId = output.taskId
        } else {
            self.status = nil
            self.summary = nil
            self.taskId = nil
        }
    }
}

public struct GetDataSetImportTaskOutput: Swift.Equatable {
    /// The status of the task.
    /// This member is required.
    public var status: M2ClientTypes.DataSetTaskLifecycle?
    /// A summary of the status of the task.
    public var summary: M2ClientTypes.DataSetImportSummary?
    /// The task identifier.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        status: M2ClientTypes.DataSetTaskLifecycle? = nil,
        summary: M2ClientTypes.DataSetImportSummary? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.status = status
        self.summary = summary
        self.taskId = taskId
    }
}

struct GetDataSetImportTaskOutputBody: Swift.Equatable {
    let taskId: Swift.String?
    let status: M2ClientTypes.DataSetTaskLifecycle?
    let summary: M2ClientTypes.DataSetImportSummary?
}

extension GetDataSetImportTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
        case summary
        case taskId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(M2ClientTypes.DataSetTaskLifecycle.self, forKey: .status)
        status = statusDecoded
        let summaryDecoded = try containerValues.decodeIfPresent(M2ClientTypes.DataSetImportSummary.self, forKey: .summary)
        summary = summaryDecoded
    }
}

enum GetDataSetImportTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let deploymentId = deploymentId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/deployments/\(deploymentId.urlPercentEncoding())"
    }
}

public struct GetDeploymentInput: Swift.Equatable {
    /// The unique identifier of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The unique identifier for the deployment.
    /// This member is required.
    public var deploymentId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        deploymentId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.deploymentId = deploymentId
    }
}

struct GetDeploymentInputBody: Swift.Equatable {
}

extension GetDeploymentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDeploymentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDeploymentOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.applicationVersion = output.applicationVersion
            self.creationTime = output.creationTime
            self.deploymentId = output.deploymentId
            self.environmentId = output.environmentId
            self.status = output.status
            self.statusReason = output.statusReason
        } else {
            self.applicationId = nil
            self.applicationVersion = nil
            self.creationTime = nil
            self.deploymentId = nil
            self.environmentId = nil
            self.status = nil
            self.statusReason = nil
        }
    }
}

public struct GetDeploymentOutput: Swift.Equatable {
    /// The unique identifier of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The application version.
    /// This member is required.
    public var applicationVersion: Swift.Int?
    /// The timestamp when the deployment was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The unique identifier of the deployment.
    /// This member is required.
    public var deploymentId: Swift.String?
    /// The unique identifier of the runtime environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The status of the deployment.
    /// This member is required.
    public var status: M2ClientTypes.DeploymentLifecycle?
    /// The reason for the reported status.
    public var statusReason: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        applicationVersion: Swift.Int? = nil,
        creationTime: ClientRuntime.Date? = nil,
        deploymentId: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        status: M2ClientTypes.DeploymentLifecycle? = nil,
        statusReason: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.applicationVersion = applicationVersion
        self.creationTime = creationTime
        self.deploymentId = deploymentId
        self.environmentId = environmentId
        self.status = status
        self.statusReason = statusReason
    }
}

struct GetDeploymentOutputBody: Swift.Equatable {
    let deploymentId: Swift.String?
    let applicationId: Swift.String?
    let environmentId: Swift.String?
    let applicationVersion: Swift.Int?
    let status: M2ClientTypes.DeploymentLifecycle?
    let creationTime: ClientRuntime.Date?
    let statusReason: Swift.String?
}

extension GetDeploymentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId
        case applicationVersion
        case creationTime
        case deploymentId
        case environmentId
        case status
        case statusReason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let applicationVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .applicationVersion)
        applicationVersion = applicationVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(M2ClientTypes.DeploymentLifecycle.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
    }
}

enum GetDeploymentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let environmentId = environmentId else {
            return nil
        }
        return "/environments/\(environmentId.urlPercentEncoding())"
    }
}

public struct GetEnvironmentInput: Swift.Equatable {
    /// The unique identifier of the runtime environment.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        environmentId: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
    }
}

struct GetEnvironmentInputBody: Swift.Equatable {
}

extension GetEnvironmentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEnvironmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.actualCapacity = output.actualCapacity
            self.creationTime = output.creationTime
            self.description = output.description
            self.engineType = output.engineType
            self.engineVersion = output.engineVersion
            self.environmentArn = output.environmentArn
            self.environmentId = output.environmentId
            self.highAvailabilityConfig = output.highAvailabilityConfig
            self.instanceType = output.instanceType
            self.kmsKeyId = output.kmsKeyId
            self.loadBalancerArn = output.loadBalancerArn
            self.name = output.name
            self.pendingMaintenance = output.pendingMaintenance
            self.preferredMaintenanceWindow = output.preferredMaintenanceWindow
            self.publiclyAccessible = output.publiclyAccessible
            self.securityGroupIds = output.securityGroupIds
            self.status = output.status
            self.statusReason = output.statusReason
            self.storageConfigurations = output.storageConfigurations
            self.subnetIds = output.subnetIds
            self.tags = output.tags
            self.vpcId = output.vpcId
        } else {
            self.actualCapacity = nil
            self.creationTime = nil
            self.description = nil
            self.engineType = nil
            self.engineVersion = nil
            self.environmentArn = nil
            self.environmentId = nil
            self.highAvailabilityConfig = nil
            self.instanceType = nil
            self.kmsKeyId = nil
            self.loadBalancerArn = nil
            self.name = nil
            self.pendingMaintenance = nil
            self.preferredMaintenanceWindow = nil
            self.publiclyAccessible = false
            self.securityGroupIds = nil
            self.status = nil
            self.statusReason = nil
            self.storageConfigurations = nil
            self.subnetIds = nil
            self.tags = nil
            self.vpcId = nil
        }
    }
}

public struct GetEnvironmentOutput: Swift.Equatable {
    /// The number of instances included in the runtime environment. A standalone runtime environment has a maxiumum of one instance. Currently, a high availability runtime environment has a maximum of two instances.
    public var actualCapacity: Swift.Int?
    /// The timestamp when the runtime environment was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The description of the runtime environment.
    public var description: Swift.String?
    /// The target platform for the runtime environment.
    /// This member is required.
    public var engineType: M2ClientTypes.EngineType?
    /// The version of the runtime engine.
    /// This member is required.
    public var engineVersion: Swift.String?
    /// The Amazon Resource Name (ARN) of the runtime environment.
    /// This member is required.
    public var environmentArn: Swift.String?
    /// The unique identifier of the runtime environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The desired capacity of the high availability configuration for the runtime environment.
    public var highAvailabilityConfig: M2ClientTypes.HighAvailabilityConfig?
    /// The type of instance underlying the runtime environment.
    /// This member is required.
    public var instanceType: Swift.String?
    /// The identifier of a customer managed key.
    public var kmsKeyId: Swift.String?
    /// The Amazon Resource Name (ARN) for the load balancer used with the runtime environment.
    public var loadBalancerArn: Swift.String?
    /// The name of the runtime environment. Must be unique within the account.
    /// This member is required.
    public var name: Swift.String?
    /// Indicates the pending maintenance scheduled on this environment.
    public var pendingMaintenance: M2ClientTypes.PendingMaintenance?
    /// Configures the maintenance window you want for the runtime environment. If you do not provide a value, a random system-generated value will be assigned.
    public var preferredMaintenanceWindow: Swift.String?
    /// Whether applications running in this runtime environment are publicly accessible.
    public var publiclyAccessible: Swift.Bool
    /// The unique identifiers of the security groups assigned to this runtime environment.
    /// This member is required.
    public var securityGroupIds: [Swift.String]?
    /// The status of the runtime environment.
    /// This member is required.
    public var status: M2ClientTypes.EnvironmentLifecycle?
    /// The reason for the reported status.
    public var statusReason: Swift.String?
    /// The storage configurations defined for the runtime environment.
    public var storageConfigurations: [M2ClientTypes.StorageConfiguration]?
    /// The unique identifiers of the subnets assigned to this runtime environment.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// The tags defined for this runtime environment.
    public var tags: [Swift.String:Swift.String]?
    /// The unique identifier for the VPC used with this runtime environment.
    /// This member is required.
    public var vpcId: Swift.String?

    public init(
        actualCapacity: Swift.Int? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        engineType: M2ClientTypes.EngineType? = nil,
        engineVersion: Swift.String? = nil,
        environmentArn: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        highAvailabilityConfig: M2ClientTypes.HighAvailabilityConfig? = nil,
        instanceType: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        loadBalancerArn: Swift.String? = nil,
        name: Swift.String? = nil,
        pendingMaintenance: M2ClientTypes.PendingMaintenance? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        publiclyAccessible: Swift.Bool = false,
        securityGroupIds: [Swift.String]? = nil,
        status: M2ClientTypes.EnvironmentLifecycle? = nil,
        statusReason: Swift.String? = nil,
        storageConfigurations: [M2ClientTypes.StorageConfiguration]? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.actualCapacity = actualCapacity
        self.creationTime = creationTime
        self.description = description
        self.engineType = engineType
        self.engineVersion = engineVersion
        self.environmentArn = environmentArn
        self.environmentId = environmentId
        self.highAvailabilityConfig = highAvailabilityConfig
        self.instanceType = instanceType
        self.kmsKeyId = kmsKeyId
        self.loadBalancerArn = loadBalancerArn
        self.name = name
        self.pendingMaintenance = pendingMaintenance
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.publiclyAccessible = publiclyAccessible
        self.securityGroupIds = securityGroupIds
        self.status = status
        self.statusReason = statusReason
        self.storageConfigurations = storageConfigurations
        self.subnetIds = subnetIds
        self.tags = tags
        self.vpcId = vpcId
    }
}

struct GetEnvironmentOutputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let environmentArn: Swift.String?
    let environmentId: Swift.String?
    let instanceType: Swift.String?
    let status: M2ClientTypes.EnvironmentLifecycle?
    let engineType: M2ClientTypes.EngineType?
    let engineVersion: Swift.String?
    let vpcId: Swift.String?
    let subnetIds: [Swift.String]?
    let securityGroupIds: [Swift.String]?
    let creationTime: ClientRuntime.Date?
    let storageConfigurations: [M2ClientTypes.StorageConfiguration]?
    let tags: [Swift.String:Swift.String]?
    let highAvailabilityConfig: M2ClientTypes.HighAvailabilityConfig?
    let publiclyAccessible: Swift.Bool
    let actualCapacity: Swift.Int?
    let loadBalancerArn: Swift.String?
    let statusReason: Swift.String?
    let preferredMaintenanceWindow: Swift.String?
    let pendingMaintenance: M2ClientTypes.PendingMaintenance?
    let kmsKeyId: Swift.String?
}

extension GetEnvironmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actualCapacity
        case creationTime
        case description
        case engineType
        case engineVersion
        case environmentArn
        case environmentId
        case highAvailabilityConfig
        case instanceType
        case kmsKeyId
        case loadBalancerArn
        case name
        case pendingMaintenance
        case preferredMaintenanceWindow
        case publiclyAccessible
        case securityGroupIds
        case status
        case statusReason
        case storageConfigurations
        case subnetIds
        case tags
        case vpcId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let environmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentArn)
        environmentArn = environmentArnDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(M2ClientTypes.EnvironmentLifecycle.self, forKey: .status)
        status = statusDecoded
        let engineTypeDecoded = try containerValues.decodeIfPresent(M2ClientTypes.EngineType.self, forKey: .engineType)
        engineType = engineTypeDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let storageConfigurationsContainer = try containerValues.decodeIfPresent([M2ClientTypes.StorageConfiguration?].self, forKey: .storageConfigurations)
        var storageConfigurationsDecoded0:[M2ClientTypes.StorageConfiguration]? = nil
        if let storageConfigurationsContainer = storageConfigurationsContainer {
            storageConfigurationsDecoded0 = [M2ClientTypes.StorageConfiguration]()
            for union0 in storageConfigurationsContainer {
                if let union0 = union0 {
                    storageConfigurationsDecoded0?.append(union0)
                }
            }
        }
        storageConfigurations = storageConfigurationsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let highAvailabilityConfigDecoded = try containerValues.decodeIfPresent(M2ClientTypes.HighAvailabilityConfig.self, forKey: .highAvailabilityConfig)
        highAvailabilityConfig = highAvailabilityConfigDecoded
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible) ?? false
        publiclyAccessible = publiclyAccessibleDecoded
        let actualCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .actualCapacity)
        actualCapacity = actualCapacityDecoded
        let loadBalancerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loadBalancerArn)
        loadBalancerArn = loadBalancerArnDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let pendingMaintenanceDecoded = try containerValues.decodeIfPresent(M2ClientTypes.PendingMaintenance.self, forKey: .pendingMaintenance)
        pendingMaintenance = pendingMaintenanceDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

enum GetEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSignedBluinsightsUrlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/signed-bi-url"
    }
}

public struct GetSignedBluinsightsUrlInput: Swift.Equatable {

    public init() { }
}

struct GetSignedBluinsightsUrlInputBody: Swift.Equatable {
}

extension GetSignedBluinsightsUrlInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSignedBluinsightsUrlOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSignedBluinsightsUrlOutputBody = try responseDecoder.decode(responseBody: data)
            self.signedBiUrl = output.signedBiUrl
        } else {
            self.signedBiUrl = nil
        }
    }
}

public struct GetSignedBluinsightsUrlOutput: Swift.Equatable {
    /// Single sign-on AWS Blu Insights URL.
    /// This member is required.
    public var signedBiUrl: Swift.String?

    public init(
        signedBiUrl: Swift.String? = nil
    )
    {
        self.signedBiUrl = signedBiUrl
    }
}

struct GetSignedBluinsightsUrlOutputBody: Swift.Equatable {
    let signedBiUrl: Swift.String?
}

extension GetSignedBluinsightsUrlOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case signedBiUrl
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signedBiUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signedBiUrl)
        signedBiUrl = signedBiUrlDecoded
    }
}

enum GetSignedBluinsightsUrlOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension M2ClientTypes.HighAvailabilityConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case desiredCapacity
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let desiredCapacity = self.desiredCapacity {
            try encodeContainer.encode(desiredCapacity, forKey: .desiredCapacity)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let desiredCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .desiredCapacity)
        desiredCapacity = desiredCapacityDecoded
    }
}

extension M2ClientTypes {
    /// Defines the details of a high availability configuration.
    public struct HighAvailabilityConfig: Swift.Equatable {
        /// The number of instances in a high availability configuration. The minimum possible value is 1 and the maximum is 100.
        /// This member is required.
        public var desiredCapacity: Swift.Int?

        public init(
            desiredCapacity: Swift.Int? = nil
        )
        {
            self.desiredCapacity = desiredCapacity
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = 0
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An unexpected error occurred during the processing of the request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The number of seconds to wait before retrying the request.
        public internal(set) var retryAfterSeconds: Swift.Int = 0
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListApplicationVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListApplicationVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/versions"
    }
}

public struct ListApplicationVersionsInput: Swift.Equatable {
    /// The unique identifier of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The maximum number of application versions to return.
    public var maxResults: Swift.Int?
    /// A pagination token returned from a previous call to this operation. This specifies the next item to return. To return to the beginning of the list, exclude this parameter.
    public var nextToken: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApplicationVersionsInputBody: Swift.Equatable {
}

extension ListApplicationVersionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListApplicationVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListApplicationVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationVersions = output.applicationVersions
            self.nextToken = output.nextToken
        } else {
            self.applicationVersions = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationVersionsOutput: Swift.Equatable {
    /// The list of application versions.
    /// This member is required.
    public var applicationVersions: [M2ClientTypes.ApplicationVersionSummary]?
    /// If there are more items to return, this contains a token that is passed to a subsequent call to this operation to retrieve the next set of items.
    public var nextToken: Swift.String?

    public init(
        applicationVersions: [M2ClientTypes.ApplicationVersionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationVersions = applicationVersions
        self.nextToken = nextToken
    }
}

struct ListApplicationVersionsOutputBody: Swift.Equatable {
    let applicationVersions: [M2ClientTypes.ApplicationVersionSummary]?
    let nextToken: Swift.String?
}

extension ListApplicationVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationVersions
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationVersionsContainer = try containerValues.decodeIfPresent([M2ClientTypes.ApplicationVersionSummary?].self, forKey: .applicationVersions)
        var applicationVersionsDecoded0:[M2ClientTypes.ApplicationVersionSummary]? = nil
        if let applicationVersionsContainer = applicationVersionsContainer {
            applicationVersionsDecoded0 = [M2ClientTypes.ApplicationVersionSummary]()
            for structure0 in applicationVersionsContainer {
                if let structure0 = structure0 {
                    applicationVersionsDecoded0?.append(structure0)
                }
            }
        }
        applicationVersions = applicationVersionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListApplicationVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListApplicationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let names = names {
                names.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "names".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            if let environmentId = environmentId {
                let environmentIdQueryItem = ClientRuntime.URLQueryItem(name: "environmentId".urlPercentEncoding(), value: Swift.String(environmentId).urlPercentEncoding())
                items.append(environmentIdQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListApplicationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/applications"
    }
}

public struct ListApplicationsInput: Swift.Equatable {
    /// The unique identifier of the runtime environment where the applications are deployed.
    public var environmentId: Swift.String?
    /// The maximum number of applications to return.
    public var maxResults: Swift.Int?
    /// The names of the applications.
    public var names: [Swift.String]?
    /// A pagination token to control the number of applications displayed in the list.
    public var nextToken: Swift.String?

    public init(
        environmentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        names: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
        self.maxResults = maxResults
        self.names = names
        self.nextToken = nextToken
    }
}

struct ListApplicationsInputBody: Swift.Equatable {
}

extension ListApplicationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListApplicationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListApplicationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.applications = output.applications
            self.nextToken = output.nextToken
        } else {
            self.applications = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationsOutput: Swift.Equatable {
    /// Returns a list of summary details for all the applications in a runtime environment.
    /// This member is required.
    public var applications: [M2ClientTypes.ApplicationSummary]?
    /// A pagination token that's returned when the response doesn't contain all applications.
    public var nextToken: Swift.String?

    public init(
        applications: [M2ClientTypes.ApplicationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applications = applications
        self.nextToken = nextToken
    }
}

struct ListApplicationsOutputBody: Swift.Equatable {
    let applications: [M2ClientTypes.ApplicationSummary]?
    let nextToken: Swift.String?
}

extension ListApplicationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applications
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationsContainer = try containerValues.decodeIfPresent([M2ClientTypes.ApplicationSummary?].self, forKey: .applications)
        var applicationsDecoded0:[M2ClientTypes.ApplicationSummary]? = nil
        if let applicationsContainer = applicationsContainer {
            applicationsDecoded0 = [M2ClientTypes.ApplicationSummary]()
            for structure0 in applicationsContainer {
                if let structure0 = structure0 {
                    applicationsDecoded0?.append(structure0)
                }
            }
        }
        applications = applicationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListApplicationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListBatchJobDefinitionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let `prefix` = `prefix` {
                let prefixQueryItem = ClientRuntime.URLQueryItem(name: "prefix".urlPercentEncoding(), value: Swift.String(`prefix`).urlPercentEncoding())
                items.append(prefixQueryItem)
            }
            return items
        }
    }
}

extension ListBatchJobDefinitionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/batch-job-definitions"
    }
}

public struct ListBatchJobDefinitionsInput: Swift.Equatable {
    /// The identifier of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The maximum number of batch job definitions to return.
    public var maxResults: Swift.Int?
    /// A pagination token returned from a previous call to this operation. This specifies the next item to return. To return to the beginning of the list, exclude this parameter.
    public var nextToken: Swift.String?
    /// If the batch job definition is a FileBatchJobDefinition, the prefix allows you to search on the file names of FileBatchJobDefinitions.
    public var `prefix`: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        `prefix`: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.`prefix` = `prefix`
    }
}

struct ListBatchJobDefinitionsInputBody: Swift.Equatable {
}

extension ListBatchJobDefinitionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListBatchJobDefinitionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListBatchJobDefinitionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.batchJobDefinitions = output.batchJobDefinitions
            self.nextToken = output.nextToken
        } else {
            self.batchJobDefinitions = nil
            self.nextToken = nil
        }
    }
}

public struct ListBatchJobDefinitionsOutput: Swift.Equatable {
    /// The list of batch job definitions.
    /// This member is required.
    public var batchJobDefinitions: [M2ClientTypes.BatchJobDefinition]?
    /// If there are more items to return, this contains a token that is passed to a subsequent call to this operation to retrieve the next set of items.
    public var nextToken: Swift.String?

    public init(
        batchJobDefinitions: [M2ClientTypes.BatchJobDefinition]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.batchJobDefinitions = batchJobDefinitions
        self.nextToken = nextToken
    }
}

struct ListBatchJobDefinitionsOutputBody: Swift.Equatable {
    let batchJobDefinitions: [M2ClientTypes.BatchJobDefinition]?
    let nextToken: Swift.String?
}

extension ListBatchJobDefinitionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchJobDefinitions
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchJobDefinitionsContainer = try containerValues.decodeIfPresent([M2ClientTypes.BatchJobDefinition?].self, forKey: .batchJobDefinitions)
        var batchJobDefinitionsDecoded0:[M2ClientTypes.BatchJobDefinition]? = nil
        if let batchJobDefinitionsContainer = batchJobDefinitionsContainer {
            batchJobDefinitionsDecoded0 = [M2ClientTypes.BatchJobDefinition]()
            for union0 in batchJobDefinitionsContainer {
                if let union0 = union0 {
                    batchJobDefinitionsDecoded0?.append(union0)
                }
            }
        }
        batchJobDefinitions = batchJobDefinitionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListBatchJobDefinitionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListBatchJobExecutionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let jobName = jobName {
                let jobNameQueryItem = ClientRuntime.URLQueryItem(name: "jobName".urlPercentEncoding(), value: Swift.String(jobName).urlPercentEncoding())
                items.append(jobNameQueryItem)
            }
            if let executionIds = executionIds {
                executionIds.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "executionIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let startedAfter = startedAfter {
                let startedAfterQueryItem = ClientRuntime.URLQueryItem(name: "startedAfter".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: startedAfter)).urlPercentEncoding())
                items.append(startedAfterQueryItem)
            }
            if let startedBefore = startedBefore {
                let startedBeforeQueryItem = ClientRuntime.URLQueryItem(name: "startedBefore".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: startedBefore)).urlPercentEncoding())
                items.append(startedBeforeQueryItem)
            }
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            return items
        }
    }
}

extension ListBatchJobExecutionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/batch-job-executions"
    }
}

public struct ListBatchJobExecutionsInput: Swift.Equatable {
    /// The unique identifier of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The unique identifier of each batch job execution.
    public var executionIds: [Swift.String]?
    /// The name of each batch job execution.
    public var jobName: Swift.String?
    /// The maximum number of batch job executions to return.
    public var maxResults: Swift.Int?
    /// A pagination token to control the number of batch job executions displayed in the list.
    public var nextToken: Swift.String?
    /// The time after which the batch job executions started.
    public var startedAfter: ClientRuntime.Date?
    /// The time before the batch job executions started.
    public var startedBefore: ClientRuntime.Date?
    /// The status of the batch job executions.
    public var status: M2ClientTypes.BatchJobExecutionStatus?

    public init(
        applicationId: Swift.String? = nil,
        executionIds: [Swift.String]? = nil,
        jobName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startedAfter: ClientRuntime.Date? = nil,
        startedBefore: ClientRuntime.Date? = nil,
        status: M2ClientTypes.BatchJobExecutionStatus? = nil
    )
    {
        self.applicationId = applicationId
        self.executionIds = executionIds
        self.jobName = jobName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startedAfter = startedAfter
        self.startedBefore = startedBefore
        self.status = status
    }
}

struct ListBatchJobExecutionsInputBody: Swift.Equatable {
}

extension ListBatchJobExecutionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListBatchJobExecutionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListBatchJobExecutionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.batchJobExecutions = output.batchJobExecutions
            self.nextToken = output.nextToken
        } else {
            self.batchJobExecutions = nil
            self.nextToken = nil
        }
    }
}

public struct ListBatchJobExecutionsOutput: Swift.Equatable {
    /// Returns a list of batch job executions for an application.
    /// This member is required.
    public var batchJobExecutions: [M2ClientTypes.BatchJobExecutionSummary]?
    /// A pagination token that's returned when the response doesn't contain all batch job executions.
    public var nextToken: Swift.String?

    public init(
        batchJobExecutions: [M2ClientTypes.BatchJobExecutionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.batchJobExecutions = batchJobExecutions
        self.nextToken = nextToken
    }
}

struct ListBatchJobExecutionsOutputBody: Swift.Equatable {
    let batchJobExecutions: [M2ClientTypes.BatchJobExecutionSummary]?
    let nextToken: Swift.String?
}

extension ListBatchJobExecutionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchJobExecutions
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchJobExecutionsContainer = try containerValues.decodeIfPresent([M2ClientTypes.BatchJobExecutionSummary?].self, forKey: .batchJobExecutions)
        var batchJobExecutionsDecoded0:[M2ClientTypes.BatchJobExecutionSummary]? = nil
        if let batchJobExecutionsContainer = batchJobExecutionsContainer {
            batchJobExecutionsDecoded0 = [M2ClientTypes.BatchJobExecutionSummary]()
            for structure0 in batchJobExecutionsContainer {
                if let structure0 = structure0 {
                    batchJobExecutionsDecoded0?.append(structure0)
                }
            }
        }
        batchJobExecutions = batchJobExecutionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListBatchJobExecutionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDataSetImportHistoryInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListDataSetImportHistoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/dataset-import-tasks"
    }
}

public struct ListDataSetImportHistoryInput: Swift.Equatable {
    /// The unique identifier of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The maximum number of objects to return.
    public var maxResults: Swift.Int?
    /// A pagination token returned from a previous call to this operation. This specifies the next item to return. To return to the beginning of the list, exclude this parameter.
    public var nextToken: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDataSetImportHistoryInputBody: Swift.Equatable {
}

extension ListDataSetImportHistoryInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDataSetImportHistoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDataSetImportHistoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataSetImportTasks = output.dataSetImportTasks
            self.nextToken = output.nextToken
        } else {
            self.dataSetImportTasks = nil
            self.nextToken = nil
        }
    }
}

public struct ListDataSetImportHistoryOutput: Swift.Equatable {
    /// The data set import tasks.
    /// This member is required.
    public var dataSetImportTasks: [M2ClientTypes.DataSetImportTask]?
    /// If there are more items to return, this contains a token that is passed to a subsequent call to this operation to retrieve the next set of items.
    public var nextToken: Swift.String?

    public init(
        dataSetImportTasks: [M2ClientTypes.DataSetImportTask]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataSetImportTasks = dataSetImportTasks
        self.nextToken = nextToken
    }
}

struct ListDataSetImportHistoryOutputBody: Swift.Equatable {
    let dataSetImportTasks: [M2ClientTypes.DataSetImportTask]?
    let nextToken: Swift.String?
}

extension ListDataSetImportHistoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSetImportTasks
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetImportTasksContainer = try containerValues.decodeIfPresent([M2ClientTypes.DataSetImportTask?].self, forKey: .dataSetImportTasks)
        var dataSetImportTasksDecoded0:[M2ClientTypes.DataSetImportTask]? = nil
        if let dataSetImportTasksContainer = dataSetImportTasksContainer {
            dataSetImportTasksDecoded0 = [M2ClientTypes.DataSetImportTask]()
            for structure0 in dataSetImportTasksContainer {
                if let structure0 = structure0 {
                    dataSetImportTasksDecoded0?.append(structure0)
                }
            }
        }
        dataSetImportTasks = dataSetImportTasksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDataSetImportHistoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDataSetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let `prefix` = `prefix` {
                let prefixQueryItem = ClientRuntime.URLQueryItem(name: "prefix".urlPercentEncoding(), value: Swift.String(`prefix`).urlPercentEncoding())
                items.append(prefixQueryItem)
            }
            return items
        }
    }
}

extension ListDataSetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/datasets"
    }
}

public struct ListDataSetsInput: Swift.Equatable {
    /// The unique identifier of the application for which you want to list the associated data sets.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The maximum number of objects to return.
    public var maxResults: Swift.Int?
    /// A pagination token returned from a previous call to this operation. This specifies the next item to return. To return to the beginning of the list, exclude this parameter.
    public var nextToken: Swift.String?
    /// The prefix of the data set name, which you can use to filter the list of data sets.
    public var `prefix`: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        `prefix`: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.`prefix` = `prefix`
    }
}

struct ListDataSetsInputBody: Swift.Equatable {
}

extension ListDataSetsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDataSetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDataSetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataSets = output.dataSets
            self.nextToken = output.nextToken
        } else {
            self.dataSets = nil
            self.nextToken = nil
        }
    }
}

public struct ListDataSetsOutput: Swift.Equatable {
    /// The list of data sets, containing information including the creation time, the data set name, the data set organization, the data set format, and the last time the data set was referenced or updated.
    /// This member is required.
    public var dataSets: [M2ClientTypes.DataSetSummary]?
    /// If there are more items to return, this contains a token that is passed to a subsequent call to this operation to retrieve the next set of items.
    public var nextToken: Swift.String?

    public init(
        dataSets: [M2ClientTypes.DataSetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataSets = dataSets
        self.nextToken = nextToken
    }
}

struct ListDataSetsOutputBody: Swift.Equatable {
    let dataSets: [M2ClientTypes.DataSetSummary]?
    let nextToken: Swift.String?
}

extension ListDataSetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSets
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetsContainer = try containerValues.decodeIfPresent([M2ClientTypes.DataSetSummary?].self, forKey: .dataSets)
        var dataSetsDecoded0:[M2ClientTypes.DataSetSummary]? = nil
        if let dataSetsContainer = dataSetsContainer {
            dataSetsDecoded0 = [M2ClientTypes.DataSetSummary]()
            for structure0 in dataSetsContainer {
                if let structure0 = structure0 {
                    dataSetsDecoded0?.append(structure0)
                }
            }
        }
        dataSets = dataSetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDataSetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDeploymentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListDeploymentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/deployments"
    }
}

public struct ListDeploymentsInput: Swift.Equatable {
    /// The application identifier.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The maximum number of objects to return.
    public var maxResults: Swift.Int?
    /// A pagination token returned from a previous call to this operation. This specifies the next item to return. To return to the beginning of the list, exclude this parameter.
    public var nextToken: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDeploymentsInputBody: Swift.Equatable {
}

extension ListDeploymentsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDeploymentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDeploymentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.deployments = output.deployments
            self.nextToken = output.nextToken
        } else {
            self.deployments = nil
            self.nextToken = nil
        }
    }
}

public struct ListDeploymentsOutput: Swift.Equatable {
    /// The list of deployments that is returned.
    /// This member is required.
    public var deployments: [M2ClientTypes.DeploymentSummary]?
    /// If there are more items to return, this contains a token that is passed to a subsequent call to this operation to retrieve the next set of items.
    public var nextToken: Swift.String?

    public init(
        deployments: [M2ClientTypes.DeploymentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deployments = deployments
        self.nextToken = nextToken
    }
}

struct ListDeploymentsOutputBody: Swift.Equatable {
    let deployments: [M2ClientTypes.DeploymentSummary]?
    let nextToken: Swift.String?
}

extension ListDeploymentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deployments
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentsContainer = try containerValues.decodeIfPresent([M2ClientTypes.DeploymentSummary?].self, forKey: .deployments)
        var deploymentsDecoded0:[M2ClientTypes.DeploymentSummary]? = nil
        if let deploymentsContainer = deploymentsContainer {
            deploymentsDecoded0 = [M2ClientTypes.DeploymentSummary]()
            for structure0 in deploymentsContainer {
                if let structure0 = structure0 {
                    deploymentsDecoded0?.append(structure0)
                }
            }
        }
        deployments = deploymentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDeploymentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListEngineVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let engineType = engineType {
                let engineTypeQueryItem = ClientRuntime.URLQueryItem(name: "engineType".urlPercentEncoding(), value: Swift.String(engineType.rawValue).urlPercentEncoding())
                items.append(engineTypeQueryItem)
            }
            return items
        }
    }
}

extension ListEngineVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/engine-versions"
    }
}

public struct ListEngineVersionsInput: Swift.Equatable {
    /// The type of target platform.
    public var engineType: M2ClientTypes.EngineType?
    /// The maximum number of objects to return.
    public var maxResults: Swift.Int?
    /// A pagination token returned from a previous call to this operation. This specifies the next item to return. To return to the beginning of the list, exclude this parameter.
    public var nextToken: Swift.String?

    public init(
        engineType: M2ClientTypes.EngineType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.engineType = engineType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEngineVersionsInputBody: Swift.Equatable {
}

extension ListEngineVersionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListEngineVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEngineVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.engineVersions = output.engineVersions
            self.nextToken = output.nextToken
        } else {
            self.engineVersions = nil
            self.nextToken = nil
        }
    }
}

public struct ListEngineVersionsOutput: Swift.Equatable {
    /// Returns the engine versions.
    /// This member is required.
    public var engineVersions: [M2ClientTypes.EngineVersionsSummary]?
    /// If there are more items to return, this contains a token that is passed to a subsequent call to this operation to retrieve the next set of items.
    public var nextToken: Swift.String?

    public init(
        engineVersions: [M2ClientTypes.EngineVersionsSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.engineVersions = engineVersions
        self.nextToken = nextToken
    }
}

struct ListEngineVersionsOutputBody: Swift.Equatable {
    let engineVersions: [M2ClientTypes.EngineVersionsSummary]?
    let nextToken: Swift.String?
}

extension ListEngineVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineVersions
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineVersionsContainer = try containerValues.decodeIfPresent([M2ClientTypes.EngineVersionsSummary?].self, forKey: .engineVersions)
        var engineVersionsDecoded0:[M2ClientTypes.EngineVersionsSummary]? = nil
        if let engineVersionsContainer = engineVersionsContainer {
            engineVersionsDecoded0 = [M2ClientTypes.EngineVersionsSummary]()
            for structure0 in engineVersionsContainer {
                if let structure0 = structure0 {
                    engineVersionsDecoded0?.append(structure0)
                }
            }
        }
        engineVersions = engineVersionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEngineVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListEnvironmentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let names = names {
                names.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "names".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let engineType = engineType {
                let engineTypeQueryItem = ClientRuntime.URLQueryItem(name: "engineType".urlPercentEncoding(), value: Swift.String(engineType.rawValue).urlPercentEncoding())
                items.append(engineTypeQueryItem)
            }
            return items
        }
    }
}

extension ListEnvironmentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/environments"
    }
}

public struct ListEnvironmentsInput: Swift.Equatable {
    /// The engine type for the runtime environment.
    public var engineType: M2ClientTypes.EngineType?
    /// The maximum number of runtime environments to return.
    public var maxResults: Swift.Int?
    /// The names of the runtime environments. Must be unique within the account.
    public var names: [Swift.String]?
    /// A pagination token to control the number of runtime environments displayed in the list.
    public var nextToken: Swift.String?

    public init(
        engineType: M2ClientTypes.EngineType? = nil,
        maxResults: Swift.Int? = nil,
        names: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.engineType = engineType
        self.maxResults = maxResults
        self.names = names
        self.nextToken = nextToken
    }
}

struct ListEnvironmentsInputBody: Swift.Equatable {
}

extension ListEnvironmentsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListEnvironmentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEnvironmentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.environments = output.environments
            self.nextToken = output.nextToken
        } else {
            self.environments = nil
            self.nextToken = nil
        }
    }
}

public struct ListEnvironmentsOutput: Swift.Equatable {
    /// Returns a list of summary details for all the runtime environments in your account.
    /// This member is required.
    public var environments: [M2ClientTypes.EnvironmentSummary]?
    /// A pagination token that's returned when the response doesn't contain all the runtime environments.
    public var nextToken: Swift.String?

    public init(
        environments: [M2ClientTypes.EnvironmentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.environments = environments
        self.nextToken = nextToken
    }
}

struct ListEnvironmentsOutputBody: Swift.Equatable {
    let environments: [M2ClientTypes.EnvironmentSummary]?
    let nextToken: Swift.String?
}

extension ListEnvironmentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environments
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentsContainer = try containerValues.decodeIfPresent([M2ClientTypes.EnvironmentSummary?].self, forKey: .environments)
        var environmentsDecoded0:[M2ClientTypes.EnvironmentSummary]? = nil
        if let environmentsContainer = environmentsContainer {
            environmentsDecoded0 = [M2ClientTypes.EnvironmentSummary]()
            for structure0 in environmentsContainer {
                if let structure0 = structure0 {
                    environmentsDecoded0?.append(structure0)
                }
            }
        }
        environments = environmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEnvironmentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The tags for the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension M2ClientTypes.LogGroupSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logGroupName
        case logType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logGroupName = self.logGroupName {
            try encodeContainer.encode(logGroupName, forKey: .logGroupName)
        }
        if let logType = self.logType {
            try encodeContainer.encode(logType, forKey: .logType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logType)
        logType = logTypeDecoded
        let logGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
    }
}

extension M2ClientTypes {
    /// A subset of the attributes that describe a log group. In CloudWatch a log group is a group of log streams that share the same retention, monitoring, and access control settings.
    public struct LogGroupSummary: Swift.Equatable {
        /// The name of the log group.
        /// This member is required.
        public var logGroupName: Swift.String?
        /// The type of log.
        /// This member is required.
        public var logType: Swift.String?

        public init(
            logGroupName: Swift.String? = nil,
            logType: Swift.String? = nil
        )
        {
            self.logGroupName = logGroupName
            self.logType = logType
        }
    }

}

extension M2ClientTypes.MaintenanceSchedule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case startTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension M2ClientTypes {
    /// The information about the maintenance schedule.
    public struct MaintenanceSchedule: Swift.Equatable {
        /// The time the scheduled maintenance is to end.
        public var endTime: ClientRuntime.Date?
        /// The time the scheduled maintenance is to start.
        public var startTime: ClientRuntime.Date?

        public init(
            endTime: ClientRuntime.Date? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
        }
    }

}

extension M2ClientTypes.PendingMaintenance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineVersion
        case schedule
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let schedule = self.schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduleDecoded = try containerValues.decodeIfPresent(M2ClientTypes.MaintenanceSchedule.self, forKey: .schedule)
        schedule = scheduleDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
    }
}

extension M2ClientTypes {
    /// The scheduled maintenance for a runtime engine.
    public struct PendingMaintenance: Swift.Equatable {
        /// The specific runtime engine that the maintenance schedule applies to.
        public var engineVersion: Swift.String?
        /// The maintenance schedule for the runtime engine version.
        public var schedule: M2ClientTypes.MaintenanceSchedule?

        public init(
            engineVersion: Swift.String? = nil,
            schedule: M2ClientTypes.MaintenanceSchedule? = nil
        )
        {
            self.engineVersion = engineVersion
            self.schedule = schedule
        }
    }

}

extension M2ClientTypes.PoAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encoding
        case format
        case memberFileExtensions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encoding = self.encoding {
            try encodeContainer.encode(encoding, forKey: .encoding)
        }
        if let format = self.format {
            try encodeContainer.encode(format, forKey: .format)
        }
        if let memberFileExtensions = memberFileExtensions {
            var memberFileExtensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .memberFileExtensions)
            for string200 in memberFileExtensions {
                try memberFileExtensionsContainer.encode(string200)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
        let encodingDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encoding)
        encoding = encodingDecoded
        let memberFileExtensionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .memberFileExtensions)
        var memberFileExtensionsDecoded0:[Swift.String]? = nil
        if let memberFileExtensionsContainer = memberFileExtensionsContainer {
            memberFileExtensionsDecoded0 = [Swift.String]()
            for string0 in memberFileExtensionsContainer {
                if let string0 = string0 {
                    memberFileExtensionsDecoded0?.append(string0)
                }
            }
        }
        memberFileExtensions = memberFileExtensionsDecoded0
    }
}

extension M2ClientTypes {
    /// The supported properties for a PO type data set.
    public struct PoAttributes: Swift.Equatable {
        /// The character set encoding of the data set.
        public var encoding: Swift.String?
        /// The format of the data set records.
        /// This member is required.
        public var format: Swift.String?
        /// An array containing one or more filename extensions, allowing you to specify which files to be included as PDS member.
        /// This member is required.
        public var memberFileExtensions: [Swift.String]?

        public init(
            encoding: Swift.String? = nil,
            format: Swift.String? = nil,
            memberFileExtensions: [Swift.String]? = nil
        )
        {
            self.encoding = encoding
            self.format = format
            self.memberFileExtensions = memberFileExtensions
        }
    }

}

extension M2ClientTypes.PoDetailAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encoding
        case format
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encoding = self.encoding {
            try encodeContainer.encode(encoding, forKey: .encoding)
        }
        if let format = self.format {
            try encodeContainer.encode(format, forKey: .format)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
        let encodingDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encoding)
        encoding = encodingDecoded
    }
}

extension M2ClientTypes {
    /// The supported properties for a PO type data set.
    public struct PoDetailAttributes: Swift.Equatable {
        /// The character set encoding of the data set.
        /// This member is required.
        public var encoding: Swift.String?
        /// The format of the data set records.
        /// This member is required.
        public var format: Swift.String?

        public init(
            encoding: Swift.String? = nil,
            format: Swift.String? = nil
        )
        {
            self.encoding = encoding
            self.format = format
        }
    }

}

extension M2ClientTypes.PrimaryKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case length
        case name
        case offset
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if length != 0 {
            try encodeContainer.encode(length, forKey: .length)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if offset != 0 {
            try encodeContainer.encode(offset, forKey: .offset)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let offsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .offset) ?? 0
        offset = offsetDecoded
        let lengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .length) ?? 0
        length = lengthDecoded
    }
}

extension M2ClientTypes {
    /// The primary key for a KSDS data set.
    public struct PrimaryKey: Swift.Equatable {
        /// A strictly positive integer value representing the length of the primary key.
        /// This member is required.
        public var length: Swift.Int
        /// A name for the Primary Key.
        public var name: Swift.String?
        /// A positive integer value representing the offset to mark the start of the primary key in the record byte array.
        /// This member is required.
        public var offset: Swift.Int

        public init(
            length: Swift.Int = 0,
            name: Swift.String? = nil,
            offset: Swift.Int = 0
        )
        {
            self.length = length
            self.name = name
            self.offset = offset
        }
    }

}

extension M2ClientTypes.PsAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encoding
        case format
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encoding = self.encoding {
            try encodeContainer.encode(encoding, forKey: .encoding)
        }
        if let format = self.format {
            try encodeContainer.encode(format, forKey: .format)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
        let encodingDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encoding)
        encoding = encodingDecoded
    }
}

extension M2ClientTypes {
    /// The supported properties for a PS type data set.
    public struct PsAttributes: Swift.Equatable {
        /// The character set encoding of the data set.
        public var encoding: Swift.String?
        /// The format of the data set records.
        /// This member is required.
        public var format: Swift.String?

        public init(
            encoding: Swift.String? = nil,
            format: Swift.String? = nil
        )
        {
            self.encoding = encoding
            self.format = format
        }
    }

}

extension M2ClientTypes.PsDetailAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encoding
        case format
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encoding = self.encoding {
            try encodeContainer.encode(encoding, forKey: .encoding)
        }
        if let format = self.format {
            try encodeContainer.encode(format, forKey: .format)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
        let encodingDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encoding)
        encoding = encodingDecoded
    }
}

extension M2ClientTypes {
    /// The supported properties for a PS type data set.
    public struct PsDetailAttributes: Swift.Equatable {
        /// The character set encoding of the data set.
        /// This member is required.
        public var encoding: Swift.String?
        /// The format of the data set records.
        /// This member is required.
        public var format: Swift.String?

        public init(
            encoding: Swift.String? = nil,
            format: Swift.String? = nil
        )
        {
            self.encoding = encoding
            self.format = format
        }
    }

}

extension M2ClientTypes.RecordLength: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case max
        case min
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if max != 0 {
            try encodeContainer.encode(max, forKey: .max)
        }
        if min != 0 {
            try encodeContainer.encode(min, forKey: .min)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .min) ?? 0
        min = minDecoded
        let maxDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .max) ?? 0
        max = maxDecoded
    }
}

extension M2ClientTypes {
    /// The length of the records in the data set.
    public struct RecordLength: Swift.Equatable {
        /// The maximum record length. In case of fixed, both minimum and maximum are the same.
        /// This member is required.
        public var max: Swift.Int
        /// The minimum record length of a record.
        /// This member is required.
        public var min: Swift.Int

        public init(
            max: Swift.Int = 0,
            min: Swift.Int = 0
        )
        {
            self.max = max
            self.min = min
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the missing resource.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the missing resource.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension M2ClientTypes.ScriptBatchJobDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scriptName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scriptName = self.scriptName {
            try encodeContainer.encode(scriptName, forKey: .scriptName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scriptNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scriptName)
        scriptName = scriptNameDecoded
    }
}

extension M2ClientTypes {
    /// A batch job definition contained in a script.
    public struct ScriptBatchJobDefinition: Swift.Equatable {
        /// The name of the script containing the batch job definition.
        /// This member is required.
        public var scriptName: Swift.String?

        public init(
            scriptName: Swift.String? = nil
        )
        {
            self.scriptName = scriptName
        }
    }

}

extension M2ClientTypes.ScriptBatchJobIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scriptName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scriptName = self.scriptName {
            try encodeContainer.encode(scriptName, forKey: .scriptName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scriptNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scriptName)
        scriptName = scriptNameDecoded
    }
}

extension M2ClientTypes {
    /// A batch job identifier in which the batch job to run is identified by the script name.
    public struct ScriptBatchJobIdentifier: Swift.Equatable {
        /// The name of the script containing the batch job definition.
        /// This member is required.
        public var scriptName: Swift.String?

        public init(
            scriptName: Swift.String? = nil
        )
        {
            self.scriptName = scriptName
        }
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// One or more quotas for Amazon Web Services Mainframe Modernization exceeds the limit.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier of the exceeded quota.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The ID of the resource that is exceeding the quota limit.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of resource that is exceeding the quota limit for Amazon Web Services Mainframe Modernization.
        public internal(set) var resourceType: Swift.String? = nil
        /// A code that identifies the service that the exceeded quota belongs to.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case resourceId
        case resourceType
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension StartApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/start"
    }
}

public struct StartApplicationInput: Swift.Equatable {
    /// The unique identifier of the application you want to start.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct StartApplicationInputBody: Swift.Equatable {
}

extension StartApplicationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StartApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StartApplicationOutput: Swift.Equatable {

    public init() { }
}

enum StartApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartBatchJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchJobIdentifier
        case jobParams
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchJobIdentifier = self.batchJobIdentifier {
            try encodeContainer.encode(batchJobIdentifier, forKey: .batchJobIdentifier)
        }
        if let jobParams = jobParams {
            var jobParamsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .jobParams)
            for (dictKey0, batchJobParametersMap0) in jobParams {
                try jobParamsContainer.encode(batchJobParametersMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension StartBatchJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/batch-job"
    }
}

public struct StartBatchJobInput: Swift.Equatable {
    /// The unique identifier of the application associated with this batch job.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The unique identifier of the batch job.
    /// This member is required.
    public var batchJobIdentifier: M2ClientTypes.BatchJobIdentifier?
    /// The collection of batch job parameters. For details about limits for keys and values, see [Coding variables in JCL](https://www.ibm.com/docs/en/workload-automation/9.3.0?topic=zos-coding-variables-in-jcl).
    public var jobParams: [Swift.String:Swift.String]?

    public init(
        applicationId: Swift.String? = nil,
        batchJobIdentifier: M2ClientTypes.BatchJobIdentifier? = nil,
        jobParams: [Swift.String:Swift.String]? = nil
    )
    {
        self.applicationId = applicationId
        self.batchJobIdentifier = batchJobIdentifier
        self.jobParams = jobParams
    }
}

struct StartBatchJobInputBody: Swift.Equatable {
    let batchJobIdentifier: M2ClientTypes.BatchJobIdentifier?
    let jobParams: [Swift.String:Swift.String]?
}

extension StartBatchJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchJobIdentifier
        case jobParams
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchJobIdentifierDecoded = try containerValues.decodeIfPresent(M2ClientTypes.BatchJobIdentifier.self, forKey: .batchJobIdentifier)
        batchJobIdentifier = batchJobIdentifierDecoded
        let jobParamsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .jobParams)
        var jobParamsDecoded0: [Swift.String:Swift.String]? = nil
        if let jobParamsContainer = jobParamsContainer {
            jobParamsDecoded0 = [Swift.String:Swift.String]()
            for (key0, batchparamvalue0) in jobParamsContainer {
                if let batchparamvalue0 = batchparamvalue0 {
                    jobParamsDecoded0?[key0] = batchparamvalue0
                }
            }
        }
        jobParams = jobParamsDecoded0
    }
}

extension StartBatchJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartBatchJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.executionId = output.executionId
        } else {
            self.executionId = nil
        }
    }
}

public struct StartBatchJobOutput: Swift.Equatable {
    /// The unique identifier of this execution of the batch job.
    /// This member is required.
    public var executionId: Swift.String?

    public init(
        executionId: Swift.String? = nil
    )
    {
        self.executionId = executionId
    }
}

struct StartBatchJobOutputBody: Swift.Equatable {
    let executionId: Swift.String?
}

extension StartBatchJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
    }
}

enum StartBatchJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forceStop
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if forceStop != false {
            try encodeContainer.encode(forceStop, forKey: .forceStop)
        }
    }
}

extension StopApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/stop"
    }
}

public struct StopApplicationInput: Swift.Equatable {
    /// The unique identifier of the application you want to stop.
    /// This member is required.
    public var applicationId: Swift.String?
    /// Stopping an application process can take a long time. Setting this parameter to true lets you force stop the application so you don't need to wait until the process finishes to apply another action on the application. The default value is false.
    public var forceStop: Swift.Bool

    public init(
        applicationId: Swift.String? = nil,
        forceStop: Swift.Bool = false
    )
    {
        self.applicationId = applicationId
        self.forceStop = forceStop
    }
}

struct StopApplicationInputBody: Swift.Equatable {
    let forceStop: Swift.Bool
}

extension StopApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forceStop
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forceStopDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forceStop) ?? false
        forceStop = forceStopDecoded
    }
}

extension StopApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopApplicationOutput: Swift.Equatable {

    public init() { }
}

enum StopApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension M2ClientTypes.StorageConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case efs
        case fsx
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .efs(efs):
                try container.encode(efs, forKey: .efs)
            case let .fsx(fsx):
                try container.encode(fsx, forKey: .fsx)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let efsDecoded = try values.decodeIfPresent(M2ClientTypes.EfsStorageConfiguration.self, forKey: .efs)
        if let efs = efsDecoded {
            self = .efs(efs)
            return
        }
        let fsxDecoded = try values.decodeIfPresent(M2ClientTypes.FsxStorageConfiguration.self, forKey: .fsx)
        if let fsx = fsxDecoded {
            self = .fsx(fsx)
            return
        }
        self = .sdkUnknown("")
    }
}

extension M2ClientTypes {
    /// Defines the storage configuration for a runtime environment.
    public enum StorageConfiguration: Swift.Equatable {
        /// Defines the storage configuration for an Amazon EFS file system.
        case efs(M2ClientTypes.EfsStorageConfiguration)
        /// Defines the storage configuration for an Amazon FSx file system.
        case fsx(M2ClientTypes.FsxStorageConfiguration)
        case sdkUnknown(Swift.String)
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = 0
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The number of requests made exceeds the limit.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier of the throttled reuqest.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The number of seconds to wait before retrying the request.
        public internal(set) var retryAfterSeconds: Swift.Int = 0
        /// The identifier of the service that the throttled request was made to.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentApplicationVersion
        case definition
        case description
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentApplicationVersion = self.currentApplicationVersion {
            try encodeContainer.encode(currentApplicationVersion, forKey: .currentApplicationVersion)
        }
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())"
    }
}

public struct UpdateApplicationInput: Swift.Equatable {
    /// The unique identifier of the application you want to update.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The current version of the application to update.
    /// This member is required.
    public var currentApplicationVersion: Swift.Int?
    /// The application definition for this application. You can specify either inline JSON or an S3 bucket location.
    public var definition: M2ClientTypes.Definition?
    /// The description of the application to update.
    public var description: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        currentApplicationVersion: Swift.Int? = nil,
        definition: M2ClientTypes.Definition? = nil,
        description: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.currentApplicationVersion = currentApplicationVersion
        self.definition = definition
        self.description = description
    }
}

struct UpdateApplicationInputBody: Swift.Equatable {
    let description: Swift.String?
    let currentApplicationVersion: Swift.Int?
    let definition: M2ClientTypes.Definition?
}

extension UpdateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentApplicationVersion
        case definition
        case description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let currentApplicationVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .currentApplicationVersion)
        currentApplicationVersion = currentApplicationVersionDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(M2ClientTypes.Definition.self, forKey: .definition)
        definition = definitionDecoded
    }
}

extension UpdateApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationVersion = output.applicationVersion
        } else {
            self.applicationVersion = nil
        }
    }
}

public struct UpdateApplicationOutput: Swift.Equatable {
    /// The new version of the application.
    /// This member is required.
    public var applicationVersion: Swift.Int?

    public init(
        applicationVersion: Swift.Int? = nil
    )
    {
        self.applicationVersion = applicationVersion
    }
}

struct UpdateApplicationOutputBody: Swift.Equatable {
    let applicationVersion: Swift.Int?
}

extension UpdateApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .applicationVersion)
        applicationVersion = applicationVersionDecoded
    }
}

enum UpdateApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateEnvironmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applyDuringMaintenanceWindow
        case desiredCapacity
        case engineVersion
        case instanceType
        case preferredMaintenanceWindow
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if applyDuringMaintenanceWindow != false {
            try encodeContainer.encode(applyDuringMaintenanceWindow, forKey: .applyDuringMaintenanceWindow)
        }
        if let desiredCapacity = self.desiredCapacity {
            try encodeContainer.encode(desiredCapacity, forKey: .desiredCapacity)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let preferredMaintenanceWindow = self.preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
    }
}

extension UpdateEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let environmentId = environmentId else {
            return nil
        }
        return "/environments/\(environmentId.urlPercentEncoding())"
    }
}

public struct UpdateEnvironmentInput: Swift.Equatable {
    /// Indicates whether to update the runtime environment during the maintenance window. The default is false. Currently, Amazon Web Services Mainframe Modernization accepts the engineVersion parameter only if applyDuringMaintenanceWindow is true. If any parameter other than engineVersion is provided in UpdateEnvironmentRequest, it will fail if applyDuringMaintenanceWindow is set to true.
    public var applyDuringMaintenanceWindow: Swift.Bool
    /// The desired capacity for the runtime environment to update. The minimum possible value is 0 and the maximum is 100.
    public var desiredCapacity: Swift.Int?
    /// The version of the runtime engine for the runtime environment.
    public var engineVersion: Swift.String?
    /// The unique identifier of the runtime environment that you want to update.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The instance type for the runtime environment to update.
    public var instanceType: Swift.String?
    /// Configures the maintenance window you want for the runtime environment. If you do not provide a value, a random system-generated value will be assigned.
    public var preferredMaintenanceWindow: Swift.String?

    public init(
        applyDuringMaintenanceWindow: Swift.Bool = false,
        desiredCapacity: Swift.Int? = nil,
        engineVersion: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        instanceType: Swift.String? = nil,
        preferredMaintenanceWindow: Swift.String? = nil
    )
    {
        self.applyDuringMaintenanceWindow = applyDuringMaintenanceWindow
        self.desiredCapacity = desiredCapacity
        self.engineVersion = engineVersion
        self.environmentId = environmentId
        self.instanceType = instanceType
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
    }
}

struct UpdateEnvironmentInputBody: Swift.Equatable {
    let desiredCapacity: Swift.Int?
    let instanceType: Swift.String?
    let engineVersion: Swift.String?
    let preferredMaintenanceWindow: Swift.String?
    let applyDuringMaintenanceWindow: Swift.Bool
}

extension UpdateEnvironmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applyDuringMaintenanceWindow
        case desiredCapacity
        case engineVersion
        case instanceType
        case preferredMaintenanceWindow
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let desiredCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .desiredCapacity)
        desiredCapacity = desiredCapacityDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let applyDuringMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .applyDuringMaintenanceWindow) ?? false
        applyDuringMaintenanceWindow = applyDuringMaintenanceWindowDecoded
    }
}

extension UpdateEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateEnvironmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.environmentId = output.environmentId
        } else {
            self.environmentId = nil
        }
    }
}

public struct UpdateEnvironmentOutput: Swift.Equatable {
    /// The unique identifier of the runtime environment that was updated.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        environmentId: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
    }
}

struct UpdateEnvironmentOutputBody: Swift.Equatable {
    let environmentId: Swift.String?
}

extension UpdateEnvironmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
    }
}

enum UpdateEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.fieldList = output.fieldList
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.fieldList = nil
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// One or more parameters provided in the request is not valid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The list of fields that failed service validation.
        public internal(set) var fieldList: [M2ClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason why it failed service validation.
        public internal(set) var reason: M2ClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [M2ClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: M2ClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: M2ClientTypes.ValidationExceptionReason?
    let fieldList: [M2ClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldList
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(M2ClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([M2ClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[M2ClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [M2ClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension M2ClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension M2ClientTypes {
    /// Contains information about a validation exception field.
    public struct ValidationExceptionField: Swift.Equatable {
        /// The message of the exception field.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the exception field.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension M2ClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension M2ClientTypes.VsamAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alternateKeys
        case compressed
        case encoding
        case format
        case primaryKey
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alternateKeys = alternateKeys {
            var alternateKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .alternateKeys)
            for alternatekey0 in alternateKeys {
                try alternateKeysContainer.encode(alternatekey0)
            }
        }
        if compressed != false {
            try encodeContainer.encode(compressed, forKey: .compressed)
        }
        if let encoding = self.encoding {
            try encodeContainer.encode(encoding, forKey: .encoding)
        }
        if let format = self.format {
            try encodeContainer.encode(format, forKey: .format)
        }
        if let primaryKey = self.primaryKey {
            try encodeContainer.encode(primaryKey, forKey: .primaryKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
        let encodingDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encoding)
        encoding = encodingDecoded
        let compressedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .compressed) ?? false
        compressed = compressedDecoded
        let primaryKeyDecoded = try containerValues.decodeIfPresent(M2ClientTypes.PrimaryKey.self, forKey: .primaryKey)
        primaryKey = primaryKeyDecoded
        let alternateKeysContainer = try containerValues.decodeIfPresent([M2ClientTypes.AlternateKey?].self, forKey: .alternateKeys)
        var alternateKeysDecoded0:[M2ClientTypes.AlternateKey]? = nil
        if let alternateKeysContainer = alternateKeysContainer {
            alternateKeysDecoded0 = [M2ClientTypes.AlternateKey]()
            for structure0 in alternateKeysContainer {
                if let structure0 = structure0 {
                    alternateKeysDecoded0?.append(structure0)
                }
            }
        }
        alternateKeys = alternateKeysDecoded0
    }
}

extension M2ClientTypes {
    /// The attributes of a VSAM type data set.
    public struct VsamAttributes: Swift.Equatable {
        /// The alternate key definitions, if any. A legacy dataset might not have any alternate key defined, but if those alternate keys definitions exist, provide them as some applications will make use of them.
        public var alternateKeys: [M2ClientTypes.AlternateKey]?
        /// Indicates whether indexes for this dataset are stored as compressed values. If you have a large data set (typically > 100 Mb), consider setting this flag to True.
        public var compressed: Swift.Bool
        /// The character set used by the data set. Can be ASCII, EBCDIC, or unknown.
        public var encoding: Swift.String?
        /// The record format of the data set.
        /// This member is required.
        public var format: Swift.String?
        /// The primary key of the data set.
        public var primaryKey: M2ClientTypes.PrimaryKey?

        public init(
            alternateKeys: [M2ClientTypes.AlternateKey]? = nil,
            compressed: Swift.Bool = false,
            encoding: Swift.String? = nil,
            format: Swift.String? = nil,
            primaryKey: M2ClientTypes.PrimaryKey? = nil
        )
        {
            self.alternateKeys = alternateKeys
            self.compressed = compressed
            self.encoding = encoding
            self.format = format
            self.primaryKey = primaryKey
        }
    }

}

extension M2ClientTypes.VsamDetailAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alternateKeys
        case cacheAtStartup
        case compressed
        case encoding
        case primaryKey
        case recordFormat
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alternateKeys = alternateKeys {
            var alternateKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .alternateKeys)
            for alternatekey0 in alternateKeys {
                try alternateKeysContainer.encode(alternatekey0)
            }
        }
        if let cacheAtStartup = self.cacheAtStartup {
            try encodeContainer.encode(cacheAtStartup, forKey: .cacheAtStartup)
        }
        if let compressed = self.compressed {
            try encodeContainer.encode(compressed, forKey: .compressed)
        }
        if let encoding = self.encoding {
            try encodeContainer.encode(encoding, forKey: .encoding)
        }
        if let primaryKey = self.primaryKey {
            try encodeContainer.encode(primaryKey, forKey: .primaryKey)
        }
        if let recordFormat = self.recordFormat {
            try encodeContainer.encode(recordFormat, forKey: .recordFormat)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encodingDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encoding)
        encoding = encodingDecoded
        let recordFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordFormat)
        recordFormat = recordFormatDecoded
        let compressedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .compressed)
        compressed = compressedDecoded
        let cacheAtStartupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cacheAtStartup)
        cacheAtStartup = cacheAtStartupDecoded
        let primaryKeyDecoded = try containerValues.decodeIfPresent(M2ClientTypes.PrimaryKey.self, forKey: .primaryKey)
        primaryKey = primaryKeyDecoded
        let alternateKeysContainer = try containerValues.decodeIfPresent([M2ClientTypes.AlternateKey?].self, forKey: .alternateKeys)
        var alternateKeysDecoded0:[M2ClientTypes.AlternateKey]? = nil
        if let alternateKeysContainer = alternateKeysContainer {
            alternateKeysDecoded0 = [M2ClientTypes.AlternateKey]()
            for structure0 in alternateKeysContainer {
                if let structure0 = structure0 {
                    alternateKeysDecoded0?.append(structure0)
                }
            }
        }
        alternateKeys = alternateKeysDecoded0
    }
}

extension M2ClientTypes {
    /// The attributes of a VSAM type data set.
    public struct VsamDetailAttributes: Swift.Equatable {
        /// The alternate key definitions, if any. A legacy dataset might not have any alternate key defined, but if those alternate keys definitions exist, provide them as some applications will make use of them.
        public var alternateKeys: [M2ClientTypes.AlternateKey]?
        /// If set to True, enforces loading the data set into cache before its used by the application.
        public var cacheAtStartup: Swift.Bool?
        /// Indicates whether indexes for this dataset are stored as compressed values. If you have a large data set (typically > 100 Mb), consider setting this flag to True.
        public var compressed: Swift.Bool?
        /// The character set used by the data set. Can be ASCII, EBCDIC, or unknown.
        public var encoding: Swift.String?
        /// The primary key of the data set.
        public var primaryKey: M2ClientTypes.PrimaryKey?
        /// The record format of the data set.
        public var recordFormat: Swift.String?

        public init(
            alternateKeys: [M2ClientTypes.AlternateKey]? = nil,
            cacheAtStartup: Swift.Bool? = nil,
            compressed: Swift.Bool? = nil,
            encoding: Swift.String? = nil,
            primaryKey: M2ClientTypes.PrimaryKey? = nil,
            recordFormat: Swift.String? = nil
        )
        {
            self.alternateKeys = alternateKeys
            self.cacheAtStartup = cacheAtStartup
            self.compressed = compressed
            self.encoding = encoding
            self.primaryKey = primaryKey
            self.recordFormat = recordFormat
        }
    }

}
