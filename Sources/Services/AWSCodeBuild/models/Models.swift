// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccountLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccountLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An Amazon Web Services service limit was exceeded for the calling Amazon Web Services account.
public struct AccountLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccountLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccountLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeBuildClientTypes {
    public enum ArtifactNamespace: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case buildId
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [ArtifactNamespace] {
            return [
                .buildId,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .buildId: return "BUILD_ID"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ArtifactNamespace(rawValue: rawValue) ?? ArtifactNamespace.sdkUnknown(rawValue)
        }
    }
}

extension CodeBuildClientTypes {
    public enum ArtifactPackaging: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case zip
        case sdkUnknown(Swift.String)

        public static var allCases: [ArtifactPackaging] {
            return [
                .none,
                .zip,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .zip: return "ZIP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ArtifactPackaging(rawValue: rawValue) ?? ArtifactPackaging.sdkUnknown(rawValue)
        }
    }
}

extension CodeBuildClientTypes {
    public enum ArtifactsType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case codepipeline
        case noArtifacts
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [ArtifactsType] {
            return [
                .codepipeline,
                .noArtifacts,
                .s3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .codepipeline: return "CODEPIPELINE"
            case .noArtifacts: return "NO_ARTIFACTS"
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ArtifactsType(rawValue: rawValue) ?? ArtifactsType.sdkUnknown(rawValue)
        }
    }
}

extension CodeBuildClientTypes {
    public enum AuthType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case basicAuth
        case oauth
        case personalAccessToken
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthType] {
            return [
                .basicAuth,
                .oauth,
                .personalAccessToken,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .basicAuth: return "BASIC_AUTH"
            case .oauth: return "OAUTH"
            case .personalAccessToken: return "PERSONAL_ACCESS_TOKEN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthType(rawValue: rawValue) ?? AuthType.sdkUnknown(rawValue)
        }
    }
}

extension BatchDeleteBuildsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ids
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ids = ids {
            var idsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ids)
            for nonemptystring0 in ids {
                try idsContainer.encode(nonemptystring0)
            }
        }
    }
}

extension BatchDeleteBuildsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchDeleteBuildsInput: Swift.Equatable {
    /// The IDs of the builds to delete.
    /// This member is required.
    public var ids: [Swift.String]?

    public init (
        ids: [Swift.String]? = nil
    )
    {
        self.ids = ids
    }
}

struct BatchDeleteBuildsInputBody: Swift.Equatable {
    let ids: [Swift.String]?
}

extension BatchDeleteBuildsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ids
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ids)
        var idsDecoded0:[Swift.String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [Swift.String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
    }
}

extension BatchDeleteBuildsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDeleteBuildsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchDeleteBuildsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDeleteBuildsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchDeleteBuildsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.buildsDeleted = output.buildsDeleted
            self.buildsNotDeleted = output.buildsNotDeleted
        } else {
            self.buildsDeleted = nil
            self.buildsNotDeleted = nil
        }
    }
}

public struct BatchDeleteBuildsOutputResponse: Swift.Equatable {
    /// The IDs of the builds that were successfully deleted.
    public var buildsDeleted: [Swift.String]?
    /// Information about any builds that could not be successfully deleted.
    public var buildsNotDeleted: [CodeBuildClientTypes.BuildNotDeleted]?

    public init (
        buildsDeleted: [Swift.String]? = nil,
        buildsNotDeleted: [CodeBuildClientTypes.BuildNotDeleted]? = nil
    )
    {
        self.buildsDeleted = buildsDeleted
        self.buildsNotDeleted = buildsNotDeleted
    }
}

struct BatchDeleteBuildsOutputResponseBody: Swift.Equatable {
    let buildsDeleted: [Swift.String]?
    let buildsNotDeleted: [CodeBuildClientTypes.BuildNotDeleted]?
}

extension BatchDeleteBuildsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case buildsDeleted
        case buildsNotDeleted
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let buildsDeletedContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .buildsDeleted)
        var buildsDeletedDecoded0:[Swift.String]? = nil
        if let buildsDeletedContainer = buildsDeletedContainer {
            buildsDeletedDecoded0 = [Swift.String]()
            for string0 in buildsDeletedContainer {
                if let string0 = string0 {
                    buildsDeletedDecoded0?.append(string0)
                }
            }
        }
        buildsDeleted = buildsDeletedDecoded0
        let buildsNotDeletedContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.BuildNotDeleted?].self, forKey: .buildsNotDeleted)
        var buildsNotDeletedDecoded0:[CodeBuildClientTypes.BuildNotDeleted]? = nil
        if let buildsNotDeletedContainer = buildsNotDeletedContainer {
            buildsNotDeletedDecoded0 = [CodeBuildClientTypes.BuildNotDeleted]()
            for structure0 in buildsNotDeletedContainer {
                if let structure0 = structure0 {
                    buildsNotDeletedDecoded0?.append(structure0)
                }
            }
        }
        buildsNotDeleted = buildsNotDeletedDecoded0
    }
}

extension BatchGetBuildBatchesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ids
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ids = ids {
            var idsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ids)
            for nonemptystring0 in ids {
                try idsContainer.encode(nonemptystring0)
            }
        }
    }
}

extension BatchGetBuildBatchesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchGetBuildBatchesInput: Swift.Equatable {
    /// An array that contains the batch build identifiers to retrieve.
    /// This member is required.
    public var ids: [Swift.String]?

    public init (
        ids: [Swift.String]? = nil
    )
    {
        self.ids = ids
    }
}

struct BatchGetBuildBatchesInputBody: Swift.Equatable {
    let ids: [Swift.String]?
}

extension BatchGetBuildBatchesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ids
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ids)
        var idsDecoded0:[Swift.String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [Swift.String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
    }
}

extension BatchGetBuildBatchesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetBuildBatchesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchGetBuildBatchesOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetBuildBatchesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchGetBuildBatchesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.buildBatches = output.buildBatches
            self.buildBatchesNotFound = output.buildBatchesNotFound
        } else {
            self.buildBatches = nil
            self.buildBatchesNotFound = nil
        }
    }
}

public struct BatchGetBuildBatchesOutputResponse: Swift.Equatable {
    /// An array of BuildBatch objects that represent the retrieved batch builds.
    public var buildBatches: [CodeBuildClientTypes.BuildBatch]?
    /// An array that contains the identifiers of any batch builds that are not found.
    public var buildBatchesNotFound: [Swift.String]?

    public init (
        buildBatches: [CodeBuildClientTypes.BuildBatch]? = nil,
        buildBatchesNotFound: [Swift.String]? = nil
    )
    {
        self.buildBatches = buildBatches
        self.buildBatchesNotFound = buildBatchesNotFound
    }
}

struct BatchGetBuildBatchesOutputResponseBody: Swift.Equatable {
    let buildBatches: [CodeBuildClientTypes.BuildBatch]?
    let buildBatchesNotFound: [Swift.String]?
}

extension BatchGetBuildBatchesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case buildBatches
        case buildBatchesNotFound
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let buildBatchesContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.BuildBatch?].self, forKey: .buildBatches)
        var buildBatchesDecoded0:[CodeBuildClientTypes.BuildBatch]? = nil
        if let buildBatchesContainer = buildBatchesContainer {
            buildBatchesDecoded0 = [CodeBuildClientTypes.BuildBatch]()
            for structure0 in buildBatchesContainer {
                if let structure0 = structure0 {
                    buildBatchesDecoded0?.append(structure0)
                }
            }
        }
        buildBatches = buildBatchesDecoded0
        let buildBatchesNotFoundContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .buildBatchesNotFound)
        var buildBatchesNotFoundDecoded0:[Swift.String]? = nil
        if let buildBatchesNotFoundContainer = buildBatchesNotFoundContainer {
            buildBatchesNotFoundDecoded0 = [Swift.String]()
            for string0 in buildBatchesNotFoundContainer {
                if let string0 = string0 {
                    buildBatchesNotFoundDecoded0?.append(string0)
                }
            }
        }
        buildBatchesNotFound = buildBatchesNotFoundDecoded0
    }
}

extension BatchGetBuildsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ids
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ids = ids {
            var idsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ids)
            for nonemptystring0 in ids {
                try idsContainer.encode(nonemptystring0)
            }
        }
    }
}

extension BatchGetBuildsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchGetBuildsInput: Swift.Equatable {
    /// The IDs of the builds.
    /// This member is required.
    public var ids: [Swift.String]?

    public init (
        ids: [Swift.String]? = nil
    )
    {
        self.ids = ids
    }
}

struct BatchGetBuildsInputBody: Swift.Equatable {
    let ids: [Swift.String]?
}

extension BatchGetBuildsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ids
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ids)
        var idsDecoded0:[Swift.String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [Swift.String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
    }
}

extension BatchGetBuildsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetBuildsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchGetBuildsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetBuildsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchGetBuildsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.builds = output.builds
            self.buildsNotFound = output.buildsNotFound
        } else {
            self.builds = nil
            self.buildsNotFound = nil
        }
    }
}

public struct BatchGetBuildsOutputResponse: Swift.Equatable {
    /// Information about the requested builds.
    public var builds: [CodeBuildClientTypes.Build]?
    /// The IDs of builds for which information could not be found.
    public var buildsNotFound: [Swift.String]?

    public init (
        builds: [CodeBuildClientTypes.Build]? = nil,
        buildsNotFound: [Swift.String]? = nil
    )
    {
        self.builds = builds
        self.buildsNotFound = buildsNotFound
    }
}

struct BatchGetBuildsOutputResponseBody: Swift.Equatable {
    let builds: [CodeBuildClientTypes.Build]?
    let buildsNotFound: [Swift.String]?
}

extension BatchGetBuildsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case builds
        case buildsNotFound
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let buildsContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.Build?].self, forKey: .builds)
        var buildsDecoded0:[CodeBuildClientTypes.Build]? = nil
        if let buildsContainer = buildsContainer {
            buildsDecoded0 = [CodeBuildClientTypes.Build]()
            for structure0 in buildsContainer {
                if let structure0 = structure0 {
                    buildsDecoded0?.append(structure0)
                }
            }
        }
        builds = buildsDecoded0
        let buildsNotFoundContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .buildsNotFound)
        var buildsNotFoundDecoded0:[Swift.String]? = nil
        if let buildsNotFoundContainer = buildsNotFoundContainer {
            buildsNotFoundDecoded0 = [Swift.String]()
            for string0 in buildsNotFoundContainer {
                if let string0 = string0 {
                    buildsNotFoundDecoded0?.append(string0)
                }
            }
        }
        buildsNotFound = buildsNotFoundDecoded0
    }
}

extension BatchGetProjectsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case names
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for nonemptystring0 in names {
                try namesContainer.encode(nonemptystring0)
            }
        }
    }
}

extension BatchGetProjectsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchGetProjectsInput: Swift.Equatable {
    /// The names or ARNs of the build projects. To get information about a project shared with your Amazon Web Services account, its ARN must be specified. You cannot specify a shared project using its name.
    /// This member is required.
    public var names: [Swift.String]?

    public init (
        names: [Swift.String]? = nil
    )
    {
        self.names = names
    }
}

struct BatchGetProjectsInputBody: Swift.Equatable {
    let names: [Swift.String]?
}

extension BatchGetProjectsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case names
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .names)
        var namesDecoded0:[Swift.String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [Swift.String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
    }
}

extension BatchGetProjectsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetProjectsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchGetProjectsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetProjectsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchGetProjectsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.projects = output.projects
            self.projectsNotFound = output.projectsNotFound
        } else {
            self.projects = nil
            self.projectsNotFound = nil
        }
    }
}

public struct BatchGetProjectsOutputResponse: Swift.Equatable {
    /// Information about the requested build projects.
    public var projects: [CodeBuildClientTypes.Project]?
    /// The names of build projects for which information could not be found.
    public var projectsNotFound: [Swift.String]?

    public init (
        projects: [CodeBuildClientTypes.Project]? = nil,
        projectsNotFound: [Swift.String]? = nil
    )
    {
        self.projects = projects
        self.projectsNotFound = projectsNotFound
    }
}

struct BatchGetProjectsOutputResponseBody: Swift.Equatable {
    let projects: [CodeBuildClientTypes.Project]?
    let projectsNotFound: [Swift.String]?
}

extension BatchGetProjectsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projects
        case projectsNotFound
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectsContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.Project?].self, forKey: .projects)
        var projectsDecoded0:[CodeBuildClientTypes.Project]? = nil
        if let projectsContainer = projectsContainer {
            projectsDecoded0 = [CodeBuildClientTypes.Project]()
            for structure0 in projectsContainer {
                if let structure0 = structure0 {
                    projectsDecoded0?.append(structure0)
                }
            }
        }
        projects = projectsDecoded0
        let projectsNotFoundContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .projectsNotFound)
        var projectsNotFoundDecoded0:[Swift.String]? = nil
        if let projectsNotFoundContainer = projectsNotFoundContainer {
            projectsNotFoundDecoded0 = [Swift.String]()
            for string0 in projectsNotFoundContainer {
                if let string0 = string0 {
                    projectsNotFoundDecoded0?.append(string0)
                }
            }
        }
        projectsNotFound = projectsNotFoundDecoded0
    }
}

extension BatchGetReportGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportGroupArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reportGroupArns = reportGroupArns {
            var reportGroupArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reportGroupArns)
            for nonemptystring0 in reportGroupArns {
                try reportGroupArnsContainer.encode(nonemptystring0)
            }
        }
    }
}

extension BatchGetReportGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchGetReportGroupsInput: Swift.Equatable {
    /// An array of report group ARNs that identify the report groups to return.
    /// This member is required.
    public var reportGroupArns: [Swift.String]?

    public init (
        reportGroupArns: [Swift.String]? = nil
    )
    {
        self.reportGroupArns = reportGroupArns
    }
}

struct BatchGetReportGroupsInputBody: Swift.Equatable {
    let reportGroupArns: [Swift.String]?
}

extension BatchGetReportGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportGroupArns
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportGroupArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .reportGroupArns)
        var reportGroupArnsDecoded0:[Swift.String]? = nil
        if let reportGroupArnsContainer = reportGroupArnsContainer {
            reportGroupArnsDecoded0 = [Swift.String]()
            for string0 in reportGroupArnsContainer {
                if let string0 = string0 {
                    reportGroupArnsDecoded0?.append(string0)
                }
            }
        }
        reportGroupArns = reportGroupArnsDecoded0
    }
}

extension BatchGetReportGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetReportGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchGetReportGroupsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetReportGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchGetReportGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.reportGroups = output.reportGroups
            self.reportGroupsNotFound = output.reportGroupsNotFound
        } else {
            self.reportGroups = nil
            self.reportGroupsNotFound = nil
        }
    }
}

public struct BatchGetReportGroupsOutputResponse: Swift.Equatable {
    /// The array of report groups returned by BatchGetReportGroups.
    public var reportGroups: [CodeBuildClientTypes.ReportGroup]?
    /// An array of ARNs passed to BatchGetReportGroups that are not associated with a ReportGroup.
    public var reportGroupsNotFound: [Swift.String]?

    public init (
        reportGroups: [CodeBuildClientTypes.ReportGroup]? = nil,
        reportGroupsNotFound: [Swift.String]? = nil
    )
    {
        self.reportGroups = reportGroups
        self.reportGroupsNotFound = reportGroupsNotFound
    }
}

struct BatchGetReportGroupsOutputResponseBody: Swift.Equatable {
    let reportGroups: [CodeBuildClientTypes.ReportGroup]?
    let reportGroupsNotFound: [Swift.String]?
}

extension BatchGetReportGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportGroups
        case reportGroupsNotFound
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportGroupsContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.ReportGroup?].self, forKey: .reportGroups)
        var reportGroupsDecoded0:[CodeBuildClientTypes.ReportGroup]? = nil
        if let reportGroupsContainer = reportGroupsContainer {
            reportGroupsDecoded0 = [CodeBuildClientTypes.ReportGroup]()
            for structure0 in reportGroupsContainer {
                if let structure0 = structure0 {
                    reportGroupsDecoded0?.append(structure0)
                }
            }
        }
        reportGroups = reportGroupsDecoded0
        let reportGroupsNotFoundContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .reportGroupsNotFound)
        var reportGroupsNotFoundDecoded0:[Swift.String]? = nil
        if let reportGroupsNotFoundContainer = reportGroupsNotFoundContainer {
            reportGroupsNotFoundDecoded0 = [Swift.String]()
            for string0 in reportGroupsNotFoundContainer {
                if let string0 = string0 {
                    reportGroupsNotFoundDecoded0?.append(string0)
                }
            }
        }
        reportGroupsNotFound = reportGroupsNotFoundDecoded0
    }
}

extension BatchGetReportsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reportArns = reportArns {
            var reportArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reportArns)
            for nonemptystring0 in reportArns {
                try reportArnsContainer.encode(nonemptystring0)
            }
        }
    }
}

extension BatchGetReportsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchGetReportsInput: Swift.Equatable {
    /// An array of ARNs that identify the Report objects to return.
    /// This member is required.
    public var reportArns: [Swift.String]?

    public init (
        reportArns: [Swift.String]? = nil
    )
    {
        self.reportArns = reportArns
    }
}

struct BatchGetReportsInputBody: Swift.Equatable {
    let reportArns: [Swift.String]?
}

extension BatchGetReportsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportArns
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .reportArns)
        var reportArnsDecoded0:[Swift.String]? = nil
        if let reportArnsContainer = reportArnsContainer {
            reportArnsDecoded0 = [Swift.String]()
            for string0 in reportArnsContainer {
                if let string0 = string0 {
                    reportArnsDecoded0?.append(string0)
                }
            }
        }
        reportArns = reportArnsDecoded0
    }
}

extension BatchGetReportsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetReportsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchGetReportsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetReportsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchGetReportsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.reports = output.reports
            self.reportsNotFound = output.reportsNotFound
        } else {
            self.reports = nil
            self.reportsNotFound = nil
        }
    }
}

public struct BatchGetReportsOutputResponse: Swift.Equatable {
    /// The array of Report objects returned by BatchGetReports.
    public var reports: [CodeBuildClientTypes.Report]?
    /// An array of ARNs passed to BatchGetReportGroups that are not associated with a Report.
    public var reportsNotFound: [Swift.String]?

    public init (
        reports: [CodeBuildClientTypes.Report]? = nil,
        reportsNotFound: [Swift.String]? = nil
    )
    {
        self.reports = reports
        self.reportsNotFound = reportsNotFound
    }
}

struct BatchGetReportsOutputResponseBody: Swift.Equatable {
    let reports: [CodeBuildClientTypes.Report]?
    let reportsNotFound: [Swift.String]?
}

extension BatchGetReportsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reports
        case reportsNotFound
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportsContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.Report?].self, forKey: .reports)
        var reportsDecoded0:[CodeBuildClientTypes.Report]? = nil
        if let reportsContainer = reportsContainer {
            reportsDecoded0 = [CodeBuildClientTypes.Report]()
            for structure0 in reportsContainer {
                if let structure0 = structure0 {
                    reportsDecoded0?.append(structure0)
                }
            }
        }
        reports = reportsDecoded0
        let reportsNotFoundContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .reportsNotFound)
        var reportsNotFoundDecoded0:[Swift.String]? = nil
        if let reportsNotFoundContainer = reportsNotFoundContainer {
            reportsNotFoundDecoded0 = [Swift.String]()
            for string0 in reportsNotFoundContainer {
                if let string0 = string0 {
                    reportsNotFoundDecoded0?.append(string0)
                }
            }
        }
        reportsNotFound = reportsNotFoundDecoded0
    }
}

extension CodeBuildClientTypes {
    public enum BatchReportModeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case reportAggregatedBatch
        case reportIndividualBuilds
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchReportModeType] {
            return [
                .reportAggregatedBatch,
                .reportIndividualBuilds,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .reportAggregatedBatch: return "REPORT_AGGREGATED_BATCH"
            case .reportIndividualBuilds: return "REPORT_INDIVIDUAL_BUILDS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BatchReportModeType(rawValue: rawValue) ?? BatchReportModeType.sdkUnknown(rawValue)
        }
    }
}

extension CodeBuildClientTypes.BatchRestrictions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computeTypesAllowed
        case maximumBuildsAllowed
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computeTypesAllowed = computeTypesAllowed {
            var computeTypesAllowedContainer = encodeContainer.nestedUnkeyedContainer(forKey: .computeTypesAllowed)
            for nonemptystring0 in computeTypesAllowed {
                try computeTypesAllowedContainer.encode(nonemptystring0)
            }
        }
        if let maximumBuildsAllowed = self.maximumBuildsAllowed {
            try encodeContainer.encode(maximumBuildsAllowed, forKey: .maximumBuildsAllowed)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maximumBuildsAllowedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumBuildsAllowed)
        maximumBuildsAllowed = maximumBuildsAllowedDecoded
        let computeTypesAllowedContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .computeTypesAllowed)
        var computeTypesAllowedDecoded0:[Swift.String]? = nil
        if let computeTypesAllowedContainer = computeTypesAllowedContainer {
            computeTypesAllowedDecoded0 = [Swift.String]()
            for string0 in computeTypesAllowedContainer {
                if let string0 = string0 {
                    computeTypesAllowedDecoded0?.append(string0)
                }
            }
        }
        computeTypesAllowed = computeTypesAllowedDecoded0
    }
}

extension CodeBuildClientTypes {
    /// Specifies restrictions for the batch build.
    public struct BatchRestrictions: Swift.Equatable {
        /// An array of strings that specify the compute types that are allowed for the batch build. See [Build environment compute types](https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref-compute-types.html) in the CodeBuild User Guide for these values.
        public var computeTypesAllowed: [Swift.String]?
        /// Specifies the maximum number of builds allowed.
        public var maximumBuildsAllowed: Swift.Int?

        public init (
            computeTypesAllowed: [Swift.String]? = nil,
            maximumBuildsAllowed: Swift.Int? = nil
        )
        {
            self.computeTypesAllowed = computeTypesAllowed
            self.maximumBuildsAllowed = maximumBuildsAllowed
        }
    }

}

extension CodeBuildClientTypes {
    /// Specifies the bucket owner's access for objects that another account uploads to their Amazon S3 bucket. By default, only the account that uploads the objects to the bucket has access to these objects. This property allows you to give the bucket owner access to these objects. To use this property, your CodeBuild service role must have the s3:PutBucketAcl permission. This permission allows CodeBuild to modify the access control list for the bucket. This property can be one of the following values: NONE The bucket owner does not have access to the objects. This is the default. READ_ONLY The bucket owner has read-only access to the objects. The uploading account retains ownership of the objects. FULL The bucket owner has full access to the objects. Object ownership is determined by the following criteria:
    ///
    /// * If the bucket is configured with the Bucket owner preferred setting, the bucket owner owns the objects. The uploading account will have object access as specified by the bucket's policy.
    ///
    /// * Otherwise, the uploading account retains ownership of the objects.
    ///
    ///
    /// For more information about Amazon S3 object ownership, see [Controlling ownership of uploaded objects using S3 Object Ownership](https://docs.aws.amazon.com/AmazonS3/latest/userguide/about-object-ownership.html) in the Amazon Simple Storage Service User Guide.
    public enum BucketOwnerAccess: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case full
        case `none`
        case readOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [BucketOwnerAccess] {
            return [
                .full,
                .none,
                .readOnly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .full: return "FULL"
            case .none: return "NONE"
            case .readOnly: return "READ_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BucketOwnerAccess(rawValue: rawValue) ?? BucketOwnerAccess.sdkUnknown(rawValue)
        }
    }
}

extension CodeBuildClientTypes.Build: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case artifacts
        case buildBatchArn
        case buildComplete
        case buildNumber
        case buildStatus
        case cache
        case currentPhase
        case debugSession
        case encryptionKey
        case endTime
        case environment
        case exportedEnvironmentVariables
        case fileSystemLocations
        case id
        case initiator
        case logs
        case networkInterface
        case phases
        case projectName
        case queuedTimeoutInMinutes
        case reportArns
        case resolvedSourceVersion
        case secondaryArtifacts
        case secondarySourceVersions
        case secondarySources
        case serviceRole
        case source
        case sourceVersion
        case startTime
        case timeoutInMinutes
        case vpcConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let artifacts = self.artifacts {
            try encodeContainer.encode(artifacts, forKey: .artifacts)
        }
        if let buildBatchArn = self.buildBatchArn {
            try encodeContainer.encode(buildBatchArn, forKey: .buildBatchArn)
        }
        if buildComplete != false {
            try encodeContainer.encode(buildComplete, forKey: .buildComplete)
        }
        if let buildNumber = self.buildNumber {
            try encodeContainer.encode(buildNumber, forKey: .buildNumber)
        }
        if let buildStatus = self.buildStatus {
            try encodeContainer.encode(buildStatus.rawValue, forKey: .buildStatus)
        }
        if let cache = self.cache {
            try encodeContainer.encode(cache, forKey: .cache)
        }
        if let currentPhase = self.currentPhase {
            try encodeContainer.encode(currentPhase, forKey: .currentPhase)
        }
        if let debugSession = self.debugSession {
            try encodeContainer.encode(debugSession, forKey: .debugSession)
        }
        if let encryptionKey = self.encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let environment = self.environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let exportedEnvironmentVariables = exportedEnvironmentVariables {
            var exportedEnvironmentVariablesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exportedEnvironmentVariables)
            for exportedenvironmentvariable0 in exportedEnvironmentVariables {
                try exportedEnvironmentVariablesContainer.encode(exportedenvironmentvariable0)
            }
        }
        if let fileSystemLocations = fileSystemLocations {
            var fileSystemLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileSystemLocations)
            for projectfilesystemlocation0 in fileSystemLocations {
                try fileSystemLocationsContainer.encode(projectfilesystemlocation0)
            }
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let initiator = self.initiator {
            try encodeContainer.encode(initiator, forKey: .initiator)
        }
        if let logs = self.logs {
            try encodeContainer.encode(logs, forKey: .logs)
        }
        if let networkInterface = self.networkInterface {
            try encodeContainer.encode(networkInterface, forKey: .networkInterface)
        }
        if let phases = phases {
            var phasesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phases)
            for buildphase0 in phases {
                try phasesContainer.encode(buildphase0)
            }
        }
        if let projectName = self.projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let queuedTimeoutInMinutes = self.queuedTimeoutInMinutes {
            try encodeContainer.encode(queuedTimeoutInMinutes, forKey: .queuedTimeoutInMinutes)
        }
        if let reportArns = reportArns {
            var reportArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reportArns)
            for string0 in reportArns {
                try reportArnsContainer.encode(string0)
            }
        }
        if let resolvedSourceVersion = self.resolvedSourceVersion {
            try encodeContainer.encode(resolvedSourceVersion, forKey: .resolvedSourceVersion)
        }
        if let secondaryArtifacts = secondaryArtifacts {
            var secondaryArtifactsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondaryArtifacts)
            for buildartifacts0 in secondaryArtifacts {
                try secondaryArtifactsContainer.encode(buildartifacts0)
            }
        }
        if let secondarySourceVersions = secondarySourceVersions {
            var secondarySourceVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondarySourceVersions)
            for projectsourceversion0 in secondarySourceVersions {
                try secondarySourceVersionsContainer.encode(projectsourceversion0)
            }
        }
        if let secondarySources = secondarySources {
            var secondarySourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondarySources)
            for projectsource0 in secondarySources {
                try secondarySourcesContainer.encode(projectsource0)
            }
        }
        if let serviceRole = self.serviceRole {
            try encodeContainer.encode(serviceRole, forKey: .serviceRole)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let sourceVersion = self.sourceVersion {
            try encodeContainer.encode(sourceVersion, forKey: .sourceVersion)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let timeoutInMinutes = self.timeoutInMinutes {
            try encodeContainer.encode(timeoutInMinutes, forKey: .timeoutInMinutes)
        }
        if let vpcConfig = self.vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let buildNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .buildNumber)
        buildNumber = buildNumberDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let currentPhaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentPhase)
        currentPhase = currentPhaseDecoded
        let buildStatusDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.StatusType.self, forKey: .buildStatus)
        buildStatus = buildStatusDecoded
        let sourceVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceVersion)
        sourceVersion = sourceVersionDecoded
        let resolvedSourceVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolvedSourceVersion)
        resolvedSourceVersion = resolvedSourceVersionDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let phasesContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.BuildPhase?].self, forKey: .phases)
        var phasesDecoded0:[CodeBuildClientTypes.BuildPhase]? = nil
        if let phasesContainer = phasesContainer {
            phasesDecoded0 = [CodeBuildClientTypes.BuildPhase]()
            for structure0 in phasesContainer {
                if let structure0 = structure0 {
                    phasesDecoded0?.append(structure0)
                }
            }
        }
        phases = phasesDecoded0
        let sourceDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ProjectSource.self, forKey: .source)
        source = sourceDecoded
        let secondarySourcesContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.ProjectSource?].self, forKey: .secondarySources)
        var secondarySourcesDecoded0:[CodeBuildClientTypes.ProjectSource]? = nil
        if let secondarySourcesContainer = secondarySourcesContainer {
            secondarySourcesDecoded0 = [CodeBuildClientTypes.ProjectSource]()
            for structure0 in secondarySourcesContainer {
                if let structure0 = structure0 {
                    secondarySourcesDecoded0?.append(structure0)
                }
            }
        }
        secondarySources = secondarySourcesDecoded0
        let secondarySourceVersionsContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.ProjectSourceVersion?].self, forKey: .secondarySourceVersions)
        var secondarySourceVersionsDecoded0:[CodeBuildClientTypes.ProjectSourceVersion]? = nil
        if let secondarySourceVersionsContainer = secondarySourceVersionsContainer {
            secondarySourceVersionsDecoded0 = [CodeBuildClientTypes.ProjectSourceVersion]()
            for structure0 in secondarySourceVersionsContainer {
                if let structure0 = structure0 {
                    secondarySourceVersionsDecoded0?.append(structure0)
                }
            }
        }
        secondarySourceVersions = secondarySourceVersionsDecoded0
        let artifactsDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.BuildArtifacts.self, forKey: .artifacts)
        artifacts = artifactsDecoded
        let secondaryArtifactsContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.BuildArtifacts?].self, forKey: .secondaryArtifacts)
        var secondaryArtifactsDecoded0:[CodeBuildClientTypes.BuildArtifacts]? = nil
        if let secondaryArtifactsContainer = secondaryArtifactsContainer {
            secondaryArtifactsDecoded0 = [CodeBuildClientTypes.BuildArtifacts]()
            for structure0 in secondaryArtifactsContainer {
                if let structure0 = structure0 {
                    secondaryArtifactsDecoded0?.append(structure0)
                }
            }
        }
        secondaryArtifacts = secondaryArtifactsDecoded0
        let cacheDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ProjectCache.self, forKey: .cache)
        cache = cacheDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ProjectEnvironment.self, forKey: .environment)
        environment = environmentDecoded
        let serviceRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRole)
        serviceRole = serviceRoleDecoded
        let logsDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.LogsLocation.self, forKey: .logs)
        logs = logsDecoded
        let timeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutInMinutes)
        timeoutInMinutes = timeoutInMinutesDecoded
        let queuedTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .queuedTimeoutInMinutes)
        queuedTimeoutInMinutes = queuedTimeoutInMinutesDecoded
        let buildCompleteDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .buildComplete) ?? false
        buildComplete = buildCompleteDecoded
        let initiatorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initiator)
        initiator = initiatorDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let networkInterfaceDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.NetworkInterface.self, forKey: .networkInterface)
        networkInterface = networkInterfaceDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let exportedEnvironmentVariablesContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.ExportedEnvironmentVariable?].self, forKey: .exportedEnvironmentVariables)
        var exportedEnvironmentVariablesDecoded0:[CodeBuildClientTypes.ExportedEnvironmentVariable]? = nil
        if let exportedEnvironmentVariablesContainer = exportedEnvironmentVariablesContainer {
            exportedEnvironmentVariablesDecoded0 = [CodeBuildClientTypes.ExportedEnvironmentVariable]()
            for structure0 in exportedEnvironmentVariablesContainer {
                if let structure0 = structure0 {
                    exportedEnvironmentVariablesDecoded0?.append(structure0)
                }
            }
        }
        exportedEnvironmentVariables = exportedEnvironmentVariablesDecoded0
        let reportArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .reportArns)
        var reportArnsDecoded0:[Swift.String]? = nil
        if let reportArnsContainer = reportArnsContainer {
            reportArnsDecoded0 = [Swift.String]()
            for string0 in reportArnsContainer {
                if let string0 = string0 {
                    reportArnsDecoded0?.append(string0)
                }
            }
        }
        reportArns = reportArnsDecoded0
        let fileSystemLocationsContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.ProjectFileSystemLocation?].self, forKey: .fileSystemLocations)
        var fileSystemLocationsDecoded0:[CodeBuildClientTypes.ProjectFileSystemLocation]? = nil
        if let fileSystemLocationsContainer = fileSystemLocationsContainer {
            fileSystemLocationsDecoded0 = [CodeBuildClientTypes.ProjectFileSystemLocation]()
            for structure0 in fileSystemLocationsContainer {
                if let structure0 = structure0 {
                    fileSystemLocationsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemLocations = fileSystemLocationsDecoded0
        let debugSessionDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.DebugSession.self, forKey: .debugSession)
        debugSession = debugSessionDecoded
        let buildBatchArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .buildBatchArn)
        buildBatchArn = buildBatchArnDecoded
    }
}

extension CodeBuildClientTypes {
    /// Information about a build.
    public struct Build: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the build.
        public var arn: Swift.String?
        /// Information about the output artifacts for the build.
        public var artifacts: CodeBuildClientTypes.BuildArtifacts?
        /// The ARN of the batch build that this build is a member of, if applicable.
        public var buildBatchArn: Swift.String?
        /// Whether the build is complete. True if complete; otherwise, false.
        public var buildComplete: Swift.Bool
        /// The number of the build. For each project, the buildNumber of its first build is 1. The buildNumber of each subsequent build is incremented by 1. If a build is deleted, the buildNumber of other builds does not change.
        public var buildNumber: Swift.Int?
        /// The current status of the build. Valid values include:
        ///
        /// * FAILED: The build failed.
        ///
        /// * FAULT: The build faulted.
        ///
        /// * IN_PROGRESS: The build is still in progress.
        ///
        /// * STOPPED: The build stopped.
        ///
        /// * SUCCEEDED: The build succeeded.
        ///
        /// * TIMED_OUT: The build timed out.
        public var buildStatus: CodeBuildClientTypes.StatusType?
        /// Information about the cache for the build.
        public var cache: CodeBuildClientTypes.ProjectCache?
        /// The current build phase.
        public var currentPhase: Swift.String?
        /// Contains information about the debug session for this build.
        public var debugSession: CodeBuildClientTypes.DebugSession?
        /// The Key Management Service customer master key (CMK) to be used for encrypting the build output artifacts. You can use a cross-account KMS key to encrypt the build output artifacts if your service role has permission to that key. You can specify either the Amazon Resource Name (ARN) of the CMK or, if available, the CMK's alias (using the format alias/).
        public var encryptionKey: Swift.String?
        /// When the build process ended, expressed in Unix time format.
        public var endTime: ClientRuntime.Date?
        /// Information about the build environment for this build.
        public var environment: CodeBuildClientTypes.ProjectEnvironment?
        /// A list of exported environment variables for this build. Exported environment variables are used in conjunction with CodePipeline to export environment variables from the current build stage to subsequent stages in the pipeline. For more information, see [Working with variables](https://docs.aws.amazon.com/codepipeline/latest/userguide/actions-variables.html) in the CodePipeline User Guide.
        public var exportedEnvironmentVariables: [CodeBuildClientTypes.ExportedEnvironmentVariable]?
        /// An array of ProjectFileSystemLocation objects for a CodeBuild build project. A ProjectFileSystemLocation object specifies the identifier, location, mountOptions, mountPoint, and type of a file system created using Amazon Elastic File System.
        public var fileSystemLocations: [CodeBuildClientTypes.ProjectFileSystemLocation]?
        /// The unique ID for the build.
        public var id: Swift.String?
        /// The entity that started the build. Valid values include:
        ///
        /// * If CodePipeline started the build, the pipeline's name (for example, codepipeline/my-demo-pipeline).
        ///
        /// * If an IAM user started the build, the user's name (for example, MyUserName).
        ///
        /// * If the Jenkins plugin for CodeBuild started the build, the string CodeBuild-Jenkins-Plugin.
        public var initiator: Swift.String?
        /// Information about the build's logs in CloudWatch Logs.
        public var logs: CodeBuildClientTypes.LogsLocation?
        /// Describes a network interface.
        public var networkInterface: CodeBuildClientTypes.NetworkInterface?
        /// Information about all previous build phases that are complete and information about any current build phase that is not yet complete.
        public var phases: [CodeBuildClientTypes.BuildPhase]?
        /// The name of the CodeBuild project.
        public var projectName: Swift.String?
        /// The number of minutes a build is allowed to be queued before it times out.
        public var queuedTimeoutInMinutes: Swift.Int?
        /// An array of the ARNs associated with this build's reports.
        public var reportArns: [Swift.String]?
        /// An identifier for the version of this build's source code.
        ///
        /// * For CodeCommit, GitHub, GitHub Enterprise, and BitBucket, the commit ID.
        ///
        /// * For CodePipeline, the source revision provided by CodePipeline.
        ///
        /// * For Amazon S3, this does not apply.
        public var resolvedSourceVersion: Swift.String?
        /// An array of ProjectArtifacts objects.
        public var secondaryArtifacts: [CodeBuildClientTypes.BuildArtifacts]?
        /// An array of ProjectSourceVersion objects. Each ProjectSourceVersion must be one of:
        ///
        /// * For CodeCommit: the commit ID, branch, or Git tag to use.
        ///
        /// * For GitHub: the commit ID, pull request ID, branch name, or tag name that corresponds to the version of the source code you want to build. If a pull request ID is specified, it must use the format pr/pull-request-ID (for example, pr/25). If a branch name is specified, the branch's HEAD commit ID is used. If not specified, the default branch's HEAD commit ID is used.
        ///
        /// * For Bitbucket: the commit ID, branch name, or tag name that corresponds to the version of the source code you want to build. If a branch name is specified, the branch's HEAD commit ID is used. If not specified, the default branch's HEAD commit ID is used.
        ///
        /// * For Amazon S3: the version ID of the object that represents the build input ZIP file to use.
        public var secondarySourceVersions: [CodeBuildClientTypes.ProjectSourceVersion]?
        /// An array of ProjectSource objects.
        public var secondarySources: [CodeBuildClientTypes.ProjectSource]?
        /// The name of a service role used for this build.
        public var serviceRole: Swift.String?
        /// Information about the source code to be built.
        public var source: CodeBuildClientTypes.ProjectSource?
        /// Any version identifier for the version of the source code to be built. If sourceVersion is specified at the project level, then this sourceVersion (at the build level) takes precedence. For more information, see [Source Version Sample with CodeBuild](https://docs.aws.amazon.com/codebuild/latest/userguide/sample-source-version.html) in the CodeBuild User Guide.
        public var sourceVersion: Swift.String?
        /// When the build process started, expressed in Unix time format.
        public var startTime: ClientRuntime.Date?
        /// How long, in minutes, for CodeBuild to wait before timing out this build if it does not get marked as completed.
        public var timeoutInMinutes: Swift.Int?
        /// If your CodeBuild project accesses resources in an Amazon VPC, you provide this parameter that identifies the VPC ID and the list of security group IDs and subnet IDs. The security groups and subnets must belong to the same VPC. You must provide at least one security group and one subnet ID.
        public var vpcConfig: CodeBuildClientTypes.VpcConfig?

        public init (
            arn: Swift.String? = nil,
            artifacts: CodeBuildClientTypes.BuildArtifacts? = nil,
            buildBatchArn: Swift.String? = nil,
            buildComplete: Swift.Bool = false,
            buildNumber: Swift.Int? = nil,
            buildStatus: CodeBuildClientTypes.StatusType? = nil,
            cache: CodeBuildClientTypes.ProjectCache? = nil,
            currentPhase: Swift.String? = nil,
            debugSession: CodeBuildClientTypes.DebugSession? = nil,
            encryptionKey: Swift.String? = nil,
            endTime: ClientRuntime.Date? = nil,
            environment: CodeBuildClientTypes.ProjectEnvironment? = nil,
            exportedEnvironmentVariables: [CodeBuildClientTypes.ExportedEnvironmentVariable]? = nil,
            fileSystemLocations: [CodeBuildClientTypes.ProjectFileSystemLocation]? = nil,
            id: Swift.String? = nil,
            initiator: Swift.String? = nil,
            logs: CodeBuildClientTypes.LogsLocation? = nil,
            networkInterface: CodeBuildClientTypes.NetworkInterface? = nil,
            phases: [CodeBuildClientTypes.BuildPhase]? = nil,
            projectName: Swift.String? = nil,
            queuedTimeoutInMinutes: Swift.Int? = nil,
            reportArns: [Swift.String]? = nil,
            resolvedSourceVersion: Swift.String? = nil,
            secondaryArtifacts: [CodeBuildClientTypes.BuildArtifacts]? = nil,
            secondarySourceVersions: [CodeBuildClientTypes.ProjectSourceVersion]? = nil,
            secondarySources: [CodeBuildClientTypes.ProjectSource]? = nil,
            serviceRole: Swift.String? = nil,
            source: CodeBuildClientTypes.ProjectSource? = nil,
            sourceVersion: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            timeoutInMinutes: Swift.Int? = nil,
            vpcConfig: CodeBuildClientTypes.VpcConfig? = nil
        )
        {
            self.arn = arn
            self.artifacts = artifacts
            self.buildBatchArn = buildBatchArn
            self.buildComplete = buildComplete
            self.buildNumber = buildNumber
            self.buildStatus = buildStatus
            self.cache = cache
            self.currentPhase = currentPhase
            self.debugSession = debugSession
            self.encryptionKey = encryptionKey
            self.endTime = endTime
            self.environment = environment
            self.exportedEnvironmentVariables = exportedEnvironmentVariables
            self.fileSystemLocations = fileSystemLocations
            self.id = id
            self.initiator = initiator
            self.logs = logs
            self.networkInterface = networkInterface
            self.phases = phases
            self.projectName = projectName
            self.queuedTimeoutInMinutes = queuedTimeoutInMinutes
            self.reportArns = reportArns
            self.resolvedSourceVersion = resolvedSourceVersion
            self.secondaryArtifacts = secondaryArtifacts
            self.secondarySourceVersions = secondarySourceVersions
            self.secondarySources = secondarySources
            self.serviceRole = serviceRole
            self.source = source
            self.sourceVersion = sourceVersion
            self.startTime = startTime
            self.timeoutInMinutes = timeoutInMinutes
            self.vpcConfig = vpcConfig
        }
    }

}

extension CodeBuildClientTypes.BuildArtifacts: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifactIdentifier
        case bucketOwnerAccess
        case encryptionDisabled
        case location
        case md5sum
        case overrideArtifactName
        case sha256sum
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactIdentifier = self.artifactIdentifier {
            try encodeContainer.encode(artifactIdentifier, forKey: .artifactIdentifier)
        }
        if let bucketOwnerAccess = self.bucketOwnerAccess {
            try encodeContainer.encode(bucketOwnerAccess.rawValue, forKey: .bucketOwnerAccess)
        }
        if let encryptionDisabled = self.encryptionDisabled {
            try encodeContainer.encode(encryptionDisabled, forKey: .encryptionDisabled)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let md5sum = self.md5sum {
            try encodeContainer.encode(md5sum, forKey: .md5sum)
        }
        if let overrideArtifactName = self.overrideArtifactName {
            try encodeContainer.encode(overrideArtifactName, forKey: .overrideArtifactName)
        }
        if let sha256sum = self.sha256sum {
            try encodeContainer.encode(sha256sum, forKey: .sha256sum)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let sha256sumDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sha256sum)
        sha256sum = sha256sumDecoded
        let md5sumDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .md5sum)
        md5sum = md5sumDecoded
        let overrideArtifactNameDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .overrideArtifactName)
        overrideArtifactName = overrideArtifactNameDecoded
        let encryptionDisabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encryptionDisabled)
        encryptionDisabled = encryptionDisabledDecoded
        let artifactIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .artifactIdentifier)
        artifactIdentifier = artifactIdentifierDecoded
        let bucketOwnerAccessDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.BucketOwnerAccess.self, forKey: .bucketOwnerAccess)
        bucketOwnerAccess = bucketOwnerAccessDecoded
    }
}

extension CodeBuildClientTypes {
    /// Information about build output artifacts.
    public struct BuildArtifacts: Swift.Equatable {
        /// An identifier for this artifact definition.
        public var artifactIdentifier: Swift.String?
        /// Specifies the bucket owner's access for objects that another account uploads to their Amazon S3 bucket. By default, only the account that uploads the objects to the bucket has access to these objects. This property allows you to give the bucket owner access to these objects. To use this property, your CodeBuild service role must have the s3:PutBucketAcl permission. This permission allows CodeBuild to modify the access control list for the bucket. This property can be one of the following values: NONE The bucket owner does not have access to the objects. This is the default. READ_ONLY The bucket owner has read-only access to the objects. The uploading account retains ownership of the objects. FULL The bucket owner has full access to the objects. Object ownership is determined by the following criteria:
        ///
        /// * If the bucket is configured with the Bucket owner preferred setting, the bucket owner owns the objects. The uploading account will have object access as specified by the bucket's policy.
        ///
        /// * Otherwise, the uploading account retains ownership of the objects.
        ///
        ///
        /// For more information about Amazon S3 object ownership, see [Controlling ownership of uploaded objects using S3 Object Ownership](https://docs.aws.amazon.com/AmazonS3/latest/userguide/about-object-ownership.html) in the Amazon Simple Storage Service User Guide.
        public var bucketOwnerAccess: CodeBuildClientTypes.BucketOwnerAccess?
        /// Information that tells you if encryption for build artifacts is disabled.
        public var encryptionDisabled: Swift.Bool?
        /// Information about the location of the build artifacts.
        public var location: Swift.String?
        /// The MD5 hash of the build artifact. You can use this hash along with a checksum tool to confirm file integrity and authenticity. This value is available only if the build project's packaging value is set to ZIP.
        public var md5sum: Swift.String?
        /// If this flag is set, a name specified in the buildspec file overrides the artifact name. The name specified in a buildspec file is calculated at build time and uses the Shell Command Language. For example, you can append a date and time to your artifact name so that it is always unique.
        public var overrideArtifactName: Swift.Bool?
        /// The SHA-256 hash of the build artifact. You can use this hash along with a checksum tool to confirm file integrity and authenticity. This value is available only if the build project's packaging value is set to ZIP.
        public var sha256sum: Swift.String?

        public init (
            artifactIdentifier: Swift.String? = nil,
            bucketOwnerAccess: CodeBuildClientTypes.BucketOwnerAccess? = nil,
            encryptionDisabled: Swift.Bool? = nil,
            location: Swift.String? = nil,
            md5sum: Swift.String? = nil,
            overrideArtifactName: Swift.Bool? = nil,
            sha256sum: Swift.String? = nil
        )
        {
            self.artifactIdentifier = artifactIdentifier
            self.bucketOwnerAccess = bucketOwnerAccess
            self.encryptionDisabled = encryptionDisabled
            self.location = location
            self.md5sum = md5sum
            self.overrideArtifactName = overrideArtifactName
            self.sha256sum = sha256sum
        }
    }

}

extension CodeBuildClientTypes.BuildBatch: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case artifacts
        case buildBatchConfig
        case buildBatchNumber
        case buildBatchStatus
        case buildGroups
        case buildTimeoutInMinutes
        case cache
        case complete
        case currentPhase
        case debugSessionEnabled
        case encryptionKey
        case endTime
        case environment
        case fileSystemLocations
        case id
        case initiator
        case logConfig
        case phases
        case projectName
        case queuedTimeoutInMinutes
        case resolvedSourceVersion
        case secondaryArtifacts
        case secondarySourceVersions
        case secondarySources
        case serviceRole
        case source
        case sourceVersion
        case startTime
        case vpcConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let artifacts = self.artifacts {
            try encodeContainer.encode(artifacts, forKey: .artifacts)
        }
        if let buildBatchConfig = self.buildBatchConfig {
            try encodeContainer.encode(buildBatchConfig, forKey: .buildBatchConfig)
        }
        if let buildBatchNumber = self.buildBatchNumber {
            try encodeContainer.encode(buildBatchNumber, forKey: .buildBatchNumber)
        }
        if let buildBatchStatus = self.buildBatchStatus {
            try encodeContainer.encode(buildBatchStatus.rawValue, forKey: .buildBatchStatus)
        }
        if let buildGroups = buildGroups {
            var buildGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .buildGroups)
            for buildgroup0 in buildGroups {
                try buildGroupsContainer.encode(buildgroup0)
            }
        }
        if let buildTimeoutInMinutes = self.buildTimeoutInMinutes {
            try encodeContainer.encode(buildTimeoutInMinutes, forKey: .buildTimeoutInMinutes)
        }
        if let cache = self.cache {
            try encodeContainer.encode(cache, forKey: .cache)
        }
        if complete != false {
            try encodeContainer.encode(complete, forKey: .complete)
        }
        if let currentPhase = self.currentPhase {
            try encodeContainer.encode(currentPhase, forKey: .currentPhase)
        }
        if let debugSessionEnabled = self.debugSessionEnabled {
            try encodeContainer.encode(debugSessionEnabled, forKey: .debugSessionEnabled)
        }
        if let encryptionKey = self.encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let environment = self.environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let fileSystemLocations = fileSystemLocations {
            var fileSystemLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileSystemLocations)
            for projectfilesystemlocation0 in fileSystemLocations {
                try fileSystemLocationsContainer.encode(projectfilesystemlocation0)
            }
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let initiator = self.initiator {
            try encodeContainer.encode(initiator, forKey: .initiator)
        }
        if let logConfig = self.logConfig {
            try encodeContainer.encode(logConfig, forKey: .logConfig)
        }
        if let phases = phases {
            var phasesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phases)
            for buildbatchphase0 in phases {
                try phasesContainer.encode(buildbatchphase0)
            }
        }
        if let projectName = self.projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let queuedTimeoutInMinutes = self.queuedTimeoutInMinutes {
            try encodeContainer.encode(queuedTimeoutInMinutes, forKey: .queuedTimeoutInMinutes)
        }
        if let resolvedSourceVersion = self.resolvedSourceVersion {
            try encodeContainer.encode(resolvedSourceVersion, forKey: .resolvedSourceVersion)
        }
        if let secondaryArtifacts = secondaryArtifacts {
            var secondaryArtifactsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondaryArtifacts)
            for buildartifacts0 in secondaryArtifacts {
                try secondaryArtifactsContainer.encode(buildartifacts0)
            }
        }
        if let secondarySourceVersions = secondarySourceVersions {
            var secondarySourceVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondarySourceVersions)
            for projectsourceversion0 in secondarySourceVersions {
                try secondarySourceVersionsContainer.encode(projectsourceversion0)
            }
        }
        if let secondarySources = secondarySources {
            var secondarySourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondarySources)
            for projectsource0 in secondarySources {
                try secondarySourcesContainer.encode(projectsource0)
            }
        }
        if let serviceRole = self.serviceRole {
            try encodeContainer.encode(serviceRole, forKey: .serviceRole)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let sourceVersion = self.sourceVersion {
            try encodeContainer.encode(sourceVersion, forKey: .sourceVersion)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let vpcConfig = self.vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let currentPhaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentPhase)
        currentPhase = currentPhaseDecoded
        let buildBatchStatusDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.StatusType.self, forKey: .buildBatchStatus)
        buildBatchStatus = buildBatchStatusDecoded
        let sourceVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceVersion)
        sourceVersion = sourceVersionDecoded
        let resolvedSourceVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolvedSourceVersion)
        resolvedSourceVersion = resolvedSourceVersionDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let phasesContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.BuildBatchPhase?].self, forKey: .phases)
        var phasesDecoded0:[CodeBuildClientTypes.BuildBatchPhase]? = nil
        if let phasesContainer = phasesContainer {
            phasesDecoded0 = [CodeBuildClientTypes.BuildBatchPhase]()
            for structure0 in phasesContainer {
                if let structure0 = structure0 {
                    phasesDecoded0?.append(structure0)
                }
            }
        }
        phases = phasesDecoded0
        let sourceDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ProjectSource.self, forKey: .source)
        source = sourceDecoded
        let secondarySourcesContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.ProjectSource?].self, forKey: .secondarySources)
        var secondarySourcesDecoded0:[CodeBuildClientTypes.ProjectSource]? = nil
        if let secondarySourcesContainer = secondarySourcesContainer {
            secondarySourcesDecoded0 = [CodeBuildClientTypes.ProjectSource]()
            for structure0 in secondarySourcesContainer {
                if let structure0 = structure0 {
                    secondarySourcesDecoded0?.append(structure0)
                }
            }
        }
        secondarySources = secondarySourcesDecoded0
        let secondarySourceVersionsContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.ProjectSourceVersion?].self, forKey: .secondarySourceVersions)
        var secondarySourceVersionsDecoded0:[CodeBuildClientTypes.ProjectSourceVersion]? = nil
        if let secondarySourceVersionsContainer = secondarySourceVersionsContainer {
            secondarySourceVersionsDecoded0 = [CodeBuildClientTypes.ProjectSourceVersion]()
            for structure0 in secondarySourceVersionsContainer {
                if let structure0 = structure0 {
                    secondarySourceVersionsDecoded0?.append(structure0)
                }
            }
        }
        secondarySourceVersions = secondarySourceVersionsDecoded0
        let artifactsDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.BuildArtifacts.self, forKey: .artifacts)
        artifacts = artifactsDecoded
        let secondaryArtifactsContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.BuildArtifacts?].self, forKey: .secondaryArtifacts)
        var secondaryArtifactsDecoded0:[CodeBuildClientTypes.BuildArtifacts]? = nil
        if let secondaryArtifactsContainer = secondaryArtifactsContainer {
            secondaryArtifactsDecoded0 = [CodeBuildClientTypes.BuildArtifacts]()
            for structure0 in secondaryArtifactsContainer {
                if let structure0 = structure0 {
                    secondaryArtifactsDecoded0?.append(structure0)
                }
            }
        }
        secondaryArtifacts = secondaryArtifactsDecoded0
        let cacheDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ProjectCache.self, forKey: .cache)
        cache = cacheDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ProjectEnvironment.self, forKey: .environment)
        environment = environmentDecoded
        let serviceRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRole)
        serviceRole = serviceRoleDecoded
        let logConfigDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.LogsConfig.self, forKey: .logConfig)
        logConfig = logConfigDecoded
        let buildTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .buildTimeoutInMinutes)
        buildTimeoutInMinutes = buildTimeoutInMinutesDecoded
        let queuedTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .queuedTimeoutInMinutes)
        queuedTimeoutInMinutes = queuedTimeoutInMinutesDecoded
        let completeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .complete) ?? false
        complete = completeDecoded
        let initiatorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initiator)
        initiator = initiatorDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let buildBatchNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .buildBatchNumber)
        buildBatchNumber = buildBatchNumberDecoded
        let fileSystemLocationsContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.ProjectFileSystemLocation?].self, forKey: .fileSystemLocations)
        var fileSystemLocationsDecoded0:[CodeBuildClientTypes.ProjectFileSystemLocation]? = nil
        if let fileSystemLocationsContainer = fileSystemLocationsContainer {
            fileSystemLocationsDecoded0 = [CodeBuildClientTypes.ProjectFileSystemLocation]()
            for structure0 in fileSystemLocationsContainer {
                if let structure0 = structure0 {
                    fileSystemLocationsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemLocations = fileSystemLocationsDecoded0
        let buildBatchConfigDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ProjectBuildBatchConfig.self, forKey: .buildBatchConfig)
        buildBatchConfig = buildBatchConfigDecoded
        let buildGroupsContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.BuildGroup?].self, forKey: .buildGroups)
        var buildGroupsDecoded0:[CodeBuildClientTypes.BuildGroup]? = nil
        if let buildGroupsContainer = buildGroupsContainer {
            buildGroupsDecoded0 = [CodeBuildClientTypes.BuildGroup]()
            for structure0 in buildGroupsContainer {
                if let structure0 = structure0 {
                    buildGroupsDecoded0?.append(structure0)
                }
            }
        }
        buildGroups = buildGroupsDecoded0
        let debugSessionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .debugSessionEnabled)
        debugSessionEnabled = debugSessionEnabledDecoded
    }
}

extension CodeBuildClientTypes {
    /// Contains information about a batch build.
    public struct BuildBatch: Swift.Equatable {
        /// The ARN of the batch build.
        public var arn: Swift.String?
        /// A BuildArtifacts object the defines the build artifacts for this batch build.
        public var artifacts: CodeBuildClientTypes.BuildArtifacts?
        /// Contains configuration information about a batch build project.
        public var buildBatchConfig: CodeBuildClientTypes.ProjectBuildBatchConfig?
        /// The number of the batch build. For each project, the buildBatchNumber of its first batch build is 1. The buildBatchNumber of each subsequent batch build is incremented by 1. If a batch build is deleted, the buildBatchNumber of other batch builds does not change.
        public var buildBatchNumber: Swift.Int?
        /// The status of the batch build.
        public var buildBatchStatus: CodeBuildClientTypes.StatusType?
        /// An array of BuildGroup objects that define the build groups for the batch build.
        public var buildGroups: [CodeBuildClientTypes.BuildGroup]?
        /// Specifies the maximum amount of time, in minutes, that the build in a batch must be completed in.
        public var buildTimeoutInMinutes: Swift.Int?
        /// Information about the cache for the build project.
        public var cache: CodeBuildClientTypes.ProjectCache?
        /// Indicates if the batch build is complete.
        public var complete: Swift.Bool
        /// The current phase of the batch build.
        public var currentPhase: Swift.String?
        /// Specifies if session debugging is enabled for this batch build. For more information, see [Viewing a running build in Session Manager](https://docs.aws.amazon.com/codebuild/latest/userguide/session-manager.html). Batch session debugging is not supported for matrix batch builds.
        public var debugSessionEnabled: Swift.Bool?
        /// The Key Management Service customer master key (CMK) to be used for encrypting the batch build output artifacts. You can use a cross-account KMS key to encrypt the build output artifacts if your service role has permission to that key. You can specify either the Amazon Resource Name (ARN) of the CMK or, if available, the CMK's alias (using the format alias/).
        public var encryptionKey: Swift.String?
        /// The date and time that the batch build ended.
        public var endTime: ClientRuntime.Date?
        /// Information about the build environment of the build project.
        public var environment: CodeBuildClientTypes.ProjectEnvironment?
        /// An array of ProjectFileSystemLocation objects for the batch build project. A ProjectFileSystemLocation object specifies the identifier, location, mountOptions, mountPoint, and type of a file system created using Amazon Elastic File System.
        public var fileSystemLocations: [CodeBuildClientTypes.ProjectFileSystemLocation]?
        /// The identifier of the batch build.
        public var id: Swift.String?
        /// The entity that started the batch build. Valid values include:
        ///
        /// * If CodePipeline started the build, the pipeline's name (for example, codepipeline/my-demo-pipeline).
        ///
        /// * If an IAM user started the build, the user's name.
        ///
        /// * If the Jenkins plugin for CodeBuild started the build, the string CodeBuild-Jenkins-Plugin.
        public var initiator: Swift.String?
        /// Information about logs for a build project. These can be logs in CloudWatch Logs, built in a specified S3 bucket, or both.
        public var logConfig: CodeBuildClientTypes.LogsConfig?
        /// An array of BuildBatchPhase objects the specify the phases of the batch build.
        public var phases: [CodeBuildClientTypes.BuildBatchPhase]?
        /// The name of the batch build project.
        public var projectName: Swift.String?
        /// Specifies the amount of time, in minutes, that the batch build is allowed to be queued before it times out.
        public var queuedTimeoutInMinutes: Swift.Int?
        /// The identifier of the resolved version of this batch build's source code.
        ///
        /// * For CodeCommit, GitHub, GitHub Enterprise, and BitBucket, the commit ID.
        ///
        /// * For CodePipeline, the source revision provided by CodePipeline.
        ///
        /// * For Amazon S3, this does not apply.
        public var resolvedSourceVersion: Swift.String?
        /// An array of BuildArtifacts objects the define the build artifacts for this batch build.
        public var secondaryArtifacts: [CodeBuildClientTypes.BuildArtifacts]?
        /// An array of ProjectSourceVersion objects. Each ProjectSourceVersion must be one of:
        ///
        /// * For CodeCommit: the commit ID, branch, or Git tag to use.
        ///
        /// * For GitHub: the commit ID, pull request ID, branch name, or tag name that corresponds to the version of the source code you want to build. If a pull request ID is specified, it must use the format pr/pull-request-ID (for example, pr/25). If a branch name is specified, the branch's HEAD commit ID is used. If not specified, the default branch's HEAD commit ID is used.
        ///
        /// * For Bitbucket: the commit ID, branch name, or tag name that corresponds to the version of the source code you want to build. If a branch name is specified, the branch's HEAD commit ID is used. If not specified, the default branch's HEAD commit ID is used.
        ///
        /// * For Amazon S3: the version ID of the object that represents the build input ZIP file to use.
        public var secondarySourceVersions: [CodeBuildClientTypes.ProjectSourceVersion]?
        /// An array of ProjectSource objects that define the sources for the batch build.
        public var secondarySources: [CodeBuildClientTypes.ProjectSource]?
        /// The name of a service role used for builds in the batch.
        public var serviceRole: Swift.String?
        /// Information about the build input source code for the build project.
        public var source: CodeBuildClientTypes.ProjectSource?
        /// The identifier of the version of the source code to be built.
        public var sourceVersion: Swift.String?
        /// The date and time that the batch build started.
        public var startTime: ClientRuntime.Date?
        /// Information about the VPC configuration that CodeBuild accesses.
        public var vpcConfig: CodeBuildClientTypes.VpcConfig?

        public init (
            arn: Swift.String? = nil,
            artifacts: CodeBuildClientTypes.BuildArtifacts? = nil,
            buildBatchConfig: CodeBuildClientTypes.ProjectBuildBatchConfig? = nil,
            buildBatchNumber: Swift.Int? = nil,
            buildBatchStatus: CodeBuildClientTypes.StatusType? = nil,
            buildGroups: [CodeBuildClientTypes.BuildGroup]? = nil,
            buildTimeoutInMinutes: Swift.Int? = nil,
            cache: CodeBuildClientTypes.ProjectCache? = nil,
            complete: Swift.Bool = false,
            currentPhase: Swift.String? = nil,
            debugSessionEnabled: Swift.Bool? = nil,
            encryptionKey: Swift.String? = nil,
            endTime: ClientRuntime.Date? = nil,
            environment: CodeBuildClientTypes.ProjectEnvironment? = nil,
            fileSystemLocations: [CodeBuildClientTypes.ProjectFileSystemLocation]? = nil,
            id: Swift.String? = nil,
            initiator: Swift.String? = nil,
            logConfig: CodeBuildClientTypes.LogsConfig? = nil,
            phases: [CodeBuildClientTypes.BuildBatchPhase]? = nil,
            projectName: Swift.String? = nil,
            queuedTimeoutInMinutes: Swift.Int? = nil,
            resolvedSourceVersion: Swift.String? = nil,
            secondaryArtifacts: [CodeBuildClientTypes.BuildArtifacts]? = nil,
            secondarySourceVersions: [CodeBuildClientTypes.ProjectSourceVersion]? = nil,
            secondarySources: [CodeBuildClientTypes.ProjectSource]? = nil,
            serviceRole: Swift.String? = nil,
            source: CodeBuildClientTypes.ProjectSource? = nil,
            sourceVersion: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            vpcConfig: CodeBuildClientTypes.VpcConfig? = nil
        )
        {
            self.arn = arn
            self.artifacts = artifacts
            self.buildBatchConfig = buildBatchConfig
            self.buildBatchNumber = buildBatchNumber
            self.buildBatchStatus = buildBatchStatus
            self.buildGroups = buildGroups
            self.buildTimeoutInMinutes = buildTimeoutInMinutes
            self.cache = cache
            self.complete = complete
            self.currentPhase = currentPhase
            self.debugSessionEnabled = debugSessionEnabled
            self.encryptionKey = encryptionKey
            self.endTime = endTime
            self.environment = environment
            self.fileSystemLocations = fileSystemLocations
            self.id = id
            self.initiator = initiator
            self.logConfig = logConfig
            self.phases = phases
            self.projectName = projectName
            self.queuedTimeoutInMinutes = queuedTimeoutInMinutes
            self.resolvedSourceVersion = resolvedSourceVersion
            self.secondaryArtifacts = secondaryArtifacts
            self.secondarySourceVersions = secondarySourceVersions
            self.secondarySources = secondarySources
            self.serviceRole = serviceRole
            self.source = source
            self.sourceVersion = sourceVersion
            self.startTime = startTime
            self.vpcConfig = vpcConfig
        }
    }

}

extension CodeBuildClientTypes.BuildBatchFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.StatusType.self, forKey: .status)
        status = statusDecoded
    }
}

extension CodeBuildClientTypes {
    /// Specifies filters when retrieving batch builds.
    public struct BuildBatchFilter: Swift.Equatable {
        /// The status of the batch builds to retrieve. Only batch builds that have this status will be retrieved.
        public var status: CodeBuildClientTypes.StatusType?

        public init (
            status: CodeBuildClientTypes.StatusType? = nil
        )
        {
            self.status = status
        }
    }

}

extension CodeBuildClientTypes.BuildBatchPhase: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contexts
        case durationInSeconds
        case endTime
        case phaseStatus
        case phaseType
        case startTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contexts = contexts {
            var contextsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .contexts)
            for phasecontext0 in contexts {
                try contextsContainer.encode(phasecontext0)
            }
        }
        if let durationInSeconds = self.durationInSeconds {
            try encodeContainer.encode(durationInSeconds, forKey: .durationInSeconds)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let phaseStatus = self.phaseStatus {
            try encodeContainer.encode(phaseStatus.rawValue, forKey: .phaseStatus)
        }
        if let phaseType = self.phaseType {
            try encodeContainer.encode(phaseType.rawValue, forKey: .phaseType)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phaseTypeDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.BuildBatchPhaseType.self, forKey: .phaseType)
        phaseType = phaseTypeDecoded
        let phaseStatusDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.StatusType.self, forKey: .phaseStatus)
        phaseStatus = phaseStatusDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let durationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationInSeconds)
        durationInSeconds = durationInSecondsDecoded
        let contextsContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.PhaseContext?].self, forKey: .contexts)
        var contextsDecoded0:[CodeBuildClientTypes.PhaseContext]? = nil
        if let contextsContainer = contextsContainer {
            contextsDecoded0 = [CodeBuildClientTypes.PhaseContext]()
            for structure0 in contextsContainer {
                if let structure0 = structure0 {
                    contextsDecoded0?.append(structure0)
                }
            }
        }
        contexts = contextsDecoded0
    }
}

extension CodeBuildClientTypes {
    /// Contains information about a stage for a batch build.
    public struct BuildBatchPhase: Swift.Equatable {
        /// Additional information about the batch build phase. Especially to help troubleshoot a failed batch build.
        public var contexts: [CodeBuildClientTypes.PhaseContext]?
        /// How long, in seconds, between the starting and ending times of the batch build's phase.
        public var durationInSeconds: Swift.Int?
        /// When the batch build phase ended, expressed in Unix time format.
        public var endTime: ClientRuntime.Date?
        /// The current status of the batch build phase. Valid values include: FAILED The build phase failed. FAULT The build phase faulted. IN_PROGRESS The build phase is still in progress. STOPPED The build phase stopped. SUCCEEDED The build phase succeeded. TIMED_OUT The build phase timed out.
        public var phaseStatus: CodeBuildClientTypes.StatusType?
        /// The name of the batch build phase. Valid values include: COMBINE_ARTIFACTS Build output artifacts are being combined and uploaded to the output location. DOWNLOAD_BATCHSPEC The batch build specification is being downloaded. FAILED One or more of the builds failed. IN_PROGRESS The batch build is in progress. STOPPED The batch build was stopped. SUBMITTED The btach build has been submitted. SUCCEEDED The batch build succeeded.
        public var phaseType: CodeBuildClientTypes.BuildBatchPhaseType?
        /// When the batch build phase started, expressed in Unix time format.
        public var startTime: ClientRuntime.Date?

        public init (
            contexts: [CodeBuildClientTypes.PhaseContext]? = nil,
            durationInSeconds: Swift.Int? = nil,
            endTime: ClientRuntime.Date? = nil,
            phaseStatus: CodeBuildClientTypes.StatusType? = nil,
            phaseType: CodeBuildClientTypes.BuildBatchPhaseType? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.contexts = contexts
            self.durationInSeconds = durationInSeconds
            self.endTime = endTime
            self.phaseStatus = phaseStatus
            self.phaseType = phaseType
            self.startTime = startTime
        }
    }

}

extension CodeBuildClientTypes {
    public enum BuildBatchPhaseType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case combineArtifacts
        case downloadBatchspec
        case failed
        case inProgress
        case stopped
        case submitted
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [BuildBatchPhaseType] {
            return [
                .combineArtifacts,
                .downloadBatchspec,
                .failed,
                .inProgress,
                .stopped,
                .submitted,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .combineArtifacts: return "COMBINE_ARTIFACTS"
            case .downloadBatchspec: return "DOWNLOAD_BATCHSPEC"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .stopped: return "STOPPED"
            case .submitted: return "SUBMITTED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BuildBatchPhaseType(rawValue: rawValue) ?? BuildBatchPhaseType.sdkUnknown(rawValue)
        }
    }
}

extension CodeBuildClientTypes.BuildGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentBuildSummary
        case dependsOn
        case identifier
        case ignoreFailure
        case priorBuildSummaryList
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentBuildSummary = self.currentBuildSummary {
            try encodeContainer.encode(currentBuildSummary, forKey: .currentBuildSummary)
        }
        if let dependsOn = dependsOn {
            var dependsOnContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dependsOn)
            for nonemptystring0 in dependsOn {
                try dependsOnContainer.encode(nonemptystring0)
            }
        }
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if ignoreFailure != false {
            try encodeContainer.encode(ignoreFailure, forKey: .ignoreFailure)
        }
        if let priorBuildSummaryList = priorBuildSummaryList {
            var priorBuildSummaryListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .priorBuildSummaryList)
            for buildsummary0 in priorBuildSummaryList {
                try priorBuildSummaryListContainer.encode(buildsummary0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let dependsOnContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dependsOn)
        var dependsOnDecoded0:[Swift.String]? = nil
        if let dependsOnContainer = dependsOnContainer {
            dependsOnDecoded0 = [Swift.String]()
            for string0 in dependsOnContainer {
                if let string0 = string0 {
                    dependsOnDecoded0?.append(string0)
                }
            }
        }
        dependsOn = dependsOnDecoded0
        let ignoreFailureDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ignoreFailure) ?? false
        ignoreFailure = ignoreFailureDecoded
        let currentBuildSummaryDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.BuildSummary.self, forKey: .currentBuildSummary)
        currentBuildSummary = currentBuildSummaryDecoded
        let priorBuildSummaryListContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.BuildSummary?].self, forKey: .priorBuildSummaryList)
        var priorBuildSummaryListDecoded0:[CodeBuildClientTypes.BuildSummary]? = nil
        if let priorBuildSummaryListContainer = priorBuildSummaryListContainer {
            priorBuildSummaryListDecoded0 = [CodeBuildClientTypes.BuildSummary]()
            for structure0 in priorBuildSummaryListContainer {
                if let structure0 = structure0 {
                    priorBuildSummaryListDecoded0?.append(structure0)
                }
            }
        }
        priorBuildSummaryList = priorBuildSummaryListDecoded0
    }
}

extension CodeBuildClientTypes {
    /// Contains information about a batch build build group. Build groups are used to combine builds that can run in parallel, while still being able to set dependencies on other build groups.
    public struct BuildGroup: Swift.Equatable {
        /// A BuildSummary object that contains a summary of the current build group.
        public var currentBuildSummary: CodeBuildClientTypes.BuildSummary?
        /// An array of strings that contain the identifiers of the build groups that this build group depends on.
        public var dependsOn: [Swift.String]?
        /// Contains the identifier of the build group.
        public var identifier: Swift.String?
        /// Specifies if failures in this build group can be ignored.
        public var ignoreFailure: Swift.Bool
        /// An array of BuildSummary objects that contain summaries of previous build groups.
        public var priorBuildSummaryList: [CodeBuildClientTypes.BuildSummary]?

        public init (
            currentBuildSummary: CodeBuildClientTypes.BuildSummary? = nil,
            dependsOn: [Swift.String]? = nil,
            identifier: Swift.String? = nil,
            ignoreFailure: Swift.Bool = false,
            priorBuildSummaryList: [CodeBuildClientTypes.BuildSummary]? = nil
        )
        {
            self.currentBuildSummary = currentBuildSummary
            self.dependsOn = dependsOn
            self.identifier = identifier
            self.ignoreFailure = ignoreFailure
            self.priorBuildSummaryList = priorBuildSummaryList
        }
    }

}

extension CodeBuildClientTypes.BuildNotDeleted: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case statusCode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let statusCode = self.statusCode {
            try encodeContainer.encode(statusCode, forKey: .statusCode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
    }
}

extension CodeBuildClientTypes {
    /// Information about a build that could not be successfully deleted.
    public struct BuildNotDeleted: Swift.Equatable {
        /// The ID of the build that could not be successfully deleted.
        public var id: Swift.String?
        /// Additional information about the build that could not be successfully deleted.
        public var statusCode: Swift.String?

        public init (
            id: Swift.String? = nil,
            statusCode: Swift.String? = nil
        )
        {
            self.id = id
            self.statusCode = statusCode
        }
    }

}

extension CodeBuildClientTypes.BuildPhase: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contexts
        case durationInSeconds
        case endTime
        case phaseStatus
        case phaseType
        case startTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contexts = contexts {
            var contextsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .contexts)
            for phasecontext0 in contexts {
                try contextsContainer.encode(phasecontext0)
            }
        }
        if let durationInSeconds = self.durationInSeconds {
            try encodeContainer.encode(durationInSeconds, forKey: .durationInSeconds)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let phaseStatus = self.phaseStatus {
            try encodeContainer.encode(phaseStatus.rawValue, forKey: .phaseStatus)
        }
        if let phaseType = self.phaseType {
            try encodeContainer.encode(phaseType.rawValue, forKey: .phaseType)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phaseTypeDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.BuildPhaseType.self, forKey: .phaseType)
        phaseType = phaseTypeDecoded
        let phaseStatusDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.StatusType.self, forKey: .phaseStatus)
        phaseStatus = phaseStatusDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let durationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationInSeconds)
        durationInSeconds = durationInSecondsDecoded
        let contextsContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.PhaseContext?].self, forKey: .contexts)
        var contextsDecoded0:[CodeBuildClientTypes.PhaseContext]? = nil
        if let contextsContainer = contextsContainer {
            contextsDecoded0 = [CodeBuildClientTypes.PhaseContext]()
            for structure0 in contextsContainer {
                if let structure0 = structure0 {
                    contextsDecoded0?.append(structure0)
                }
            }
        }
        contexts = contextsDecoded0
    }
}

extension CodeBuildClientTypes {
    /// Information about a stage for a build.
    public struct BuildPhase: Swift.Equatable {
        /// Additional information about a build phase, especially to help troubleshoot a failed build.
        public var contexts: [CodeBuildClientTypes.PhaseContext]?
        /// How long, in seconds, between the starting and ending times of the build's phase.
        public var durationInSeconds: Swift.Int?
        /// When the build phase ended, expressed in Unix time format.
        public var endTime: ClientRuntime.Date?
        /// The current status of the build phase. Valid values include: FAILED The build phase failed. FAULT The build phase faulted. IN_PROGRESS The build phase is still in progress. STOPPED The build phase stopped. SUCCEEDED The build phase succeeded. TIMED_OUT The build phase timed out.
        public var phaseStatus: CodeBuildClientTypes.StatusType?
        /// The name of the build phase. Valid values include: BUILD Core build activities typically occur in this build phase. COMPLETED The build has been completed. DOWNLOAD_SOURCE Source code is being downloaded in this build phase. FINALIZING The build process is completing in this build phase. INSTALL Installation activities typically occur in this build phase. POST_BUILD Post-build activities typically occur in this build phase. PRE_BUILD Pre-build activities typically occur in this build phase. PROVISIONING The build environment is being set up. QUEUED The build has been submitted and is queued behind other submitted builds. SUBMITTED The build has been submitted. UPLOAD_ARTIFACTS Build output artifacts are being uploaded to the output location.
        public var phaseType: CodeBuildClientTypes.BuildPhaseType?
        /// When the build phase started, expressed in Unix time format.
        public var startTime: ClientRuntime.Date?

        public init (
            contexts: [CodeBuildClientTypes.PhaseContext]? = nil,
            durationInSeconds: Swift.Int? = nil,
            endTime: ClientRuntime.Date? = nil,
            phaseStatus: CodeBuildClientTypes.StatusType? = nil,
            phaseType: CodeBuildClientTypes.BuildPhaseType? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.contexts = contexts
            self.durationInSeconds = durationInSeconds
            self.endTime = endTime
            self.phaseStatus = phaseStatus
            self.phaseType = phaseType
            self.startTime = startTime
        }
    }

}

extension CodeBuildClientTypes {
    public enum BuildPhaseType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case build
        case completed
        case downloadSource
        case finalizing
        case install
        case postBuild
        case preBuild
        case provisioning
        case queued
        case submitted
        case uploadArtifacts
        case sdkUnknown(Swift.String)

        public static var allCases: [BuildPhaseType] {
            return [
                .build,
                .completed,
                .downloadSource,
                .finalizing,
                .install,
                .postBuild,
                .preBuild,
                .provisioning,
                .queued,
                .submitted,
                .uploadArtifacts,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .build: return "BUILD"
            case .completed: return "COMPLETED"
            case .downloadSource: return "DOWNLOAD_SOURCE"
            case .finalizing: return "FINALIZING"
            case .install: return "INSTALL"
            case .postBuild: return "POST_BUILD"
            case .preBuild: return "PRE_BUILD"
            case .provisioning: return "PROVISIONING"
            case .queued: return "QUEUED"
            case .submitted: return "SUBMITTED"
            case .uploadArtifacts: return "UPLOAD_ARTIFACTS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BuildPhaseType(rawValue: rawValue) ?? BuildPhaseType.sdkUnknown(rawValue)
        }
    }
}

extension CodeBuildClientTypes.BuildStatusConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case context
        case targetUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let context = self.context {
            try encodeContainer.encode(context, forKey: .context)
        }
        if let targetUrl = self.targetUrl {
            try encodeContainer.encode(targetUrl, forKey: .targetUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .context)
        context = contextDecoded
        let targetUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetUrl)
        targetUrl = targetUrlDecoded
    }
}

extension CodeBuildClientTypes {
    /// Contains information that defines how the CodeBuild build project reports the build status to the source provider.
    public struct BuildStatusConfig: Swift.Equatable {
        /// Specifies the context of the build status CodeBuild sends to the source provider. The usage of this parameter depends on the source provider. Bitbucket This parameter is used for the name parameter in the Bitbucket commit status. For more information, see [build](https://developer.atlassian.com/bitbucket/api/2/reference/resource/repositories/%7Bworkspace%7D/%7Brepo_slug%7D/commit/%7Bnode%7D/statuses/build) in the Bitbucket API documentation. GitHub/GitHub Enterprise Server This parameter is used for the context parameter in the GitHub commit status. For more information, see [Create a commit status](https://developer.github.com/v3/repos/statuses/#create-a-commit-status) in the GitHub developer guide.
        public var context: Swift.String?
        /// Specifies the target url of the build status CodeBuild sends to the source provider. The usage of this parameter depends on the source provider. Bitbucket This parameter is used for the url parameter in the Bitbucket commit status. For more information, see [build](https://developer.atlassian.com/bitbucket/api/2/reference/resource/repositories/%7Bworkspace%7D/%7Brepo_slug%7D/commit/%7Bnode%7D/statuses/build) in the Bitbucket API documentation. GitHub/GitHub Enterprise Server This parameter is used for the target_url parameter in the GitHub commit status. For more information, see [Create a commit status](https://developer.github.com/v3/repos/statuses/#create-a-commit-status) in the GitHub developer guide.
        public var targetUrl: Swift.String?

        public init (
            context: Swift.String? = nil,
            targetUrl: Swift.String? = nil
        )
        {
            self.context = context
            self.targetUrl = targetUrl
        }
    }

}

extension CodeBuildClientTypes.BuildSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case buildStatus
        case primaryArtifact
        case requestedOn
        case secondaryArtifacts
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let buildStatus = self.buildStatus {
            try encodeContainer.encode(buildStatus.rawValue, forKey: .buildStatus)
        }
        if let primaryArtifact = self.primaryArtifact {
            try encodeContainer.encode(primaryArtifact, forKey: .primaryArtifact)
        }
        if let requestedOn = self.requestedOn {
            try encodeContainer.encodeTimestamp(requestedOn, format: .epochSeconds, forKey: .requestedOn)
        }
        if let secondaryArtifacts = secondaryArtifacts {
            var secondaryArtifactsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondaryArtifacts)
            for resolvedartifact0 in secondaryArtifacts {
                try secondaryArtifactsContainer.encode(resolvedartifact0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let requestedOnDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .requestedOn)
        requestedOn = requestedOnDecoded
        let buildStatusDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.StatusType.self, forKey: .buildStatus)
        buildStatus = buildStatusDecoded
        let primaryArtifactDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ResolvedArtifact.self, forKey: .primaryArtifact)
        primaryArtifact = primaryArtifactDecoded
        let secondaryArtifactsContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.ResolvedArtifact?].self, forKey: .secondaryArtifacts)
        var secondaryArtifactsDecoded0:[CodeBuildClientTypes.ResolvedArtifact]? = nil
        if let secondaryArtifactsContainer = secondaryArtifactsContainer {
            secondaryArtifactsDecoded0 = [CodeBuildClientTypes.ResolvedArtifact]()
            for structure0 in secondaryArtifactsContainer {
                if let structure0 = structure0 {
                    secondaryArtifactsDecoded0?.append(structure0)
                }
            }
        }
        secondaryArtifacts = secondaryArtifactsDecoded0
    }
}

extension CodeBuildClientTypes {
    /// Contains summary information about a batch build group.
    public struct BuildSummary: Swift.Equatable {
        /// The batch build ARN.
        public var arn: Swift.String?
        /// The status of the build group. FAILED The build group failed. FAULT The build group faulted. IN_PROGRESS The build group is still in progress. STOPPED The build group stopped. SUCCEEDED The build group succeeded. TIMED_OUT The build group timed out.
        public var buildStatus: CodeBuildClientTypes.StatusType?
        /// A ResolvedArtifact object that represents the primary build artifacts for the build group.
        public var primaryArtifact: CodeBuildClientTypes.ResolvedArtifact?
        /// When the build was started, expressed in Unix time format.
        public var requestedOn: ClientRuntime.Date?
        /// An array of ResolvedArtifact objects that represents the secondary build artifacts for the build group.
        public var secondaryArtifacts: [CodeBuildClientTypes.ResolvedArtifact]?

        public init (
            arn: Swift.String? = nil,
            buildStatus: CodeBuildClientTypes.StatusType? = nil,
            primaryArtifact: CodeBuildClientTypes.ResolvedArtifact? = nil,
            requestedOn: ClientRuntime.Date? = nil,
            secondaryArtifacts: [CodeBuildClientTypes.ResolvedArtifact]? = nil
        )
        {
            self.arn = arn
            self.buildStatus = buildStatus
            self.primaryArtifact = primaryArtifact
            self.requestedOn = requestedOn
            self.secondaryArtifacts = secondaryArtifacts
        }
    }

}

extension CodeBuildClientTypes {
    public enum CacheMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case localCustomCache
        case localDockerLayerCache
        case localSourceCache
        case sdkUnknown(Swift.String)

        public static var allCases: [CacheMode] {
            return [
                .localCustomCache,
                .localDockerLayerCache,
                .localSourceCache,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .localCustomCache: return "LOCAL_CUSTOM_CACHE"
            case .localDockerLayerCache: return "LOCAL_DOCKER_LAYER_CACHE"
            case .localSourceCache: return "LOCAL_SOURCE_CACHE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CacheMode(rawValue: rawValue) ?? CacheMode.sdkUnknown(rawValue)
        }
    }
}

extension CodeBuildClientTypes {
    public enum CacheType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case local
        case noCache
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [CacheType] {
            return [
                .local,
                .noCache,
                .s3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .local: return "LOCAL"
            case .noCache: return "NO_CACHE"
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CacheType(rawValue: rawValue) ?? CacheType.sdkUnknown(rawValue)
        }
    }
}

extension CodeBuildClientTypes.CloudWatchLogsConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName
        case status
        case streamName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.LogsConfigStatusType.self, forKey: .status)
        status = statusDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
    }
}

extension CodeBuildClientTypes {
    /// Information about CloudWatch Logs for a build project.
    public struct CloudWatchLogsConfig: Swift.Equatable {
        /// The group name of the logs in CloudWatch Logs. For more information, see [Working with Log Groups and Log Streams](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html).
        public var groupName: Swift.String?
        /// The current status of the logs in CloudWatch Logs for a build project. Valid values are:
        ///
        /// * ENABLED: CloudWatch Logs are enabled for this build project.
        ///
        /// * DISABLED: CloudWatch Logs are not enabled for this build project.
        /// This member is required.
        public var status: CodeBuildClientTypes.LogsConfigStatusType?
        /// The prefix of the stream name of the CloudWatch Logs. For more information, see [Working with Log Groups and Log Streams](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html).
        public var streamName: Swift.String?

        public init (
            groupName: Swift.String? = nil,
            status: CodeBuildClientTypes.LogsConfigStatusType? = nil,
            streamName: Swift.String? = nil
        )
        {
            self.groupName = groupName
            self.status = status
            self.streamName = streamName
        }
    }

}

extension CodeBuildClientTypes.CodeCoverage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchCoveragePercentage
        case branchesCovered
        case branchesMissed
        case expired
        case filePath
        case id
        case lineCoveragePercentage
        case linesCovered
        case linesMissed
        case reportARN
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchCoveragePercentage = self.branchCoveragePercentage {
            try encodeContainer.encode(branchCoveragePercentage, forKey: .branchCoveragePercentage)
        }
        if let branchesCovered = self.branchesCovered {
            try encodeContainer.encode(branchesCovered, forKey: .branchesCovered)
        }
        if let branchesMissed = self.branchesMissed {
            try encodeContainer.encode(branchesMissed, forKey: .branchesMissed)
        }
        if let expired = self.expired {
            try encodeContainer.encodeTimestamp(expired, format: .epochSeconds, forKey: .expired)
        }
        if let filePath = self.filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lineCoveragePercentage = self.lineCoveragePercentage {
            try encodeContainer.encode(lineCoveragePercentage, forKey: .lineCoveragePercentage)
        }
        if let linesCovered = self.linesCovered {
            try encodeContainer.encode(linesCovered, forKey: .linesCovered)
        }
        if let linesMissed = self.linesMissed {
            try encodeContainer.encode(linesMissed, forKey: .linesMissed)
        }
        if let reportARN = self.reportARN {
            try encodeContainer.encode(reportARN, forKey: .reportARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let reportARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportARN)
        reportARN = reportARNDecoded
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
        let lineCoveragePercentageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .lineCoveragePercentage)
        lineCoveragePercentage = lineCoveragePercentageDecoded
        let linesCoveredDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .linesCovered)
        linesCovered = linesCoveredDecoded
        let linesMissedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .linesMissed)
        linesMissed = linesMissedDecoded
        let branchCoveragePercentageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .branchCoveragePercentage)
        branchCoveragePercentage = branchCoveragePercentageDecoded
        let branchesCoveredDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .branchesCovered)
        branchesCovered = branchesCoveredDecoded
        let branchesMissedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .branchesMissed)
        branchesMissed = branchesMissedDecoded
        let expiredDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expired)
        expired = expiredDecoded
    }
}

extension CodeBuildClientTypes {
    /// Contains code coverage report information. Line coverage measures how many statements your tests cover. A statement is a single instruction, not including comments, conditionals, etc. Branch coverage determines if your tests cover every possible branch of a control structure, such as an if or case statement.
    public struct CodeCoverage: Swift.Equatable {
        /// The percentage of branches that are covered by your tests.
        public var branchCoveragePercentage: Swift.Double?
        /// The number of conditional branches that are covered by your tests.
        public var branchesCovered: Swift.Int?
        /// The number of conditional branches that are not covered by your tests.
        public var branchesMissed: Swift.Int?
        /// The date and time that the tests were run.
        public var expired: ClientRuntime.Date?
        /// The path of the test report file.
        public var filePath: Swift.String?
        /// The identifier of the code coverage report.
        public var id: Swift.String?
        /// The percentage of lines that are covered by your tests.
        public var lineCoveragePercentage: Swift.Double?
        /// The number of lines that are covered by your tests.
        public var linesCovered: Swift.Int?
        /// The number of lines that are not covered by your tests.
        public var linesMissed: Swift.Int?
        /// The ARN of the report.
        public var reportARN: Swift.String?

        public init (
            branchCoveragePercentage: Swift.Double? = nil,
            branchesCovered: Swift.Int? = nil,
            branchesMissed: Swift.Int? = nil,
            expired: ClientRuntime.Date? = nil,
            filePath: Swift.String? = nil,
            id: Swift.String? = nil,
            lineCoveragePercentage: Swift.Double? = nil,
            linesCovered: Swift.Int? = nil,
            linesMissed: Swift.Int? = nil,
            reportARN: Swift.String? = nil
        )
        {
            self.branchCoveragePercentage = branchCoveragePercentage
            self.branchesCovered = branchesCovered
            self.branchesMissed = branchesMissed
            self.expired = expired
            self.filePath = filePath
            self.id = id
            self.lineCoveragePercentage = lineCoveragePercentage
            self.linesCovered = linesCovered
            self.linesMissed = linesMissed
            self.reportARN = reportARN
        }
    }

}

extension CodeBuildClientTypes.CodeCoverageReportSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchCoveragePercentage
        case branchesCovered
        case branchesMissed
        case lineCoveragePercentage
        case linesCovered
        case linesMissed
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchCoveragePercentage = self.branchCoveragePercentage {
            try encodeContainer.encode(branchCoveragePercentage, forKey: .branchCoveragePercentage)
        }
        if let branchesCovered = self.branchesCovered {
            try encodeContainer.encode(branchesCovered, forKey: .branchesCovered)
        }
        if let branchesMissed = self.branchesMissed {
            try encodeContainer.encode(branchesMissed, forKey: .branchesMissed)
        }
        if let lineCoveragePercentage = self.lineCoveragePercentage {
            try encodeContainer.encode(lineCoveragePercentage, forKey: .lineCoveragePercentage)
        }
        if let linesCovered = self.linesCovered {
            try encodeContainer.encode(linesCovered, forKey: .linesCovered)
        }
        if let linesMissed = self.linesMissed {
            try encodeContainer.encode(linesMissed, forKey: .linesMissed)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lineCoveragePercentageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .lineCoveragePercentage)
        lineCoveragePercentage = lineCoveragePercentageDecoded
        let linesCoveredDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .linesCovered)
        linesCovered = linesCoveredDecoded
        let linesMissedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .linesMissed)
        linesMissed = linesMissedDecoded
        let branchCoveragePercentageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .branchCoveragePercentage)
        branchCoveragePercentage = branchCoveragePercentageDecoded
        let branchesCoveredDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .branchesCovered)
        branchesCovered = branchesCoveredDecoded
        let branchesMissedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .branchesMissed)
        branchesMissed = branchesMissedDecoded
    }
}

extension CodeBuildClientTypes {
    /// Contains a summary of a code coverage report. Line coverage measures how many statements your tests cover. A statement is a single instruction, not including comments, conditionals, etc. Branch coverage determines if your tests cover every possible branch of a control structure, such as an if or case statement.
    public struct CodeCoverageReportSummary: Swift.Equatable {
        /// The percentage of branches that are covered by your tests.
        public var branchCoveragePercentage: Swift.Double?
        /// The number of conditional branches that are covered by your tests.
        public var branchesCovered: Swift.Int?
        /// The number of conditional branches that are not covered by your tests.
        public var branchesMissed: Swift.Int?
        /// The percentage of lines that are covered by your tests.
        public var lineCoveragePercentage: Swift.Double?
        /// The number of lines that are covered by your tests.
        public var linesCovered: Swift.Int?
        /// The number of lines that are not covered by your tests.
        public var linesMissed: Swift.Int?

        public init (
            branchCoveragePercentage: Swift.Double? = nil,
            branchesCovered: Swift.Int? = nil,
            branchesMissed: Swift.Int? = nil,
            lineCoveragePercentage: Swift.Double? = nil,
            linesCovered: Swift.Int? = nil,
            linesMissed: Swift.Int? = nil
        )
        {
            self.branchCoveragePercentage = branchCoveragePercentage
            self.branchesCovered = branchesCovered
            self.branchesMissed = branchesMissed
            self.lineCoveragePercentage = lineCoveragePercentage
            self.linesCovered = linesCovered
            self.linesMissed = linesMissed
        }
    }

}

extension CodeBuildClientTypes {
    public enum ComputeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case buildGeneral12xlarge
        case buildGeneral1Large
        case buildGeneral1Medium
        case buildGeneral1Small
        case sdkUnknown(Swift.String)

        public static var allCases: [ComputeType] {
            return [
                .buildGeneral12xlarge,
                .buildGeneral1Large,
                .buildGeneral1Medium,
                .buildGeneral1Small,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .buildGeneral12xlarge: return "BUILD_GENERAL1_2XLARGE"
            case .buildGeneral1Large: return "BUILD_GENERAL1_LARGE"
            case .buildGeneral1Medium: return "BUILD_GENERAL1_MEDIUM"
            case .buildGeneral1Small: return "BUILD_GENERAL1_SMALL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComputeType(rawValue: rawValue) ?? ComputeType.sdkUnknown(rawValue)
        }
    }
}

extension CreateProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifacts
        case badgeEnabled
        case buildBatchConfig
        case cache
        case concurrentBuildLimit
        case description
        case encryptionKey
        case environment
        case fileSystemLocations
        case logsConfig
        case name
        case queuedTimeoutInMinutes
        case secondaryArtifacts
        case secondarySourceVersions
        case secondarySources
        case serviceRole
        case source
        case sourceVersion
        case tags
        case timeoutInMinutes
        case vpcConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifacts = self.artifacts {
            try encodeContainer.encode(artifacts, forKey: .artifacts)
        }
        if let badgeEnabled = self.badgeEnabled {
            try encodeContainer.encode(badgeEnabled, forKey: .badgeEnabled)
        }
        if let buildBatchConfig = self.buildBatchConfig {
            try encodeContainer.encode(buildBatchConfig, forKey: .buildBatchConfig)
        }
        if let cache = self.cache {
            try encodeContainer.encode(cache, forKey: .cache)
        }
        if let concurrentBuildLimit = self.concurrentBuildLimit {
            try encodeContainer.encode(concurrentBuildLimit, forKey: .concurrentBuildLimit)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encryptionKey = self.encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let environment = self.environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let fileSystemLocations = fileSystemLocations {
            var fileSystemLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileSystemLocations)
            for projectfilesystemlocation0 in fileSystemLocations {
                try fileSystemLocationsContainer.encode(projectfilesystemlocation0)
            }
        }
        if let logsConfig = self.logsConfig {
            try encodeContainer.encode(logsConfig, forKey: .logsConfig)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let queuedTimeoutInMinutes = self.queuedTimeoutInMinutes {
            try encodeContainer.encode(queuedTimeoutInMinutes, forKey: .queuedTimeoutInMinutes)
        }
        if let secondaryArtifacts = secondaryArtifacts {
            var secondaryArtifactsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondaryArtifacts)
            for projectartifacts0 in secondaryArtifacts {
                try secondaryArtifactsContainer.encode(projectartifacts0)
            }
        }
        if let secondarySourceVersions = secondarySourceVersions {
            var secondarySourceVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondarySourceVersions)
            for projectsourceversion0 in secondarySourceVersions {
                try secondarySourceVersionsContainer.encode(projectsourceversion0)
            }
        }
        if let secondarySources = secondarySources {
            var secondarySourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondarySources)
            for projectsource0 in secondarySources {
                try secondarySourcesContainer.encode(projectsource0)
            }
        }
        if let serviceRole = self.serviceRole {
            try encodeContainer.encode(serviceRole, forKey: .serviceRole)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let sourceVersion = self.sourceVersion {
            try encodeContainer.encode(sourceVersion, forKey: .sourceVersion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let timeoutInMinutes = self.timeoutInMinutes {
            try encodeContainer.encode(timeoutInMinutes, forKey: .timeoutInMinutes)
        }
        if let vpcConfig = self.vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

extension CreateProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateProjectInput: Swift.Equatable {
    /// Information about the build output artifacts for the build project.
    /// This member is required.
    public var artifacts: CodeBuildClientTypes.ProjectArtifacts?
    /// Set this to true to generate a publicly accessible URL for your project's build badge.
    public var badgeEnabled: Swift.Bool?
    /// A [ProjectBuildBatchConfig] object that defines the batch build options for the project.
    public var buildBatchConfig: CodeBuildClientTypes.ProjectBuildBatchConfig?
    /// Stores recently used information so that it can be quickly accessed at a later time.
    public var cache: CodeBuildClientTypes.ProjectCache?
    /// The maximum number of concurrent builds that are allowed for this project. New builds are only started if the current number of builds is less than or equal to this limit. If the current build count meets this limit, new builds are throttled and are not run.
    public var concurrentBuildLimit: Swift.Int?
    /// A description that makes the build project easy to identify.
    public var description: Swift.String?
    /// The Key Management Service customer master key (CMK) to be used for encrypting the build output artifacts. You can use a cross-account KMS key to encrypt the build output artifacts if your service role has permission to that key. You can specify either the Amazon Resource Name (ARN) of the CMK or, if available, the CMK's alias (using the format alias/).
    public var encryptionKey: Swift.String?
    /// Information about the build environment for the build project.
    /// This member is required.
    public var environment: CodeBuildClientTypes.ProjectEnvironment?
    /// An array of ProjectFileSystemLocation objects for a CodeBuild build project. A ProjectFileSystemLocation object specifies the identifier, location, mountOptions, mountPoint, and type of a file system created using Amazon Elastic File System.
    public var fileSystemLocations: [CodeBuildClientTypes.ProjectFileSystemLocation]?
    /// Information about logs for the build project. These can be logs in CloudWatch Logs, logs uploaded to a specified S3 bucket, or both.
    public var logsConfig: CodeBuildClientTypes.LogsConfig?
    /// The name of the build project.
    /// This member is required.
    public var name: Swift.String?
    /// The number of minutes a build is allowed to be queued before it times out.
    public var queuedTimeoutInMinutes: Swift.Int?
    /// An array of ProjectArtifacts objects.
    public var secondaryArtifacts: [CodeBuildClientTypes.ProjectArtifacts]?
    /// An array of ProjectSourceVersion objects. If secondarySourceVersions is specified at the build level, then they take precedence over these secondarySourceVersions (at the project level).
    public var secondarySourceVersions: [CodeBuildClientTypes.ProjectSourceVersion]?
    /// An array of ProjectSource objects.
    public var secondarySources: [CodeBuildClientTypes.ProjectSource]?
    /// The ARN of the IAM role that enables CodeBuild to interact with dependent Amazon Web Services services on behalf of the Amazon Web Services account.
    /// This member is required.
    public var serviceRole: Swift.String?
    /// Information about the build input source code for the build project.
    /// This member is required.
    public var source: CodeBuildClientTypes.ProjectSource?
    /// A version of the build input to be built for this project. If not specified, the latest version is used. If specified, it must be one of:
    ///
    /// * For CodeCommit: the commit ID, branch, or Git tag to use.
    ///
    /// * For GitHub: the commit ID, pull request ID, branch name, or tag name that corresponds to the version of the source code you want to build. If a pull request ID is specified, it must use the format pr/pull-request-ID (for example pr/25). If a branch name is specified, the branch's HEAD commit ID is used. If not specified, the default branch's HEAD commit ID is used.
    ///
    /// * For Bitbucket: the commit ID, branch name, or tag name that corresponds to the version of the source code you want to build. If a branch name is specified, the branch's HEAD commit ID is used. If not specified, the default branch's HEAD commit ID is used.
    ///
    /// * For Amazon S3: the version ID of the object that represents the build input ZIP file to use.
    ///
    ///
    /// If sourceVersion is specified at the build level, then that version takes precedence over this sourceVersion (at the project level). For more information, see [Source Version Sample with CodeBuild](https://docs.aws.amazon.com/codebuild/latest/userguide/sample-source-version.html) in the CodeBuild User Guide.
    public var sourceVersion: Swift.String?
    /// A list of tag key and value pairs associated with this build project. These tags are available for use by Amazon Web Services services that support CodeBuild build project tags.
    public var tags: [CodeBuildClientTypes.Tag]?
    /// How long, in minutes, from 5 to 480 (8 hours), for CodeBuild to wait before it times out any build that has not been marked as completed. The default is 60 minutes.
    public var timeoutInMinutes: Swift.Int?
    /// VpcConfig enables CodeBuild to access resources in an Amazon VPC.
    public var vpcConfig: CodeBuildClientTypes.VpcConfig?

    public init (
        artifacts: CodeBuildClientTypes.ProjectArtifacts? = nil,
        badgeEnabled: Swift.Bool? = nil,
        buildBatchConfig: CodeBuildClientTypes.ProjectBuildBatchConfig? = nil,
        cache: CodeBuildClientTypes.ProjectCache? = nil,
        concurrentBuildLimit: Swift.Int? = nil,
        description: Swift.String? = nil,
        encryptionKey: Swift.String? = nil,
        environment: CodeBuildClientTypes.ProjectEnvironment? = nil,
        fileSystemLocations: [CodeBuildClientTypes.ProjectFileSystemLocation]? = nil,
        logsConfig: CodeBuildClientTypes.LogsConfig? = nil,
        name: Swift.String? = nil,
        queuedTimeoutInMinutes: Swift.Int? = nil,
        secondaryArtifacts: [CodeBuildClientTypes.ProjectArtifacts]? = nil,
        secondarySourceVersions: [CodeBuildClientTypes.ProjectSourceVersion]? = nil,
        secondarySources: [CodeBuildClientTypes.ProjectSource]? = nil,
        serviceRole: Swift.String? = nil,
        source: CodeBuildClientTypes.ProjectSource? = nil,
        sourceVersion: Swift.String? = nil,
        tags: [CodeBuildClientTypes.Tag]? = nil,
        timeoutInMinutes: Swift.Int? = nil,
        vpcConfig: CodeBuildClientTypes.VpcConfig? = nil
    )
    {
        self.artifacts = artifacts
        self.badgeEnabled = badgeEnabled
        self.buildBatchConfig = buildBatchConfig
        self.cache = cache
        self.concurrentBuildLimit = concurrentBuildLimit
        self.description = description
        self.encryptionKey = encryptionKey
        self.environment = environment
        self.fileSystemLocations = fileSystemLocations
        self.logsConfig = logsConfig
        self.name = name
        self.queuedTimeoutInMinutes = queuedTimeoutInMinutes
        self.secondaryArtifacts = secondaryArtifacts
        self.secondarySourceVersions = secondarySourceVersions
        self.secondarySources = secondarySources
        self.serviceRole = serviceRole
        self.source = source
        self.sourceVersion = sourceVersion
        self.tags = tags
        self.timeoutInMinutes = timeoutInMinutes
        self.vpcConfig = vpcConfig
    }
}

struct CreateProjectInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let source: CodeBuildClientTypes.ProjectSource?
    let secondarySources: [CodeBuildClientTypes.ProjectSource]?
    let sourceVersion: Swift.String?
    let secondarySourceVersions: [CodeBuildClientTypes.ProjectSourceVersion]?
    let artifacts: CodeBuildClientTypes.ProjectArtifacts?
    let secondaryArtifacts: [CodeBuildClientTypes.ProjectArtifacts]?
    let cache: CodeBuildClientTypes.ProjectCache?
    let environment: CodeBuildClientTypes.ProjectEnvironment?
    let serviceRole: Swift.String?
    let timeoutInMinutes: Swift.Int?
    let queuedTimeoutInMinutes: Swift.Int?
    let encryptionKey: Swift.String?
    let tags: [CodeBuildClientTypes.Tag]?
    let vpcConfig: CodeBuildClientTypes.VpcConfig?
    let badgeEnabled: Swift.Bool?
    let logsConfig: CodeBuildClientTypes.LogsConfig?
    let fileSystemLocations: [CodeBuildClientTypes.ProjectFileSystemLocation]?
    let buildBatchConfig: CodeBuildClientTypes.ProjectBuildBatchConfig?
    let concurrentBuildLimit: Swift.Int?
}

extension CreateProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifacts
        case badgeEnabled
        case buildBatchConfig
        case cache
        case concurrentBuildLimit
        case description
        case encryptionKey
        case environment
        case fileSystemLocations
        case logsConfig
        case name
        case queuedTimeoutInMinutes
        case secondaryArtifacts
        case secondarySourceVersions
        case secondarySources
        case serviceRole
        case source
        case sourceVersion
        case tags
        case timeoutInMinutes
        case vpcConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ProjectSource.self, forKey: .source)
        source = sourceDecoded
        let secondarySourcesContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.ProjectSource?].self, forKey: .secondarySources)
        var secondarySourcesDecoded0:[CodeBuildClientTypes.ProjectSource]? = nil
        if let secondarySourcesContainer = secondarySourcesContainer {
            secondarySourcesDecoded0 = [CodeBuildClientTypes.ProjectSource]()
            for structure0 in secondarySourcesContainer {
                if let structure0 = structure0 {
                    secondarySourcesDecoded0?.append(structure0)
                }
            }
        }
        secondarySources = secondarySourcesDecoded0
        let sourceVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceVersion)
        sourceVersion = sourceVersionDecoded
        let secondarySourceVersionsContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.ProjectSourceVersion?].self, forKey: .secondarySourceVersions)
        var secondarySourceVersionsDecoded0:[CodeBuildClientTypes.ProjectSourceVersion]? = nil
        if let secondarySourceVersionsContainer = secondarySourceVersionsContainer {
            secondarySourceVersionsDecoded0 = [CodeBuildClientTypes.ProjectSourceVersion]()
            for structure0 in secondarySourceVersionsContainer {
                if let structure0 = structure0 {
                    secondarySourceVersionsDecoded0?.append(structure0)
                }
            }
        }
        secondarySourceVersions = secondarySourceVersionsDecoded0
        let artifactsDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ProjectArtifacts.self, forKey: .artifacts)
        artifacts = artifactsDecoded
        let secondaryArtifactsContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.ProjectArtifacts?].self, forKey: .secondaryArtifacts)
        var secondaryArtifactsDecoded0:[CodeBuildClientTypes.ProjectArtifacts]? = nil
        if let secondaryArtifactsContainer = secondaryArtifactsContainer {
            secondaryArtifactsDecoded0 = [CodeBuildClientTypes.ProjectArtifacts]()
            for structure0 in secondaryArtifactsContainer {
                if let structure0 = structure0 {
                    secondaryArtifactsDecoded0?.append(structure0)
                }
            }
        }
        secondaryArtifacts = secondaryArtifactsDecoded0
        let cacheDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ProjectCache.self, forKey: .cache)
        cache = cacheDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ProjectEnvironment.self, forKey: .environment)
        environment = environmentDecoded
        let serviceRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRole)
        serviceRole = serviceRoleDecoded
        let timeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutInMinutes)
        timeoutInMinutes = timeoutInMinutesDecoded
        let queuedTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .queuedTimeoutInMinutes)
        queuedTimeoutInMinutes = queuedTimeoutInMinutesDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[CodeBuildClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [CodeBuildClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let vpcConfigDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let badgeEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .badgeEnabled)
        badgeEnabled = badgeEnabledDecoded
        let logsConfigDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.LogsConfig.self, forKey: .logsConfig)
        logsConfig = logsConfigDecoded
        let fileSystemLocationsContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.ProjectFileSystemLocation?].self, forKey: .fileSystemLocations)
        var fileSystemLocationsDecoded0:[CodeBuildClientTypes.ProjectFileSystemLocation]? = nil
        if let fileSystemLocationsContainer = fileSystemLocationsContainer {
            fileSystemLocationsDecoded0 = [CodeBuildClientTypes.ProjectFileSystemLocation]()
            for structure0 in fileSystemLocationsContainer {
                if let structure0 = structure0 {
                    fileSystemLocationsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemLocations = fileSystemLocationsDecoded0
        let buildBatchConfigDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ProjectBuildBatchConfig.self, forKey: .buildBatchConfig)
        buildBatchConfig = buildBatchConfigDecoded
        let concurrentBuildLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .concurrentBuildLimit)
        concurrentBuildLimit = concurrentBuildLimitDecoded
    }
}

extension CreateProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccountLimitExceededException" : self = .accountLimitExceededException(try AccountLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateProjectOutputError: Swift.Error, Swift.Equatable {
    case accountLimitExceededException(AccountLimitExceededException)
    case invalidInputException(InvalidInputException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.project = output.project
        } else {
            self.project = nil
        }
    }
}

public struct CreateProjectOutputResponse: Swift.Equatable {
    /// Information about the build project that was created.
    public var project: CodeBuildClientTypes.Project?

    public init (
        project: CodeBuildClientTypes.Project? = nil
    )
    {
        self.project = project
    }
}

struct CreateProjectOutputResponseBody: Swift.Equatable {
    let project: CodeBuildClientTypes.Project?
}

extension CreateProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case project
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.Project.self, forKey: .project)
        project = projectDecoded
    }
}

extension CreateReportGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportConfig
        case name
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exportConfig = self.exportConfig {
            try encodeContainer.encode(exportConfig, forKey: .exportConfig)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateReportGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateReportGroupInput: Swift.Equatable {
    /// A ReportExportConfig object that contains information about where the report group test results are exported.
    /// This member is required.
    public var exportConfig: CodeBuildClientTypes.ReportExportConfig?
    /// The name of the report group.
    /// This member is required.
    public var name: Swift.String?
    /// A list of tag key and value pairs associated with this report group. These tags are available for use by Amazon Web Services services that support CodeBuild report group tags.
    public var tags: [CodeBuildClientTypes.Tag]?
    /// The type of report group.
    /// This member is required.
    public var type: CodeBuildClientTypes.ReportType?

    public init (
        exportConfig: CodeBuildClientTypes.ReportExportConfig? = nil,
        name: Swift.String? = nil,
        tags: [CodeBuildClientTypes.Tag]? = nil,
        type: CodeBuildClientTypes.ReportType? = nil
    )
    {
        self.exportConfig = exportConfig
        self.name = name
        self.tags = tags
        self.type = type
    }
}

struct CreateReportGroupInputBody: Swift.Equatable {
    let name: Swift.String?
    let type: CodeBuildClientTypes.ReportType?
    let exportConfig: CodeBuildClientTypes.ReportExportConfig?
    let tags: [CodeBuildClientTypes.Tag]?
}

extension CreateReportGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportConfig
        case name
        case tags
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ReportType.self, forKey: .type)
        type = typeDecoded
        let exportConfigDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ReportExportConfig.self, forKey: .exportConfig)
        exportConfig = exportConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[CodeBuildClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [CodeBuildClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateReportGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateReportGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccountLimitExceededException" : self = .accountLimitExceededException(try AccountLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateReportGroupOutputError: Swift.Error, Swift.Equatable {
    case accountLimitExceededException(AccountLimitExceededException)
    case invalidInputException(InvalidInputException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateReportGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateReportGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.reportGroup = output.reportGroup
        } else {
            self.reportGroup = nil
        }
    }
}

public struct CreateReportGroupOutputResponse: Swift.Equatable {
    /// Information about the report group that was created.
    public var reportGroup: CodeBuildClientTypes.ReportGroup?

    public init (
        reportGroup: CodeBuildClientTypes.ReportGroup? = nil
    )
    {
        self.reportGroup = reportGroup
    }
}

struct CreateReportGroupOutputResponseBody: Swift.Equatable {
    let reportGroup: CodeBuildClientTypes.ReportGroup?
}

extension CreateReportGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportGroup
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportGroupDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ReportGroup.self, forKey: .reportGroup)
        reportGroup = reportGroupDecoded
    }
}

extension CreateWebhookInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchFilter
        case buildType
        case filterGroups
        case projectName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchFilter = self.branchFilter {
            try encodeContainer.encode(branchFilter, forKey: .branchFilter)
        }
        if let buildType = self.buildType {
            try encodeContainer.encode(buildType.rawValue, forKey: .buildType)
        }
        if let filterGroups = filterGroups {
            var filterGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterGroups)
            for filtergroup0 in filterGroups {
                var filtergroup0Container = filterGroupsContainer.nestedUnkeyedContainer()
                for webhookfilter1 in filtergroup0 {
                    try filtergroup0Container.encode(webhookfilter1)
                }
            }
        }
        if let projectName = self.projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
    }
}

extension CreateWebhookInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateWebhookInput: Swift.Equatable {
    /// A regular expression used to determine which repository branches are built when a webhook is triggered. If the name of a branch matches the regular expression, then it is built. If branchFilter is empty, then all branches are built. It is recommended that you use filterGroups instead of branchFilter.
    public var branchFilter: Swift.String?
    /// Specifies the type of build this webhook will trigger.
    public var buildType: CodeBuildClientTypes.WebhookBuildType?
    /// An array of arrays of WebhookFilter objects used to determine which webhooks are triggered. At least one WebhookFilter in the array must specify EVENT as its type. For a build to be triggered, at least one filter group in the filterGroups array must pass. For a filter group to pass, each of its filters must pass.
    public var filterGroups: [[CodeBuildClientTypes.WebhookFilter]]?
    /// The name of the CodeBuild project.
    /// This member is required.
    public var projectName: Swift.String?

    public init (
        branchFilter: Swift.String? = nil,
        buildType: CodeBuildClientTypes.WebhookBuildType? = nil,
        filterGroups: [[CodeBuildClientTypes.WebhookFilter]]? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.branchFilter = branchFilter
        self.buildType = buildType
        self.filterGroups = filterGroups
        self.projectName = projectName
    }
}

struct CreateWebhookInputBody: Swift.Equatable {
    let projectName: Swift.String?
    let branchFilter: Swift.String?
    let filterGroups: [[CodeBuildClientTypes.WebhookFilter]]?
    let buildType: CodeBuildClientTypes.WebhookBuildType?
}

extension CreateWebhookInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchFilter
        case buildType
        case filterGroups
        case projectName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let branchFilterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branchFilter)
        branchFilter = branchFilterDecoded
        let filterGroupsContainer = try containerValues.decodeIfPresent([[CodeBuildClientTypes.WebhookFilter?]?].self, forKey: .filterGroups)
        var filterGroupsDecoded0:[[CodeBuildClientTypes.WebhookFilter]]? = nil
        if let filterGroupsContainer = filterGroupsContainer {
            filterGroupsDecoded0 = [[CodeBuildClientTypes.WebhookFilter]]()
            for list0 in filterGroupsContainer {
                var list0Decoded0: [CodeBuildClientTypes.WebhookFilter]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [CodeBuildClientTypes.WebhookFilter]()
                    for structure1 in list0 {
                        if let structure1 = structure1 {
                            list0Decoded0?.append(structure1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    filterGroupsDecoded0?.append(list0Decoded0)
                }
            }
        }
        filterGroups = filterGroupsDecoded0
        let buildTypeDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.WebhookBuildType.self, forKey: .buildType)
        buildType = buildTypeDecoded
    }
}

extension CreateWebhookOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWebhookOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OAuthProviderException" : self = .oAuthProviderException(try OAuthProviderException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateWebhookOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case oAuthProviderException(OAuthProviderException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWebhookOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateWebhookOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.webhook = output.webhook
        } else {
            self.webhook = nil
        }
    }
}

public struct CreateWebhookOutputResponse: Swift.Equatable {
    /// Information about a webhook that connects repository events to a build project in CodeBuild.
    public var webhook: CodeBuildClientTypes.Webhook?

    public init (
        webhook: CodeBuildClientTypes.Webhook? = nil
    )
    {
        self.webhook = webhook
    }
}

struct CreateWebhookOutputResponseBody: Swift.Equatable {
    let webhook: CodeBuildClientTypes.Webhook?
}

extension CreateWebhookOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case webhook
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webhookDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.Webhook.self, forKey: .webhook)
        webhook = webhookDecoded
    }
}

extension CodeBuildClientTypes {
    public enum CredentialProviderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case secretsManager
        case sdkUnknown(Swift.String)

        public static var allCases: [CredentialProviderType] {
            return [
                .secretsManager,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .secretsManager: return "SECRETS_MANAGER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CredentialProviderType(rawValue: rawValue) ?? CredentialProviderType.sdkUnknown(rawValue)
        }
    }
}

extension CodeBuildClientTypes.DebugSession: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionEnabled
        case sessionTarget
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sessionEnabled = self.sessionEnabled {
            try encodeContainer.encode(sessionEnabled, forKey: .sessionEnabled)
        }
        if let sessionTarget = self.sessionTarget {
            try encodeContainer.encode(sessionTarget, forKey: .sessionTarget)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sessionEnabled)
        sessionEnabled = sessionEnabledDecoded
        let sessionTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionTarget)
        sessionTarget = sessionTargetDecoded
    }
}

extension CodeBuildClientTypes {
    /// Contains information about the debug session for a build. For more information, see [Viewing a running build in Session Manager](https://docs.aws.amazon.com/codebuild/latest/userguide/session-manager.html).
    public struct DebugSession: Swift.Equatable {
        /// Specifies if session debugging is enabled for this build.
        public var sessionEnabled: Swift.Bool?
        /// Contains the identifier of the Session Manager session used for the build. To work with the paused build, you open this session to examine, control, and resume the build.
        public var sessionTarget: Swift.String?

        public init (
            sessionEnabled: Swift.Bool? = nil,
            sessionTarget: Swift.String? = nil
        )
        {
            self.sessionEnabled = sessionEnabled
            self.sessionTarget = sessionTarget
        }
    }

}

extension DeleteBuildBatchInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DeleteBuildBatchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteBuildBatchInput: Swift.Equatable {
    /// The identifier of the batch build to delete.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteBuildBatchInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension DeleteBuildBatchInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteBuildBatchOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBuildBatchOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteBuildBatchOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBuildBatchOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteBuildBatchOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.buildsDeleted = output.buildsDeleted
            self.buildsNotDeleted = output.buildsNotDeleted
            self.statusCode = output.statusCode
        } else {
            self.buildsDeleted = nil
            self.buildsNotDeleted = nil
            self.statusCode = nil
        }
    }
}

public struct DeleteBuildBatchOutputResponse: Swift.Equatable {
    /// An array of strings that contain the identifiers of the builds that were deleted.
    public var buildsDeleted: [Swift.String]?
    /// An array of BuildNotDeleted objects that specify the builds that could not be deleted.
    public var buildsNotDeleted: [CodeBuildClientTypes.BuildNotDeleted]?
    /// The status code.
    public var statusCode: Swift.String?

    public init (
        buildsDeleted: [Swift.String]? = nil,
        buildsNotDeleted: [CodeBuildClientTypes.BuildNotDeleted]? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.buildsDeleted = buildsDeleted
        self.buildsNotDeleted = buildsNotDeleted
        self.statusCode = statusCode
    }
}

struct DeleteBuildBatchOutputResponseBody: Swift.Equatable {
    let statusCode: Swift.String?
    let buildsDeleted: [Swift.String]?
    let buildsNotDeleted: [CodeBuildClientTypes.BuildNotDeleted]?
}

extension DeleteBuildBatchOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case buildsDeleted
        case buildsNotDeleted
        case statusCode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let buildsDeletedContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .buildsDeleted)
        var buildsDeletedDecoded0:[Swift.String]? = nil
        if let buildsDeletedContainer = buildsDeletedContainer {
            buildsDeletedDecoded0 = [Swift.String]()
            for string0 in buildsDeletedContainer {
                if let string0 = string0 {
                    buildsDeletedDecoded0?.append(string0)
                }
            }
        }
        buildsDeleted = buildsDeletedDecoded0
        let buildsNotDeletedContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.BuildNotDeleted?].self, forKey: .buildsNotDeleted)
        var buildsNotDeletedDecoded0:[CodeBuildClientTypes.BuildNotDeleted]? = nil
        if let buildsNotDeletedContainer = buildsNotDeletedContainer {
            buildsNotDeletedDecoded0 = [CodeBuildClientTypes.BuildNotDeleted]()
            for structure0 in buildsNotDeletedContainer {
                if let structure0 = structure0 {
                    buildsNotDeletedDecoded0?.append(structure0)
                }
            }
        }
        buildsNotDeleted = buildsNotDeletedDecoded0
    }
}

extension DeleteProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeleteProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteProjectInput: Swift.Equatable {
    /// The name of the build project.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteProjectInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteProjectOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteProjectOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteReportGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case deleteReports
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if deleteReports != false {
            try encodeContainer.encode(deleteReports, forKey: .deleteReports)
        }
    }
}

extension DeleteReportGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteReportGroupInput: Swift.Equatable {
    /// The ARN of the report group to delete.
    /// This member is required.
    public var arn: Swift.String?
    /// If true, deletes any reports that belong to a report group before deleting the report group. If false, you must delete any reports in the report group. Use [ListReportsForReportGroup](https://docs.aws.amazon.com/codebuild/latest/APIReference/API_ListReportsForReportGroup.html) to get the reports in a report group. Use [DeleteReport](https://docs.aws.amazon.com/codebuild/latest/APIReference/API_DeleteReport.html) to delete the reports. If you call DeleteReportGroup for a report group that contains one or more reports, an exception is thrown.
    public var deleteReports: Swift.Bool

    public init (
        arn: Swift.String? = nil,
        deleteReports: Swift.Bool = false
    )
    {
        self.arn = arn
        self.deleteReports = deleteReports
    }
}

struct DeleteReportGroupInputBody: Swift.Equatable {
    let arn: Swift.String?
    let deleteReports: Swift.Bool
}

extension DeleteReportGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case deleteReports
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let deleteReportsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleteReports) ?? false
        deleteReports = deleteReportsDecoded
    }
}

extension DeleteReportGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteReportGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteReportGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteReportGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteReportGroupOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteReportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension DeleteReportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteReportInput: Swift.Equatable {
    /// The ARN of the report to delete.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteReportInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeleteReportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteReportOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteReportOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteReportOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteReportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteReportOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteResourcePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension DeleteResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteResourcePolicyInput: Swift.Equatable {
    /// The ARN of the resource that is associated with the resource policy.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct DeleteResourcePolicyInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension DeleteResourcePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension DeleteResourcePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourcePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteResourcePolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourcePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteResourcePolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteSourceCredentialsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension DeleteSourceCredentialsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteSourceCredentialsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the token.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteSourceCredentialsInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeleteSourceCredentialsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteSourceCredentialsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSourceCredentialsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSourceCredentialsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSourceCredentialsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteSourceCredentialsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct DeleteSourceCredentialsOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the token.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteSourceCredentialsOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeleteSourceCredentialsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteWebhookInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let projectName = self.projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
    }
}

extension DeleteWebhookInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteWebhookInput: Swift.Equatable {
    /// The name of the CodeBuild project.
    /// This member is required.
    public var projectName: Swift.String?

    public init (
        projectName: Swift.String? = nil
    )
    {
        self.projectName = projectName
    }
}

struct DeleteWebhookInputBody: Swift.Equatable {
    let projectName: Swift.String?
}

extension DeleteWebhookInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
    }
}

extension DeleteWebhookOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWebhookOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OAuthProviderException" : self = .oAuthProviderException(try OAuthProviderException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteWebhookOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case oAuthProviderException(OAuthProviderException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWebhookOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWebhookOutputResponse: Swift.Equatable {

    public init () { }
}

extension DescribeCodeCoveragesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxLineCoveragePercentage
        case maxResults
        case minLineCoveragePercentage
        case nextToken
        case reportArn
        case sortBy
        case sortOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxLineCoveragePercentage = self.maxLineCoveragePercentage {
            try encodeContainer.encode(maxLineCoveragePercentage, forKey: .maxLineCoveragePercentage)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let minLineCoveragePercentage = self.minLineCoveragePercentage {
            try encodeContainer.encode(minLineCoveragePercentage, forKey: .minLineCoveragePercentage)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let reportArn = self.reportArn {
            try encodeContainer.encode(reportArn, forKey: .reportArn)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

extension DescribeCodeCoveragesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeCodeCoveragesInput: Swift.Equatable {
    /// The maximum line coverage percentage to report.
    public var maxLineCoveragePercentage: Swift.Double?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The minimum line coverage percentage to report.
    public var minLineCoveragePercentage: Swift.Double?
    /// The nextToken value returned from a previous call to DescribeCodeCoverages. This specifies the next item to return. To return the beginning of the list, exclude this parameter.
    public var nextToken: Swift.String?
    /// The ARN of the report for which test cases are returned.
    /// This member is required.
    public var reportArn: Swift.String?
    /// Specifies how the results are sorted. Possible values are: FILE_PATH The results are sorted by file path. LINE_COVERAGE_PERCENTAGE The results are sorted by the percentage of lines that are covered.
    public var sortBy: CodeBuildClientTypes.ReportCodeCoverageSortByType?
    /// Specifies if the results are sorted in ascending or descending order.
    public var sortOrder: CodeBuildClientTypes.SortOrderType?

    public init (
        maxLineCoveragePercentage: Swift.Double? = nil,
        maxResults: Swift.Int? = nil,
        minLineCoveragePercentage: Swift.Double? = nil,
        nextToken: Swift.String? = nil,
        reportArn: Swift.String? = nil,
        sortBy: CodeBuildClientTypes.ReportCodeCoverageSortByType? = nil,
        sortOrder: CodeBuildClientTypes.SortOrderType? = nil
    )
    {
        self.maxLineCoveragePercentage = maxLineCoveragePercentage
        self.maxResults = maxResults
        self.minLineCoveragePercentage = minLineCoveragePercentage
        self.nextToken = nextToken
        self.reportArn = reportArn
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

struct DescribeCodeCoveragesInputBody: Swift.Equatable {
    let reportArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let sortOrder: CodeBuildClientTypes.SortOrderType?
    let sortBy: CodeBuildClientTypes.ReportCodeCoverageSortByType?
    let minLineCoveragePercentage: Swift.Double?
    let maxLineCoveragePercentage: Swift.Double?
}

extension DescribeCodeCoveragesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxLineCoveragePercentage
        case maxResults
        case minLineCoveragePercentage
        case nextToken
        case reportArn
        case sortBy
        case sortOrder
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportArn)
        reportArn = reportArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.SortOrderType.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ReportCodeCoverageSortByType.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let minLineCoveragePercentageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .minLineCoveragePercentage)
        minLineCoveragePercentage = minLineCoveragePercentageDecoded
        let maxLineCoveragePercentageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .maxLineCoveragePercentage)
        maxLineCoveragePercentage = maxLineCoveragePercentageDecoded
    }
}

extension DescribeCodeCoveragesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCodeCoveragesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeCodeCoveragesOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCodeCoveragesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeCodeCoveragesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.codeCoverages = output.codeCoverages
            self.nextToken = output.nextToken
        } else {
            self.codeCoverages = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeCodeCoveragesOutputResponse: Swift.Equatable {
    /// An array of CodeCoverage objects that contain the results.
    public var codeCoverages: [CodeBuildClientTypes.CodeCoverage]?
    /// If there are more items to return, this contains a token that is passed to a subsequent call to DescribeCodeCoverages to retrieve the next set of items.
    public var nextToken: Swift.String?

    public init (
        codeCoverages: [CodeBuildClientTypes.CodeCoverage]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.codeCoverages = codeCoverages
        self.nextToken = nextToken
    }
}

struct DescribeCodeCoveragesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let codeCoverages: [CodeBuildClientTypes.CodeCoverage]?
}

extension DescribeCodeCoveragesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeCoverages
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let codeCoveragesContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.CodeCoverage?].self, forKey: .codeCoverages)
        var codeCoveragesDecoded0:[CodeBuildClientTypes.CodeCoverage]? = nil
        if let codeCoveragesContainer = codeCoveragesContainer {
            codeCoveragesDecoded0 = [CodeBuildClientTypes.CodeCoverage]()
            for structure0 in codeCoveragesContainer {
                if let structure0 = structure0 {
                    codeCoveragesDecoded0?.append(structure0)
                }
            }
        }
        codeCoverages = codeCoveragesDecoded0
    }
}

extension DescribeTestCasesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case maxResults
        case nextToken
        case reportArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let reportArn = self.reportArn {
            try encodeContainer.encode(reportArn, forKey: .reportArn)
        }
    }
}

extension DescribeTestCasesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeTestCasesInput: Swift.Equatable {
    /// A TestCaseFilter object used to filter the returned reports.
    public var filter: CodeBuildClientTypes.TestCaseFilter?
    /// The maximum number of paginated test cases returned per response. Use nextToken to iterate pages in the list of returned TestCase objects. The default value is 100.
    public var maxResults: Swift.Int?
    /// During a previous call, the maximum number of items that can be returned is the value specified in maxResults. If there more items in the list, then a unique string called a nextToken is returned. To get the next batch of items in the list, call this operation again, adding the next token to the call. To get all of the items in the list, keep calling this operation with each subsequent next token that is returned, until no more next tokens are returned.
    public var nextToken: Swift.String?
    /// The ARN of the report for which test cases are returned.
    /// This member is required.
    public var reportArn: Swift.String?

    public init (
        filter: CodeBuildClientTypes.TestCaseFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        reportArn: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.reportArn = reportArn
    }
}

struct DescribeTestCasesInputBody: Swift.Equatable {
    let reportArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filter: CodeBuildClientTypes.TestCaseFilter?
}

extension DescribeTestCasesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case maxResults
        case nextToken
        case reportArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportArn)
        reportArn = reportArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filterDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.TestCaseFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension DescribeTestCasesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTestCasesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeTestCasesOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTestCasesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeTestCasesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.testCases = output.testCases
        } else {
            self.nextToken = nil
            self.testCases = nil
        }
    }
}

public struct DescribeTestCasesOutputResponse: Swift.Equatable {
    /// During a previous call, the maximum number of items that can be returned is the value specified in maxResults. If there more items in the list, then a unique string called a nextToken is returned. To get the next batch of items in the list, call this operation again, adding the next token to the call. To get all of the items in the list, keep calling this operation with each subsequent next token that is returned, until no more next tokens are returned.
    public var nextToken: Swift.String?
    /// The returned list of test cases.
    public var testCases: [CodeBuildClientTypes.TestCase]?

    public init (
        nextToken: Swift.String? = nil,
        testCases: [CodeBuildClientTypes.TestCase]? = nil
    )
    {
        self.nextToken = nextToken
        self.testCases = testCases
    }
}

struct DescribeTestCasesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let testCases: [CodeBuildClientTypes.TestCase]?
}

extension DescribeTestCasesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case testCases
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let testCasesContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.TestCase?].self, forKey: .testCases)
        var testCasesDecoded0:[CodeBuildClientTypes.TestCase]? = nil
        if let testCasesContainer = testCasesContainer {
            testCasesDecoded0 = [CodeBuildClientTypes.TestCase]()
            for structure0 in testCasesContainer {
                if let structure0 = structure0 {
                    testCasesDecoded0?.append(structure0)
                }
            }
        }
        testCases = testCasesDecoded0
    }
}

extension CodeBuildClientTypes.EnvironmentImage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case versions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let versions = versions {
            var versionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .versions)
            for string0 in versions {
                try versionsContainer.encode(string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let versionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .versions)
        var versionsDecoded0:[Swift.String]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [Swift.String]()
            for string0 in versionsContainer {
                if let string0 = string0 {
                    versionsDecoded0?.append(string0)
                }
            }
        }
        versions = versionsDecoded0
    }
}

extension CodeBuildClientTypes {
    /// Information about a Docker image that is managed by CodeBuild.
    public struct EnvironmentImage: Swift.Equatable {
        /// The description of the Docker image.
        public var description: Swift.String?
        /// The name of the Docker image.
        public var name: Swift.String?
        /// A list of environment image versions.
        public var versions: [Swift.String]?

        public init (
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            versions: [Swift.String]? = nil
        )
        {
            self.description = description
            self.name = name
            self.versions = versions
        }
    }

}

extension CodeBuildClientTypes.EnvironmentLanguage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case images
        case language
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let images = images {
            var imagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .images)
            for environmentimage0 in images {
                try imagesContainer.encode(environmentimage0)
            }
        }
        if let language = self.language {
            try encodeContainer.encode(language.rawValue, forKey: .language)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.LanguageType.self, forKey: .language)
        language = languageDecoded
        let imagesContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.EnvironmentImage?].self, forKey: .images)
        var imagesDecoded0:[CodeBuildClientTypes.EnvironmentImage]? = nil
        if let imagesContainer = imagesContainer {
            imagesDecoded0 = [CodeBuildClientTypes.EnvironmentImage]()
            for structure0 in imagesContainer {
                if let structure0 = structure0 {
                    imagesDecoded0?.append(structure0)
                }
            }
        }
        images = imagesDecoded0
    }
}

extension CodeBuildClientTypes {
    /// A set of Docker images that are related by programming language and are managed by CodeBuild.
    public struct EnvironmentLanguage: Swift.Equatable {
        /// The list of Docker images that are related by the specified programming language.
        public var images: [CodeBuildClientTypes.EnvironmentImage]?
        /// The programming language for the Docker images.
        public var language: CodeBuildClientTypes.LanguageType?

        public init (
            images: [CodeBuildClientTypes.EnvironmentImage]? = nil,
            language: CodeBuildClientTypes.LanguageType? = nil
        )
        {
            self.images = images
            self.language = language
        }
    }

}

extension CodeBuildClientTypes.EnvironmentPlatform: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case languages
        case platform
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let languages = languages {
            var languagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .languages)
            for environmentlanguage0 in languages {
                try languagesContainer.encode(environmentlanguage0)
            }
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let platformDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.PlatformType.self, forKey: .platform)
        platform = platformDecoded
        let languagesContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.EnvironmentLanguage?].self, forKey: .languages)
        var languagesDecoded0:[CodeBuildClientTypes.EnvironmentLanguage]? = nil
        if let languagesContainer = languagesContainer {
            languagesDecoded0 = [CodeBuildClientTypes.EnvironmentLanguage]()
            for structure0 in languagesContainer {
                if let structure0 = structure0 {
                    languagesDecoded0?.append(structure0)
                }
            }
        }
        languages = languagesDecoded0
    }
}

extension CodeBuildClientTypes {
    /// A set of Docker images that are related by platform and are managed by CodeBuild.
    public struct EnvironmentPlatform: Swift.Equatable {
        /// The list of programming languages that are available for the specified platform.
        public var languages: [CodeBuildClientTypes.EnvironmentLanguage]?
        /// The platform's name.
        public var platform: CodeBuildClientTypes.PlatformType?

        public init (
            languages: [CodeBuildClientTypes.EnvironmentLanguage]? = nil,
            platform: CodeBuildClientTypes.PlatformType? = nil
        )
        {
            self.languages = languages
            self.platform = platform
        }
    }

}

extension CodeBuildClientTypes {
    public enum EnvironmentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case armContainer
        case linuxContainer
        case linuxGpuContainer
        case windowsContainer
        case windowsServer2019Container
        case sdkUnknown(Swift.String)

        public static var allCases: [EnvironmentType] {
            return [
                .armContainer,
                .linuxContainer,
                .linuxGpuContainer,
                .windowsContainer,
                .windowsServer2019Container,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .armContainer: return "ARM_CONTAINER"
            case .linuxContainer: return "LINUX_CONTAINER"
            case .linuxGpuContainer: return "LINUX_GPU_CONTAINER"
            case .windowsContainer: return "WINDOWS_CONTAINER"
            case .windowsServer2019Container: return "WINDOWS_SERVER_2019_CONTAINER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EnvironmentType(rawValue: rawValue) ?? EnvironmentType.sdkUnknown(rawValue)
        }
    }
}

extension CodeBuildClientTypes.EnvironmentVariable: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case type
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let typeDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.EnvironmentVariableType.self, forKey: .type)
        type = typeDecoded
    }
}

extension CodeBuildClientTypes {
    /// Information about an environment variable for a build project or a build.
    public struct EnvironmentVariable: Swift.Equatable {
        /// The name or key of the environment variable.
        /// This member is required.
        public var name: Swift.String?
        /// The type of environment variable. Valid values include:
        ///
        /// * PARAMETER_STORE: An environment variable stored in Systems Manager Parameter Store. To learn how to specify a parameter store environment variable, see [env/parameter-store](https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html#build-spec.env.parameter-store) in the CodeBuild User Guide.
        ///
        /// * PLAINTEXT: An environment variable in plain text format. This is the default value.
        ///
        /// * SECRETS_MANAGER: An environment variable stored in Secrets Manager. To learn how to specify a secrets manager environment variable, see [env/secrets-manager](https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html#build-spec.env.secrets-manager) in the CodeBuild User Guide.
        public var type: CodeBuildClientTypes.EnvironmentVariableType?
        /// The value of the environment variable. We strongly discourage the use of PLAINTEXT environment variables to store sensitive values, especially Amazon Web Services secret key IDs and secret access keys. PLAINTEXT environment variables can be displayed in plain text using the CodeBuild console and the CLI. For sensitive values, we recommend you use an environment variable of type PARAMETER_STORE or SECRETS_MANAGER.
        /// This member is required.
        public var value: Swift.String?

        public init (
            name: Swift.String? = nil,
            type: CodeBuildClientTypes.EnvironmentVariableType? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.type = type
            self.value = value
        }
    }

}

extension CodeBuildClientTypes {
    public enum EnvironmentVariableType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case parameterStore
        case plaintext
        case secretsManager
        case sdkUnknown(Swift.String)

        public static var allCases: [EnvironmentVariableType] {
            return [
                .parameterStore,
                .plaintext,
                .secretsManager,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .parameterStore: return "PARAMETER_STORE"
            case .plaintext: return "PLAINTEXT"
            case .secretsManager: return "SECRETS_MANAGER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EnvironmentVariableType(rawValue: rawValue) ?? EnvironmentVariableType.sdkUnknown(rawValue)
        }
    }
}

extension CodeBuildClientTypes.ExportedEnvironmentVariable: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension CodeBuildClientTypes {
    /// Contains information about an exported environment variable. Exported environment variables are used in conjunction with CodePipeline to export environment variables from the current build stage to subsequent stages in the pipeline. For more information, see [Working with variables](https://docs.aws.amazon.com/codepipeline/latest/userguide/actions-variables.html) in the CodePipeline User Guide. During a build, the value of a variable is available starting with the install phase. It can be updated between the start of the install phase and the end of the post_build phase. After the post_build phase ends, the value of exported variables cannot change.
    public struct ExportedEnvironmentVariable: Swift.Equatable {
        /// The name of the exported environment variable.
        public var name: Swift.String?
        /// The value assigned to the exported environment variable.
        public var value: Swift.String?

        public init (
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension CodeBuildClientTypes {
    public enum FileSystemType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case efs
        case sdkUnknown(Swift.String)

        public static var allCases: [FileSystemType] {
            return [
                .efs,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .efs: return "EFS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FileSystemType(rawValue: rawValue) ?? FileSystemType.sdkUnknown(rawValue)
        }
    }
}

extension GetReportGroupTrendInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case numOfReports
        case reportGroupArn
        case trendField
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let numOfReports = self.numOfReports {
            try encodeContainer.encode(numOfReports, forKey: .numOfReports)
        }
        if let reportGroupArn = self.reportGroupArn {
            try encodeContainer.encode(reportGroupArn, forKey: .reportGroupArn)
        }
        if let trendField = self.trendField {
            try encodeContainer.encode(trendField.rawValue, forKey: .trendField)
        }
    }
}

extension GetReportGroupTrendInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetReportGroupTrendInput: Swift.Equatable {
    /// The number of reports to analyze. This operation always retrieves the most recent reports. If this parameter is omitted, the most recent 100 reports are analyzed.
    public var numOfReports: Swift.Int?
    /// The ARN of the report group that contains the reports to analyze.
    /// This member is required.
    public var reportGroupArn: Swift.String?
    /// The test report value to accumulate. This must be one of the following values: Test reports: DURATION Accumulate the test run times for the specified reports. PASS_RATE Accumulate the percentage of tests that passed for the specified test reports. TOTAL Accumulate the total number of tests for the specified test reports. Code coverage reports: BRANCH_COVERAGE Accumulate the branch coverage percentages for the specified test reports. BRANCHES_COVERED Accumulate the branches covered values for the specified test reports. BRANCHES_MISSED Accumulate the branches missed values for the specified test reports. LINE_COVERAGE Accumulate the line coverage percentages for the specified test reports. LINES_COVERED Accumulate the lines covered values for the specified test reports. LINES_MISSED Accumulate the lines not covered values for the specified test reports.
    /// This member is required.
    public var trendField: CodeBuildClientTypes.ReportGroupTrendFieldType?

    public init (
        numOfReports: Swift.Int? = nil,
        reportGroupArn: Swift.String? = nil,
        trendField: CodeBuildClientTypes.ReportGroupTrendFieldType? = nil
    )
    {
        self.numOfReports = numOfReports
        self.reportGroupArn = reportGroupArn
        self.trendField = trendField
    }
}

struct GetReportGroupTrendInputBody: Swift.Equatable {
    let reportGroupArn: Swift.String?
    let numOfReports: Swift.Int?
    let trendField: CodeBuildClientTypes.ReportGroupTrendFieldType?
}

extension GetReportGroupTrendInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case numOfReports
        case reportGroupArn
        case trendField
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportGroupArn)
        reportGroupArn = reportGroupArnDecoded
        let numOfReportsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numOfReports)
        numOfReports = numOfReportsDecoded
        let trendFieldDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ReportGroupTrendFieldType.self, forKey: .trendField)
        trendField = trendFieldDecoded
    }
}

extension GetReportGroupTrendOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetReportGroupTrendOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetReportGroupTrendOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetReportGroupTrendOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetReportGroupTrendOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.rawData = output.rawData
            self.stats = output.stats
        } else {
            self.rawData = nil
            self.stats = nil
        }
    }
}

public struct GetReportGroupTrendOutputResponse: Swift.Equatable {
    /// An array that contains the raw data for each report.
    public var rawData: [CodeBuildClientTypes.ReportWithRawData]?
    /// Contains the accumulated trend data.
    public var stats: CodeBuildClientTypes.ReportGroupTrendStats?

    public init (
        rawData: [CodeBuildClientTypes.ReportWithRawData]? = nil,
        stats: CodeBuildClientTypes.ReportGroupTrendStats? = nil
    )
    {
        self.rawData = rawData
        self.stats = stats
    }
}

struct GetReportGroupTrendOutputResponseBody: Swift.Equatable {
    let stats: CodeBuildClientTypes.ReportGroupTrendStats?
    let rawData: [CodeBuildClientTypes.ReportWithRawData]?
}

extension GetReportGroupTrendOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rawData
        case stats
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statsDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ReportGroupTrendStats.self, forKey: .stats)
        stats = statsDecoded
        let rawDataContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.ReportWithRawData?].self, forKey: .rawData)
        var rawDataDecoded0:[CodeBuildClientTypes.ReportWithRawData]? = nil
        if let rawDataContainer = rawDataContainer {
            rawDataDecoded0 = [CodeBuildClientTypes.ReportWithRawData]()
            for structure0 in rawDataContainer {
                if let structure0 = structure0 {
                    rawDataDecoded0?.append(structure0)
                }
            }
        }
        rawData = rawDataDecoded0
    }
}

extension GetResourcePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension GetResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetResourcePolicyInput: Swift.Equatable {
    /// The ARN of the resource that is associated with the resource policy.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct GetResourcePolicyInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension GetResourcePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension GetResourcePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourcePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetResourcePolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourcePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetResourcePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetResourcePolicyOutputResponse: Swift.Equatable {
    /// The resource policy for the resource identified by the input ARN parameter.
    public var policy: Swift.String?

    public init (
        policy: Swift.String? = nil
    )
    {
        self.policy = policy
    }
}

struct GetResourcePolicyOutputResponseBody: Swift.Equatable {
    let policy: Swift.String?
}

extension GetResourcePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension CodeBuildClientTypes.GitSubmodulesConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fetchSubmodules
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fetchSubmodules = self.fetchSubmodules {
            try encodeContainer.encode(fetchSubmodules, forKey: .fetchSubmodules)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fetchSubmodulesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .fetchSubmodules)
        fetchSubmodules = fetchSubmodulesDecoded
    }
}

extension CodeBuildClientTypes {
    /// Information about the Git submodules configuration for an CodeBuild build project.
    public struct GitSubmodulesConfig: Swift.Equatable {
        /// Set to true to fetch Git submodules for your CodeBuild build project.
        /// This member is required.
        public var fetchSubmodules: Swift.Bool?

        public init (
            fetchSubmodules: Swift.Bool? = nil
        )
        {
            self.fetchSubmodules = fetchSubmodules
        }
    }

}

extension CodeBuildClientTypes {
    public enum ImagePullCredentialsType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case codebuild
        case serviceRole
        case sdkUnknown(Swift.String)

        public static var allCases: [ImagePullCredentialsType] {
            return [
                .codebuild,
                .serviceRole,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .codebuild: return "CODEBUILD"
            case .serviceRole: return "SERVICE_ROLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImagePullCredentialsType(rawValue: rawValue) ?? ImagePullCredentialsType.sdkUnknown(rawValue)
        }
    }
}

extension ImportSourceCredentialsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportSourceCredentialsInput(authType: \(Swift.String(describing: authType)), serverType: \(Swift.String(describing: serverType)), shouldOverwrite: \(Swift.String(describing: shouldOverwrite)), username: \(Swift.String(describing: username)), token: \"CONTENT_REDACTED\")"}
}

extension ImportSourceCredentialsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authType
        case serverType
        case shouldOverwrite
        case token
        case username
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authType = self.authType {
            try encodeContainer.encode(authType.rawValue, forKey: .authType)
        }
        if let serverType = self.serverType {
            try encodeContainer.encode(serverType.rawValue, forKey: .serverType)
        }
        if let shouldOverwrite = self.shouldOverwrite {
            try encodeContainer.encode(shouldOverwrite, forKey: .shouldOverwrite)
        }
        if let token = self.token {
            try encodeContainer.encode(token, forKey: .token)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

extension ImportSourceCredentialsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ImportSourceCredentialsInput: Swift.Equatable {
    /// The type of authentication used to connect to a GitHub, GitHub Enterprise, or Bitbucket repository. An OAUTH connection is not supported by the API and must be created using the CodeBuild console.
    /// This member is required.
    public var authType: CodeBuildClientTypes.AuthType?
    /// The source provider used for this project.
    /// This member is required.
    public var serverType: CodeBuildClientTypes.ServerType?
    /// Set to false to prevent overwriting the repository source credentials. Set to true to overwrite the repository source credentials. The default value is true.
    public var shouldOverwrite: Swift.Bool?
    /// For GitHub or GitHub Enterprise, this is the personal access token. For Bitbucket, this is the app password.
    /// This member is required.
    public var token: Swift.String?
    /// The Bitbucket username when the authType is BASIC_AUTH. This parameter is not valid for other types of source providers or connections.
    public var username: Swift.String?

    public init (
        authType: CodeBuildClientTypes.AuthType? = nil,
        serverType: CodeBuildClientTypes.ServerType? = nil,
        shouldOverwrite: Swift.Bool? = nil,
        token: Swift.String? = nil,
        username: Swift.String? = nil
    )
    {
        self.authType = authType
        self.serverType = serverType
        self.shouldOverwrite = shouldOverwrite
        self.token = token
        self.username = username
    }
}

struct ImportSourceCredentialsInputBody: Swift.Equatable {
    let username: Swift.String?
    let token: Swift.String?
    let serverType: CodeBuildClientTypes.ServerType?
    let authType: CodeBuildClientTypes.AuthType?
    let shouldOverwrite: Swift.Bool?
}

extension ImportSourceCredentialsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authType
        case serverType
        case shouldOverwrite
        case token
        case username
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
        let serverTypeDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ServerType.self, forKey: .serverType)
        serverType = serverTypeDecoded
        let authTypeDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.AuthType.self, forKey: .authType)
        authType = authTypeDecoded
        let shouldOverwriteDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .shouldOverwrite)
        shouldOverwrite = shouldOverwriteDecoded
    }
}

extension ImportSourceCredentialsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportSourceCredentialsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccountLimitExceededException" : self = .accountLimitExceededException(try AccountLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ImportSourceCredentialsOutputError: Swift.Error, Swift.Equatable {
    case accountLimitExceededException(AccountLimitExceededException)
    case invalidInputException(InvalidInputException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportSourceCredentialsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ImportSourceCredentialsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct ImportSourceCredentialsOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the token.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct ImportSourceCredentialsOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
}

extension ImportSourceCredentialsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension InvalidInputException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidInputExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input value that was provided is not valid.
public struct InvalidInputException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInputExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidInputExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidateProjectCacheInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let projectName = self.projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
    }
}

extension InvalidateProjectCacheInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct InvalidateProjectCacheInput: Swift.Equatable {
    /// The name of the CodeBuild build project that the cache is reset for.
    /// This member is required.
    public var projectName: Swift.String?

    public init (
        projectName: Swift.String? = nil
    )
    {
        self.projectName = projectName
    }
}

struct InvalidateProjectCacheInputBody: Swift.Equatable {
    let projectName: Swift.String?
}

extension InvalidateProjectCacheInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
    }
}

extension InvalidateProjectCacheOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InvalidateProjectCacheOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum InvalidateProjectCacheOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InvalidateProjectCacheOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct InvalidateProjectCacheOutputResponse: Swift.Equatable {

    public init () { }
}

extension CodeBuildClientTypes {
    public enum LanguageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case android
        case base
        case docker
        case dotnet
        case golang
        case java
        case nodeJs
        case php
        case python
        case ruby
        case sdkUnknown(Swift.String)

        public static var allCases: [LanguageType] {
            return [
                .android,
                .base,
                .docker,
                .dotnet,
                .golang,
                .java,
                .nodeJs,
                .php,
                .python,
                .ruby,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .android: return "ANDROID"
            case .base: return "BASE"
            case .docker: return "DOCKER"
            case .dotnet: return "DOTNET"
            case .golang: return "GOLANG"
            case .java: return "JAVA"
            case .nodeJs: return "NODE_JS"
            case .php: return "PHP"
            case .python: return "PYTHON"
            case .ruby: return "RUBY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LanguageType(rawValue: rawValue) ?? LanguageType.sdkUnknown(rawValue)
        }
    }
}

extension ListBuildBatchesForProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case maxResults
        case nextToken
        case projectName
        case sortOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let projectName = self.projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

extension ListBuildBatchesForProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListBuildBatchesForProjectInput: Swift.Equatable {
    /// A BuildBatchFilter object that specifies the filters for the search.
    public var filter: CodeBuildClientTypes.BuildBatchFilter?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The nextToken value returned from a previous call to ListBuildBatchesForProject. This specifies the next item to return. To return the beginning of the list, exclude this parameter.
    public var nextToken: Swift.String?
    /// The name of the project.
    public var projectName: Swift.String?
    /// Specifies the sort order of the returned items. Valid values include:
    ///
    /// * ASCENDING: List the batch build identifiers in ascending order by identifier.
    ///
    /// * DESCENDING: List the batch build identifiers in descending order by identifier.
    public var sortOrder: CodeBuildClientTypes.SortOrderType?

    public init (
        filter: CodeBuildClientTypes.BuildBatchFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectName: Swift.String? = nil,
        sortOrder: CodeBuildClientTypes.SortOrderType? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectName = projectName
        self.sortOrder = sortOrder
    }
}

struct ListBuildBatchesForProjectInputBody: Swift.Equatable {
    let projectName: Swift.String?
    let filter: CodeBuildClientTypes.BuildBatchFilter?
    let maxResults: Swift.Int?
    let sortOrder: CodeBuildClientTypes.SortOrderType?
    let nextToken: Swift.String?
}

extension ListBuildBatchesForProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case maxResults
        case nextToken
        case projectName
        case sortOrder
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let filterDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.BuildBatchFilter.self, forKey: .filter)
        filter = filterDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.SortOrderType.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListBuildBatchesForProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBuildBatchesForProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListBuildBatchesForProjectOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBuildBatchesForProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListBuildBatchesForProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.ids = output.ids
            self.nextToken = output.nextToken
        } else {
            self.ids = nil
            self.nextToken = nil
        }
    }
}

public struct ListBuildBatchesForProjectOutputResponse: Swift.Equatable {
    /// An array of strings that contains the batch build identifiers.
    public var ids: [Swift.String]?
    /// If there are more items to return, this contains a token that is passed to a subsequent call to ListBuildBatchesForProject to retrieve the next set of items.
    public var nextToken: Swift.String?

    public init (
        ids: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.ids = ids
        self.nextToken = nextToken
    }
}

struct ListBuildBatchesForProjectOutputResponseBody: Swift.Equatable {
    let ids: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListBuildBatchesForProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ids
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ids)
        var idsDecoded0:[Swift.String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [Swift.String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListBuildBatchesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case maxResults
        case nextToken
        case sortOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

extension ListBuildBatchesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListBuildBatchesInput: Swift.Equatable {
    /// A BuildBatchFilter object that specifies the filters for the search.
    public var filter: CodeBuildClientTypes.BuildBatchFilter?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The nextToken value returned from a previous call to ListBuildBatches. This specifies the next item to return. To return the beginning of the list, exclude this parameter.
    public var nextToken: Swift.String?
    /// Specifies the sort order of the returned items. Valid values include:
    ///
    /// * ASCENDING: List the batch build identifiers in ascending order by identifier.
    ///
    /// * DESCENDING: List the batch build identifiers in descending order by identifier.
    public var sortOrder: CodeBuildClientTypes.SortOrderType?

    public init (
        filter: CodeBuildClientTypes.BuildBatchFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortOrder: CodeBuildClientTypes.SortOrderType? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortOrder = sortOrder
    }
}

struct ListBuildBatchesInputBody: Swift.Equatable {
    let filter: CodeBuildClientTypes.BuildBatchFilter?
    let maxResults: Swift.Int?
    let sortOrder: CodeBuildClientTypes.SortOrderType?
    let nextToken: Swift.String?
}

extension ListBuildBatchesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case maxResults
        case nextToken
        case sortOrder
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.BuildBatchFilter.self, forKey: .filter)
        filter = filterDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.SortOrderType.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListBuildBatchesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBuildBatchesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListBuildBatchesOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBuildBatchesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListBuildBatchesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.ids = output.ids
            self.nextToken = output.nextToken
        } else {
            self.ids = nil
            self.nextToken = nil
        }
    }
}

public struct ListBuildBatchesOutputResponse: Swift.Equatable {
    /// An array of strings that contains the batch build identifiers.
    public var ids: [Swift.String]?
    /// If there are more items to return, this contains a token that is passed to a subsequent call to ListBuildBatches to retrieve the next set of items.
    public var nextToken: Swift.String?

    public init (
        ids: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.ids = ids
        self.nextToken = nextToken
    }
}

struct ListBuildBatchesOutputResponseBody: Swift.Equatable {
    let ids: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListBuildBatchesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ids
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ids)
        var idsDecoded0:[Swift.String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [Swift.String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListBuildsForProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case projectName
        case sortOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let projectName = self.projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

extension ListBuildsForProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListBuildsForProjectInput: Swift.Equatable {
    /// During a previous call, if there are more than 100 items in the list, only the first 100 items are returned, along with a unique string called a nextToken. To get the next batch of items in the list, call this operation again, adding the next token to the call. To get all of the items in the list, keep calling this operation with each subsequent next token that is returned, until no more next tokens are returned.
    public var nextToken: Swift.String?
    /// The name of the CodeBuild project.
    /// This member is required.
    public var projectName: Swift.String?
    /// The order to sort the results in. The results are sorted by build number, not the build identifier. If this is not specified, the results are sorted in descending order. Valid values include:
    ///
    /// * ASCENDING: List the build identifiers in ascending order, by build number.
    ///
    /// * DESCENDING: List the build identifiers in descending order, by build number.
    ///
    ///
    /// If the project has more than 100 builds, setting the sort order will result in an error.
    public var sortOrder: CodeBuildClientTypes.SortOrderType?

    public init (
        nextToken: Swift.String? = nil,
        projectName: Swift.String? = nil,
        sortOrder: CodeBuildClientTypes.SortOrderType? = nil
    )
    {
        self.nextToken = nextToken
        self.projectName = projectName
        self.sortOrder = sortOrder
    }
}

struct ListBuildsForProjectInputBody: Swift.Equatable {
    let projectName: Swift.String?
    let sortOrder: CodeBuildClientTypes.SortOrderType?
    let nextToken: Swift.String?
}

extension ListBuildsForProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case projectName
        case sortOrder
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.SortOrderType.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListBuildsForProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBuildsForProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListBuildsForProjectOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBuildsForProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListBuildsForProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.ids = output.ids
            self.nextToken = output.nextToken
        } else {
            self.ids = nil
            self.nextToken = nil
        }
    }
}

public struct ListBuildsForProjectOutputResponse: Swift.Equatable {
    /// A list of build identifiers for the specified build project, with each build ID representing a single build.
    public var ids: [Swift.String]?
    /// If there are more than 100 items in the list, only the first 100 items are returned, along with a unique string called a nextToken. To get the next batch of items in the list, call this operation again, adding the next token to the call.
    public var nextToken: Swift.String?

    public init (
        ids: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.ids = ids
        self.nextToken = nextToken
    }
}

struct ListBuildsForProjectOutputResponseBody: Swift.Equatable {
    let ids: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListBuildsForProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ids
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ids)
        var idsDecoded0:[Swift.String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [Swift.String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListBuildsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case sortOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

extension ListBuildsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListBuildsInput: Swift.Equatable {
    /// During a previous call, if there are more than 100 items in the list, only the first 100 items are returned, along with a unique string called a nextToken. To get the next batch of items in the list, call this operation again, adding the next token to the call. To get all of the items in the list, keep calling this operation with each subsequent next token that is returned, until no more next tokens are returned.
    public var nextToken: Swift.String?
    /// The order to list build IDs. Valid values include:
    ///
    /// * ASCENDING: List the build IDs in ascending order by build ID.
    ///
    /// * DESCENDING: List the build IDs in descending order by build ID.
    public var sortOrder: CodeBuildClientTypes.SortOrderType?

    public init (
        nextToken: Swift.String? = nil,
        sortOrder: CodeBuildClientTypes.SortOrderType? = nil
    )
    {
        self.nextToken = nextToken
        self.sortOrder = sortOrder
    }
}

struct ListBuildsInputBody: Swift.Equatable {
    let sortOrder: CodeBuildClientTypes.SortOrderType?
    let nextToken: Swift.String?
}

extension ListBuildsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case sortOrder
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortOrderDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.SortOrderType.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListBuildsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBuildsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListBuildsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBuildsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListBuildsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.ids = output.ids
            self.nextToken = output.nextToken
        } else {
            self.ids = nil
            self.nextToken = nil
        }
    }
}

public struct ListBuildsOutputResponse: Swift.Equatable {
    /// A list of build IDs, with each build ID representing a single build.
    public var ids: [Swift.String]?
    /// If there are more than 100 items in the list, only the first 100 items are returned, along with a unique string called a nextToken. To get the next batch of items in the list, call this operation again, adding the next token to the call.
    public var nextToken: Swift.String?

    public init (
        ids: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.ids = ids
        self.nextToken = nextToken
    }
}

struct ListBuildsOutputResponseBody: Swift.Equatable {
    let ids: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListBuildsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ids
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ids)
        var idsDecoded0:[Swift.String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [Swift.String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCuratedEnvironmentImagesInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListCuratedEnvironmentImagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListCuratedEnvironmentImagesInput: Swift.Equatable {

    public init () { }
}

struct ListCuratedEnvironmentImagesInputBody: Swift.Equatable {
}

extension ListCuratedEnvironmentImagesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListCuratedEnvironmentImagesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCuratedEnvironmentImagesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListCuratedEnvironmentImagesOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCuratedEnvironmentImagesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListCuratedEnvironmentImagesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.platforms = output.platforms
        } else {
            self.platforms = nil
        }
    }
}

public struct ListCuratedEnvironmentImagesOutputResponse: Swift.Equatable {
    /// Information about supported platforms for Docker images that are managed by CodeBuild.
    public var platforms: [CodeBuildClientTypes.EnvironmentPlatform]?

    public init (
        platforms: [CodeBuildClientTypes.EnvironmentPlatform]? = nil
    )
    {
        self.platforms = platforms
    }
}

struct ListCuratedEnvironmentImagesOutputResponseBody: Swift.Equatable {
    let platforms: [CodeBuildClientTypes.EnvironmentPlatform]?
}

extension ListCuratedEnvironmentImagesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case platforms
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let platformsContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.EnvironmentPlatform?].self, forKey: .platforms)
        var platformsDecoded0:[CodeBuildClientTypes.EnvironmentPlatform]? = nil
        if let platformsContainer = platformsContainer {
            platformsDecoded0 = [CodeBuildClientTypes.EnvironmentPlatform]()
            for structure0 in platformsContainer {
                if let structure0 = structure0 {
                    platformsDecoded0?.append(structure0)
                }
            }
        }
        platforms = platformsDecoded0
    }
}

extension ListProjectsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case sortBy
        case sortOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

extension ListProjectsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListProjectsInput: Swift.Equatable {
    /// During a previous call, if there are more than 100 items in the list, only the first 100 items are returned, along with a unique string called a nextToken. To get the next batch of items in the list, call this operation again, adding the next token to the call. To get all of the items in the list, keep calling this operation with each subsequent next token that is returned, until no more next tokens are returned.
    public var nextToken: Swift.String?
    /// The criterion to be used to list build project names. Valid values include:
    ///
    /// * CREATED_TIME: List based on when each build project was created.
    ///
    /// * LAST_MODIFIED_TIME: List based on when information about each build project was last changed.
    ///
    /// * NAME: List based on each build project's name.
    ///
    ///
    /// Use sortOrder to specify in what order to list the build project names based on the preceding criteria.
    public var sortBy: CodeBuildClientTypes.ProjectSortByType?
    /// The order in which to list build projects. Valid values include:
    ///
    /// * ASCENDING: List in ascending order.
    ///
    /// * DESCENDING: List in descending order.
    ///
    ///
    /// Use sortBy to specify the criterion to be used to list build project names.
    public var sortOrder: CodeBuildClientTypes.SortOrderType?

    public init (
        nextToken: Swift.String? = nil,
        sortBy: CodeBuildClientTypes.ProjectSortByType? = nil,
        sortOrder: CodeBuildClientTypes.SortOrderType? = nil
    )
    {
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

struct ListProjectsInputBody: Swift.Equatable {
    let sortBy: CodeBuildClientTypes.ProjectSortByType?
    let sortOrder: CodeBuildClientTypes.SortOrderType?
    let nextToken: Swift.String?
}

extension ListProjectsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case sortBy
        case sortOrder
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortByDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ProjectSortByType.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.SortOrderType.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProjectsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProjectsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListProjectsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProjectsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListProjectsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.projects = output.projects
        } else {
            self.nextToken = nil
            self.projects = nil
        }
    }
}

public struct ListProjectsOutputResponse: Swift.Equatable {
    /// If there are more than 100 items in the list, only the first 100 items are returned, along with a unique string called a nextToken. To get the next batch of items in the list, call this operation again, adding the next token to the call.
    public var nextToken: Swift.String?
    /// The list of build project names, with each build project name representing a single build project.
    public var projects: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        projects: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.projects = projects
    }
}

struct ListProjectsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let projects: [Swift.String]?
}

extension ListProjectsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case projects
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let projectsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .projects)
        var projectsDecoded0:[Swift.String]? = nil
        if let projectsContainer = projectsContainer {
            projectsDecoded0 = [Swift.String]()
            for string0 in projectsContainer {
                if let string0 = string0 {
                    projectsDecoded0?.append(string0)
                }
            }
        }
        projects = projectsDecoded0
    }
}

extension ListReportGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case sortBy
        case sortOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

extension ListReportGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListReportGroupsInput: Swift.Equatable {
    /// The maximum number of paginated report groups returned per response. Use nextToken to iterate pages in the list of returned ReportGroup objects. The default value is 100.
    public var maxResults: Swift.Int?
    /// During a previous call, the maximum number of items that can be returned is the value specified in maxResults. If there more items in the list, then a unique string called a nextToken is returned. To get the next batch of items in the list, call this operation again, adding the next token to the call. To get all of the items in the list, keep calling this operation with each subsequent next token that is returned, until no more next tokens are returned.
    public var nextToken: Swift.String?
    /// The criterion to be used to list build report groups. Valid values include:
    ///
    /// * CREATED_TIME: List based on when each report group was created.
    ///
    /// * LAST_MODIFIED_TIME: List based on when each report group was last changed.
    ///
    /// * NAME: List based on each report group's name.
    public var sortBy: CodeBuildClientTypes.ReportGroupSortByType?
    /// Used to specify the order to sort the list of returned report groups. Valid values are ASCENDING and DESCENDING.
    public var sortOrder: CodeBuildClientTypes.SortOrderType?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: CodeBuildClientTypes.ReportGroupSortByType? = nil,
        sortOrder: CodeBuildClientTypes.SortOrderType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

struct ListReportGroupsInputBody: Swift.Equatable {
    let sortOrder: CodeBuildClientTypes.SortOrderType?
    let sortBy: CodeBuildClientTypes.ReportGroupSortByType?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListReportGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case sortBy
        case sortOrder
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortOrderDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.SortOrderType.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ReportGroupSortByType.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListReportGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListReportGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListReportGroupsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListReportGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListReportGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.reportGroups = output.reportGroups
        } else {
            self.nextToken = nil
            self.reportGroups = nil
        }
    }
}

public struct ListReportGroupsOutputResponse: Swift.Equatable {
    /// During a previous call, the maximum number of items that can be returned is the value specified in maxResults. If there more items in the list, then a unique string called a nextToken is returned. To get the next batch of items in the list, call this operation again, adding the next token to the call. To get all of the items in the list, keep calling this operation with each subsequent next token that is returned, until no more next tokens are returned.
    public var nextToken: Swift.String?
    /// The list of ARNs for the report groups in the current Amazon Web Services account.
    public var reportGroups: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        reportGroups: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.reportGroups = reportGroups
    }
}

struct ListReportGroupsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let reportGroups: [Swift.String]?
}

extension ListReportGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case reportGroups
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let reportGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .reportGroups)
        var reportGroupsDecoded0:[Swift.String]? = nil
        if let reportGroupsContainer = reportGroupsContainer {
            reportGroupsDecoded0 = [Swift.String]()
            for string0 in reportGroupsContainer {
                if let string0 = string0 {
                    reportGroupsDecoded0?.append(string0)
                }
            }
        }
        reportGroups = reportGroupsDecoded0
    }
}

extension ListReportsForReportGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case maxResults
        case nextToken
        case reportGroupArn
        case sortOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let reportGroupArn = self.reportGroupArn {
            try encodeContainer.encode(reportGroupArn, forKey: .reportGroupArn)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

extension ListReportsForReportGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListReportsForReportGroupInput: Swift.Equatable {
    /// A ReportFilter object used to filter the returned reports.
    public var filter: CodeBuildClientTypes.ReportFilter?
    /// The maximum number of paginated reports in this report group returned per response. Use nextToken to iterate pages in the list of returned Report objects. The default value is 100.
    public var maxResults: Swift.Int?
    /// During a previous call, the maximum number of items that can be returned is the value specified in maxResults. If there more items in the list, then a unique string called a nextToken is returned. To get the next batch of items in the list, call this operation again, adding the next token to the call. To get all of the items in the list, keep calling this operation with each subsequent next token that is returned, until no more next tokens are returned.
    public var nextToken: Swift.String?
    /// The ARN of the report group for which you want to return report ARNs.
    /// This member is required.
    public var reportGroupArn: Swift.String?
    /// Use to specify whether the results are returned in ascending or descending order.
    public var sortOrder: CodeBuildClientTypes.SortOrderType?

    public init (
        filter: CodeBuildClientTypes.ReportFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        reportGroupArn: Swift.String? = nil,
        sortOrder: CodeBuildClientTypes.SortOrderType? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.reportGroupArn = reportGroupArn
        self.sortOrder = sortOrder
    }
}

struct ListReportsForReportGroupInputBody: Swift.Equatable {
    let reportGroupArn: Swift.String?
    let nextToken: Swift.String?
    let sortOrder: CodeBuildClientTypes.SortOrderType?
    let maxResults: Swift.Int?
    let filter: CodeBuildClientTypes.ReportFilter?
}

extension ListReportsForReportGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case maxResults
        case nextToken
        case reportGroupArn
        case sortOrder
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportGroupArn)
        reportGroupArn = reportGroupArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.SortOrderType.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filterDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ReportFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListReportsForReportGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListReportsForReportGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListReportsForReportGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListReportsForReportGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListReportsForReportGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.reports = output.reports
        } else {
            self.nextToken = nil
            self.reports = nil
        }
    }
}

public struct ListReportsForReportGroupOutputResponse: Swift.Equatable {
    /// During a previous call, the maximum number of items that can be returned is the value specified in maxResults. If there more items in the list, then a unique string called a nextToken is returned. To get the next batch of items in the list, call this operation again, adding the next token to the call. To get all of the items in the list, keep calling this operation with each subsequent next token that is returned, until no more next tokens are returned.
    public var nextToken: Swift.String?
    /// The list of report ARNs.
    public var reports: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        reports: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.reports = reports
    }
}

struct ListReportsForReportGroupOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let reports: [Swift.String]?
}

extension ListReportsForReportGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case reports
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let reportsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .reports)
        var reportsDecoded0:[Swift.String]? = nil
        if let reportsContainer = reportsContainer {
            reportsDecoded0 = [Swift.String]()
            for string0 in reportsContainer {
                if let string0 = string0 {
                    reportsDecoded0?.append(string0)
                }
            }
        }
        reports = reportsDecoded0
    }
}

extension ListReportsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case maxResults
        case nextToken
        case sortOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

extension ListReportsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListReportsInput: Swift.Equatable {
    /// A ReportFilter object used to filter the returned reports.
    public var filter: CodeBuildClientTypes.ReportFilter?
    /// The maximum number of paginated reports returned per response. Use nextToken to iterate pages in the list of returned Report objects. The default value is 100.
    public var maxResults: Swift.Int?
    /// During a previous call, the maximum number of items that can be returned is the value specified in maxResults. If there more items in the list, then a unique string called a nextToken is returned. To get the next batch of items in the list, call this operation again, adding the next token to the call. To get all of the items in the list, keep calling this operation with each subsequent next token that is returned, until no more next tokens are returned.
    public var nextToken: Swift.String?
    /// Specifies the sort order for the list of returned reports. Valid values are:
    ///
    /// * ASCENDING: return reports in chronological order based on their creation date.
    ///
    /// * DESCENDING: return reports in the reverse chronological order based on their creation date.
    public var sortOrder: CodeBuildClientTypes.SortOrderType?

    public init (
        filter: CodeBuildClientTypes.ReportFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortOrder: CodeBuildClientTypes.SortOrderType? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortOrder = sortOrder
    }
}

struct ListReportsInputBody: Swift.Equatable {
    let sortOrder: CodeBuildClientTypes.SortOrderType?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filter: CodeBuildClientTypes.ReportFilter?
}

extension ListReportsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case maxResults
        case nextToken
        case sortOrder
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortOrderDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.SortOrderType.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filterDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ReportFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListReportsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListReportsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListReportsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListReportsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListReportsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.reports = output.reports
        } else {
            self.nextToken = nil
            self.reports = nil
        }
    }
}

public struct ListReportsOutputResponse: Swift.Equatable {
    /// During a previous call, the maximum number of items that can be returned is the value specified in maxResults. If there more items in the list, then a unique string called a nextToken is returned. To get the next batch of items in the list, call this operation again, adding the next token to the call. To get all of the items in the list, keep calling this operation with each subsequent next token that is returned, until no more next tokens are returned.
    public var nextToken: Swift.String?
    /// The list of returned ARNs for the reports in the current Amazon Web Services account.
    public var reports: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        reports: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.reports = reports
    }
}

struct ListReportsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let reports: [Swift.String]?
}

extension ListReportsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case reports
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let reportsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .reports)
        var reportsDecoded0:[Swift.String]? = nil
        if let reportsContainer = reportsContainer {
            reportsDecoded0 = [Swift.String]()
            for string0 in reportsContainer {
                if let string0 = string0 {
                    reportsDecoded0?.append(string0)
                }
            }
        }
        reports = reportsDecoded0
    }
}

extension ListSharedProjectsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case sortBy
        case sortOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

extension ListSharedProjectsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSharedProjectsInput: Swift.Equatable {
    /// The maximum number of paginated shared build projects returned per response. Use nextToken to iterate pages in the list of returned Project objects. The default value is 100.
    public var maxResults: Swift.Int?
    /// During a previous call, the maximum number of items that can be returned is the value specified in maxResults. If there more items in the list, then a unique string called a nextToken is returned. To get the next batch of items in the list, call this operation again, adding the next token to the call. To get all of the items in the list, keep calling this operation with each subsequent next token that is returned, until no more next tokens are returned.
    public var nextToken: Swift.String?
    /// The criterion to be used to list build projects shared with the current Amazon Web Services account or user. Valid values include:
    ///
    /// * ARN: List based on the ARN.
    ///
    /// * MODIFIED_TIME: List based on when information about the shared project was last changed.
    public var sortBy: CodeBuildClientTypes.SharedResourceSortByType?
    /// The order in which to list shared build projects. Valid values include:
    ///
    /// * ASCENDING: List in ascending order.
    ///
    /// * DESCENDING: List in descending order.
    public var sortOrder: CodeBuildClientTypes.SortOrderType?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: CodeBuildClientTypes.SharedResourceSortByType? = nil,
        sortOrder: CodeBuildClientTypes.SortOrderType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

struct ListSharedProjectsInputBody: Swift.Equatable {
    let sortBy: CodeBuildClientTypes.SharedResourceSortByType?
    let sortOrder: CodeBuildClientTypes.SortOrderType?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListSharedProjectsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case sortBy
        case sortOrder
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortByDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.SharedResourceSortByType.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.SortOrderType.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSharedProjectsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSharedProjectsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSharedProjectsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSharedProjectsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSharedProjectsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.projects = output.projects
        } else {
            self.nextToken = nil
            self.projects = nil
        }
    }
}

public struct ListSharedProjectsOutputResponse: Swift.Equatable {
    /// During a previous call, the maximum number of items that can be returned is the value specified in maxResults. If there more items in the list, then a unique string called a nextToken is returned. To get the next batch of items in the list, call this operation again, adding the next token to the call. To get all of the items in the list, keep calling this operation with each subsequent next token that is returned, until no more next tokens are returned.
    public var nextToken: Swift.String?
    /// The list of ARNs for the build projects shared with the current Amazon Web Services account or user.
    public var projects: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        projects: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.projects = projects
    }
}

struct ListSharedProjectsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let projects: [Swift.String]?
}

extension ListSharedProjectsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case projects
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let projectsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .projects)
        var projectsDecoded0:[Swift.String]? = nil
        if let projectsContainer = projectsContainer {
            projectsDecoded0 = [Swift.String]()
            for string0 in projectsContainer {
                if let string0 = string0 {
                    projectsDecoded0?.append(string0)
                }
            }
        }
        projects = projectsDecoded0
    }
}

extension ListSharedReportGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case sortBy
        case sortOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

extension ListSharedReportGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSharedReportGroupsInput: Swift.Equatable {
    /// The maximum number of paginated shared report groups per response. Use nextToken to iterate pages in the list of returned ReportGroup objects. The default value is 100.
    public var maxResults: Swift.Int?
    /// During a previous call, the maximum number of items that can be returned is the value specified in maxResults. If there more items in the list, then a unique string called a nextToken is returned. To get the next batch of items in the list, call this operation again, adding the next token to the call. To get all of the items in the list, keep calling this operation with each subsequent next token that is returned, until no more next tokens are returned.
    public var nextToken: Swift.String?
    /// The criterion to be used to list report groups shared with the current Amazon Web Services account or user. Valid values include:
    ///
    /// * ARN: List based on the ARN.
    ///
    /// * MODIFIED_TIME: List based on when information about the shared report group was last changed.
    public var sortBy: CodeBuildClientTypes.SharedResourceSortByType?
    /// The order in which to list shared report groups. Valid values include:
    ///
    /// * ASCENDING: List in ascending order.
    ///
    /// * DESCENDING: List in descending order.
    public var sortOrder: CodeBuildClientTypes.SortOrderType?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: CodeBuildClientTypes.SharedResourceSortByType? = nil,
        sortOrder: CodeBuildClientTypes.SortOrderType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

struct ListSharedReportGroupsInputBody: Swift.Equatable {
    let sortOrder: CodeBuildClientTypes.SortOrderType?
    let sortBy: CodeBuildClientTypes.SharedResourceSortByType?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListSharedReportGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case sortBy
        case sortOrder
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortOrderDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.SortOrderType.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.SharedResourceSortByType.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListSharedReportGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSharedReportGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSharedReportGroupsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSharedReportGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSharedReportGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.reportGroups = output.reportGroups
        } else {
            self.nextToken = nil
            self.reportGroups = nil
        }
    }
}

public struct ListSharedReportGroupsOutputResponse: Swift.Equatable {
    /// During a previous call, the maximum number of items that can be returned is the value specified in maxResults. If there more items in the list, then a unique string called a nextToken is returned. To get the next batch of items in the list, call this operation again, adding the next token to the call. To get all of the items in the list, keep calling this operation with each subsequent next token that is returned, until no more next tokens are returned.
    public var nextToken: Swift.String?
    /// The list of ARNs for the report groups shared with the current Amazon Web Services account or user.
    public var reportGroups: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        reportGroups: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.reportGroups = reportGroups
    }
}

struct ListSharedReportGroupsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let reportGroups: [Swift.String]?
}

extension ListSharedReportGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case reportGroups
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let reportGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .reportGroups)
        var reportGroupsDecoded0:[Swift.String]? = nil
        if let reportGroupsContainer = reportGroupsContainer {
            reportGroupsDecoded0 = [Swift.String]()
            for string0 in reportGroupsContainer {
                if let string0 = string0 {
                    reportGroupsDecoded0?.append(string0)
                }
            }
        }
        reportGroups = reportGroupsDecoded0
    }
}

extension ListSourceCredentialsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListSourceCredentialsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSourceCredentialsInput: Swift.Equatable {

    public init () { }
}

struct ListSourceCredentialsInputBody: Swift.Equatable {
}

extension ListSourceCredentialsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSourceCredentialsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSourceCredentialsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSourceCredentialsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSourceCredentialsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSourceCredentialsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sourceCredentialsInfos = output.sourceCredentialsInfos
        } else {
            self.sourceCredentialsInfos = nil
        }
    }
}

public struct ListSourceCredentialsOutputResponse: Swift.Equatable {
    /// A list of SourceCredentialsInfo objects. Each SourceCredentialsInfo object includes the authentication type, token ARN, and type of source provider for one set of credentials.
    public var sourceCredentialsInfos: [CodeBuildClientTypes.SourceCredentialsInfo]?

    public init (
        sourceCredentialsInfos: [CodeBuildClientTypes.SourceCredentialsInfo]? = nil
    )
    {
        self.sourceCredentialsInfos = sourceCredentialsInfos
    }
}

struct ListSourceCredentialsOutputResponseBody: Swift.Equatable {
    let sourceCredentialsInfos: [CodeBuildClientTypes.SourceCredentialsInfo]?
}

extension ListSourceCredentialsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceCredentialsInfos
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceCredentialsInfosContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.SourceCredentialsInfo?].self, forKey: .sourceCredentialsInfos)
        var sourceCredentialsInfosDecoded0:[CodeBuildClientTypes.SourceCredentialsInfo]? = nil
        if let sourceCredentialsInfosContainer = sourceCredentialsInfosContainer {
            sourceCredentialsInfosDecoded0 = [CodeBuildClientTypes.SourceCredentialsInfo]()
            for structure0 in sourceCredentialsInfosContainer {
                if let structure0 = structure0 {
                    sourceCredentialsInfosDecoded0?.append(structure0)
                }
            }
        }
        sourceCredentialsInfos = sourceCredentialsInfosDecoded0
    }
}

extension CodeBuildClientTypes.LogsConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogs
        case s3Logs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogs = self.cloudWatchLogs {
            try encodeContainer.encode(cloudWatchLogs, forKey: .cloudWatchLogs)
        }
        if let s3Logs = self.s3Logs {
            try encodeContainer.encode(s3Logs, forKey: .s3Logs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLogsDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.CloudWatchLogsConfig.self, forKey: .cloudWatchLogs)
        cloudWatchLogs = cloudWatchLogsDecoded
        let s3LogsDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.S3LogsConfig.self, forKey: .s3Logs)
        s3Logs = s3LogsDecoded
    }
}

extension CodeBuildClientTypes {
    /// Information about logs for a build project. These can be logs in CloudWatch Logs, built in a specified S3 bucket, or both.
    public struct LogsConfig: Swift.Equatable {
        /// Information about CloudWatch Logs for a build project. CloudWatch Logs are enabled by default.
        public var cloudWatchLogs: CodeBuildClientTypes.CloudWatchLogsConfig?
        /// Information about logs built to an S3 bucket for a build project. S3 logs are not enabled by default.
        public var s3Logs: CodeBuildClientTypes.S3LogsConfig?

        public init (
            cloudWatchLogs: CodeBuildClientTypes.CloudWatchLogsConfig? = nil,
            s3Logs: CodeBuildClientTypes.S3LogsConfig? = nil
        )
        {
            self.cloudWatchLogs = cloudWatchLogs
            self.s3Logs = s3Logs
        }
    }

}

extension CodeBuildClientTypes {
    public enum LogsConfigStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [LogsConfigStatusType] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LogsConfigStatusType(rawValue: rawValue) ?? LogsConfigStatusType.sdkUnknown(rawValue)
        }
    }
}

extension CodeBuildClientTypes.LogsLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogs
        case cloudWatchLogsArn
        case deepLink
        case groupName
        case s3DeepLink
        case s3Logs
        case s3LogsArn
        case streamName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogs = self.cloudWatchLogs {
            try encodeContainer.encode(cloudWatchLogs, forKey: .cloudWatchLogs)
        }
        if let cloudWatchLogsArn = self.cloudWatchLogsArn {
            try encodeContainer.encode(cloudWatchLogsArn, forKey: .cloudWatchLogsArn)
        }
        if let deepLink = self.deepLink {
            try encodeContainer.encode(deepLink, forKey: .deepLink)
        }
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let s3DeepLink = self.s3DeepLink {
            try encodeContainer.encode(s3DeepLink, forKey: .s3DeepLink)
        }
        if let s3Logs = self.s3Logs {
            try encodeContainer.encode(s3Logs, forKey: .s3Logs)
        }
        if let s3LogsArn = self.s3LogsArn {
            try encodeContainer.encode(s3LogsArn, forKey: .s3LogsArn)
        }
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let deepLinkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deepLink)
        deepLink = deepLinkDecoded
        let s3DeepLinkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3DeepLink)
        s3DeepLink = s3DeepLinkDecoded
        let cloudWatchLogsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogsArn)
        cloudWatchLogsArn = cloudWatchLogsArnDecoded
        let s3LogsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3LogsArn)
        s3LogsArn = s3LogsArnDecoded
        let cloudWatchLogsDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.CloudWatchLogsConfig.self, forKey: .cloudWatchLogs)
        cloudWatchLogs = cloudWatchLogsDecoded
        let s3LogsDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.S3LogsConfig.self, forKey: .s3Logs)
        s3Logs = s3LogsDecoded
    }
}

extension CodeBuildClientTypes {
    /// Information about build logs in CloudWatch Logs.
    public struct LogsLocation: Swift.Equatable {
        /// Information about CloudWatch Logs for a build project.
        public var cloudWatchLogs: CodeBuildClientTypes.CloudWatchLogsConfig?
        /// The ARN of CloudWatch Logs for a build project. Its format is arn:${Partition}:logs:${Region}:${Account}:log-group:${LogGroupName}:log-stream:${LogStreamName}. For more information, see [Resources Defined by CloudWatch Logs](https://docs.aws.amazon.com/IAM/latest/UserGuide/list_amazoncloudwatchlogs.html#amazoncloudwatchlogs-resources-for-iam-policies).
        public var cloudWatchLogsArn: Swift.String?
        /// The URL to an individual build log in CloudWatch Logs.
        public var deepLink: Swift.String?
        /// The name of the CloudWatch Logs group for the build logs.
        public var groupName: Swift.String?
        /// The URL to a build log in an S3 bucket.
        public var s3DeepLink: Swift.String?
        /// Information about S3 logs for a build project.
        public var s3Logs: CodeBuildClientTypes.S3LogsConfig?
        /// The ARN of S3 logs for a build project. Its format is arn:${Partition}:s3:::${BucketName}/${ObjectName}. For more information, see [Resources Defined by Amazon S3](https://docs.aws.amazon.com/IAM/latest/UserGuide/list_amazons3.html#amazons3-resources-for-iam-policies).
        public var s3LogsArn: Swift.String?
        /// The name of the CloudWatch Logs stream for the build logs.
        public var streamName: Swift.String?

        public init (
            cloudWatchLogs: CodeBuildClientTypes.CloudWatchLogsConfig? = nil,
            cloudWatchLogsArn: Swift.String? = nil,
            deepLink: Swift.String? = nil,
            groupName: Swift.String? = nil,
            s3DeepLink: Swift.String? = nil,
            s3Logs: CodeBuildClientTypes.S3LogsConfig? = nil,
            s3LogsArn: Swift.String? = nil,
            streamName: Swift.String? = nil
        )
        {
            self.cloudWatchLogs = cloudWatchLogs
            self.cloudWatchLogsArn = cloudWatchLogsArn
            self.deepLink = deepLink
            self.groupName = groupName
            self.s3DeepLink = s3DeepLink
            self.s3Logs = s3Logs
            self.s3LogsArn = s3LogsArn
            self.streamName = streamName
        }
    }

}

extension CodeBuildClientTypes.NetworkInterface: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkInterfaceId
        case subnetId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let networkInterfaceId = self.networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
    }
}

extension CodeBuildClientTypes {
    /// Describes a network interface.
    public struct NetworkInterface: Swift.Equatable {
        /// The ID of the network interface.
        public var networkInterfaceId: Swift.String?
        /// The ID of the subnet.
        public var subnetId: Swift.String?

        public init (
            networkInterfaceId: Swift.String? = nil,
            subnetId: Swift.String? = nil
        )
        {
            self.networkInterfaceId = networkInterfaceId
            self.subnetId = subnetId
        }
    }

}

extension OAuthProviderException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: OAuthProviderExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There was a problem with the underlying OAuth provider.
public struct OAuthProviderException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OAuthProviderExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OAuthProviderExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeBuildClientTypes.PhaseContext: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case statusCode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let statusCode = self.statusCode {
            try encodeContainer.encode(statusCode, forKey: .statusCode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeBuildClientTypes {
    /// Additional information about a build phase that has an error. You can use this information for troubleshooting.
    public struct PhaseContext: Swift.Equatable {
        /// An explanation of the build phase's context. This might include a command ID and an exit code.
        public var message: Swift.String?
        /// The status code for the context of the build phase.
        public var statusCode: Swift.String?

        public init (
            message: Swift.String? = nil,
            statusCode: Swift.String? = nil
        )
        {
            self.message = message
            self.statusCode = statusCode
        }
    }

}

extension CodeBuildClientTypes {
    public enum PlatformType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazonLinux
        case debian
        case ubuntu
        case windowsServer
        case sdkUnknown(Swift.String)

        public static var allCases: [PlatformType] {
            return [
                .amazonLinux,
                .debian,
                .ubuntu,
                .windowsServer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazonLinux: return "AMAZON_LINUX"
            case .debian: return "DEBIAN"
            case .ubuntu: return "UBUNTU"
            case .windowsServer: return "WINDOWS_SERVER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PlatformType(rawValue: rawValue) ?? PlatformType.sdkUnknown(rawValue)
        }
    }
}

extension CodeBuildClientTypes.Project: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case artifacts
        case badge
        case buildBatchConfig
        case cache
        case concurrentBuildLimit
        case created
        case description
        case encryptionKey
        case environment
        case fileSystemLocations
        case lastModified
        case logsConfig
        case name
        case projectVisibility
        case publicProjectAlias
        case queuedTimeoutInMinutes
        case resourceAccessRole
        case secondaryArtifacts
        case secondarySourceVersions
        case secondarySources
        case serviceRole
        case source
        case sourceVersion
        case tags
        case timeoutInMinutes
        case vpcConfig
        case webhook
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let artifacts = self.artifacts {
            try encodeContainer.encode(artifacts, forKey: .artifacts)
        }
        if let badge = self.badge {
            try encodeContainer.encode(badge, forKey: .badge)
        }
        if let buildBatchConfig = self.buildBatchConfig {
            try encodeContainer.encode(buildBatchConfig, forKey: .buildBatchConfig)
        }
        if let cache = self.cache {
            try encodeContainer.encode(cache, forKey: .cache)
        }
        if let concurrentBuildLimit = self.concurrentBuildLimit {
            try encodeContainer.encode(concurrentBuildLimit, forKey: .concurrentBuildLimit)
        }
        if let created = self.created {
            try encodeContainer.encodeTimestamp(created, format: .epochSeconds, forKey: .created)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encryptionKey = self.encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let environment = self.environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let fileSystemLocations = fileSystemLocations {
            var fileSystemLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileSystemLocations)
            for projectfilesystemlocation0 in fileSystemLocations {
                try fileSystemLocationsContainer.encode(projectfilesystemlocation0)
            }
        }
        if let lastModified = self.lastModified {
            try encodeContainer.encodeTimestamp(lastModified, format: .epochSeconds, forKey: .lastModified)
        }
        if let logsConfig = self.logsConfig {
            try encodeContainer.encode(logsConfig, forKey: .logsConfig)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let projectVisibility = self.projectVisibility {
            try encodeContainer.encode(projectVisibility.rawValue, forKey: .projectVisibility)
        }
        if let publicProjectAlias = self.publicProjectAlias {
            try encodeContainer.encode(publicProjectAlias, forKey: .publicProjectAlias)
        }
        if let queuedTimeoutInMinutes = self.queuedTimeoutInMinutes {
            try encodeContainer.encode(queuedTimeoutInMinutes, forKey: .queuedTimeoutInMinutes)
        }
        if let resourceAccessRole = self.resourceAccessRole {
            try encodeContainer.encode(resourceAccessRole, forKey: .resourceAccessRole)
        }
        if let secondaryArtifacts = secondaryArtifacts {
            var secondaryArtifactsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondaryArtifacts)
            for projectartifacts0 in secondaryArtifacts {
                try secondaryArtifactsContainer.encode(projectartifacts0)
            }
        }
        if let secondarySourceVersions = secondarySourceVersions {
            var secondarySourceVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondarySourceVersions)
            for projectsourceversion0 in secondarySourceVersions {
                try secondarySourceVersionsContainer.encode(projectsourceversion0)
            }
        }
        if let secondarySources = secondarySources {
            var secondarySourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondarySources)
            for projectsource0 in secondarySources {
                try secondarySourcesContainer.encode(projectsource0)
            }
        }
        if let serviceRole = self.serviceRole {
            try encodeContainer.encode(serviceRole, forKey: .serviceRole)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let sourceVersion = self.sourceVersion {
            try encodeContainer.encode(sourceVersion, forKey: .sourceVersion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let timeoutInMinutes = self.timeoutInMinutes {
            try encodeContainer.encode(timeoutInMinutes, forKey: .timeoutInMinutes)
        }
        if let vpcConfig = self.vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
        if let webhook = self.webhook {
            try encodeContainer.encode(webhook, forKey: .webhook)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ProjectSource.self, forKey: .source)
        source = sourceDecoded
        let secondarySourcesContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.ProjectSource?].self, forKey: .secondarySources)
        var secondarySourcesDecoded0:[CodeBuildClientTypes.ProjectSource]? = nil
        if let secondarySourcesContainer = secondarySourcesContainer {
            secondarySourcesDecoded0 = [CodeBuildClientTypes.ProjectSource]()
            for structure0 in secondarySourcesContainer {
                if let structure0 = structure0 {
                    secondarySourcesDecoded0?.append(structure0)
                }
            }
        }
        secondarySources = secondarySourcesDecoded0
        let sourceVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceVersion)
        sourceVersion = sourceVersionDecoded
        let secondarySourceVersionsContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.ProjectSourceVersion?].self, forKey: .secondarySourceVersions)
        var secondarySourceVersionsDecoded0:[CodeBuildClientTypes.ProjectSourceVersion]? = nil
        if let secondarySourceVersionsContainer = secondarySourceVersionsContainer {
            secondarySourceVersionsDecoded0 = [CodeBuildClientTypes.ProjectSourceVersion]()
            for structure0 in secondarySourceVersionsContainer {
                if let structure0 = structure0 {
                    secondarySourceVersionsDecoded0?.append(structure0)
                }
            }
        }
        secondarySourceVersions = secondarySourceVersionsDecoded0
        let artifactsDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ProjectArtifacts.self, forKey: .artifacts)
        artifacts = artifactsDecoded
        let secondaryArtifactsContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.ProjectArtifacts?].self, forKey: .secondaryArtifacts)
        var secondaryArtifactsDecoded0:[CodeBuildClientTypes.ProjectArtifacts]? = nil
        if let secondaryArtifactsContainer = secondaryArtifactsContainer {
            secondaryArtifactsDecoded0 = [CodeBuildClientTypes.ProjectArtifacts]()
            for structure0 in secondaryArtifactsContainer {
                if let structure0 = structure0 {
                    secondaryArtifactsDecoded0?.append(structure0)
                }
            }
        }
        secondaryArtifacts = secondaryArtifactsDecoded0
        let cacheDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ProjectCache.self, forKey: .cache)
        cache = cacheDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ProjectEnvironment.self, forKey: .environment)
        environment = environmentDecoded
        let serviceRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRole)
        serviceRole = serviceRoleDecoded
        let timeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutInMinutes)
        timeoutInMinutes = timeoutInMinutesDecoded
        let queuedTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .queuedTimeoutInMinutes)
        queuedTimeoutInMinutes = queuedTimeoutInMinutesDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[CodeBuildClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [CodeBuildClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .created)
        created = createdDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let webhookDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.Webhook.self, forKey: .webhook)
        webhook = webhookDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let badgeDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ProjectBadge.self, forKey: .badge)
        badge = badgeDecoded
        let logsConfigDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.LogsConfig.self, forKey: .logsConfig)
        logsConfig = logsConfigDecoded
        let fileSystemLocationsContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.ProjectFileSystemLocation?].self, forKey: .fileSystemLocations)
        var fileSystemLocationsDecoded0:[CodeBuildClientTypes.ProjectFileSystemLocation]? = nil
        if let fileSystemLocationsContainer = fileSystemLocationsContainer {
            fileSystemLocationsDecoded0 = [CodeBuildClientTypes.ProjectFileSystemLocation]()
            for structure0 in fileSystemLocationsContainer {
                if let structure0 = structure0 {
                    fileSystemLocationsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemLocations = fileSystemLocationsDecoded0
        let buildBatchConfigDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ProjectBuildBatchConfig.self, forKey: .buildBatchConfig)
        buildBatchConfig = buildBatchConfigDecoded
        let concurrentBuildLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .concurrentBuildLimit)
        concurrentBuildLimit = concurrentBuildLimitDecoded
        let projectVisibilityDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ProjectVisibilityType.self, forKey: .projectVisibility)
        projectVisibility = projectVisibilityDecoded
        let publicProjectAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicProjectAlias)
        publicProjectAlias = publicProjectAliasDecoded
        let resourceAccessRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceAccessRole)
        resourceAccessRole = resourceAccessRoleDecoded
    }
}

extension CodeBuildClientTypes {
    /// Information about a build project.
    public struct Project: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the build project.
        public var arn: Swift.String?
        /// Information about the build output artifacts for the build project.
        public var artifacts: CodeBuildClientTypes.ProjectArtifacts?
        /// Information about the build badge for the build project.
        public var badge: CodeBuildClientTypes.ProjectBadge?
        /// A [ProjectBuildBatchConfig] object that defines the batch build options for the project.
        public var buildBatchConfig: CodeBuildClientTypes.ProjectBuildBatchConfig?
        /// Information about the cache for the build project.
        public var cache: CodeBuildClientTypes.ProjectCache?
        /// The maximum number of concurrent builds that are allowed for this project. New builds are only started if the current number of builds is less than or equal to this limit. If the current build count meets this limit, new builds are throttled and are not run.
        public var concurrentBuildLimit: Swift.Int?
        /// When the build project was created, expressed in Unix time format.
        public var created: ClientRuntime.Date?
        /// A description that makes the build project easy to identify.
        public var description: Swift.String?
        /// The Key Management Service customer master key (CMK) to be used for encrypting the build output artifacts. You can use a cross-account KMS key to encrypt the build output artifacts if your service role has permission to that key. You can specify either the Amazon Resource Name (ARN) of the CMK or, if available, the CMK's alias (using the format alias/). If you don't specify a value, CodeBuild uses the managed CMK for Amazon Simple Storage Service (Amazon S3).
        public var encryptionKey: Swift.String?
        /// Information about the build environment for this build project.
        public var environment: CodeBuildClientTypes.ProjectEnvironment?
        /// An array of ProjectFileSystemLocation objects for a CodeBuild build project. A ProjectFileSystemLocation object specifies the identifier, location, mountOptions, mountPoint, and type of a file system created using Amazon Elastic File System.
        public var fileSystemLocations: [CodeBuildClientTypes.ProjectFileSystemLocation]?
        /// When the build project's settings were last modified, expressed in Unix time format.
        public var lastModified: ClientRuntime.Date?
        /// Information about logs for the build project. A project can create logs in CloudWatch Logs, an S3 bucket, or both.
        public var logsConfig: CodeBuildClientTypes.LogsConfig?
        /// The name of the build project.
        public var name: Swift.String?
        /// Specifies the visibility of the project's builds. Possible values are: PUBLIC_READ The project builds are visible to the public. PRIVATE The project builds are not visible to the public.
        public var projectVisibility: CodeBuildClientTypes.ProjectVisibilityType?
        /// Contains the project identifier used with the public build APIs.
        public var publicProjectAlias: Swift.String?
        /// The number of minutes a build is allowed to be queued before it times out.
        public var queuedTimeoutInMinutes: Swift.Int?
        /// The ARN of the IAM role that enables CodeBuild to access the CloudWatch Logs and Amazon S3 artifacts for the project's builds.
        public var resourceAccessRole: Swift.String?
        /// An array of ProjectArtifacts objects.
        public var secondaryArtifacts: [CodeBuildClientTypes.ProjectArtifacts]?
        /// An array of ProjectSourceVersion objects. If secondarySourceVersions is specified at the build level, then they take over these secondarySourceVersions (at the project level).
        public var secondarySourceVersions: [CodeBuildClientTypes.ProjectSourceVersion]?
        /// An array of ProjectSource objects.
        public var secondarySources: [CodeBuildClientTypes.ProjectSource]?
        /// The ARN of the IAM role that enables CodeBuild to interact with dependent Amazon Web Services services on behalf of the Amazon Web Services account.
        public var serviceRole: Swift.String?
        /// Information about the build input source code for this build project.
        public var source: CodeBuildClientTypes.ProjectSource?
        /// A version of the build input to be built for this project. If not specified, the latest version is used. If specified, it must be one of:
        ///
        /// * For CodeCommit: the commit ID, branch, or Git tag to use.
        ///
        /// * For GitHub: the commit ID, pull request ID, branch name, or tag name that corresponds to the version of the source code you want to build. If a pull request ID is specified, it must use the format pr/pull-request-ID (for example pr/25). If a branch name is specified, the branch's HEAD commit ID is used. If not specified, the default branch's HEAD commit ID is used.
        ///
        /// * For Bitbucket: the commit ID, branch name, or tag name that corresponds to the version of the source code you want to build. If a branch name is specified, the branch's HEAD commit ID is used. If not specified, the default branch's HEAD commit ID is used.
        ///
        /// * For Amazon S3: the version ID of the object that represents the build input ZIP file to use.
        ///
        ///
        /// If sourceVersion is specified at the build level, then that version takes precedence over this sourceVersion (at the project level). For more information, see [Source Version Sample with CodeBuild](https://docs.aws.amazon.com/codebuild/latest/userguide/sample-source-version.html) in the CodeBuild User Guide.
        public var sourceVersion: Swift.String?
        /// A list of tag key and value pairs associated with this build project. These tags are available for use by Amazon Web Services services that support CodeBuild build project tags.
        public var tags: [CodeBuildClientTypes.Tag]?
        /// How long, in minutes, from 5 to 480 (8 hours), for CodeBuild to wait before timing out any related build that did not get marked as completed. The default is 60 minutes.
        public var timeoutInMinutes: Swift.Int?
        /// Information about the VPC configuration that CodeBuild accesses.
        public var vpcConfig: CodeBuildClientTypes.VpcConfig?
        /// Information about a webhook that connects repository events to a build project in CodeBuild.
        public var webhook: CodeBuildClientTypes.Webhook?

        public init (
            arn: Swift.String? = nil,
            artifacts: CodeBuildClientTypes.ProjectArtifacts? = nil,
            badge: CodeBuildClientTypes.ProjectBadge? = nil,
            buildBatchConfig: CodeBuildClientTypes.ProjectBuildBatchConfig? = nil,
            cache: CodeBuildClientTypes.ProjectCache? = nil,
            concurrentBuildLimit: Swift.Int? = nil,
            created: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            encryptionKey: Swift.String? = nil,
            environment: CodeBuildClientTypes.ProjectEnvironment? = nil,
            fileSystemLocations: [CodeBuildClientTypes.ProjectFileSystemLocation]? = nil,
            lastModified: ClientRuntime.Date? = nil,
            logsConfig: CodeBuildClientTypes.LogsConfig? = nil,
            name: Swift.String? = nil,
            projectVisibility: CodeBuildClientTypes.ProjectVisibilityType? = nil,
            publicProjectAlias: Swift.String? = nil,
            queuedTimeoutInMinutes: Swift.Int? = nil,
            resourceAccessRole: Swift.String? = nil,
            secondaryArtifacts: [CodeBuildClientTypes.ProjectArtifacts]? = nil,
            secondarySourceVersions: [CodeBuildClientTypes.ProjectSourceVersion]? = nil,
            secondarySources: [CodeBuildClientTypes.ProjectSource]? = nil,
            serviceRole: Swift.String? = nil,
            source: CodeBuildClientTypes.ProjectSource? = nil,
            sourceVersion: Swift.String? = nil,
            tags: [CodeBuildClientTypes.Tag]? = nil,
            timeoutInMinutes: Swift.Int? = nil,
            vpcConfig: CodeBuildClientTypes.VpcConfig? = nil,
            webhook: CodeBuildClientTypes.Webhook? = nil
        )
        {
            self.arn = arn
            self.artifacts = artifacts
            self.badge = badge
            self.buildBatchConfig = buildBatchConfig
            self.cache = cache
            self.concurrentBuildLimit = concurrentBuildLimit
            self.created = created
            self.description = description
            self.encryptionKey = encryptionKey
            self.environment = environment
            self.fileSystemLocations = fileSystemLocations
            self.lastModified = lastModified
            self.logsConfig = logsConfig
            self.name = name
            self.projectVisibility = projectVisibility
            self.publicProjectAlias = publicProjectAlias
            self.queuedTimeoutInMinutes = queuedTimeoutInMinutes
            self.resourceAccessRole = resourceAccessRole
            self.secondaryArtifacts = secondaryArtifacts
            self.secondarySourceVersions = secondarySourceVersions
            self.secondarySources = secondarySources
            self.serviceRole = serviceRole
            self.source = source
            self.sourceVersion = sourceVersion
            self.tags = tags
            self.timeoutInMinutes = timeoutInMinutes
            self.vpcConfig = vpcConfig
            self.webhook = webhook
        }
    }

}

extension CodeBuildClientTypes.ProjectArtifacts: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifactIdentifier
        case bucketOwnerAccess
        case encryptionDisabled
        case location
        case name
        case namespaceType
        case overrideArtifactName
        case packaging
        case path
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactIdentifier = self.artifactIdentifier {
            try encodeContainer.encode(artifactIdentifier, forKey: .artifactIdentifier)
        }
        if let bucketOwnerAccess = self.bucketOwnerAccess {
            try encodeContainer.encode(bucketOwnerAccess.rawValue, forKey: .bucketOwnerAccess)
        }
        if let encryptionDisabled = self.encryptionDisabled {
            try encodeContainer.encode(encryptionDisabled, forKey: .encryptionDisabled)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let namespaceType = self.namespaceType {
            try encodeContainer.encode(namespaceType.rawValue, forKey: .namespaceType)
        }
        if let overrideArtifactName = self.overrideArtifactName {
            try encodeContainer.encode(overrideArtifactName, forKey: .overrideArtifactName)
        }
        if let packaging = self.packaging {
            try encodeContainer.encode(packaging.rawValue, forKey: .packaging)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ArtifactsType.self, forKey: .type)
        type = typeDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let namespaceTypeDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ArtifactNamespace.self, forKey: .namespaceType)
        namespaceType = namespaceTypeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let packagingDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ArtifactPackaging.self, forKey: .packaging)
        packaging = packagingDecoded
        let overrideArtifactNameDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .overrideArtifactName)
        overrideArtifactName = overrideArtifactNameDecoded
        let encryptionDisabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encryptionDisabled)
        encryptionDisabled = encryptionDisabledDecoded
        let artifactIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .artifactIdentifier)
        artifactIdentifier = artifactIdentifierDecoded
        let bucketOwnerAccessDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.BucketOwnerAccess.self, forKey: .bucketOwnerAccess)
        bucketOwnerAccess = bucketOwnerAccessDecoded
    }
}

extension CodeBuildClientTypes {
    /// Information about the build output artifacts for the build project.
    public struct ProjectArtifacts: Swift.Equatable {
        /// An identifier for this artifact definition.
        public var artifactIdentifier: Swift.String?
        /// Specifies the bucket owner's access for objects that another account uploads to their Amazon S3 bucket. By default, only the account that uploads the objects to the bucket has access to these objects. This property allows you to give the bucket owner access to these objects. To use this property, your CodeBuild service role must have the s3:PutBucketAcl permission. This permission allows CodeBuild to modify the access control list for the bucket. This property can be one of the following values: NONE The bucket owner does not have access to the objects. This is the default. READ_ONLY The bucket owner has read-only access to the objects. The uploading account retains ownership of the objects. FULL The bucket owner has full access to the objects. Object ownership is determined by the following criteria:
        ///
        /// * If the bucket is configured with the Bucket owner preferred setting, the bucket owner owns the objects. The uploading account will have object access as specified by the bucket's policy.
        ///
        /// * Otherwise, the uploading account retains ownership of the objects.
        ///
        ///
        /// For more information about Amazon S3 object ownership, see [Controlling ownership of uploaded objects using S3 Object Ownership](https://docs.aws.amazon.com/AmazonS3/latest/userguide/about-object-ownership.html) in the Amazon Simple Storage Service User Guide.
        public var bucketOwnerAccess: CodeBuildClientTypes.BucketOwnerAccess?
        /// Set to true if you do not want your output artifacts encrypted. This option is valid only if your artifacts type is Amazon S3. If this is set with another artifacts type, an invalidInputException is thrown.
        public var encryptionDisabled: Swift.Bool?
        /// Information about the build output artifact location:
        ///
        /// * If type is set to CODEPIPELINE, CodePipeline ignores this value if specified. This is because CodePipeline manages its build output locations instead of CodeBuild.
        ///
        /// * If type is set to NO_ARTIFACTS, this value is ignored if specified, because no build output is produced.
        ///
        /// * If type is set to S3, this is the name of the output bucket.
        public var location: Swift.String?
        /// Along with path and namespaceType, the pattern that CodeBuild uses to name and store the output artifact:
        ///
        /// * If type is set to CODEPIPELINE, CodePipeline ignores this value if specified. This is because CodePipeline manages its build output names instead of CodeBuild.
        ///
        /// * If type is set to NO_ARTIFACTS, this value is ignored if specified, because no build output is produced.
        ///
        /// * If type is set to S3, this is the name of the output artifact object. If you set the name to be a forward slash ("/"), the artifact is stored in the root of the output bucket.
        ///
        ///
        /// For example:
        ///
        /// * If path is set to MyArtifacts, namespaceType is set to BUILD_ID, and name is set to MyArtifact.zip, then the output artifact is stored in MyArtifacts//MyArtifact.zip.
        ///
        /// * If path is empty, namespaceType is set to NONE, and name is set to "/", the output artifact is stored in the root of the output bucket.
        ///
        /// * If path is set to MyArtifacts, namespaceType is set to BUILD_ID, and name is set to "/", the output artifact is stored in MyArtifacts/.
        public var name: Swift.String?
        /// Along with path and name, the pattern that CodeBuild uses to determine the name and location to store the output artifact:
        ///
        /// * If type is set to CODEPIPELINE, CodePipeline ignores this value if specified. This is because CodePipeline manages its build output names instead of CodeBuild.
        ///
        /// * If type is set to NO_ARTIFACTS, this value is ignored if specified, because no build output is produced.
        ///
        /// * If type is set to S3, valid values include:
        ///
        /// * BUILD_ID: Include the build ID in the location of the build output artifact.
        ///
        /// * NONE: Do not include the build ID. This is the default if namespaceType is not specified.
        ///
        ///
        ///
        ///
        ///
        /// For example, if path is set to MyArtifacts, namespaceType is set to BUILD_ID, and name is set to MyArtifact.zip, the output artifact is stored in MyArtifacts//MyArtifact.zip.
        public var namespaceType: CodeBuildClientTypes.ArtifactNamespace?
        /// If this flag is set, a name specified in the buildspec file overrides the artifact name. The name specified in a buildspec file is calculated at build time and uses the Shell Command Language. For example, you can append a date and time to your artifact name so that it is always unique.
        public var overrideArtifactName: Swift.Bool?
        /// The type of build output artifact to create:
        ///
        /// * If type is set to CODEPIPELINE, CodePipeline ignores this value if specified. This is because CodePipeline manages its build output artifacts instead of CodeBuild.
        ///
        /// * If type is set to NO_ARTIFACTS, this value is ignored if specified, because no build output is produced.
        ///
        /// * If type is set to S3, valid values include:
        ///
        /// * NONE: CodeBuild creates in the output bucket a folder that contains the build output. This is the default if packaging is not specified.
        ///
        /// * ZIP: CodeBuild creates in the output bucket a ZIP file that contains the build output.
        public var packaging: CodeBuildClientTypes.ArtifactPackaging?
        /// Along with namespaceType and name, the pattern that CodeBuild uses to name and store the output artifact:
        ///
        /// * If type is set to CODEPIPELINE, CodePipeline ignores this value if specified. This is because CodePipeline manages its build output names instead of CodeBuild.
        ///
        /// * If type is set to NO_ARTIFACTS, this value is ignored if specified, because no build output is produced.
        ///
        /// * If type is set to S3, this is the path to the output artifact. If path is not specified, path is not used.
        ///
        ///
        /// For example, if path is set to MyArtifacts, namespaceType is set to NONE, and name is set to MyArtifact.zip, the output artifact is stored in the output bucket at MyArtifacts/MyArtifact.zip.
        public var path: Swift.String?
        /// The type of build output artifact. Valid values include:
        ///
        /// * CODEPIPELINE: The build project has build output generated through CodePipeline. The CODEPIPELINE type is not supported for secondaryArtifacts.
        ///
        /// * NO_ARTIFACTS: The build project does not produce any build output.
        ///
        /// * S3: The build project stores build output in Amazon S3.
        /// This member is required.
        public var type: CodeBuildClientTypes.ArtifactsType?

        public init (
            artifactIdentifier: Swift.String? = nil,
            bucketOwnerAccess: CodeBuildClientTypes.BucketOwnerAccess? = nil,
            encryptionDisabled: Swift.Bool? = nil,
            location: Swift.String? = nil,
            name: Swift.String? = nil,
            namespaceType: CodeBuildClientTypes.ArtifactNamespace? = nil,
            overrideArtifactName: Swift.Bool? = nil,
            packaging: CodeBuildClientTypes.ArtifactPackaging? = nil,
            path: Swift.String? = nil,
            type: CodeBuildClientTypes.ArtifactsType? = nil
        )
        {
            self.artifactIdentifier = artifactIdentifier
            self.bucketOwnerAccess = bucketOwnerAccess
            self.encryptionDisabled = encryptionDisabled
            self.location = location
            self.name = name
            self.namespaceType = namespaceType
            self.overrideArtifactName = overrideArtifactName
            self.packaging = packaging
            self.path = path
            self.type = type
        }
    }

}

extension CodeBuildClientTypes.ProjectBadge: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case badgeEnabled
        case badgeRequestUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if badgeEnabled != false {
            try encodeContainer.encode(badgeEnabled, forKey: .badgeEnabled)
        }
        if let badgeRequestUrl = self.badgeRequestUrl {
            try encodeContainer.encode(badgeRequestUrl, forKey: .badgeRequestUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let badgeEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .badgeEnabled) ?? false
        badgeEnabled = badgeEnabledDecoded
        let badgeRequestUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .badgeRequestUrl)
        badgeRequestUrl = badgeRequestUrlDecoded
    }
}

extension CodeBuildClientTypes {
    /// Information about the build badge for the build project.
    public struct ProjectBadge: Swift.Equatable {
        /// Set this to true to generate a publicly accessible URL for your project's build badge.
        public var badgeEnabled: Swift.Bool
        /// The publicly-accessible URL through which you can access the build badge for your project.
        public var badgeRequestUrl: Swift.String?

        public init (
            badgeEnabled: Swift.Bool = false,
            badgeRequestUrl: Swift.String? = nil
        )
        {
            self.badgeEnabled = badgeEnabled
            self.badgeRequestUrl = badgeRequestUrl
        }
    }

}

extension CodeBuildClientTypes.ProjectBuildBatchConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchReportMode
        case combineArtifacts
        case restrictions
        case serviceRole
        case timeoutInMins
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchReportMode = self.batchReportMode {
            try encodeContainer.encode(batchReportMode.rawValue, forKey: .batchReportMode)
        }
        if let combineArtifacts = self.combineArtifacts {
            try encodeContainer.encode(combineArtifacts, forKey: .combineArtifacts)
        }
        if let restrictions = self.restrictions {
            try encodeContainer.encode(restrictions, forKey: .restrictions)
        }
        if let serviceRole = self.serviceRole {
            try encodeContainer.encode(serviceRole, forKey: .serviceRole)
        }
        if let timeoutInMins = self.timeoutInMins {
            try encodeContainer.encode(timeoutInMins, forKey: .timeoutInMins)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRole)
        serviceRole = serviceRoleDecoded
        let combineArtifactsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .combineArtifacts)
        combineArtifacts = combineArtifactsDecoded
        let restrictionsDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.BatchRestrictions.self, forKey: .restrictions)
        restrictions = restrictionsDecoded
        let timeoutInMinsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutInMins)
        timeoutInMins = timeoutInMinsDecoded
        let batchReportModeDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.BatchReportModeType.self, forKey: .batchReportMode)
        batchReportMode = batchReportModeDecoded
    }
}

extension CodeBuildClientTypes {
    /// Contains configuration information about a batch build project.
    public struct ProjectBuildBatchConfig: Swift.Equatable {
        /// Specifies how build status reports are sent to the source provider for the batch build. This property is only used when the source provider for your project is Bitbucket, GitHub, or GitHub Enterprise, and your project is configured to report build statuses to the source provider. REPORT_AGGREGATED_BATCH (Default) Aggregate all of the build statuses into a single status report. REPORT_INDIVIDUAL_BUILDS Send a separate status report for each individual build.
        public var batchReportMode: CodeBuildClientTypes.BatchReportModeType?
        /// Specifies if the build artifacts for the batch build should be combined into a single artifact location.
        public var combineArtifacts: Swift.Bool?
        /// A BatchRestrictions object that specifies the restrictions for the batch build.
        public var restrictions: CodeBuildClientTypes.BatchRestrictions?
        /// Specifies the service role ARN for the batch build project.
        public var serviceRole: Swift.String?
        /// Specifies the maximum amount of time, in minutes, that the batch build must be completed in.
        public var timeoutInMins: Swift.Int?

        public init (
            batchReportMode: CodeBuildClientTypes.BatchReportModeType? = nil,
            combineArtifacts: Swift.Bool? = nil,
            restrictions: CodeBuildClientTypes.BatchRestrictions? = nil,
            serviceRole: Swift.String? = nil,
            timeoutInMins: Swift.Int? = nil
        )
        {
            self.batchReportMode = batchReportMode
            self.combineArtifacts = combineArtifacts
            self.restrictions = restrictions
            self.serviceRole = serviceRole
            self.timeoutInMins = timeoutInMins
        }
    }

}

extension CodeBuildClientTypes.ProjectCache: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case location
        case modes
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let modes = modes {
            var modesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .modes)
            for cachemode0 in modes {
                try modesContainer.encode(cachemode0.rawValue)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.CacheType.self, forKey: .type)
        type = typeDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let modesContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.CacheMode?].self, forKey: .modes)
        var modesDecoded0:[CodeBuildClientTypes.CacheMode]? = nil
        if let modesContainer = modesContainer {
            modesDecoded0 = [CodeBuildClientTypes.CacheMode]()
            for string0 in modesContainer {
                if let string0 = string0 {
                    modesDecoded0?.append(string0)
                }
            }
        }
        modes = modesDecoded0
    }
}

extension CodeBuildClientTypes {
    /// Information about the cache for the build project.
    public struct ProjectCache: Swift.Equatable {
        /// Information about the cache location:
        ///
        /// * NO_CACHE or LOCAL: This value is ignored.
        ///
        /// * S3: This is the S3 bucket name/prefix.
        public var location: Swift.String?
        /// An array of strings that specify the local cache modes. You can use one or more local cache modes at the same time. This is only used for LOCAL cache types. Possible values are: LOCAL_SOURCE_CACHE Caches Git metadata for primary and secondary sources. After the cache is created, subsequent builds pull only the change between commits. This mode is a good choice for projects with a clean working directory and a source that is a large Git repository. If you choose this option and your project does not use a Git repository (GitHub, GitHub Enterprise, or Bitbucket), the option is ignored. LOCAL_DOCKER_LAYER_CACHE Caches existing Docker layers. This mode is a good choice for projects that build or pull large Docker images. It can prevent the performance issues caused by pulling large Docker images down from the network.
        ///
        /// * You can use a Docker layer cache in the Linux environment only.
        ///
        /// * The privileged flag must be set so that your project has the required Docker permissions.
        ///
        /// * You should consider the security implications before you use a Docker layer cache.
        ///
        ///
        /// LOCAL_CUSTOM_CACHE Caches directories you specify in the buildspec file. This mode is a good choice if your build scenario is not suited to one of the other three local cache modes. If you use a custom cache:
        ///
        /// * Only directories can be specified for caching. You cannot specify individual files.
        ///
        /// * Symlinks are used to reference cached directories.
        ///
        /// * Cached directories are linked to your build before it downloads its project sources. Cached items are overridden if a source item has the same name. Directories are specified using cache paths in the buildspec file.
        public var modes: [CodeBuildClientTypes.CacheMode]?
        /// The type of cache used by the build project. Valid values include:
        ///
        /// * NO_CACHE: The build project does not use any cache.
        ///
        /// * S3: The build project reads and writes from and to S3.
        ///
        /// * LOCAL: The build project stores a cache locally on a build host that is only available to that build host.
        /// This member is required.
        public var type: CodeBuildClientTypes.CacheType?

        public init (
            location: Swift.String? = nil,
            modes: [CodeBuildClientTypes.CacheMode]? = nil,
            type: CodeBuildClientTypes.CacheType? = nil
        )
        {
            self.location = location
            self.modes = modes
            self.type = type
        }
    }

}

extension CodeBuildClientTypes.ProjectEnvironment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate
        case computeType
        case environmentVariables
        case image
        case imagePullCredentialsType
        case privilegedMode
        case registryCredential
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificate = self.certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let computeType = self.computeType {
            try encodeContainer.encode(computeType.rawValue, forKey: .computeType)
        }
        if let environmentVariables = environmentVariables {
            var environmentVariablesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .environmentVariables)
            for environmentvariable0 in environmentVariables {
                try environmentVariablesContainer.encode(environmentvariable0)
            }
        }
        if let image = self.image {
            try encodeContainer.encode(image, forKey: .image)
        }
        if let imagePullCredentialsType = self.imagePullCredentialsType {
            try encodeContainer.encode(imagePullCredentialsType.rawValue, forKey: .imagePullCredentialsType)
        }
        if let privilegedMode = self.privilegedMode {
            try encodeContainer.encode(privilegedMode, forKey: .privilegedMode)
        }
        if let registryCredential = self.registryCredential {
            try encodeContainer.encode(registryCredential, forKey: .registryCredential)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.EnvironmentType.self, forKey: .type)
        type = typeDecoded
        let imageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .image)
        image = imageDecoded
        let computeTypeDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ComputeType.self, forKey: .computeType)
        computeType = computeTypeDecoded
        let environmentVariablesContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.EnvironmentVariable?].self, forKey: .environmentVariables)
        var environmentVariablesDecoded0:[CodeBuildClientTypes.EnvironmentVariable]? = nil
        if let environmentVariablesContainer = environmentVariablesContainer {
            environmentVariablesDecoded0 = [CodeBuildClientTypes.EnvironmentVariable]()
            for structure0 in environmentVariablesContainer {
                if let structure0 = structure0 {
                    environmentVariablesDecoded0?.append(structure0)
                }
            }
        }
        environmentVariables = environmentVariablesDecoded0
        let privilegedModeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .privilegedMode)
        privilegedMode = privilegedModeDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
        let registryCredentialDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.RegistryCredential.self, forKey: .registryCredential)
        registryCredential = registryCredentialDecoded
        let imagePullCredentialsTypeDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ImagePullCredentialsType.self, forKey: .imagePullCredentialsType)
        imagePullCredentialsType = imagePullCredentialsTypeDecoded
    }
}

extension CodeBuildClientTypes {
    /// Information about the build environment of the build project.
    public struct ProjectEnvironment: Swift.Equatable {
        /// The ARN of the Amazon S3 bucket, path prefix, and object key that contains the PEM-encoded certificate for the build project. For more information, see [certificate](https://docs.aws.amazon.com/codebuild/latest/userguide/create-project-cli.html#cli.environment.certificate) in the CodeBuild User Guide.
        public var certificate: Swift.String?
        /// Information about the compute resources the build project uses. Available values include:
        ///
        /// * BUILD_GENERAL1_SMALL: Use up to 3 GB memory and 2 vCPUs for builds.
        ///
        /// * BUILD_GENERAL1_MEDIUM: Use up to 7 GB memory and 4 vCPUs for builds.
        ///
        /// * BUILD_GENERAL1_LARGE: Use up to 16 GB memory and 8 vCPUs for builds, depending on your environment type.
        ///
        /// * BUILD_GENERAL1_2XLARGE: Use up to 145 GB memory, 72 vCPUs, and 824 GB of SSD storage for builds. This compute type supports Docker images up to 100 GB uncompressed.
        ///
        ///
        /// If you use BUILD_GENERAL1_LARGE:
        ///
        /// * For environment type LINUX_CONTAINER, you can use up to 15 GB memory and 8 vCPUs for builds.
        ///
        /// * For environment type LINUX_GPU_CONTAINER, you can use up to 255 GB memory, 32 vCPUs, and 4 NVIDIA Tesla V100 GPUs for builds.
        ///
        /// * For environment type ARM_CONTAINER, you can use up to 16 GB memory and 8 vCPUs on ARM-based processors for builds.
        ///
        ///
        /// For more information, see [Build Environment Compute Types](https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref-compute-types.html) in the CodeBuild User Guide.
        /// This member is required.
        public var computeType: CodeBuildClientTypes.ComputeType?
        /// A set of environment variables to make available to builds for this build project.
        public var environmentVariables: [CodeBuildClientTypes.EnvironmentVariable]?
        /// The image tag or image digest that identifies the Docker image to use for this build project. Use the following formats:
        ///
        /// * For an image tag: /:. For example, in the Docker repository that CodeBuild uses to manage its Docker images, this would be aws/codebuild/standard:4.0.
        ///
        /// * For an image digest: /@. For example, to specify an image with the digest "sha256:cbbf2f9a99b47fc460d422812b6a5adff7dfee951d8fa2e4a98caa0382cfbdbf," use /@sha256:cbbf2f9a99b47fc460d422812b6a5adff7dfee951d8fa2e4a98caa0382cfbdbf.
        ///
        ///
        /// For more information, see [Docker images provided by CodeBuild](https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref-available.html) in the CodeBuild user guide.
        /// This member is required.
        public var image: Swift.String?
        /// The type of credentials CodeBuild uses to pull images in your build. There are two valid values:
        ///
        /// * CODEBUILD specifies that CodeBuild uses its own credentials. This requires that you modify your ECR repository policy to trust CodeBuild service principal.
        ///
        /// * SERVICE_ROLE specifies that CodeBuild uses your build project's service role.
        ///
        ///
        /// When you use a cross-account or private registry image, you must use SERVICE_ROLE credentials. When you use an CodeBuild curated image, you must use CODEBUILD credentials.
        public var imagePullCredentialsType: CodeBuildClientTypes.ImagePullCredentialsType?
        /// Enables running the Docker daemon inside a Docker container. Set to true only if the build project is used to build Docker images. Otherwise, a build that attempts to interact with the Docker daemon fails. The default setting is false. You can initialize the Docker daemon during the install phase of your build by adding one of the following sets of commands to the install phase of your buildspec file: If the operating system's base image is Ubuntu Linux: - nohup /usr/local/bin/dockerd --host=unix:///var/run/docker.sock --host=tcp://0.0.0.0:2375 --storage-driver=overlay&- timeout 15 sh -c "until docker info; do echo .; sleep 1; done" If the operating system's base image is Alpine Linux and the previous command does not work, add the -t argument to timeout: - nohup /usr/local/bin/dockerd --host=unix:///var/run/docker.sock --host=tcp://0.0.0.0:2375 --storage-driver=overlay&
        ///     - timeout -t 15 sh -c "until docker info; do echo .; sleep 1; done"
        public var privilegedMode: Swift.Bool?
        /// The credentials for access to a private registry.
        public var registryCredential: CodeBuildClientTypes.RegistryCredential?
        /// The type of build environment to use for related builds.
        ///
        /// * The environment type ARM_CONTAINER is available only in regions US East (N. Virginia), US East (Ohio), US West (Oregon), EU (Ireland), Asia Pacific (Mumbai), Asia Pacific (Tokyo), Asia Pacific (Sydney), and EU (Frankfurt).
        ///
        /// * The environment type LINUX_CONTAINER with compute type build.general1.2xlarge is available only in regions US East (N. Virginia), US East (Ohio), US West (Oregon), Canada (Central), EU (Ireland), EU (London), EU (Frankfurt), Asia Pacific (Tokyo), Asia Pacific (Seoul), Asia Pacific (Singapore), Asia Pacific (Sydney), China (Beijing), and China (Ningxia).
        ///
        /// * The environment type LINUX_GPU_CONTAINER is available only in regions US East (N. Virginia), US East (Ohio), US West (Oregon), Canada (Central), EU (Ireland), EU (London), EU (Frankfurt), Asia Pacific (Tokyo), Asia Pacific (Seoul), Asia Pacific (Singapore), Asia Pacific (Sydney) , China (Beijing), and China (Ningxia).
        ///
        ///
        ///
        ///
        /// * The environment types WINDOWS_CONTAINER and WINDOWS_SERVER_2019_CONTAINER are available only in regions US East (N. Virginia), US East (Ohio), US West (Oregon), and EU (Ireland).
        ///
        ///
        /// For more information, see [Build environment compute types](https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref-compute-types.html) in the CodeBuild user guide.
        /// This member is required.
        public var type: CodeBuildClientTypes.EnvironmentType?

        public init (
            certificate: Swift.String? = nil,
            computeType: CodeBuildClientTypes.ComputeType? = nil,
            environmentVariables: [CodeBuildClientTypes.EnvironmentVariable]? = nil,
            image: Swift.String? = nil,
            imagePullCredentialsType: CodeBuildClientTypes.ImagePullCredentialsType? = nil,
            privilegedMode: Swift.Bool? = nil,
            registryCredential: CodeBuildClientTypes.RegistryCredential? = nil,
            type: CodeBuildClientTypes.EnvironmentType? = nil
        )
        {
            self.certificate = certificate
            self.computeType = computeType
            self.environmentVariables = environmentVariables
            self.image = image
            self.imagePullCredentialsType = imagePullCredentialsType
            self.privilegedMode = privilegedMode
            self.registryCredential = registryCredential
            self.type = type
        }
    }

}

extension CodeBuildClientTypes.ProjectFileSystemLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
        case location
        case mountOptions
        case mountPoint
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let mountOptions = self.mountOptions {
            try encodeContainer.encode(mountOptions, forKey: .mountOptions)
        }
        if let mountPoint = self.mountPoint {
            try encodeContainer.encode(mountPoint, forKey: .mountPoint)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.FileSystemType.self, forKey: .type)
        type = typeDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let mountPointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mountPoint)
        mountPoint = mountPointDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let mountOptionsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mountOptions)
        mountOptions = mountOptionsDecoded
    }
}

extension CodeBuildClientTypes {
    /// Information about a file system created by Amazon Elastic File System (EFS). For more information, see [What Is Amazon Elastic File System?](https://docs.aws.amazon.com/efs/latest/ug/whatisefs.html)
    public struct ProjectFileSystemLocation: Swift.Equatable {
        /// The name used to access a file system created by Amazon EFS. CodeBuild creates an environment variable by appending the identifier in all capital letters to CODEBUILD_. For example, if you specify my_efs for identifier, a new environment variable is create named CODEBUILD_MY_EFS. The identifier is used to mount your file system.
        public var identifier: Swift.String?
        /// A string that specifies the location of the file system created by Amazon EFS. Its format is efs-dns-name:/directory-path. You can find the DNS name of file system when you view it in the Amazon EFS console. The directory path is a path to a directory in the file system that CodeBuild mounts. For example, if the DNS name of a file system is fs-abcd1234.efs.us-west-2.amazonaws.com, and its mount directory is my-efs-mount-directory, then the location is fs-abcd1234.efs.us-west-2.amazonaws.com:/my-efs-mount-directory. The directory path in the format efs-dns-name:/directory-path is optional. If you do not specify a directory path, the location is only the DNS name and CodeBuild mounts the entire file system.
        public var location: Swift.String?
        /// The mount options for a file system created by Amazon EFS. The default mount options used by CodeBuild are nfsvers=4.1,rsize=1048576,wsize=1048576,hard,timeo=600,retrans=2. For more information, see [Recommended NFS Mount Options](https://docs.aws.amazon.com/efs/latest/ug/mounting-fs-nfs-mount-settings.html).
        public var mountOptions: Swift.String?
        /// The location in the container where you mount the file system.
        public var mountPoint: Swift.String?
        /// The type of the file system. The one supported type is EFS.
        public var type: CodeBuildClientTypes.FileSystemType?

        public init (
            identifier: Swift.String? = nil,
            location: Swift.String? = nil,
            mountOptions: Swift.String? = nil,
            mountPoint: Swift.String? = nil,
            type: CodeBuildClientTypes.FileSystemType? = nil
        )
        {
            self.identifier = identifier
            self.location = location
            self.mountOptions = mountOptions
            self.mountPoint = mountPoint
            self.type = type
        }
    }

}

extension CodeBuildClientTypes {
    public enum ProjectSortByType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createdTime
        case lastModifiedTime
        case name
        case sdkUnknown(Swift.String)

        public static var allCases: [ProjectSortByType] {
            return [
                .createdTime,
                .lastModifiedTime,
                .name,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createdTime: return "CREATED_TIME"
            case .lastModifiedTime: return "LAST_MODIFIED_TIME"
            case .name: return "NAME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProjectSortByType(rawValue: rawValue) ?? ProjectSortByType.sdkUnknown(rawValue)
        }
    }
}

extension CodeBuildClientTypes.ProjectSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auth
        case buildStatusConfig
        case buildspec
        case gitCloneDepth
        case gitSubmodulesConfig
        case insecureSsl
        case location
        case reportBuildStatus
        case sourceIdentifier
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auth = self.auth {
            try encodeContainer.encode(auth, forKey: .auth)
        }
        if let buildStatusConfig = self.buildStatusConfig {
            try encodeContainer.encode(buildStatusConfig, forKey: .buildStatusConfig)
        }
        if let buildspec = self.buildspec {
            try encodeContainer.encode(buildspec, forKey: .buildspec)
        }
        if let gitCloneDepth = self.gitCloneDepth {
            try encodeContainer.encode(gitCloneDepth, forKey: .gitCloneDepth)
        }
        if let gitSubmodulesConfig = self.gitSubmodulesConfig {
            try encodeContainer.encode(gitSubmodulesConfig, forKey: .gitSubmodulesConfig)
        }
        if let insecureSsl = self.insecureSsl {
            try encodeContainer.encode(insecureSsl, forKey: .insecureSsl)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let reportBuildStatus = self.reportBuildStatus {
            try encodeContainer.encode(reportBuildStatus, forKey: .reportBuildStatus)
        }
        if let sourceIdentifier = self.sourceIdentifier {
            try encodeContainer.encode(sourceIdentifier, forKey: .sourceIdentifier)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.SourceType.self, forKey: .type)
        type = typeDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let gitCloneDepthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .gitCloneDepth)
        gitCloneDepth = gitCloneDepthDecoded
        let gitSubmodulesConfigDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.GitSubmodulesConfig.self, forKey: .gitSubmodulesConfig)
        gitSubmodulesConfig = gitSubmodulesConfigDecoded
        let buildspecDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .buildspec)
        buildspec = buildspecDecoded
        let authDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.SourceAuth.self, forKey: .auth)
        auth = authDecoded
        let reportBuildStatusDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .reportBuildStatus)
        reportBuildStatus = reportBuildStatusDecoded
        let buildStatusConfigDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.BuildStatusConfig.self, forKey: .buildStatusConfig)
        buildStatusConfig = buildStatusConfigDecoded
        let insecureSslDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .insecureSsl)
        insecureSsl = insecureSslDecoded
        let sourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceIdentifier)
        sourceIdentifier = sourceIdentifierDecoded
    }
}

extension CodeBuildClientTypes {
    /// Information about the build input source code for the build project.
    public struct ProjectSource: Swift.Equatable {
        /// Information about the authorization settings for CodeBuild to access the source code to be built. This information is for the CodeBuild console's use only. Your code should not get or set this information directly.
        public var auth: CodeBuildClientTypes.SourceAuth?
        /// Contains information that defines how the build project reports the build status to the source provider. This option is only used when the source provider is GITHUB, GITHUB_ENTERPRISE, or BITBUCKET.
        public var buildStatusConfig: CodeBuildClientTypes.BuildStatusConfig?
        /// The buildspec file declaration to use for the builds in this build project. If this value is set, it can be either an inline buildspec definition, the path to an alternate buildspec file relative to the value of the built-in CODEBUILD_SRC_DIR environment variable, or the path to an S3 bucket. The bucket must be in the same Amazon Web Services Region as the build project. Specify the buildspec file using its ARN (for example, arn:aws:s3:::my-codebuild-sample2/buildspec.yml). If this value is not provided or is set to an empty string, the source code must contain a buildspec file in its root directory. For more information, see [Buildspec File Name and Storage Location](https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html#build-spec-ref-name-storage).
        public var buildspec: Swift.String?
        /// Information about the Git clone depth for the build project.
        public var gitCloneDepth: Swift.Int?
        /// Information about the Git submodules configuration for the build project.
        public var gitSubmodulesConfig: CodeBuildClientTypes.GitSubmodulesConfig?
        /// Enable this flag to ignore SSL warnings while connecting to the project source code.
        public var insecureSsl: Swift.Bool?
        /// Information about the location of the source code to be built. Valid values include:
        ///
        /// * For source code settings that are specified in the source action of a pipeline in CodePipeline, location should not be specified. If it is specified, CodePipeline ignores it. This is because CodePipeline uses the settings in a pipeline's source action instead of this value.
        ///
        /// * For source code in an CodeCommit repository, the HTTPS clone URL to the repository that contains the source code and the buildspec file (for example, https://git-codecommit..amazonaws.com/v1/repos/).
        ///
        /// * For source code in an Amazon S3 input bucket, one of the following.
        ///
        /// * The path to the ZIP file that contains the source code (for example, //.zip).
        ///
        /// * The path to the folder that contains the source code (for example, ///).
        ///
        ///
        ///
        ///
        /// * For source code in a GitHub repository, the HTTPS clone URL to the repository that contains the source and the buildspec file. You must connect your Amazon Web Services account to your GitHub account. Use the CodeBuild console to start creating a build project. When you use the console to connect (or reconnect) with GitHub, on the GitHub Authorize application page, for Organization access, choose Request access next to each repository you want to allow CodeBuild to have access to, and then choose Authorize application. (After you have connected to your GitHub account, you do not need to finish creating the build project. You can leave the CodeBuild console.) To instruct CodeBuild to use this connection, in the source object, set the auth object's type value to OAUTH.
        ///
        /// * For source code in a Bitbucket repository, the HTTPS clone URL to the repository that contains the source and the buildspec file. You must connect your Amazon Web Services account to your Bitbucket account. Use the CodeBuild console to start creating a build project. When you use the console to connect (or reconnect) with Bitbucket, on the Bitbucket Confirm access to your account page, choose Grant access. (After you have connected to your Bitbucket account, you do not need to finish creating the build project. You can leave the CodeBuild console.) To instruct CodeBuild to use this connection, in the source object, set the auth object's type value to OAUTH.
        ///
        ///
        /// If you specify CODEPIPELINE for the Type property, don't specify this property. For all of the other types, you must specify Location.
        public var location: Swift.String?
        /// Set to true to report the status of a build's start and finish to your source provider. This option is valid only when your source provider is GitHub, GitHub Enterprise, or Bitbucket. If this is set and you use a different source provider, an invalidInputException is thrown. To be able to report the build status to the source provider, the user associated with the source provider must have write access to the repo. If the user does not have write access, the build status cannot be updated. For more information, see [Source provider access](https://docs.aws.amazon.com/codebuild/latest/userguide/access-tokens.html) in the CodeBuild User Guide. The status of a build triggered by a webhook is always reported to your source provider. If your project's builds are triggered by a webhook, you must push a new commit to the repo for a change to this property to take effect.
        public var reportBuildStatus: Swift.Bool?
        /// An identifier for this project source. The identifier can only contain alphanumeric characters and underscores, and must be less than 128 characters in length.
        public var sourceIdentifier: Swift.String?
        /// The type of repository that contains the source code to be built. Valid values include:
        ///
        /// * BITBUCKET: The source code is in a Bitbucket repository.
        ///
        /// * CODECOMMIT: The source code is in an CodeCommit repository.
        ///
        /// * CODEPIPELINE: The source code settings are specified in the source action of a pipeline in CodePipeline.
        ///
        /// * GITHUB: The source code is in a GitHub or GitHub Enterprise Cloud repository.
        ///
        /// * GITHUB_ENTERPRISE: The source code is in a GitHub Enterprise Server repository.
        ///
        /// * NO_SOURCE: The project does not have input source code.
        ///
        /// * S3: The source code is in an Amazon S3 bucket.
        /// This member is required.
        public var type: CodeBuildClientTypes.SourceType?

        public init (
            auth: CodeBuildClientTypes.SourceAuth? = nil,
            buildStatusConfig: CodeBuildClientTypes.BuildStatusConfig? = nil,
            buildspec: Swift.String? = nil,
            gitCloneDepth: Swift.Int? = nil,
            gitSubmodulesConfig: CodeBuildClientTypes.GitSubmodulesConfig? = nil,
            insecureSsl: Swift.Bool? = nil,
            location: Swift.String? = nil,
            reportBuildStatus: Swift.Bool? = nil,
            sourceIdentifier: Swift.String? = nil,
            type: CodeBuildClientTypes.SourceType? = nil
        )
        {
            self.auth = auth
            self.buildStatusConfig = buildStatusConfig
            self.buildspec = buildspec
            self.gitCloneDepth = gitCloneDepth
            self.gitSubmodulesConfig = gitSubmodulesConfig
            self.insecureSsl = insecureSsl
            self.location = location
            self.reportBuildStatus = reportBuildStatus
            self.sourceIdentifier = sourceIdentifier
            self.type = type
        }
    }

}

extension CodeBuildClientTypes.ProjectSourceVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceIdentifier
        case sourceVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceIdentifier = self.sourceIdentifier {
            try encodeContainer.encode(sourceIdentifier, forKey: .sourceIdentifier)
        }
        if let sourceVersion = self.sourceVersion {
            try encodeContainer.encode(sourceVersion, forKey: .sourceVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceIdentifier)
        sourceIdentifier = sourceIdentifierDecoded
        let sourceVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceVersion)
        sourceVersion = sourceVersionDecoded
    }
}

extension CodeBuildClientTypes {
    /// A source identifier and its corresponding version.
    public struct ProjectSourceVersion: Swift.Equatable {
        /// An identifier for a source in the build project. The identifier can only contain alphanumeric characters and underscores, and must be less than 128 characters in length.
        /// This member is required.
        public var sourceIdentifier: Swift.String?
        /// The source version for the corresponding source identifier. If specified, must be one of:
        ///
        /// * For CodeCommit: the commit ID, branch, or Git tag to use.
        ///
        /// * For GitHub: the commit ID, pull request ID, branch name, or tag name that corresponds to the version of the source code you want to build. If a pull request ID is specified, it must use the format pr/pull-request-ID (for example, pr/25). If a branch name is specified, the branch's HEAD commit ID is used. If not specified, the default branch's HEAD commit ID is used.
        ///
        /// * For Bitbucket: the commit ID, branch name, or tag name that corresponds to the version of the source code you want to build. If a branch name is specified, the branch's HEAD commit ID is used. If not specified, the default branch's HEAD commit ID is used.
        ///
        /// * For Amazon S3: the version ID of the object that represents the build input ZIP file to use.
        ///
        ///
        /// For more information, see [Source Version Sample with CodeBuild](https://docs.aws.amazon.com/codebuild/latest/userguide/sample-source-version.html) in the CodeBuild User Guide.
        /// This member is required.
        public var sourceVersion: Swift.String?

        public init (
            sourceIdentifier: Swift.String? = nil,
            sourceVersion: Swift.String? = nil
        )
        {
            self.sourceIdentifier = sourceIdentifier
            self.sourceVersion = sourceVersion
        }
    }

}

extension CodeBuildClientTypes {
    /// Specifies the visibility of the project's builds. Possible values are: PUBLIC_READ The project builds are visible to the public. PRIVATE The project builds are not visible to the public.
    public enum ProjectVisibilityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `private`
        case publicRead
        case sdkUnknown(Swift.String)

        public static var allCases: [ProjectVisibilityType] {
            return [
                .private,
                .publicRead,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .private: return "PRIVATE"
            case .publicRead: return "PUBLIC_READ"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProjectVisibilityType(rawValue: rawValue) ?? ProjectVisibilityType.sdkUnknown(rawValue)
        }
    }
}

extension PutResourcePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension PutResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutResourcePolicyInput: Swift.Equatable {
    /// A JSON-formatted resource policy. For more information, see [Sharing a Project](https://docs.aws.amazon.com/codebuild/latest/userguide/project-sharing.html#project-sharing-share) and [Sharing a Report Group](https://docs.aws.amazon.com/codebuild/latest/userguide/report-groups-sharing.html#report-groups-sharing-share) in the CodeBuild User Guide.
    /// This member is required.
    public var policy: Swift.String?
    /// The ARN of the Project or ReportGroup resource you want to associate with a resource policy.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        policy: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.policy = policy
        self.resourceArn = resourceArn
    }
}

struct PutResourcePolicyInputBody: Swift.Equatable {
    let policy: Swift.String?
    let resourceArn: Swift.String?
}

extension PutResourcePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
        case resourceArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension PutResourcePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutResourcePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutResourcePolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutResourcePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutResourcePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourceArn = output.resourceArn
        } else {
            self.resourceArn = nil
        }
    }
}

public struct PutResourcePolicyOutputResponse: Swift.Equatable {
    /// The ARN of the Project or ReportGroup resource that is associated with a resource policy.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct PutResourcePolicyOutputResponseBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension PutResourcePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension CodeBuildClientTypes.RegistryCredential: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credential
        case credentialProvider
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let credential = self.credential {
            try encodeContainer.encode(credential, forKey: .credential)
        }
        if let credentialProvider = self.credentialProvider {
            try encodeContainer.encode(credentialProvider.rawValue, forKey: .credentialProvider)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let credentialDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credential)
        credential = credentialDecoded
        let credentialProviderDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.CredentialProviderType.self, forKey: .credentialProvider)
        credentialProvider = credentialProviderDecoded
    }
}

extension CodeBuildClientTypes {
    /// Information about credentials that provide access to a private Docker registry. When this is set:
    ///
    /// * imagePullCredentialsType must be set to SERVICE_ROLE.
    ///
    /// * images cannot be curated or an Amazon ECR image.
    ///
    ///
    /// For more information, see [Private Registry with Secrets Manager Sample for CodeBuild](https://docs.aws.amazon.com/codebuild/latest/userguide/sample-private-registry.html).
    public struct RegistryCredential: Swift.Equatable {
        /// The Amazon Resource Name (ARN) or name of credentials created using Secrets Manager. The credential can use the name of the credentials only if they exist in your current Amazon Web Services Region.
        /// This member is required.
        public var credential: Swift.String?
        /// The service that created the credentials to access a private Docker registry. The valid value, SECRETS_MANAGER, is for Secrets Manager.
        /// This member is required.
        public var credentialProvider: CodeBuildClientTypes.CredentialProviderType?

        public init (
            credential: Swift.String? = nil,
            credentialProvider: CodeBuildClientTypes.CredentialProviderType? = nil
        )
        {
            self.credential = credential
            self.credentialProvider = credentialProvider
        }
    }

}

extension CodeBuildClientTypes.Report: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case codeCoverageSummary
        case created
        case executionId
        case expired
        case exportConfig
        case name
        case reportGroupArn
        case status
        case testSummary
        case truncated
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let codeCoverageSummary = self.codeCoverageSummary {
            try encodeContainer.encode(codeCoverageSummary, forKey: .codeCoverageSummary)
        }
        if let created = self.created {
            try encodeContainer.encodeTimestamp(created, format: .epochSeconds, forKey: .created)
        }
        if let executionId = self.executionId {
            try encodeContainer.encode(executionId, forKey: .executionId)
        }
        if let expired = self.expired {
            try encodeContainer.encodeTimestamp(expired, format: .epochSeconds, forKey: .expired)
        }
        if let exportConfig = self.exportConfig {
            try encodeContainer.encode(exportConfig, forKey: .exportConfig)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let reportGroupArn = self.reportGroupArn {
            try encodeContainer.encode(reportGroupArn, forKey: .reportGroupArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let testSummary = self.testSummary {
            try encodeContainer.encode(testSummary, forKey: .testSummary)
        }
        if let truncated = self.truncated {
            try encodeContainer.encode(truncated, forKey: .truncated)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ReportType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let reportGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportGroupArn)
        reportGroupArn = reportGroupArnDecoded
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ReportStatusType.self, forKey: .status)
        status = statusDecoded
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .created)
        created = createdDecoded
        let expiredDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expired)
        expired = expiredDecoded
        let exportConfigDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ReportExportConfig.self, forKey: .exportConfig)
        exportConfig = exportConfigDecoded
        let truncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .truncated)
        truncated = truncatedDecoded
        let testSummaryDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.TestReportSummary.self, forKey: .testSummary)
        testSummary = testSummaryDecoded
        let codeCoverageSummaryDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.CodeCoverageReportSummary.self, forKey: .codeCoverageSummary)
        codeCoverageSummary = codeCoverageSummaryDecoded
    }
}

extension CodeBuildClientTypes {
    /// Information about the results from running a series of test cases during the run of a build project. The test cases are specified in the buildspec for the build project using one or more paths to the test case files. You can specify any type of tests you want, such as unit tests, integration tests, and functional tests.
    public struct Report: Swift.Equatable {
        /// The ARN of the report run.
        public var arn: Swift.String?
        /// A CodeCoverageReportSummary object that contains a code coverage summary for this report.
        public var codeCoverageSummary: CodeBuildClientTypes.CodeCoverageReportSummary?
        /// The date and time this report run occurred.
        public var created: ClientRuntime.Date?
        /// The ARN of the build run that generated this report.
        public var executionId: Swift.String?
        /// The date and time a report expires. A report expires 30 days after it is created. An expired report is not available to view in CodeBuild.
        public var expired: ClientRuntime.Date?
        /// Information about where the raw data used to generate this report was exported.
        public var exportConfig: CodeBuildClientTypes.ReportExportConfig?
        /// The name of the report that was run.
        public var name: Swift.String?
        /// The ARN of the report group associated with this report.
        public var reportGroupArn: Swift.String?
        /// The status of this report.
        public var status: CodeBuildClientTypes.ReportStatusType?
        /// A TestReportSummary object that contains information about this test report.
        public var testSummary: CodeBuildClientTypes.TestReportSummary?
        /// A boolean that specifies if this report run is truncated. The list of test cases is truncated after the maximum number of test cases is reached.
        public var truncated: Swift.Bool?
        /// The type of the report that was run. CODE_COVERAGE A code coverage report. TEST A test report.
        public var type: CodeBuildClientTypes.ReportType?

        public init (
            arn: Swift.String? = nil,
            codeCoverageSummary: CodeBuildClientTypes.CodeCoverageReportSummary? = nil,
            created: ClientRuntime.Date? = nil,
            executionId: Swift.String? = nil,
            expired: ClientRuntime.Date? = nil,
            exportConfig: CodeBuildClientTypes.ReportExportConfig? = nil,
            name: Swift.String? = nil,
            reportGroupArn: Swift.String? = nil,
            status: CodeBuildClientTypes.ReportStatusType? = nil,
            testSummary: CodeBuildClientTypes.TestReportSummary? = nil,
            truncated: Swift.Bool? = nil,
            type: CodeBuildClientTypes.ReportType? = nil
        )
        {
            self.arn = arn
            self.codeCoverageSummary = codeCoverageSummary
            self.created = created
            self.executionId = executionId
            self.expired = expired
            self.exportConfig = exportConfig
            self.name = name
            self.reportGroupArn = reportGroupArn
            self.status = status
            self.testSummary = testSummary
            self.truncated = truncated
            self.type = type
        }
    }

}

extension CodeBuildClientTypes {
    public enum ReportCodeCoverageSortByType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case filePath
        case lineCoveragePercentage
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportCodeCoverageSortByType] {
            return [
                .filePath,
                .lineCoveragePercentage,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .filePath: return "FILE_PATH"
            case .lineCoveragePercentage: return "LINE_COVERAGE_PERCENTAGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReportCodeCoverageSortByType(rawValue: rawValue) ?? ReportCodeCoverageSortByType.sdkUnknown(rawValue)
        }
    }
}

extension CodeBuildClientTypes.ReportExportConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportConfigType
        case s3Destination
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exportConfigType = self.exportConfigType {
            try encodeContainer.encode(exportConfigType.rawValue, forKey: .exportConfigType)
        }
        if let s3Destination = self.s3Destination {
            try encodeContainer.encode(s3Destination, forKey: .s3Destination)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportConfigTypeDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ReportExportConfigType.self, forKey: .exportConfigType)
        exportConfigType = exportConfigTypeDecoded
        let s3DestinationDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.S3ReportExportConfig.self, forKey: .s3Destination)
        s3Destination = s3DestinationDecoded
    }
}

extension CodeBuildClientTypes {
    /// Information about the location where the run of a report is exported.
    public struct ReportExportConfig: Swift.Equatable {
        /// The export configuration type. Valid values are:
        ///
        /// * S3: The report results are exported to an S3 bucket.
        ///
        /// * NO_EXPORT: The report results are not exported.
        public var exportConfigType: CodeBuildClientTypes.ReportExportConfigType?
        /// A S3ReportExportConfig object that contains information about the S3 bucket where the run of a report is exported.
        public var s3Destination: CodeBuildClientTypes.S3ReportExportConfig?

        public init (
            exportConfigType: CodeBuildClientTypes.ReportExportConfigType? = nil,
            s3Destination: CodeBuildClientTypes.S3ReportExportConfig? = nil
        )
        {
            self.exportConfigType = exportConfigType
            self.s3Destination = s3Destination
        }
    }

}

extension CodeBuildClientTypes {
    public enum ReportExportConfigType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case noExport
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportExportConfigType] {
            return [
                .noExport,
                .s3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .noExport: return "NO_EXPORT"
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReportExportConfigType(rawValue: rawValue) ?? ReportExportConfigType.sdkUnknown(rawValue)
        }
    }
}

extension CodeBuildClientTypes.ReportFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ReportStatusType.self, forKey: .status)
        status = statusDecoded
    }
}

extension CodeBuildClientTypes {
    /// A filter used to return reports with the status specified by the input status parameter.
    public struct ReportFilter: Swift.Equatable {
        /// The status used to filter reports. You can filter using one status only.
        public var status: CodeBuildClientTypes.ReportStatusType?

        public init (
            status: CodeBuildClientTypes.ReportStatusType? = nil
        )
        {
            self.status = status
        }
    }

}

extension CodeBuildClientTypes.ReportGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case created
        case exportConfig
        case lastModified
        case name
        case status
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let created = self.created {
            try encodeContainer.encodeTimestamp(created, format: .epochSeconds, forKey: .created)
        }
        if let exportConfig = self.exportConfig {
            try encodeContainer.encode(exportConfig, forKey: .exportConfig)
        }
        if let lastModified = self.lastModified {
            try encodeContainer.encodeTimestamp(lastModified, format: .epochSeconds, forKey: .lastModified)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ReportType.self, forKey: .type)
        type = typeDecoded
        let exportConfigDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ReportExportConfig.self, forKey: .exportConfig)
        exportConfig = exportConfigDecoded
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .created)
        created = createdDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[CodeBuildClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [CodeBuildClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ReportGroupStatusType.self, forKey: .status)
        status = statusDecoded
    }
}

extension CodeBuildClientTypes {
    /// A series of reports. Each report contains information about the results from running a series of test cases. You specify the test cases for a report group in the buildspec for a build project using one or more paths to the test case files.
    public struct ReportGroup: Swift.Equatable {
        /// The ARN of the ReportGroup.
        public var arn: Swift.String?
        /// The date and time this ReportGroup was created.
        public var created: ClientRuntime.Date?
        /// Information about the destination where the raw data of this ReportGroup is exported.
        public var exportConfig: CodeBuildClientTypes.ReportExportConfig?
        /// The date and time this ReportGroup was last modified.
        public var lastModified: ClientRuntime.Date?
        /// The name of the ReportGroup.
        public var name: Swift.String?
        /// The status of the report group. This property is read-only. This can be one of the following values: ACTIVE The report group is active. DELETING The report group is in the process of being deleted.
        public var status: CodeBuildClientTypes.ReportGroupStatusType?
        /// A list of tag key and value pairs associated with this report group. These tags are available for use by Amazon Web Services services that support CodeBuild report group tags.
        public var tags: [CodeBuildClientTypes.Tag]?
        /// The type of the ReportGroup. This can be one of the following values: CODE_COVERAGE The report group contains code coverage reports. TEST The report group contains test reports.
        public var type: CodeBuildClientTypes.ReportType?

        public init (
            arn: Swift.String? = nil,
            created: ClientRuntime.Date? = nil,
            exportConfig: CodeBuildClientTypes.ReportExportConfig? = nil,
            lastModified: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: CodeBuildClientTypes.ReportGroupStatusType? = nil,
            tags: [CodeBuildClientTypes.Tag]? = nil,
            type: CodeBuildClientTypes.ReportType? = nil
        )
        {
            self.arn = arn
            self.created = created
            self.exportConfig = exportConfig
            self.lastModified = lastModified
            self.name = name
            self.status = status
            self.tags = tags
            self.type = type
        }
    }

}

extension CodeBuildClientTypes {
    public enum ReportGroupSortByType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createdTime
        case lastModifiedTime
        case name
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportGroupSortByType] {
            return [
                .createdTime,
                .lastModifiedTime,
                .name,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createdTime: return "CREATED_TIME"
            case .lastModifiedTime: return "LAST_MODIFIED_TIME"
            case .name: return "NAME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReportGroupSortByType(rawValue: rawValue) ?? ReportGroupSortByType.sdkUnknown(rawValue)
        }
    }
}

extension CodeBuildClientTypes {
    public enum ReportGroupStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportGroupStatusType] {
            return [
                .active,
                .deleting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReportGroupStatusType(rawValue: rawValue) ?? ReportGroupStatusType.sdkUnknown(rawValue)
        }
    }
}

extension CodeBuildClientTypes {
    public enum ReportGroupTrendFieldType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case branchesCovered
        case branchesMissed
        case branchCoverage
        case duration
        case linesCovered
        case linesMissed
        case lineCoverage
        case passRate
        case total
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportGroupTrendFieldType] {
            return [
                .branchesCovered,
                .branchesMissed,
                .branchCoverage,
                .duration,
                .linesCovered,
                .linesMissed,
                .lineCoverage,
                .passRate,
                .total,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .branchesCovered: return "BRANCHES_COVERED"
            case .branchesMissed: return "BRANCHES_MISSED"
            case .branchCoverage: return "BRANCH_COVERAGE"
            case .duration: return "DURATION"
            case .linesCovered: return "LINES_COVERED"
            case .linesMissed: return "LINES_MISSED"
            case .lineCoverage: return "LINE_COVERAGE"
            case .passRate: return "PASS_RATE"
            case .total: return "TOTAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReportGroupTrendFieldType(rawValue: rawValue) ?? ReportGroupTrendFieldType.sdkUnknown(rawValue)
        }
    }
}

extension CodeBuildClientTypes.ReportGroupTrendStats: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case average
        case max
        case min
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let average = self.average {
            try encodeContainer.encode(average, forKey: .average)
        }
        if let max = self.max {
            try encodeContainer.encode(max, forKey: .max)
        }
        if let min = self.min {
            try encodeContainer.encode(min, forKey: .min)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let averageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .average)
        average = averageDecoded
        let maxDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .max)
        max = maxDecoded
        let minDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .min)
        min = minDecoded
    }
}

extension CodeBuildClientTypes {
    /// Contains trend statistics for a set of reports. The actual values depend on the type of trend being collected. For more information, see .
    public struct ReportGroupTrendStats: Swift.Equatable {
        /// Contains the average of all values analyzed.
        public var average: Swift.String?
        /// Contains the maximum value analyzed.
        public var max: Swift.String?
        /// Contains the minimum value analyzed.
        public var min: Swift.String?

        public init (
            average: Swift.String? = nil,
            max: Swift.String? = nil,
            min: Swift.String? = nil
        )
        {
            self.average = average
            self.max = max
            self.min = min
        }
    }

}

extension CodeBuildClientTypes {
    public enum ReportPackagingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case zip
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportPackagingType] {
            return [
                .none,
                .zip,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .zip: return "ZIP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReportPackagingType(rawValue: rawValue) ?? ReportPackagingType.sdkUnknown(rawValue)
        }
    }
}

extension CodeBuildClientTypes {
    public enum ReportStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleting
        case failed
        case generating
        case incomplete
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportStatusType] {
            return [
                .deleting,
                .failed,
                .generating,
                .incomplete,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .generating: return "GENERATING"
            case .incomplete: return "INCOMPLETE"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReportStatusType(rawValue: rawValue) ?? ReportStatusType.sdkUnknown(rawValue)
        }
    }
}

extension CodeBuildClientTypes {
    public enum ReportType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case codeCoverage
        case test
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportType] {
            return [
                .codeCoverage,
                .test,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .codeCoverage: return "CODE_COVERAGE"
            case .test: return "TEST"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReportType(rawValue: rawValue) ?? ReportType.sdkUnknown(rawValue)
        }
    }
}

extension CodeBuildClientTypes.ReportWithRawData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case data
        case reportArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = self.data {
            try encodeContainer.encode(data, forKey: .data)
        }
        if let reportArn = self.reportArn {
            try encodeContainer.encode(reportArn, forKey: .reportArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportArn)
        reportArn = reportArnDecoded
        let dataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .data)
        data = dataDecoded
    }
}

extension CodeBuildClientTypes {
    /// Contains the unmodified data for the report. For more information, see .
    public struct ReportWithRawData: Swift.Equatable {
        /// The value of the requested data field from the report.
        public var data: Swift.String?
        /// The ARN of the report.
        public var reportArn: Swift.String?

        public init (
            data: Swift.String? = nil,
            reportArn: Swift.String? = nil
        )
        {
            self.data = data
            self.reportArn = reportArn
        }
    }

}

extension CodeBuildClientTypes.ResolvedArtifact: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
        case location
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ArtifactsType.self, forKey: .type)
        type = typeDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
    }
}

extension CodeBuildClientTypes {
    /// Represents a resolved build artifact. A resolved artifact is an artifact that is built and deployed to the destination, such as Amazon S3.
    public struct ResolvedArtifact: Swift.Equatable {
        /// The identifier of the artifact.
        public var identifier: Swift.String?
        /// The location of the artifact.
        public var location: Swift.String?
        /// Specifies the type of artifact.
        public var type: CodeBuildClientTypes.ArtifactsType?

        public init (
            identifier: Swift.String? = nil,
            location: Swift.String? = nil,
            type: CodeBuildClientTypes.ArtifactsType? = nil
        )
        {
            self.identifier = identifier
            self.location = location
            self.type = type
        }
    }

}

extension ResourceAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified Amazon Web Services resource cannot be created, because an Amazon Web Services resource with the same settings already exists.
public struct ResourceAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified Amazon Web Services resource cannot be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RetryBuildBatchInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case idempotencyToken
        case retryType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let retryType = self.retryType {
            try encodeContainer.encode(retryType.rawValue, forKey: .retryType)
        }
    }
}

extension RetryBuildBatchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RetryBuildBatchInput: Swift.Equatable {
    /// Specifies the identifier of the batch build to restart.
    public var id: Swift.String?
    /// A unique, case sensitive identifier you provide to ensure the idempotency of the RetryBuildBatch request. The token is included in the RetryBuildBatch request and is valid for five minutes. If you repeat the RetryBuildBatch request with the same token, but change a parameter, CodeBuild returns a parameter mismatch error.
    public var idempotencyToken: Swift.String?
    /// Specifies the type of retry to perform.
    public var retryType: CodeBuildClientTypes.RetryBuildBatchType?

    public init (
        id: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        retryType: CodeBuildClientTypes.RetryBuildBatchType? = nil
    )
    {
        self.id = id
        self.idempotencyToken = idempotencyToken
        self.retryType = retryType
    }
}

struct RetryBuildBatchInputBody: Swift.Equatable {
    let id: Swift.String?
    let idempotencyToken: Swift.String?
    let retryType: CodeBuildClientTypes.RetryBuildBatchType?
}

extension RetryBuildBatchInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case idempotencyToken
        case retryType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let retryTypeDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.RetryBuildBatchType.self, forKey: .retryType)
        retryType = retryTypeDecoded
    }
}

extension RetryBuildBatchOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RetryBuildBatchOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RetryBuildBatchOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RetryBuildBatchOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RetryBuildBatchOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.buildBatch = output.buildBatch
        } else {
            self.buildBatch = nil
        }
    }
}

public struct RetryBuildBatchOutputResponse: Swift.Equatable {
    /// Contains information about a batch build.
    public var buildBatch: CodeBuildClientTypes.BuildBatch?

    public init (
        buildBatch: CodeBuildClientTypes.BuildBatch? = nil
    )
    {
        self.buildBatch = buildBatch
    }
}

struct RetryBuildBatchOutputResponseBody: Swift.Equatable {
    let buildBatch: CodeBuildClientTypes.BuildBatch?
}

extension RetryBuildBatchOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case buildBatch
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let buildBatchDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.BuildBatch.self, forKey: .buildBatch)
        buildBatch = buildBatchDecoded
    }
}

extension CodeBuildClientTypes {
    public enum RetryBuildBatchType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case retryAllBuilds
        case retryFailedBuilds
        case sdkUnknown(Swift.String)

        public static var allCases: [RetryBuildBatchType] {
            return [
                .retryAllBuilds,
                .retryFailedBuilds,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .retryAllBuilds: return "RETRY_ALL_BUILDS"
            case .retryFailedBuilds: return "RETRY_FAILED_BUILDS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RetryBuildBatchType(rawValue: rawValue) ?? RetryBuildBatchType.sdkUnknown(rawValue)
        }
    }
}

extension RetryBuildInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case idempotencyToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
    }
}

extension RetryBuildInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RetryBuildInput: Swift.Equatable {
    /// Specifies the identifier of the build to restart.
    public var id: Swift.String?
    /// A unique, case sensitive identifier you provide to ensure the idempotency of the RetryBuild request. The token is included in the RetryBuild request and is valid for five minutes. If you repeat the RetryBuild request with the same token, but change a parameter, CodeBuild returns a parameter mismatch error.
    public var idempotencyToken: Swift.String?

    public init (
        id: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil
    )
    {
        self.id = id
        self.idempotencyToken = idempotencyToken
    }
}

struct RetryBuildInputBody: Swift.Equatable {
    let id: Swift.String?
    let idempotencyToken: Swift.String?
}

extension RetryBuildInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case idempotencyToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension RetryBuildOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RetryBuildOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccountLimitExceededException" : self = .accountLimitExceededException(try AccountLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RetryBuildOutputError: Swift.Error, Swift.Equatable {
    case accountLimitExceededException(AccountLimitExceededException)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RetryBuildOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RetryBuildOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.build = output.build
        } else {
            self.build = nil
        }
    }
}

public struct RetryBuildOutputResponse: Swift.Equatable {
    /// Information about a build.
    public var build: CodeBuildClientTypes.Build?

    public init (
        build: CodeBuildClientTypes.Build? = nil
    )
    {
        self.build = build
    }
}

struct RetryBuildOutputResponseBody: Swift.Equatable {
    let build: CodeBuildClientTypes.Build?
}

extension RetryBuildOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case build
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let buildDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.Build.self, forKey: .build)
        build = buildDecoded
    }
}

extension CodeBuildClientTypes.S3LogsConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketOwnerAccess
        case encryptionDisabled
        case location
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketOwnerAccess = self.bucketOwnerAccess {
            try encodeContainer.encode(bucketOwnerAccess.rawValue, forKey: .bucketOwnerAccess)
        }
        if let encryptionDisabled = self.encryptionDisabled {
            try encodeContainer.encode(encryptionDisabled, forKey: .encryptionDisabled)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.LogsConfigStatusType.self, forKey: .status)
        status = statusDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let encryptionDisabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encryptionDisabled)
        encryptionDisabled = encryptionDisabledDecoded
        let bucketOwnerAccessDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.BucketOwnerAccess.self, forKey: .bucketOwnerAccess)
        bucketOwnerAccess = bucketOwnerAccessDecoded
    }
}

extension CodeBuildClientTypes {
    /// Information about S3 logs for a build project.
    public struct S3LogsConfig: Swift.Equatable {
        /// Specifies the bucket owner's access for objects that another account uploads to their Amazon S3 bucket. By default, only the account that uploads the objects to the bucket has access to these objects. This property allows you to give the bucket owner access to these objects. To use this property, your CodeBuild service role must have the s3:PutBucketAcl permission. This permission allows CodeBuild to modify the access control list for the bucket. This property can be one of the following values: NONE The bucket owner does not have access to the objects. This is the default. READ_ONLY The bucket owner has read-only access to the objects. The uploading account retains ownership of the objects. FULL The bucket owner has full access to the objects. Object ownership is determined by the following criteria:
        ///
        /// * If the bucket is configured with the Bucket owner preferred setting, the bucket owner owns the objects. The uploading account will have object access as specified by the bucket's policy.
        ///
        /// * Otherwise, the uploading account retains ownership of the objects.
        ///
        ///
        /// For more information about Amazon S3 object ownership, see [Controlling ownership of uploaded objects using S3 Object Ownership](https://docs.aws.amazon.com/AmazonS3/latest/userguide/about-object-ownership.html) in the Amazon Simple Storage Service User Guide.
        public var bucketOwnerAccess: CodeBuildClientTypes.BucketOwnerAccess?
        /// Set to true if you do not want your S3 build log output encrypted. By default S3 build logs are encrypted.
        public var encryptionDisabled: Swift.Bool?
        /// The ARN of an S3 bucket and the path prefix for S3 logs. If your Amazon S3 bucket name is my-bucket, and your path prefix is build-log, then acceptable formats are my-bucket/build-log or arn:aws:s3:::my-bucket/build-log.
        public var location: Swift.String?
        /// The current status of the S3 build logs. Valid values are:
        ///
        /// * ENABLED: S3 build logs are enabled for this build project.
        ///
        /// * DISABLED: S3 build logs are not enabled for this build project.
        /// This member is required.
        public var status: CodeBuildClientTypes.LogsConfigStatusType?

        public init (
            bucketOwnerAccess: CodeBuildClientTypes.BucketOwnerAccess? = nil,
            encryptionDisabled: Swift.Bool? = nil,
            location: Swift.String? = nil,
            status: CodeBuildClientTypes.LogsConfigStatusType? = nil
        )
        {
            self.bucketOwnerAccess = bucketOwnerAccess
            self.encryptionDisabled = encryptionDisabled
            self.location = location
            self.status = status
        }
    }

}

extension CodeBuildClientTypes.S3ReportExportConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case bucketOwner
        case encryptionDisabled
        case encryptionKey
        case packaging
        case path
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let bucketOwner = self.bucketOwner {
            try encodeContainer.encode(bucketOwner, forKey: .bucketOwner)
        }
        if let encryptionDisabled = self.encryptionDisabled {
            try encodeContainer.encode(encryptionDisabled, forKey: .encryptionDisabled)
        }
        if let encryptionKey = self.encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let packaging = self.packaging {
            try encodeContainer.encode(packaging.rawValue, forKey: .packaging)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let bucketOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketOwner)
        bucketOwner = bucketOwnerDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let packagingDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ReportPackagingType.self, forKey: .packaging)
        packaging = packagingDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let encryptionDisabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encryptionDisabled)
        encryptionDisabled = encryptionDisabledDecoded
    }
}

extension CodeBuildClientTypes {
    /// Information about the S3 bucket where the raw data of a report are exported.
    public struct S3ReportExportConfig: Swift.Equatable {
        /// The name of the S3 bucket where the raw data of a report are exported.
        public var bucket: Swift.String?
        /// The Amazon Web Services account identifier of the owner of the Amazon S3 bucket. This allows report data to be exported to an Amazon S3 bucket that is owned by an account other than the account running the build.
        public var bucketOwner: Swift.String?
        /// A boolean value that specifies if the results of a report are encrypted.
        public var encryptionDisabled: Swift.Bool?
        /// The encryption key for the report's encrypted raw data.
        public var encryptionKey: Swift.String?
        /// The type of build output artifact to create. Valid values include:
        ///
        /// * NONE: CodeBuild creates the raw data in the output bucket. This is the default if packaging is not specified.
        ///
        /// * ZIP: CodeBuild creates a ZIP file with the raw data in the output bucket.
        public var packaging: CodeBuildClientTypes.ReportPackagingType?
        /// The path to the exported report's raw data results.
        public var path: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            bucketOwner: Swift.String? = nil,
            encryptionDisabled: Swift.Bool? = nil,
            encryptionKey: Swift.String? = nil,
            packaging: CodeBuildClientTypes.ReportPackagingType? = nil,
            path: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.bucketOwner = bucketOwner
            self.encryptionDisabled = encryptionDisabled
            self.encryptionKey = encryptionKey
            self.packaging = packaging
            self.path = path
        }
    }

}

extension CodeBuildClientTypes {
    public enum ServerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bitbucket
        case github
        case githubEnterprise
        case sdkUnknown(Swift.String)

        public static var allCases: [ServerType] {
            return [
                .bitbucket,
                .github,
                .githubEnterprise,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bitbucket: return "BITBUCKET"
            case .github: return "GITHUB"
            case .githubEnterprise: return "GITHUB_ENTERPRISE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServerType(rawValue: rawValue) ?? ServerType.sdkUnknown(rawValue)
        }
    }
}

extension CodeBuildClientTypes {
    public enum SharedResourceSortByType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case arn
        case modifiedTime
        case sdkUnknown(Swift.String)

        public static var allCases: [SharedResourceSortByType] {
            return [
                .arn,
                .modifiedTime,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .arn: return "ARN"
            case .modifiedTime: return "MODIFIED_TIME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SharedResourceSortByType(rawValue: rawValue) ?? SharedResourceSortByType.sdkUnknown(rawValue)
        }
    }
}

extension CodeBuildClientTypes {
    public enum SortOrderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrderType] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrderType(rawValue: rawValue) ?? SortOrderType.sdkUnknown(rawValue)
        }
    }
}

extension CodeBuildClientTypes.SourceAuth: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resource
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resource = self.resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.SourceAuthType.self, forKey: .type)
        type = typeDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resource)
        resource = resourceDecoded
    }
}

extension CodeBuildClientTypes {
    /// Information about the authorization settings for CodeBuild to access the source code to be built. This information is for the CodeBuild console's use only. Your code should not get or set this information directly.
    public struct SourceAuth: Swift.Equatable {
        /// The resource value that applies to the specified authorization type.
        public var resource: Swift.String?
        /// This data type is deprecated and is no longer accurate or used. The authorization type to use. The only valid value is OAUTH, which represents the OAuth authorization type.
        /// This member is required.
        public var type: CodeBuildClientTypes.SourceAuthType?

        public init (
            resource: Swift.String? = nil,
            type: CodeBuildClientTypes.SourceAuthType? = nil
        )
        {
            self.resource = resource
            self.type = type
        }
    }

}

extension CodeBuildClientTypes {
    public enum SourceAuthType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case oauth
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceAuthType] {
            return [
                .oauth,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .oauth: return "OAUTH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceAuthType(rawValue: rawValue) ?? SourceAuthType.sdkUnknown(rawValue)
        }
    }
}

extension CodeBuildClientTypes.SourceCredentialsInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case authType
        case serverType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let authType = self.authType {
            try encodeContainer.encode(authType.rawValue, forKey: .authType)
        }
        if let serverType = self.serverType {
            try encodeContainer.encode(serverType.rawValue, forKey: .serverType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let serverTypeDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ServerType.self, forKey: .serverType)
        serverType = serverTypeDecoded
        let authTypeDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.AuthType.self, forKey: .authType)
        authType = authTypeDecoded
    }
}

extension CodeBuildClientTypes {
    /// Information about the credentials for a GitHub, GitHub Enterprise, or Bitbucket repository.
    public struct SourceCredentialsInfo: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the token.
        public var arn: Swift.String?
        /// The type of authentication used by the credentials. Valid options are OAUTH, BASIC_AUTH, or PERSONAL_ACCESS_TOKEN.
        public var authType: CodeBuildClientTypes.AuthType?
        /// The type of source provider. The valid options are GITHUB, GITHUB_ENTERPRISE, or BITBUCKET.
        public var serverType: CodeBuildClientTypes.ServerType?

        public init (
            arn: Swift.String? = nil,
            authType: CodeBuildClientTypes.AuthType? = nil,
            serverType: CodeBuildClientTypes.ServerType? = nil
        )
        {
            self.arn = arn
            self.authType = authType
            self.serverType = serverType
        }
    }

}

extension CodeBuildClientTypes {
    public enum SourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bitbucket
        case codecommit
        case codepipeline
        case github
        case githubEnterprise
        case noSource
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceType] {
            return [
                .bitbucket,
                .codecommit,
                .codepipeline,
                .github,
                .githubEnterprise,
                .noSource,
                .s3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bitbucket: return "BITBUCKET"
            case .codecommit: return "CODECOMMIT"
            case .codepipeline: return "CODEPIPELINE"
            case .github: return "GITHUB"
            case .githubEnterprise: return "GITHUB_ENTERPRISE"
            case .noSource: return "NO_SOURCE"
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceType(rawValue: rawValue) ?? SourceType.sdkUnknown(rawValue)
        }
    }
}

extension StartBuildBatchInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifactsOverride
        case buildBatchConfigOverride
        case buildTimeoutInMinutesOverride
        case buildspecOverride
        case cacheOverride
        case certificateOverride
        case computeTypeOverride
        case debugSessionEnabled
        case encryptionKeyOverride
        case environmentTypeOverride
        case environmentVariablesOverride
        case gitCloneDepthOverride
        case gitSubmodulesConfigOverride
        case idempotencyToken
        case imageOverride
        case imagePullCredentialsTypeOverride
        case insecureSslOverride
        case logsConfigOverride
        case privilegedModeOverride
        case projectName
        case queuedTimeoutInMinutesOverride
        case registryCredentialOverride
        case reportBuildBatchStatusOverride
        case secondaryArtifactsOverride
        case secondarySourcesOverride
        case secondarySourcesVersionOverride
        case serviceRoleOverride
        case sourceAuthOverride
        case sourceLocationOverride
        case sourceTypeOverride
        case sourceVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactsOverride = self.artifactsOverride {
            try encodeContainer.encode(artifactsOverride, forKey: .artifactsOverride)
        }
        if let buildBatchConfigOverride = self.buildBatchConfigOverride {
            try encodeContainer.encode(buildBatchConfigOverride, forKey: .buildBatchConfigOverride)
        }
        if let buildTimeoutInMinutesOverride = self.buildTimeoutInMinutesOverride {
            try encodeContainer.encode(buildTimeoutInMinutesOverride, forKey: .buildTimeoutInMinutesOverride)
        }
        if let buildspecOverride = self.buildspecOverride {
            try encodeContainer.encode(buildspecOverride, forKey: .buildspecOverride)
        }
        if let cacheOverride = self.cacheOverride {
            try encodeContainer.encode(cacheOverride, forKey: .cacheOverride)
        }
        if let certificateOverride = self.certificateOverride {
            try encodeContainer.encode(certificateOverride, forKey: .certificateOverride)
        }
        if let computeTypeOverride = self.computeTypeOverride {
            try encodeContainer.encode(computeTypeOverride.rawValue, forKey: .computeTypeOverride)
        }
        if let debugSessionEnabled = self.debugSessionEnabled {
            try encodeContainer.encode(debugSessionEnabled, forKey: .debugSessionEnabled)
        }
        if let encryptionKeyOverride = self.encryptionKeyOverride {
            try encodeContainer.encode(encryptionKeyOverride, forKey: .encryptionKeyOverride)
        }
        if let environmentTypeOverride = self.environmentTypeOverride {
            try encodeContainer.encode(environmentTypeOverride.rawValue, forKey: .environmentTypeOverride)
        }
        if let environmentVariablesOverride = environmentVariablesOverride {
            var environmentVariablesOverrideContainer = encodeContainer.nestedUnkeyedContainer(forKey: .environmentVariablesOverride)
            for environmentvariable0 in environmentVariablesOverride {
                try environmentVariablesOverrideContainer.encode(environmentvariable0)
            }
        }
        if let gitCloneDepthOverride = self.gitCloneDepthOverride {
            try encodeContainer.encode(gitCloneDepthOverride, forKey: .gitCloneDepthOverride)
        }
        if let gitSubmodulesConfigOverride = self.gitSubmodulesConfigOverride {
            try encodeContainer.encode(gitSubmodulesConfigOverride, forKey: .gitSubmodulesConfigOverride)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let imageOverride = self.imageOverride {
            try encodeContainer.encode(imageOverride, forKey: .imageOverride)
        }
        if let imagePullCredentialsTypeOverride = self.imagePullCredentialsTypeOverride {
            try encodeContainer.encode(imagePullCredentialsTypeOverride.rawValue, forKey: .imagePullCredentialsTypeOverride)
        }
        if let insecureSslOverride = self.insecureSslOverride {
            try encodeContainer.encode(insecureSslOverride, forKey: .insecureSslOverride)
        }
        if let logsConfigOverride = self.logsConfigOverride {
            try encodeContainer.encode(logsConfigOverride, forKey: .logsConfigOverride)
        }
        if let privilegedModeOverride = self.privilegedModeOverride {
            try encodeContainer.encode(privilegedModeOverride, forKey: .privilegedModeOverride)
        }
        if let projectName = self.projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let queuedTimeoutInMinutesOverride = self.queuedTimeoutInMinutesOverride {
            try encodeContainer.encode(queuedTimeoutInMinutesOverride, forKey: .queuedTimeoutInMinutesOverride)
        }
        if let registryCredentialOverride = self.registryCredentialOverride {
            try encodeContainer.encode(registryCredentialOverride, forKey: .registryCredentialOverride)
        }
        if let reportBuildBatchStatusOverride = self.reportBuildBatchStatusOverride {
            try encodeContainer.encode(reportBuildBatchStatusOverride, forKey: .reportBuildBatchStatusOverride)
        }
        if let secondaryArtifactsOverride = secondaryArtifactsOverride {
            var secondaryArtifactsOverrideContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondaryArtifactsOverride)
            for projectartifacts0 in secondaryArtifactsOverride {
                try secondaryArtifactsOverrideContainer.encode(projectartifacts0)
            }
        }
        if let secondarySourcesOverride = secondarySourcesOverride {
            var secondarySourcesOverrideContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondarySourcesOverride)
            for projectsource0 in secondarySourcesOverride {
                try secondarySourcesOverrideContainer.encode(projectsource0)
            }
        }
        if let secondarySourcesVersionOverride = secondarySourcesVersionOverride {
            var secondarySourcesVersionOverrideContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondarySourcesVersionOverride)
            for projectsourceversion0 in secondarySourcesVersionOverride {
                try secondarySourcesVersionOverrideContainer.encode(projectsourceversion0)
            }
        }
        if let serviceRoleOverride = self.serviceRoleOverride {
            try encodeContainer.encode(serviceRoleOverride, forKey: .serviceRoleOverride)
        }
        if let sourceAuthOverride = self.sourceAuthOverride {
            try encodeContainer.encode(sourceAuthOverride, forKey: .sourceAuthOverride)
        }
        if let sourceLocationOverride = self.sourceLocationOverride {
            try encodeContainer.encode(sourceLocationOverride, forKey: .sourceLocationOverride)
        }
        if let sourceTypeOverride = self.sourceTypeOverride {
            try encodeContainer.encode(sourceTypeOverride.rawValue, forKey: .sourceTypeOverride)
        }
        if let sourceVersion = self.sourceVersion {
            try encodeContainer.encode(sourceVersion, forKey: .sourceVersion)
        }
    }
}

extension StartBuildBatchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartBuildBatchInput: Swift.Equatable {
    /// An array of ProjectArtifacts objects that contains information about the build output artifact overrides for the build project.
    public var artifactsOverride: CodeBuildClientTypes.ProjectArtifacts?
    /// A BuildBatchConfigOverride object that contains batch build configuration overrides.
    public var buildBatchConfigOverride: CodeBuildClientTypes.ProjectBuildBatchConfig?
    /// Overrides the build timeout specified in the batch build project.
    public var buildTimeoutInMinutesOverride: Swift.Int?
    /// A buildspec file declaration that overrides, for this build only, the latest one already defined in the build project. If this value is set, it can be either an inline buildspec definition, the path to an alternate buildspec file relative to the value of the built-in CODEBUILD_SRC_DIR environment variable, or the path to an S3 bucket. The bucket must be in the same Amazon Web Services Region as the build project. Specify the buildspec file using its ARN (for example, arn:aws:s3:::my-codebuild-sample2/buildspec.yml). If this value is not provided or is set to an empty string, the source code must contain a buildspec file in its root directory. For more information, see [Buildspec File Name and Storage Location](https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html#build-spec-ref-name-storage).
    public var buildspecOverride: Swift.String?
    /// A ProjectCache object that specifies cache overrides.
    public var cacheOverride: CodeBuildClientTypes.ProjectCache?
    /// The name of a certificate for this batch build that overrides the one specified in the batch build project.
    public var certificateOverride: Swift.String?
    /// The name of a compute type for this batch build that overrides the one specified in the batch build project.
    public var computeTypeOverride: CodeBuildClientTypes.ComputeType?
    /// Specifies if session debugging is enabled for this batch build. For more information, see [Viewing a running build in Session Manager](https://docs.aws.amazon.com/codebuild/latest/userguide/session-manager.html). Batch session debugging is not supported for matrix batch builds.
    public var debugSessionEnabled: Swift.Bool?
    /// The Key Management Service customer master key (CMK) that overrides the one specified in the batch build project. The CMK key encrypts the build output artifacts. You can use a cross-account KMS key to encrypt the build output artifacts if your service role has permission to that key. You can specify either the Amazon Resource Name (ARN) of the CMK or, if available, the CMK's alias (using the format alias/).
    public var encryptionKeyOverride: Swift.String?
    /// A container type for this batch build that overrides the one specified in the batch build project.
    public var environmentTypeOverride: CodeBuildClientTypes.EnvironmentType?
    /// An array of EnvironmentVariable objects that override, or add to, the environment variables defined in the batch build project.
    public var environmentVariablesOverride: [CodeBuildClientTypes.EnvironmentVariable]?
    /// The user-defined depth of history, with a minimum value of 0, that overrides, for this batch build only, any previous depth of history defined in the batch build project.
    public var gitCloneDepthOverride: Swift.Int?
    /// A GitSubmodulesConfig object that overrides the Git submodules configuration for this batch build.
    public var gitSubmodulesConfigOverride: CodeBuildClientTypes.GitSubmodulesConfig?
    /// A unique, case sensitive identifier you provide to ensure the idempotency of the StartBuildBatch request. The token is included in the StartBuildBatch request and is valid for five minutes. If you repeat the StartBuildBatch request with the same token, but change a parameter, CodeBuild returns a parameter mismatch error.
    public var idempotencyToken: Swift.String?
    /// The name of an image for this batch build that overrides the one specified in the batch build project.
    public var imageOverride: Swift.String?
    /// The type of credentials CodeBuild uses to pull images in your batch build. There are two valid values: CODEBUILD Specifies that CodeBuild uses its own credentials. This requires that you modify your ECR repository policy to trust CodeBuild's service principal. SERVICE_ROLE Specifies that CodeBuild uses your build project's service role. When using a cross-account or private registry image, you must use SERVICE_ROLE credentials. When using an CodeBuild curated image, you must use CODEBUILD credentials.
    public var imagePullCredentialsTypeOverride: CodeBuildClientTypes.ImagePullCredentialsType?
    /// Enable this flag to override the insecure SSL setting that is specified in the batch build project. The insecure SSL setting determines whether to ignore SSL warnings while connecting to the project source code. This override applies only if the build's source is GitHub Enterprise.
    public var insecureSslOverride: Swift.Bool?
    /// A LogsConfig object that override the log settings defined in the batch build project.
    public var logsConfigOverride: CodeBuildClientTypes.LogsConfig?
    /// Enable this flag to override privileged mode in the batch build project.
    public var privilegedModeOverride: Swift.Bool?
    /// The name of the project.
    /// This member is required.
    public var projectName: Swift.String?
    /// The number of minutes a batch build is allowed to be queued before it times out.
    public var queuedTimeoutInMinutesOverride: Swift.Int?
    /// A RegistryCredential object that overrides credentials for access to a private registry.
    public var registryCredentialOverride: CodeBuildClientTypes.RegistryCredential?
    /// Set to true to report to your source provider the status of a batch build's start and completion. If you use this option with a source provider other than GitHub, GitHub Enterprise, or Bitbucket, an invalidInputException is thrown. The status of a build triggered by a webhook is always reported to your source provider.
    public var reportBuildBatchStatusOverride: Swift.Bool?
    /// An array of ProjectArtifacts objects that override the secondary artifacts defined in the batch build project.
    public var secondaryArtifactsOverride: [CodeBuildClientTypes.ProjectArtifacts]?
    /// An array of ProjectSource objects that override the secondary sources defined in the batch build project.
    public var secondarySourcesOverride: [CodeBuildClientTypes.ProjectSource]?
    /// An array of ProjectSourceVersion objects that override the secondary source versions in the batch build project.
    public var secondarySourcesVersionOverride: [CodeBuildClientTypes.ProjectSourceVersion]?
    /// The name of a service role for this batch build that overrides the one specified in the batch build project.
    public var serviceRoleOverride: Swift.String?
    /// A SourceAuth object that overrides the one defined in the batch build project. This override applies only if the build project's source is BitBucket or GitHub.
    public var sourceAuthOverride: CodeBuildClientTypes.SourceAuth?
    /// A location that overrides, for this batch build, the source location defined in the batch build project.
    public var sourceLocationOverride: Swift.String?
    /// The source input type that overrides the source input defined in the batch build project.
    public var sourceTypeOverride: CodeBuildClientTypes.SourceType?
    /// The version of the batch build input to be built, for this build only. If not specified, the latest version is used. If specified, the contents depends on the source provider: CodeCommit The commit ID, branch, or Git tag to use. GitHub The commit ID, pull request ID, branch name, or tag name that corresponds to the version of the source code you want to build. If a pull request ID is specified, it must use the format pr/pull-request-ID (for example pr/25). If a branch name is specified, the branch's HEAD commit ID is used. If not specified, the default branch's HEAD commit ID is used. Bitbucket The commit ID, branch name, or tag name that corresponds to the version of the source code you want to build. If a branch name is specified, the branch's HEAD commit ID is used. If not specified, the default branch's HEAD commit ID is used. Amazon S3 The version ID of the object that represents the build input ZIP file to use. If sourceVersion is specified at the project level, then this sourceVersion (at the build level) takes precedence. For more information, see [Source Version Sample with CodeBuild](https://docs.aws.amazon.com/codebuild/latest/userguide/sample-source-version.html) in the CodeBuild User Guide.
    public var sourceVersion: Swift.String?

    public init (
        artifactsOverride: CodeBuildClientTypes.ProjectArtifacts? = nil,
        buildBatchConfigOverride: CodeBuildClientTypes.ProjectBuildBatchConfig? = nil,
        buildTimeoutInMinutesOverride: Swift.Int? = nil,
        buildspecOverride: Swift.String? = nil,
        cacheOverride: CodeBuildClientTypes.ProjectCache? = nil,
        certificateOverride: Swift.String? = nil,
        computeTypeOverride: CodeBuildClientTypes.ComputeType? = nil,
        debugSessionEnabled: Swift.Bool? = nil,
        encryptionKeyOverride: Swift.String? = nil,
        environmentTypeOverride: CodeBuildClientTypes.EnvironmentType? = nil,
        environmentVariablesOverride: [CodeBuildClientTypes.EnvironmentVariable]? = nil,
        gitCloneDepthOverride: Swift.Int? = nil,
        gitSubmodulesConfigOverride: CodeBuildClientTypes.GitSubmodulesConfig? = nil,
        idempotencyToken: Swift.String? = nil,
        imageOverride: Swift.String? = nil,
        imagePullCredentialsTypeOverride: CodeBuildClientTypes.ImagePullCredentialsType? = nil,
        insecureSslOverride: Swift.Bool? = nil,
        logsConfigOverride: CodeBuildClientTypes.LogsConfig? = nil,
        privilegedModeOverride: Swift.Bool? = nil,
        projectName: Swift.String? = nil,
        queuedTimeoutInMinutesOverride: Swift.Int? = nil,
        registryCredentialOverride: CodeBuildClientTypes.RegistryCredential? = nil,
        reportBuildBatchStatusOverride: Swift.Bool? = nil,
        secondaryArtifactsOverride: [CodeBuildClientTypes.ProjectArtifacts]? = nil,
        secondarySourcesOverride: [CodeBuildClientTypes.ProjectSource]? = nil,
        secondarySourcesVersionOverride: [CodeBuildClientTypes.ProjectSourceVersion]? = nil,
        serviceRoleOverride: Swift.String? = nil,
        sourceAuthOverride: CodeBuildClientTypes.SourceAuth? = nil,
        sourceLocationOverride: Swift.String? = nil,
        sourceTypeOverride: CodeBuildClientTypes.SourceType? = nil,
        sourceVersion: Swift.String? = nil
    )
    {
        self.artifactsOverride = artifactsOverride
        self.buildBatchConfigOverride = buildBatchConfigOverride
        self.buildTimeoutInMinutesOverride = buildTimeoutInMinutesOverride
        self.buildspecOverride = buildspecOverride
        self.cacheOverride = cacheOverride
        self.certificateOverride = certificateOverride
        self.computeTypeOverride = computeTypeOverride
        self.debugSessionEnabled = debugSessionEnabled
        self.encryptionKeyOverride = encryptionKeyOverride
        self.environmentTypeOverride = environmentTypeOverride
        self.environmentVariablesOverride = environmentVariablesOverride
        self.gitCloneDepthOverride = gitCloneDepthOverride
        self.gitSubmodulesConfigOverride = gitSubmodulesConfigOverride
        self.idempotencyToken = idempotencyToken
        self.imageOverride = imageOverride
        self.imagePullCredentialsTypeOverride = imagePullCredentialsTypeOverride
        self.insecureSslOverride = insecureSslOverride
        self.logsConfigOverride = logsConfigOverride
        self.privilegedModeOverride = privilegedModeOverride
        self.projectName = projectName
        self.queuedTimeoutInMinutesOverride = queuedTimeoutInMinutesOverride
        self.registryCredentialOverride = registryCredentialOverride
        self.reportBuildBatchStatusOverride = reportBuildBatchStatusOverride
        self.secondaryArtifactsOverride = secondaryArtifactsOverride
        self.secondarySourcesOverride = secondarySourcesOverride
        self.secondarySourcesVersionOverride = secondarySourcesVersionOverride
        self.serviceRoleOverride = serviceRoleOverride
        self.sourceAuthOverride = sourceAuthOverride
        self.sourceLocationOverride = sourceLocationOverride
        self.sourceTypeOverride = sourceTypeOverride
        self.sourceVersion = sourceVersion
    }
}

struct StartBuildBatchInputBody: Swift.Equatable {
    let projectName: Swift.String?
    let secondarySourcesOverride: [CodeBuildClientTypes.ProjectSource]?
    let secondarySourcesVersionOverride: [CodeBuildClientTypes.ProjectSourceVersion]?
    let sourceVersion: Swift.String?
    let artifactsOverride: CodeBuildClientTypes.ProjectArtifacts?
    let secondaryArtifactsOverride: [CodeBuildClientTypes.ProjectArtifacts]?
    let environmentVariablesOverride: [CodeBuildClientTypes.EnvironmentVariable]?
    let sourceTypeOverride: CodeBuildClientTypes.SourceType?
    let sourceLocationOverride: Swift.String?
    let sourceAuthOverride: CodeBuildClientTypes.SourceAuth?
    let gitCloneDepthOverride: Swift.Int?
    let gitSubmodulesConfigOverride: CodeBuildClientTypes.GitSubmodulesConfig?
    let buildspecOverride: Swift.String?
    let insecureSslOverride: Swift.Bool?
    let reportBuildBatchStatusOverride: Swift.Bool?
    let environmentTypeOverride: CodeBuildClientTypes.EnvironmentType?
    let imageOverride: Swift.String?
    let computeTypeOverride: CodeBuildClientTypes.ComputeType?
    let certificateOverride: Swift.String?
    let cacheOverride: CodeBuildClientTypes.ProjectCache?
    let serviceRoleOverride: Swift.String?
    let privilegedModeOverride: Swift.Bool?
    let buildTimeoutInMinutesOverride: Swift.Int?
    let queuedTimeoutInMinutesOverride: Swift.Int?
    let encryptionKeyOverride: Swift.String?
    let idempotencyToken: Swift.String?
    let logsConfigOverride: CodeBuildClientTypes.LogsConfig?
    let registryCredentialOverride: CodeBuildClientTypes.RegistryCredential?
    let imagePullCredentialsTypeOverride: CodeBuildClientTypes.ImagePullCredentialsType?
    let buildBatchConfigOverride: CodeBuildClientTypes.ProjectBuildBatchConfig?
    let debugSessionEnabled: Swift.Bool?
}

extension StartBuildBatchInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifactsOverride
        case buildBatchConfigOverride
        case buildTimeoutInMinutesOverride
        case buildspecOverride
        case cacheOverride
        case certificateOverride
        case computeTypeOverride
        case debugSessionEnabled
        case encryptionKeyOverride
        case environmentTypeOverride
        case environmentVariablesOverride
        case gitCloneDepthOverride
        case gitSubmodulesConfigOverride
        case idempotencyToken
        case imageOverride
        case imagePullCredentialsTypeOverride
        case insecureSslOverride
        case logsConfigOverride
        case privilegedModeOverride
        case projectName
        case queuedTimeoutInMinutesOverride
        case registryCredentialOverride
        case reportBuildBatchStatusOverride
        case secondaryArtifactsOverride
        case secondarySourcesOverride
        case secondarySourcesVersionOverride
        case serviceRoleOverride
        case sourceAuthOverride
        case sourceLocationOverride
        case sourceTypeOverride
        case sourceVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let secondarySourcesOverrideContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.ProjectSource?].self, forKey: .secondarySourcesOverride)
        var secondarySourcesOverrideDecoded0:[CodeBuildClientTypes.ProjectSource]? = nil
        if let secondarySourcesOverrideContainer = secondarySourcesOverrideContainer {
            secondarySourcesOverrideDecoded0 = [CodeBuildClientTypes.ProjectSource]()
            for structure0 in secondarySourcesOverrideContainer {
                if let structure0 = structure0 {
                    secondarySourcesOverrideDecoded0?.append(structure0)
                }
            }
        }
        secondarySourcesOverride = secondarySourcesOverrideDecoded0
        let secondarySourcesVersionOverrideContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.ProjectSourceVersion?].self, forKey: .secondarySourcesVersionOverride)
        var secondarySourcesVersionOverrideDecoded0:[CodeBuildClientTypes.ProjectSourceVersion]? = nil
        if let secondarySourcesVersionOverrideContainer = secondarySourcesVersionOverrideContainer {
            secondarySourcesVersionOverrideDecoded0 = [CodeBuildClientTypes.ProjectSourceVersion]()
            for structure0 in secondarySourcesVersionOverrideContainer {
                if let structure0 = structure0 {
                    secondarySourcesVersionOverrideDecoded0?.append(structure0)
                }
            }
        }
        secondarySourcesVersionOverride = secondarySourcesVersionOverrideDecoded0
        let sourceVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceVersion)
        sourceVersion = sourceVersionDecoded
        let artifactsOverrideDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ProjectArtifacts.self, forKey: .artifactsOverride)
        artifactsOverride = artifactsOverrideDecoded
        let secondaryArtifactsOverrideContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.ProjectArtifacts?].self, forKey: .secondaryArtifactsOverride)
        var secondaryArtifactsOverrideDecoded0:[CodeBuildClientTypes.ProjectArtifacts]? = nil
        if let secondaryArtifactsOverrideContainer = secondaryArtifactsOverrideContainer {
            secondaryArtifactsOverrideDecoded0 = [CodeBuildClientTypes.ProjectArtifacts]()
            for structure0 in secondaryArtifactsOverrideContainer {
                if let structure0 = structure0 {
                    secondaryArtifactsOverrideDecoded0?.append(structure0)
                }
            }
        }
        secondaryArtifactsOverride = secondaryArtifactsOverrideDecoded0
        let environmentVariablesOverrideContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.EnvironmentVariable?].self, forKey: .environmentVariablesOverride)
        var environmentVariablesOverrideDecoded0:[CodeBuildClientTypes.EnvironmentVariable]? = nil
        if let environmentVariablesOverrideContainer = environmentVariablesOverrideContainer {
            environmentVariablesOverrideDecoded0 = [CodeBuildClientTypes.EnvironmentVariable]()
            for structure0 in environmentVariablesOverrideContainer {
                if let structure0 = structure0 {
                    environmentVariablesOverrideDecoded0?.append(structure0)
                }
            }
        }
        environmentVariablesOverride = environmentVariablesOverrideDecoded0
        let sourceTypeOverrideDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.SourceType.self, forKey: .sourceTypeOverride)
        sourceTypeOverride = sourceTypeOverrideDecoded
        let sourceLocationOverrideDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLocationOverride)
        sourceLocationOverride = sourceLocationOverrideDecoded
        let sourceAuthOverrideDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.SourceAuth.self, forKey: .sourceAuthOverride)
        sourceAuthOverride = sourceAuthOverrideDecoded
        let gitCloneDepthOverrideDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .gitCloneDepthOverride)
        gitCloneDepthOverride = gitCloneDepthOverrideDecoded
        let gitSubmodulesConfigOverrideDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.GitSubmodulesConfig.self, forKey: .gitSubmodulesConfigOverride)
        gitSubmodulesConfigOverride = gitSubmodulesConfigOverrideDecoded
        let buildspecOverrideDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .buildspecOverride)
        buildspecOverride = buildspecOverrideDecoded
        let insecureSslOverrideDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .insecureSslOverride)
        insecureSslOverride = insecureSslOverrideDecoded
        let reportBuildBatchStatusOverrideDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .reportBuildBatchStatusOverride)
        reportBuildBatchStatusOverride = reportBuildBatchStatusOverrideDecoded
        let environmentTypeOverrideDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.EnvironmentType.self, forKey: .environmentTypeOverride)
        environmentTypeOverride = environmentTypeOverrideDecoded
        let imageOverrideDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageOverride)
        imageOverride = imageOverrideDecoded
        let computeTypeOverrideDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ComputeType.self, forKey: .computeTypeOverride)
        computeTypeOverride = computeTypeOverrideDecoded
        let certificateOverrideDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateOverride)
        certificateOverride = certificateOverrideDecoded
        let cacheOverrideDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ProjectCache.self, forKey: .cacheOverride)
        cacheOverride = cacheOverrideDecoded
        let serviceRoleOverrideDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRoleOverride)
        serviceRoleOverride = serviceRoleOverrideDecoded
        let privilegedModeOverrideDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .privilegedModeOverride)
        privilegedModeOverride = privilegedModeOverrideDecoded
        let buildTimeoutInMinutesOverrideDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .buildTimeoutInMinutesOverride)
        buildTimeoutInMinutesOverride = buildTimeoutInMinutesOverrideDecoded
        let queuedTimeoutInMinutesOverrideDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .queuedTimeoutInMinutesOverride)
        queuedTimeoutInMinutesOverride = queuedTimeoutInMinutesOverrideDecoded
        let encryptionKeyOverrideDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKeyOverride)
        encryptionKeyOverride = encryptionKeyOverrideDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let logsConfigOverrideDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.LogsConfig.self, forKey: .logsConfigOverride)
        logsConfigOverride = logsConfigOverrideDecoded
        let registryCredentialOverrideDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.RegistryCredential.self, forKey: .registryCredentialOverride)
        registryCredentialOverride = registryCredentialOverrideDecoded
        let imagePullCredentialsTypeOverrideDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ImagePullCredentialsType.self, forKey: .imagePullCredentialsTypeOverride)
        imagePullCredentialsTypeOverride = imagePullCredentialsTypeOverrideDecoded
        let buildBatchConfigOverrideDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ProjectBuildBatchConfig.self, forKey: .buildBatchConfigOverride)
        buildBatchConfigOverride = buildBatchConfigOverrideDecoded
        let debugSessionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .debugSessionEnabled)
        debugSessionEnabled = debugSessionEnabledDecoded
    }
}

extension StartBuildBatchOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartBuildBatchOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartBuildBatchOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartBuildBatchOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartBuildBatchOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.buildBatch = output.buildBatch
        } else {
            self.buildBatch = nil
        }
    }
}

public struct StartBuildBatchOutputResponse: Swift.Equatable {
    /// A BuildBatch object that contains information about the batch build.
    public var buildBatch: CodeBuildClientTypes.BuildBatch?

    public init (
        buildBatch: CodeBuildClientTypes.BuildBatch? = nil
    )
    {
        self.buildBatch = buildBatch
    }
}

struct StartBuildBatchOutputResponseBody: Swift.Equatable {
    let buildBatch: CodeBuildClientTypes.BuildBatch?
}

extension StartBuildBatchOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case buildBatch
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let buildBatchDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.BuildBatch.self, forKey: .buildBatch)
        buildBatch = buildBatchDecoded
    }
}

extension StartBuildInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifactsOverride
        case buildStatusConfigOverride
        case buildspecOverride
        case cacheOverride
        case certificateOverride
        case computeTypeOverride
        case debugSessionEnabled
        case encryptionKeyOverride
        case environmentTypeOverride
        case environmentVariablesOverride
        case gitCloneDepthOverride
        case gitSubmodulesConfigOverride
        case idempotencyToken
        case imageOverride
        case imagePullCredentialsTypeOverride
        case insecureSslOverride
        case logsConfigOverride
        case privilegedModeOverride
        case projectName
        case queuedTimeoutInMinutesOverride
        case registryCredentialOverride
        case reportBuildStatusOverride
        case secondaryArtifactsOverride
        case secondarySourcesOverride
        case secondarySourcesVersionOverride
        case serviceRoleOverride
        case sourceAuthOverride
        case sourceLocationOverride
        case sourceTypeOverride
        case sourceVersion
        case timeoutInMinutesOverride
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactsOverride = self.artifactsOverride {
            try encodeContainer.encode(artifactsOverride, forKey: .artifactsOverride)
        }
        if let buildStatusConfigOverride = self.buildStatusConfigOverride {
            try encodeContainer.encode(buildStatusConfigOverride, forKey: .buildStatusConfigOverride)
        }
        if let buildspecOverride = self.buildspecOverride {
            try encodeContainer.encode(buildspecOverride, forKey: .buildspecOverride)
        }
        if let cacheOverride = self.cacheOverride {
            try encodeContainer.encode(cacheOverride, forKey: .cacheOverride)
        }
        if let certificateOverride = self.certificateOverride {
            try encodeContainer.encode(certificateOverride, forKey: .certificateOverride)
        }
        if let computeTypeOverride = self.computeTypeOverride {
            try encodeContainer.encode(computeTypeOverride.rawValue, forKey: .computeTypeOverride)
        }
        if let debugSessionEnabled = self.debugSessionEnabled {
            try encodeContainer.encode(debugSessionEnabled, forKey: .debugSessionEnabled)
        }
        if let encryptionKeyOverride = self.encryptionKeyOverride {
            try encodeContainer.encode(encryptionKeyOverride, forKey: .encryptionKeyOverride)
        }
        if let environmentTypeOverride = self.environmentTypeOverride {
            try encodeContainer.encode(environmentTypeOverride.rawValue, forKey: .environmentTypeOverride)
        }
        if let environmentVariablesOverride = environmentVariablesOverride {
            var environmentVariablesOverrideContainer = encodeContainer.nestedUnkeyedContainer(forKey: .environmentVariablesOverride)
            for environmentvariable0 in environmentVariablesOverride {
                try environmentVariablesOverrideContainer.encode(environmentvariable0)
            }
        }
        if let gitCloneDepthOverride = self.gitCloneDepthOverride {
            try encodeContainer.encode(gitCloneDepthOverride, forKey: .gitCloneDepthOverride)
        }
        if let gitSubmodulesConfigOverride = self.gitSubmodulesConfigOverride {
            try encodeContainer.encode(gitSubmodulesConfigOverride, forKey: .gitSubmodulesConfigOverride)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let imageOverride = self.imageOverride {
            try encodeContainer.encode(imageOverride, forKey: .imageOverride)
        }
        if let imagePullCredentialsTypeOverride = self.imagePullCredentialsTypeOverride {
            try encodeContainer.encode(imagePullCredentialsTypeOverride.rawValue, forKey: .imagePullCredentialsTypeOverride)
        }
        if let insecureSslOverride = self.insecureSslOverride {
            try encodeContainer.encode(insecureSslOverride, forKey: .insecureSslOverride)
        }
        if let logsConfigOverride = self.logsConfigOverride {
            try encodeContainer.encode(logsConfigOverride, forKey: .logsConfigOverride)
        }
        if let privilegedModeOverride = self.privilegedModeOverride {
            try encodeContainer.encode(privilegedModeOverride, forKey: .privilegedModeOverride)
        }
        if let projectName = self.projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let queuedTimeoutInMinutesOverride = self.queuedTimeoutInMinutesOverride {
            try encodeContainer.encode(queuedTimeoutInMinutesOverride, forKey: .queuedTimeoutInMinutesOverride)
        }
        if let registryCredentialOverride = self.registryCredentialOverride {
            try encodeContainer.encode(registryCredentialOverride, forKey: .registryCredentialOverride)
        }
        if let reportBuildStatusOverride = self.reportBuildStatusOverride {
            try encodeContainer.encode(reportBuildStatusOverride, forKey: .reportBuildStatusOverride)
        }
        if let secondaryArtifactsOverride = secondaryArtifactsOverride {
            var secondaryArtifactsOverrideContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondaryArtifactsOverride)
            for projectartifacts0 in secondaryArtifactsOverride {
                try secondaryArtifactsOverrideContainer.encode(projectartifacts0)
            }
        }
        if let secondarySourcesOverride = secondarySourcesOverride {
            var secondarySourcesOverrideContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondarySourcesOverride)
            for projectsource0 in secondarySourcesOverride {
                try secondarySourcesOverrideContainer.encode(projectsource0)
            }
        }
        if let secondarySourcesVersionOverride = secondarySourcesVersionOverride {
            var secondarySourcesVersionOverrideContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondarySourcesVersionOverride)
            for projectsourceversion0 in secondarySourcesVersionOverride {
                try secondarySourcesVersionOverrideContainer.encode(projectsourceversion0)
            }
        }
        if let serviceRoleOverride = self.serviceRoleOverride {
            try encodeContainer.encode(serviceRoleOverride, forKey: .serviceRoleOverride)
        }
        if let sourceAuthOverride = self.sourceAuthOverride {
            try encodeContainer.encode(sourceAuthOverride, forKey: .sourceAuthOverride)
        }
        if let sourceLocationOverride = self.sourceLocationOverride {
            try encodeContainer.encode(sourceLocationOverride, forKey: .sourceLocationOverride)
        }
        if let sourceTypeOverride = self.sourceTypeOverride {
            try encodeContainer.encode(sourceTypeOverride.rawValue, forKey: .sourceTypeOverride)
        }
        if let sourceVersion = self.sourceVersion {
            try encodeContainer.encode(sourceVersion, forKey: .sourceVersion)
        }
        if let timeoutInMinutesOverride = self.timeoutInMinutesOverride {
            try encodeContainer.encode(timeoutInMinutesOverride, forKey: .timeoutInMinutesOverride)
        }
    }
}

extension StartBuildInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartBuildInput: Swift.Equatable {
    /// Build output artifact settings that override, for this build only, the latest ones already defined in the build project.
    public var artifactsOverride: CodeBuildClientTypes.ProjectArtifacts?
    /// Contains information that defines how the build project reports the build status to the source provider. This option is only used when the source provider is GITHUB, GITHUB_ENTERPRISE, or BITBUCKET.
    public var buildStatusConfigOverride: CodeBuildClientTypes.BuildStatusConfig?
    /// A buildspec file declaration that overrides, for this build only, the latest one already defined in the build project. If this value is set, it can be either an inline buildspec definition, the path to an alternate buildspec file relative to the value of the built-in CODEBUILD_SRC_DIR environment variable, or the path to an S3 bucket. The bucket must be in the same Amazon Web Services Region as the build project. Specify the buildspec file using its ARN (for example, arn:aws:s3:::my-codebuild-sample2/buildspec.yml). If this value is not provided or is set to an empty string, the source code must contain a buildspec file in its root directory. For more information, see [Buildspec File Name and Storage Location](https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html#build-spec-ref-name-storage).
    public var buildspecOverride: Swift.String?
    /// A ProjectCache object specified for this build that overrides the one defined in the build project.
    public var cacheOverride: CodeBuildClientTypes.ProjectCache?
    /// The name of a certificate for this build that overrides the one specified in the build project.
    public var certificateOverride: Swift.String?
    /// The name of a compute type for this build that overrides the one specified in the build project.
    public var computeTypeOverride: CodeBuildClientTypes.ComputeType?
    /// Specifies if session debugging is enabled for this build. For more information, see [Viewing a running build in Session Manager](https://docs.aws.amazon.com/codebuild/latest/userguide/session-manager.html).
    public var debugSessionEnabled: Swift.Bool?
    /// The Key Management Service customer master key (CMK) that overrides the one specified in the build project. The CMK key encrypts the build output artifacts. You can use a cross-account KMS key to encrypt the build output artifacts if your service role has permission to that key. You can specify either the Amazon Resource Name (ARN) of the CMK or, if available, the CMK's alias (using the format alias/).
    public var encryptionKeyOverride: Swift.String?
    /// A container type for this build that overrides the one specified in the build project.
    public var environmentTypeOverride: CodeBuildClientTypes.EnvironmentType?
    /// A set of environment variables that overrides, for this build only, the latest ones already defined in the build project.
    public var environmentVariablesOverride: [CodeBuildClientTypes.EnvironmentVariable]?
    /// The user-defined depth of history, with a minimum value of 0, that overrides, for this build only, any previous depth of history defined in the build project.
    public var gitCloneDepthOverride: Swift.Int?
    /// Information about the Git submodules configuration for this build of an CodeBuild build project.
    public var gitSubmodulesConfigOverride: CodeBuildClientTypes.GitSubmodulesConfig?
    /// A unique, case sensitive identifier you provide to ensure the idempotency of the StartBuild request. The token is included in the StartBuild request and is valid for 5 minutes. If you repeat the StartBuild request with the same token, but change a parameter, CodeBuild returns a parameter mismatch error.
    public var idempotencyToken: Swift.String?
    /// The name of an image for this build that overrides the one specified in the build project.
    public var imageOverride: Swift.String?
    /// The type of credentials CodeBuild uses to pull images in your build. There are two valid values: CODEBUILD Specifies that CodeBuild uses its own credentials. This requires that you modify your ECR repository policy to trust CodeBuild's service principal. SERVICE_ROLE Specifies that CodeBuild uses your build project's service role. When using a cross-account or private registry image, you must use SERVICE_ROLE credentials. When using an CodeBuild curated image, you must use CODEBUILD credentials.
    public var imagePullCredentialsTypeOverride: CodeBuildClientTypes.ImagePullCredentialsType?
    /// Enable this flag to override the insecure SSL setting that is specified in the build project. The insecure SSL setting determines whether to ignore SSL warnings while connecting to the project source code. This override applies only if the build's source is GitHub Enterprise.
    public var insecureSslOverride: Swift.Bool?
    /// Log settings for this build that override the log settings defined in the build project.
    public var logsConfigOverride: CodeBuildClientTypes.LogsConfig?
    /// Enable this flag to override privileged mode in the build project.
    public var privilegedModeOverride: Swift.Bool?
    /// The name of the CodeBuild build project to start running a build.
    /// This member is required.
    public var projectName: Swift.String?
    /// The number of minutes a build is allowed to be queued before it times out.
    public var queuedTimeoutInMinutesOverride: Swift.Int?
    /// The credentials for access to a private registry.
    public var registryCredentialOverride: CodeBuildClientTypes.RegistryCredential?
    /// Set to true to report to your source provider the status of a build's start and completion. If you use this option with a source provider other than GitHub, GitHub Enterprise, or Bitbucket, an invalidInputException is thrown. To be able to report the build status to the source provider, the user associated with the source provider must have write access to the repo. If the user does not have write access, the build status cannot be updated. For more information, see [Source provider access](https://docs.aws.amazon.com/codebuild/latest/userguide/access-tokens.html) in the CodeBuild User Guide. The status of a build triggered by a webhook is always reported to your source provider.
    public var reportBuildStatusOverride: Swift.Bool?
    /// An array of ProjectArtifacts objects.
    public var secondaryArtifactsOverride: [CodeBuildClientTypes.ProjectArtifacts]?
    /// An array of ProjectSource objects.
    public var secondarySourcesOverride: [CodeBuildClientTypes.ProjectSource]?
    /// An array of ProjectSourceVersion objects that specify one or more versions of the project's secondary sources to be used for this build only.
    public var secondarySourcesVersionOverride: [CodeBuildClientTypes.ProjectSourceVersion]?
    /// The name of a service role for this build that overrides the one specified in the build project.
    public var serviceRoleOverride: Swift.String?
    /// An authorization type for this build that overrides the one defined in the build project. This override applies only if the build project's source is BitBucket or GitHub.
    public var sourceAuthOverride: CodeBuildClientTypes.SourceAuth?
    /// A location that overrides, for this build, the source location for the one defined in the build project.
    public var sourceLocationOverride: Swift.String?
    /// A source input type, for this build, that overrides the source input defined in the build project.
    public var sourceTypeOverride: CodeBuildClientTypes.SourceType?
    /// The version of the build input to be built, for this build only. If not specified, the latest version is used. If specified, the contents depends on the source provider: CodeCommit The commit ID, branch, or Git tag to use. GitHub The commit ID, pull request ID, branch name, or tag name that corresponds to the version of the source code you want to build. If a pull request ID is specified, it must use the format pr/pull-request-ID (for example pr/25). If a branch name is specified, the branch's HEAD commit ID is used. If not specified, the default branch's HEAD commit ID is used. Bitbucket The commit ID, branch name, or tag name that corresponds to the version of the source code you want to build. If a branch name is specified, the branch's HEAD commit ID is used. If not specified, the default branch's HEAD commit ID is used. Amazon S3 The version ID of the object that represents the build input ZIP file to use. If sourceVersion is specified at the project level, then this sourceVersion (at the build level) takes precedence. For more information, see [Source Version Sample with CodeBuild](https://docs.aws.amazon.com/codebuild/latest/userguide/sample-source-version.html) in the CodeBuild User Guide.
    public var sourceVersion: Swift.String?
    /// The number of build timeout minutes, from 5 to 480 (8 hours), that overrides, for this build only, the latest setting already defined in the build project.
    public var timeoutInMinutesOverride: Swift.Int?

    public init (
        artifactsOverride: CodeBuildClientTypes.ProjectArtifacts? = nil,
        buildStatusConfigOverride: CodeBuildClientTypes.BuildStatusConfig? = nil,
        buildspecOverride: Swift.String? = nil,
        cacheOverride: CodeBuildClientTypes.ProjectCache? = nil,
        certificateOverride: Swift.String? = nil,
        computeTypeOverride: CodeBuildClientTypes.ComputeType? = nil,
        debugSessionEnabled: Swift.Bool? = nil,
        encryptionKeyOverride: Swift.String? = nil,
        environmentTypeOverride: CodeBuildClientTypes.EnvironmentType? = nil,
        environmentVariablesOverride: [CodeBuildClientTypes.EnvironmentVariable]? = nil,
        gitCloneDepthOverride: Swift.Int? = nil,
        gitSubmodulesConfigOverride: CodeBuildClientTypes.GitSubmodulesConfig? = nil,
        idempotencyToken: Swift.String? = nil,
        imageOverride: Swift.String? = nil,
        imagePullCredentialsTypeOverride: CodeBuildClientTypes.ImagePullCredentialsType? = nil,
        insecureSslOverride: Swift.Bool? = nil,
        logsConfigOverride: CodeBuildClientTypes.LogsConfig? = nil,
        privilegedModeOverride: Swift.Bool? = nil,
        projectName: Swift.String? = nil,
        queuedTimeoutInMinutesOverride: Swift.Int? = nil,
        registryCredentialOverride: CodeBuildClientTypes.RegistryCredential? = nil,
        reportBuildStatusOverride: Swift.Bool? = nil,
        secondaryArtifactsOverride: [CodeBuildClientTypes.ProjectArtifacts]? = nil,
        secondarySourcesOverride: [CodeBuildClientTypes.ProjectSource]? = nil,
        secondarySourcesVersionOverride: [CodeBuildClientTypes.ProjectSourceVersion]? = nil,
        serviceRoleOverride: Swift.String? = nil,
        sourceAuthOverride: CodeBuildClientTypes.SourceAuth? = nil,
        sourceLocationOverride: Swift.String? = nil,
        sourceTypeOverride: CodeBuildClientTypes.SourceType? = nil,
        sourceVersion: Swift.String? = nil,
        timeoutInMinutesOverride: Swift.Int? = nil
    )
    {
        self.artifactsOverride = artifactsOverride
        self.buildStatusConfigOverride = buildStatusConfigOverride
        self.buildspecOverride = buildspecOverride
        self.cacheOverride = cacheOverride
        self.certificateOverride = certificateOverride
        self.computeTypeOverride = computeTypeOverride
        self.debugSessionEnabled = debugSessionEnabled
        self.encryptionKeyOverride = encryptionKeyOverride
        self.environmentTypeOverride = environmentTypeOverride
        self.environmentVariablesOverride = environmentVariablesOverride
        self.gitCloneDepthOverride = gitCloneDepthOverride
        self.gitSubmodulesConfigOverride = gitSubmodulesConfigOverride
        self.idempotencyToken = idempotencyToken
        self.imageOverride = imageOverride
        self.imagePullCredentialsTypeOverride = imagePullCredentialsTypeOverride
        self.insecureSslOverride = insecureSslOverride
        self.logsConfigOverride = logsConfigOverride
        self.privilegedModeOverride = privilegedModeOverride
        self.projectName = projectName
        self.queuedTimeoutInMinutesOverride = queuedTimeoutInMinutesOverride
        self.registryCredentialOverride = registryCredentialOverride
        self.reportBuildStatusOverride = reportBuildStatusOverride
        self.secondaryArtifactsOverride = secondaryArtifactsOverride
        self.secondarySourcesOverride = secondarySourcesOverride
        self.secondarySourcesVersionOverride = secondarySourcesVersionOverride
        self.serviceRoleOverride = serviceRoleOverride
        self.sourceAuthOverride = sourceAuthOverride
        self.sourceLocationOverride = sourceLocationOverride
        self.sourceTypeOverride = sourceTypeOverride
        self.sourceVersion = sourceVersion
        self.timeoutInMinutesOverride = timeoutInMinutesOverride
    }
}

struct StartBuildInputBody: Swift.Equatable {
    let projectName: Swift.String?
    let secondarySourcesOverride: [CodeBuildClientTypes.ProjectSource]?
    let secondarySourcesVersionOverride: [CodeBuildClientTypes.ProjectSourceVersion]?
    let sourceVersion: Swift.String?
    let artifactsOverride: CodeBuildClientTypes.ProjectArtifacts?
    let secondaryArtifactsOverride: [CodeBuildClientTypes.ProjectArtifacts]?
    let environmentVariablesOverride: [CodeBuildClientTypes.EnvironmentVariable]?
    let sourceTypeOverride: CodeBuildClientTypes.SourceType?
    let sourceLocationOverride: Swift.String?
    let sourceAuthOverride: CodeBuildClientTypes.SourceAuth?
    let gitCloneDepthOverride: Swift.Int?
    let gitSubmodulesConfigOverride: CodeBuildClientTypes.GitSubmodulesConfig?
    let buildspecOverride: Swift.String?
    let insecureSslOverride: Swift.Bool?
    let reportBuildStatusOverride: Swift.Bool?
    let buildStatusConfigOverride: CodeBuildClientTypes.BuildStatusConfig?
    let environmentTypeOverride: CodeBuildClientTypes.EnvironmentType?
    let imageOverride: Swift.String?
    let computeTypeOverride: CodeBuildClientTypes.ComputeType?
    let certificateOverride: Swift.String?
    let cacheOverride: CodeBuildClientTypes.ProjectCache?
    let serviceRoleOverride: Swift.String?
    let privilegedModeOverride: Swift.Bool?
    let timeoutInMinutesOverride: Swift.Int?
    let queuedTimeoutInMinutesOverride: Swift.Int?
    let encryptionKeyOverride: Swift.String?
    let idempotencyToken: Swift.String?
    let logsConfigOverride: CodeBuildClientTypes.LogsConfig?
    let registryCredentialOverride: CodeBuildClientTypes.RegistryCredential?
    let imagePullCredentialsTypeOverride: CodeBuildClientTypes.ImagePullCredentialsType?
    let debugSessionEnabled: Swift.Bool?
}

extension StartBuildInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifactsOverride
        case buildStatusConfigOverride
        case buildspecOverride
        case cacheOverride
        case certificateOverride
        case computeTypeOverride
        case debugSessionEnabled
        case encryptionKeyOverride
        case environmentTypeOverride
        case environmentVariablesOverride
        case gitCloneDepthOverride
        case gitSubmodulesConfigOverride
        case idempotencyToken
        case imageOverride
        case imagePullCredentialsTypeOverride
        case insecureSslOverride
        case logsConfigOverride
        case privilegedModeOverride
        case projectName
        case queuedTimeoutInMinutesOverride
        case registryCredentialOverride
        case reportBuildStatusOverride
        case secondaryArtifactsOverride
        case secondarySourcesOverride
        case secondarySourcesVersionOverride
        case serviceRoleOverride
        case sourceAuthOverride
        case sourceLocationOverride
        case sourceTypeOverride
        case sourceVersion
        case timeoutInMinutesOverride
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let secondarySourcesOverrideContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.ProjectSource?].self, forKey: .secondarySourcesOverride)
        var secondarySourcesOverrideDecoded0:[CodeBuildClientTypes.ProjectSource]? = nil
        if let secondarySourcesOverrideContainer = secondarySourcesOverrideContainer {
            secondarySourcesOverrideDecoded0 = [CodeBuildClientTypes.ProjectSource]()
            for structure0 in secondarySourcesOverrideContainer {
                if let structure0 = structure0 {
                    secondarySourcesOverrideDecoded0?.append(structure0)
                }
            }
        }
        secondarySourcesOverride = secondarySourcesOverrideDecoded0
        let secondarySourcesVersionOverrideContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.ProjectSourceVersion?].self, forKey: .secondarySourcesVersionOverride)
        var secondarySourcesVersionOverrideDecoded0:[CodeBuildClientTypes.ProjectSourceVersion]? = nil
        if let secondarySourcesVersionOverrideContainer = secondarySourcesVersionOverrideContainer {
            secondarySourcesVersionOverrideDecoded0 = [CodeBuildClientTypes.ProjectSourceVersion]()
            for structure0 in secondarySourcesVersionOverrideContainer {
                if let structure0 = structure0 {
                    secondarySourcesVersionOverrideDecoded0?.append(structure0)
                }
            }
        }
        secondarySourcesVersionOverride = secondarySourcesVersionOverrideDecoded0
        let sourceVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceVersion)
        sourceVersion = sourceVersionDecoded
        let artifactsOverrideDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ProjectArtifacts.self, forKey: .artifactsOverride)
        artifactsOverride = artifactsOverrideDecoded
        let secondaryArtifactsOverrideContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.ProjectArtifacts?].self, forKey: .secondaryArtifactsOverride)
        var secondaryArtifactsOverrideDecoded0:[CodeBuildClientTypes.ProjectArtifacts]? = nil
        if let secondaryArtifactsOverrideContainer = secondaryArtifactsOverrideContainer {
            secondaryArtifactsOverrideDecoded0 = [CodeBuildClientTypes.ProjectArtifacts]()
            for structure0 in secondaryArtifactsOverrideContainer {
                if let structure0 = structure0 {
                    secondaryArtifactsOverrideDecoded0?.append(structure0)
                }
            }
        }
        secondaryArtifactsOverride = secondaryArtifactsOverrideDecoded0
        let environmentVariablesOverrideContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.EnvironmentVariable?].self, forKey: .environmentVariablesOverride)
        var environmentVariablesOverrideDecoded0:[CodeBuildClientTypes.EnvironmentVariable]? = nil
        if let environmentVariablesOverrideContainer = environmentVariablesOverrideContainer {
            environmentVariablesOverrideDecoded0 = [CodeBuildClientTypes.EnvironmentVariable]()
            for structure0 in environmentVariablesOverrideContainer {
                if let structure0 = structure0 {
                    environmentVariablesOverrideDecoded0?.append(structure0)
                }
            }
        }
        environmentVariablesOverride = environmentVariablesOverrideDecoded0
        let sourceTypeOverrideDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.SourceType.self, forKey: .sourceTypeOverride)
        sourceTypeOverride = sourceTypeOverrideDecoded
        let sourceLocationOverrideDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLocationOverride)
        sourceLocationOverride = sourceLocationOverrideDecoded
        let sourceAuthOverrideDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.SourceAuth.self, forKey: .sourceAuthOverride)
        sourceAuthOverride = sourceAuthOverrideDecoded
        let gitCloneDepthOverrideDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .gitCloneDepthOverride)
        gitCloneDepthOverride = gitCloneDepthOverrideDecoded
        let gitSubmodulesConfigOverrideDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.GitSubmodulesConfig.self, forKey: .gitSubmodulesConfigOverride)
        gitSubmodulesConfigOverride = gitSubmodulesConfigOverrideDecoded
        let buildspecOverrideDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .buildspecOverride)
        buildspecOverride = buildspecOverrideDecoded
        let insecureSslOverrideDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .insecureSslOverride)
        insecureSslOverride = insecureSslOverrideDecoded
        let reportBuildStatusOverrideDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .reportBuildStatusOverride)
        reportBuildStatusOverride = reportBuildStatusOverrideDecoded
        let buildStatusConfigOverrideDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.BuildStatusConfig.self, forKey: .buildStatusConfigOverride)
        buildStatusConfigOverride = buildStatusConfigOverrideDecoded
        let environmentTypeOverrideDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.EnvironmentType.self, forKey: .environmentTypeOverride)
        environmentTypeOverride = environmentTypeOverrideDecoded
        let imageOverrideDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageOverride)
        imageOverride = imageOverrideDecoded
        let computeTypeOverrideDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ComputeType.self, forKey: .computeTypeOverride)
        computeTypeOverride = computeTypeOverrideDecoded
        let certificateOverrideDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateOverride)
        certificateOverride = certificateOverrideDecoded
        let cacheOverrideDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ProjectCache.self, forKey: .cacheOverride)
        cacheOverride = cacheOverrideDecoded
        let serviceRoleOverrideDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRoleOverride)
        serviceRoleOverride = serviceRoleOverrideDecoded
        let privilegedModeOverrideDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .privilegedModeOverride)
        privilegedModeOverride = privilegedModeOverrideDecoded
        let timeoutInMinutesOverrideDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutInMinutesOverride)
        timeoutInMinutesOverride = timeoutInMinutesOverrideDecoded
        let queuedTimeoutInMinutesOverrideDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .queuedTimeoutInMinutesOverride)
        queuedTimeoutInMinutesOverride = queuedTimeoutInMinutesOverrideDecoded
        let encryptionKeyOverrideDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKeyOverride)
        encryptionKeyOverride = encryptionKeyOverrideDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let logsConfigOverrideDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.LogsConfig.self, forKey: .logsConfigOverride)
        logsConfigOverride = logsConfigOverrideDecoded
        let registryCredentialOverrideDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.RegistryCredential.self, forKey: .registryCredentialOverride)
        registryCredentialOverride = registryCredentialOverrideDecoded
        let imagePullCredentialsTypeOverrideDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ImagePullCredentialsType.self, forKey: .imagePullCredentialsTypeOverride)
        imagePullCredentialsTypeOverride = imagePullCredentialsTypeOverrideDecoded
        let debugSessionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .debugSessionEnabled)
        debugSessionEnabled = debugSessionEnabledDecoded
    }
}

extension StartBuildOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartBuildOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccountLimitExceededException" : self = .accountLimitExceededException(try AccountLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartBuildOutputError: Swift.Error, Swift.Equatable {
    case accountLimitExceededException(AccountLimitExceededException)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartBuildOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartBuildOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.build = output.build
        } else {
            self.build = nil
        }
    }
}

public struct StartBuildOutputResponse: Swift.Equatable {
    /// Information about the build to be run.
    public var build: CodeBuildClientTypes.Build?

    public init (
        build: CodeBuildClientTypes.Build? = nil
    )
    {
        self.build = build
    }
}

struct StartBuildOutputResponseBody: Swift.Equatable {
    let build: CodeBuildClientTypes.Build?
}

extension StartBuildOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case build
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let buildDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.Build.self, forKey: .build)
        build = buildDecoded
    }
}

extension CodeBuildClientTypes {
    public enum StatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case fault
        case inProgress
        case stopped
        case succeeded
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [StatusType] {
            return [
                .failed,
                .fault,
                .inProgress,
                .stopped,
                .succeeded,
                .timedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .fault: return "FAULT"
            case .inProgress: return "IN_PROGRESS"
            case .stopped: return "STOPPED"
            case .succeeded: return "SUCCEEDED"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StatusType(rawValue: rawValue) ?? StatusType.sdkUnknown(rawValue)
        }
    }
}

extension StopBuildBatchInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension StopBuildBatchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopBuildBatchInput: Swift.Equatable {
    /// The identifier of the batch build to stop.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct StopBuildBatchInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension StopBuildBatchInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension StopBuildBatchOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopBuildBatchOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StopBuildBatchOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopBuildBatchOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StopBuildBatchOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.buildBatch = output.buildBatch
        } else {
            self.buildBatch = nil
        }
    }
}

public struct StopBuildBatchOutputResponse: Swift.Equatable {
    /// Contains information about a batch build.
    public var buildBatch: CodeBuildClientTypes.BuildBatch?

    public init (
        buildBatch: CodeBuildClientTypes.BuildBatch? = nil
    )
    {
        self.buildBatch = buildBatch
    }
}

struct StopBuildBatchOutputResponseBody: Swift.Equatable {
    let buildBatch: CodeBuildClientTypes.BuildBatch?
}

extension StopBuildBatchOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case buildBatch
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let buildBatchDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.BuildBatch.self, forKey: .buildBatch)
        buildBatch = buildBatchDecoded
    }
}

extension StopBuildInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension StopBuildInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopBuildInput: Swift.Equatable {
    /// The ID of the build.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct StopBuildInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension StopBuildInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension StopBuildOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopBuildOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StopBuildOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopBuildOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StopBuildOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.build = output.build
        } else {
            self.build = nil
        }
    }
}

public struct StopBuildOutputResponse: Swift.Equatable {
    /// Information about the build.
    public var build: CodeBuildClientTypes.Build?

    public init (
        build: CodeBuildClientTypes.Build? = nil
    )
    {
        self.build = build
    }
}

struct StopBuildOutputResponseBody: Swift.Equatable {
    let build: CodeBuildClientTypes.Build?
}

extension StopBuildOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case build
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let buildDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.Build.self, forKey: .build)
        build = buildDecoded
    }
}

extension CodeBuildClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension CodeBuildClientTypes {
    /// A tag, consisting of a key and a value. This tag is available for use by Amazon Web Services services that support tags in CodeBuild.
    public struct Tag: Swift.Equatable {
        /// The tag's key.
        public var key: Swift.String?
        /// The tag's value.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension CodeBuildClientTypes.TestCase: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case durationInNanoSeconds
        case expired
        case message
        case name
        case `prefix` = "prefix"
        case reportArn
        case status
        case testRawDataPath
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let durationInNanoSeconds = self.durationInNanoSeconds {
            try encodeContainer.encode(durationInNanoSeconds, forKey: .durationInNanoSeconds)
        }
        if let expired = self.expired {
            try encodeContainer.encodeTimestamp(expired, format: .epochSeconds, forKey: .expired)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let `prefix` = self.`prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
        if let reportArn = self.reportArn {
            try encodeContainer.encode(reportArn, forKey: .reportArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let testRawDataPath = self.testRawDataPath {
            try encodeContainer.encode(testRawDataPath, forKey: .testRawDataPath)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportArn)
        reportArn = reportArnDecoded
        let testRawDataPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testRawDataPath)
        testRawDataPath = testRawDataPathDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let durationInNanoSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationInNanoSeconds)
        durationInNanoSeconds = durationInNanoSecondsDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let expiredDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expired)
        expired = expiredDecoded
    }
}

extension CodeBuildClientTypes {
    /// Information about a test case created using a framework such as NUnit or Cucumber. A test case might be a unit test or a configuration test.
    public struct TestCase: Swift.Equatable {
        /// The number of nanoseconds it took to run this test case.
        public var durationInNanoSeconds: Swift.Int?
        /// The date and time a test case expires. A test case expires 30 days after it is created. An expired test case is not available to view in CodeBuild.
        public var expired: ClientRuntime.Date?
        /// A message associated with a test case. For example, an error message or stack trace.
        public var message: Swift.String?
        /// The name of the test case.
        public var name: Swift.String?
        /// A string that is applied to a series of related test cases. CodeBuild generates the prefix. The prefix depends on the framework used to generate the tests.
        public var `prefix`: Swift.String?
        /// The ARN of the report to which the test case belongs.
        public var reportArn: Swift.String?
        /// The status returned by the test case after it was run. Valid statuses are SUCCEEDED, FAILED, ERROR, SKIPPED, and UNKNOWN.
        public var status: Swift.String?
        /// The path to the raw data file that contains the test result.
        public var testRawDataPath: Swift.String?

        public init (
            durationInNanoSeconds: Swift.Int? = nil,
            expired: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            name: Swift.String? = nil,
            `prefix`: Swift.String? = nil,
            reportArn: Swift.String? = nil,
            status: Swift.String? = nil,
            testRawDataPath: Swift.String? = nil
        )
        {
            self.durationInNanoSeconds = durationInNanoSeconds
            self.expired = expired
            self.message = message
            self.name = name
            self.`prefix` = `prefix`
            self.reportArn = reportArn
            self.status = status
            self.testRawDataPath = testRawDataPath
        }
    }

}

extension CodeBuildClientTypes.TestCaseFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyword
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyword = self.keyword {
            try encodeContainer.encode(keyword, forKey: .keyword)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let keywordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyword)
        keyword = keywordDecoded
    }
}

extension CodeBuildClientTypes {
    /// A filter used to return specific types of test cases. In order to pass the filter, the report must meet all of the filter properties.
    public struct TestCaseFilter: Swift.Equatable {
        /// A keyword that is used to filter on the name or the prefix of the test cases. Only test cases where the keyword is a substring of the name or the prefix will be returned.
        public var keyword: Swift.String?
        /// The status used to filter test cases. A TestCaseFilter can have one status. Valid values are:
        ///
        /// * SUCCEEDED
        ///
        /// * FAILED
        ///
        /// * ERROR
        ///
        /// * SKIPPED
        ///
        /// * UNKNOWN
        public var status: Swift.String?

        public init (
            keyword: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.keyword = keyword
            self.status = status
        }
    }

}

extension CodeBuildClientTypes.TestReportSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case durationInNanoSeconds
        case statusCounts
        case total
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let durationInNanoSeconds = self.durationInNanoSeconds {
            try encodeContainer.encode(durationInNanoSeconds, forKey: .durationInNanoSeconds)
        }
        if let statusCounts = statusCounts {
            var statusCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .statusCounts)
            for (dictKey0, reportStatusCounts0) in statusCounts {
                try statusCountsContainer.encode(reportStatusCounts0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let total = self.total {
            try encodeContainer.encode(total, forKey: .total)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .total)
        total = totalDecoded
        let statusCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .statusCounts)
        var statusCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let statusCountsContainer = statusCountsContainer {
            statusCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, wrapperint0) in statusCountsContainer {
                if let wrapperint0 = wrapperint0 {
                    statusCountsDecoded0?[key0] = wrapperint0
                }
            }
        }
        statusCounts = statusCountsDecoded0
        let durationInNanoSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationInNanoSeconds)
        durationInNanoSeconds = durationInNanoSecondsDecoded
    }
}

extension CodeBuildClientTypes {
    /// Information about a test report.
    public struct TestReportSummary: Swift.Equatable {
        /// The number of nanoseconds it took to run all of the test cases in this report.
        /// This member is required.
        public var durationInNanoSeconds: Swift.Int?
        /// A map that contains the number of each type of status returned by the test results in this TestReportSummary.
        /// This member is required.
        public var statusCounts: [Swift.String:Swift.Int]?
        /// The number of test cases in this TestReportSummary. The total includes truncated test cases.
        /// This member is required.
        public var total: Swift.Int?

        public init (
            durationInNanoSeconds: Swift.Int? = nil,
            statusCounts: [Swift.String:Swift.Int]? = nil,
            total: Swift.Int? = nil
        )
        {
            self.durationInNanoSeconds = durationInNanoSeconds
            self.statusCounts = statusCounts
            self.total = total
        }
    }

}

extension UpdateProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifacts
        case badgeEnabled
        case buildBatchConfig
        case cache
        case concurrentBuildLimit
        case description
        case encryptionKey
        case environment
        case fileSystemLocations
        case logsConfig
        case name
        case queuedTimeoutInMinutes
        case secondaryArtifacts
        case secondarySourceVersions
        case secondarySources
        case serviceRole
        case source
        case sourceVersion
        case tags
        case timeoutInMinutes
        case vpcConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifacts = self.artifacts {
            try encodeContainer.encode(artifacts, forKey: .artifacts)
        }
        if let badgeEnabled = self.badgeEnabled {
            try encodeContainer.encode(badgeEnabled, forKey: .badgeEnabled)
        }
        if let buildBatchConfig = self.buildBatchConfig {
            try encodeContainer.encode(buildBatchConfig, forKey: .buildBatchConfig)
        }
        if let cache = self.cache {
            try encodeContainer.encode(cache, forKey: .cache)
        }
        if let concurrentBuildLimit = self.concurrentBuildLimit {
            try encodeContainer.encode(concurrentBuildLimit, forKey: .concurrentBuildLimit)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encryptionKey = self.encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let environment = self.environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let fileSystemLocations = fileSystemLocations {
            var fileSystemLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileSystemLocations)
            for projectfilesystemlocation0 in fileSystemLocations {
                try fileSystemLocationsContainer.encode(projectfilesystemlocation0)
            }
        }
        if let logsConfig = self.logsConfig {
            try encodeContainer.encode(logsConfig, forKey: .logsConfig)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let queuedTimeoutInMinutes = self.queuedTimeoutInMinutes {
            try encodeContainer.encode(queuedTimeoutInMinutes, forKey: .queuedTimeoutInMinutes)
        }
        if let secondaryArtifacts = secondaryArtifacts {
            var secondaryArtifactsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondaryArtifacts)
            for projectartifacts0 in secondaryArtifacts {
                try secondaryArtifactsContainer.encode(projectartifacts0)
            }
        }
        if let secondarySourceVersions = secondarySourceVersions {
            var secondarySourceVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondarySourceVersions)
            for projectsourceversion0 in secondarySourceVersions {
                try secondarySourceVersionsContainer.encode(projectsourceversion0)
            }
        }
        if let secondarySources = secondarySources {
            var secondarySourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondarySources)
            for projectsource0 in secondarySources {
                try secondarySourcesContainer.encode(projectsource0)
            }
        }
        if let serviceRole = self.serviceRole {
            try encodeContainer.encode(serviceRole, forKey: .serviceRole)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let sourceVersion = self.sourceVersion {
            try encodeContainer.encode(sourceVersion, forKey: .sourceVersion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let timeoutInMinutes = self.timeoutInMinutes {
            try encodeContainer.encode(timeoutInMinutes, forKey: .timeoutInMinutes)
        }
        if let vpcConfig = self.vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

extension UpdateProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateProjectInput: Swift.Equatable {
    /// Information to be changed about the build output artifacts for the build project.
    public var artifacts: CodeBuildClientTypes.ProjectArtifacts?
    /// Set this to true to generate a publicly accessible URL for your project's build badge.
    public var badgeEnabled: Swift.Bool?
    /// Contains configuration information about a batch build project.
    public var buildBatchConfig: CodeBuildClientTypes.ProjectBuildBatchConfig?
    /// Stores recently used information so that it can be quickly accessed at a later time.
    public var cache: CodeBuildClientTypes.ProjectCache?
    /// The maximum number of concurrent builds that are allowed for this project. New builds are only started if the current number of builds is less than or equal to this limit. If the current build count meets this limit, new builds are throttled and are not run. To remove this limit, set this value to -1.
    public var concurrentBuildLimit: Swift.Int?
    /// A new or replacement description of the build project.
    public var description: Swift.String?
    /// The Key Management Service customer master key (CMK) to be used for encrypting the build output artifacts. You can use a cross-account KMS key to encrypt the build output artifacts if your service role has permission to that key. You can specify either the Amazon Resource Name (ARN) of the CMK or, if available, the CMK's alias (using the format alias/).
    public var encryptionKey: Swift.String?
    /// Information to be changed about the build environment for the build project.
    public var environment: CodeBuildClientTypes.ProjectEnvironment?
    /// An array of ProjectFileSystemLocation objects for a CodeBuild build project. A ProjectFileSystemLocation object specifies the identifier, location, mountOptions, mountPoint, and type of a file system created using Amazon Elastic File System.
    public var fileSystemLocations: [CodeBuildClientTypes.ProjectFileSystemLocation]?
    /// Information about logs for the build project. A project can create logs in CloudWatch Logs, logs in an S3 bucket, or both.
    public var logsConfig: CodeBuildClientTypes.LogsConfig?
    /// The name of the build project. You cannot change a build project's name.
    /// This member is required.
    public var name: Swift.String?
    /// The number of minutes a build is allowed to be queued before it times out.
    public var queuedTimeoutInMinutes: Swift.Int?
    /// An array of ProjectArtifact objects.
    public var secondaryArtifacts: [CodeBuildClientTypes.ProjectArtifacts]?
    /// An array of ProjectSourceVersion objects. If secondarySourceVersions is specified at the build level, then they take over these secondarySourceVersions (at the project level).
    public var secondarySourceVersions: [CodeBuildClientTypes.ProjectSourceVersion]?
    /// An array of ProjectSource objects.
    public var secondarySources: [CodeBuildClientTypes.ProjectSource]?
    /// The replacement ARN of the IAM role that enables CodeBuild to interact with dependent Amazon Web Services services on behalf of the Amazon Web Services account.
    public var serviceRole: Swift.String?
    /// Information to be changed about the build input source code for the build project.
    public var source: CodeBuildClientTypes.ProjectSource?
    /// A version of the build input to be built for this project. If not specified, the latest version is used. If specified, it must be one of:
    ///
    /// * For CodeCommit: the commit ID, branch, or Git tag to use.
    ///
    /// * For GitHub: the commit ID, pull request ID, branch name, or tag name that corresponds to the version of the source code you want to build. If a pull request ID is specified, it must use the format pr/pull-request-ID (for example pr/25). If a branch name is specified, the branch's HEAD commit ID is used. If not specified, the default branch's HEAD commit ID is used.
    ///
    /// * For Bitbucket: the commit ID, branch name, or tag name that corresponds to the version of the source code you want to build. If a branch name is specified, the branch's HEAD commit ID is used. If not specified, the default branch's HEAD commit ID is used.
    ///
    /// * For Amazon S3: the version ID of the object that represents the build input ZIP file to use.
    ///
    ///
    /// If sourceVersion is specified at the build level, then that version takes precedence over this sourceVersion (at the project level). For more information, see [Source Version Sample with CodeBuild](https://docs.aws.amazon.com/codebuild/latest/userguide/sample-source-version.html) in the CodeBuild User Guide.
    public var sourceVersion: Swift.String?
    /// An updated list of tag key and value pairs associated with this build project. These tags are available for use by Amazon Web Services services that support CodeBuild build project tags.
    public var tags: [CodeBuildClientTypes.Tag]?
    /// The replacement value in minutes, from 5 to 480 (8 hours), for CodeBuild to wait before timing out any related build that did not get marked as completed.
    public var timeoutInMinutes: Swift.Int?
    /// VpcConfig enables CodeBuild to access resources in an Amazon VPC.
    public var vpcConfig: CodeBuildClientTypes.VpcConfig?

    public init (
        artifacts: CodeBuildClientTypes.ProjectArtifacts? = nil,
        badgeEnabled: Swift.Bool? = nil,
        buildBatchConfig: CodeBuildClientTypes.ProjectBuildBatchConfig? = nil,
        cache: CodeBuildClientTypes.ProjectCache? = nil,
        concurrentBuildLimit: Swift.Int? = nil,
        description: Swift.String? = nil,
        encryptionKey: Swift.String? = nil,
        environment: CodeBuildClientTypes.ProjectEnvironment? = nil,
        fileSystemLocations: [CodeBuildClientTypes.ProjectFileSystemLocation]? = nil,
        logsConfig: CodeBuildClientTypes.LogsConfig? = nil,
        name: Swift.String? = nil,
        queuedTimeoutInMinutes: Swift.Int? = nil,
        secondaryArtifacts: [CodeBuildClientTypes.ProjectArtifacts]? = nil,
        secondarySourceVersions: [CodeBuildClientTypes.ProjectSourceVersion]? = nil,
        secondarySources: [CodeBuildClientTypes.ProjectSource]? = nil,
        serviceRole: Swift.String? = nil,
        source: CodeBuildClientTypes.ProjectSource? = nil,
        sourceVersion: Swift.String? = nil,
        tags: [CodeBuildClientTypes.Tag]? = nil,
        timeoutInMinutes: Swift.Int? = nil,
        vpcConfig: CodeBuildClientTypes.VpcConfig? = nil
    )
    {
        self.artifacts = artifacts
        self.badgeEnabled = badgeEnabled
        self.buildBatchConfig = buildBatchConfig
        self.cache = cache
        self.concurrentBuildLimit = concurrentBuildLimit
        self.description = description
        self.encryptionKey = encryptionKey
        self.environment = environment
        self.fileSystemLocations = fileSystemLocations
        self.logsConfig = logsConfig
        self.name = name
        self.queuedTimeoutInMinutes = queuedTimeoutInMinutes
        self.secondaryArtifacts = secondaryArtifacts
        self.secondarySourceVersions = secondarySourceVersions
        self.secondarySources = secondarySources
        self.serviceRole = serviceRole
        self.source = source
        self.sourceVersion = sourceVersion
        self.tags = tags
        self.timeoutInMinutes = timeoutInMinutes
        self.vpcConfig = vpcConfig
    }
}

struct UpdateProjectInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let source: CodeBuildClientTypes.ProjectSource?
    let secondarySources: [CodeBuildClientTypes.ProjectSource]?
    let sourceVersion: Swift.String?
    let secondarySourceVersions: [CodeBuildClientTypes.ProjectSourceVersion]?
    let artifacts: CodeBuildClientTypes.ProjectArtifacts?
    let secondaryArtifacts: [CodeBuildClientTypes.ProjectArtifacts]?
    let cache: CodeBuildClientTypes.ProjectCache?
    let environment: CodeBuildClientTypes.ProjectEnvironment?
    let serviceRole: Swift.String?
    let timeoutInMinutes: Swift.Int?
    let queuedTimeoutInMinutes: Swift.Int?
    let encryptionKey: Swift.String?
    let tags: [CodeBuildClientTypes.Tag]?
    let vpcConfig: CodeBuildClientTypes.VpcConfig?
    let badgeEnabled: Swift.Bool?
    let logsConfig: CodeBuildClientTypes.LogsConfig?
    let fileSystemLocations: [CodeBuildClientTypes.ProjectFileSystemLocation]?
    let buildBatchConfig: CodeBuildClientTypes.ProjectBuildBatchConfig?
    let concurrentBuildLimit: Swift.Int?
}

extension UpdateProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifacts
        case badgeEnabled
        case buildBatchConfig
        case cache
        case concurrentBuildLimit
        case description
        case encryptionKey
        case environment
        case fileSystemLocations
        case logsConfig
        case name
        case queuedTimeoutInMinutes
        case secondaryArtifacts
        case secondarySourceVersions
        case secondarySources
        case serviceRole
        case source
        case sourceVersion
        case tags
        case timeoutInMinutes
        case vpcConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ProjectSource.self, forKey: .source)
        source = sourceDecoded
        let secondarySourcesContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.ProjectSource?].self, forKey: .secondarySources)
        var secondarySourcesDecoded0:[CodeBuildClientTypes.ProjectSource]? = nil
        if let secondarySourcesContainer = secondarySourcesContainer {
            secondarySourcesDecoded0 = [CodeBuildClientTypes.ProjectSource]()
            for structure0 in secondarySourcesContainer {
                if let structure0 = structure0 {
                    secondarySourcesDecoded0?.append(structure0)
                }
            }
        }
        secondarySources = secondarySourcesDecoded0
        let sourceVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceVersion)
        sourceVersion = sourceVersionDecoded
        let secondarySourceVersionsContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.ProjectSourceVersion?].self, forKey: .secondarySourceVersions)
        var secondarySourceVersionsDecoded0:[CodeBuildClientTypes.ProjectSourceVersion]? = nil
        if let secondarySourceVersionsContainer = secondarySourceVersionsContainer {
            secondarySourceVersionsDecoded0 = [CodeBuildClientTypes.ProjectSourceVersion]()
            for structure0 in secondarySourceVersionsContainer {
                if let structure0 = structure0 {
                    secondarySourceVersionsDecoded0?.append(structure0)
                }
            }
        }
        secondarySourceVersions = secondarySourceVersionsDecoded0
        let artifactsDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ProjectArtifacts.self, forKey: .artifacts)
        artifacts = artifactsDecoded
        let secondaryArtifactsContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.ProjectArtifacts?].self, forKey: .secondaryArtifacts)
        var secondaryArtifactsDecoded0:[CodeBuildClientTypes.ProjectArtifacts]? = nil
        if let secondaryArtifactsContainer = secondaryArtifactsContainer {
            secondaryArtifactsDecoded0 = [CodeBuildClientTypes.ProjectArtifacts]()
            for structure0 in secondaryArtifactsContainer {
                if let structure0 = structure0 {
                    secondaryArtifactsDecoded0?.append(structure0)
                }
            }
        }
        secondaryArtifacts = secondaryArtifactsDecoded0
        let cacheDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ProjectCache.self, forKey: .cache)
        cache = cacheDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ProjectEnvironment.self, forKey: .environment)
        environment = environmentDecoded
        let serviceRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRole)
        serviceRole = serviceRoleDecoded
        let timeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutInMinutes)
        timeoutInMinutes = timeoutInMinutesDecoded
        let queuedTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .queuedTimeoutInMinutes)
        queuedTimeoutInMinutes = queuedTimeoutInMinutesDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[CodeBuildClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [CodeBuildClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let vpcConfigDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let badgeEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .badgeEnabled)
        badgeEnabled = badgeEnabledDecoded
        let logsConfigDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.LogsConfig.self, forKey: .logsConfig)
        logsConfig = logsConfigDecoded
        let fileSystemLocationsContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.ProjectFileSystemLocation?].self, forKey: .fileSystemLocations)
        var fileSystemLocationsDecoded0:[CodeBuildClientTypes.ProjectFileSystemLocation]? = nil
        if let fileSystemLocationsContainer = fileSystemLocationsContainer {
            fileSystemLocationsDecoded0 = [CodeBuildClientTypes.ProjectFileSystemLocation]()
            for structure0 in fileSystemLocationsContainer {
                if let structure0 = structure0 {
                    fileSystemLocationsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemLocations = fileSystemLocationsDecoded0
        let buildBatchConfigDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ProjectBuildBatchConfig.self, forKey: .buildBatchConfig)
        buildBatchConfig = buildBatchConfigDecoded
        let concurrentBuildLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .concurrentBuildLimit)
        concurrentBuildLimit = concurrentBuildLimitDecoded
    }
}

extension UpdateProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateProjectOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.project = output.project
        } else {
            self.project = nil
        }
    }
}

public struct UpdateProjectOutputResponse: Swift.Equatable {
    /// Information about the build project that was changed.
    public var project: CodeBuildClientTypes.Project?

    public init (
        project: CodeBuildClientTypes.Project? = nil
    )
    {
        self.project = project
    }
}

struct UpdateProjectOutputResponseBody: Swift.Equatable {
    let project: CodeBuildClientTypes.Project?
}

extension UpdateProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case project
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.Project.self, forKey: .project)
        project = projectDecoded
    }
}

extension UpdateProjectVisibilityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectArn
        case projectVisibility
        case resourceAccessRole
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let projectArn = self.projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
        if let projectVisibility = self.projectVisibility {
            try encodeContainer.encode(projectVisibility.rawValue, forKey: .projectVisibility)
        }
        if let resourceAccessRole = self.resourceAccessRole {
            try encodeContainer.encode(resourceAccessRole, forKey: .resourceAccessRole)
        }
    }
}

extension UpdateProjectVisibilityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateProjectVisibilityInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the build project.
    /// This member is required.
    public var projectArn: Swift.String?
    /// Specifies the visibility of the project's builds. Possible values are: PUBLIC_READ The project builds are visible to the public. PRIVATE The project builds are not visible to the public.
    /// This member is required.
    public var projectVisibility: CodeBuildClientTypes.ProjectVisibilityType?
    /// The ARN of the IAM role that enables CodeBuild to access the CloudWatch Logs and Amazon S3 artifacts for the project's builds.
    public var resourceAccessRole: Swift.String?

    public init (
        projectArn: Swift.String? = nil,
        projectVisibility: CodeBuildClientTypes.ProjectVisibilityType? = nil,
        resourceAccessRole: Swift.String? = nil
    )
    {
        self.projectArn = projectArn
        self.projectVisibility = projectVisibility
        self.resourceAccessRole = resourceAccessRole
    }
}

struct UpdateProjectVisibilityInputBody: Swift.Equatable {
    let projectArn: Swift.String?
    let projectVisibility: CodeBuildClientTypes.ProjectVisibilityType?
    let resourceAccessRole: Swift.String?
}

extension UpdateProjectVisibilityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectArn
        case projectVisibility
        case resourceAccessRole
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
        let projectVisibilityDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ProjectVisibilityType.self, forKey: .projectVisibility)
        projectVisibility = projectVisibilityDecoded
        let resourceAccessRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceAccessRole)
        resourceAccessRole = resourceAccessRoleDecoded
    }
}

extension UpdateProjectVisibilityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateProjectVisibilityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateProjectVisibilityOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateProjectVisibilityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateProjectVisibilityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.projectArn = output.projectArn
            self.projectVisibility = output.projectVisibility
            self.publicProjectAlias = output.publicProjectAlias
        } else {
            self.projectArn = nil
            self.projectVisibility = nil
            self.publicProjectAlias = nil
        }
    }
}

public struct UpdateProjectVisibilityOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the build project.
    public var projectArn: Swift.String?
    /// Specifies the visibility of the project's builds. Possible values are: PUBLIC_READ The project builds are visible to the public. PRIVATE The project builds are not visible to the public.
    public var projectVisibility: CodeBuildClientTypes.ProjectVisibilityType?
    /// Contains the project identifier used with the public build APIs.
    public var publicProjectAlias: Swift.String?

    public init (
        projectArn: Swift.String? = nil,
        projectVisibility: CodeBuildClientTypes.ProjectVisibilityType? = nil,
        publicProjectAlias: Swift.String? = nil
    )
    {
        self.projectArn = projectArn
        self.projectVisibility = projectVisibility
        self.publicProjectAlias = publicProjectAlias
    }
}

struct UpdateProjectVisibilityOutputResponseBody: Swift.Equatable {
    let projectArn: Swift.String?
    let publicProjectAlias: Swift.String?
    let projectVisibility: CodeBuildClientTypes.ProjectVisibilityType?
}

extension UpdateProjectVisibilityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectArn
        case projectVisibility
        case publicProjectAlias
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
        let publicProjectAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicProjectAlias)
        publicProjectAlias = publicProjectAliasDecoded
        let projectVisibilityDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ProjectVisibilityType.self, forKey: .projectVisibility)
        projectVisibility = projectVisibilityDecoded
    }
}

extension UpdateReportGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case exportConfig
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let exportConfig = self.exportConfig {
            try encodeContainer.encode(exportConfig, forKey: .exportConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension UpdateReportGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateReportGroupInput: Swift.Equatable {
    /// The ARN of the report group to update.
    /// This member is required.
    public var arn: Swift.String?
    /// Used to specify an updated export type. Valid values are:
    ///
    /// * S3: The report results are exported to an S3 bucket.
    ///
    /// * NO_EXPORT: The report results are not exported.
    public var exportConfig: CodeBuildClientTypes.ReportExportConfig?
    /// An updated list of tag key and value pairs associated with this report group. These tags are available for use by Amazon Web Services services that support CodeBuild report group tags.
    public var tags: [CodeBuildClientTypes.Tag]?

    public init (
        arn: Swift.String? = nil,
        exportConfig: CodeBuildClientTypes.ReportExportConfig? = nil,
        tags: [CodeBuildClientTypes.Tag]? = nil
    )
    {
        self.arn = arn
        self.exportConfig = exportConfig
        self.tags = tags
    }
}

struct UpdateReportGroupInputBody: Swift.Equatable {
    let arn: Swift.String?
    let exportConfig: CodeBuildClientTypes.ReportExportConfig?
    let tags: [CodeBuildClientTypes.Tag]?
}

extension UpdateReportGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case exportConfig
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let exportConfigDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ReportExportConfig.self, forKey: .exportConfig)
        exportConfig = exportConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[CodeBuildClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [CodeBuildClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UpdateReportGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateReportGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateReportGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateReportGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateReportGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.reportGroup = output.reportGroup
        } else {
            self.reportGroup = nil
        }
    }
}

public struct UpdateReportGroupOutputResponse: Swift.Equatable {
    /// Information about the updated report group.
    public var reportGroup: CodeBuildClientTypes.ReportGroup?

    public init (
        reportGroup: CodeBuildClientTypes.ReportGroup? = nil
    )
    {
        self.reportGroup = reportGroup
    }
}

struct UpdateReportGroupOutputResponseBody: Swift.Equatable {
    let reportGroup: CodeBuildClientTypes.ReportGroup?
}

extension UpdateReportGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportGroup
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportGroupDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ReportGroup.self, forKey: .reportGroup)
        reportGroup = reportGroupDecoded
    }
}

extension UpdateWebhookInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchFilter
        case buildType
        case filterGroups
        case projectName
        case rotateSecret
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchFilter = self.branchFilter {
            try encodeContainer.encode(branchFilter, forKey: .branchFilter)
        }
        if let buildType = self.buildType {
            try encodeContainer.encode(buildType.rawValue, forKey: .buildType)
        }
        if let filterGroups = filterGroups {
            var filterGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterGroups)
            for filtergroup0 in filterGroups {
                var filtergroup0Container = filterGroupsContainer.nestedUnkeyedContainer()
                for webhookfilter1 in filtergroup0 {
                    try filtergroup0Container.encode(webhookfilter1)
                }
            }
        }
        if let projectName = self.projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if rotateSecret != false {
            try encodeContainer.encode(rotateSecret, forKey: .rotateSecret)
        }
    }
}

extension UpdateWebhookInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateWebhookInput: Swift.Equatable {
    /// A regular expression used to determine which repository branches are built when a webhook is triggered. If the name of a branch matches the regular expression, then it is built. If branchFilter is empty, then all branches are built. It is recommended that you use filterGroups instead of branchFilter.
    public var branchFilter: Swift.String?
    /// Specifies the type of build this webhook will trigger.
    public var buildType: CodeBuildClientTypes.WebhookBuildType?
    /// An array of arrays of WebhookFilter objects used to determine if a webhook event can trigger a build. A filter group must contain at least one EVENTWebhookFilter.
    public var filterGroups: [[CodeBuildClientTypes.WebhookFilter]]?
    /// The name of the CodeBuild project.
    /// This member is required.
    public var projectName: Swift.String?
    /// A boolean value that specifies whether the associated GitHub repository's secret token should be updated. If you use Bitbucket for your repository, rotateSecret is ignored.
    public var rotateSecret: Swift.Bool

    public init (
        branchFilter: Swift.String? = nil,
        buildType: CodeBuildClientTypes.WebhookBuildType? = nil,
        filterGroups: [[CodeBuildClientTypes.WebhookFilter]]? = nil,
        projectName: Swift.String? = nil,
        rotateSecret: Swift.Bool = false
    )
    {
        self.branchFilter = branchFilter
        self.buildType = buildType
        self.filterGroups = filterGroups
        self.projectName = projectName
        self.rotateSecret = rotateSecret
    }
}

struct UpdateWebhookInputBody: Swift.Equatable {
    let projectName: Swift.String?
    let branchFilter: Swift.String?
    let rotateSecret: Swift.Bool
    let filterGroups: [[CodeBuildClientTypes.WebhookFilter]]?
    let buildType: CodeBuildClientTypes.WebhookBuildType?
}

extension UpdateWebhookInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchFilter
        case buildType
        case filterGroups
        case projectName
        case rotateSecret
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let branchFilterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branchFilter)
        branchFilter = branchFilterDecoded
        let rotateSecretDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .rotateSecret) ?? false
        rotateSecret = rotateSecretDecoded
        let filterGroupsContainer = try containerValues.decodeIfPresent([[CodeBuildClientTypes.WebhookFilter?]?].self, forKey: .filterGroups)
        var filterGroupsDecoded0:[[CodeBuildClientTypes.WebhookFilter]]? = nil
        if let filterGroupsContainer = filterGroupsContainer {
            filterGroupsDecoded0 = [[CodeBuildClientTypes.WebhookFilter]]()
            for list0 in filterGroupsContainer {
                var list0Decoded0: [CodeBuildClientTypes.WebhookFilter]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [CodeBuildClientTypes.WebhookFilter]()
                    for structure1 in list0 {
                        if let structure1 = structure1 {
                            list0Decoded0?.append(structure1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    filterGroupsDecoded0?.append(list0Decoded0)
                }
            }
        }
        filterGroups = filterGroupsDecoded0
        let buildTypeDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.WebhookBuildType.self, forKey: .buildType)
        buildType = buildTypeDecoded
    }
}

extension UpdateWebhookOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWebhookOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OAuthProviderException" : self = .oAuthProviderException(try OAuthProviderException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateWebhookOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case oAuthProviderException(OAuthProviderException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWebhookOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateWebhookOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.webhook = output.webhook
        } else {
            self.webhook = nil
        }
    }
}

public struct UpdateWebhookOutputResponse: Swift.Equatable {
    /// Information about a repository's webhook that is associated with a project in CodeBuild.
    public var webhook: CodeBuildClientTypes.Webhook?

    public init (
        webhook: CodeBuildClientTypes.Webhook? = nil
    )
    {
        self.webhook = webhook
    }
}

struct UpdateWebhookOutputResponseBody: Swift.Equatable {
    let webhook: CodeBuildClientTypes.Webhook?
}

extension UpdateWebhookOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case webhook
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webhookDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.Webhook.self, forKey: .webhook)
        webhook = webhookDecoded
    }
}

extension CodeBuildClientTypes.VpcConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds
        case subnets
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for nonemptystring0 in securityGroupIds {
                try securityGroupIdsContainer.encode(nonemptystring0)
            }
        }
        if let subnets = subnets {
            var subnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnets)
            for nonemptystring0 in subnets {
                try subnetsContainer.encode(nonemptystring0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnets)
        var subnetsDecoded0:[Swift.String]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [Swift.String]()
            for string0 in subnetsContainer {
                if let string0 = string0 {
                    subnetsDecoded0?.append(string0)
                }
            }
        }
        subnets = subnetsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension CodeBuildClientTypes {
    /// Information about the VPC configuration that CodeBuild accesses.
    public struct VpcConfig: Swift.Equatable {
        /// A list of one or more security groups IDs in your Amazon VPC.
        public var securityGroupIds: [Swift.String]?
        /// A list of one or more subnet IDs in your Amazon VPC.
        public var subnets: [Swift.String]?
        /// The ID of the Amazon VPC.
        public var vpcId: Swift.String?

        public init (
            securityGroupIds: [Swift.String]? = nil,
            subnets: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnets = subnets
            self.vpcId = vpcId
        }
    }

}

extension CodeBuildClientTypes.Webhook: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchFilter
        case buildType
        case filterGroups
        case lastModifiedSecret
        case payloadUrl
        case secret
        case url
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchFilter = self.branchFilter {
            try encodeContainer.encode(branchFilter, forKey: .branchFilter)
        }
        if let buildType = self.buildType {
            try encodeContainer.encode(buildType.rawValue, forKey: .buildType)
        }
        if let filterGroups = filterGroups {
            var filterGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterGroups)
            for filtergroup0 in filterGroups {
                var filtergroup0Container = filterGroupsContainer.nestedUnkeyedContainer()
                for webhookfilter1 in filtergroup0 {
                    try filtergroup0Container.encode(webhookfilter1)
                }
            }
        }
        if let lastModifiedSecret = self.lastModifiedSecret {
            try encodeContainer.encodeTimestamp(lastModifiedSecret, format: .epochSeconds, forKey: .lastModifiedSecret)
        }
        if let payloadUrl = self.payloadUrl {
            try encodeContainer.encode(payloadUrl, forKey: .payloadUrl)
        }
        if let secret = self.secret {
            try encodeContainer.encode(secret, forKey: .secret)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let payloadUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .payloadUrl)
        payloadUrl = payloadUrlDecoded
        let secretDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secret)
        secret = secretDecoded
        let branchFilterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branchFilter)
        branchFilter = branchFilterDecoded
        let filterGroupsContainer = try containerValues.decodeIfPresent([[CodeBuildClientTypes.WebhookFilter?]?].self, forKey: .filterGroups)
        var filterGroupsDecoded0:[[CodeBuildClientTypes.WebhookFilter]]? = nil
        if let filterGroupsContainer = filterGroupsContainer {
            filterGroupsDecoded0 = [[CodeBuildClientTypes.WebhookFilter]]()
            for list0 in filterGroupsContainer {
                var list0Decoded0: [CodeBuildClientTypes.WebhookFilter]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [CodeBuildClientTypes.WebhookFilter]()
                    for structure1 in list0 {
                        if let structure1 = structure1 {
                            list0Decoded0?.append(structure1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    filterGroupsDecoded0?.append(list0Decoded0)
                }
            }
        }
        filterGroups = filterGroupsDecoded0
        let buildTypeDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.WebhookBuildType.self, forKey: .buildType)
        buildType = buildTypeDecoded
        let lastModifiedSecretDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedSecret)
        lastModifiedSecret = lastModifiedSecretDecoded
    }
}

extension CodeBuildClientTypes {
    /// Information about a webhook that connects repository events to a build project in CodeBuild.
    public struct Webhook: Swift.Equatable {
        /// A regular expression used to determine which repository branches are built when a webhook is triggered. If the name of a branch matches the regular expression, then it is built. If branchFilter is empty, then all branches are built. It is recommended that you use filterGroups instead of branchFilter.
        public var branchFilter: Swift.String?
        /// Specifies the type of build this webhook will trigger.
        public var buildType: CodeBuildClientTypes.WebhookBuildType?
        /// An array of arrays of WebhookFilter objects used to determine which webhooks are triggered. At least one WebhookFilter in the array must specify EVENT as its type. For a build to be triggered, at least one filter group in the filterGroups array must pass. For a filter group to pass, each of its filters must pass.
        public var filterGroups: [[CodeBuildClientTypes.WebhookFilter]]?
        /// A timestamp that indicates the last time a repository's secret token was modified.
        public var lastModifiedSecret: ClientRuntime.Date?
        /// The CodeBuild endpoint where webhook events are sent.
        public var payloadUrl: Swift.String?
        /// The secret token of the associated repository. A Bitbucket webhook does not support secret.
        public var secret: Swift.String?
        /// The URL to the webhook.
        public var url: Swift.String?

        public init (
            branchFilter: Swift.String? = nil,
            buildType: CodeBuildClientTypes.WebhookBuildType? = nil,
            filterGroups: [[CodeBuildClientTypes.WebhookFilter]]? = nil,
            lastModifiedSecret: ClientRuntime.Date? = nil,
            payloadUrl: Swift.String? = nil,
            secret: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.branchFilter = branchFilter
            self.buildType = buildType
            self.filterGroups = filterGroups
            self.lastModifiedSecret = lastModifiedSecret
            self.payloadUrl = payloadUrl
            self.secret = secret
            self.url = url
        }
    }

}

extension CodeBuildClientTypes {
    public enum WebhookBuildType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case build
        case buildBatch
        case sdkUnknown(Swift.String)

        public static var allCases: [WebhookBuildType] {
            return [
                .build,
                .buildBatch,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .build: return "BUILD"
            case .buildBatch: return "BUILD_BATCH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WebhookBuildType(rawValue: rawValue) ?? WebhookBuildType.sdkUnknown(rawValue)
        }
    }
}

extension CodeBuildClientTypes.WebhookFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case excludeMatchedPattern
        case pattern
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let excludeMatchedPattern = self.excludeMatchedPattern {
            try encodeContainer.encode(excludeMatchedPattern, forKey: .excludeMatchedPattern)
        }
        if let pattern = self.pattern {
            try encodeContainer.encode(pattern, forKey: .pattern)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.WebhookFilterType.self, forKey: .type)
        type = typeDecoded
        let patternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pattern)
        pattern = patternDecoded
        let excludeMatchedPatternDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .excludeMatchedPattern)
        excludeMatchedPattern = excludeMatchedPatternDecoded
    }
}

extension CodeBuildClientTypes {
    /// A filter used to determine which webhooks trigger a build.
    public struct WebhookFilter: Swift.Equatable {
        /// Used to indicate that the pattern determines which webhook events do not trigger a build. If true, then a webhook event that does not match the pattern triggers a build. If false, then a webhook event that matches the pattern triggers a build.
        public var excludeMatchedPattern: Swift.Bool?
        /// For a WebHookFilter that uses EVENT type, a comma-separated string that specifies one or more events. For example, the webhook filter PUSH, PULL_REQUEST_CREATED, PULL_REQUEST_UPDATED allows all push, pull request created, and pull request updated events to trigger a build. For a WebHookFilter that uses any of the other filter types, a regular expression pattern. For example, a WebHookFilter that uses HEAD_REF for its type and the pattern ^refs/heads/ triggers a build when the head reference is a branch with a reference name refs/heads/branch-name.
        /// This member is required.
        public var pattern: Swift.String?
        /// The type of webhook filter. There are six webhook filter types: EVENT, ACTOR_ACCOUNT_ID, HEAD_REF, BASE_REF, FILE_PATH, and COMMIT_MESSAGE. EVENT A webhook event triggers a build when the provided pattern matches one of five event types: PUSH, PULL_REQUEST_CREATED, PULL_REQUEST_UPDATED, PULL_REQUEST_REOPENED, and PULL_REQUEST_MERGED. The EVENT patterns are specified as a comma-separated string. For example, PUSH, PULL_REQUEST_CREATED, PULL_REQUEST_UPDATED filters all push, pull request created, and pull request updated events. The PULL_REQUEST_REOPENED works with GitHub and GitHub Enterprise only. ACTOR_ACCOUNT_ID A webhook event triggers a build when a GitHub, GitHub Enterprise, or Bitbucket account ID matches the regular expression pattern. HEAD_REF A webhook event triggers a build when the head reference matches the regular expression pattern. For example, refs/heads/branch-name and refs/tags/tag-name. Works with GitHub and GitHub Enterprise push, GitHub and GitHub Enterprise pull request, Bitbucket push, and Bitbucket pull request events. BASE_REF A webhook event triggers a build when the base reference matches the regular expression pattern. For example, refs/heads/branch-name. Works with pull request events only. FILE_PATH A webhook triggers a build when the path of a changed file matches the regular expression pattern. Works with GitHub and Bitbucket events push and pull requests events. Also works with GitHub Enterprise push events, but does not work with GitHub Enterprise pull request events. COMMIT_MESSAGE A webhook triggers a build when the head commit message matches the regular expression pattern. Works with GitHub and Bitbucket events push and pull requests events. Also works with GitHub Enterprise push events, but does not work with GitHub Enterprise pull request events.
        /// This member is required.
        public var type: CodeBuildClientTypes.WebhookFilterType?

        public init (
            excludeMatchedPattern: Swift.Bool? = nil,
            pattern: Swift.String? = nil,
            type: CodeBuildClientTypes.WebhookFilterType? = nil
        )
        {
            self.excludeMatchedPattern = excludeMatchedPattern
            self.pattern = pattern
            self.type = type
        }
    }

}

extension CodeBuildClientTypes {
    public enum WebhookFilterType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case actorAccountId
        case baseRef
        case commitMessage
        case event
        case filePath
        case headRef
        case sdkUnknown(Swift.String)

        public static var allCases: [WebhookFilterType] {
            return [
                .actorAccountId,
                .baseRef,
                .commitMessage,
                .event,
                .filePath,
                .headRef,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .actorAccountId: return "ACTOR_ACCOUNT_ID"
            case .baseRef: return "BASE_REF"
            case .commitMessage: return "COMMIT_MESSAGE"
            case .event: return "EVENT"
            case .filePath: return "FILE_PATH"
            case .headRef: return "HEAD_REF"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WebhookFilterType(rawValue: rawValue) ?? WebhookFilterType.sdkUnknown(rawValue)
        }
    }
}
