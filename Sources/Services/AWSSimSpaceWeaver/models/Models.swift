// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SimSpaceWeaverClientTypes {
    public enum ClockStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case started
        case starting
        case stopped
        case stopping
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [ClockStatus] {
            return [
                .started,
                .starting,
                .stopped,
                .stopping,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .started: return "STARTED"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ClockStatus(rawValue: rawValue) ?? ClockStatus.sdkUnknown(rawValue)
        }
    }
}

extension SimSpaceWeaverClientTypes {
    public enum ClockTargetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case started
        case stopped
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [ClockTargetStatus] {
            return [
                .started,
                .stopped,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .started: return "STARTED"
            case .stopped: return "STOPPED"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ClockTargetStatus(rawValue: rawValue) ?? ClockTargetStatus.sdkUnknown(rawValue)
        }
    }
}

extension SimSpaceWeaverClientTypes.CloudWatchLogsLogGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logGroupArn = "LogGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logGroupArn = self.logGroupArn {
            try encodeContainer.encode(logGroupArn, forKey: .logGroupArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupArn)
        logGroupArn = logGroupArnDecoded
    }
}

extension SimSpaceWeaverClientTypes {
    /// The Amazon CloudWatch Logs log group for the simulation. For more information about log groups, see [Working with log groups and log streams](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html) in the Amazon CloudWatch Logs User Guide.
    public struct CloudWatchLogsLogGroup: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Amazon CloudWatch Logs log group for the simulation. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference. For more information about log groups, see [Working with log groups and log streams](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html) in the Amazon CloudWatch Logs User Guide.
        public var logGroupArn: Swift.String?

        public init(
            logGroupArn: Swift.String? = nil
        )
        {
            self.logGroupArn = logGroupArn
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateSnapshotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case simulation = "Simulation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let simulation = self.simulation {
            try encodeContainer.encode(simulation, forKey: .simulation)
        }
    }
}

extension CreateSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createsnapshot"
    }
}

public struct CreateSnapshotInput: Swift.Equatable {
    /// The Amazon S3 bucket and optional folder (object key prefix) where SimSpace Weaver creates the snapshot file. The Amazon S3 bucket must be in the same Amazon Web Services Region as the simulation.
    /// This member is required.
    public var destination: SimSpaceWeaverClientTypes.S3Destination?
    /// The name of the simulation.
    /// This member is required.
    public var simulation: Swift.String?

    public init(
        destination: SimSpaceWeaverClientTypes.S3Destination? = nil,
        simulation: Swift.String? = nil
    )
    {
        self.destination = destination
        self.simulation = simulation
    }
}

struct CreateSnapshotInputBody: Swift.Equatable {
    let simulation: Swift.String?
    let destination: SimSpaceWeaverClientTypes.S3Destination?
}

extension CreateSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case simulation = "Simulation"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simulationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .simulation)
        simulation = simulationDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(SimSpaceWeaverClientTypes.S3Destination.self, forKey: .destination)
        destination = destinationDecoded
    }
}

public enum CreateSnapshotOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateSnapshotOutputResponse: Swift.Equatable {

    public init() { }
}

extension DeleteAppInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let app = app else {
                let message = "Creating a URL Query Item failed. app is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let appQueryItem = ClientRuntime.URLQueryItem(name: "app".urlPercentEncoding(), value: Swift.String(app).urlPercentEncoding())
            items.append(appQueryItem)
            guard let simulation = simulation else {
                let message = "Creating a URL Query Item failed. simulation is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let simulationQueryItem = ClientRuntime.URLQueryItem(name: "simulation".urlPercentEncoding(), value: Swift.String(simulation).urlPercentEncoding())
            items.append(simulationQueryItem)
            guard let domain = domain else {
                let message = "Creating a URL Query Item failed. domain is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
            return items
        }
    }
}

extension DeleteAppInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deleteapp"
    }
}

public struct DeleteAppInput: Swift.Equatable {
    /// The name of the app.
    /// This member is required.
    public var app: Swift.String?
    /// The name of the domain of the app.
    /// This member is required.
    public var domain: Swift.String?
    /// The name of the simulation of the app.
    /// This member is required.
    public var simulation: Swift.String?

    public init(
        app: Swift.String? = nil,
        domain: Swift.String? = nil,
        simulation: Swift.String? = nil
    )
    {
        self.app = app
        self.domain = domain
        self.simulation = simulation
    }
}

struct DeleteAppInputBody: Swift.Equatable {
}

extension DeleteAppInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum DeleteAppOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAppOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAppOutputResponse: Swift.Equatable {

    public init() { }
}

extension DeleteSimulationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let simulation = simulation else {
                let message = "Creating a URL Query Item failed. simulation is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let simulationQueryItem = ClientRuntime.URLQueryItem(name: "simulation".urlPercentEncoding(), value: Swift.String(simulation).urlPercentEncoding())
            items.append(simulationQueryItem)
            return items
        }
    }
}

extension DeleteSimulationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deletesimulation"
    }
}

public struct DeleteSimulationInput: Swift.Equatable {
    /// The name of the simulation.
    /// This member is required.
    public var simulation: Swift.String?

    public init(
        simulation: Swift.String? = nil
    )
    {
        self.simulation = simulation
    }
}

struct DeleteSimulationInputBody: Swift.Equatable {
}

extension DeleteSimulationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum DeleteSimulationOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSimulationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSimulationOutputResponse: Swift.Equatable {

    public init() { }
}

extension DescribeAppInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let app = app else {
                let message = "Creating a URL Query Item failed. app is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let appQueryItem = ClientRuntime.URLQueryItem(name: "app".urlPercentEncoding(), value: Swift.String(app).urlPercentEncoding())
            items.append(appQueryItem)
            guard let simulation = simulation else {
                let message = "Creating a URL Query Item failed. simulation is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let simulationQueryItem = ClientRuntime.URLQueryItem(name: "simulation".urlPercentEncoding(), value: Swift.String(simulation).urlPercentEncoding())
            items.append(simulationQueryItem)
            guard let domain = domain else {
                let message = "Creating a URL Query Item failed. domain is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
            return items
        }
    }
}

extension DescribeAppInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeapp"
    }
}

public struct DescribeAppInput: Swift.Equatable {
    /// The name of the app.
    /// This member is required.
    public var app: Swift.String?
    /// The name of the domain of the app.
    /// This member is required.
    public var domain: Swift.String?
    /// The name of the simulation of the app.
    /// This member is required.
    public var simulation: Swift.String?

    public init(
        app: Swift.String? = nil,
        domain: Swift.String? = nil,
        simulation: Swift.String? = nil
    )
    {
        self.app = app
        self.domain = domain
        self.simulation = simulation
    }
}

struct DescribeAppInputBody: Swift.Equatable {
}

extension DescribeAppInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum DescribeAppOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAppOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAppOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.domain = output.domain
            self.endpointInfo = output.endpointInfo
            self.launchOverrides = output.launchOverrides
            self.name = output.name
            self.simulation = output.simulation
            self.status = output.status
            self.targetStatus = output.targetStatus
        } else {
            self.description = nil
            self.domain = nil
            self.endpointInfo = nil
            self.launchOverrides = nil
            self.name = nil
            self.simulation = nil
            self.status = nil
            self.targetStatus = nil
        }
    }
}

public struct DescribeAppOutputResponse: Swift.Equatable {
    /// The description of the app.
    public var description: Swift.String?
    /// The name of the domain of the app.
    public var domain: Swift.String?
    /// Information about the network endpoint for the custom app. You can use the endpoint to connect to the custom app.
    public var endpointInfo: SimSpaceWeaverClientTypes.SimulationAppEndpointInfo?
    /// Options that apply when the app starts. These options override default behavior.
    public var launchOverrides: SimSpaceWeaverClientTypes.LaunchOverrides?
    /// The name of the app.
    public var name: Swift.String?
    /// The name of the simulation of the app.
    public var simulation: Swift.String?
    /// The current lifecycle state of the custom app.
    public var status: SimSpaceWeaverClientTypes.SimulationAppStatus?
    /// The desired lifecycle state of the custom app.
    public var targetStatus: SimSpaceWeaverClientTypes.SimulationAppTargetStatus?

    public init(
        description: Swift.String? = nil,
        domain: Swift.String? = nil,
        endpointInfo: SimSpaceWeaverClientTypes.SimulationAppEndpointInfo? = nil,
        launchOverrides: SimSpaceWeaverClientTypes.LaunchOverrides? = nil,
        name: Swift.String? = nil,
        simulation: Swift.String? = nil,
        status: SimSpaceWeaverClientTypes.SimulationAppStatus? = nil,
        targetStatus: SimSpaceWeaverClientTypes.SimulationAppTargetStatus? = nil
    )
    {
        self.description = description
        self.domain = domain
        self.endpointInfo = endpointInfo
        self.launchOverrides = launchOverrides
        self.name = name
        self.simulation = simulation
        self.status = status
        self.targetStatus = targetStatus
    }
}

struct DescribeAppOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let simulation: Swift.String?
    let domain: Swift.String?
    let status: SimSpaceWeaverClientTypes.SimulationAppStatus?
    let targetStatus: SimSpaceWeaverClientTypes.SimulationAppTargetStatus?
    let launchOverrides: SimSpaceWeaverClientTypes.LaunchOverrides?
    let description: Swift.String?
    let endpointInfo: SimSpaceWeaverClientTypes.SimulationAppEndpointInfo?
}

extension DescribeAppOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case domain = "Domain"
        case endpointInfo = "EndpointInfo"
        case launchOverrides = "LaunchOverrides"
        case name = "Name"
        case simulation = "Simulation"
        case status = "Status"
        case targetStatus = "TargetStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let simulationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .simulation)
        simulation = simulationDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SimSpaceWeaverClientTypes.SimulationAppStatus.self, forKey: .status)
        status = statusDecoded
        let targetStatusDecoded = try containerValues.decodeIfPresent(SimSpaceWeaverClientTypes.SimulationAppTargetStatus.self, forKey: .targetStatus)
        targetStatus = targetStatusDecoded
        let launchOverridesDecoded = try containerValues.decodeIfPresent(SimSpaceWeaverClientTypes.LaunchOverrides.self, forKey: .launchOverrides)
        launchOverrides = launchOverridesDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let endpointInfoDecoded = try containerValues.decodeIfPresent(SimSpaceWeaverClientTypes.SimulationAppEndpointInfo.self, forKey: .endpointInfo)
        endpointInfo = endpointInfoDecoded
    }
}

extension DescribeSimulationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let simulation = simulation else {
                let message = "Creating a URL Query Item failed. simulation is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let simulationQueryItem = ClientRuntime.URLQueryItem(name: "simulation".urlPercentEncoding(), value: Swift.String(simulation).urlPercentEncoding())
            items.append(simulationQueryItem)
            return items
        }
    }
}

extension DescribeSimulationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describesimulation"
    }
}

public struct DescribeSimulationInput: Swift.Equatable {
    /// The name of the simulation.
    /// This member is required.
    public var simulation: Swift.String?

    public init(
        simulation: Swift.String? = nil
    )
    {
        self.simulation = simulation
    }
}

struct DescribeSimulationInputBody: Swift.Equatable {
}

extension DescribeSimulationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum DescribeSimulationOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeSimulationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeSimulationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.description = output.description
            self.executionId = output.executionId
            self.liveSimulationState = output.liveSimulationState
            self.loggingConfiguration = output.loggingConfiguration
            self.maximumDuration = output.maximumDuration
            self.name = output.name
            self.roleArn = output.roleArn
            self.schemaError = output.schemaError
            self.schemaS3Location = output.schemaS3Location
            self.snapshotS3Location = output.snapshotS3Location
            self.startError = output.startError
            self.status = output.status
            self.targetStatus = output.targetStatus
        } else {
            self.arn = nil
            self.creationTime = nil
            self.description = nil
            self.executionId = nil
            self.liveSimulationState = nil
            self.loggingConfiguration = nil
            self.maximumDuration = nil
            self.name = nil
            self.roleArn = nil
            self.schemaError = nil
            self.schemaS3Location = nil
            self.snapshotS3Location = nil
            self.startError = nil
            self.status = nil
            self.targetStatus = nil
        }
    }
}

public struct DescribeSimulationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the simulation. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    public var arn: Swift.String?
    /// The time when the simulation was created, expressed as the number of seconds and milliseconds in UTC since the Unix epoch (0:0:0.000, January 1, 1970).
    public var creationTime: ClientRuntime.Date?
    /// The description of the simulation.
    public var description: Swift.String?
    /// A universally unique identifier (UUID) for this simulation.
    public var executionId: Swift.String?
    /// A collection of additional state information, such as domain and clock configuration.
    public var liveSimulationState: SimSpaceWeaverClientTypes.LiveSimulationState?
    /// Settings that control how SimSpace Weaver handles your simulation log data.
    public var loggingConfiguration: SimSpaceWeaverClientTypes.LoggingConfiguration?
    /// The maximum running time of the simulation, specified as a number of minutes (m or M), hours (h or H), or days (d or D). The simulation stops when it reaches this limit. The maximum value is 14D, or its equivalent in the other units. The default value is 14D. A value equivalent to 0 makes the simulation immediately transition to Stopping as soon as it reaches Started.
    public var maximumDuration: Swift.String?
    /// The name of the simulation.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that the simulation assumes to perform actions. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference. For more information about IAM roles, see [IAM roles](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html) in the Identity and Access Management User Guide.
    public var roleArn: Swift.String?
    /// An error message that SimSpace Weaver returns only if there is a problem with the simulation schema.
    @available(*, deprecated, message: "SchemaError is no longer used, check StartError instead.")
    public var schemaError: Swift.String?
    /// The location of the simulation schema in Amazon Simple Storage Service (Amazon S3). For more information about Amazon S3, see the [ Amazon Simple Storage Service User Guide ](https://docs.aws.amazon.com/AmazonS3/latest/userguide/Welcome.html).
    public var schemaS3Location: SimSpaceWeaverClientTypes.S3Location?
    /// A location in Amazon Simple Storage Service (Amazon S3) where SimSpace Weaver stores simulation data, such as your app .zip files and schema file. For more information about Amazon S3, see the [ Amazon Simple Storage Service User Guide ](https://docs.aws.amazon.com/AmazonS3/latest/userguide/Welcome.html).
    public var snapshotS3Location: SimSpaceWeaverClientTypes.S3Location?
    /// An error message that SimSpace Weaver returns only if a problem occurs when the simulation is in the STARTING state.
    public var startError: Swift.String?
    /// The current lifecycle state of the simulation.
    public var status: SimSpaceWeaverClientTypes.SimulationStatus?
    /// The desired lifecycle state of the simulation.
    public var targetStatus: SimSpaceWeaverClientTypes.SimulationTargetStatus?

    public init(
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        executionId: Swift.String? = nil,
        liveSimulationState: SimSpaceWeaverClientTypes.LiveSimulationState? = nil,
        loggingConfiguration: SimSpaceWeaverClientTypes.LoggingConfiguration? = nil,
        maximumDuration: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        schemaError: Swift.String? = nil,
        schemaS3Location: SimSpaceWeaverClientTypes.S3Location? = nil,
        snapshotS3Location: SimSpaceWeaverClientTypes.S3Location? = nil,
        startError: Swift.String? = nil,
        status: SimSpaceWeaverClientTypes.SimulationStatus? = nil,
        targetStatus: SimSpaceWeaverClientTypes.SimulationTargetStatus? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.executionId = executionId
        self.liveSimulationState = liveSimulationState
        self.loggingConfiguration = loggingConfiguration
        self.maximumDuration = maximumDuration
        self.name = name
        self.roleArn = roleArn
        self.schemaError = schemaError
        self.schemaS3Location = schemaS3Location
        self.snapshotS3Location = snapshotS3Location
        self.startError = startError
        self.status = status
        self.targetStatus = targetStatus
    }
}

struct DescribeSimulationOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let executionId: Swift.String?
    let arn: Swift.String?
    let description: Swift.String?
    let roleArn: Swift.String?
    let creationTime: ClientRuntime.Date?
    let status: SimSpaceWeaverClientTypes.SimulationStatus?
    let targetStatus: SimSpaceWeaverClientTypes.SimulationTargetStatus?
    let schemaS3Location: SimSpaceWeaverClientTypes.S3Location?
    let schemaError: Swift.String?
    let loggingConfiguration: SimSpaceWeaverClientTypes.LoggingConfiguration?
    let liveSimulationState: SimSpaceWeaverClientTypes.LiveSimulationState?
    let maximumDuration: Swift.String?
    let snapshotS3Location: SimSpaceWeaverClientTypes.S3Location?
    let startError: Swift.String?
}

extension DescribeSimulationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case description = "Description"
        case executionId = "ExecutionId"
        case liveSimulationState = "LiveSimulationState"
        case loggingConfiguration = "LoggingConfiguration"
        case maximumDuration = "MaximumDuration"
        case name = "Name"
        case roleArn = "RoleArn"
        case schemaError = "SchemaError"
        case schemaS3Location = "SchemaS3Location"
        case snapshotS3Location = "SnapshotS3Location"
        case startError = "StartError"
        case status = "Status"
        case targetStatus = "TargetStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SimSpaceWeaverClientTypes.SimulationStatus.self, forKey: .status)
        status = statusDecoded
        let targetStatusDecoded = try containerValues.decodeIfPresent(SimSpaceWeaverClientTypes.SimulationTargetStatus.self, forKey: .targetStatus)
        targetStatus = targetStatusDecoded
        let schemaS3LocationDecoded = try containerValues.decodeIfPresent(SimSpaceWeaverClientTypes.S3Location.self, forKey: .schemaS3Location)
        schemaS3Location = schemaS3LocationDecoded
        let schemaErrorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaError)
        schemaError = schemaErrorDecoded
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(SimSpaceWeaverClientTypes.LoggingConfiguration.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
        let liveSimulationStateDecoded = try containerValues.decodeIfPresent(SimSpaceWeaverClientTypes.LiveSimulationState.self, forKey: .liveSimulationState)
        liveSimulationState = liveSimulationStateDecoded
        let maximumDurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maximumDuration)
        maximumDuration = maximumDurationDecoded
        let snapshotS3LocationDecoded = try containerValues.decodeIfPresent(SimSpaceWeaverClientTypes.S3Location.self, forKey: .snapshotS3Location)
        snapshotS3Location = snapshotS3LocationDecoded
        let startErrorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startError)
        startError = startErrorDecoded
    }
}

extension SimSpaceWeaverClientTypes.Domain: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecycle = "Lifecycle"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lifecycle = self.lifecycle {
            try encodeContainer.encode(lifecycle.rawValue, forKey: .lifecycle)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(SimSpaceWeaverClientTypes.LifecycleManagementStrategy.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
    }
}

extension SimSpaceWeaverClientTypes {
    /// A collection of app instances that run the same executable app code and have the same launch options and commands. For more information about domains, see [Key concepts: Domains](https://docs.aws.amazon.com/simspaceweaver/latest/userguide/what-is_key-concepts.html#what-is_key-concepts_domains) in the SimSpace Weaver User Guide.
    public struct Domain: Swift.Equatable {
        /// The type of lifecycle management for apps in the domain. Indicates whether apps in this domain are managed (SimSpace Weaver starts and stops the apps) or unmanaged (you must start and stop the apps). Lifecycle types
        ///
        /// * PerWorker – Managed: SimSpace Weaver starts one app on each worker.
        ///
        /// * BySpatialSubdivision – Managed: SimSpace Weaver starts one app for each spatial partition.
        ///
        /// * ByRequest – Unmanaged: You use the StartApp API to start the apps and use the StopApp API to stop the apps.
        public var lifecycle: SimSpaceWeaverClientTypes.LifecycleManagementStrategy?
        /// The name of the domain.
        public var name: Swift.String?

        public init(
            lifecycle: SimSpaceWeaverClientTypes.LifecycleManagementStrategy? = nil,
            name: Swift.String? = nil
        )
        {
            self.lifecycle = lifecycle
            self.name = name
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SimSpaceWeaverClientTypes.LaunchOverrides: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchCommands = "LaunchCommands"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let launchCommands = launchCommands {
            var launchCommandsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .launchCommands)
            for nonemptystring0 in launchCommands {
                try launchCommandsContainer.encode(nonemptystring0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchCommandsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .launchCommands)
        var launchCommandsDecoded0:[Swift.String]? = nil
        if let launchCommandsContainer = launchCommandsContainer {
            launchCommandsDecoded0 = [Swift.String]()
            for string0 in launchCommandsContainer {
                if let string0 = string0 {
                    launchCommandsDecoded0?.append(string0)
                }
            }
        }
        launchCommands = launchCommandsDecoded0
    }
}

extension SimSpaceWeaverClientTypes {
    /// Options that apply when the app starts. These options override default behavior.
    public struct LaunchOverrides: Swift.Equatable {
        /// App launch commands and command line parameters that override the launch command configured in the simulation schema.
        public var launchCommands: [Swift.String]?

        public init(
            launchCommands: [Swift.String]? = nil
        )
        {
            self.launchCommands = launchCommands
        }
    }

}

extension SimSpaceWeaverClientTypes {
    public enum LifecycleManagementStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case byrequest
        case byspatialsubdivision
        case perworker
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [LifecycleManagementStrategy] {
            return [
                .byrequest,
                .byspatialsubdivision,
                .perworker,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .byrequest: return "ByRequest"
            case .byspatialsubdivision: return "BySpatialSubdivision"
            case .perworker: return "PerWorker"
            case .unknown: return "Unknown"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LifecycleManagementStrategy(rawValue: rawValue) ?? LifecycleManagementStrategy.sdkUnknown(rawValue)
        }
    }
}

extension ListAppsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let simulation = simulation else {
                let message = "Creating a URL Query Item failed. simulation is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let simulationQueryItem = ClientRuntime.URLQueryItem(name: "simulation".urlPercentEncoding(), value: Swift.String(simulation).urlPercentEncoding())
            items.append(simulationQueryItem)
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let domain = domain {
                let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
                items.append(domainQueryItem)
            }
            return items
        }
    }
}

extension ListAppsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listapps"
    }
}

public struct ListAppsInput: Swift.Equatable {
    /// The name of the domain that you want to list apps for.
    public var domain: Swift.String?
    /// The maximum number of apps to list.
    public var maxResults: Swift.Int?
    /// If SimSpace Weaver returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?
    /// The name of the simulation that you want to list apps for.
    /// This member is required.
    public var simulation: Swift.String?

    public init(
        domain: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        simulation: Swift.String? = nil
    )
    {
        self.domain = domain
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.simulation = simulation
    }
}

struct ListAppsInputBody: Swift.Equatable {
}

extension ListAppsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum ListAppsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAppsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAppsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apps = output.apps
            self.nextToken = output.nextToken
        } else {
            self.apps = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppsOutputResponse: Swift.Equatable {
    /// The list of apps for the given simulation and domain.
    public var apps: [SimSpaceWeaverClientTypes.SimulationAppMetadata]?
    /// If SimSpace Weaver returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?

    public init(
        apps: [SimSpaceWeaverClientTypes.SimulationAppMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apps = apps
        self.nextToken = nextToken
    }
}

struct ListAppsOutputResponseBody: Swift.Equatable {
    let apps: [SimSpaceWeaverClientTypes.SimulationAppMetadata]?
    let nextToken: Swift.String?
}

extension ListAppsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apps = "Apps"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appsContainer = try containerValues.decodeIfPresent([SimSpaceWeaverClientTypes.SimulationAppMetadata?].self, forKey: .apps)
        var appsDecoded0:[SimSpaceWeaverClientTypes.SimulationAppMetadata]? = nil
        if let appsContainer = appsContainer {
            appsDecoded0 = [SimSpaceWeaverClientTypes.SimulationAppMetadata]()
            for structure0 in appsContainer {
                if let structure0 = structure0 {
                    appsDecoded0?.append(structure0)
                }
            }
        }
        apps = appsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSimulationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListSimulationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listsimulations"
    }
}

public struct ListSimulationsInput: Swift.Equatable {
    /// The maximum number of simulations to list.
    public var maxResults: Swift.Int?
    /// If SimSpace Weaver returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSimulationsInputBody: Swift.Equatable {
}

extension ListSimulationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum ListSimulationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSimulationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSimulationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.simulations = output.simulations
        } else {
            self.nextToken = nil
            self.simulations = nil
        }
    }
}

public struct ListSimulationsOutputResponse: Swift.Equatable {
    /// If SimSpace Weaver returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?
    /// The list of simulations.
    public var simulations: [SimSpaceWeaverClientTypes.SimulationMetadata]?

    public init(
        nextToken: Swift.String? = nil,
        simulations: [SimSpaceWeaverClientTypes.SimulationMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.simulations = simulations
    }
}

struct ListSimulationsOutputResponseBody: Swift.Equatable {
    let simulations: [SimSpaceWeaverClientTypes.SimulationMetadata]?
    let nextToken: Swift.String?
}

extension ListSimulationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case simulations = "Simulations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simulationsContainer = try containerValues.decodeIfPresent([SimSpaceWeaverClientTypes.SimulationMetadata?].self, forKey: .simulations)
        var simulationsDecoded0:[SimSpaceWeaverClientTypes.SimulationMetadata]? = nil
        if let simulationsContainer = simulationsContainer {
            simulationsDecoded0 = [SimSpaceWeaverClientTypes.SimulationMetadata]()
            for structure0 in simulationsContainer {
                if let structure0 = structure0 {
                    simulationsDecoded0?.append(structure0)
                }
            }
        }
        simulations = simulationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The list of tags for the resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SimSpaceWeaverClientTypes.LiveSimulationState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clocks = "Clocks"
        case domains = "Domains"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clocks = clocks {
            var clocksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .clocks)
            for simulationclock0 in clocks {
                try clocksContainer.encode(simulationclock0)
            }
        }
        if let domains = domains {
            var domainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domains)
            for domain0 in domains {
                try domainsContainer.encode(domain0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainsContainer = try containerValues.decodeIfPresent([SimSpaceWeaverClientTypes.Domain?].self, forKey: .domains)
        var domainsDecoded0:[SimSpaceWeaverClientTypes.Domain]? = nil
        if let domainsContainer = domainsContainer {
            domainsDecoded0 = [SimSpaceWeaverClientTypes.Domain]()
            for structure0 in domainsContainer {
                if let structure0 = structure0 {
                    domainsDecoded0?.append(structure0)
                }
            }
        }
        domains = domainsDecoded0
        let clocksContainer = try containerValues.decodeIfPresent([SimSpaceWeaverClientTypes.SimulationClock?].self, forKey: .clocks)
        var clocksDecoded0:[SimSpaceWeaverClientTypes.SimulationClock]? = nil
        if let clocksContainer = clocksContainer {
            clocksDecoded0 = [SimSpaceWeaverClientTypes.SimulationClock]()
            for structure0 in clocksContainer {
                if let structure0 = structure0 {
                    clocksDecoded0?.append(structure0)
                }
            }
        }
        clocks = clocksDecoded0
    }
}

extension SimSpaceWeaverClientTypes {
    /// A collection of additional state information, such as domain and clock configuration.
    public struct LiveSimulationState: Swift.Equatable {
        /// A list of simulation clocks. At this time, a simulation has only one clock.
        public var clocks: [SimSpaceWeaverClientTypes.SimulationClock]?
        /// A list of domains for the simulation. For more information about domains, see [Key concepts: Domains](https://docs.aws.amazon.com/simspaceweaver/latest/userguide/what-is_key-concepts.html#what-is_key-concepts_domains) in the SimSpace Weaver User Guide.
        public var domains: [SimSpaceWeaverClientTypes.Domain]?

        public init(
            clocks: [SimSpaceWeaverClientTypes.SimulationClock]? = nil,
            domains: [SimSpaceWeaverClientTypes.Domain]? = nil
        )
        {
            self.clocks = clocks
            self.domains = domains
        }
    }

}

extension SimSpaceWeaverClientTypes.LogDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsLogGroup = "CloudWatchLogsLogGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogsLogGroup = self.cloudWatchLogsLogGroup {
            try encodeContainer.encode(cloudWatchLogsLogGroup, forKey: .cloudWatchLogsLogGroup)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLogsLogGroupDecoded = try containerValues.decodeIfPresent(SimSpaceWeaverClientTypes.CloudWatchLogsLogGroup.self, forKey: .cloudWatchLogsLogGroup)
        cloudWatchLogsLogGroup = cloudWatchLogsLogGroupDecoded
    }
}

extension SimSpaceWeaverClientTypes {
    /// The location where SimSpace Weaver sends simulation log data.
    public struct LogDestination: Swift.Equatable {
        /// An Amazon CloudWatch Logs log group that stores simulation log data. For more information about log groups, see [Working with log groups and log streams](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html) in the Amazon CloudWatch Logs User Guide.
        public var cloudWatchLogsLogGroup: SimSpaceWeaverClientTypes.CloudWatchLogsLogGroup?

        public init(
            cloudWatchLogsLogGroup: SimSpaceWeaverClientTypes.CloudWatchLogsLogGroup? = nil
        )
        {
            self.cloudWatchLogsLogGroup = cloudWatchLogsLogGroup
        }
    }

}

extension SimSpaceWeaverClientTypes.LoggingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinations = "Destinations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinations = destinations {
            var destinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinations)
            for logdestination0 in destinations {
                try destinationsContainer.encode(logdestination0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationsContainer = try containerValues.decodeIfPresent([SimSpaceWeaverClientTypes.LogDestination?].self, forKey: .destinations)
        var destinationsDecoded0:[SimSpaceWeaverClientTypes.LogDestination]? = nil
        if let destinationsContainer = destinationsContainer {
            destinationsDecoded0 = [SimSpaceWeaverClientTypes.LogDestination]()
            for structure0 in destinationsContainer {
                if let structure0 = structure0 {
                    destinationsDecoded0?.append(structure0)
                }
            }
        }
        destinations = destinationsDecoded0
    }
}

extension SimSpaceWeaverClientTypes {
    /// The logging configuration for a simulation.
    public struct LoggingConfiguration: Swift.Equatable {
        /// A list of the locations where SimSpace Weaver sends simulation log data.
        public var destinations: [SimSpaceWeaverClientTypes.LogDestination]?

        public init(
            destinations: [SimSpaceWeaverClientTypes.LogDestination]? = nil
        )
        {
            self.destinations = destinations
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SimSpaceWeaverClientTypes.S3Destination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName = "BucketName"
        case objectKeyPrefix = "ObjectKeyPrefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let objectKeyPrefix = self.objectKeyPrefix {
            try encodeContainer.encode(objectKeyPrefix, forKey: .objectKeyPrefix)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let objectKeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectKeyPrefix)
        objectKeyPrefix = objectKeyPrefixDecoded
    }
}

extension SimSpaceWeaverClientTypes {
    /// An Amazon S3 bucket and optional folder (object key prefix) where SimSpace Weaver creates a file.
    public struct S3Destination: Swift.Equatable {
        /// The name of an Amazon S3 bucket. For more information about buckets, see [Creating, configuring, and working with Amazon S3 buckets](https://docs.aws.amazon.com/AmazonS3/latest/userguide/creating-buckets-s3.html) in the Amazon Simple Storage Service User Guide.
        /// This member is required.
        public var bucketName: Swift.String?
        /// A string prefix for an Amazon S3 object key. It's usually a folder name. For more information about folders in Amazon S3, see [Organizing objects in the Amazon S3 console using folders](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-folders.html) in the Amazon Simple Storage Service User Guide.
        public var objectKeyPrefix: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            objectKeyPrefix: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.objectKeyPrefix = objectKeyPrefix
        }
    }

}

extension SimSpaceWeaverClientTypes.S3Location: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName = "BucketName"
        case objectKey = "ObjectKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let objectKey = self.objectKey {
            try encodeContainer.encode(objectKey, forKey: .objectKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let objectKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectKey)
        objectKey = objectKeyDecoded
    }
}

extension SimSpaceWeaverClientTypes {
    /// A location in Amazon Simple Storage Service (Amazon S3) where SimSpace Weaver stores simulation data, such as your app .zip files and schema file. For more information about Amazon S3, see the [ Amazon Simple Storage Service User Guide ](https://docs.aws.amazon.com/AmazonS3/latest/userguide/Welcome.html).
    public struct S3Location: Swift.Equatable {
        /// The name of an Amazon S3 bucket. For more information about buckets, see [Creating, configuring, and working with Amazon S3 buckets](https://docs.aws.amazon.com/AmazonS3/latest/userguide/creating-buckets-s3.html) in the Amazon Simple Storage Service User Guide.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The key name of an object in Amazon S3. For more information about Amazon S3 objects and object keys, see [Uploading, downloading, and working with objects in Amazon S3](https://docs.aws.amazon.com/AmazonS3/latest/userguide/uploading-downloading-objects.html) in the Amazon Simple Storage Service User Guide.
        /// This member is required.
        public var objectKey: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            objectKey: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.objectKey = objectKey
        }
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SimSpaceWeaverClientTypes.SimulationAppEndpointInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case ingressPortMappings = "IngressPortMappings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = self.address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let ingressPortMappings = ingressPortMappings {
            var ingressPortMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ingressPortMappings)
            for simulationappportmapping0 in ingressPortMappings {
                try ingressPortMappingsContainer.encode(simulationappportmapping0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        let ingressPortMappingsContainer = try containerValues.decodeIfPresent([SimSpaceWeaverClientTypes.SimulationAppPortMapping?].self, forKey: .ingressPortMappings)
        var ingressPortMappingsDecoded0:[SimSpaceWeaverClientTypes.SimulationAppPortMapping]? = nil
        if let ingressPortMappingsContainer = ingressPortMappingsContainer {
            ingressPortMappingsDecoded0 = [SimSpaceWeaverClientTypes.SimulationAppPortMapping]()
            for structure0 in ingressPortMappingsContainer {
                if let structure0 = structure0 {
                    ingressPortMappingsDecoded0?.append(structure0)
                }
            }
        }
        ingressPortMappings = ingressPortMappingsDecoded0
    }
}

extension SimSpaceWeaverClientTypes {
    /// Information about the network endpoint that you can use to connect to your custom or service app. For more information about SimSpace Weaver apps, see [Key concepts: Apps](https://docs.aws.amazon.com/simspaceweaver/latest/userguide/what-is_key-concepts.html#what-is_key-concepts_apps) in the SimSpace Weaver User Guide..
    public struct SimulationAppEndpointInfo: Swift.Equatable {
        /// The IP address of the app. SimSpace Weaver dynamically assigns this IP address when the app starts.
        public var address: Swift.String?
        /// The inbound TCP/UDP port numbers of the app. The combination of an IP address and a port number form a network endpoint.
        public var ingressPortMappings: [SimSpaceWeaverClientTypes.SimulationAppPortMapping]?

        public init(
            address: Swift.String? = nil,
            ingressPortMappings: [SimSpaceWeaverClientTypes.SimulationAppPortMapping]? = nil
        )
        {
            self.address = address
            self.ingressPortMappings = ingressPortMappings
        }
    }

}

extension SimSpaceWeaverClientTypes.SimulationAppMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
        case name = "Name"
        case simulation = "Simulation"
        case status = "Status"
        case targetStatus = "TargetStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = self.domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let simulation = self.simulation {
            try encodeContainer.encode(simulation, forKey: .simulation)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let targetStatus = self.targetStatus {
            try encodeContainer.encode(targetStatus.rawValue, forKey: .targetStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let simulationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .simulation)
        simulation = simulationDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SimSpaceWeaverClientTypes.SimulationAppStatus.self, forKey: .status)
        status = statusDecoded
        let targetStatusDecoded = try containerValues.decodeIfPresent(SimSpaceWeaverClientTypes.SimulationAppTargetStatus.self, forKey: .targetStatus)
        targetStatus = targetStatusDecoded
    }
}

extension SimSpaceWeaverClientTypes {
    /// A collection of metadata about the app.
    public struct SimulationAppMetadata: Swift.Equatable {
        /// The domain of the app. For more information about domains, see [Key concepts: Domains](https://docs.aws.amazon.com/simspaceweaver/latest/userguide/what-is_key-concepts.html#what-is_key-concepts_domains) in the SimSpace Weaver User Guide.
        public var domain: Swift.String?
        /// The name of the app.
        public var name: Swift.String?
        /// The name of the simulation of the app.
        public var simulation: Swift.String?
        /// The current status of the app.
        public var status: SimSpaceWeaverClientTypes.SimulationAppStatus?
        /// The desired status of the app.
        public var targetStatus: SimSpaceWeaverClientTypes.SimulationAppTargetStatus?

        public init(
            domain: Swift.String? = nil,
            name: Swift.String? = nil,
            simulation: Swift.String? = nil,
            status: SimSpaceWeaverClientTypes.SimulationAppStatus? = nil,
            targetStatus: SimSpaceWeaverClientTypes.SimulationAppTargetStatus? = nil
        )
        {
            self.domain = domain
            self.name = name
            self.simulation = simulation
            self.status = status
            self.targetStatus = targetStatus
        }
    }

}

extension SimSpaceWeaverClientTypes.SimulationAppPortMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actual = "Actual"
        case declared = "Declared"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actual = self.actual {
            try encodeContainer.encode(actual, forKey: .actual)
        }
        if let declared = self.declared {
            try encodeContainer.encode(declared, forKey: .declared)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let declaredDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .declared)
        declared = declaredDecoded
        let actualDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .actual)
        actual = actualDecoded
    }
}

extension SimSpaceWeaverClientTypes {
    /// A collection of TCP/UDP ports for a custom or service app.
    public struct SimulationAppPortMapping: Swift.Equatable {
        /// The TCP/UDP port number of the running app. SimSpace Weaver dynamically assigns this port number when the app starts. SimSpace Weaver maps the Declared port to the Actual port. Clients connect to the app using the app's IP address and the Actual port number.
        public var actual: Swift.Int?
        /// The TCP/UDP port number of the app, declared in the simulation schema. SimSpace Weaver maps the Declared port to the Actual port. The source code for the app should bind to the Declared port.
        public var declared: Swift.Int?

        public init(
            actual: Swift.Int? = nil,
            declared: Swift.Int? = nil
        )
        {
            self.actual = actual
            self.declared = declared
        }
    }

}

extension SimSpaceWeaverClientTypes {
    public enum SimulationAppStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case started
        case starting
        case stopped
        case stopping
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [SimulationAppStatus] {
            return [
                .error,
                .started,
                .starting,
                .stopped,
                .stopping,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .started: return "STARTED"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SimulationAppStatus(rawValue: rawValue) ?? SimulationAppStatus.sdkUnknown(rawValue)
        }
    }
}

extension SimSpaceWeaverClientTypes {
    public enum SimulationAppTargetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case started
        case stopped
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [SimulationAppTargetStatus] {
            return [
                .started,
                .stopped,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .started: return "STARTED"
            case .stopped: return "STOPPED"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SimulationAppTargetStatus(rawValue: rawValue) ?? SimulationAppTargetStatus.sdkUnknown(rawValue)
        }
    }
}

extension SimSpaceWeaverClientTypes.SimulationClock: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
        case targetStatus = "TargetStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let targetStatus = self.targetStatus {
            try encodeContainer.encode(targetStatus.rawValue, forKey: .targetStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(SimSpaceWeaverClientTypes.ClockStatus.self, forKey: .status)
        status = statusDecoded
        let targetStatusDecoded = try containerValues.decodeIfPresent(SimSpaceWeaverClientTypes.ClockTargetStatus.self, forKey: .targetStatus)
        targetStatus = targetStatusDecoded
    }
}

extension SimSpaceWeaverClientTypes {
    /// Status information about the simulation clock.
    public struct SimulationClock: Swift.Equatable {
        /// The current status of the simulation clock.
        public var status: SimSpaceWeaverClientTypes.ClockStatus?
        /// The desired status of the simulation clock.
        public var targetStatus: SimSpaceWeaverClientTypes.ClockTargetStatus?

        public init(
            status: SimSpaceWeaverClientTypes.ClockStatus? = nil,
            targetStatus: SimSpaceWeaverClientTypes.ClockTargetStatus? = nil
        )
        {
            self.status = status
            self.targetStatus = targetStatus
        }
    }

}

extension SimSpaceWeaverClientTypes.SimulationMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case name = "Name"
        case status = "Status"
        case targetStatus = "TargetStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let targetStatus = self.targetStatus {
            try encodeContainer.encode(targetStatus.rawValue, forKey: .targetStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SimSpaceWeaverClientTypes.SimulationStatus.self, forKey: .status)
        status = statusDecoded
        let targetStatusDecoded = try containerValues.decodeIfPresent(SimSpaceWeaverClientTypes.SimulationTargetStatus.self, forKey: .targetStatus)
        targetStatus = targetStatusDecoded
    }
}

extension SimSpaceWeaverClientTypes {
    /// A collection of data about the simulation.
    public struct SimulationMetadata: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the simulation. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        public var arn: Swift.String?
        /// The time when the simulation was created, expressed as the number of seconds and milliseconds in UTC since the Unix epoch (0:0:0.000, January 1, 1970).
        public var creationTime: ClientRuntime.Date?
        /// The name of the simulation.
        public var name: Swift.String?
        /// The current status of the simulation.
        public var status: SimSpaceWeaverClientTypes.SimulationStatus?
        /// The desired status of the simulation.
        public var targetStatus: SimSpaceWeaverClientTypes.SimulationTargetStatus?

        public init(
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: SimSpaceWeaverClientTypes.SimulationStatus? = nil,
            targetStatus: SimSpaceWeaverClientTypes.SimulationTargetStatus? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.name = name
            self.status = status
            self.targetStatus = targetStatus
        }
    }

}

extension SimSpaceWeaverClientTypes {
    public enum SimulationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleted
        case deleting
        case failed
        case snapshotInProgress
        case started
        case starting
        case stopped
        case stopping
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [SimulationStatus] {
            return [
                .deleted,
                .deleting,
                .failed,
                .snapshotInProgress,
                .started,
                .starting,
                .stopped,
                .stopping,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .snapshotInProgress: return "SNAPSHOT_IN_PROGRESS"
            case .started: return "STARTED"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SimulationStatus(rawValue: rawValue) ?? SimulationStatus.sdkUnknown(rawValue)
        }
    }
}

extension SimSpaceWeaverClientTypes {
    public enum SimulationTargetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleted
        case started
        case stopped
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [SimulationTargetStatus] {
            return [
                .deleted,
                .started,
                .stopped,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "DELETED"
            case .started: return "STARTED"
            case .stopped: return "STOPPED"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SimulationTargetStatus(rawValue: rawValue) ?? SimulationTargetStatus.sdkUnknown(rawValue)
        }
    }
}

extension StartAppInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartAppInput(description: \(Swift.String(describing: description)), domain: \(Swift.String(describing: domain)), launchOverrides: \(Swift.String(describing: launchOverrides)), name: \(Swift.String(describing: name)), simulation: \(Swift.String(describing: simulation)), clientToken: \"CONTENT_REDACTED\")"}
}

extension StartAppInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case domain = "Domain"
        case launchOverrides = "LaunchOverrides"
        case name = "Name"
        case simulation = "Simulation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domain = self.domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let launchOverrides = self.launchOverrides {
            try encodeContainer.encode(launchOverrides, forKey: .launchOverrides)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let simulation = self.simulation {
            try encodeContainer.encode(simulation, forKey: .simulation)
        }
    }
}

extension StartAppInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/startapp"
    }
}

public struct StartAppInput: Swift.Equatable {
    /// A value that you provide to ensure that repeated calls to this API operation using the same parameters complete only once. A ClientToken is also known as an idempotency token. A ClientToken expires after 24 hours.
    public var clientToken: Swift.String?
    /// The description of the app.
    public var description: Swift.String?
    /// The name of the domain of the app.
    /// This member is required.
    public var domain: Swift.String?
    /// Options that apply when the app starts. These options override default behavior.
    public var launchOverrides: SimSpaceWeaverClientTypes.LaunchOverrides?
    /// The name of the app.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the simulation of the app.
    /// This member is required.
    public var simulation: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        domain: Swift.String? = nil,
        launchOverrides: SimSpaceWeaverClientTypes.LaunchOverrides? = nil,
        name: Swift.String? = nil,
        simulation: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.domain = domain
        self.launchOverrides = launchOverrides
        self.name = name
        self.simulation = simulation
    }
}

struct StartAppInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let simulation: Swift.String?
    let domain: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let launchOverrides: SimSpaceWeaverClientTypes.LaunchOverrides?
}

extension StartAppInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case domain = "Domain"
        case launchOverrides = "LaunchOverrides"
        case name = "Name"
        case simulation = "Simulation"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let simulationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .simulation)
        simulation = simulationDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let launchOverridesDecoded = try containerValues.decodeIfPresent(SimSpaceWeaverClientTypes.LaunchOverrides.self, forKey: .launchOverrides)
        launchOverrides = launchOverridesDecoded
    }
}

public enum StartAppOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartAppOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartAppOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domain = output.domain
            self.name = output.name
            self.simulation = output.simulation
        } else {
            self.domain = nil
            self.name = nil
            self.simulation = nil
        }
    }
}

public struct StartAppOutputResponse: Swift.Equatable {
    /// The name of the domain of the app.
    public var domain: Swift.String?
    /// The name of the app.
    public var name: Swift.String?
    /// The name of the simulation of the app.
    public var simulation: Swift.String?

    public init(
        domain: Swift.String? = nil,
        name: Swift.String? = nil,
        simulation: Swift.String? = nil
    )
    {
        self.domain = domain
        self.name = name
        self.simulation = simulation
    }
}

struct StartAppOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let domain: Swift.String?
    let simulation: Swift.String?
}

extension StartAppOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
        case name = "Name"
        case simulation = "Simulation"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let simulationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .simulation)
        simulation = simulationDecoded
    }
}

extension StartClockInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case simulation = "Simulation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let simulation = self.simulation {
            try encodeContainer.encode(simulation, forKey: .simulation)
        }
    }
}

extension StartClockInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/startclock"
    }
}

public struct StartClockInput: Swift.Equatable {
    /// The name of the simulation.
    /// This member is required.
    public var simulation: Swift.String?

    public init(
        simulation: Swift.String? = nil
    )
    {
        self.simulation = simulation
    }
}

struct StartClockInputBody: Swift.Equatable {
    let simulation: Swift.String?
}

extension StartClockInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case simulation = "Simulation"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simulationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .simulation)
        simulation = simulationDecoded
    }
}

public enum StartClockOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartClockOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StartClockOutputResponse: Swift.Equatable {

    public init() { }
}

extension StartSimulationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartSimulationInput(description: \(Swift.String(describing: description)), maximumDuration: \(Swift.String(describing: maximumDuration)), name: \(Swift.String(describing: name)), roleArn: \(Swift.String(describing: roleArn)), schemaS3Location: \(Swift.String(describing: schemaS3Location)), snapshotS3Location: \(Swift.String(describing: snapshotS3Location)), tags: \(Swift.String(describing: tags)), clientToken: \"CONTENT_REDACTED\")"}
}

extension StartSimulationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case maximumDuration = "MaximumDuration"
        case name = "Name"
        case roleArn = "RoleArn"
        case schemaS3Location = "SchemaS3Location"
        case snapshotS3Location = "SnapshotS3Location"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let maximumDuration = self.maximumDuration {
            try encodeContainer.encode(maximumDuration, forKey: .maximumDuration)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let schemaS3Location = self.schemaS3Location {
            try encodeContainer.encode(schemaS3Location, forKey: .schemaS3Location)
        }
        if let snapshotS3Location = self.snapshotS3Location {
            try encodeContainer.encode(snapshotS3Location, forKey: .snapshotS3Location)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension StartSimulationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/startsimulation"
    }
}

public struct StartSimulationInput: Swift.Equatable {
    /// A value that you provide to ensure that repeated calls to this API operation using the same parameters complete only once. A ClientToken is also known as an idempotency token. A ClientToken expires after 24 hours.
    public var clientToken: Swift.String?
    /// The description of the simulation.
    public var description: Swift.String?
    /// The maximum running time of the simulation, specified as a number of minutes (m or M), hours (h or H), or days (d or D). The simulation stops when it reaches this limit. The maximum value is 14D, or its equivalent in the other units. The default value is 14D. A value equivalent to 0 makes the simulation immediately transition to Stopping as soon as it reaches Started.
    public var maximumDuration: Swift.String?
    /// The name of the simulation.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that the simulation assumes to perform actions. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference. For more information about IAM roles, see [IAM roles](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html) in the Identity and Access Management User Guide.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The location of the simulation schema in Amazon Simple Storage Service (Amazon S3). For more information about Amazon S3, see the [ Amazon Simple Storage Service User Guide ](https://docs.aws.amazon.com/AmazonS3/latest/userguide/Welcome.html). Provide a SchemaS3Location to start your simulation from a schema. If you provide a SchemaS3Location then you can't provide a SnapshotS3Location.
    public var schemaS3Location: SimSpaceWeaverClientTypes.S3Location?
    /// The location of the snapshot .zip file in Amazon Simple Storage Service (Amazon S3). For more information about Amazon S3, see the [ Amazon Simple Storage Service User Guide ](https://docs.aws.amazon.com/AmazonS3/latest/userguide/Welcome.html). Provide a SnapshotS3Location to start your simulation from a snapshot. The Amazon S3 bucket must be in the same Amazon Web Services Region as the simulation. If you provide a SnapshotS3Location then you can't provide a SchemaS3Location.
    public var snapshotS3Location: SimSpaceWeaverClientTypes.S3Location?
    /// A list of tags for the simulation. For more information about tags, see [Tagging Amazon Web Services resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) in the Amazon Web Services General Reference.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        maximumDuration: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        schemaS3Location: SimSpaceWeaverClientTypes.S3Location? = nil,
        snapshotS3Location: SimSpaceWeaverClientTypes.S3Location? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.maximumDuration = maximumDuration
        self.name = name
        self.roleArn = roleArn
        self.schemaS3Location = schemaS3Location
        self.snapshotS3Location = snapshotS3Location
        self.tags = tags
    }
}

struct StartSimulationInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let roleArn: Swift.String?
    let schemaS3Location: SimSpaceWeaverClientTypes.S3Location?
    let maximumDuration: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let snapshotS3Location: SimSpaceWeaverClientTypes.S3Location?
}

extension StartSimulationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case maximumDuration = "MaximumDuration"
        case name = "Name"
        case roleArn = "RoleArn"
        case schemaS3Location = "SchemaS3Location"
        case snapshotS3Location = "SnapshotS3Location"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let schemaS3LocationDecoded = try containerValues.decodeIfPresent(SimSpaceWeaverClientTypes.S3Location.self, forKey: .schemaS3Location)
        schemaS3Location = schemaS3LocationDecoded
        let maximumDurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maximumDuration)
        maximumDuration = maximumDurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let snapshotS3LocationDecoded = try containerValues.decodeIfPresent(SimSpaceWeaverClientTypes.S3Location.self, forKey: .snapshotS3Location)
        snapshotS3Location = snapshotS3LocationDecoded
    }
}

public enum StartSimulationOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartSimulationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartSimulationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.executionId = output.executionId
        } else {
            self.arn = nil
            self.creationTime = nil
            self.executionId = nil
        }
    }
}

public struct StartSimulationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the simulation. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    public var arn: Swift.String?
    /// The time when the simulation was created, expressed as the number of seconds and milliseconds in UTC since the Unix epoch (0:0:0.000, January 1, 1970).
    public var creationTime: ClientRuntime.Date?
    /// A universally unique identifier (UUID) for this simulation.
    public var executionId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        executionId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.executionId = executionId
    }
}

struct StartSimulationOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let executionId: Swift.String?
    let creationTime: ClientRuntime.Date?
}

extension StartSimulationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case executionId = "ExecutionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension StopAppInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case app = "App"
        case domain = "Domain"
        case simulation = "Simulation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let app = self.app {
            try encodeContainer.encode(app, forKey: .app)
        }
        if let domain = self.domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let simulation = self.simulation {
            try encodeContainer.encode(simulation, forKey: .simulation)
        }
    }
}

extension StopAppInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/stopapp"
    }
}

public struct StopAppInput: Swift.Equatable {
    /// The name of the app.
    /// This member is required.
    public var app: Swift.String?
    /// The name of the domain of the app.
    /// This member is required.
    public var domain: Swift.String?
    /// The name of the simulation of the app.
    /// This member is required.
    public var simulation: Swift.String?

    public init(
        app: Swift.String? = nil,
        domain: Swift.String? = nil,
        simulation: Swift.String? = nil
    )
    {
        self.app = app
        self.domain = domain
        self.simulation = simulation
    }
}

struct StopAppInputBody: Swift.Equatable {
    let simulation: Swift.String?
    let domain: Swift.String?
    let app: Swift.String?
}

extension StopAppInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case app = "App"
        case domain = "Domain"
        case simulation = "Simulation"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simulationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .simulation)
        simulation = simulationDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let appDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .app)
        app = appDecoded
    }
}

public enum StopAppOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopAppOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopAppOutputResponse: Swift.Equatable {

    public init() { }
}

extension StopClockInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case simulation = "Simulation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let simulation = self.simulation {
            try encodeContainer.encode(simulation, forKey: .simulation)
        }
    }
}

extension StopClockInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/stopclock"
    }
}

public struct StopClockInput: Swift.Equatable {
    /// The name of the simulation.
    /// This member is required.
    public var simulation: Swift.String?

    public init(
        simulation: Swift.String? = nil
    )
    {
        self.simulation = simulation
    }
}

struct StopClockInputBody: Swift.Equatable {
    let simulation: Swift.String?
}

extension StopClockInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case simulation = "Simulation"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simulationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .simulation)
        simulation = simulationDecoded
    }
}

public enum StopClockOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopClockOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopClockOutputResponse: Swift.Equatable {

    public init() { }
}

extension StopSimulationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case simulation = "Simulation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let simulation = self.simulation {
            try encodeContainer.encode(simulation, forKey: .simulation)
        }
    }
}

extension StopSimulationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/stopsimulation"
    }
}

public struct StopSimulationInput: Swift.Equatable {
    /// The name of the simulation.
    /// This member is required.
    public var simulation: Swift.String?

    public init(
        simulation: Swift.String? = nil
    )
    {
        self.simulation = simulation
    }
}

struct StopSimulationInputBody: Swift.Equatable {
    let simulation: Swift.String?
}

extension StopSimulationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case simulation = "Simulation"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simulationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .simulation)
        simulation = simulationDecoded
    }
}

public enum StopSimulationOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopSimulationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopSimulationOutputResponse: Swift.Equatable {

    public init() { }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to add tags to. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tags to apply to the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() { }
}

extension TooManyTagsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to remove tags from. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() { }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
