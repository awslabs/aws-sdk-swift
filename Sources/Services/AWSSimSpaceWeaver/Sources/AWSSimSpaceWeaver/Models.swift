//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem

///
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SimSpaceWeaverClientTypes {
    /// A collection of TCP/UDP ports for a custom or service app.
    public struct SimulationAppPortMapping {
        /// The TCP/UDP port number of the running app. SimSpace Weaver dynamically assigns this port number when the app starts. SimSpace Weaver maps the Declared port to the Actual port. Clients connect to the app using the app's IP address and the Actual port number.
        public var actual: Swift.Int?
        /// The TCP/UDP port number of the app, declared in the simulation schema. SimSpace Weaver maps the Declared port to the Actual port. The source code for the app should bind to the Declared port.
        public var declared: Swift.Int?

        public init(
            actual: Swift.Int? = nil,
            declared: Swift.Int? = nil
        )
        {
            self.actual = actual
            self.declared = declared
        }
    }

}

extension SimSpaceWeaverClientTypes {

    public enum ClockStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case started
        case starting
        case stopped
        case stopping
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [ClockStatus] {
            return [
                .started,
                .starting,
                .stopped,
                .stopping,
                .unknown
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .started: return "STARTED"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SimSpaceWeaverClientTypes {

    public enum ClockTargetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case started
        case stopped
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [ClockTargetStatus] {
            return [
                .started,
                .stopped,
                .unknown
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .started: return "STARTED"
            case .stopped: return "STOPPED"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SimSpaceWeaverClientTypes {
    /// The Amazon CloudWatch Logs log group for the simulation. For more information about log groups, see [Working with log groups and log streams](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html) in the Amazon CloudWatch Logs User Guide.
    public struct CloudWatchLogsLogGroup {
        /// The Amazon Resource Name (ARN) of the Amazon CloudWatch Logs log group for the simulation. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference. For more information about log groups, see [Working with log groups and log streams](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html) in the Amazon CloudWatch Logs User Guide.
        public var logGroupArn: Swift.String?

        public init(
            logGroupArn: Swift.String? = nil
        )
        {
            self.logGroupArn = logGroupArn
        }
    }

}

///
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SimSpaceWeaverClientTypes {
    /// An Amazon S3 bucket and optional folder (object key prefix) where SimSpace Weaver creates a file.
    public struct S3Destination {
        /// The name of an Amazon S3 bucket. For more information about buckets, see [Creating, configuring, and working with Amazon S3 buckets](https://docs.aws.amazon.com/AmazonS3/latest/userguide/creating-buckets-s3.html) in the Amazon Simple Storage Service User Guide.
        /// This member is required.
        public var bucketName: Swift.String?
        /// A string prefix for an Amazon S3 object key. It's usually a folder name. For more information about folders in Amazon S3, see [Organizing objects in the Amazon S3 console using folders](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-folders.html) in the Amazon Simple Storage Service User Guide.
        public var objectKeyPrefix: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            objectKeyPrefix: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.objectKeyPrefix = objectKeyPrefix
        }
    }

}

public struct CreateSnapshotInput {
    /// The Amazon S3 bucket and optional folder (object key prefix) where SimSpace Weaver creates the snapshot file. The Amazon S3 bucket must be in the same Amazon Web Services Region as the simulation.
    /// This member is required.
    public var destination: SimSpaceWeaverClientTypes.S3Destination?
    /// The name of the simulation.
    /// This member is required.
    public var simulation: Swift.String?

    public init(
        destination: SimSpaceWeaverClientTypes.S3Destination? = nil,
        simulation: Swift.String? = nil
    )
    {
        self.destination = destination
        self.simulation = simulation
    }
}

public struct CreateSnapshotOutput {

    public init() { }
}

public struct DeleteAppInput {
    /// The name of the app.
    /// This member is required.
    public var app: Swift.String?
    /// The name of the domain of the app.
    /// This member is required.
    public var domain: Swift.String?
    /// The name of the simulation of the app.
    /// This member is required.
    public var simulation: Swift.String?

    public init(
        app: Swift.String? = nil,
        domain: Swift.String? = nil,
        simulation: Swift.String? = nil
    )
    {
        self.app = app
        self.domain = domain
        self.simulation = simulation
    }
}

public struct DeleteAppOutput {

    public init() { }
}

public struct DeleteSimulationInput {
    /// The name of the simulation.
    /// This member is required.
    public var simulation: Swift.String?

    public init(
        simulation: Swift.String? = nil
    )
    {
        self.simulation = simulation
    }
}

public struct DeleteSimulationOutput {

    public init() { }
}

public struct DescribeAppInput {
    /// The name of the app.
    /// This member is required.
    public var app: Swift.String?
    /// The name of the domain of the app.
    /// This member is required.
    public var domain: Swift.String?
    /// The name of the simulation of the app.
    /// This member is required.
    public var simulation: Swift.String?

    public init(
        app: Swift.String? = nil,
        domain: Swift.String? = nil,
        simulation: Swift.String? = nil
    )
    {
        self.app = app
        self.domain = domain
        self.simulation = simulation
    }
}

extension SimSpaceWeaverClientTypes {
    /// Information about the network endpoint that you can use to connect to your custom or service app. For more information about SimSpace Weaver apps, see [Key concepts: Apps](https://docs.aws.amazon.com/simspaceweaver/latest/userguide/what-is_key-concepts.html#what-is_key-concepts_apps) in the SimSpace Weaver User Guide..
    public struct SimulationAppEndpointInfo {
        /// The IP address of the app. SimSpace Weaver dynamically assigns this IP address when the app starts.
        public var address: Swift.String?
        /// The inbound TCP/UDP port numbers of the app. The combination of an IP address and a port number form a network endpoint.
        public var ingressPortMappings: [SimSpaceWeaverClientTypes.SimulationAppPortMapping]?

        public init(
            address: Swift.String? = nil,
            ingressPortMappings: [SimSpaceWeaverClientTypes.SimulationAppPortMapping]? = nil
        )
        {
            self.address = address
            self.ingressPortMappings = ingressPortMappings
        }
    }

}

extension SimSpaceWeaverClientTypes {
    /// Options that apply when the app starts. These options override default behavior.
    public struct LaunchOverrides {
        /// App launch commands and command line parameters that override the launch command configured in the simulation schema.
        public var launchCommands: [Swift.String]?

        public init(
            launchCommands: [Swift.String]? = nil
        )
        {
            self.launchCommands = launchCommands
        }
    }

}

extension SimSpaceWeaverClientTypes {

    public enum SimulationAppStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case error
        case started
        case starting
        case stopped
        case stopping
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [SimulationAppStatus] {
            return [
                .error,
                .started,
                .starting,
                .stopped,
                .stopping,
                .unknown
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .started: return "STARTED"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SimSpaceWeaverClientTypes {

    public enum SimulationAppTargetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case started
        case stopped
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [SimulationAppTargetStatus] {
            return [
                .started,
                .stopped,
                .unknown
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .started: return "STARTED"
            case .stopped: return "STOPPED"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeAppOutput {
    /// The description of the app.
    public var description: Swift.String?
    /// The name of the domain of the app.
    public var domain: Swift.String?
    /// Information about the network endpoint for the custom app. You can use the endpoint to connect to the custom app.
    public var endpointInfo: SimSpaceWeaverClientTypes.SimulationAppEndpointInfo?
    /// Options that apply when the app starts. These options override default behavior.
    public var launchOverrides: SimSpaceWeaverClientTypes.LaunchOverrides?
    /// The name of the app.
    public var name: Swift.String?
    /// The name of the simulation of the app.
    public var simulation: Swift.String?
    /// The current lifecycle state of the custom app.
    public var status: SimSpaceWeaverClientTypes.SimulationAppStatus?
    /// The desired lifecycle state of the custom app.
    public var targetStatus: SimSpaceWeaverClientTypes.SimulationAppTargetStatus?

    public init(
        description: Swift.String? = nil,
        domain: Swift.String? = nil,
        endpointInfo: SimSpaceWeaverClientTypes.SimulationAppEndpointInfo? = nil,
        launchOverrides: SimSpaceWeaverClientTypes.LaunchOverrides? = nil,
        name: Swift.String? = nil,
        simulation: Swift.String? = nil,
        status: SimSpaceWeaverClientTypes.SimulationAppStatus? = nil,
        targetStatus: SimSpaceWeaverClientTypes.SimulationAppTargetStatus? = nil
    )
    {
        self.description = description
        self.domain = domain
        self.endpointInfo = endpointInfo
        self.launchOverrides = launchOverrides
        self.name = name
        self.simulation = simulation
        self.status = status
        self.targetStatus = targetStatus
    }
}

public struct DescribeSimulationInput {
    /// The name of the simulation.
    /// This member is required.
    public var simulation: Swift.String?

    public init(
        simulation: Swift.String? = nil
    )
    {
        self.simulation = simulation
    }
}

extension SimSpaceWeaverClientTypes {
    /// Status information about the simulation clock.
    public struct SimulationClock {
        /// The current status of the simulation clock.
        public var status: SimSpaceWeaverClientTypes.ClockStatus?
        /// The desired status of the simulation clock.
        public var targetStatus: SimSpaceWeaverClientTypes.ClockTargetStatus?

        public init(
            status: SimSpaceWeaverClientTypes.ClockStatus? = nil,
            targetStatus: SimSpaceWeaverClientTypes.ClockTargetStatus? = nil
        )
        {
            self.status = status
            self.targetStatus = targetStatus
        }
    }

}

extension SimSpaceWeaverClientTypes {

    public enum LifecycleManagementStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case byrequest
        case byspatialsubdivision
        case perworker
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [LifecycleManagementStrategy] {
            return [
                .byrequest,
                .byspatialsubdivision,
                .perworker,
                .unknown
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .byrequest: return "ByRequest"
            case .byspatialsubdivision: return "BySpatialSubdivision"
            case .perworker: return "PerWorker"
            case .unknown: return "Unknown"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SimSpaceWeaverClientTypes {
    /// A collection of app instances that run the same executable app code and have the same launch options and commands. For more information about domains, see [Key concepts: Domains](https://docs.aws.amazon.com/simspaceweaver/latest/userguide/what-is_key-concepts.html#what-is_key-concepts_domains) in the SimSpace Weaver User Guide.
    public struct Domain {
        /// The type of lifecycle management for apps in the domain. Indicates whether apps in this domain are managed (SimSpace Weaver starts and stops the apps) or unmanaged (you must start and stop the apps). Lifecycle types
        ///
        /// * PerWorker – Managed: SimSpace Weaver starts one app on each worker.
        ///
        /// * BySpatialSubdivision – Managed: SimSpace Weaver starts one app for each spatial partition.
        ///
        /// * ByRequest – Unmanaged: You use the StartApp API to start the apps and use the StopApp API to stop the apps.
        public var lifecycle: SimSpaceWeaverClientTypes.LifecycleManagementStrategy?
        /// The name of the domain.
        public var name: Swift.String?

        public init(
            lifecycle: SimSpaceWeaverClientTypes.LifecycleManagementStrategy? = nil,
            name: Swift.String? = nil
        )
        {
            self.lifecycle = lifecycle
            self.name = name
        }
    }

}

extension SimSpaceWeaverClientTypes {
    /// A collection of additional state information, such as domain and clock configuration.
    public struct LiveSimulationState {
        /// A list of simulation clocks. At this time, a simulation has only one clock.
        public var clocks: [SimSpaceWeaverClientTypes.SimulationClock]?
        /// A list of domains for the simulation. For more information about domains, see [Key concepts: Domains](https://docs.aws.amazon.com/simspaceweaver/latest/userguide/what-is_key-concepts.html#what-is_key-concepts_domains) in the SimSpace Weaver User Guide.
        public var domains: [SimSpaceWeaverClientTypes.Domain]?

        public init(
            clocks: [SimSpaceWeaverClientTypes.SimulationClock]? = nil,
            domains: [SimSpaceWeaverClientTypes.Domain]? = nil
        )
        {
            self.clocks = clocks
            self.domains = domains
        }
    }

}

extension SimSpaceWeaverClientTypes {
    /// The location where SimSpace Weaver sends simulation log data.
    public struct LogDestination {
        /// An Amazon CloudWatch Logs log group that stores simulation log data. For more information about log groups, see [Working with log groups and log streams](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html) in the Amazon CloudWatch Logs User Guide.
        public var cloudWatchLogsLogGroup: SimSpaceWeaverClientTypes.CloudWatchLogsLogGroup?

        public init(
            cloudWatchLogsLogGroup: SimSpaceWeaverClientTypes.CloudWatchLogsLogGroup? = nil
        )
        {
            self.cloudWatchLogsLogGroup = cloudWatchLogsLogGroup
        }
    }

}

extension SimSpaceWeaverClientTypes {
    /// The logging configuration for a simulation.
    public struct LoggingConfiguration {
        /// A list of the locations where SimSpace Weaver sends simulation log data.
        public var destinations: [SimSpaceWeaverClientTypes.LogDestination]?

        public init(
            destinations: [SimSpaceWeaverClientTypes.LogDestination]? = nil
        )
        {
            self.destinations = destinations
        }
    }

}

extension SimSpaceWeaverClientTypes {
    /// A location in Amazon Simple Storage Service (Amazon S3) where SimSpace Weaver stores simulation data, such as your app .zip files and schema file. For more information about Amazon S3, see the [ Amazon Simple Storage Service User Guide ](https://docs.aws.amazon.com/AmazonS3/latest/userguide/Welcome.html).
    public struct S3Location {
        /// The name of an Amazon S3 bucket. For more information about buckets, see [Creating, configuring, and working with Amazon S3 buckets](https://docs.aws.amazon.com/AmazonS3/latest/userguide/creating-buckets-s3.html) in the Amazon Simple Storage Service User Guide.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The key name of an object in Amazon S3. For more information about Amazon S3 objects and object keys, see [Uploading, downloading, and working with objects in Amazon S3](https://docs.aws.amazon.com/AmazonS3/latest/userguide/uploading-downloading-objects.html) in the Amazon Simple Storage Service User Guide.
        /// This member is required.
        public var objectKey: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            objectKey: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.objectKey = objectKey
        }
    }

}

extension SimSpaceWeaverClientTypes {

    public enum SimulationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deleted
        case deleting
        case failed
        case snapshotInProgress
        case started
        case starting
        case stopped
        case stopping
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [SimulationStatus] {
            return [
                .deleted,
                .deleting,
                .failed,
                .snapshotInProgress,
                .started,
                .starting,
                .stopped,
                .stopping,
                .unknown
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .snapshotInProgress: return "SNAPSHOT_IN_PROGRESS"
            case .started: return "STARTED"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SimSpaceWeaverClientTypes {

    public enum SimulationTargetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deleted
        case started
        case stopped
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [SimulationTargetStatus] {
            return [
                .deleted,
                .started,
                .stopped,
                .unknown
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "DELETED"
            case .started: return "STARTED"
            case .stopped: return "STOPPED"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeSimulationOutput {
    /// The Amazon Resource Name (ARN) of the simulation. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    public var arn: Swift.String?
    /// The time when the simulation was created, expressed as the number of seconds and milliseconds in UTC since the Unix epoch (0:0:0.000, January 1, 1970).
    public var creationTime: Foundation.Date?
    /// The description of the simulation.
    public var description: Swift.String?
    /// A universally unique identifier (UUID) for this simulation.
    public var executionId: Swift.String?
    /// A collection of additional state information, such as domain and clock configuration.
    public var liveSimulationState: SimSpaceWeaverClientTypes.LiveSimulationState?
    /// Settings that control how SimSpace Weaver handles your simulation log data.
    public var loggingConfiguration: SimSpaceWeaverClientTypes.LoggingConfiguration?
    /// The maximum running time of the simulation, specified as a number of minutes (m or M), hours (h or H), or days (d or D). The simulation stops when it reaches this limit. The maximum value is 14D, or its equivalent in the other units. The default value is 14D. A value equivalent to 0 makes the simulation immediately transition to Stopping as soon as it reaches Started.
    public var maximumDuration: Swift.String?
    /// The name of the simulation.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that the simulation assumes to perform actions. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference. For more information about IAM roles, see [IAM roles](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html) in the Identity and Access Management User Guide.
    public var roleArn: Swift.String?
    /// An error message that SimSpace Weaver returns only if there is a problem with the simulation schema.
    @available(*, deprecated, message: "SchemaError is no longer used, check StartError instead.")
    public var schemaError: Swift.String?
    /// The location of the simulation schema in Amazon Simple Storage Service (Amazon S3). For more information about Amazon S3, see the [ Amazon Simple Storage Service User Guide ](https://docs.aws.amazon.com/AmazonS3/latest/userguide/Welcome.html).
    public var schemaS3Location: SimSpaceWeaverClientTypes.S3Location?
    /// A location in Amazon Simple Storage Service (Amazon S3) where SimSpace Weaver stores simulation data, such as your app .zip files and schema file. For more information about Amazon S3, see the [ Amazon Simple Storage Service User Guide ](https://docs.aws.amazon.com/AmazonS3/latest/userguide/Welcome.html).
    public var snapshotS3Location: SimSpaceWeaverClientTypes.S3Location?
    /// An error message that SimSpace Weaver returns only if a problem occurs when the simulation is in the STARTING state.
    public var startError: Swift.String?
    /// The current lifecycle state of the simulation.
    public var status: SimSpaceWeaverClientTypes.SimulationStatus?
    /// The desired lifecycle state of the simulation.
    public var targetStatus: SimSpaceWeaverClientTypes.SimulationTargetStatus?

    public init(
        arn: Swift.String? = nil,
        creationTime: Foundation.Date? = nil,
        description: Swift.String? = nil,
        executionId: Swift.String? = nil,
        liveSimulationState: SimSpaceWeaverClientTypes.LiveSimulationState? = nil,
        loggingConfiguration: SimSpaceWeaverClientTypes.LoggingConfiguration? = nil,
        maximumDuration: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        schemaError: Swift.String? = nil,
        schemaS3Location: SimSpaceWeaverClientTypes.S3Location? = nil,
        snapshotS3Location: SimSpaceWeaverClientTypes.S3Location? = nil,
        startError: Swift.String? = nil,
        status: SimSpaceWeaverClientTypes.SimulationStatus? = nil,
        targetStatus: SimSpaceWeaverClientTypes.SimulationTargetStatus? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.executionId = executionId
        self.liveSimulationState = liveSimulationState
        self.loggingConfiguration = loggingConfiguration
        self.maximumDuration = maximumDuration
        self.name = name
        self.roleArn = roleArn
        self.schemaError = schemaError
        self.schemaS3Location = schemaS3Location
        self.snapshotS3Location = snapshotS3Location
        self.startError = startError
        self.status = status
        self.targetStatus = targetStatus
    }
}

public struct ListAppsInput {
    /// The name of the domain that you want to list apps for.
    public var domain: Swift.String?
    /// The maximum number of apps to list.
    public var maxResults: Swift.Int?
    /// If SimSpace Weaver returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?
    /// The name of the simulation that you want to list apps for.
    /// This member is required.
    public var simulation: Swift.String?

    public init(
        domain: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        simulation: Swift.String? = nil
    )
    {
        self.domain = domain
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.simulation = simulation
    }
}

extension SimSpaceWeaverClientTypes {
    /// A collection of metadata about the app.
    public struct SimulationAppMetadata {
        /// The domain of the app. For more information about domains, see [Key concepts: Domains](https://docs.aws.amazon.com/simspaceweaver/latest/userguide/what-is_key-concepts.html#what-is_key-concepts_domains) in the SimSpace Weaver User Guide.
        public var domain: Swift.String?
        /// The name of the app.
        public var name: Swift.String?
        /// The name of the simulation of the app.
        public var simulation: Swift.String?
        /// The current status of the app.
        public var status: SimSpaceWeaverClientTypes.SimulationAppStatus?
        /// The desired status of the app.
        public var targetStatus: SimSpaceWeaverClientTypes.SimulationAppTargetStatus?

        public init(
            domain: Swift.String? = nil,
            name: Swift.String? = nil,
            simulation: Swift.String? = nil,
            status: SimSpaceWeaverClientTypes.SimulationAppStatus? = nil,
            targetStatus: SimSpaceWeaverClientTypes.SimulationAppTargetStatus? = nil
        )
        {
            self.domain = domain
            self.name = name
            self.simulation = simulation
            self.status = status
            self.targetStatus = targetStatus
        }
    }

}

public struct ListAppsOutput {
    /// The list of apps for the given simulation and domain.
    public var apps: [SimSpaceWeaverClientTypes.SimulationAppMetadata]?
    /// If SimSpace Weaver returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?

    public init(
        apps: [SimSpaceWeaverClientTypes.SimulationAppMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apps = apps
        self.nextToken = nextToken
    }
}

public struct ListSimulationsInput {
    /// The maximum number of simulations to list.
    public var maxResults: Swift.Int?
    /// If SimSpace Weaver returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SimSpaceWeaverClientTypes {
    /// A collection of data about the simulation.
    public struct SimulationMetadata {
        /// The Amazon Resource Name (ARN) of the simulation. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        public var arn: Swift.String?
        /// The time when the simulation was created, expressed as the number of seconds and milliseconds in UTC since the Unix epoch (0:0:0.000, January 1, 1970).
        public var creationTime: Foundation.Date?
        /// The name of the simulation.
        public var name: Swift.String?
        /// The current status of the simulation.
        public var status: SimSpaceWeaverClientTypes.SimulationStatus?
        /// The desired status of the simulation.
        public var targetStatus: SimSpaceWeaverClientTypes.SimulationTargetStatus?

        public init(
            arn: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            status: SimSpaceWeaverClientTypes.SimulationStatus? = nil,
            targetStatus: SimSpaceWeaverClientTypes.SimulationTargetStatus? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.name = name
            self.status = status
            self.targetStatus = targetStatus
        }
    }

}

public struct ListSimulationsOutput {
    /// If SimSpace Weaver returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?
    /// The list of simulations.
    public var simulations: [SimSpaceWeaverClientTypes.SimulationMetadata]?

    public init(
        nextToken: Swift.String? = nil,
        simulations: [SimSpaceWeaverClientTypes.SimulationMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.simulations = simulations
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) of the resource. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    /// The list of tags for the resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

///
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct StartAppInput {
    /// A value that you provide to ensure that repeated calls to this API operation using the same parameters complete only once. A ClientToken is also known as an idempotency token. A ClientToken expires after 24 hours.
    public var clientToken: Swift.String?
    /// The description of the app.
    public var description: Swift.String?
    /// The name of the domain of the app.
    /// This member is required.
    public var domain: Swift.String?
    /// Options that apply when the app starts. These options override default behavior.
    public var launchOverrides: SimSpaceWeaverClientTypes.LaunchOverrides?
    /// The name of the app.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the simulation of the app.
    /// This member is required.
    public var simulation: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        domain: Swift.String? = nil,
        launchOverrides: SimSpaceWeaverClientTypes.LaunchOverrides? = nil,
        name: Swift.String? = nil,
        simulation: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.domain = domain
        self.launchOverrides = launchOverrides
        self.name = name
        self.simulation = simulation
    }
}

extension StartAppInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartAppInput(description: \(Swift.String(describing: description)), domain: \(Swift.String(describing: domain)), launchOverrides: \(Swift.String(describing: launchOverrides)), name: \(Swift.String(describing: name)), simulation: \(Swift.String(describing: simulation)), clientToken: \"CONTENT_REDACTED\")"}
}

public struct StartAppOutput {
    /// The name of the domain of the app.
    public var domain: Swift.String?
    /// The name of the app.
    public var name: Swift.String?
    /// The name of the simulation of the app.
    public var simulation: Swift.String?

    public init(
        domain: Swift.String? = nil,
        name: Swift.String? = nil,
        simulation: Swift.String? = nil
    )
    {
        self.domain = domain
        self.name = name
        self.simulation = simulation
    }
}

public struct StartClockInput {
    /// The name of the simulation.
    /// This member is required.
    public var simulation: Swift.String?

    public init(
        simulation: Swift.String? = nil
    )
    {
        self.simulation = simulation
    }
}

public struct StartClockOutput {

    public init() { }
}

public struct StartSimulationInput {
    /// A value that you provide to ensure that repeated calls to this API operation using the same parameters complete only once. A ClientToken is also known as an idempotency token. A ClientToken expires after 24 hours.
    public var clientToken: Swift.String?
    /// The description of the simulation.
    public var description: Swift.String?
    /// The maximum running time of the simulation, specified as a number of minutes (m or M), hours (h or H), or days (d or D). The simulation stops when it reaches this limit. The maximum value is 14D, or its equivalent in the other units. The default value is 14D. A value equivalent to 0 makes the simulation immediately transition to Stopping as soon as it reaches Started.
    public var maximumDuration: Swift.String?
    /// The name of the simulation.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that the simulation assumes to perform actions. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference. For more information about IAM roles, see [IAM roles](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html) in the Identity and Access Management User Guide.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The location of the simulation schema in Amazon Simple Storage Service (Amazon S3). For more information about Amazon S3, see the [ Amazon Simple Storage Service User Guide ](https://docs.aws.amazon.com/AmazonS3/latest/userguide/Welcome.html). Provide a SchemaS3Location to start your simulation from a schema. If you provide a SchemaS3Location then you can't provide a SnapshotS3Location.
    public var schemaS3Location: SimSpaceWeaverClientTypes.S3Location?
    /// The location of the snapshot .zip file in Amazon Simple Storage Service (Amazon S3). For more information about Amazon S3, see the [ Amazon Simple Storage Service User Guide ](https://docs.aws.amazon.com/AmazonS3/latest/userguide/Welcome.html). Provide a SnapshotS3Location to start your simulation from a snapshot. The Amazon S3 bucket must be in the same Amazon Web Services Region as the simulation. If you provide a SnapshotS3Location then you can't provide a SchemaS3Location.
    public var snapshotS3Location: SimSpaceWeaverClientTypes.S3Location?
    /// A list of tags for the simulation. For more information about tags, see [Tagging Amazon Web Services resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) in the Amazon Web Services General Reference.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        maximumDuration: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        schemaS3Location: SimSpaceWeaverClientTypes.S3Location? = nil,
        snapshotS3Location: SimSpaceWeaverClientTypes.S3Location? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.maximumDuration = maximumDuration
        self.name = name
        self.roleArn = roleArn
        self.schemaS3Location = schemaS3Location
        self.snapshotS3Location = snapshotS3Location
        self.tags = tags
    }
}

extension StartSimulationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartSimulationInput(description: \(Swift.String(describing: description)), maximumDuration: \(Swift.String(describing: maximumDuration)), name: \(Swift.String(describing: name)), roleArn: \(Swift.String(describing: roleArn)), schemaS3Location: \(Swift.String(describing: schemaS3Location)), snapshotS3Location: \(Swift.String(describing: snapshotS3Location)), tags: \(Swift.String(describing: tags)), clientToken: \"CONTENT_REDACTED\")"}
}

public struct StartSimulationOutput {
    /// The Amazon Resource Name (ARN) of the simulation. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    public var arn: Swift.String?
    /// The time when the simulation was created, expressed as the number of seconds and milliseconds in UTC since the Unix epoch (0:0:0.000, January 1, 1970).
    public var creationTime: Foundation.Date?
    /// A universally unique identifier (UUID) for this simulation.
    public var executionId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTime: Foundation.Date? = nil,
        executionId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.executionId = executionId
    }
}

public struct StopAppInput {
    /// The name of the app.
    /// This member is required.
    public var app: Swift.String?
    /// The name of the domain of the app.
    /// This member is required.
    public var domain: Swift.String?
    /// The name of the simulation of the app.
    /// This member is required.
    public var simulation: Swift.String?

    public init(
        app: Swift.String? = nil,
        domain: Swift.String? = nil,
        simulation: Swift.String? = nil
    )
    {
        self.app = app
        self.domain = domain
        self.simulation = simulation
    }
}

public struct StopAppOutput {

    public init() { }
}

public struct StopClockInput {
    /// The name of the simulation.
    /// This member is required.
    public var simulation: Swift.String?

    public init(
        simulation: Swift.String? = nil
    )
    {
        self.simulation = simulation
    }
}

public struct StopClockOutput {

    public init() { }
}

public struct StopSimulationInput {
    /// The name of the simulation.
    /// This member is required.
    public var simulation: Swift.String?

    public init(
        simulation: Swift.String? = nil
    )
    {
        self.simulation = simulation
    }
}

public struct StopSimulationOutput {

    public init() { }
}

///
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource that you want to add tags to. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tags to apply to the resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource that you want to remove tags from. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

extension CreateSnapshotInput {

    static func urlPathProvider(_ value: CreateSnapshotInput) -> Swift.String? {
        return "/createsnapshot"
    }
}

extension DeleteAppInput {

    static func urlPathProvider(_ value: DeleteAppInput) -> Swift.String? {
        return "/deleteapp"
    }
}

extension DeleteAppInput {

    static func queryItemProvider(_ value: DeleteAppInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let app = value.app else {
            let message = "Creating a URL Query Item failed. app is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let appQueryItem = Smithy.URIQueryItem(name: "app".urlPercentEncoding(), value: Swift.String(app).urlPercentEncoding())
        items.append(appQueryItem)
        guard let simulation = value.simulation else {
            let message = "Creating a URL Query Item failed. simulation is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let simulationQueryItem = Smithy.URIQueryItem(name: "simulation".urlPercentEncoding(), value: Swift.String(simulation).urlPercentEncoding())
        items.append(simulationQueryItem)
        guard let domain = value.domain else {
            let message = "Creating a URL Query Item failed. domain is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let domainQueryItem = Smithy.URIQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
        items.append(domainQueryItem)
        return items
    }
}

extension DeleteSimulationInput {

    static func urlPathProvider(_ value: DeleteSimulationInput) -> Swift.String? {
        return "/deletesimulation"
    }
}

extension DeleteSimulationInput {

    static func queryItemProvider(_ value: DeleteSimulationInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let simulation = value.simulation else {
            let message = "Creating a URL Query Item failed. simulation is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let simulationQueryItem = Smithy.URIQueryItem(name: "simulation".urlPercentEncoding(), value: Swift.String(simulation).urlPercentEncoding())
        items.append(simulationQueryItem)
        return items
    }
}

extension DescribeAppInput {

    static func urlPathProvider(_ value: DescribeAppInput) -> Swift.String? {
        return "/describeapp"
    }
}

extension DescribeAppInput {

    static func queryItemProvider(_ value: DescribeAppInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let app = value.app else {
            let message = "Creating a URL Query Item failed. app is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let appQueryItem = Smithy.URIQueryItem(name: "app".urlPercentEncoding(), value: Swift.String(app).urlPercentEncoding())
        items.append(appQueryItem)
        guard let simulation = value.simulation else {
            let message = "Creating a URL Query Item failed. simulation is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let simulationQueryItem = Smithy.URIQueryItem(name: "simulation".urlPercentEncoding(), value: Swift.String(simulation).urlPercentEncoding())
        items.append(simulationQueryItem)
        guard let domain = value.domain else {
            let message = "Creating a URL Query Item failed. domain is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let domainQueryItem = Smithy.URIQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
        items.append(domainQueryItem)
        return items
    }
}

extension DescribeSimulationInput {

    static func urlPathProvider(_ value: DescribeSimulationInput) -> Swift.String? {
        return "/describesimulation"
    }
}

extension DescribeSimulationInput {

    static func queryItemProvider(_ value: DescribeSimulationInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let simulation = value.simulation else {
            let message = "Creating a URL Query Item failed. simulation is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let simulationQueryItem = Smithy.URIQueryItem(name: "simulation".urlPercentEncoding(), value: Swift.String(simulation).urlPercentEncoding())
        items.append(simulationQueryItem)
        return items
    }
}

extension ListAppsInput {

    static func urlPathProvider(_ value: ListAppsInput) -> Swift.String? {
        return "/listapps"
    }
}

extension ListAppsInput {

    static func queryItemProvider(_ value: ListAppsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let simulation = value.simulation else {
            let message = "Creating a URL Query Item failed. simulation is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let simulationQueryItem = Smithy.URIQueryItem(name: "simulation".urlPercentEncoding(), value: Swift.String(simulation).urlPercentEncoding())
        items.append(simulationQueryItem)
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let domain = value.domain {
            let domainQueryItem = Smithy.URIQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
        }
        return items
    }
}

extension ListSimulationsInput {

    static func urlPathProvider(_ value: ListSimulationsInput) -> Swift.String? {
        return "/listsimulations"
    }
}

extension ListSimulationsInput {

    static func queryItemProvider(_ value: ListSimulationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension StartAppInput {

    static func urlPathProvider(_ value: StartAppInput) -> Swift.String? {
        return "/startapp"
    }
}

extension StartClockInput {

    static func urlPathProvider(_ value: StartClockInput) -> Swift.String? {
        return "/startclock"
    }
}

extension StartSimulationInput {

    static func urlPathProvider(_ value: StartSimulationInput) -> Swift.String? {
        return "/startsimulation"
    }
}

extension StopAppInput {

    static func urlPathProvider(_ value: StopAppInput) -> Swift.String? {
        return "/stopapp"
    }
}

extension StopClockInput {

    static func urlPathProvider(_ value: StopClockInput) -> Swift.String? {
        return "/stopclock"
    }
}

extension StopSimulationInput {

    static func urlPathProvider(_ value: StopSimulationInput) -> Swift.String? {
        return "/stopsimulation"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension CreateSnapshotInput {

    static func write(value: CreateSnapshotInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Destination"].write(value.destination, with: SimSpaceWeaverClientTypes.S3Destination.write(value:to:))
        try writer["Simulation"].write(value.simulation)
    }
}

extension StartAppInput {

    static func write(value: StartAppInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["Description"].write(value.description)
        try writer["Domain"].write(value.domain)
        try writer["LaunchOverrides"].write(value.launchOverrides, with: SimSpaceWeaverClientTypes.LaunchOverrides.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["Simulation"].write(value.simulation)
    }
}

extension StartClockInput {

    static func write(value: StartClockInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Simulation"].write(value.simulation)
    }
}

extension StartSimulationInput {

    static func write(value: StartSimulationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["Description"].write(value.description)
        try writer["MaximumDuration"].write(value.maximumDuration)
        try writer["Name"].write(value.name)
        try writer["RoleArn"].write(value.roleArn)
        try writer["SchemaS3Location"].write(value.schemaS3Location, with: SimSpaceWeaverClientTypes.S3Location.write(value:to:))
        try writer["SnapshotS3Location"].write(value.snapshotS3Location, with: SimSpaceWeaverClientTypes.S3Location.write(value:to:))
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension StopAppInput {

    static func write(value: StopAppInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["App"].write(value.app)
        try writer["Domain"].write(value.domain)
        try writer["Simulation"].write(value.simulation)
    }
}

extension StopClockInput {

    static func write(value: StopClockInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Simulation"].write(value.simulation)
    }
}

extension StopSimulationInput {

    static func write(value: StopSimulationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Simulation"].write(value.simulation)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateSnapshotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSnapshotOutput {
        return CreateSnapshotOutput()
    }
}

extension DeleteAppOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAppOutput {
        return DeleteAppOutput()
    }
}

extension DeleteSimulationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSimulationOutput {
        return DeleteSimulationOutput()
    }
}

extension DescribeAppOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAppOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAppOutput()
        value.description = try reader["Description"].readIfPresent()
        value.domain = try reader["Domain"].readIfPresent()
        value.endpointInfo = try reader["EndpointInfo"].readIfPresent(with: SimSpaceWeaverClientTypes.SimulationAppEndpointInfo.read(from:))
        value.launchOverrides = try reader["LaunchOverrides"].readIfPresent(with: SimSpaceWeaverClientTypes.LaunchOverrides.read(from:))
        value.name = try reader["Name"].readIfPresent()
        value.simulation = try reader["Simulation"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.targetStatus = try reader["TargetStatus"].readIfPresent()
        return value
    }
}

extension DescribeSimulationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeSimulationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeSimulationOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        value.executionId = try reader["ExecutionId"].readIfPresent()
        value.liveSimulationState = try reader["LiveSimulationState"].readIfPresent(with: SimSpaceWeaverClientTypes.LiveSimulationState.read(from:))
        value.loggingConfiguration = try reader["LoggingConfiguration"].readIfPresent(with: SimSpaceWeaverClientTypes.LoggingConfiguration.read(from:))
        value.maximumDuration = try reader["MaximumDuration"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.roleArn = try reader["RoleArn"].readIfPresent()
        value.schemaError = try reader["SchemaError"].readIfPresent()
        value.schemaS3Location = try reader["SchemaS3Location"].readIfPresent(with: SimSpaceWeaverClientTypes.S3Location.read(from:))
        value.snapshotS3Location = try reader["SnapshotS3Location"].readIfPresent(with: SimSpaceWeaverClientTypes.S3Location.read(from:))
        value.startError = try reader["StartError"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.targetStatus = try reader["TargetStatus"].readIfPresent()
        return value
    }
}

extension ListAppsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAppsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAppsOutput()
        value.apps = try reader["Apps"].readListIfPresent(memberReadingClosure: SimSpaceWeaverClientTypes.SimulationAppMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListSimulationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSimulationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSimulationsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.simulations = try reader["Simulations"].readListIfPresent(memberReadingClosure: SimSpaceWeaverClientTypes.SimulationMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension StartAppOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartAppOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartAppOutput()
        value.domain = try reader["Domain"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.simulation = try reader["Simulation"].readIfPresent()
        return value
    }
}

extension StartClockOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartClockOutput {
        return StartClockOutput()
    }
}

extension StartSimulationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartSimulationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartSimulationOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.executionId = try reader["ExecutionId"].readIfPresent()
        return value
    }
}

extension StopAppOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopAppOutput {
        return StopAppOutput()
    }
}

extension StopClockOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopClockOutput {
        return StopClockOutput()
    }
}

extension StopSimulationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopSimulationOutput {
        return StopSimulationOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

enum CreateSnapshotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAppOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSimulationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAppOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeSimulationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAppsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSimulationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartAppOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartClockOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartSimulationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopAppOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopClockOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopSimulationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyTagsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyTagsException {
        let reader = baseError.errorBodyReader
        var value = TooManyTagsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SimSpaceWeaverClientTypes.LaunchOverrides {

    static func write(value: SimSpaceWeaverClientTypes.LaunchOverrides?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LaunchCommands"].writeList(value.launchCommands, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SimSpaceWeaverClientTypes.LaunchOverrides {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SimSpaceWeaverClientTypes.LaunchOverrides()
        value.launchCommands = try reader["LaunchCommands"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SimSpaceWeaverClientTypes.SimulationAppEndpointInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> SimSpaceWeaverClientTypes.SimulationAppEndpointInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SimSpaceWeaverClientTypes.SimulationAppEndpointInfo()
        value.address = try reader["Address"].readIfPresent()
        value.ingressPortMappings = try reader["IngressPortMappings"].readListIfPresent(memberReadingClosure: SimSpaceWeaverClientTypes.SimulationAppPortMapping.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SimSpaceWeaverClientTypes.SimulationAppPortMapping {

    static func read(from reader: SmithyJSON.Reader) throws -> SimSpaceWeaverClientTypes.SimulationAppPortMapping {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SimSpaceWeaverClientTypes.SimulationAppPortMapping()
        value.declared = try reader["Declared"].readIfPresent()
        value.actual = try reader["Actual"].readIfPresent()
        return value
    }
}

extension SimSpaceWeaverClientTypes.S3Location {

    static func write(value: SimSpaceWeaverClientTypes.S3Location?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BucketName"].write(value.bucketName)
        try writer["ObjectKey"].write(value.objectKey)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SimSpaceWeaverClientTypes.S3Location {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SimSpaceWeaverClientTypes.S3Location()
        value.bucketName = try reader["BucketName"].readIfPresent() ?? ""
        value.objectKey = try reader["ObjectKey"].readIfPresent() ?? ""
        return value
    }
}

extension SimSpaceWeaverClientTypes.LoggingConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> SimSpaceWeaverClientTypes.LoggingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SimSpaceWeaverClientTypes.LoggingConfiguration()
        value.destinations = try reader["Destinations"].readListIfPresent(memberReadingClosure: SimSpaceWeaverClientTypes.LogDestination.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SimSpaceWeaverClientTypes.LogDestination {

    static func read(from reader: SmithyJSON.Reader) throws -> SimSpaceWeaverClientTypes.LogDestination {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SimSpaceWeaverClientTypes.LogDestination()
        value.cloudWatchLogsLogGroup = try reader["CloudWatchLogsLogGroup"].readIfPresent(with: SimSpaceWeaverClientTypes.CloudWatchLogsLogGroup.read(from:))
        return value
    }
}

extension SimSpaceWeaverClientTypes.CloudWatchLogsLogGroup {

    static func read(from reader: SmithyJSON.Reader) throws -> SimSpaceWeaverClientTypes.CloudWatchLogsLogGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SimSpaceWeaverClientTypes.CloudWatchLogsLogGroup()
        value.logGroupArn = try reader["LogGroupArn"].readIfPresent()
        return value
    }
}

extension SimSpaceWeaverClientTypes.LiveSimulationState {

    static func read(from reader: SmithyJSON.Reader) throws -> SimSpaceWeaverClientTypes.LiveSimulationState {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SimSpaceWeaverClientTypes.LiveSimulationState()
        value.domains = try reader["Domains"].readListIfPresent(memberReadingClosure: SimSpaceWeaverClientTypes.Domain.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.clocks = try reader["Clocks"].readListIfPresent(memberReadingClosure: SimSpaceWeaverClientTypes.SimulationClock.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SimSpaceWeaverClientTypes.SimulationClock {

    static func read(from reader: SmithyJSON.Reader) throws -> SimSpaceWeaverClientTypes.SimulationClock {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SimSpaceWeaverClientTypes.SimulationClock()
        value.status = try reader["Status"].readIfPresent()
        value.targetStatus = try reader["TargetStatus"].readIfPresent()
        return value
    }
}

extension SimSpaceWeaverClientTypes.Domain {

    static func read(from reader: SmithyJSON.Reader) throws -> SimSpaceWeaverClientTypes.Domain {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SimSpaceWeaverClientTypes.Domain()
        value.name = try reader["Name"].readIfPresent()
        value.lifecycle = try reader["Lifecycle"].readIfPresent()
        return value
    }
}

extension SimSpaceWeaverClientTypes.SimulationAppMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> SimSpaceWeaverClientTypes.SimulationAppMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SimSpaceWeaverClientTypes.SimulationAppMetadata()
        value.name = try reader["Name"].readIfPresent()
        value.simulation = try reader["Simulation"].readIfPresent()
        value.domain = try reader["Domain"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.targetStatus = try reader["TargetStatus"].readIfPresent()
        return value
    }
}

extension SimSpaceWeaverClientTypes.SimulationMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> SimSpaceWeaverClientTypes.SimulationMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SimSpaceWeaverClientTypes.SimulationMetadata()
        value.name = try reader["Name"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        value.targetStatus = try reader["TargetStatus"].readIfPresent()
        return value
    }
}

extension SimSpaceWeaverClientTypes.S3Destination {

    static func write(value: SimSpaceWeaverClientTypes.S3Destination?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BucketName"].write(value.bucketName)
        try writer["ObjectKeyPrefix"].write(value.objectKeyPrefix)
    }
}

public enum SimSpaceWeaverClientTypes {}
