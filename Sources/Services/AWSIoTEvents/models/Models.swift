// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension IoTEventsClientTypes.AcknowledgeFlow: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension IoTEventsClientTypes {
    /// Specifies whether to get notified for alarm state changes.
    public struct AcknowledgeFlow: Swift.Equatable {
        /// The value must be TRUE or FALSE. If TRUE, you receive a notification when the alarm state changes. You must choose to acknowledge the notification before the alarm state can return to NORMAL. If FALSE, you won't receive notifications. The alarm automatically changes to the NORMAL state when the input property value returns to the specified range.
        /// This member is required.
        public var enabled: Swift.Bool?

        public init (
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }

}

extension IoTEventsClientTypes.Action: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clearTimer
        case dynamoDB
        case dynamoDBv2
        case firehose
        case iotEvents
        case iotSiteWise
        case iotTopicPublish
        case lambda
        case resetTimer
        case setTimer
        case setVariable
        case sns
        case sqs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clearTimer = self.clearTimer {
            try encodeContainer.encode(clearTimer, forKey: .clearTimer)
        }
        if let dynamoDB = self.dynamoDB {
            try encodeContainer.encode(dynamoDB, forKey: .dynamoDB)
        }
        if let dynamoDBv2 = self.dynamoDBv2 {
            try encodeContainer.encode(dynamoDBv2, forKey: .dynamoDBv2)
        }
        if let firehose = self.firehose {
            try encodeContainer.encode(firehose, forKey: .firehose)
        }
        if let iotEvents = self.iotEvents {
            try encodeContainer.encode(iotEvents, forKey: .iotEvents)
        }
        if let iotSiteWise = self.iotSiteWise {
            try encodeContainer.encode(iotSiteWise, forKey: .iotSiteWise)
        }
        if let iotTopicPublish = self.iotTopicPublish {
            try encodeContainer.encode(iotTopicPublish, forKey: .iotTopicPublish)
        }
        if let lambda = self.lambda {
            try encodeContainer.encode(lambda, forKey: .lambda)
        }
        if let resetTimer = self.resetTimer {
            try encodeContainer.encode(resetTimer, forKey: .resetTimer)
        }
        if let setTimer = self.setTimer {
            try encodeContainer.encode(setTimer, forKey: .setTimer)
        }
        if let setVariable = self.setVariable {
            try encodeContainer.encode(setVariable, forKey: .setVariable)
        }
        if let sns = self.sns {
            try encodeContainer.encode(sns, forKey: .sns)
        }
        if let sqs = self.sqs {
            try encodeContainer.encode(sqs, forKey: .sqs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let setVariableDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.SetVariableAction.self, forKey: .setVariable)
        setVariable = setVariableDecoded
        let snsDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.SNSTopicPublishAction.self, forKey: .sns)
        sns = snsDecoded
        let iotTopicPublishDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.IotTopicPublishAction.self, forKey: .iotTopicPublish)
        iotTopicPublish = iotTopicPublishDecoded
        let setTimerDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.SetTimerAction.self, forKey: .setTimer)
        setTimer = setTimerDecoded
        let clearTimerDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.ClearTimerAction.self, forKey: .clearTimer)
        clearTimer = clearTimerDecoded
        let resetTimerDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.ResetTimerAction.self, forKey: .resetTimer)
        resetTimer = resetTimerDecoded
        let lambdaDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.LambdaAction.self, forKey: .lambda)
        lambda = lambdaDecoded
        let iotEventsDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.IotEventsAction.self, forKey: .iotEvents)
        iotEvents = iotEventsDecoded
        let sqsDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.SqsAction.self, forKey: .sqs)
        sqs = sqsDecoded
        let firehoseDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.FirehoseAction.self, forKey: .firehose)
        firehose = firehoseDecoded
        let dynamoDBDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.DynamoDBAction.self, forKey: .dynamoDB)
        dynamoDB = dynamoDBDecoded
        let dynamoDBv2Decoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.DynamoDBv2Action.self, forKey: .dynamoDBv2)
        dynamoDBv2 = dynamoDBv2Decoded
        let iotSiteWiseDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.IotSiteWiseAction.self, forKey: .iotSiteWise)
        iotSiteWise = iotSiteWiseDecoded
    }
}

extension IoTEventsClientTypes {
    /// An action to be performed when the condition is TRUE.
    public struct Action: Swift.Equatable {
        /// Information needed to clear the timer.
        public var clearTimer: IoTEventsClientTypes.ClearTimerAction?
        /// Writes to the DynamoDB table that you created. The default action payload contains all attribute-value pairs that have the information about the detector model instance and the event that triggered the action. You can customize the [payload](https://docs.aws.amazon.com/iotevents/latest/apireference/API_Payload.html). One column of the DynamoDB table receives all attribute-value pairs in the payload that you specify. For more information, see [Actions](https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-event-actions.html) in AWS IoT Events Developer Guide.
        public var dynamoDB: IoTEventsClientTypes.DynamoDBAction?
        /// Writes to the DynamoDB table that you created. The default action payload contains all attribute-value pairs that have the information about the detector model instance and the event that triggered the action. You can customize the [payload](https://docs.aws.amazon.com/iotevents/latest/apireference/API_Payload.html). A separate column of the DynamoDB table receives one attribute-value pair in the payload that you specify. For more information, see [Actions](https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-event-actions.html) in AWS IoT Events Developer Guide.
        public var dynamoDBv2: IoTEventsClientTypes.DynamoDBv2Action?
        /// Sends information about the detector model instance and the event that triggered the action to an Amazon Kinesis Data Firehose delivery stream.
        public var firehose: IoTEventsClientTypes.FirehoseAction?
        /// Sends AWS IoT Events input, which passes information about the detector model instance and the event that triggered the action.
        public var iotEvents: IoTEventsClientTypes.IotEventsAction?
        /// Sends information about the detector model instance and the event that triggered the action to an asset property in AWS IoT SiteWise .
        public var iotSiteWise: IoTEventsClientTypes.IotSiteWiseAction?
        /// Publishes an MQTT message with the given topic to the AWS IoT message broker.
        public var iotTopicPublish: IoTEventsClientTypes.IotTopicPublishAction?
        /// Calls a Lambda function, passing in information about the detector model instance and the event that triggered the action.
        public var lambda: IoTEventsClientTypes.LambdaAction?
        /// Information needed to reset the timer.
        public var resetTimer: IoTEventsClientTypes.ResetTimerAction?
        /// Information needed to set the timer.
        public var setTimer: IoTEventsClientTypes.SetTimerAction?
        /// Sets a variable to a specified value.
        public var setVariable: IoTEventsClientTypes.SetVariableAction?
        /// Sends an Amazon SNS message.
        public var sns: IoTEventsClientTypes.SNSTopicPublishAction?
        /// Sends information about the detector model instance and the event that triggered the action to an Amazon SQS queue.
        public var sqs: IoTEventsClientTypes.SqsAction?

        public init (
            clearTimer: IoTEventsClientTypes.ClearTimerAction? = nil,
            dynamoDB: IoTEventsClientTypes.DynamoDBAction? = nil,
            dynamoDBv2: IoTEventsClientTypes.DynamoDBv2Action? = nil,
            firehose: IoTEventsClientTypes.FirehoseAction? = nil,
            iotEvents: IoTEventsClientTypes.IotEventsAction? = nil,
            iotSiteWise: IoTEventsClientTypes.IotSiteWiseAction? = nil,
            iotTopicPublish: IoTEventsClientTypes.IotTopicPublishAction? = nil,
            lambda: IoTEventsClientTypes.LambdaAction? = nil,
            resetTimer: IoTEventsClientTypes.ResetTimerAction? = nil,
            setTimer: IoTEventsClientTypes.SetTimerAction? = nil,
            setVariable: IoTEventsClientTypes.SetVariableAction? = nil,
            sns: IoTEventsClientTypes.SNSTopicPublishAction? = nil,
            sqs: IoTEventsClientTypes.SqsAction? = nil
        )
        {
            self.clearTimer = clearTimer
            self.dynamoDB = dynamoDB
            self.dynamoDBv2 = dynamoDBv2
            self.firehose = firehose
            self.iotEvents = iotEvents
            self.iotSiteWise = iotSiteWise
            self.iotTopicPublish = iotTopicPublish
            self.lambda = lambda
            self.resetTimer = resetTimer
            self.setTimer = setTimer
            self.setVariable = setVariable
            self.sns = sns
            self.sqs = sqs
        }
    }

}

extension IoTEventsClientTypes.AlarmAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dynamoDB
        case dynamoDBv2
        case firehose
        case iotEvents
        case iotSiteWise
        case iotTopicPublish
        case lambda
        case sns
        case sqs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dynamoDB = self.dynamoDB {
            try encodeContainer.encode(dynamoDB, forKey: .dynamoDB)
        }
        if let dynamoDBv2 = self.dynamoDBv2 {
            try encodeContainer.encode(dynamoDBv2, forKey: .dynamoDBv2)
        }
        if let firehose = self.firehose {
            try encodeContainer.encode(firehose, forKey: .firehose)
        }
        if let iotEvents = self.iotEvents {
            try encodeContainer.encode(iotEvents, forKey: .iotEvents)
        }
        if let iotSiteWise = self.iotSiteWise {
            try encodeContainer.encode(iotSiteWise, forKey: .iotSiteWise)
        }
        if let iotTopicPublish = self.iotTopicPublish {
            try encodeContainer.encode(iotTopicPublish, forKey: .iotTopicPublish)
        }
        if let lambda = self.lambda {
            try encodeContainer.encode(lambda, forKey: .lambda)
        }
        if let sns = self.sns {
            try encodeContainer.encode(sns, forKey: .sns)
        }
        if let sqs = self.sqs {
            try encodeContainer.encode(sqs, forKey: .sqs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snsDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.SNSTopicPublishAction.self, forKey: .sns)
        sns = snsDecoded
        let iotTopicPublishDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.IotTopicPublishAction.self, forKey: .iotTopicPublish)
        iotTopicPublish = iotTopicPublishDecoded
        let lambdaDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.LambdaAction.self, forKey: .lambda)
        lambda = lambdaDecoded
        let iotEventsDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.IotEventsAction.self, forKey: .iotEvents)
        iotEvents = iotEventsDecoded
        let sqsDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.SqsAction.self, forKey: .sqs)
        sqs = sqsDecoded
        let firehoseDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.FirehoseAction.self, forKey: .firehose)
        firehose = firehoseDecoded
        let dynamoDBDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.DynamoDBAction.self, forKey: .dynamoDB)
        dynamoDB = dynamoDBDecoded
        let dynamoDBv2Decoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.DynamoDBv2Action.self, forKey: .dynamoDBv2)
        dynamoDBv2 = dynamoDBv2Decoded
        let iotSiteWiseDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.IotSiteWiseAction.self, forKey: .iotSiteWise)
        iotSiteWise = iotSiteWiseDecoded
    }
}

extension IoTEventsClientTypes {
    /// Specifies one of the following actions to receive notifications when the alarm state changes.
    public struct AlarmAction: Swift.Equatable {
        /// Defines an action to write to the Amazon DynamoDB table that you created. The standard action payload contains all the information about the detector model instance and the event that triggered the action. You can customize the [payload](https://docs.aws.amazon.com/iotevents/latest/apireference/API_Payload.html). One column of the DynamoDB table receives all attribute-value pairs in the payload that you specify. You must use expressions for all parameters in DynamoDBAction. The expressions accept literals, operators, functions, references, and substitution templates. Examples
        ///
        /// * For literal values, the expressions must contain single quotes. For example, the value for the hashKeyType parameter can be 'STRING'.
        ///
        /// * For references, you must specify either variables or input values. For example, the value for the hashKeyField parameter can be $input.GreenhouseInput.name.
        ///
        /// * For a substitution template, you must use ${}, and the template must be in single quotes. A substitution template can also contain a combination of literals, operators, functions, references, and substitution templates. In the following example, the value for the hashKeyValue parameter uses a substitution template. '${$input.GreenhouseInput.temperature * 6 / 5 + 32} in Fahrenheit'
        ///
        /// * For a string concatenation, you must use +. A string concatenation can also contain a combination of literals, operators, functions, references, and substitution templates. In the following example, the value for the tableName parameter uses a string concatenation. 'GreenhouseTemperatureTable ' + $input.GreenhouseInput.date
        ///
        ///
        /// For more information, see [Expressions](https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html) in the AWS IoT Events Developer Guide. If the defined payload type is a string, DynamoDBAction writes non-JSON data to the DynamoDB table as binary data. The DynamoDB console displays the data as Base64-encoded text. The value for the payloadField parameter is _raw.
        public var dynamoDB: IoTEventsClientTypes.DynamoDBAction?
        /// Defines an action to write to the Amazon DynamoDB table that you created. The default action payload contains all the information about the detector model instance and the event that triggered the action. You can customize the [payload](https://docs.aws.amazon.com/iotevents/latest/apireference/API_Payload.html). A separate column of the DynamoDB table receives one attribute-value pair in the payload that you specify. You must use expressions for all parameters in DynamoDBv2Action. The expressions accept literals, operators, functions, references, and substitution templates. Examples
        ///
        /// * For literal values, the expressions must contain single quotes. For example, the value for the tableName parameter can be 'GreenhouseTemperatureTable'.
        ///
        /// * For references, you must specify either variables or input values. For example, the value for the tableName parameter can be $variable.ddbtableName.
        ///
        /// * For a substitution template, you must use ${}, and the template must be in single quotes. A substitution template can also contain a combination of literals, operators, functions, references, and substitution templates. In the following example, the value for the contentExpression parameter in Payload uses a substitution template. '{\"sensorID\": \"${$input.GreenhouseInput.sensor_id}\", \"temperature\": \"${$input.GreenhouseInput.temperature * 9 / 5 + 32}\"}'
        ///
        /// * For a string concatenation, you must use +. A string concatenation can also contain a combination of literals, operators, functions, references, and substitution templates. In the following example, the value for the tableName parameter uses a string concatenation. 'GreenhouseTemperatureTable ' + $input.GreenhouseInput.date
        ///
        ///
        /// For more information, see [Expressions](https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html) in the AWS IoT Events Developer Guide. The value for the type parameter in Payload must be JSON.
        public var dynamoDBv2: IoTEventsClientTypes.DynamoDBv2Action?
        /// Sends information about the detector model instance and the event that triggered the action to an Amazon Kinesis Data Firehose delivery stream.
        public var firehose: IoTEventsClientTypes.FirehoseAction?
        /// Sends an AWS IoT Events input, passing in information about the detector model instance and the event that triggered the action.
        public var iotEvents: IoTEventsClientTypes.IotEventsAction?
        /// Sends information about the detector model instance and the event that triggered the action to a specified asset property in AWS IoT SiteWise. You must use expressions for all parameters in IotSiteWiseAction. The expressions accept literals, operators, functions, references, and substitutions templates. Examples
        ///
        /// * For literal values, the expressions must contain single quotes. For example, the value for the propertyAlias parameter can be '/company/windfarm/3/turbine/7/temperature'.
        ///
        /// * For references, you must specify either variables or input values. For example, the value for the assetId parameter can be $input.TurbineInput.assetId1.
        ///
        /// * For a substitution template, you must use ${}, and the template must be in single quotes. A substitution template can also contain a combination of literals, operators, functions, references, and substitution templates. In the following example, the value for the propertyAlias parameter uses a substitution template. 'company/windfarm/${$input.TemperatureInput.sensorData.windfarmID}/turbine/ ${$input.TemperatureInput.sensorData.turbineID}/temperature'
        ///
        ///
        /// You must specify either propertyAlias or both assetId and propertyId to identify the target asset property in AWS IoT SiteWise. For more information, see [Expressions](https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html) in the AWS IoT Events Developer Guide.
        public var iotSiteWise: IoTEventsClientTypes.IotSiteWiseAction?
        /// Information required to publish the MQTT message through the AWS IoT message broker.
        public var iotTopicPublish: IoTEventsClientTypes.IotTopicPublishAction?
        /// Calls a Lambda function, passing in information about the detector model instance and the event that triggered the action.
        public var lambda: IoTEventsClientTypes.LambdaAction?
        /// Information required to publish the Amazon SNS message.
        public var sns: IoTEventsClientTypes.SNSTopicPublishAction?
        /// Sends information about the detector model instance and the event that triggered the action to an Amazon SQS queue.
        public var sqs: IoTEventsClientTypes.SqsAction?

        public init (
            dynamoDB: IoTEventsClientTypes.DynamoDBAction? = nil,
            dynamoDBv2: IoTEventsClientTypes.DynamoDBv2Action? = nil,
            firehose: IoTEventsClientTypes.FirehoseAction? = nil,
            iotEvents: IoTEventsClientTypes.IotEventsAction? = nil,
            iotSiteWise: IoTEventsClientTypes.IotSiteWiseAction? = nil,
            iotTopicPublish: IoTEventsClientTypes.IotTopicPublishAction? = nil,
            lambda: IoTEventsClientTypes.LambdaAction? = nil,
            sns: IoTEventsClientTypes.SNSTopicPublishAction? = nil,
            sqs: IoTEventsClientTypes.SqsAction? = nil
        )
        {
            self.dynamoDB = dynamoDB
            self.dynamoDBv2 = dynamoDBv2
            self.firehose = firehose
            self.iotEvents = iotEvents
            self.iotSiteWise = iotSiteWise
            self.iotTopicPublish = iotTopicPublish
            self.lambda = lambda
            self.sns = sns
            self.sqs = sqs
        }
    }

}

extension IoTEventsClientTypes.AlarmCapabilities: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acknowledgeFlow
        case initializationConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acknowledgeFlow = self.acknowledgeFlow {
            try encodeContainer.encode(acknowledgeFlow, forKey: .acknowledgeFlow)
        }
        if let initializationConfiguration = self.initializationConfiguration {
            try encodeContainer.encode(initializationConfiguration, forKey: .initializationConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initializationConfigurationDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.InitializationConfiguration.self, forKey: .initializationConfiguration)
        initializationConfiguration = initializationConfigurationDecoded
        let acknowledgeFlowDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.AcknowledgeFlow.self, forKey: .acknowledgeFlow)
        acknowledgeFlow = acknowledgeFlowDecoded
    }
}

extension IoTEventsClientTypes {
    /// Contains the configuration information of alarm state changes.
    public struct AlarmCapabilities: Swift.Equatable {
        /// Specifies whether to get notified for alarm state changes.
        public var acknowledgeFlow: IoTEventsClientTypes.AcknowledgeFlow?
        /// Specifies the default alarm state. The configuration applies to all alarms that were created based on this alarm model.
        public var initializationConfiguration: IoTEventsClientTypes.InitializationConfiguration?

        public init (
            acknowledgeFlow: IoTEventsClientTypes.AcknowledgeFlow? = nil,
            initializationConfiguration: IoTEventsClientTypes.InitializationConfiguration? = nil
        )
        {
            self.acknowledgeFlow = acknowledgeFlow
            self.initializationConfiguration = initializationConfiguration
        }
    }

}

extension IoTEventsClientTypes.AlarmEventActions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmActions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmActions = alarmActions {
            var alarmActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .alarmActions)
            for alarmaction0 in alarmActions {
                try alarmActionsContainer.encode(alarmaction0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmActionsContainer = try containerValues.decodeIfPresent([IoTEventsClientTypes.AlarmAction?].self, forKey: .alarmActions)
        var alarmActionsDecoded0:[IoTEventsClientTypes.AlarmAction]? = nil
        if let alarmActionsContainer = alarmActionsContainer {
            alarmActionsDecoded0 = [IoTEventsClientTypes.AlarmAction]()
            for structure0 in alarmActionsContainer {
                if let structure0 = structure0 {
                    alarmActionsDecoded0?.append(structure0)
                }
            }
        }
        alarmActions = alarmActionsDecoded0
    }
}

extension IoTEventsClientTypes {
    /// Contains information about one or more alarm actions.
    public struct AlarmEventActions: Swift.Equatable {
        /// Specifies one or more supported actions to receive notifications when the alarm state changes.
        public var alarmActions: [IoTEventsClientTypes.AlarmAction]?

        public init (
            alarmActions: [IoTEventsClientTypes.AlarmAction]? = nil
        )
        {
            self.alarmActions = alarmActions
        }
    }

}

extension IoTEventsClientTypes.AlarmModelSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmModelDescription
        case alarmModelName
        case creationTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmModelDescription = self.alarmModelDescription {
            try encodeContainer.encode(alarmModelDescription, forKey: .alarmModelDescription)
        }
        if let alarmModelName = self.alarmModelName {
            try encodeContainer.encode(alarmModelName, forKey: .alarmModelName)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let alarmModelDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelDescription)
        alarmModelDescription = alarmModelDescriptionDecoded
        let alarmModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelName)
        alarmModelName = alarmModelNameDecoded
    }
}

extension IoTEventsClientTypes {
    /// Contains a summary of an alarm model.
    public struct AlarmModelSummary: Swift.Equatable {
        /// The description of the alarm model.
        public var alarmModelDescription: Swift.String?
        /// The name of the alarm model.
        public var alarmModelName: Swift.String?
        /// The time the alarm model was created, in the Unix epoch format.
        public var creationTime: ClientRuntime.Date?

        public init (
            alarmModelDescription: Swift.String? = nil,
            alarmModelName: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil
        )
        {
            self.alarmModelDescription = alarmModelDescription
            self.alarmModelName = alarmModelName
            self.creationTime = creationTime
        }
    }

}

extension IoTEventsClientTypes {
    public enum AlarmModelVersionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activating
        case active
        case failed
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [AlarmModelVersionStatus] {
            return [
                .activating,
                .active,
                .failed,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activating: return "ACTIVATING"
            case .active: return "ACTIVE"
            case .failed: return "FAILED"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AlarmModelVersionStatus(rawValue: rawValue) ?? AlarmModelVersionStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTEventsClientTypes.AlarmModelVersionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmModelArn
        case alarmModelName
        case alarmModelVersion
        case creationTime
        case lastUpdateTime
        case roleArn
        case status
        case statusMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmModelArn = self.alarmModelArn {
            try encodeContainer.encode(alarmModelArn, forKey: .alarmModelArn)
        }
        if let alarmModelName = self.alarmModelName {
            try encodeContainer.encode(alarmModelName, forKey: .alarmModelName)
        }
        if let alarmModelVersion = self.alarmModelVersion {
            try encodeContainer.encode(alarmModelVersion, forKey: .alarmModelVersion)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let lastUpdateTime = self.lastUpdateTime {
            try encodeContainer.encodeTimestamp(lastUpdateTime, format: .epochSeconds, forKey: .lastUpdateTime)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelName)
        alarmModelName = alarmModelNameDecoded
        let alarmModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelArn)
        alarmModelArn = alarmModelArnDecoded
        let alarmModelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelVersion)
        alarmModelVersion = alarmModelVersionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.AlarmModelVersionStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension IoTEventsClientTypes {
    /// Contains a summary of an alarm model version.
    public struct AlarmModelVersionSummary: Swift.Equatable {
        /// The ARN of the alarm model. For more information, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
        public var alarmModelArn: Swift.String?
        /// The name of the alarm model.
        public var alarmModelName: Swift.String?
        /// The version of the alarm model.
        public var alarmModelVersion: Swift.String?
        /// The time the alarm model was created, in the Unix epoch format.
        public var creationTime: ClientRuntime.Date?
        /// The time the alarm model was last updated, in the Unix epoch format.
        public var lastUpdateTime: ClientRuntime.Date?
        /// The ARN of the IAM role that allows the alarm to perform actions and access AWS resources. For more information, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
        public var roleArn: Swift.String?
        /// The status of the alarm model. The status can be one of the following values:
        ///
        /// * ACTIVE - The alarm model is active and it's ready to evaluate data.
        ///
        /// * ACTIVATING - AWS IoT Events is activating your alarm model. Activating an alarm model can take up to a few minutes.
        ///
        /// * INACTIVE - The alarm model is inactive, so it isn't ready to evaluate data. Check your alarm model information and update the alarm model.
        ///
        /// * FAILED - You couldn't create or update the alarm model. Check your alarm model information and try again.
        public var status: IoTEventsClientTypes.AlarmModelVersionStatus?
        /// Contains information about the status of the alarm model version.
        public var statusMessage: Swift.String?

        public init (
            alarmModelArn: Swift.String? = nil,
            alarmModelName: Swift.String? = nil,
            alarmModelVersion: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            roleArn: Swift.String? = nil,
            status: IoTEventsClientTypes.AlarmModelVersionStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.alarmModelArn = alarmModelArn
            self.alarmModelName = alarmModelName
            self.alarmModelVersion = alarmModelVersion
            self.creationTime = creationTime
            self.lastUpdateTime = lastUpdateTime
            self.roleArn = roleArn
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension IoTEventsClientTypes.AlarmNotification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notificationActions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notificationActions = notificationActions {
            var notificationActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notificationActions)
            for notificationaction0 in notificationActions {
                try notificationActionsContainer.encode(notificationaction0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationActionsContainer = try containerValues.decodeIfPresent([IoTEventsClientTypes.NotificationAction?].self, forKey: .notificationActions)
        var notificationActionsDecoded0:[IoTEventsClientTypes.NotificationAction]? = nil
        if let notificationActionsContainer = notificationActionsContainer {
            notificationActionsDecoded0 = [IoTEventsClientTypes.NotificationAction]()
            for structure0 in notificationActionsContainer {
                if let structure0 = structure0 {
                    notificationActionsDecoded0?.append(structure0)
                }
            }
        }
        notificationActions = notificationActionsDecoded0
    }
}

extension IoTEventsClientTypes {
    /// Contains information about one or more notification actions.
    public struct AlarmNotification: Swift.Equatable {
        /// Contains the notification settings of an alarm model. The settings apply to all alarms that were created based on this alarm model.
        public var notificationActions: [IoTEventsClientTypes.NotificationAction]?

        public init (
            notificationActions: [IoTEventsClientTypes.NotificationAction]? = nil
        )
        {
            self.notificationActions = notificationActions
        }
    }

}

extension IoTEventsClientTypes.AlarmRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case simpleRule
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let simpleRule = self.simpleRule {
            try encodeContainer.encode(simpleRule, forKey: .simpleRule)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simpleRuleDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.SimpleRule.self, forKey: .simpleRule)
        simpleRule = simpleRuleDecoded
    }
}

extension IoTEventsClientTypes {
    /// Defines when your alarm is invoked.
    public struct AlarmRule: Swift.Equatable {
        /// A rule that compares an input property value to a threshold value with a comparison operator.
        public var simpleRule: IoTEventsClientTypes.SimpleRule?

        public init (
            simpleRule: IoTEventsClientTypes.SimpleRule? = nil
        )
        {
            self.simpleRule = simpleRule
        }
    }

}

extension IoTEventsClientTypes.AnalysisResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case level
        case locations
        case message
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let level = self.level {
            try encodeContainer.encode(level.rawValue, forKey: .level)
        }
        if let locations = locations {
            var locationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .locations)
            for analysisresultlocation0 in locations {
                try locationsContainer.encode(analysisresultlocation0)
            }
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let levelDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.AnalysisResultLevel.self, forKey: .level)
        level = levelDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let locationsContainer = try containerValues.decodeIfPresent([IoTEventsClientTypes.AnalysisResultLocation?].self, forKey: .locations)
        var locationsDecoded0:[IoTEventsClientTypes.AnalysisResultLocation]? = nil
        if let locationsContainer = locationsContainer {
            locationsDecoded0 = [IoTEventsClientTypes.AnalysisResultLocation]()
            for structure0 in locationsContainer {
                if let structure0 = structure0 {
                    locationsDecoded0?.append(structure0)
                }
            }
        }
        locations = locationsDecoded0
    }
}

extension IoTEventsClientTypes {
    /// Contains the result of the analysis.
    public struct AnalysisResult: Swift.Equatable {
        /// The severity level of the analysis result. Based on the severity level, analysis results fall into three general categories:
        ///
        /// * INFO - An information result tells you about a significant field in your detector model. This type of result usually doesn't require immediate action.
        ///
        /// * WARNING - A warning result draws special attention to fields that might cause issues for your detector model. We recommend that you review warnings and take necessary actions before you use your detector model in production environments. Otherwise, the detector model might not work as expected.
        ///
        /// * ERROR - An error result notifies you about a problem found in your detector model. You must fix all errors before you can publish your detector model.
        public var level: IoTEventsClientTypes.AnalysisResultLevel?
        /// Contains one or more locations that you can use to locate the fields in your detector model that the analysis result references.
        public var locations: [IoTEventsClientTypes.AnalysisResultLocation]?
        /// Contains additional information about the analysis result.
        public var message: Swift.String?
        /// The type of the analysis result. Analyses fall into the following types based on the validators used to generate the analysis result:
        ///
        /// * supported-actions - You must specify AWS IoT Events supported actions that work with other AWS services in a supported AWS Region.
        ///
        /// * service-limits - Resources or API operations can't exceed service quotas (also known as limits). Update your detector model or request a quota increase.
        ///
        /// * structure - The detector model must follow a structure that AWS IoT Events supports.
        ///
        /// * expression-syntax - Your expression must follow the required syntax.
        ///
        /// * data-type - Data types referenced in the detector model must be compatible.
        ///
        /// * referenced-data - You must define the data referenced in your detector model before you can use the data.
        ///
        /// * referenced-resource - Resources that the detector model uses must be available.
        ///
        ///
        /// For more information, see [Running detector model analyses](https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-analyze-api.html) in the AWS IoT Events Developer Guide.
        public var type: Swift.String?

        public init (
            level: IoTEventsClientTypes.AnalysisResultLevel? = nil,
            locations: [IoTEventsClientTypes.AnalysisResultLocation]? = nil,
            message: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.level = level
            self.locations = locations
            self.message = message
            self.type = type
        }
    }

}

extension IoTEventsClientTypes {
    public enum AnalysisResultLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case info
        case warning
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalysisResultLevel] {
            return [
                .error,
                .info,
                .warning,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .info: return "INFO"
            case .warning: return "WARNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalysisResultLevel(rawValue: rawValue) ?? AnalysisResultLevel.sdkUnknown(rawValue)
        }
    }
}

extension IoTEventsClientTypes.AnalysisResultLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case path
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
    }
}

extension IoTEventsClientTypes {
    /// Contains information that you can use to locate the field in your detector model that the analysis result references.
    public struct AnalysisResultLocation: Swift.Equatable {
        /// A [JsonPath](https://github.com/json-path/JsonPath) expression that identifies the error field in your detector model.
        public var path: Swift.String?

        public init (
            path: Swift.String? = nil
        )
        {
            self.path = path
        }
    }

}

extension IoTEventsClientTypes {
    public enum AnalysisStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case failed
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalysisStatus] {
            return [
                .complete,
                .failed,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalysisStatus(rawValue: rawValue) ?? AnalysisStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTEventsClientTypes.AssetPropertyTimestamp: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case offsetInNanos
        case timeInSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let offsetInNanos = self.offsetInNanos {
            try encodeContainer.encode(offsetInNanos, forKey: .offsetInNanos)
        }
        if let timeInSeconds = self.timeInSeconds {
            try encodeContainer.encode(timeInSeconds, forKey: .timeInSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeInSeconds)
        timeInSeconds = timeInSecondsDecoded
        let offsetInNanosDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offsetInNanos)
        offsetInNanos = offsetInNanosDecoded
    }
}

extension IoTEventsClientTypes {
    /// A structure that contains timestamp information. For more information, see [TimeInNanos](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_TimeInNanos.html) in the AWS IoT SiteWise API Reference. You must use expressions for all parameters in AssetPropertyTimestamp. The expressions accept literals, operators, functions, references, and substitution templates. Examples
    ///
    /// * For literal values, the expressions must contain single quotes. For example, the value for the timeInSeconds parameter can be '1586400675'.
    ///
    /// * For references, you must specify either variables or input values. For example, the value for the offsetInNanos parameter can be $variable.time.
    ///
    /// * For a substitution template, you must use ${}, and the template must be in single quotes. A substitution template can also contain a combination of literals, operators, functions, references, and substitution templates. In the following example, the value for the timeInSeconds parameter uses a substitution template. '${$input.TemperatureInput.sensorData.timestamp / 1000}'
    ///
    ///
    /// For more information, see [Expressions](https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html) in the AWS IoT Events Developer Guide.
    public struct AssetPropertyTimestamp: Swift.Equatable {
        /// The nanosecond offset converted from timeInSeconds. The valid range is between 0-999999999.
        public var offsetInNanos: Swift.String?
        /// The timestamp, in seconds, in the Unix epoch format. The valid range is between 1-31556889864403199.
        /// This member is required.
        public var timeInSeconds: Swift.String?

        public init (
            offsetInNanos: Swift.String? = nil,
            timeInSeconds: Swift.String? = nil
        )
        {
            self.offsetInNanos = offsetInNanos
            self.timeInSeconds = timeInSeconds
        }
    }

}

extension IoTEventsClientTypes.AssetPropertyValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quality
        case timestamp
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let quality = self.quality {
            try encodeContainer.encode(quality, forKey: .quality)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.AssetPropertyVariant.self, forKey: .value)
        value = valueDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.AssetPropertyTimestamp.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let qualityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quality)
        quality = qualityDecoded
    }
}

extension IoTEventsClientTypes {
    /// A structure that contains value information. For more information, see [AssetPropertyValue](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_AssetPropertyValue.html) in the AWS IoT SiteWise API Reference. You must use expressions for all parameters in AssetPropertyValue. The expressions accept literals, operators, functions, references, and substitution templates. Examples
    ///
    /// * For literal values, the expressions must contain single quotes. For example, the value for the quality parameter can be 'GOOD'.
    ///
    /// * For references, you must specify either variables or input values. For example, the value for the quality parameter can be $input.TemperatureInput.sensorData.quality.
    ///
    ///
    /// For more information, see [Expressions](https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html) in the AWS IoT Events Developer Guide.
    public struct AssetPropertyValue: Swift.Equatable {
        /// The quality of the asset property value. The value must be 'GOOD', 'BAD', or 'UNCERTAIN'.
        public var quality: Swift.String?
        /// The timestamp associated with the asset property value. The default is the current event time.
        public var timestamp: IoTEventsClientTypes.AssetPropertyTimestamp?
        /// The value to send to an asset property.
        public var value: IoTEventsClientTypes.AssetPropertyVariant?

        public init (
            quality: Swift.String? = nil,
            timestamp: IoTEventsClientTypes.AssetPropertyTimestamp? = nil,
            value: IoTEventsClientTypes.AssetPropertyVariant? = nil
        )
        {
            self.quality = quality
            self.timestamp = timestamp
            self.value = value
        }
    }

}

extension IoTEventsClientTypes.AssetPropertyVariant: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case booleanValue
        case doubleValue
        case integerValue
        case stringValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let booleanValue = self.booleanValue {
            try encodeContainer.encode(booleanValue, forKey: .booleanValue)
        }
        if let doubleValue = self.doubleValue {
            try encodeContainer.encode(doubleValue, forKey: .doubleValue)
        }
        if let integerValue = self.integerValue {
            try encodeContainer.encode(integerValue, forKey: .integerValue)
        }
        if let stringValue = self.stringValue {
            try encodeContainer.encode(stringValue, forKey: .stringValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stringValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stringValue)
        stringValue = stringValueDecoded
        let integerValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integerValue)
        integerValue = integerValueDecoded
        let doubleValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .doubleValue)
        doubleValue = doubleValueDecoded
        let booleanValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .booleanValue)
        booleanValue = booleanValueDecoded
    }
}

extension IoTEventsClientTypes {
    /// A structure that contains an asset property value. For more information, see [Variant](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_Variant.html) in the AWS IoT SiteWise API Reference. You must use expressions for all parameters in AssetPropertyVariant. The expressions accept literals, operators, functions, references, and substitution templates. Examples
    ///
    /// * For literal values, the expressions must contain single quotes. For example, the value for the integerValue parameter can be '100'.
    ///
    /// * For references, you must specify either variables or parameters. For example, the value for the booleanValue parameter can be $variable.offline.
    ///
    /// * For a substitution template, you must use ${}, and the template must be in single quotes. A substitution template can also contain a combination of literals, operators, functions, references, and substitution templates. In the following example, the value for the doubleValue parameter uses a substitution template. '${$input.TemperatureInput.sensorData.temperature * 6 / 5 + 32}'
    ///
    ///
    /// For more information, see [Expressions](https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html) in the AWS IoT Events Developer Guide. You must specify one of the following value types, depending on the dataType of the specified asset property. For more information, see [AssetProperty](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_AssetProperty.html) in the AWS IoT SiteWise API Reference.
    public struct AssetPropertyVariant: Swift.Equatable {
        /// The asset property value is a Boolean value that must be 'TRUE' or 'FALSE'. You must use an expression, and the evaluated result should be a Boolean value.
        public var booleanValue: Swift.String?
        /// The asset property value is a double. You must use an expression, and the evaluated result should be a double.
        public var doubleValue: Swift.String?
        /// The asset property value is an integer. You must use an expression, and the evaluated result should be an integer.
        public var integerValue: Swift.String?
        /// The asset property value is a string. You must use an expression, and the evaluated result should be a string.
        public var stringValue: Swift.String?

        public init (
            booleanValue: Swift.String? = nil,
            doubleValue: Swift.String? = nil,
            integerValue: Swift.String? = nil,
            stringValue: Swift.String? = nil
        )
        {
            self.booleanValue = booleanValue
            self.doubleValue = doubleValue
            self.integerValue = integerValue
            self.stringValue = stringValue
        }
    }

}

extension IoTEventsClientTypes.Attribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jsonPath
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jsonPath = self.jsonPath {
            try encodeContainer.encode(jsonPath, forKey: .jsonPath)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jsonPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jsonPath)
        jsonPath = jsonPathDecoded
    }
}

extension IoTEventsClientTypes {
    /// The attributes from the JSON payload that are made available by the input. Inputs are derived from messages sent to the AWS IoT Events system using BatchPutMessage. Each such message contains a JSON payload. Those attributes (and their paired values) specified here are available for use in the condition expressions used by detectors.
    public struct Attribute: Swift.Equatable {
        /// An expression that specifies an attribute-value pair in a JSON structure. Use this to specify an attribute from the JSON payload that is made available by the input. Inputs are derived from messages sent to AWS IoT Events (BatchPutMessage). Each such message contains a JSON payload. The attribute (and its paired value) specified here are available for use in the condition expressions used by detectors. Syntax: ....
        /// This member is required.
        public var jsonPath: Swift.String?

        public init (
            jsonPath: Swift.String? = nil
        )
        {
            self.jsonPath = jsonPath
        }
    }

}

extension IoTEventsClientTypes.ClearTimerAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timerName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timerName = self.timerName {
            try encodeContainer.encode(timerName, forKey: .timerName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timerName)
        timerName = timerNameDecoded
    }
}

extension IoTEventsClientTypes {
    /// Information needed to clear the timer.
    public struct ClearTimerAction: Swift.Equatable {
        /// The name of the timer to clear.
        /// This member is required.
        public var timerName: Swift.String?

        public init (
            timerName: Swift.String? = nil
        )
        {
            self.timerName = timerName
        }
    }

}

extension IoTEventsClientTypes {
    public enum ComparisonOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equal
        case greater
        case greaterOrEqual
        case less
        case lessOrEqual
        case notEqual
        case sdkUnknown(Swift.String)

        public static var allCases: [ComparisonOperator] {
            return [
                .equal,
                .greater,
                .greaterOrEqual,
                .less,
                .lessOrEqual,
                .notEqual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equal: return "EQUAL"
            case .greater: return "GREATER"
            case .greaterOrEqual: return "GREATER_OR_EQUAL"
            case .less: return "LESS"
            case .lessOrEqual: return "LESS_OR_EQUAL"
            case .notEqual: return "NOT_EQUAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComparisonOperator(rawValue: rawValue) ?? ComparisonOperator.sdkUnknown(rawValue)
        }
    }
}

extension CreateAlarmModelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmCapabilities
        case alarmEventActions
        case alarmModelDescription
        case alarmModelName
        case alarmNotification
        case alarmRule
        case key
        case roleArn
        case severity
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmCapabilities = self.alarmCapabilities {
            try encodeContainer.encode(alarmCapabilities, forKey: .alarmCapabilities)
        }
        if let alarmEventActions = self.alarmEventActions {
            try encodeContainer.encode(alarmEventActions, forKey: .alarmEventActions)
        }
        if let alarmModelDescription = self.alarmModelDescription {
            try encodeContainer.encode(alarmModelDescription, forKey: .alarmModelDescription)
        }
        if let alarmModelName = self.alarmModelName {
            try encodeContainer.encode(alarmModelName, forKey: .alarmModelName)
        }
        if let alarmNotification = self.alarmNotification {
            try encodeContainer.encode(alarmNotification, forKey: .alarmNotification)
        }
        if let alarmRule = self.alarmRule {
            try encodeContainer.encode(alarmRule, forKey: .alarmRule)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let severity = self.severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateAlarmModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/alarm-models"
    }
}

public struct CreateAlarmModelInput: Swift.Equatable {
    /// Contains the configuration information of alarm state changes.
    public var alarmCapabilities: IoTEventsClientTypes.AlarmCapabilities?
    /// Contains information about one or more alarm actions.
    public var alarmEventActions: IoTEventsClientTypes.AlarmEventActions?
    /// A description that tells you what the alarm model detects.
    public var alarmModelDescription: Swift.String?
    /// A unique name that helps you identify the alarm model. You can't change this name after you create the alarm model.
    /// This member is required.
    public var alarmModelName: Swift.String?
    /// Contains information about one or more notification actions.
    public var alarmNotification: IoTEventsClientTypes.AlarmNotification?
    /// Defines when your alarm is invoked.
    /// This member is required.
    public var alarmRule: IoTEventsClientTypes.AlarmRule?
    /// An input attribute used as a key to create an alarm. AWS IoT Events routes [inputs](https://docs.aws.amazon.com/iotevents/latest/apireference/API_Input.html) associated with this key to the alarm.
    public var key: Swift.String?
    /// The ARN of the IAM role that allows the alarm to perform actions and access AWS resources. For more information, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A non-negative integer that reflects the severity level of the alarm.
    public var severity: Swift.Int?
    /// A list of key-value pairs that contain metadata for the alarm model. The tags help you manage the alarm model. For more information, see [Tagging your AWS IoT Events resources](https://docs.aws.amazon.com/iotevents/latest/developerguide/tagging-iotevents.html) in the AWS IoT Events Developer Guide. You can create up to 50 tags for one alarm model.
    public var tags: [IoTEventsClientTypes.Tag]?

    public init (
        alarmCapabilities: IoTEventsClientTypes.AlarmCapabilities? = nil,
        alarmEventActions: IoTEventsClientTypes.AlarmEventActions? = nil,
        alarmModelDescription: Swift.String? = nil,
        alarmModelName: Swift.String? = nil,
        alarmNotification: IoTEventsClientTypes.AlarmNotification? = nil,
        alarmRule: IoTEventsClientTypes.AlarmRule? = nil,
        key: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        severity: Swift.Int? = nil,
        tags: [IoTEventsClientTypes.Tag]? = nil
    )
    {
        self.alarmCapabilities = alarmCapabilities
        self.alarmEventActions = alarmEventActions
        self.alarmModelDescription = alarmModelDescription
        self.alarmModelName = alarmModelName
        self.alarmNotification = alarmNotification
        self.alarmRule = alarmRule
        self.key = key
        self.roleArn = roleArn
        self.severity = severity
        self.tags = tags
    }
}

struct CreateAlarmModelInputBody: Swift.Equatable {
    let alarmModelName: Swift.String?
    let alarmModelDescription: Swift.String?
    let roleArn: Swift.String?
    let tags: [IoTEventsClientTypes.Tag]?
    let key: Swift.String?
    let severity: Swift.Int?
    let alarmRule: IoTEventsClientTypes.AlarmRule?
    let alarmNotification: IoTEventsClientTypes.AlarmNotification?
    let alarmEventActions: IoTEventsClientTypes.AlarmEventActions?
    let alarmCapabilities: IoTEventsClientTypes.AlarmCapabilities?
}

extension CreateAlarmModelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmCapabilities
        case alarmEventActions
        case alarmModelDescription
        case alarmModelName
        case alarmNotification
        case alarmRule
        case key
        case roleArn
        case severity
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelName)
        alarmModelName = alarmModelNameDecoded
        let alarmModelDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelDescription)
        alarmModelDescription = alarmModelDescriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTEventsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTEventsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTEventsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let severityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .severity)
        severity = severityDecoded
        let alarmRuleDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.AlarmRule.self, forKey: .alarmRule)
        alarmRule = alarmRuleDecoded
        let alarmNotificationDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.AlarmNotification.self, forKey: .alarmNotification)
        alarmNotification = alarmNotificationDecoded
        let alarmEventActionsDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.AlarmEventActions.self, forKey: .alarmEventActions)
        alarmEventActions = alarmEventActionsDecoded
        let alarmCapabilitiesDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.AlarmCapabilities.self, forKey: .alarmCapabilities)
        alarmCapabilities = alarmCapabilitiesDecoded
    }
}

extension CreateAlarmModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAlarmModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateAlarmModelOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAlarmModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateAlarmModelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alarmModelArn = output.alarmModelArn
            self.alarmModelVersion = output.alarmModelVersion
            self.creationTime = output.creationTime
            self.lastUpdateTime = output.lastUpdateTime
            self.status = output.status
        } else {
            self.alarmModelArn = nil
            self.alarmModelVersion = nil
            self.creationTime = nil
            self.lastUpdateTime = nil
            self.status = nil
        }
    }
}

public struct CreateAlarmModelOutputResponse: Swift.Equatable {
    /// The ARN of the alarm model. For more information, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    public var alarmModelArn: Swift.String?
    /// The version of the alarm model.
    public var alarmModelVersion: Swift.String?
    /// The time the alarm model was created, in the Unix epoch format.
    public var creationTime: ClientRuntime.Date?
    /// The time the alarm model was last updated, in the Unix epoch format.
    public var lastUpdateTime: ClientRuntime.Date?
    /// The status of the alarm model. The status can be one of the following values:
    ///
    /// * ACTIVE - The alarm model is active and it's ready to evaluate data.
    ///
    /// * ACTIVATING - AWS IoT Events is activating your alarm model. Activating an alarm model can take up to a few minutes.
    ///
    /// * INACTIVE - The alarm model is inactive, so it isn't ready to evaluate data. Check your alarm model information and update the alarm model.
    ///
    /// * FAILED - You couldn't create or update the alarm model. Check your alarm model information and try again.
    public var status: IoTEventsClientTypes.AlarmModelVersionStatus?

    public init (
        alarmModelArn: Swift.String? = nil,
        alarmModelVersion: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        lastUpdateTime: ClientRuntime.Date? = nil,
        status: IoTEventsClientTypes.AlarmModelVersionStatus? = nil
    )
    {
        self.alarmModelArn = alarmModelArn
        self.alarmModelVersion = alarmModelVersion
        self.creationTime = creationTime
        self.lastUpdateTime = lastUpdateTime
        self.status = status
    }
}

struct CreateAlarmModelOutputResponseBody: Swift.Equatable {
    let creationTime: ClientRuntime.Date?
    let alarmModelArn: Swift.String?
    let alarmModelVersion: Swift.String?
    let lastUpdateTime: ClientRuntime.Date?
    let status: IoTEventsClientTypes.AlarmModelVersionStatus?
}

extension CreateAlarmModelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmModelArn
        case alarmModelVersion
        case creationTime
        case lastUpdateTime
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let alarmModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelArn)
        alarmModelArn = alarmModelArnDecoded
        let alarmModelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelVersion)
        alarmModelVersion = alarmModelVersionDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.AlarmModelVersionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CreateDetectorModelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorModelDefinition
        case detectorModelDescription
        case detectorModelName
        case evaluationMethod
        case key
        case roleArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorModelDefinition = self.detectorModelDefinition {
            try encodeContainer.encode(detectorModelDefinition, forKey: .detectorModelDefinition)
        }
        if let detectorModelDescription = self.detectorModelDescription {
            try encodeContainer.encode(detectorModelDescription, forKey: .detectorModelDescription)
        }
        if let detectorModelName = self.detectorModelName {
            try encodeContainer.encode(detectorModelName, forKey: .detectorModelName)
        }
        if let evaluationMethod = self.evaluationMethod {
            try encodeContainer.encode(evaluationMethod.rawValue, forKey: .evaluationMethod)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateDetectorModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/detector-models"
    }
}

public struct CreateDetectorModelInput: Swift.Equatable {
    /// Information that defines how the detectors operate.
    /// This member is required.
    public var detectorModelDefinition: IoTEventsClientTypes.DetectorModelDefinition?
    /// A brief description of the detector model.
    public var detectorModelDescription: Swift.String?
    /// The name of the detector model.
    /// This member is required.
    public var detectorModelName: Swift.String?
    /// Information about the order in which events are evaluated and how actions are executed.
    public var evaluationMethod: IoTEventsClientTypes.EvaluationMethod?
    /// The input attribute key used to identify a device or system to create a detector (an instance of the detector model) and then to route each input received to the appropriate detector (instance). This parameter uses a JSON-path expression in the message payload of each input to specify the attribute-value pair that is used to identify the device associated with the input.
    public var key: Swift.String?
    /// The ARN of the role that grants permission to AWS IoT Events to perform its operations.
    /// This member is required.
    public var roleArn: Swift.String?
    /// Metadata that can be used to manage the detector model.
    public var tags: [IoTEventsClientTypes.Tag]?

    public init (
        detectorModelDefinition: IoTEventsClientTypes.DetectorModelDefinition? = nil,
        detectorModelDescription: Swift.String? = nil,
        detectorModelName: Swift.String? = nil,
        evaluationMethod: IoTEventsClientTypes.EvaluationMethod? = nil,
        key: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        tags: [IoTEventsClientTypes.Tag]? = nil
    )
    {
        self.detectorModelDefinition = detectorModelDefinition
        self.detectorModelDescription = detectorModelDescription
        self.detectorModelName = detectorModelName
        self.evaluationMethod = evaluationMethod
        self.key = key
        self.roleArn = roleArn
        self.tags = tags
    }
}

struct CreateDetectorModelInputBody: Swift.Equatable {
    let detectorModelName: Swift.String?
    let detectorModelDefinition: IoTEventsClientTypes.DetectorModelDefinition?
    let detectorModelDescription: Swift.String?
    let key: Swift.String?
    let roleArn: Swift.String?
    let tags: [IoTEventsClientTypes.Tag]?
    let evaluationMethod: IoTEventsClientTypes.EvaluationMethod?
}

extension CreateDetectorModelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorModelDefinition
        case detectorModelDescription
        case detectorModelName
        case evaluationMethod
        case key
        case roleArn
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorModelName)
        detectorModelName = detectorModelNameDecoded
        let detectorModelDefinitionDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.DetectorModelDefinition.self, forKey: .detectorModelDefinition)
        detectorModelDefinition = detectorModelDefinitionDecoded
        let detectorModelDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorModelDescription)
        detectorModelDescription = detectorModelDescriptionDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTEventsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTEventsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTEventsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let evaluationMethodDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.EvaluationMethod.self, forKey: .evaluationMethod)
        evaluationMethod = evaluationMethodDecoded
    }
}

extension CreateDetectorModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDetectorModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDetectorModelOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDetectorModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateDetectorModelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.detectorModelConfiguration = output.detectorModelConfiguration
        } else {
            self.detectorModelConfiguration = nil
        }
    }
}

public struct CreateDetectorModelOutputResponse: Swift.Equatable {
    /// Information about how the detector model is configured.
    public var detectorModelConfiguration: IoTEventsClientTypes.DetectorModelConfiguration?

    public init (
        detectorModelConfiguration: IoTEventsClientTypes.DetectorModelConfiguration? = nil
    )
    {
        self.detectorModelConfiguration = detectorModelConfiguration
    }
}

struct CreateDetectorModelOutputResponseBody: Swift.Equatable {
    let detectorModelConfiguration: IoTEventsClientTypes.DetectorModelConfiguration?
}

extension CreateDetectorModelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorModelConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelConfigurationDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.DetectorModelConfiguration.self, forKey: .detectorModelConfiguration)
        detectorModelConfiguration = detectorModelConfigurationDecoded
    }
}

extension CreateInputInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputDefinition
        case inputDescription
        case inputName
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputDefinition = self.inputDefinition {
            try encodeContainer.encode(inputDefinition, forKey: .inputDefinition)
        }
        if let inputDescription = self.inputDescription {
            try encodeContainer.encode(inputDescription, forKey: .inputDescription)
        }
        if let inputName = self.inputName {
            try encodeContainer.encode(inputName, forKey: .inputName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateInputInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/inputs"
    }
}

public struct CreateInputInput: Swift.Equatable {
    /// The definition of the input.
    /// This member is required.
    public var inputDefinition: IoTEventsClientTypes.InputDefinition?
    /// A brief description of the input.
    public var inputDescription: Swift.String?
    /// The name you want to give to the input.
    /// This member is required.
    public var inputName: Swift.String?
    /// Metadata that can be used to manage the input.
    public var tags: [IoTEventsClientTypes.Tag]?

    public init (
        inputDefinition: IoTEventsClientTypes.InputDefinition? = nil,
        inputDescription: Swift.String? = nil,
        inputName: Swift.String? = nil,
        tags: [IoTEventsClientTypes.Tag]? = nil
    )
    {
        self.inputDefinition = inputDefinition
        self.inputDescription = inputDescription
        self.inputName = inputName
        self.tags = tags
    }
}

struct CreateInputInputBody: Swift.Equatable {
    let inputName: Swift.String?
    let inputDescription: Swift.String?
    let inputDefinition: IoTEventsClientTypes.InputDefinition?
    let tags: [IoTEventsClientTypes.Tag]?
}

extension CreateInputInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputDefinition
        case inputDescription
        case inputName
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputName)
        inputName = inputNameDecoded
        let inputDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputDescription)
        inputDescription = inputDescriptionDecoded
        let inputDefinitionDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.InputDefinition.self, forKey: .inputDefinition)
        inputDefinition = inputDefinitionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTEventsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTEventsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTEventsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateInputOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateInputOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateInputOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateInputOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateInputOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.inputConfiguration = output.inputConfiguration
        } else {
            self.inputConfiguration = nil
        }
    }
}

public struct CreateInputOutputResponse: Swift.Equatable {
    /// Information about the configuration of the input.
    public var inputConfiguration: IoTEventsClientTypes.InputConfiguration?

    public init (
        inputConfiguration: IoTEventsClientTypes.InputConfiguration? = nil
    )
    {
        self.inputConfiguration = inputConfiguration
    }
}

struct CreateInputOutputResponseBody: Swift.Equatable {
    let inputConfiguration: IoTEventsClientTypes.InputConfiguration?
}

extension CreateInputOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputConfigurationDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.InputConfiguration.self, forKey: .inputConfiguration)
        inputConfiguration = inputConfigurationDecoded
    }
}

extension DeleteAlarmModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let alarmModelName = alarmModelName else {
            return nil
        }
        return "/alarm-models/\(alarmModelName.urlPercentEncoding())"
    }
}

public struct DeleteAlarmModelInput: Swift.Equatable {
    /// The name of the alarm model.
    /// This member is required.
    public var alarmModelName: Swift.String?

    public init (
        alarmModelName: Swift.String? = nil
    )
    {
        self.alarmModelName = alarmModelName
    }
}

struct DeleteAlarmModelInputBody: Swift.Equatable {
}

extension DeleteAlarmModelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAlarmModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAlarmModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteAlarmModelOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAlarmModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAlarmModelOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteDetectorModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorModelName = detectorModelName else {
            return nil
        }
        return "/detector-models/\(detectorModelName.urlPercentEncoding())"
    }
}

public struct DeleteDetectorModelInput: Swift.Equatable {
    /// The name of the detector model to be deleted.
    /// This member is required.
    public var detectorModelName: Swift.String?

    public init (
        detectorModelName: Swift.String? = nil
    )
    {
        self.detectorModelName = detectorModelName
    }
}

struct DeleteDetectorModelInputBody: Swift.Equatable {
}

extension DeleteDetectorModelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDetectorModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDetectorModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteDetectorModelOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDetectorModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDetectorModelOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteInputInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let inputName = inputName else {
            return nil
        }
        return "/inputs/\(inputName.urlPercentEncoding())"
    }
}

public struct DeleteInputInput: Swift.Equatable {
    /// The name of the input to delete.
    /// This member is required.
    public var inputName: Swift.String?

    public init (
        inputName: Swift.String? = nil
    )
    {
        self.inputName = inputName
    }
}

struct DeleteInputInputBody: Swift.Equatable {
}

extension DeleteInputInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteInputOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteInputOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteInputOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteInputOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteInputOutputResponse: Swift.Equatable {

    public init () { }
}

extension DescribeAlarmModelInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let alarmModelVersion = alarmModelVersion {
                let alarmModelVersionQueryItem = ClientRuntime.URLQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(alarmModelVersion).urlPercentEncoding())
                items.append(alarmModelVersionQueryItem)
            }
            return items
        }
    }
}

extension DescribeAlarmModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let alarmModelName = alarmModelName else {
            return nil
        }
        return "/alarm-models/\(alarmModelName.urlPercentEncoding())"
    }
}

public struct DescribeAlarmModelInput: Swift.Equatable {
    /// The name of the alarm model.
    /// This member is required.
    public var alarmModelName: Swift.String?
    /// The version of the alarm model.
    public var alarmModelVersion: Swift.String?

    public init (
        alarmModelName: Swift.String? = nil,
        alarmModelVersion: Swift.String? = nil
    )
    {
        self.alarmModelName = alarmModelName
        self.alarmModelVersion = alarmModelVersion
    }
}

struct DescribeAlarmModelInputBody: Swift.Equatable {
}

extension DescribeAlarmModelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAlarmModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAlarmModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeAlarmModelOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAlarmModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeAlarmModelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alarmCapabilities = output.alarmCapabilities
            self.alarmEventActions = output.alarmEventActions
            self.alarmModelArn = output.alarmModelArn
            self.alarmModelDescription = output.alarmModelDescription
            self.alarmModelName = output.alarmModelName
            self.alarmModelVersion = output.alarmModelVersion
            self.alarmNotification = output.alarmNotification
            self.alarmRule = output.alarmRule
            self.creationTime = output.creationTime
            self.key = output.key
            self.lastUpdateTime = output.lastUpdateTime
            self.roleArn = output.roleArn
            self.severity = output.severity
            self.status = output.status
            self.statusMessage = output.statusMessage
        } else {
            self.alarmCapabilities = nil
            self.alarmEventActions = nil
            self.alarmModelArn = nil
            self.alarmModelDescription = nil
            self.alarmModelName = nil
            self.alarmModelVersion = nil
            self.alarmNotification = nil
            self.alarmRule = nil
            self.creationTime = nil
            self.key = nil
            self.lastUpdateTime = nil
            self.roleArn = nil
            self.severity = nil
            self.status = nil
            self.statusMessage = nil
        }
    }
}

public struct DescribeAlarmModelOutputResponse: Swift.Equatable {
    /// Contains the configuration information of alarm state changes.
    public var alarmCapabilities: IoTEventsClientTypes.AlarmCapabilities?
    /// Contains information about one or more alarm actions.
    public var alarmEventActions: IoTEventsClientTypes.AlarmEventActions?
    /// The ARN of the alarm model. For more information, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    public var alarmModelArn: Swift.String?
    /// The description of the alarm model.
    public var alarmModelDescription: Swift.String?
    /// The name of the alarm model.
    public var alarmModelName: Swift.String?
    /// The version of the alarm model.
    public var alarmModelVersion: Swift.String?
    /// Contains information about one or more notification actions.
    public var alarmNotification: IoTEventsClientTypes.AlarmNotification?
    /// Defines when your alarm is invoked.
    public var alarmRule: IoTEventsClientTypes.AlarmRule?
    /// The time the alarm model was created, in the Unix epoch format.
    public var creationTime: ClientRuntime.Date?
    /// An input attribute used as a key to create an alarm. AWS IoT Events routes [inputs](https://docs.aws.amazon.com/iotevents/latest/apireference/API_Input.html) associated with this key to the alarm.
    public var key: Swift.String?
    /// The time the alarm model was last updated, in the Unix epoch format.
    public var lastUpdateTime: ClientRuntime.Date?
    /// The ARN of the IAM role that allows the alarm to perform actions and access AWS resources. For more information, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    public var roleArn: Swift.String?
    /// A non-negative integer that reflects the severity level of the alarm.
    public var severity: Swift.Int?
    /// The status of the alarm model. The status can be one of the following values:
    ///
    /// * ACTIVE - The alarm model is active and it's ready to evaluate data.
    ///
    /// * ACTIVATING - AWS IoT Events is activating your alarm model. Activating an alarm model can take up to a few minutes.
    ///
    /// * INACTIVE - The alarm model is inactive, so it isn't ready to evaluate data. Check your alarm model information and update the alarm model.
    ///
    /// * FAILED - You couldn't create or update the alarm model. Check your alarm model information and try again.
    public var status: IoTEventsClientTypes.AlarmModelVersionStatus?
    /// Contains information about the status of the alarm model.
    public var statusMessage: Swift.String?

    public init (
        alarmCapabilities: IoTEventsClientTypes.AlarmCapabilities? = nil,
        alarmEventActions: IoTEventsClientTypes.AlarmEventActions? = nil,
        alarmModelArn: Swift.String? = nil,
        alarmModelDescription: Swift.String? = nil,
        alarmModelName: Swift.String? = nil,
        alarmModelVersion: Swift.String? = nil,
        alarmNotification: IoTEventsClientTypes.AlarmNotification? = nil,
        alarmRule: IoTEventsClientTypes.AlarmRule? = nil,
        creationTime: ClientRuntime.Date? = nil,
        key: Swift.String? = nil,
        lastUpdateTime: ClientRuntime.Date? = nil,
        roleArn: Swift.String? = nil,
        severity: Swift.Int? = nil,
        status: IoTEventsClientTypes.AlarmModelVersionStatus? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.alarmCapabilities = alarmCapabilities
        self.alarmEventActions = alarmEventActions
        self.alarmModelArn = alarmModelArn
        self.alarmModelDescription = alarmModelDescription
        self.alarmModelName = alarmModelName
        self.alarmModelVersion = alarmModelVersion
        self.alarmNotification = alarmNotification
        self.alarmRule = alarmRule
        self.creationTime = creationTime
        self.key = key
        self.lastUpdateTime = lastUpdateTime
        self.roleArn = roleArn
        self.severity = severity
        self.status = status
        self.statusMessage = statusMessage
    }
}

struct DescribeAlarmModelOutputResponseBody: Swift.Equatable {
    let creationTime: ClientRuntime.Date?
    let alarmModelArn: Swift.String?
    let alarmModelVersion: Swift.String?
    let lastUpdateTime: ClientRuntime.Date?
    let status: IoTEventsClientTypes.AlarmModelVersionStatus?
    let statusMessage: Swift.String?
    let alarmModelName: Swift.String?
    let alarmModelDescription: Swift.String?
    let roleArn: Swift.String?
    let key: Swift.String?
    let severity: Swift.Int?
    let alarmRule: IoTEventsClientTypes.AlarmRule?
    let alarmNotification: IoTEventsClientTypes.AlarmNotification?
    let alarmEventActions: IoTEventsClientTypes.AlarmEventActions?
    let alarmCapabilities: IoTEventsClientTypes.AlarmCapabilities?
}

extension DescribeAlarmModelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmCapabilities
        case alarmEventActions
        case alarmModelArn
        case alarmModelDescription
        case alarmModelName
        case alarmModelVersion
        case alarmNotification
        case alarmRule
        case creationTime
        case key
        case lastUpdateTime
        case roleArn
        case severity
        case status
        case statusMessage
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let alarmModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelArn)
        alarmModelArn = alarmModelArnDecoded
        let alarmModelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelVersion)
        alarmModelVersion = alarmModelVersionDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.AlarmModelVersionStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let alarmModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelName)
        alarmModelName = alarmModelNameDecoded
        let alarmModelDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelDescription)
        alarmModelDescription = alarmModelDescriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let severityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .severity)
        severity = severityDecoded
        let alarmRuleDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.AlarmRule.self, forKey: .alarmRule)
        alarmRule = alarmRuleDecoded
        let alarmNotificationDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.AlarmNotification.self, forKey: .alarmNotification)
        alarmNotification = alarmNotificationDecoded
        let alarmEventActionsDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.AlarmEventActions.self, forKey: .alarmEventActions)
        alarmEventActions = alarmEventActionsDecoded
        let alarmCapabilitiesDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.AlarmCapabilities.self, forKey: .alarmCapabilities)
        alarmCapabilities = alarmCapabilitiesDecoded
    }
}

extension DescribeDetectorModelAnalysisInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let analysisId = analysisId else {
            return nil
        }
        return "/analysis/detector-models/\(analysisId.urlPercentEncoding())"
    }
}

public struct DescribeDetectorModelAnalysisInput: Swift.Equatable {
    /// The ID of the analysis result that you want to retrieve.
    /// This member is required.
    public var analysisId: Swift.String?

    public init (
        analysisId: Swift.String? = nil
    )
    {
        self.analysisId = analysisId
    }
}

struct DescribeDetectorModelAnalysisInputBody: Swift.Equatable {
}

extension DescribeDetectorModelAnalysisInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDetectorModelAnalysisOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDetectorModelAnalysisOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeDetectorModelAnalysisOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDetectorModelAnalysisOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeDetectorModelAnalysisOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct DescribeDetectorModelAnalysisOutputResponse: Swift.Equatable {
    /// The status of the analysis activity. The status can be one of the following values:
    ///
    /// * RUNNING - AWS IoT Events is analyzing your detector model. This process can take several minutes to complete.
    ///
    /// * COMPLETE - AWS IoT Events finished analyzing your detector model.
    ///
    /// * FAILED - AWS IoT Events couldn't analyze your detector model. Try again later.
    public var status: IoTEventsClientTypes.AnalysisStatus?

    public init (
        status: IoTEventsClientTypes.AnalysisStatus? = nil
    )
    {
        self.status = status
    }
}

struct DescribeDetectorModelAnalysisOutputResponseBody: Swift.Equatable {
    let status: IoTEventsClientTypes.AnalysisStatus?
}

extension DescribeDetectorModelAnalysisOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.AnalysisStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DescribeDetectorModelInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let detectorModelVersion = detectorModelVersion {
                let detectorModelVersionQueryItem = ClientRuntime.URLQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(detectorModelVersion).urlPercentEncoding())
                items.append(detectorModelVersionQueryItem)
            }
            return items
        }
    }
}

extension DescribeDetectorModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorModelName = detectorModelName else {
            return nil
        }
        return "/detector-models/\(detectorModelName.urlPercentEncoding())"
    }
}

public struct DescribeDetectorModelInput: Swift.Equatable {
    /// The name of the detector model.
    /// This member is required.
    public var detectorModelName: Swift.String?
    /// The version of the detector model.
    public var detectorModelVersion: Swift.String?

    public init (
        detectorModelName: Swift.String? = nil,
        detectorModelVersion: Swift.String? = nil
    )
    {
        self.detectorModelName = detectorModelName
        self.detectorModelVersion = detectorModelVersion
    }
}

struct DescribeDetectorModelInputBody: Swift.Equatable {
}

extension DescribeDetectorModelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDetectorModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDetectorModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeDetectorModelOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDetectorModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeDetectorModelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.detectorModel = output.detectorModel
        } else {
            self.detectorModel = nil
        }
    }
}

public struct DescribeDetectorModelOutputResponse: Swift.Equatable {
    /// Information about the detector model.
    public var detectorModel: IoTEventsClientTypes.DetectorModel?

    public init (
        detectorModel: IoTEventsClientTypes.DetectorModel? = nil
    )
    {
        self.detectorModel = detectorModel
    }
}

struct DescribeDetectorModelOutputResponseBody: Swift.Equatable {
    let detectorModel: IoTEventsClientTypes.DetectorModel?
}

extension DescribeDetectorModelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorModel
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.DetectorModel.self, forKey: .detectorModel)
        detectorModel = detectorModelDecoded
    }
}

extension DescribeInputInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let inputName = inputName else {
            return nil
        }
        return "/inputs/\(inputName.urlPercentEncoding())"
    }
}

public struct DescribeInputInput: Swift.Equatable {
    /// The name of the input.
    /// This member is required.
    public var inputName: Swift.String?

    public init (
        inputName: Swift.String? = nil
    )
    {
        self.inputName = inputName
    }
}

struct DescribeInputInputBody: Swift.Equatable {
}

extension DescribeInputInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeInputOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeInputOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeInputOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInputOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeInputOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.input = output.input
        } else {
            self.input = nil
        }
    }
}

public struct DescribeInputOutputResponse: Swift.Equatable {
    /// Information about the input.
    public var input: IoTEventsClientTypes.Input?

    public init (
        input: IoTEventsClientTypes.Input? = nil
    )
    {
        self.input = input
    }
}

struct DescribeInputOutputResponseBody: Swift.Equatable {
    let input: IoTEventsClientTypes.Input?
}

extension DescribeInputOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case input
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.Input.self, forKey: .input)
        input = inputDecoded
    }
}

extension DescribeLoggingOptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/logging"
    }
}

public struct DescribeLoggingOptionsInput: Swift.Equatable {

    public init () { }
}

struct DescribeLoggingOptionsInputBody: Swift.Equatable {
}

extension DescribeLoggingOptionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeLoggingOptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeLoggingOptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeLoggingOptionsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLoggingOptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeLoggingOptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.loggingOptions = output.loggingOptions
        } else {
            self.loggingOptions = nil
        }
    }
}

public struct DescribeLoggingOptionsOutputResponse: Swift.Equatable {
    /// The current settings of the AWS IoT Events logging options.
    public var loggingOptions: IoTEventsClientTypes.LoggingOptions?

    public init (
        loggingOptions: IoTEventsClientTypes.LoggingOptions? = nil
    )
    {
        self.loggingOptions = loggingOptions
    }
}

struct DescribeLoggingOptionsOutputResponseBody: Swift.Equatable {
    let loggingOptions: IoTEventsClientTypes.LoggingOptions?
}

extension DescribeLoggingOptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingOptions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingOptionsDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.LoggingOptions.self, forKey: .loggingOptions)
        loggingOptions = loggingOptionsDecoded
    }
}

extension IoTEventsClientTypes.DetectorDebugOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorModelName
        case keyValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorModelName = self.detectorModelName {
            try encodeContainer.encode(detectorModelName, forKey: .detectorModelName)
        }
        if let keyValue = self.keyValue {
            try encodeContainer.encode(keyValue, forKey: .keyValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorModelName)
        detectorModelName = detectorModelNameDecoded
        let keyValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyValue)
        keyValue = keyValueDecoded
    }
}

extension IoTEventsClientTypes {
    /// The detector model and the specific detectors (instances) for which the logging level is given.
    public struct DetectorDebugOption: Swift.Equatable {
        /// The name of the detector model.
        /// This member is required.
        public var detectorModelName: Swift.String?
        /// The value of the input attribute key used to create the detector (the instance of the detector model).
        public var keyValue: Swift.String?

        public init (
            detectorModelName: Swift.String? = nil,
            keyValue: Swift.String? = nil
        )
        {
            self.detectorModelName = detectorModelName
            self.keyValue = keyValue
        }
    }

}

extension IoTEventsClientTypes.DetectorModel: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorModelConfiguration
        case detectorModelDefinition
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorModelConfiguration = self.detectorModelConfiguration {
            try encodeContainer.encode(detectorModelConfiguration, forKey: .detectorModelConfiguration)
        }
        if let detectorModelDefinition = self.detectorModelDefinition {
            try encodeContainer.encode(detectorModelDefinition, forKey: .detectorModelDefinition)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelDefinitionDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.DetectorModelDefinition.self, forKey: .detectorModelDefinition)
        detectorModelDefinition = detectorModelDefinitionDecoded
        let detectorModelConfigurationDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.DetectorModelConfiguration.self, forKey: .detectorModelConfiguration)
        detectorModelConfiguration = detectorModelConfigurationDecoded
    }
}

extension IoTEventsClientTypes {
    /// Information about the detector model.
    public struct DetectorModel: Swift.Equatable {
        /// Information about how the detector is configured.
        public var detectorModelConfiguration: IoTEventsClientTypes.DetectorModelConfiguration?
        /// Information that defines how a detector operates.
        public var detectorModelDefinition: IoTEventsClientTypes.DetectorModelDefinition?

        public init (
            detectorModelConfiguration: IoTEventsClientTypes.DetectorModelConfiguration? = nil,
            detectorModelDefinition: IoTEventsClientTypes.DetectorModelDefinition? = nil
        )
        {
            self.detectorModelConfiguration = detectorModelConfiguration
            self.detectorModelDefinition = detectorModelDefinition
        }
    }

}

extension IoTEventsClientTypes.DetectorModelConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case detectorModelArn
        case detectorModelDescription
        case detectorModelName
        case detectorModelVersion
        case evaluationMethod
        case key
        case lastUpdateTime
        case roleArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let detectorModelArn = self.detectorModelArn {
            try encodeContainer.encode(detectorModelArn, forKey: .detectorModelArn)
        }
        if let detectorModelDescription = self.detectorModelDescription {
            try encodeContainer.encode(detectorModelDescription, forKey: .detectorModelDescription)
        }
        if let detectorModelName = self.detectorModelName {
            try encodeContainer.encode(detectorModelName, forKey: .detectorModelName)
        }
        if let detectorModelVersion = self.detectorModelVersion {
            try encodeContainer.encode(detectorModelVersion, forKey: .detectorModelVersion)
        }
        if let evaluationMethod = self.evaluationMethod {
            try encodeContainer.encode(evaluationMethod.rawValue, forKey: .evaluationMethod)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let lastUpdateTime = self.lastUpdateTime {
            try encodeContainer.encodeTimestamp(lastUpdateTime, format: .epochSeconds, forKey: .lastUpdateTime)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorModelName)
        detectorModelName = detectorModelNameDecoded
        let detectorModelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorModelVersion)
        detectorModelVersion = detectorModelVersionDecoded
        let detectorModelDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorModelDescription)
        detectorModelDescription = detectorModelDescriptionDecoded
        let detectorModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorModelArn)
        detectorModelArn = detectorModelArnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.DetectorModelVersionStatus.self, forKey: .status)
        status = statusDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let evaluationMethodDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.EvaluationMethod.self, forKey: .evaluationMethod)
        evaluationMethod = evaluationMethodDecoded
    }
}

extension IoTEventsClientTypes {
    /// Information about how the detector model is configured.
    public struct DetectorModelConfiguration: Swift.Equatable {
        /// The time the detector model was created.
        public var creationTime: ClientRuntime.Date?
        /// The ARN of the detector model.
        public var detectorModelArn: Swift.String?
        /// A brief description of the detector model.
        public var detectorModelDescription: Swift.String?
        /// The name of the detector model.
        public var detectorModelName: Swift.String?
        /// The version of the detector model.
        public var detectorModelVersion: Swift.String?
        /// Information about the order in which events are evaluated and how actions are executed.
        public var evaluationMethod: IoTEventsClientTypes.EvaluationMethod?
        /// The value used to identify a detector instance. When a device or system sends input, a new detector instance with a unique key value is created. AWS IoT Events can continue to route input to its corresponding detector instance based on this identifying information. This parameter uses a JSON-path expression to select the attribute-value pair in the message payload that is used for identification. To route the message to the correct detector instance, the device must send a message payload that contains the same attribute-value.
        public var key: Swift.String?
        /// The time the detector model was last updated.
        public var lastUpdateTime: ClientRuntime.Date?
        /// The ARN of the role that grants permission to AWS IoT Events to perform its operations.
        public var roleArn: Swift.String?
        /// The status of the detector model.
        public var status: IoTEventsClientTypes.DetectorModelVersionStatus?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            detectorModelArn: Swift.String? = nil,
            detectorModelDescription: Swift.String? = nil,
            detectorModelName: Swift.String? = nil,
            detectorModelVersion: Swift.String? = nil,
            evaluationMethod: IoTEventsClientTypes.EvaluationMethod? = nil,
            key: Swift.String? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            roleArn: Swift.String? = nil,
            status: IoTEventsClientTypes.DetectorModelVersionStatus? = nil
        )
        {
            self.creationTime = creationTime
            self.detectorModelArn = detectorModelArn
            self.detectorModelDescription = detectorModelDescription
            self.detectorModelName = detectorModelName
            self.detectorModelVersion = detectorModelVersion
            self.evaluationMethod = evaluationMethod
            self.key = key
            self.lastUpdateTime = lastUpdateTime
            self.roleArn = roleArn
            self.status = status
        }
    }

}

extension IoTEventsClientTypes.DetectorModelDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialStateName
        case states
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initialStateName = self.initialStateName {
            try encodeContainer.encode(initialStateName, forKey: .initialStateName)
        }
        if let states = states {
            var statesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .states)
            for state0 in states {
                try statesContainer.encode(state0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statesContainer = try containerValues.decodeIfPresent([IoTEventsClientTypes.State?].self, forKey: .states)
        var statesDecoded0:[IoTEventsClientTypes.State]? = nil
        if let statesContainer = statesContainer {
            statesDecoded0 = [IoTEventsClientTypes.State]()
            for structure0 in statesContainer {
                if let structure0 = structure0 {
                    statesDecoded0?.append(structure0)
                }
            }
        }
        states = statesDecoded0
        let initialStateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initialStateName)
        initialStateName = initialStateNameDecoded
    }
}

extension IoTEventsClientTypes {
    /// Information that defines how a detector operates.
    public struct DetectorModelDefinition: Swift.Equatable {
        /// The state that is entered at the creation of each detector (instance).
        /// This member is required.
        public var initialStateName: Swift.String?
        /// Information about the states of the detector.
        /// This member is required.
        public var states: [IoTEventsClientTypes.State]?

        public init (
            initialStateName: Swift.String? = nil,
            states: [IoTEventsClientTypes.State]? = nil
        )
        {
            self.initialStateName = initialStateName
            self.states = states
        }
    }

}

extension IoTEventsClientTypes.DetectorModelSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case detectorModelDescription
        case detectorModelName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let detectorModelDescription = self.detectorModelDescription {
            try encodeContainer.encode(detectorModelDescription, forKey: .detectorModelDescription)
        }
        if let detectorModelName = self.detectorModelName {
            try encodeContainer.encode(detectorModelName, forKey: .detectorModelName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorModelName)
        detectorModelName = detectorModelNameDecoded
        let detectorModelDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorModelDescription)
        detectorModelDescription = detectorModelDescriptionDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension IoTEventsClientTypes {
    /// Information about the detector model.
    public struct DetectorModelSummary: Swift.Equatable {
        /// The time the detector model was created.
        public var creationTime: ClientRuntime.Date?
        /// A brief description of the detector model.
        public var detectorModelDescription: Swift.String?
        /// The name of the detector model.
        public var detectorModelName: Swift.String?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            detectorModelDescription: Swift.String? = nil,
            detectorModelName: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.detectorModelDescription = detectorModelDescription
            self.detectorModelName = detectorModelName
        }
    }

}

extension IoTEventsClientTypes {
    public enum DetectorModelVersionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activating
        case active
        case deprecated
        case draft
        case failed
        case inactive
        case paused
        case sdkUnknown(Swift.String)

        public static var allCases: [DetectorModelVersionStatus] {
            return [
                .activating,
                .active,
                .deprecated,
                .draft,
                .failed,
                .inactive,
                .paused,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activating: return "ACTIVATING"
            case .active: return "ACTIVE"
            case .deprecated: return "DEPRECATED"
            case .draft: return "DRAFT"
            case .failed: return "FAILED"
            case .inactive: return "INACTIVE"
            case .paused: return "PAUSED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DetectorModelVersionStatus(rawValue: rawValue) ?? DetectorModelVersionStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTEventsClientTypes.DetectorModelVersionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case detectorModelArn
        case detectorModelName
        case detectorModelVersion
        case evaluationMethod
        case lastUpdateTime
        case roleArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let detectorModelArn = self.detectorModelArn {
            try encodeContainer.encode(detectorModelArn, forKey: .detectorModelArn)
        }
        if let detectorModelName = self.detectorModelName {
            try encodeContainer.encode(detectorModelName, forKey: .detectorModelName)
        }
        if let detectorModelVersion = self.detectorModelVersion {
            try encodeContainer.encode(detectorModelVersion, forKey: .detectorModelVersion)
        }
        if let evaluationMethod = self.evaluationMethod {
            try encodeContainer.encode(evaluationMethod.rawValue, forKey: .evaluationMethod)
        }
        if let lastUpdateTime = self.lastUpdateTime {
            try encodeContainer.encodeTimestamp(lastUpdateTime, format: .epochSeconds, forKey: .lastUpdateTime)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorModelName)
        detectorModelName = detectorModelNameDecoded
        let detectorModelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorModelVersion)
        detectorModelVersion = detectorModelVersionDecoded
        let detectorModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorModelArn)
        detectorModelArn = detectorModelArnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.DetectorModelVersionStatus.self, forKey: .status)
        status = statusDecoded
        let evaluationMethodDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.EvaluationMethod.self, forKey: .evaluationMethod)
        evaluationMethod = evaluationMethodDecoded
    }
}

extension IoTEventsClientTypes {
    /// Information about the detector model version.
    public struct DetectorModelVersionSummary: Swift.Equatable {
        /// The time the detector model version was created.
        public var creationTime: ClientRuntime.Date?
        /// The ARN of the detector model version.
        public var detectorModelArn: Swift.String?
        /// The name of the detector model.
        public var detectorModelName: Swift.String?
        /// The ID of the detector model version.
        public var detectorModelVersion: Swift.String?
        /// Information about the order in which events are evaluated and how actions are executed.
        public var evaluationMethod: IoTEventsClientTypes.EvaluationMethod?
        /// The last time the detector model version was updated.
        public var lastUpdateTime: ClientRuntime.Date?
        /// The ARN of the role that grants the detector model permission to perform its tasks.
        public var roleArn: Swift.String?
        /// The status of the detector model version.
        public var status: IoTEventsClientTypes.DetectorModelVersionStatus?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            detectorModelArn: Swift.String? = nil,
            detectorModelName: Swift.String? = nil,
            detectorModelVersion: Swift.String? = nil,
            evaluationMethod: IoTEventsClientTypes.EvaluationMethod? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            roleArn: Swift.String? = nil,
            status: IoTEventsClientTypes.DetectorModelVersionStatus? = nil
        )
        {
            self.creationTime = creationTime
            self.detectorModelArn = detectorModelArn
            self.detectorModelName = detectorModelName
            self.detectorModelVersion = detectorModelVersion
            self.evaluationMethod = evaluationMethod
            self.lastUpdateTime = lastUpdateTime
            self.roleArn = roleArn
            self.status = status
        }
    }

}

extension IoTEventsClientTypes.DynamoDBAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hashKeyField
        case hashKeyType
        case hashKeyValue
        case operation
        case payload
        case payloadField
        case rangeKeyField
        case rangeKeyType
        case rangeKeyValue
        case tableName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hashKeyField = self.hashKeyField {
            try encodeContainer.encode(hashKeyField, forKey: .hashKeyField)
        }
        if let hashKeyType = self.hashKeyType {
            try encodeContainer.encode(hashKeyType, forKey: .hashKeyType)
        }
        if let hashKeyValue = self.hashKeyValue {
            try encodeContainer.encode(hashKeyValue, forKey: .hashKeyValue)
        }
        if let operation = self.operation {
            try encodeContainer.encode(operation, forKey: .operation)
        }
        if let payload = self.payload {
            try encodeContainer.encode(payload, forKey: .payload)
        }
        if let payloadField = self.payloadField {
            try encodeContainer.encode(payloadField, forKey: .payloadField)
        }
        if let rangeKeyField = self.rangeKeyField {
            try encodeContainer.encode(rangeKeyField, forKey: .rangeKeyField)
        }
        if let rangeKeyType = self.rangeKeyType {
            try encodeContainer.encode(rangeKeyType, forKey: .rangeKeyType)
        }
        if let rangeKeyValue = self.rangeKeyValue {
            try encodeContainer.encode(rangeKeyValue, forKey: .rangeKeyValue)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hashKeyTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hashKeyType)
        hashKeyType = hashKeyTypeDecoded
        let hashKeyFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hashKeyField)
        hashKeyField = hashKeyFieldDecoded
        let hashKeyValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hashKeyValue)
        hashKeyValue = hashKeyValueDecoded
        let rangeKeyTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rangeKeyType)
        rangeKeyType = rangeKeyTypeDecoded
        let rangeKeyFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rangeKeyField)
        rangeKeyField = rangeKeyFieldDecoded
        let rangeKeyValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rangeKeyValue)
        rangeKeyValue = rangeKeyValueDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let payloadFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .payloadField)
        payloadField = payloadFieldDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.Payload.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension IoTEventsClientTypes {
    /// Defines an action to write to the Amazon DynamoDB table that you created. The standard action payload contains all the information about the detector model instance and the event that triggered the action. You can customize the [payload](https://docs.aws.amazon.com/iotevents/latest/apireference/API_Payload.html). One column of the DynamoDB table receives all attribute-value pairs in the payload that you specify. You must use expressions for all parameters in DynamoDBAction. The expressions accept literals, operators, functions, references, and substitution templates. Examples
    ///
    /// * For literal values, the expressions must contain single quotes. For example, the value for the hashKeyType parameter can be 'STRING'.
    ///
    /// * For references, you must specify either variables or input values. For example, the value for the hashKeyField parameter can be $input.GreenhouseInput.name.
    ///
    /// * For a substitution template, you must use ${}, and the template must be in single quotes. A substitution template can also contain a combination of literals, operators, functions, references, and substitution templates. In the following example, the value for the hashKeyValue parameter uses a substitution template. '${$input.GreenhouseInput.temperature * 6 / 5 + 32} in Fahrenheit'
    ///
    /// * For a string concatenation, you must use +. A string concatenation can also contain a combination of literals, operators, functions, references, and substitution templates. In the following example, the value for the tableName parameter uses a string concatenation. 'GreenhouseTemperatureTable ' + $input.GreenhouseInput.date
    ///
    ///
    /// For more information, see [Expressions](https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html) in the AWS IoT Events Developer Guide. If the defined payload type is a string, DynamoDBAction writes non-JSON data to the DynamoDB table as binary data. The DynamoDB console displays the data as Base64-encoded text. The value for the payloadField parameter is _raw.
    public struct DynamoDBAction: Swift.Equatable {
        /// The name of the hash key (also called the partition key). The hashKeyField value must match the partition key of the target DynamoDB table.
        /// This member is required.
        public var hashKeyField: Swift.String?
        /// The data type for the hash key (also called the partition key). You can specify the following values:
        ///
        /// * 'STRING' - The hash key is a string.
        ///
        /// * 'NUMBER' - The hash key is a number.
        ///
        ///
        /// If you don't specify hashKeyType, the default value is 'STRING'.
        public var hashKeyType: Swift.String?
        /// The value of the hash key (also called the partition key).
        /// This member is required.
        public var hashKeyValue: Swift.String?
        /// The type of operation to perform. You can specify the following values:
        ///
        /// * 'INSERT' - Insert data as a new item into the DynamoDB table. This item uses the specified hash key as a partition key. If you specified a range key, the item uses the range key as a sort key.
        ///
        /// * 'UPDATE' - Update an existing item of the DynamoDB table with new data. This item's partition key must match the specified hash key. If you specified a range key, the range key must match the item's sort key.
        ///
        /// * 'DELETE' - Delete an existing item of the DynamoDB table. This item's partition key must match the specified hash key. If you specified a range key, the range key must match the item's sort key.
        ///
        ///
        /// If you don't specify this parameter, AWS IoT Events triggers the 'INSERT' operation.
        public var operation: Swift.String?
        /// Information needed to configure the payload. By default, AWS IoT Events generates a standard payload in JSON for any action. This action payload contains all attribute-value pairs that have the information about the detector model instance and the event triggered the action. To configure the action payload, you can use contentExpression.
        public var payload: IoTEventsClientTypes.Payload?
        /// The name of the DynamoDB column that receives the action payload. If you don't specify this parameter, the name of the DynamoDB column is payload.
        public var payloadField: Swift.String?
        /// The name of the range key (also called the sort key). The rangeKeyField value must match the sort key of the target DynamoDB table.
        public var rangeKeyField: Swift.String?
        /// The data type for the range key (also called the sort key), You can specify the following values:
        ///
        /// * 'STRING' - The range key is a string.
        ///
        /// * 'NUMBER' - The range key is number.
        ///
        ///
        /// If you don't specify rangeKeyField, the default value is 'STRING'.
        public var rangeKeyType: Swift.String?
        /// The value of the range key (also called the sort key).
        public var rangeKeyValue: Swift.String?
        /// The name of the DynamoDB table. The tableName value must match the table name of the target DynamoDB table.
        /// This member is required.
        public var tableName: Swift.String?

        public init (
            hashKeyField: Swift.String? = nil,
            hashKeyType: Swift.String? = nil,
            hashKeyValue: Swift.String? = nil,
            operation: Swift.String? = nil,
            payload: IoTEventsClientTypes.Payload? = nil,
            payloadField: Swift.String? = nil,
            rangeKeyField: Swift.String? = nil,
            rangeKeyType: Swift.String? = nil,
            rangeKeyValue: Swift.String? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.hashKeyField = hashKeyField
            self.hashKeyType = hashKeyType
            self.hashKeyValue = hashKeyValue
            self.operation = operation
            self.payload = payload
            self.payloadField = payloadField
            self.rangeKeyField = rangeKeyField
            self.rangeKeyType = rangeKeyType
            self.rangeKeyValue = rangeKeyValue
            self.tableName = tableName
        }
    }

}

extension IoTEventsClientTypes.DynamoDBv2Action: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload
        case tableName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let payload = self.payload {
            try encodeContainer.encode(payload, forKey: .payload)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.Payload.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension IoTEventsClientTypes {
    /// Defines an action to write to the Amazon DynamoDB table that you created. The default action payload contains all the information about the detector model instance and the event that triggered the action. You can customize the [payload](https://docs.aws.amazon.com/iotevents/latest/apireference/API_Payload.html). A separate column of the DynamoDB table receives one attribute-value pair in the payload that you specify. You must use expressions for all parameters in DynamoDBv2Action. The expressions accept literals, operators, functions, references, and substitution templates. Examples
    ///
    /// * For literal values, the expressions must contain single quotes. For example, the value for the tableName parameter can be 'GreenhouseTemperatureTable'.
    ///
    /// * For references, you must specify either variables or input values. For example, the value for the tableName parameter can be $variable.ddbtableName.
    ///
    /// * For a substitution template, you must use ${}, and the template must be in single quotes. A substitution template can also contain a combination of literals, operators, functions, references, and substitution templates. In the following example, the value for the contentExpression parameter in Payload uses a substitution template. '{\"sensorID\": \"${$input.GreenhouseInput.sensor_id}\", \"temperature\": \"${$input.GreenhouseInput.temperature * 9 / 5 + 32}\"}'
    ///
    /// * For a string concatenation, you must use +. A string concatenation can also contain a combination of literals, operators, functions, references, and substitution templates. In the following example, the value for the tableName parameter uses a string concatenation. 'GreenhouseTemperatureTable ' + $input.GreenhouseInput.date
    ///
    ///
    /// For more information, see [Expressions](https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html) in the AWS IoT Events Developer Guide. The value for the type parameter in Payload must be JSON.
    public struct DynamoDBv2Action: Swift.Equatable {
        /// Information needed to configure the payload. By default, AWS IoT Events generates a standard payload in JSON for any action. This action payload contains all attribute-value pairs that have the information about the detector model instance and the event triggered the action. To configure the action payload, you can use contentExpression.
        public var payload: IoTEventsClientTypes.Payload?
        /// The name of the DynamoDB table.
        /// This member is required.
        public var tableName: Swift.String?

        public init (
            payload: IoTEventsClientTypes.Payload? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.payload = payload
            self.tableName = tableName
        }
    }

}

extension IoTEventsClientTypes.EmailConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
        case from
        case recipients
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let from = self.from {
            try encodeContainer.encode(from, forKey: .from)
        }
        if let recipients = self.recipients {
            try encodeContainer.encode(recipients, forKey: .recipients)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .from)
        from = fromDecoded
        let contentDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.EmailContent.self, forKey: .content)
        content = contentDecoded
        let recipientsDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.EmailRecipients.self, forKey: .recipients)
        recipients = recipientsDecoded
    }
}

extension IoTEventsClientTypes {
    /// Contains the configuration information of email notifications.
    public struct EmailConfiguration: Swift.Equatable {
        /// Contains the subject and message of an email.
        public var content: IoTEventsClientTypes.EmailContent?
        /// The email address that sends emails. If you use the AWS IoT Events managed AWS Lambda function to manage your emails, you must [verify the email address that sends emails in Amazon SES](https://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-email-addresses.html).
        /// This member is required.
        public var from: Swift.String?
        /// Contains the information of one or more recipients who receive the emails. You must [add the users that receive emails to your AWS SSO store](https://docs.aws.amazon.com/singlesignon/latest/userguide/addusers.html).
        /// This member is required.
        public var recipients: IoTEventsClientTypes.EmailRecipients?

        public init (
            content: IoTEventsClientTypes.EmailContent? = nil,
            from: Swift.String? = nil,
            recipients: IoTEventsClientTypes.EmailRecipients? = nil
        )
        {
            self.content = content
            self.from = from
            self.recipients = recipients
        }
    }

}

extension IoTEventsClientTypes.EmailContent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalMessage
        case subject
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalMessage = self.additionalMessage {
            try encodeContainer.encode(additionalMessage, forKey: .additionalMessage)
        }
        if let subject = self.subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subject)
        subject = subjectDecoded
        let additionalMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalMessage)
        additionalMessage = additionalMessageDecoded
    }
}

extension IoTEventsClientTypes {
    /// Contains the subject and message of an email.
    public struct EmailContent: Swift.Equatable {
        /// The message that you want to send. The message can be up to 200 characters.
        public var additionalMessage: Swift.String?
        /// The subject of the email.
        public var subject: Swift.String?

        public init (
            additionalMessage: Swift.String? = nil,
            subject: Swift.String? = nil
        )
        {
            self.additionalMessage = additionalMessage
            self.subject = subject
        }
    }

}

extension IoTEventsClientTypes.EmailRecipients: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case to
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let to = to {
            var toContainer = encodeContainer.nestedUnkeyedContainer(forKey: .to)
            for recipientdetail0 in to {
                try toContainer.encode(recipientdetail0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let toContainer = try containerValues.decodeIfPresent([IoTEventsClientTypes.RecipientDetail?].self, forKey: .to)
        var toDecoded0:[IoTEventsClientTypes.RecipientDetail]? = nil
        if let toContainer = toContainer {
            toDecoded0 = [IoTEventsClientTypes.RecipientDetail]()
            for structure0 in toContainer {
                if let structure0 = structure0 {
                    toDecoded0?.append(structure0)
                }
            }
        }
        to = toDecoded0
    }
}

extension IoTEventsClientTypes {
    /// Contains the information of one or more recipients who receive the emails. You must [add the users that receive emails to your AWS SSO store](https://docs.aws.amazon.com/singlesignon/latest/userguide/addusers.html).
    public struct EmailRecipients: Swift.Equatable {
        /// Specifies one or more recipients who receive the email.
        public var to: [IoTEventsClientTypes.RecipientDetail]?

        public init (
            to: [IoTEventsClientTypes.RecipientDetail]? = nil
        )
        {
            self.to = to
        }
    }

}

extension IoTEventsClientTypes {
    public enum EvaluationMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case batch
        case serial
        case sdkUnknown(Swift.String)

        public static var allCases: [EvaluationMethod] {
            return [
                .batch,
                .serial,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .batch: return "BATCH"
            case .serial: return "SERIAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EvaluationMethod(rawValue: rawValue) ?? EvaluationMethod.sdkUnknown(rawValue)
        }
    }
}

extension IoTEventsClientTypes.Event: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case condition
        case eventName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for action0 in actions {
                try actionsContainer.encode(action0)
            }
        }
        if let condition = self.condition {
            try encodeContainer.encode(condition, forKey: .condition)
        }
        if let eventName = self.eventName {
            try encodeContainer.encode(eventName, forKey: .eventName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventName)
        eventName = eventNameDecoded
        let conditionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .condition)
        condition = conditionDecoded
        let actionsContainer = try containerValues.decodeIfPresent([IoTEventsClientTypes.Action?].self, forKey: .actions)
        var actionsDecoded0:[IoTEventsClientTypes.Action]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [IoTEventsClientTypes.Action]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
    }
}

extension IoTEventsClientTypes {
    /// Specifies the actions to be performed when the condition evaluates to TRUE.
    public struct Event: Swift.Equatable {
        /// The actions to be performed.
        public var actions: [IoTEventsClientTypes.Action]?
        /// Optional. The Boolean expression that, when TRUE, causes the actions to be performed. If not present, the actions are performed (=TRUE). If the expression result is not a Boolean value, the actions are not performed (=FALSE).
        public var condition: Swift.String?
        /// The name of the event.
        /// This member is required.
        public var eventName: Swift.String?

        public init (
            actions: [IoTEventsClientTypes.Action]? = nil,
            condition: Swift.String? = nil,
            eventName: Swift.String? = nil
        )
        {
            self.actions = actions
            self.condition = condition
            self.eventName = eventName
        }
    }

}

extension IoTEventsClientTypes.FirehoseAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryStreamName
        case payload
        case separator
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryStreamName = self.deliveryStreamName {
            try encodeContainer.encode(deliveryStreamName, forKey: .deliveryStreamName)
        }
        if let payload = self.payload {
            try encodeContainer.encode(payload, forKey: .payload)
        }
        if let separator = self.separator {
            try encodeContainer.encode(separator, forKey: .separator)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryStreamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deliveryStreamName)
        deliveryStreamName = deliveryStreamNameDecoded
        let separatorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .separator)
        separator = separatorDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.Payload.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension IoTEventsClientTypes {
    /// Sends information about the detector model instance and the event that triggered the action to an Amazon Kinesis Data Firehose delivery stream.
    public struct FirehoseAction: Swift.Equatable {
        /// The name of the Kinesis Data Firehose delivery stream where the data is written.
        /// This member is required.
        public var deliveryStreamName: Swift.String?
        /// You can configure the action payload when you send a message to an Amazon Kinesis Data Firehose delivery stream.
        public var payload: IoTEventsClientTypes.Payload?
        /// A character separator that is used to separate records written to the Kinesis Data Firehose delivery stream. Valid values are: '\n' (newline), '\t' (tab), '\r\n' (Windows newline), ',' (comma).
        public var separator: Swift.String?

        public init (
            deliveryStreamName: Swift.String? = nil,
            payload: IoTEventsClientTypes.Payload? = nil,
            separator: Swift.String? = nil
        )
        {
            self.deliveryStreamName = deliveryStreamName
            self.payload = payload
            self.separator = separator
        }
    }

}

extension GetDetectorModelAnalysisResultsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetDetectorModelAnalysisResultsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let analysisId = analysisId else {
            return nil
        }
        return "/analysis/detector-models/\(analysisId.urlPercentEncoding())/results"
    }
}

public struct GetDetectorModelAnalysisResultsInput: Swift.Equatable {
    /// The ID of the analysis result that you want to retrieve.
    /// This member is required.
    public var analysisId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token that you can use to return the next set of results.
    public var nextToken: Swift.String?

    public init (
        analysisId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.analysisId = analysisId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetDetectorModelAnalysisResultsInputBody: Swift.Equatable {
}

extension GetDetectorModelAnalysisResultsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDetectorModelAnalysisResultsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDetectorModelAnalysisResultsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDetectorModelAnalysisResultsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDetectorModelAnalysisResultsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDetectorModelAnalysisResultsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.analysisResults = output.analysisResults
            self.nextToken = output.nextToken
        } else {
            self.analysisResults = nil
            self.nextToken = nil
        }
    }
}

public struct GetDetectorModelAnalysisResultsOutputResponse: Swift.Equatable {
    /// Contains information about one or more analysis results.
    public var analysisResults: [IoTEventsClientTypes.AnalysisResult]?
    /// The token that you can use to return the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        analysisResults: [IoTEventsClientTypes.AnalysisResult]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.analysisResults = analysisResults
        self.nextToken = nextToken
    }
}

struct GetDetectorModelAnalysisResultsOutputResponseBody: Swift.Equatable {
    let analysisResults: [IoTEventsClientTypes.AnalysisResult]?
    let nextToken: Swift.String?
}

extension GetDetectorModelAnalysisResultsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisResultsContainer = try containerValues.decodeIfPresent([IoTEventsClientTypes.AnalysisResult?].self, forKey: .analysisResults)
        var analysisResultsDecoded0:[IoTEventsClientTypes.AnalysisResult]? = nil
        if let analysisResultsContainer = analysisResultsContainer {
            analysisResultsDecoded0 = [IoTEventsClientTypes.AnalysisResult]()
            for structure0 in analysisResultsContainer {
                if let structure0 = structure0 {
                    analysisResultsDecoded0?.append(structure0)
                }
            }
        }
        analysisResults = analysisResultsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension IoTEventsClientTypes.InitializationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabledOnInitialization
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disabledOnInitialization = self.disabledOnInitialization {
            try encodeContainer.encode(disabledOnInitialization, forKey: .disabledOnInitialization)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let disabledOnInitializationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabledOnInitialization)
        disabledOnInitialization = disabledOnInitializationDecoded
    }
}

extension IoTEventsClientTypes {
    /// Specifies the default alarm state. The configuration applies to all alarms that were created based on this alarm model.
    public struct InitializationConfiguration: Swift.Equatable {
        /// The value must be TRUE or FALSE. If FALSE, all alarm instances created based on the alarm model are activated. The default value is TRUE.
        /// This member is required.
        public var disabledOnInitialization: Swift.Bool?

        public init (
            disabledOnInitialization: Swift.Bool? = nil
        )
        {
            self.disabledOnInitialization = disabledOnInitialization
        }
    }

}

extension IoTEventsClientTypes.Input: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputConfiguration
        case inputDefinition
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputConfiguration = self.inputConfiguration {
            try encodeContainer.encode(inputConfiguration, forKey: .inputConfiguration)
        }
        if let inputDefinition = self.inputDefinition {
            try encodeContainer.encode(inputDefinition, forKey: .inputDefinition)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputConfigurationDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.InputConfiguration.self, forKey: .inputConfiguration)
        inputConfiguration = inputConfigurationDecoded
        let inputDefinitionDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.InputDefinition.self, forKey: .inputDefinition)
        inputDefinition = inputDefinitionDecoded
    }
}

extension IoTEventsClientTypes {
    /// Information about the input.
    public struct Input: Swift.Equatable {
        /// Information about the configuration of an input.
        public var inputConfiguration: IoTEventsClientTypes.InputConfiguration?
        /// The definition of the input.
        public var inputDefinition: IoTEventsClientTypes.InputDefinition?

        public init (
            inputConfiguration: IoTEventsClientTypes.InputConfiguration? = nil,
            inputDefinition: IoTEventsClientTypes.InputDefinition? = nil
        )
        {
            self.inputConfiguration = inputConfiguration
            self.inputDefinition = inputDefinition
        }
    }

}

extension IoTEventsClientTypes.InputConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case inputArn
        case inputDescription
        case inputName
        case lastUpdateTime
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let inputArn = self.inputArn {
            try encodeContainer.encode(inputArn, forKey: .inputArn)
        }
        if let inputDescription = self.inputDescription {
            try encodeContainer.encode(inputDescription, forKey: .inputDescription)
        }
        if let inputName = self.inputName {
            try encodeContainer.encode(inputName, forKey: .inputName)
        }
        if let lastUpdateTime = self.lastUpdateTime {
            try encodeContainer.encodeTimestamp(lastUpdateTime, format: .epochSeconds, forKey: .lastUpdateTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputName)
        inputName = inputNameDecoded
        let inputDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputDescription)
        inputDescription = inputDescriptionDecoded
        let inputArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputArn)
        inputArn = inputArnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.InputStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension IoTEventsClientTypes {
    /// Information about the configuration of an input.
    public struct InputConfiguration: Swift.Equatable {
        /// The time the input was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The ARN of the input.
        /// This member is required.
        public var inputArn: Swift.String?
        /// A brief description of the input.
        public var inputDescription: Swift.String?
        /// The name of the input.
        /// This member is required.
        public var inputName: Swift.String?
        /// The last time the input was updated.
        /// This member is required.
        public var lastUpdateTime: ClientRuntime.Date?
        /// The status of the input.
        /// This member is required.
        public var status: IoTEventsClientTypes.InputStatus?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            inputArn: Swift.String? = nil,
            inputDescription: Swift.String? = nil,
            inputName: Swift.String? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            status: IoTEventsClientTypes.InputStatus? = nil
        )
        {
            self.creationTime = creationTime
            self.inputArn = inputArn
            self.inputDescription = inputDescription
            self.inputName = inputName
            self.lastUpdateTime = lastUpdateTime
            self.status = status
        }
    }

}

extension IoTEventsClientTypes.InputDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attribute0 in attributes {
                try attributesContainer.encode(attribute0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([IoTEventsClientTypes.Attribute?].self, forKey: .attributes)
        var attributesDecoded0:[IoTEventsClientTypes.Attribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [IoTEventsClientTypes.Attribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension IoTEventsClientTypes {
    /// The definition of the input.
    public struct InputDefinition: Swift.Equatable {
        /// The attributes from the JSON payload that are made available by the input. Inputs are derived from messages sent to the AWS IoT Events system using BatchPutMessage. Each such message contains a JSON payload, and those attributes (and their paired values) specified here are available for use in the condition expressions used by detectors that monitor this input.
        /// This member is required.
        public var attributes: [IoTEventsClientTypes.Attribute]?

        public init (
            attributes: [IoTEventsClientTypes.Attribute]? = nil
        )
        {
            self.attributes = attributes
        }
    }

}

extension IoTEventsClientTypes.InputIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iotEventsInputIdentifier
        case iotSiteWiseInputIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iotEventsInputIdentifier = self.iotEventsInputIdentifier {
            try encodeContainer.encode(iotEventsInputIdentifier, forKey: .iotEventsInputIdentifier)
        }
        if let iotSiteWiseInputIdentifier = self.iotSiteWiseInputIdentifier {
            try encodeContainer.encode(iotSiteWiseInputIdentifier, forKey: .iotSiteWiseInputIdentifier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iotEventsInputIdentifierDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.IotEventsInputIdentifier.self, forKey: .iotEventsInputIdentifier)
        iotEventsInputIdentifier = iotEventsInputIdentifierDecoded
        let iotSiteWiseInputIdentifierDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.IotSiteWiseInputIdentifier.self, forKey: .iotSiteWiseInputIdentifier)
        iotSiteWiseInputIdentifier = iotSiteWiseInputIdentifierDecoded
    }
}

extension IoTEventsClientTypes {
    /// The identifer of the input.
    public struct InputIdentifier: Swift.Equatable {
        /// The identifier of the input routed to AWS IoT Events.
        public var iotEventsInputIdentifier: IoTEventsClientTypes.IotEventsInputIdentifier?
        /// The identifer of the input routed from AWS IoT SiteWise.
        public var iotSiteWiseInputIdentifier: IoTEventsClientTypes.IotSiteWiseInputIdentifier?

        public init (
            iotEventsInputIdentifier: IoTEventsClientTypes.IotEventsInputIdentifier? = nil,
            iotSiteWiseInputIdentifier: IoTEventsClientTypes.IotSiteWiseInputIdentifier? = nil
        )
        {
            self.iotEventsInputIdentifier = iotEventsInputIdentifier
            self.iotSiteWiseInputIdentifier = iotSiteWiseInputIdentifier
        }
    }

}

extension IoTEventsClientTypes {
    public enum InputStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [InputStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InputStatus(rawValue: rawValue) ?? InputStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTEventsClientTypes.InputSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case inputArn
        case inputDescription
        case inputName
        case lastUpdateTime
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let inputArn = self.inputArn {
            try encodeContainer.encode(inputArn, forKey: .inputArn)
        }
        if let inputDescription = self.inputDescription {
            try encodeContainer.encode(inputDescription, forKey: .inputDescription)
        }
        if let inputName = self.inputName {
            try encodeContainer.encode(inputName, forKey: .inputName)
        }
        if let lastUpdateTime = self.lastUpdateTime {
            try encodeContainer.encodeTimestamp(lastUpdateTime, format: .epochSeconds, forKey: .lastUpdateTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputName)
        inputName = inputNameDecoded
        let inputDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputDescription)
        inputDescription = inputDescriptionDecoded
        let inputArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputArn)
        inputArn = inputArnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.InputStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension IoTEventsClientTypes {
    /// Information about the input.
    public struct InputSummary: Swift.Equatable {
        /// The time the input was created.
        public var creationTime: ClientRuntime.Date?
        /// The ARN of the input.
        public var inputArn: Swift.String?
        /// A brief description of the input.
        public var inputDescription: Swift.String?
        /// The name of the input.
        public var inputName: Swift.String?
        /// The last time the input was updated.
        public var lastUpdateTime: ClientRuntime.Date?
        /// The status of the input.
        public var status: IoTEventsClientTypes.InputStatus?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            inputArn: Swift.String? = nil,
            inputDescription: Swift.String? = nil,
            inputName: Swift.String? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            status: IoTEventsClientTypes.InputStatus? = nil
        )
        {
            self.creationTime = creationTime
            self.inputArn = inputArn
            self.inputDescription = inputDescription
            self.inputName = inputName
            self.lastUpdateTime = lastUpdateTime
            self.status = status
        }
    }

}

extension InternalFailureException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An internal failure occurred.
public struct InternalFailureException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// The message for the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalFailureExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was invalid.
public struct InvalidRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The message for the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTEventsClientTypes.IotEventsAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputName
        case payload
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputName = self.inputName {
            try encodeContainer.encode(inputName, forKey: .inputName)
        }
        if let payload = self.payload {
            try encodeContainer.encode(payload, forKey: .payload)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputName)
        inputName = inputNameDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.Payload.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension IoTEventsClientTypes {
    /// Sends an AWS IoT Events input, passing in information about the detector model instance and the event that triggered the action.
    public struct IotEventsAction: Swift.Equatable {
        /// The name of the AWS IoT Events input where the data is sent.
        /// This member is required.
        public var inputName: Swift.String?
        /// You can configure the action payload when you send a message to an AWS IoT Events input.
        public var payload: IoTEventsClientTypes.Payload?

        public init (
            inputName: Swift.String? = nil,
            payload: IoTEventsClientTypes.Payload? = nil
        )
        {
            self.inputName = inputName
            self.payload = payload
        }
    }

}

extension IoTEventsClientTypes.IotEventsInputIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputName = self.inputName {
            try encodeContainer.encode(inputName, forKey: .inputName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputName)
        inputName = inputNameDecoded
    }
}

extension IoTEventsClientTypes {
    /// The identifier of the input routed to AWS IoT Events.
    public struct IotEventsInputIdentifier: Swift.Equatable {
        /// The name of the input routed to AWS IoT Events.
        /// This member is required.
        public var inputName: Swift.String?

        public init (
            inputName: Swift.String? = nil
        )
        {
            self.inputName = inputName
        }
    }

}

extension IoTEventsClientTypes.IotSiteWiseAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetId
        case entryId
        case propertyAlias
        case propertyId
        case propertyValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetId = self.assetId {
            try encodeContainer.encode(assetId, forKey: .assetId)
        }
        if let entryId = self.entryId {
            try encodeContainer.encode(entryId, forKey: .entryId)
        }
        if let propertyAlias = self.propertyAlias {
            try encodeContainer.encode(propertyAlias, forKey: .propertyAlias)
        }
        if let propertyId = self.propertyId {
            try encodeContainer.encode(propertyId, forKey: .propertyId)
        }
        if let propertyValue = self.propertyValue {
            try encodeContainer.encode(propertyValue, forKey: .propertyValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryId)
        entryId = entryIdDecoded
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let propertyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyId)
        propertyId = propertyIdDecoded
        let propertyAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyAlias)
        propertyAlias = propertyAliasDecoded
        let propertyValueDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.AssetPropertyValue.self, forKey: .propertyValue)
        propertyValue = propertyValueDecoded
    }
}

extension IoTEventsClientTypes {
    /// Sends information about the detector model instance and the event that triggered the action to a specified asset property in AWS IoT SiteWise. You must use expressions for all parameters in IotSiteWiseAction. The expressions accept literals, operators, functions, references, and substitutions templates. Examples
    ///
    /// * For literal values, the expressions must contain single quotes. For example, the value for the propertyAlias parameter can be '/company/windfarm/3/turbine/7/temperature'.
    ///
    /// * For references, you must specify either variables or input values. For example, the value for the assetId parameter can be $input.TurbineInput.assetId1.
    ///
    /// * For a substitution template, you must use ${}, and the template must be in single quotes. A substitution template can also contain a combination of literals, operators, functions, references, and substitution templates. In the following example, the value for the propertyAlias parameter uses a substitution template. 'company/windfarm/${$input.TemperatureInput.sensorData.windfarmID}/turbine/ ${$input.TemperatureInput.sensorData.turbineID}/temperature'
    ///
    ///
    /// You must specify either propertyAlias or both assetId and propertyId to identify the target asset property in AWS IoT SiteWise. For more information, see [Expressions](https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html) in the AWS IoT Events Developer Guide.
    public struct IotSiteWiseAction: Swift.Equatable {
        /// The ID of the asset that has the specified property.
        public var assetId: Swift.String?
        /// A unique identifier for this entry. You can use the entry ID to track which data entry causes an error in case of failure. The default is a new unique identifier.
        public var entryId: Swift.String?
        /// The alias of the asset property.
        public var propertyAlias: Swift.String?
        /// The ID of the asset property.
        public var propertyId: Swift.String?
        /// The value to send to the asset property. This value contains timestamp, quality, and value (TQV) information.
        public var propertyValue: IoTEventsClientTypes.AssetPropertyValue?

        public init (
            assetId: Swift.String? = nil,
            entryId: Swift.String? = nil,
            propertyAlias: Swift.String? = nil,
            propertyId: Swift.String? = nil,
            propertyValue: IoTEventsClientTypes.AssetPropertyValue? = nil
        )
        {
            self.assetId = assetId
            self.entryId = entryId
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.propertyValue = propertyValue
        }
    }

}

extension IoTEventsClientTypes.IotSiteWiseAssetModelPropertyIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetModelId
        case propertyId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetModelId = self.assetModelId {
            try encodeContainer.encode(assetModelId, forKey: .assetModelId)
        }
        if let propertyId = self.propertyId {
            try encodeContainer.encode(propertyId, forKey: .propertyId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetModelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelId)
        assetModelId = assetModelIdDecoded
        let propertyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyId)
        propertyId = propertyIdDecoded
    }
}

extension IoTEventsClientTypes {
    /// The asset model property identifer of the input routed from AWS IoT SiteWise.
    public struct IotSiteWiseAssetModelPropertyIdentifier: Swift.Equatable {
        /// The ID of the AWS IoT SiteWise asset model.
        /// This member is required.
        public var assetModelId: Swift.String?
        /// The ID of the AWS IoT SiteWise asset property.
        /// This member is required.
        public var propertyId: Swift.String?

        public init (
            assetModelId: Swift.String? = nil,
            propertyId: Swift.String? = nil
        )
        {
            self.assetModelId = assetModelId
            self.propertyId = propertyId
        }
    }

}

extension IoTEventsClientTypes.IotSiteWiseInputIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iotSiteWiseAssetModelPropertyIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iotSiteWiseAssetModelPropertyIdentifier = self.iotSiteWiseAssetModelPropertyIdentifier {
            try encodeContainer.encode(iotSiteWiseAssetModelPropertyIdentifier, forKey: .iotSiteWiseAssetModelPropertyIdentifier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iotSiteWiseAssetModelPropertyIdentifierDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.IotSiteWiseAssetModelPropertyIdentifier.self, forKey: .iotSiteWiseAssetModelPropertyIdentifier)
        iotSiteWiseAssetModelPropertyIdentifier = iotSiteWiseAssetModelPropertyIdentifierDecoded
    }
}

extension IoTEventsClientTypes {
    /// The identifer of the input routed from AWS IoT SiteWise.
    public struct IotSiteWiseInputIdentifier: Swift.Equatable {
        /// The identifier of the AWS IoT SiteWise asset model property.
        public var iotSiteWiseAssetModelPropertyIdentifier: IoTEventsClientTypes.IotSiteWiseAssetModelPropertyIdentifier?

        public init (
            iotSiteWiseAssetModelPropertyIdentifier: IoTEventsClientTypes.IotSiteWiseAssetModelPropertyIdentifier? = nil
        )
        {
            self.iotSiteWiseAssetModelPropertyIdentifier = iotSiteWiseAssetModelPropertyIdentifier
        }
    }

}

extension IoTEventsClientTypes.IotTopicPublishAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mqttTopic
        case payload
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mqttTopic = self.mqttTopic {
            try encodeContainer.encode(mqttTopic, forKey: .mqttTopic)
        }
        if let payload = self.payload {
            try encodeContainer.encode(payload, forKey: .payload)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mqttTopicDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mqttTopic)
        mqttTopic = mqttTopicDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.Payload.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension IoTEventsClientTypes {
    /// Information required to publish the MQTT message through the AWS IoT message broker.
    public struct IotTopicPublishAction: Swift.Equatable {
        /// The MQTT topic of the message. You can use a string expression that includes variables ($variable.) and input values ($input..) as the topic string.
        /// This member is required.
        public var mqttTopic: Swift.String?
        /// You can configure the action payload when you publish a message to an AWS IoT Core topic.
        public var payload: IoTEventsClientTypes.Payload?

        public init (
            mqttTopic: Swift.String? = nil,
            payload: IoTEventsClientTypes.Payload? = nil
        )
        {
            self.mqttTopic = mqttTopic
            self.payload = payload
        }
    }

}

extension IoTEventsClientTypes.LambdaAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionArn
        case payload
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let functionArn = self.functionArn {
            try encodeContainer.encode(functionArn, forKey: .functionArn)
        }
        if let payload = self.payload {
            try encodeContainer.encode(payload, forKey: .payload)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.Payload.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension IoTEventsClientTypes {
    /// Calls a Lambda function, passing in information about the detector model instance and the event that triggered the action.
    public struct LambdaAction: Swift.Equatable {
        /// The ARN of the Lambda function that is executed.
        /// This member is required.
        public var functionArn: Swift.String?
        /// You can configure the action payload when you send a message to a Lambda function.
        public var payload: IoTEventsClientTypes.Payload?

        public init (
            functionArn: Swift.String? = nil,
            payload: IoTEventsClientTypes.Payload? = nil
        )
        {
            self.functionArn = functionArn
            self.payload = payload
        }
    }

}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A limit was exceeded.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The message for the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAlarmModelVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAlarmModelVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let alarmModelName = alarmModelName else {
            return nil
        }
        return "/alarm-models/\(alarmModelName.urlPercentEncoding())/versions"
    }
}

public struct ListAlarmModelVersionsInput: Swift.Equatable {
    /// The name of the alarm model.
    /// This member is required.
    public var alarmModelName: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token that you can use to return the next set of results.
    public var nextToken: Swift.String?

    public init (
        alarmModelName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.alarmModelName = alarmModelName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAlarmModelVersionsInputBody: Swift.Equatable {
}

extension ListAlarmModelVersionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAlarmModelVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAlarmModelVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAlarmModelVersionsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAlarmModelVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAlarmModelVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alarmModelVersionSummaries = output.alarmModelVersionSummaries
            self.nextToken = output.nextToken
        } else {
            self.alarmModelVersionSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAlarmModelVersionsOutputResponse: Swift.Equatable {
    /// A list that summarizes each alarm model version.
    public var alarmModelVersionSummaries: [IoTEventsClientTypes.AlarmModelVersionSummary]?
    /// The token that you can use to return the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        alarmModelVersionSummaries: [IoTEventsClientTypes.AlarmModelVersionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.alarmModelVersionSummaries = alarmModelVersionSummaries
        self.nextToken = nextToken
    }
}

struct ListAlarmModelVersionsOutputResponseBody: Swift.Equatable {
    let alarmModelVersionSummaries: [IoTEventsClientTypes.AlarmModelVersionSummary]?
    let nextToken: Swift.String?
}

extension ListAlarmModelVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmModelVersionSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmModelVersionSummariesContainer = try containerValues.decodeIfPresent([IoTEventsClientTypes.AlarmModelVersionSummary?].self, forKey: .alarmModelVersionSummaries)
        var alarmModelVersionSummariesDecoded0:[IoTEventsClientTypes.AlarmModelVersionSummary]? = nil
        if let alarmModelVersionSummariesContainer = alarmModelVersionSummariesContainer {
            alarmModelVersionSummariesDecoded0 = [IoTEventsClientTypes.AlarmModelVersionSummary]()
            for structure0 in alarmModelVersionSummariesContainer {
                if let structure0 = structure0 {
                    alarmModelVersionSummariesDecoded0?.append(structure0)
                }
            }
        }
        alarmModelVersionSummaries = alarmModelVersionSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAlarmModelsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAlarmModelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/alarm-models"
    }
}

public struct ListAlarmModelsInput: Swift.Equatable {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token that you can use to return the next set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAlarmModelsInputBody: Swift.Equatable {
}

extension ListAlarmModelsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAlarmModelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAlarmModelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAlarmModelsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAlarmModelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAlarmModelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alarmModelSummaries = output.alarmModelSummaries
            self.nextToken = output.nextToken
        } else {
            self.alarmModelSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAlarmModelsOutputResponse: Swift.Equatable {
    /// A list that summarizes each alarm model.
    public var alarmModelSummaries: [IoTEventsClientTypes.AlarmModelSummary]?
    /// The token that you can use to return the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        alarmModelSummaries: [IoTEventsClientTypes.AlarmModelSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.alarmModelSummaries = alarmModelSummaries
        self.nextToken = nextToken
    }
}

struct ListAlarmModelsOutputResponseBody: Swift.Equatable {
    let alarmModelSummaries: [IoTEventsClientTypes.AlarmModelSummary]?
    let nextToken: Swift.String?
}

extension ListAlarmModelsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmModelSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmModelSummariesContainer = try containerValues.decodeIfPresent([IoTEventsClientTypes.AlarmModelSummary?].self, forKey: .alarmModelSummaries)
        var alarmModelSummariesDecoded0:[IoTEventsClientTypes.AlarmModelSummary]? = nil
        if let alarmModelSummariesContainer = alarmModelSummariesContainer {
            alarmModelSummariesDecoded0 = [IoTEventsClientTypes.AlarmModelSummary]()
            for structure0 in alarmModelSummariesContainer {
                if let structure0 = structure0 {
                    alarmModelSummariesDecoded0?.append(structure0)
                }
            }
        }
        alarmModelSummaries = alarmModelSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDetectorModelVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListDetectorModelVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorModelName = detectorModelName else {
            return nil
        }
        return "/detector-models/\(detectorModelName.urlPercentEncoding())/versions"
    }
}

public struct ListDetectorModelVersionsInput: Swift.Equatable {
    /// The name of the detector model whose versions are returned.
    /// This member is required.
    public var detectorModelName: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token that you can use to return the next set of results.
    public var nextToken: Swift.String?

    public init (
        detectorModelName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.detectorModelName = detectorModelName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDetectorModelVersionsInputBody: Swift.Equatable {
}

extension ListDetectorModelVersionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDetectorModelVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDetectorModelVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDetectorModelVersionsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDetectorModelVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDetectorModelVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.detectorModelVersionSummaries = output.detectorModelVersionSummaries
            self.nextToken = output.nextToken
        } else {
            self.detectorModelVersionSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListDetectorModelVersionsOutputResponse: Swift.Equatable {
    /// Summary information about the detector model versions.
    public var detectorModelVersionSummaries: [IoTEventsClientTypes.DetectorModelVersionSummary]?
    /// The token that you can use to return the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        detectorModelVersionSummaries: [IoTEventsClientTypes.DetectorModelVersionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.detectorModelVersionSummaries = detectorModelVersionSummaries
        self.nextToken = nextToken
    }
}

struct ListDetectorModelVersionsOutputResponseBody: Swift.Equatable {
    let detectorModelVersionSummaries: [IoTEventsClientTypes.DetectorModelVersionSummary]?
    let nextToken: Swift.String?
}

extension ListDetectorModelVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorModelVersionSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelVersionSummariesContainer = try containerValues.decodeIfPresent([IoTEventsClientTypes.DetectorModelVersionSummary?].self, forKey: .detectorModelVersionSummaries)
        var detectorModelVersionSummariesDecoded0:[IoTEventsClientTypes.DetectorModelVersionSummary]? = nil
        if let detectorModelVersionSummariesContainer = detectorModelVersionSummariesContainer {
            detectorModelVersionSummariesDecoded0 = [IoTEventsClientTypes.DetectorModelVersionSummary]()
            for structure0 in detectorModelVersionSummariesContainer {
                if let structure0 = structure0 {
                    detectorModelVersionSummariesDecoded0?.append(structure0)
                }
            }
        }
        detectorModelVersionSummaries = detectorModelVersionSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDetectorModelsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListDetectorModelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/detector-models"
    }
}

public struct ListDetectorModelsInput: Swift.Equatable {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token that you can use to return the next set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDetectorModelsInputBody: Swift.Equatable {
}

extension ListDetectorModelsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDetectorModelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDetectorModelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDetectorModelsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDetectorModelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDetectorModelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.detectorModelSummaries = output.detectorModelSummaries
            self.nextToken = output.nextToken
        } else {
            self.detectorModelSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListDetectorModelsOutputResponse: Swift.Equatable {
    /// Summary information about the detector models.
    public var detectorModelSummaries: [IoTEventsClientTypes.DetectorModelSummary]?
    /// The token that you can use to return the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        detectorModelSummaries: [IoTEventsClientTypes.DetectorModelSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.detectorModelSummaries = detectorModelSummaries
        self.nextToken = nextToken
    }
}

struct ListDetectorModelsOutputResponseBody: Swift.Equatable {
    let detectorModelSummaries: [IoTEventsClientTypes.DetectorModelSummary]?
    let nextToken: Swift.String?
}

extension ListDetectorModelsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorModelSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelSummariesContainer = try containerValues.decodeIfPresent([IoTEventsClientTypes.DetectorModelSummary?].self, forKey: .detectorModelSummaries)
        var detectorModelSummariesDecoded0:[IoTEventsClientTypes.DetectorModelSummary]? = nil
        if let detectorModelSummariesContainer = detectorModelSummariesContainer {
            detectorModelSummariesDecoded0 = [IoTEventsClientTypes.DetectorModelSummary]()
            for structure0 in detectorModelSummariesContainer {
                if let structure0 = structure0 {
                    detectorModelSummariesDecoded0?.append(structure0)
                }
            }
        }
        detectorModelSummaries = detectorModelSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInputRoutingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputIdentifier
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputIdentifier = self.inputIdentifier {
            try encodeContainer.encode(inputIdentifier, forKey: .inputIdentifier)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListInputRoutingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/input-routings"
    }
}

public struct ListInputRoutingsInput: Swift.Equatable {
    /// The identifer of the routed input.
    /// This member is required.
    public var inputIdentifier: IoTEventsClientTypes.InputIdentifier?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token that you can use to return the next set of results.
    public var nextToken: Swift.String?

    public init (
        inputIdentifier: IoTEventsClientTypes.InputIdentifier? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.inputIdentifier = inputIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListInputRoutingsInputBody: Swift.Equatable {
    let inputIdentifier: IoTEventsClientTypes.InputIdentifier?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListInputRoutingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputIdentifier
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputIdentifierDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.InputIdentifier.self, forKey: .inputIdentifier)
        inputIdentifier = inputIdentifierDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInputRoutingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInputRoutingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListInputRoutingsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInputRoutingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListInputRoutingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.routedResources = output.routedResources
        } else {
            self.nextToken = nil
            self.routedResources = nil
        }
    }
}

public struct ListInputRoutingsOutputResponse: Swift.Equatable {
    /// The token that you can use to return the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// Summary information about the routed resources.
    public var routedResources: [IoTEventsClientTypes.RoutedResource]?

    public init (
        nextToken: Swift.String? = nil,
        routedResources: [IoTEventsClientTypes.RoutedResource]? = nil
    )
    {
        self.nextToken = nextToken
        self.routedResources = routedResources
    }
}

struct ListInputRoutingsOutputResponseBody: Swift.Equatable {
    let routedResources: [IoTEventsClientTypes.RoutedResource]?
    let nextToken: Swift.String?
}

extension ListInputRoutingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case routedResources
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routedResourcesContainer = try containerValues.decodeIfPresent([IoTEventsClientTypes.RoutedResource?].self, forKey: .routedResources)
        var routedResourcesDecoded0:[IoTEventsClientTypes.RoutedResource]? = nil
        if let routedResourcesContainer = routedResourcesContainer {
            routedResourcesDecoded0 = [IoTEventsClientTypes.RoutedResource]()
            for structure0 in routedResourcesContainer {
                if let structure0 = structure0 {
                    routedResourcesDecoded0?.append(structure0)
                }
            }
        }
        routedResources = routedResourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInputsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListInputsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/inputs"
    }
}

public struct ListInputsInput: Swift.Equatable {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token that you can use to return the next set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListInputsInputBody: Swift.Equatable {
}

extension ListInputsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListInputsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInputsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListInputsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInputsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListInputsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.inputSummaries = output.inputSummaries
            self.nextToken = output.nextToken
        } else {
            self.inputSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListInputsOutputResponse: Swift.Equatable {
    /// Summary information about the inputs.
    public var inputSummaries: [IoTEventsClientTypes.InputSummary]?
    /// The token that you can use to return the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        inputSummaries: [IoTEventsClientTypes.InputSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.inputSummaries = inputSummaries
        self.nextToken = nextToken
    }
}

struct ListInputsOutputResponseBody: Swift.Equatable {
    let inputSummaries: [IoTEventsClientTypes.InputSummary]?
    let nextToken: Swift.String?
}

extension ListInputsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputSummariesContainer = try containerValues.decodeIfPresent([IoTEventsClientTypes.InputSummary?].self, forKey: .inputSummaries)
        var inputSummariesDecoded0:[IoTEventsClientTypes.InputSummary]? = nil
        if let inputSummariesContainer = inputSummariesContainer {
            inputSummariesDecoded0 = [IoTEventsClientTypes.InputSummary]()
            for structure0 in inputSummariesContainer {
                if let structure0 = structure0 {
                    inputSummariesDecoded0?.append(structure0)
                }
            }
        }
        inputSummaries = inputSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceArn = resourceArn else {
                let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            items.append(resourceArnQueryItem)
            return items
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The list of tags assigned to the resource.
    public var tags: [IoTEventsClientTypes.Tag]?

    public init (
        tags: [IoTEventsClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [IoTEventsClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([IoTEventsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTEventsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTEventsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IoTEventsClientTypes {
    public enum LoggingLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case debug
        case error
        case info
        case sdkUnknown(Swift.String)

        public static var allCases: [LoggingLevel] {
            return [
                .debug,
                .error,
                .info,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .debug: return "DEBUG"
            case .error: return "ERROR"
            case .info: return "INFO"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LoggingLevel(rawValue: rawValue) ?? LoggingLevel.sdkUnknown(rawValue)
        }
    }
}

extension IoTEventsClientTypes.LoggingOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorDebugOptions
        case enabled
        case level
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorDebugOptions = detectorDebugOptions {
            var detectorDebugOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .detectorDebugOptions)
            for detectordebugoption0 in detectorDebugOptions {
                try detectorDebugOptionsContainer.encode(detectordebugoption0)
            }
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let level = self.level {
            try encodeContainer.encode(level.rawValue, forKey: .level)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let levelDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.LoggingLevel.self, forKey: .level)
        level = levelDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
        let detectorDebugOptionsContainer = try containerValues.decodeIfPresent([IoTEventsClientTypes.DetectorDebugOption?].self, forKey: .detectorDebugOptions)
        var detectorDebugOptionsDecoded0:[IoTEventsClientTypes.DetectorDebugOption]? = nil
        if let detectorDebugOptionsContainer = detectorDebugOptionsContainer {
            detectorDebugOptionsDecoded0 = [IoTEventsClientTypes.DetectorDebugOption]()
            for structure0 in detectorDebugOptionsContainer {
                if let structure0 = structure0 {
                    detectorDebugOptionsDecoded0?.append(structure0)
                }
            }
        }
        detectorDebugOptions = detectorDebugOptionsDecoded0
    }
}

extension IoTEventsClientTypes {
    /// The values of the AWS IoT Events logging options.
    public struct LoggingOptions: Swift.Equatable {
        /// Information that identifies those detector models and their detectors (instances) for which the logging level is given.
        public var detectorDebugOptions: [IoTEventsClientTypes.DetectorDebugOption]?
        /// If TRUE, logging is enabled for AWS IoT Events.
        /// This member is required.
        public var enabled: Swift.Bool
        /// The logging level.
        /// This member is required.
        public var level: IoTEventsClientTypes.LoggingLevel?
        /// The ARN of the role that grants permission to AWS IoT Events to perform logging.
        /// This member is required.
        public var roleArn: Swift.String?

        public init (
            detectorDebugOptions: [IoTEventsClientTypes.DetectorDebugOption]? = nil,
            enabled: Swift.Bool = false,
            level: IoTEventsClientTypes.LoggingLevel? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.detectorDebugOptions = detectorDebugOptions
            self.enabled = enabled
            self.level = level
            self.roleArn = roleArn
        }
    }

}

extension IoTEventsClientTypes.NotificationAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case emailConfigurations
        case smsConfigurations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let emailConfigurations = emailConfigurations {
            var emailConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .emailConfigurations)
            for emailconfiguration0 in emailConfigurations {
                try emailConfigurationsContainer.encode(emailconfiguration0)
            }
        }
        if let smsConfigurations = smsConfigurations {
            var smsConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .smsConfigurations)
            for smsconfiguration0 in smsConfigurations {
                try smsConfigurationsContainer.encode(smsconfiguration0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.NotificationTargetActions.self, forKey: .action)
        action = actionDecoded
        let smsConfigurationsContainer = try containerValues.decodeIfPresent([IoTEventsClientTypes.SMSConfiguration?].self, forKey: .smsConfigurations)
        var smsConfigurationsDecoded0:[IoTEventsClientTypes.SMSConfiguration]? = nil
        if let smsConfigurationsContainer = smsConfigurationsContainer {
            smsConfigurationsDecoded0 = [IoTEventsClientTypes.SMSConfiguration]()
            for structure0 in smsConfigurationsContainer {
                if let structure0 = structure0 {
                    smsConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        smsConfigurations = smsConfigurationsDecoded0
        let emailConfigurationsContainer = try containerValues.decodeIfPresent([IoTEventsClientTypes.EmailConfiguration?].self, forKey: .emailConfigurations)
        var emailConfigurationsDecoded0:[IoTEventsClientTypes.EmailConfiguration]? = nil
        if let emailConfigurationsContainer = emailConfigurationsContainer {
            emailConfigurationsDecoded0 = [IoTEventsClientTypes.EmailConfiguration]()
            for structure0 in emailConfigurationsContainer {
                if let structure0 = structure0 {
                    emailConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        emailConfigurations = emailConfigurationsDecoded0
    }
}

extension IoTEventsClientTypes {
    /// Contains the notification settings of an alarm model. The settings apply to all alarms that were created based on this alarm model.
    public struct NotificationAction: Swift.Equatable {
        /// Specifies an AWS Lambda function to manage alarm notifications. You can create one or use the [AWS Lambda function provided by AWS IoT Events](https://docs.aws.amazon.com/iotevents/latest/developerguide/lambda-support.html).
        /// This member is required.
        public var action: IoTEventsClientTypes.NotificationTargetActions?
        /// Contains the configuration information of email notifications.
        public var emailConfigurations: [IoTEventsClientTypes.EmailConfiguration]?
        /// Contains the configuration information of SMS notifications.
        public var smsConfigurations: [IoTEventsClientTypes.SMSConfiguration]?

        public init (
            action: IoTEventsClientTypes.NotificationTargetActions? = nil,
            emailConfigurations: [IoTEventsClientTypes.EmailConfiguration]? = nil,
            smsConfigurations: [IoTEventsClientTypes.SMSConfiguration]? = nil
        )
        {
            self.action = action
            self.emailConfigurations = emailConfigurations
            self.smsConfigurations = smsConfigurations
        }
    }

}

extension IoTEventsClientTypes.NotificationTargetActions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lambdaAction
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lambdaAction = self.lambdaAction {
            try encodeContainer.encode(lambdaAction, forKey: .lambdaAction)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaActionDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.LambdaAction.self, forKey: .lambdaAction)
        lambdaAction = lambdaActionDecoded
    }
}

extension IoTEventsClientTypes {
    /// Specifies an AWS Lambda function to manage alarm notifications. You can create one or use the [AWS Lambda function provided by AWS IoT Events](https://docs.aws.amazon.com/iotevents/latest/developerguide/lambda-support.html).
    public struct NotificationTargetActions: Swift.Equatable {
        /// Calls a Lambda function, passing in information about the detector model instance and the event that triggered the action.
        public var lambdaAction: IoTEventsClientTypes.LambdaAction?

        public init (
            lambdaAction: IoTEventsClientTypes.LambdaAction? = nil
        )
        {
            self.lambdaAction = lambdaAction
        }
    }

}

extension IoTEventsClientTypes.OnEnterLifecycle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for event0 in events {
                try eventsContainer.encode(event0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([IoTEventsClientTypes.Event?].self, forKey: .events)
        var eventsDecoded0:[IoTEventsClientTypes.Event]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [IoTEventsClientTypes.Event]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
    }
}

extension IoTEventsClientTypes {
    /// When entering this state, perform these actions if the condition is TRUE.
    public struct OnEnterLifecycle: Swift.Equatable {
        /// Specifies the actions that are performed when the state is entered and the condition is TRUE.
        public var events: [IoTEventsClientTypes.Event]?

        public init (
            events: [IoTEventsClientTypes.Event]? = nil
        )
        {
            self.events = events
        }
    }

}

extension IoTEventsClientTypes.OnExitLifecycle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for event0 in events {
                try eventsContainer.encode(event0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([IoTEventsClientTypes.Event?].self, forKey: .events)
        var eventsDecoded0:[IoTEventsClientTypes.Event]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [IoTEventsClientTypes.Event]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
    }
}

extension IoTEventsClientTypes {
    /// When exiting this state, perform these actions if the specified condition is TRUE.
    public struct OnExitLifecycle: Swift.Equatable {
        /// Specifies the actions that are performed when the state is exited and the condition is TRUE.
        public var events: [IoTEventsClientTypes.Event]?

        public init (
            events: [IoTEventsClientTypes.Event]? = nil
        )
        {
            self.events = events
        }
    }

}

extension IoTEventsClientTypes.OnInputLifecycle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events
        case transitionEvents
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for event0 in events {
                try eventsContainer.encode(event0)
            }
        }
        if let transitionEvents = transitionEvents {
            var transitionEventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .transitionEvents)
            for transitionevent0 in transitionEvents {
                try transitionEventsContainer.encode(transitionevent0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([IoTEventsClientTypes.Event?].self, forKey: .events)
        var eventsDecoded0:[IoTEventsClientTypes.Event]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [IoTEventsClientTypes.Event]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
        let transitionEventsContainer = try containerValues.decodeIfPresent([IoTEventsClientTypes.TransitionEvent?].self, forKey: .transitionEvents)
        var transitionEventsDecoded0:[IoTEventsClientTypes.TransitionEvent]? = nil
        if let transitionEventsContainer = transitionEventsContainer {
            transitionEventsDecoded0 = [IoTEventsClientTypes.TransitionEvent]()
            for structure0 in transitionEventsContainer {
                if let structure0 = structure0 {
                    transitionEventsDecoded0?.append(structure0)
                }
            }
        }
        transitionEvents = transitionEventsDecoded0
    }
}

extension IoTEventsClientTypes {
    /// Specifies the actions performed when the condition evaluates to TRUE.
    public struct OnInputLifecycle: Swift.Equatable {
        /// Specifies the actions performed when the condition evaluates to TRUE.
        public var events: [IoTEventsClientTypes.Event]?
        /// Specifies the actions performed, and the next state entered, when a condition evaluates to TRUE.
        public var transitionEvents: [IoTEventsClientTypes.TransitionEvent]?

        public init (
            events: [IoTEventsClientTypes.Event]? = nil,
            transitionEvents: [IoTEventsClientTypes.TransitionEvent]? = nil
        )
        {
            self.events = events
            self.transitionEvents = transitionEvents
        }
    }

}

extension IoTEventsClientTypes.Payload: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentExpression
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentExpression = self.contentExpression {
            try encodeContainer.encode(contentExpression, forKey: .contentExpression)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentExpression)
        contentExpression = contentExpressionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.PayloadType.self, forKey: .type)
        type = typeDecoded
    }
}

extension IoTEventsClientTypes {
    /// Information needed to configure the payload. By default, AWS IoT Events generates a standard payload in JSON for any action. This action payload contains all attribute-value pairs that have the information about the detector model instance and the event triggered the action. To configure the action payload, you can use contentExpression.
    public struct Payload: Swift.Equatable {
        /// The content of the payload. You can use a string expression that includes quoted strings (''), variables ($variable.), input values ($input..), string concatenations, and quoted strings that contain ${} as the content. The recommended maximum size of a content expression is 1 KB.
        /// This member is required.
        public var contentExpression: Swift.String?
        /// The value of the payload type can be either STRING or JSON.
        /// This member is required.
        public var type: IoTEventsClientTypes.PayloadType?

        public init (
            contentExpression: Swift.String? = nil,
            type: IoTEventsClientTypes.PayloadType? = nil
        )
        {
            self.contentExpression = contentExpression
            self.type = type
        }
    }

}

extension IoTEventsClientTypes {
    public enum PayloadType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case json
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [PayloadType] {
            return [
                .json,
                .string,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PayloadType(rawValue: rawValue) ?? PayloadType.sdkUnknown(rawValue)
        }
    }
}

extension PutLoggingOptionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingOptions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loggingOptions = self.loggingOptions {
            try encodeContainer.encode(loggingOptions, forKey: .loggingOptions)
        }
    }
}

extension PutLoggingOptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/logging"
    }
}

public struct PutLoggingOptionsInput: Swift.Equatable {
    /// The new values of the AWS IoT Events logging options.
    /// This member is required.
    public var loggingOptions: IoTEventsClientTypes.LoggingOptions?

    public init (
        loggingOptions: IoTEventsClientTypes.LoggingOptions? = nil
    )
    {
        self.loggingOptions = loggingOptions
    }
}

struct PutLoggingOptionsInputBody: Swift.Equatable {
    let loggingOptions: IoTEventsClientTypes.LoggingOptions?
}

extension PutLoggingOptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingOptions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingOptionsDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.LoggingOptions.self, forKey: .loggingOptions)
        loggingOptions = loggingOptionsDecoded
    }
}

extension PutLoggingOptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutLoggingOptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutLoggingOptionsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutLoggingOptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutLoggingOptionsOutputResponse: Swift.Equatable {

    public init () { }
}

extension IoTEventsClientTypes.RecipientDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ssoIdentity
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ssoIdentity = self.ssoIdentity {
            try encodeContainer.encode(ssoIdentity, forKey: .ssoIdentity)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ssoIdentityDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.SSOIdentity.self, forKey: .ssoIdentity)
        ssoIdentity = ssoIdentityDecoded
    }
}

extension IoTEventsClientTypes {
    /// The information that identifies the recipient.
    public struct RecipientDetail: Swift.Equatable {
        /// The AWS Single Sign-On (AWS SSO) authentication information.
        public var ssoIdentity: IoTEventsClientTypes.SSOIdentity?

        public init (
            ssoIdentity: IoTEventsClientTypes.SSOIdentity? = nil
        )
        {
            self.ssoIdentity = ssoIdentity
        }
    }

}

extension IoTEventsClientTypes.ResetTimerAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timerName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timerName = self.timerName {
            try encodeContainer.encode(timerName, forKey: .timerName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timerName)
        timerName = timerNameDecoded
    }
}

extension IoTEventsClientTypes {
    /// Information required to reset the timer. The timer is reset to the previously evaluated result of the duration. The duration expression isn't reevaluated when you reset the timer.
    public struct ResetTimerAction: Swift.Equatable {
        /// The name of the timer to reset.
        /// This member is required.
        public var timerName: Swift.String?

        public init (
            timerName: Swift.String? = nil
        )
        {
            self.timerName = timerName
        }
    }

}

extension ResourceAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceArn = output.resourceArn
            self.resourceId = output.resourceId
        } else {
            self.message = nil
            self.resourceArn = nil
            self.resourceId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource already exists.
public struct ResourceAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The message for the exception.
    public var message: Swift.String?
    /// The ARN of the resource.
    public var resourceArn: Swift.String?
    /// The ID of the resource.
    public var resourceId: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceArn = resourceArn
        self.resourceId = resourceId
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceArn: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceArn
        case resourceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ResourceInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource is in use.
public struct ResourceInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The message for the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource was not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The message for the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTEventsClientTypes.RoutedResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension IoTEventsClientTypes {
    /// Contains information about the routed resource.
    public struct RoutedResource: Swift.Equatable {
        /// The ARN of the routed resource. For more information, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
        public var arn: Swift.String?
        /// The name of the routed resource.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
        }
    }

}

extension IoTEventsClientTypes.SMSConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalMessage
        case recipients
        case senderId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalMessage = self.additionalMessage {
            try encodeContainer.encode(additionalMessage, forKey: .additionalMessage)
        }
        if let recipients = recipients {
            var recipientsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recipients)
            for recipientdetail0 in recipients {
                try recipientsContainer.encode(recipientdetail0)
            }
        }
        if let senderId = self.senderId {
            try encodeContainer.encode(senderId, forKey: .senderId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let senderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .senderId)
        senderId = senderIdDecoded
        let additionalMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalMessage)
        additionalMessage = additionalMessageDecoded
        let recipientsContainer = try containerValues.decodeIfPresent([IoTEventsClientTypes.RecipientDetail?].self, forKey: .recipients)
        var recipientsDecoded0:[IoTEventsClientTypes.RecipientDetail]? = nil
        if let recipientsContainer = recipientsContainer {
            recipientsDecoded0 = [IoTEventsClientTypes.RecipientDetail]()
            for structure0 in recipientsContainer {
                if let structure0 = structure0 {
                    recipientsDecoded0?.append(structure0)
                }
            }
        }
        recipients = recipientsDecoded0
    }
}

extension IoTEventsClientTypes {
    /// Contains the configuration information of SMS notifications.
    public struct SMSConfiguration: Swift.Equatable {
        /// The message that you want to send. The message can be up to 200 characters.
        public var additionalMessage: Swift.String?
        /// Specifies one or more recipients who receive the message. You must [add the users that receive SMS messages to your AWS SSO store](https://docs.aws.amazon.com/singlesignon/latest/userguide/addusers.html).
        /// This member is required.
        public var recipients: [IoTEventsClientTypes.RecipientDetail]?
        /// The sender ID.
        public var senderId: Swift.String?

        public init (
            additionalMessage: Swift.String? = nil,
            recipients: [IoTEventsClientTypes.RecipientDetail]? = nil,
            senderId: Swift.String? = nil
        )
        {
            self.additionalMessage = additionalMessage
            self.recipients = recipients
            self.senderId = senderId
        }
    }

}

extension IoTEventsClientTypes.SNSTopicPublishAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload
        case targetArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let payload = self.payload {
            try encodeContainer.encode(payload, forKey: .payload)
        }
        if let targetArn = self.targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.Payload.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension IoTEventsClientTypes {
    /// Information required to publish the Amazon SNS message.
    public struct SNSTopicPublishAction: Swift.Equatable {
        /// You can configure the action payload when you send a message as an Amazon SNS push notification.
        public var payload: IoTEventsClientTypes.Payload?
        /// The ARN of the Amazon SNS target where the message is sent.
        /// This member is required.
        public var targetArn: Swift.String?

        public init (
            payload: IoTEventsClientTypes.Payload? = nil,
            targetArn: Swift.String? = nil
        )
        {
            self.payload = payload
            self.targetArn = targetArn
        }
    }

}

extension IoTEventsClientTypes.SSOIdentity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId
        case userId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

extension IoTEventsClientTypes {
    /// Contains information about your identity source in AWS Single Sign-On. For more information, see the [AWS Single Sign-On User Guide](https://docs.aws.amazon.com/singlesignon/latest/userguide/what-is.html).
    public struct SSOIdentity: Swift.Equatable {
        /// The ID of the AWS SSO identity store.
        /// This member is required.
        public var identityStoreId: Swift.String?
        /// The user ID.
        public var userId: Swift.String?

        public init (
            identityStoreId: Swift.String? = nil,
            userId: Swift.String? = nil
        )
        {
            self.identityStoreId = identityStoreId
            self.userId = userId
        }
    }

}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service is currently unavailable.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// The message for the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTEventsClientTypes.SetTimerAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case durationExpression
        case seconds
        case timerName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let durationExpression = self.durationExpression {
            try encodeContainer.encode(durationExpression, forKey: .durationExpression)
        }
        if let seconds = self.seconds {
            try encodeContainer.encode(seconds, forKey: .seconds)
        }
        if let timerName = self.timerName {
            try encodeContainer.encode(timerName, forKey: .timerName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timerName)
        timerName = timerNameDecoded
        let secondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .seconds)
        seconds = secondsDecoded
        let durationExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .durationExpression)
        durationExpression = durationExpressionDecoded
    }
}

extension IoTEventsClientTypes {
    /// Information needed to set the timer.
    public struct SetTimerAction: Swift.Equatable {
        /// The duration of the timer, in seconds. You can use a string expression that includes numbers, variables ($variable.), and input values ($input..) as the duration. The range of the duration is 1-31622400 seconds. To ensure accuracy, the minimum duration is 60 seconds. The evaluated result of the duration is rounded down to the nearest whole number.
        public var durationExpression: Swift.String?
        /// The number of seconds until the timer expires. The minimum value is 60 seconds to ensure accuracy. The maximum value is 31622400 seconds.
        @available(*, deprecated, message: "seconds is deprecated. You can use durationExpression for SetTimerAction. The value of seconds can be used as a string expression for durationExpression.")
        public var seconds: Swift.Int?
        /// The name of the timer.
        /// This member is required.
        public var timerName: Swift.String?

        public init (
            durationExpression: Swift.String? = nil,
            seconds: Swift.Int? = nil,
            timerName: Swift.String? = nil
        )
        {
            self.durationExpression = durationExpression
            self.seconds = seconds
            self.timerName = timerName
        }
    }

}

extension IoTEventsClientTypes.SetVariableAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case value
        case variableName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
        if let variableName = self.variableName {
            try encodeContainer.encode(variableName, forKey: .variableName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let variableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .variableName)
        variableName = variableNameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension IoTEventsClientTypes {
    /// Information about the variable and its new value.
    public struct SetVariableAction: Swift.Equatable {
        /// The new value of the variable.
        /// This member is required.
        public var value: Swift.String?
        /// The name of the variable.
        /// This member is required.
        public var variableName: Swift.String?

        public init (
            value: Swift.String? = nil,
            variableName: Swift.String? = nil
        )
        {
            self.value = value
            self.variableName = variableName
        }
    }

}

extension IoTEventsClientTypes.SimpleRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparisonOperator
        case inputProperty
        case threshold
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparisonOperator = self.comparisonOperator {
            try encodeContainer.encode(comparisonOperator.rawValue, forKey: .comparisonOperator)
        }
        if let inputProperty = self.inputProperty {
            try encodeContainer.encode(inputProperty, forKey: .inputProperty)
        }
        if let threshold = self.threshold {
            try encodeContainer.encode(threshold, forKey: .threshold)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputPropertyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputProperty)
        inputProperty = inputPropertyDecoded
        let comparisonOperatorDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.ComparisonOperator.self, forKey: .comparisonOperator)
        comparisonOperator = comparisonOperatorDecoded
        let thresholdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .threshold)
        threshold = thresholdDecoded
    }
}

extension IoTEventsClientTypes {
    /// A rule that compares an input property value to a threshold value with a comparison operator.
    public struct SimpleRule: Swift.Equatable {
        /// The comparison operator.
        /// This member is required.
        public var comparisonOperator: IoTEventsClientTypes.ComparisonOperator?
        /// The value on the left side of the comparison operator. You can specify an AWS IoT Events input attribute as an input property.
        /// This member is required.
        public var inputProperty: Swift.String?
        /// The value on the right side of the comparison operator. You can enter a number or specify an AWS IoT Events input attribute.
        /// This member is required.
        public var threshold: Swift.String?

        public init (
            comparisonOperator: IoTEventsClientTypes.ComparisonOperator? = nil,
            inputProperty: Swift.String? = nil,
            threshold: Swift.String? = nil
        )
        {
            self.comparisonOperator = comparisonOperator
            self.inputProperty = inputProperty
            self.threshold = threshold
        }
    }

}

extension IoTEventsClientTypes.SqsAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload
        case queueUrl
        case useBase64
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let payload = self.payload {
            try encodeContainer.encode(payload, forKey: .payload)
        }
        if let queueUrl = self.queueUrl {
            try encodeContainer.encode(queueUrl, forKey: .queueUrl)
        }
        if let useBase64 = self.useBase64 {
            try encodeContainer.encode(useBase64, forKey: .useBase64)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueUrl)
        queueUrl = queueUrlDecoded
        let useBase64Decoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useBase64)
        useBase64 = useBase64Decoded
        let payloadDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.Payload.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension IoTEventsClientTypes {
    /// Sends information about the detector model instance and the event that triggered the action to an Amazon SQS queue.
    public struct SqsAction: Swift.Equatable {
        /// You can configure the action payload when you send a message to an Amazon SQS queue.
        public var payload: IoTEventsClientTypes.Payload?
        /// The URL of the SQS queue where the data is written.
        /// This member is required.
        public var queueUrl: Swift.String?
        /// Set this to TRUE if you want the data to be base-64 encoded before it is written to the queue. Otherwise, set this to FALSE.
        public var useBase64: Swift.Bool?

        public init (
            payload: IoTEventsClientTypes.Payload? = nil,
            queueUrl: Swift.String? = nil,
            useBase64: Swift.Bool? = nil
        )
        {
            self.payload = payload
            self.queueUrl = queueUrl
            self.useBase64 = useBase64
        }
    }

}

extension StartDetectorModelAnalysisInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorModelDefinition
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorModelDefinition = self.detectorModelDefinition {
            try encodeContainer.encode(detectorModelDefinition, forKey: .detectorModelDefinition)
        }
    }
}

extension StartDetectorModelAnalysisInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/analysis/detector-models"
    }
}

public struct StartDetectorModelAnalysisInput: Swift.Equatable {
    /// Information that defines how a detector operates.
    /// This member is required.
    public var detectorModelDefinition: IoTEventsClientTypes.DetectorModelDefinition?

    public init (
        detectorModelDefinition: IoTEventsClientTypes.DetectorModelDefinition? = nil
    )
    {
        self.detectorModelDefinition = detectorModelDefinition
    }
}

struct StartDetectorModelAnalysisInputBody: Swift.Equatable {
    let detectorModelDefinition: IoTEventsClientTypes.DetectorModelDefinition?
}

extension StartDetectorModelAnalysisInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorModelDefinition
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelDefinitionDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.DetectorModelDefinition.self, forKey: .detectorModelDefinition)
        detectorModelDefinition = detectorModelDefinitionDecoded
    }
}

extension StartDetectorModelAnalysisOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartDetectorModelAnalysisOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartDetectorModelAnalysisOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDetectorModelAnalysisOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartDetectorModelAnalysisOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.analysisId = output.analysisId
        } else {
            self.analysisId = nil
        }
    }
}

public struct StartDetectorModelAnalysisOutputResponse: Swift.Equatable {
    /// The ID that you can use to retrieve the analysis result.
    public var analysisId: Swift.String?

    public init (
        analysisId: Swift.String? = nil
    )
    {
        self.analysisId = analysisId
    }
}

struct StartDetectorModelAnalysisOutputResponseBody: Swift.Equatable {
    let analysisId: Swift.String?
}

extension StartDetectorModelAnalysisOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analysisId)
        analysisId = analysisIdDecoded
    }
}

extension IoTEventsClientTypes.State: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case onEnter
        case onExit
        case onInput
        case stateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let onEnter = self.onEnter {
            try encodeContainer.encode(onEnter, forKey: .onEnter)
        }
        if let onExit = self.onExit {
            try encodeContainer.encode(onExit, forKey: .onExit)
        }
        if let onInput = self.onInput {
            try encodeContainer.encode(onInput, forKey: .onInput)
        }
        if let stateName = self.stateName {
            try encodeContainer.encode(stateName, forKey: .stateName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateName)
        stateName = stateNameDecoded
        let onInputDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.OnInputLifecycle.self, forKey: .onInput)
        onInput = onInputDecoded
        let onEnterDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.OnEnterLifecycle.self, forKey: .onEnter)
        onEnter = onEnterDecoded
        let onExitDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.OnExitLifecycle.self, forKey: .onExit)
        onExit = onExitDecoded
    }
}

extension IoTEventsClientTypes {
    /// Information that defines a state of a detector.
    public struct State: Swift.Equatable {
        /// When entering this state, perform these actions if the condition is TRUE.
        public var onEnter: IoTEventsClientTypes.OnEnterLifecycle?
        /// When exiting this state, perform these actions if the specified condition is TRUE.
        public var onExit: IoTEventsClientTypes.OnExitLifecycle?
        /// When an input is received and the condition is TRUE, perform the specified actions.
        public var onInput: IoTEventsClientTypes.OnInputLifecycle?
        /// The name of the state.
        /// This member is required.
        public var stateName: Swift.String?

        public init (
            onEnter: IoTEventsClientTypes.OnEnterLifecycle? = nil,
            onExit: IoTEventsClientTypes.OnExitLifecycle? = nil,
            onInput: IoTEventsClientTypes.OnInputLifecycle? = nil,
            stateName: Swift.String? = nil
        )
        {
            self.onEnter = onEnter
            self.onExit = onExit
            self.onInput = onInput
            self.stateName = stateName
        }
    }

}

extension IoTEventsClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension IoTEventsClientTypes {
    /// Metadata that can be used to manage the resource.
    public struct Tag: Swift.Equatable {
        /// The tag's key.
        /// This member is required.
        public var key: Swift.String?
        /// The tag's value.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceArn = resourceArn else {
                let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            items.append(resourceArnQueryItem)
            return items
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The new or modified tags for the resource.
    /// This member is required.
    public var tags: [IoTEventsClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [IoTEventsClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [IoTEventsClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([IoTEventsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTEventsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTEventsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request could not be completed due to throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The message for the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTEventsClientTypes.TransitionEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case condition
        case eventName
        case nextState
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for action0 in actions {
                try actionsContainer.encode(action0)
            }
        }
        if let condition = self.condition {
            try encodeContainer.encode(condition, forKey: .condition)
        }
        if let eventName = self.eventName {
            try encodeContainer.encode(eventName, forKey: .eventName)
        }
        if let nextState = self.nextState {
            try encodeContainer.encode(nextState, forKey: .nextState)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventName)
        eventName = eventNameDecoded
        let conditionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .condition)
        condition = conditionDecoded
        let actionsContainer = try containerValues.decodeIfPresent([IoTEventsClientTypes.Action?].self, forKey: .actions)
        var actionsDecoded0:[IoTEventsClientTypes.Action]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [IoTEventsClientTypes.Action]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let nextStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextState)
        nextState = nextStateDecoded
    }
}

extension IoTEventsClientTypes {
    /// Specifies the actions performed and the next state entered when a condition evaluates to TRUE.
    public struct TransitionEvent: Swift.Equatable {
        /// The actions to be performed.
        public var actions: [IoTEventsClientTypes.Action]?
        /// Required. A Boolean expression that when TRUE causes the actions to be performed and the nextState to be entered.
        /// This member is required.
        public var condition: Swift.String?
        /// The name of the transition event.
        /// This member is required.
        public var eventName: Swift.String?
        /// The next state to enter.
        /// This member is required.
        public var nextState: Swift.String?

        public init (
            actions: [IoTEventsClientTypes.Action]? = nil,
            condition: Swift.String? = nil,
            eventName: Swift.String? = nil,
            nextState: Swift.String? = nil
        )
        {
            self.actions = actions
            self.condition = condition
            self.eventName = eventName
            self.nextState = nextState
        }
    }

}

extension UnsupportedOperationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UnsupportedOperationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested operation is not supported.
public struct UnsupportedOperationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// The message for the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedOperationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedOperationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            guard let resourceArn = resourceArn else {
                let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            items.append(resourceArnQueryItem)
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of the keys of the tags to be removed from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateAlarmModelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmCapabilities
        case alarmEventActions
        case alarmModelDescription
        case alarmNotification
        case alarmRule
        case roleArn
        case severity
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmCapabilities = self.alarmCapabilities {
            try encodeContainer.encode(alarmCapabilities, forKey: .alarmCapabilities)
        }
        if let alarmEventActions = self.alarmEventActions {
            try encodeContainer.encode(alarmEventActions, forKey: .alarmEventActions)
        }
        if let alarmModelDescription = self.alarmModelDescription {
            try encodeContainer.encode(alarmModelDescription, forKey: .alarmModelDescription)
        }
        if let alarmNotification = self.alarmNotification {
            try encodeContainer.encode(alarmNotification, forKey: .alarmNotification)
        }
        if let alarmRule = self.alarmRule {
            try encodeContainer.encode(alarmRule, forKey: .alarmRule)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let severity = self.severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
    }
}

extension UpdateAlarmModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let alarmModelName = alarmModelName else {
            return nil
        }
        return "/alarm-models/\(alarmModelName.urlPercentEncoding())"
    }
}

public struct UpdateAlarmModelInput: Swift.Equatable {
    /// Contains the configuration information of alarm state changes.
    public var alarmCapabilities: IoTEventsClientTypes.AlarmCapabilities?
    /// Contains information about one or more alarm actions.
    public var alarmEventActions: IoTEventsClientTypes.AlarmEventActions?
    /// The description of the alarm model.
    public var alarmModelDescription: Swift.String?
    /// The name of the alarm model.
    /// This member is required.
    public var alarmModelName: Swift.String?
    /// Contains information about one or more notification actions.
    public var alarmNotification: IoTEventsClientTypes.AlarmNotification?
    /// Defines when your alarm is invoked.
    /// This member is required.
    public var alarmRule: IoTEventsClientTypes.AlarmRule?
    /// The ARN of the IAM role that allows the alarm to perform actions and access AWS resources. For more information, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A non-negative integer that reflects the severity level of the alarm.
    public var severity: Swift.Int?

    public init (
        alarmCapabilities: IoTEventsClientTypes.AlarmCapabilities? = nil,
        alarmEventActions: IoTEventsClientTypes.AlarmEventActions? = nil,
        alarmModelDescription: Swift.String? = nil,
        alarmModelName: Swift.String? = nil,
        alarmNotification: IoTEventsClientTypes.AlarmNotification? = nil,
        alarmRule: IoTEventsClientTypes.AlarmRule? = nil,
        roleArn: Swift.String? = nil,
        severity: Swift.Int? = nil
    )
    {
        self.alarmCapabilities = alarmCapabilities
        self.alarmEventActions = alarmEventActions
        self.alarmModelDescription = alarmModelDescription
        self.alarmModelName = alarmModelName
        self.alarmNotification = alarmNotification
        self.alarmRule = alarmRule
        self.roleArn = roleArn
        self.severity = severity
    }
}

struct UpdateAlarmModelInputBody: Swift.Equatable {
    let alarmModelDescription: Swift.String?
    let roleArn: Swift.String?
    let severity: Swift.Int?
    let alarmRule: IoTEventsClientTypes.AlarmRule?
    let alarmNotification: IoTEventsClientTypes.AlarmNotification?
    let alarmEventActions: IoTEventsClientTypes.AlarmEventActions?
    let alarmCapabilities: IoTEventsClientTypes.AlarmCapabilities?
}

extension UpdateAlarmModelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmCapabilities
        case alarmEventActions
        case alarmModelDescription
        case alarmNotification
        case alarmRule
        case roleArn
        case severity
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmModelDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelDescription)
        alarmModelDescription = alarmModelDescriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let severityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .severity)
        severity = severityDecoded
        let alarmRuleDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.AlarmRule.self, forKey: .alarmRule)
        alarmRule = alarmRuleDecoded
        let alarmNotificationDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.AlarmNotification.self, forKey: .alarmNotification)
        alarmNotification = alarmNotificationDecoded
        let alarmEventActionsDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.AlarmEventActions.self, forKey: .alarmEventActions)
        alarmEventActions = alarmEventActionsDecoded
        let alarmCapabilitiesDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.AlarmCapabilities.self, forKey: .alarmCapabilities)
        alarmCapabilities = alarmCapabilitiesDecoded
    }
}

extension UpdateAlarmModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAlarmModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateAlarmModelOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAlarmModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateAlarmModelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alarmModelArn = output.alarmModelArn
            self.alarmModelVersion = output.alarmModelVersion
            self.creationTime = output.creationTime
            self.lastUpdateTime = output.lastUpdateTime
            self.status = output.status
        } else {
            self.alarmModelArn = nil
            self.alarmModelVersion = nil
            self.creationTime = nil
            self.lastUpdateTime = nil
            self.status = nil
        }
    }
}

public struct UpdateAlarmModelOutputResponse: Swift.Equatable {
    /// The ARN of the alarm model. For more information, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    public var alarmModelArn: Swift.String?
    /// The version of the alarm model.
    public var alarmModelVersion: Swift.String?
    /// The time the alarm model was created, in the Unix epoch format.
    public var creationTime: ClientRuntime.Date?
    /// The time the alarm model was last updated, in the Unix epoch format.
    public var lastUpdateTime: ClientRuntime.Date?
    /// The status of the alarm model. The status can be one of the following values:
    ///
    /// * ACTIVE - The alarm model is active and it's ready to evaluate data.
    ///
    /// * ACTIVATING - AWS IoT Events is activating your alarm model. Activating an alarm model can take up to a few minutes.
    ///
    /// * INACTIVE - The alarm model is inactive, so it isn't ready to evaluate data. Check your alarm model information and update the alarm model.
    ///
    /// * FAILED - You couldn't create or update the alarm model. Check your alarm model information and try again.
    public var status: IoTEventsClientTypes.AlarmModelVersionStatus?

    public init (
        alarmModelArn: Swift.String? = nil,
        alarmModelVersion: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        lastUpdateTime: ClientRuntime.Date? = nil,
        status: IoTEventsClientTypes.AlarmModelVersionStatus? = nil
    )
    {
        self.alarmModelArn = alarmModelArn
        self.alarmModelVersion = alarmModelVersion
        self.creationTime = creationTime
        self.lastUpdateTime = lastUpdateTime
        self.status = status
    }
}

struct UpdateAlarmModelOutputResponseBody: Swift.Equatable {
    let creationTime: ClientRuntime.Date?
    let alarmModelArn: Swift.String?
    let alarmModelVersion: Swift.String?
    let lastUpdateTime: ClientRuntime.Date?
    let status: IoTEventsClientTypes.AlarmModelVersionStatus?
}

extension UpdateAlarmModelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmModelArn
        case alarmModelVersion
        case creationTime
        case lastUpdateTime
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let alarmModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelArn)
        alarmModelArn = alarmModelArnDecoded
        let alarmModelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelVersion)
        alarmModelVersion = alarmModelVersionDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.AlarmModelVersionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateDetectorModelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorModelDefinition
        case detectorModelDescription
        case evaluationMethod
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorModelDefinition = self.detectorModelDefinition {
            try encodeContainer.encode(detectorModelDefinition, forKey: .detectorModelDefinition)
        }
        if let detectorModelDescription = self.detectorModelDescription {
            try encodeContainer.encode(detectorModelDescription, forKey: .detectorModelDescription)
        }
        if let evaluationMethod = self.evaluationMethod {
            try encodeContainer.encode(evaluationMethod.rawValue, forKey: .evaluationMethod)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

extension UpdateDetectorModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorModelName = detectorModelName else {
            return nil
        }
        return "/detector-models/\(detectorModelName.urlPercentEncoding())"
    }
}

public struct UpdateDetectorModelInput: Swift.Equatable {
    /// Information that defines how a detector operates.
    /// This member is required.
    public var detectorModelDefinition: IoTEventsClientTypes.DetectorModelDefinition?
    /// A brief description of the detector model.
    public var detectorModelDescription: Swift.String?
    /// The name of the detector model that is updated.
    /// This member is required.
    public var detectorModelName: Swift.String?
    /// Information about the order in which events are evaluated and how actions are executed.
    public var evaluationMethod: IoTEventsClientTypes.EvaluationMethod?
    /// The ARN of the role that grants permission to AWS IoT Events to perform its operations.
    /// This member is required.
    public var roleArn: Swift.String?

    public init (
        detectorModelDefinition: IoTEventsClientTypes.DetectorModelDefinition? = nil,
        detectorModelDescription: Swift.String? = nil,
        detectorModelName: Swift.String? = nil,
        evaluationMethod: IoTEventsClientTypes.EvaluationMethod? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.detectorModelDefinition = detectorModelDefinition
        self.detectorModelDescription = detectorModelDescription
        self.detectorModelName = detectorModelName
        self.evaluationMethod = evaluationMethod
        self.roleArn = roleArn
    }
}

struct UpdateDetectorModelInputBody: Swift.Equatable {
    let detectorModelDefinition: IoTEventsClientTypes.DetectorModelDefinition?
    let detectorModelDescription: Swift.String?
    let roleArn: Swift.String?
    let evaluationMethod: IoTEventsClientTypes.EvaluationMethod?
}

extension UpdateDetectorModelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorModelDefinition
        case detectorModelDescription
        case evaluationMethod
        case roleArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelDefinitionDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.DetectorModelDefinition.self, forKey: .detectorModelDefinition)
        detectorModelDefinition = detectorModelDefinitionDecoded
        let detectorModelDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorModelDescription)
        detectorModelDescription = detectorModelDescriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let evaluationMethodDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.EvaluationMethod.self, forKey: .evaluationMethod)
        evaluationMethod = evaluationMethodDecoded
    }
}

extension UpdateDetectorModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDetectorModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDetectorModelOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDetectorModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateDetectorModelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.detectorModelConfiguration = output.detectorModelConfiguration
        } else {
            self.detectorModelConfiguration = nil
        }
    }
}

public struct UpdateDetectorModelOutputResponse: Swift.Equatable {
    /// Information about how the detector model is configured.
    public var detectorModelConfiguration: IoTEventsClientTypes.DetectorModelConfiguration?

    public init (
        detectorModelConfiguration: IoTEventsClientTypes.DetectorModelConfiguration? = nil
    )
    {
        self.detectorModelConfiguration = detectorModelConfiguration
    }
}

struct UpdateDetectorModelOutputResponseBody: Swift.Equatable {
    let detectorModelConfiguration: IoTEventsClientTypes.DetectorModelConfiguration?
}

extension UpdateDetectorModelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorModelConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelConfigurationDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.DetectorModelConfiguration.self, forKey: .detectorModelConfiguration)
        detectorModelConfiguration = detectorModelConfigurationDecoded
    }
}

extension UpdateInputInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputDefinition
        case inputDescription
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputDefinition = self.inputDefinition {
            try encodeContainer.encode(inputDefinition, forKey: .inputDefinition)
        }
        if let inputDescription = self.inputDescription {
            try encodeContainer.encode(inputDescription, forKey: .inputDescription)
        }
    }
}

extension UpdateInputInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let inputName = inputName else {
            return nil
        }
        return "/inputs/\(inputName.urlPercentEncoding())"
    }
}

public struct UpdateInputInput: Swift.Equatable {
    /// The definition of the input.
    /// This member is required.
    public var inputDefinition: IoTEventsClientTypes.InputDefinition?
    /// A brief description of the input.
    public var inputDescription: Swift.String?
    /// The name of the input you want to update.
    /// This member is required.
    public var inputName: Swift.String?

    public init (
        inputDefinition: IoTEventsClientTypes.InputDefinition? = nil,
        inputDescription: Swift.String? = nil,
        inputName: Swift.String? = nil
    )
    {
        self.inputDefinition = inputDefinition
        self.inputDescription = inputDescription
        self.inputName = inputName
    }
}

struct UpdateInputInputBody: Swift.Equatable {
    let inputDescription: Swift.String?
    let inputDefinition: IoTEventsClientTypes.InputDefinition?
}

extension UpdateInputInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputDefinition
        case inputDescription
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputDescription)
        inputDescription = inputDescriptionDecoded
        let inputDefinitionDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.InputDefinition.self, forKey: .inputDefinition)
        inputDefinition = inputDefinitionDecoded
    }
}

extension UpdateInputOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateInputOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateInputOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateInputOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateInputOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.inputConfiguration = output.inputConfiguration
        } else {
            self.inputConfiguration = nil
        }
    }
}

public struct UpdateInputOutputResponse: Swift.Equatable {
    /// Information about the configuration of the input.
    public var inputConfiguration: IoTEventsClientTypes.InputConfiguration?

    public init (
        inputConfiguration: IoTEventsClientTypes.InputConfiguration? = nil
    )
    {
        self.inputConfiguration = inputConfiguration
    }
}

struct UpdateInputOutputResponseBody: Swift.Equatable {
    let inputConfiguration: IoTEventsClientTypes.InputConfiguration?
}

extension UpdateInputOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputConfigurationDecoded = try containerValues.decodeIfPresent(IoTEventsClientTypes.InputConfiguration.self, forKey: .inputConfiguration)
        inputConfiguration = inputConfigurationDecoded
    }
}
