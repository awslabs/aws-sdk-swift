//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

public struct PutLoggingOptionsOutput {

    public init() { }
}

extension IoTEventsClientTypes {
    /// Specifies whether to get notified for alarm state changes.
    public struct AcknowledgeFlow {
        /// The value must be TRUE or FALSE. If TRUE, you receive a notification when the alarm state changes. You must choose to acknowledge the notification before the alarm state can return to NORMAL. If FALSE, you won't receive notifications. The alarm automatically changes to the NORMAL state when the input property value returns to the specified range.
        /// This member is required.
        public var enabled: Swift.Bool?

        public init(
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }

}

extension IoTEventsClientTypes {
    /// Information needed to clear the timer.
    public struct ClearTimerAction {
        /// The name of the timer to clear.
        /// This member is required.
        public var timerName: Swift.String?

        public init(
            timerName: Swift.String? = nil
        )
        {
            self.timerName = timerName
        }
    }

}

extension IoTEventsClientTypes {

    public enum PayloadType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case json
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [PayloadType] {
            return [
                .json,
                .string
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTEventsClientTypes {
    /// Information needed to configure the payload. By default, AWS IoT Events generates a standard payload in JSON for any action. This action payload contains all attribute-value pairs that have the information about the detector model instance and the event triggered the action. To configure the action payload, you can use contentExpression.
    public struct Payload {
        /// The content of the payload. You can use a string expression that includes quoted strings (''), variables ($variable.), input values ($input..), string concatenations, and quoted strings that contain ${} as the content. The recommended maximum size of a content expression is 1 KB.
        /// This member is required.
        public var contentExpression: Swift.String?
        /// The value of the payload type can be either STRING or JSON.
        /// This member is required.
        public var type: IoTEventsClientTypes.PayloadType?

        public init(
            contentExpression: Swift.String? = nil,
            type: IoTEventsClientTypes.PayloadType? = nil
        )
        {
            self.contentExpression = contentExpression
            self.type = type
        }
    }

}

extension IoTEventsClientTypes {
    /// Defines an action to write to the Amazon DynamoDB table that you created. The standard action payload contains all the information about the detector model instance and the event that triggered the action. You can customize the [payload](https://docs.aws.amazon.com/iotevents/latest/apireference/API_Payload.html). One column of the DynamoDB table receives all attribute-value pairs in the payload that you specify. You must use expressions for all parameters in DynamoDBAction. The expressions accept literals, operators, functions, references, and substitution templates. Examples
    ///
    /// * For literal values, the expressions must contain single quotes. For example, the value for the hashKeyType parameter can be 'STRING'.
    ///
    /// * For references, you must specify either variables or input values. For example, the value for the hashKeyField parameter can be $input.GreenhouseInput.name.
    ///
    /// * For a substitution template, you must use ${}, and the template must be in single quotes. A substitution template can also contain a combination of literals, operators, functions, references, and substitution templates. In the following example, the value for the hashKeyValue parameter uses a substitution template. '${$input.GreenhouseInput.temperature * 6 / 5 + 32} in Fahrenheit'
    ///
    /// * For a string concatenation, you must use +. A string concatenation can also contain a combination of literals, operators, functions, references, and substitution templates. In the following example, the value for the tableName parameter uses a string concatenation. 'GreenhouseTemperatureTable ' + $input.GreenhouseInput.date
    ///
    ///
    /// For more information, see [Expressions](https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html) in the AWS IoT Events Developer Guide. If the defined payload type is a string, DynamoDBAction writes non-JSON data to the DynamoDB table as binary data. The DynamoDB console displays the data as Base64-encoded text. The value for the payloadField parameter is _raw.
    public struct DynamoDBAction {
        /// The name of the hash key (also called the partition key). The hashKeyField value must match the partition key of the target DynamoDB table.
        /// This member is required.
        public var hashKeyField: Swift.String?
        /// The data type for the hash key (also called the partition key). You can specify the following values:
        ///
        /// * 'STRING' - The hash key is a string.
        ///
        /// * 'NUMBER' - The hash key is a number.
        ///
        ///
        /// If you don't specify hashKeyType, the default value is 'STRING'.
        public var hashKeyType: Swift.String?
        /// The value of the hash key (also called the partition key).
        /// This member is required.
        public var hashKeyValue: Swift.String?
        /// The type of operation to perform. You can specify the following values:
        ///
        /// * 'INSERT' - Insert data as a new item into the DynamoDB table. This item uses the specified hash key as a partition key. If you specified a range key, the item uses the range key as a sort key.
        ///
        /// * 'UPDATE' - Update an existing item of the DynamoDB table with new data. This item's partition key must match the specified hash key. If you specified a range key, the range key must match the item's sort key.
        ///
        /// * 'DELETE' - Delete an existing item of the DynamoDB table. This item's partition key must match the specified hash key. If you specified a range key, the range key must match the item's sort key.
        ///
        ///
        /// If you don't specify this parameter, AWS IoT Events triggers the 'INSERT' operation.
        public var operation: Swift.String?
        /// Information needed to configure the payload. By default, AWS IoT Events generates a standard payload in JSON for any action. This action payload contains all attribute-value pairs that have the information about the detector model instance and the event triggered the action. To configure the action payload, you can use contentExpression.
        public var payload: IoTEventsClientTypes.Payload?
        /// The name of the DynamoDB column that receives the action payload. If you don't specify this parameter, the name of the DynamoDB column is payload.
        public var payloadField: Swift.String?
        /// The name of the range key (also called the sort key). The rangeKeyField value must match the sort key of the target DynamoDB table.
        public var rangeKeyField: Swift.String?
        /// The data type for the range key (also called the sort key), You can specify the following values:
        ///
        /// * 'STRING' - The range key is a string.
        ///
        /// * 'NUMBER' - The range key is number.
        ///
        ///
        /// If you don't specify rangeKeyField, the default value is 'STRING'.
        public var rangeKeyType: Swift.String?
        /// The value of the range key (also called the sort key).
        public var rangeKeyValue: Swift.String?
        /// The name of the DynamoDB table. The tableName value must match the table name of the target DynamoDB table.
        /// This member is required.
        public var tableName: Swift.String?

        public init(
            hashKeyField: Swift.String? = nil,
            hashKeyType: Swift.String? = nil,
            hashKeyValue: Swift.String? = nil,
            operation: Swift.String? = nil,
            payload: IoTEventsClientTypes.Payload? = nil,
            payloadField: Swift.String? = nil,
            rangeKeyField: Swift.String? = nil,
            rangeKeyType: Swift.String? = nil,
            rangeKeyValue: Swift.String? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.hashKeyField = hashKeyField
            self.hashKeyType = hashKeyType
            self.hashKeyValue = hashKeyValue
            self.operation = operation
            self.payload = payload
            self.payloadField = payloadField
            self.rangeKeyField = rangeKeyField
            self.rangeKeyType = rangeKeyType
            self.rangeKeyValue = rangeKeyValue
            self.tableName = tableName
        }
    }

}

extension IoTEventsClientTypes {
    /// Defines an action to write to the Amazon DynamoDB table that you created. The default action payload contains all the information about the detector model instance and the event that triggered the action. You can customize the [payload](https://docs.aws.amazon.com/iotevents/latest/apireference/API_Payload.html). A separate column of the DynamoDB table receives one attribute-value pair in the payload that you specify. You must use expressions for all parameters in DynamoDBv2Action. The expressions accept literals, operators, functions, references, and substitution templates. Examples
    ///
    /// * For literal values, the expressions must contain single quotes. For example, the value for the tableName parameter can be 'GreenhouseTemperatureTable'.
    ///
    /// * For references, you must specify either variables or input values. For example, the value for the tableName parameter can be $variable.ddbtableName.
    ///
    /// * For a substitution template, you must use ${}, and the template must be in single quotes. A substitution template can also contain a combination of literals, operators, functions, references, and substitution templates. In the following example, the value for the contentExpression parameter in Payload uses a substitution template. '{\"sensorID\": \"${$input.GreenhouseInput.sensor_id}\", \"temperature\": \"${$input.GreenhouseInput.temperature * 9 / 5 + 32}\"}'
    ///
    /// * For a string concatenation, you must use +. A string concatenation can also contain a combination of literals, operators, functions, references, and substitution templates. In the following example, the value for the tableName parameter uses a string concatenation. 'GreenhouseTemperatureTable ' + $input.GreenhouseInput.date
    ///
    ///
    /// For more information, see [Expressions](https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html) in the AWS IoT Events Developer Guide. The value for the type parameter in Payload must be JSON.
    public struct DynamoDBv2Action {
        /// Information needed to configure the payload. By default, AWS IoT Events generates a standard payload in JSON for any action. This action payload contains all attribute-value pairs that have the information about the detector model instance and the event triggered the action. To configure the action payload, you can use contentExpression.
        public var payload: IoTEventsClientTypes.Payload?
        /// The name of the DynamoDB table.
        /// This member is required.
        public var tableName: Swift.String?

        public init(
            payload: IoTEventsClientTypes.Payload? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.payload = payload
            self.tableName = tableName
        }
    }

}

extension IoTEventsClientTypes {
    /// Sends information about the detector model instance and the event that triggered the action to an Amazon Kinesis Data Firehose delivery stream.
    public struct FirehoseAction {
        /// The name of the Kinesis Data Firehose delivery stream where the data is written.
        /// This member is required.
        public var deliveryStreamName: Swift.String?
        /// You can configure the action payload when you send a message to an Amazon Kinesis Data Firehose delivery stream.
        public var payload: IoTEventsClientTypes.Payload?
        /// A character separator that is used to separate records written to the Kinesis Data Firehose delivery stream. Valid values are: '\n' (newline), '\t' (tab), '\r\n' (Windows newline), ',' (comma).
        public var separator: Swift.String?

        public init(
            deliveryStreamName: Swift.String? = nil,
            payload: IoTEventsClientTypes.Payload? = nil,
            separator: Swift.String? = nil
        )
        {
            self.deliveryStreamName = deliveryStreamName
            self.payload = payload
            self.separator = separator
        }
    }

}

extension IoTEventsClientTypes {
    /// Sends an AWS IoT Events input, passing in information about the detector model instance and the event that triggered the action.
    public struct IotEventsAction {
        /// The name of the AWS IoT Events input where the data is sent.
        /// This member is required.
        public var inputName: Swift.String?
        /// You can configure the action payload when you send a message to an AWS IoT Events input.
        public var payload: IoTEventsClientTypes.Payload?

        public init(
            inputName: Swift.String? = nil,
            payload: IoTEventsClientTypes.Payload? = nil
        )
        {
            self.inputName = inputName
            self.payload = payload
        }
    }

}

extension IoTEventsClientTypes {
    /// A structure that contains timestamp information. For more information, see [TimeInNanos](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_TimeInNanos.html) in the AWS IoT SiteWise API Reference. You must use expressions for all parameters in AssetPropertyTimestamp. The expressions accept literals, operators, functions, references, and substitution templates. Examples
    ///
    /// * For literal values, the expressions must contain single quotes. For example, the value for the timeInSeconds parameter can be '1586400675'.
    ///
    /// * For references, you must specify either variables or input values. For example, the value for the offsetInNanos parameter can be $variable.time.
    ///
    /// * For a substitution template, you must use ${}, and the template must be in single quotes. A substitution template can also contain a combination of literals, operators, functions, references, and substitution templates. In the following example, the value for the timeInSeconds parameter uses a substitution template. '${$input.TemperatureInput.sensorData.timestamp / 1000}'
    ///
    ///
    /// For more information, see [Expressions](https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html) in the AWS IoT Events Developer Guide.
    public struct AssetPropertyTimestamp {
        /// The nanosecond offset converted from timeInSeconds. The valid range is between 0-999999999.
        public var offsetInNanos: Swift.String?
        /// The timestamp, in seconds, in the Unix epoch format. The valid range is between 1-31556889864403199.
        /// This member is required.
        public var timeInSeconds: Swift.String?

        public init(
            offsetInNanos: Swift.String? = nil,
            timeInSeconds: Swift.String? = nil
        )
        {
            self.offsetInNanos = offsetInNanos
            self.timeInSeconds = timeInSeconds
        }
    }

}

extension IoTEventsClientTypes {
    /// A structure that contains an asset property value. For more information, see [Variant](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_Variant.html) in the AWS IoT SiteWise API Reference. You must use expressions for all parameters in AssetPropertyVariant. The expressions accept literals, operators, functions, references, and substitution templates. Examples
    ///
    /// * For literal values, the expressions must contain single quotes. For example, the value for the integerValue parameter can be '100'.
    ///
    /// * For references, you must specify either variables or parameters. For example, the value for the booleanValue parameter can be $variable.offline.
    ///
    /// * For a substitution template, you must use ${}, and the template must be in single quotes. A substitution template can also contain a combination of literals, operators, functions, references, and substitution templates. In the following example, the value for the doubleValue parameter uses a substitution template. '${$input.TemperatureInput.sensorData.temperature * 6 / 5 + 32}'
    ///
    ///
    /// For more information, see [Expressions](https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html) in the AWS IoT Events Developer Guide. You must specify one of the following value types, depending on the dataType of the specified asset property. For more information, see [AssetProperty](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_AssetProperty.html) in the AWS IoT SiteWise API Reference.
    public struct AssetPropertyVariant {
        /// The asset property value is a Boolean value that must be 'TRUE' or 'FALSE'. You must use an expression, and the evaluated result should be a Boolean value.
        public var booleanValue: Swift.String?
        /// The asset property value is a double. You must use an expression, and the evaluated result should be a double.
        public var doubleValue: Swift.String?
        /// The asset property value is an integer. You must use an expression, and the evaluated result should be an integer.
        public var integerValue: Swift.String?
        /// The asset property value is a string. You must use an expression, and the evaluated result should be a string.
        public var stringValue: Swift.String?

        public init(
            booleanValue: Swift.String? = nil,
            doubleValue: Swift.String? = nil,
            integerValue: Swift.String? = nil,
            stringValue: Swift.String? = nil
        )
        {
            self.booleanValue = booleanValue
            self.doubleValue = doubleValue
            self.integerValue = integerValue
            self.stringValue = stringValue
        }
    }

}

extension IoTEventsClientTypes {
    /// A structure that contains value information. For more information, see [AssetPropertyValue](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_AssetPropertyValue.html) in the AWS IoT SiteWise API Reference. You must use expressions for all parameters in AssetPropertyValue. The expressions accept literals, operators, functions, references, and substitution templates. Examples
    ///
    /// * For literal values, the expressions must contain single quotes. For example, the value for the quality parameter can be 'GOOD'.
    ///
    /// * For references, you must specify either variables or input values. For example, the value for the quality parameter can be $input.TemperatureInput.sensorData.quality.
    ///
    ///
    /// For more information, see [Expressions](https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html) in the AWS IoT Events Developer Guide.
    public struct AssetPropertyValue {
        /// The quality of the asset property value. The value must be 'GOOD', 'BAD', or 'UNCERTAIN'.
        public var quality: Swift.String?
        /// The timestamp associated with the asset property value. The default is the current event time.
        public var timestamp: IoTEventsClientTypes.AssetPropertyTimestamp?
        /// The value to send to an asset property.
        public var value: IoTEventsClientTypes.AssetPropertyVariant?

        public init(
            quality: Swift.String? = nil,
            timestamp: IoTEventsClientTypes.AssetPropertyTimestamp? = nil,
            value: IoTEventsClientTypes.AssetPropertyVariant? = nil
        )
        {
            self.quality = quality
            self.timestamp = timestamp
            self.value = value
        }
    }

}

extension IoTEventsClientTypes {
    /// Sends information about the detector model instance and the event that triggered the action to a specified asset property in AWS IoT SiteWise. You must use expressions for all parameters in IotSiteWiseAction. The expressions accept literals, operators, functions, references, and substitutions templates. Examples
    ///
    /// * For literal values, the expressions must contain single quotes. For example, the value for the propertyAlias parameter can be '/company/windfarm/3/turbine/7/temperature'.
    ///
    /// * For references, you must specify either variables or input values. For example, the value for the assetId parameter can be $input.TurbineInput.assetId1.
    ///
    /// * For a substitution template, you must use ${}, and the template must be in single quotes. A substitution template can also contain a combination of literals, operators, functions, references, and substitution templates. In the following example, the value for the propertyAlias parameter uses a substitution template. 'company/windfarm/${$input.TemperatureInput.sensorData.windfarmID}/turbine/ ${$input.TemperatureInput.sensorData.turbineID}/temperature'
    ///
    ///
    /// You must specify either propertyAlias or both assetId and propertyId to identify the target asset property in AWS IoT SiteWise. For more information, see [Expressions](https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html) in the AWS IoT Events Developer Guide.
    public struct IotSiteWiseAction {
        /// The ID of the asset that has the specified property.
        public var assetId: Swift.String?
        /// A unique identifier for this entry. You can use the entry ID to track which data entry causes an error in case of failure. The default is a new unique identifier.
        public var entryId: Swift.String?
        /// The alias of the asset property.
        public var propertyAlias: Swift.String?
        /// The ID of the asset property.
        public var propertyId: Swift.String?
        /// The value to send to the asset property. This value contains timestamp, quality, and value (TQV) information.
        public var propertyValue: IoTEventsClientTypes.AssetPropertyValue?

        public init(
            assetId: Swift.String? = nil,
            entryId: Swift.String? = nil,
            propertyAlias: Swift.String? = nil,
            propertyId: Swift.String? = nil,
            propertyValue: IoTEventsClientTypes.AssetPropertyValue? = nil
        )
        {
            self.assetId = assetId
            self.entryId = entryId
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.propertyValue = propertyValue
        }
    }

}

extension IoTEventsClientTypes {
    /// Information required to publish the MQTT message through the AWS IoT message broker.
    public struct IotTopicPublishAction {
        /// The MQTT topic of the message. You can use a string expression that includes variables ($variable.) and input values ($input..) as the topic string.
        /// This member is required.
        public var mqttTopic: Swift.String?
        /// You can configure the action payload when you publish a message to an AWS IoT Core topic.
        public var payload: IoTEventsClientTypes.Payload?

        public init(
            mqttTopic: Swift.String? = nil,
            payload: IoTEventsClientTypes.Payload? = nil
        )
        {
            self.mqttTopic = mqttTopic
            self.payload = payload
        }
    }

}

extension IoTEventsClientTypes {
    /// Calls a Lambda function, passing in information about the detector model instance and the event that triggered the action.
    public struct LambdaAction {
        /// The ARN of the Lambda function that is executed.
        /// This member is required.
        public var functionArn: Swift.String?
        /// You can configure the action payload when you send a message to a Lambda function.
        public var payload: IoTEventsClientTypes.Payload?

        public init(
            functionArn: Swift.String? = nil,
            payload: IoTEventsClientTypes.Payload? = nil
        )
        {
            self.functionArn = functionArn
            self.payload = payload
        }
    }

}

extension IoTEventsClientTypes {
    /// Information required to reset the timer. The timer is reset to the previously evaluated result of the duration. The duration expression isn't reevaluated when you reset the timer.
    public struct ResetTimerAction {
        /// The name of the timer to reset.
        /// This member is required.
        public var timerName: Swift.String?

        public init(
            timerName: Swift.String? = nil
        )
        {
            self.timerName = timerName
        }
    }

}

extension IoTEventsClientTypes {
    /// Information needed to set the timer.
    public struct SetTimerAction {
        /// The duration of the timer, in seconds. You can use a string expression that includes numbers, variables ($variable.), and input values ($input..) as the duration. The range of the duration is 1-31622400 seconds. To ensure accuracy, the minimum duration is 60 seconds. The evaluated result of the duration is rounded down to the nearest whole number.
        public var durationExpression: Swift.String?
        /// The number of seconds until the timer expires. The minimum value is 60 seconds to ensure accuracy. The maximum value is 31622400 seconds.
        @available(*, deprecated, message: "seconds is deprecated. You can use durationExpression for SetTimerAction. The value of seconds can be used as a string expression for durationExpression.")
        public var seconds: Swift.Int?
        /// The name of the timer.
        /// This member is required.
        public var timerName: Swift.String?

        public init(
            durationExpression: Swift.String? = nil,
            seconds: Swift.Int? = nil,
            timerName: Swift.String? = nil
        )
        {
            self.durationExpression = durationExpression
            self.seconds = seconds
            self.timerName = timerName
        }
    }

}

extension IoTEventsClientTypes {
    /// Information about the variable and its new value.
    public struct SetVariableAction {
        /// The new value of the variable.
        /// This member is required.
        public var value: Swift.String?
        /// The name of the variable.
        /// This member is required.
        public var variableName: Swift.String?

        public init(
            value: Swift.String? = nil,
            variableName: Swift.String? = nil
        )
        {
            self.value = value
            self.variableName = variableName
        }
    }

}

extension IoTEventsClientTypes {
    /// Information required to publish the Amazon SNS message.
    public struct SNSTopicPublishAction {
        /// You can configure the action payload when you send a message as an Amazon SNS push notification.
        public var payload: IoTEventsClientTypes.Payload?
        /// The ARN of the Amazon SNS target where the message is sent.
        /// This member is required.
        public var targetArn: Swift.String?

        public init(
            payload: IoTEventsClientTypes.Payload? = nil,
            targetArn: Swift.String? = nil
        )
        {
            self.payload = payload
            self.targetArn = targetArn
        }
    }

}

extension IoTEventsClientTypes {
    /// Sends information about the detector model instance and the event that triggered the action to an Amazon SQS queue.
    public struct SqsAction {
        /// You can configure the action payload when you send a message to an Amazon SQS queue.
        public var payload: IoTEventsClientTypes.Payload?
        /// The URL of the SQS queue where the data is written.
        /// This member is required.
        public var queueUrl: Swift.String?
        /// Set this to TRUE if you want the data to be base-64 encoded before it is written to the queue. Otherwise, set this to FALSE.
        public var useBase64: Swift.Bool?

        public init(
            payload: IoTEventsClientTypes.Payload? = nil,
            queueUrl: Swift.String? = nil,
            useBase64: Swift.Bool? = nil
        )
        {
            self.payload = payload
            self.queueUrl = queueUrl
            self.useBase64 = useBase64
        }
    }

}

extension IoTEventsClientTypes {
    /// An action to be performed when the condition is TRUE.
    public struct Action {
        /// Information needed to clear the timer.
        public var clearTimer: IoTEventsClientTypes.ClearTimerAction?
        /// Writes to the DynamoDB table that you created. The default action payload contains all attribute-value pairs that have the information about the detector model instance and the event that triggered the action. You can customize the [payload](https://docs.aws.amazon.com/iotevents/latest/apireference/API_Payload.html). One column of the DynamoDB table receives all attribute-value pairs in the payload that you specify. For more information, see [Actions](https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-event-actions.html) in AWS IoT Events Developer Guide.
        public var dynamoDB: IoTEventsClientTypes.DynamoDBAction?
        /// Writes to the DynamoDB table that you created. The default action payload contains all attribute-value pairs that have the information about the detector model instance and the event that triggered the action. You can customize the [payload](https://docs.aws.amazon.com/iotevents/latest/apireference/API_Payload.html). A separate column of the DynamoDB table receives one attribute-value pair in the payload that you specify. For more information, see [Actions](https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-event-actions.html) in AWS IoT Events Developer Guide.
        public var dynamoDBv2: IoTEventsClientTypes.DynamoDBv2Action?
        /// Sends information about the detector model instance and the event that triggered the action to an Amazon Kinesis Data Firehose delivery stream.
        public var firehose: IoTEventsClientTypes.FirehoseAction?
        /// Sends AWS IoT Events input, which passes information about the detector model instance and the event that triggered the action.
        public var iotEvents: IoTEventsClientTypes.IotEventsAction?
        /// Sends information about the detector model instance and the event that triggered the action to an asset property in AWS IoT SiteWise .
        public var iotSiteWise: IoTEventsClientTypes.IotSiteWiseAction?
        /// Publishes an MQTT message with the given topic to the AWS IoT message broker.
        public var iotTopicPublish: IoTEventsClientTypes.IotTopicPublishAction?
        /// Calls a Lambda function, passing in information about the detector model instance and the event that triggered the action.
        public var lambda: IoTEventsClientTypes.LambdaAction?
        /// Information needed to reset the timer.
        public var resetTimer: IoTEventsClientTypes.ResetTimerAction?
        /// Information needed to set the timer.
        public var setTimer: IoTEventsClientTypes.SetTimerAction?
        /// Sets a variable to a specified value.
        public var setVariable: IoTEventsClientTypes.SetVariableAction?
        /// Sends an Amazon SNS message.
        public var sns: IoTEventsClientTypes.SNSTopicPublishAction?
        /// Sends information about the detector model instance and the event that triggered the action to an Amazon SQS queue.
        public var sqs: IoTEventsClientTypes.SqsAction?

        public init(
            clearTimer: IoTEventsClientTypes.ClearTimerAction? = nil,
            dynamoDB: IoTEventsClientTypes.DynamoDBAction? = nil,
            dynamoDBv2: IoTEventsClientTypes.DynamoDBv2Action? = nil,
            firehose: IoTEventsClientTypes.FirehoseAction? = nil,
            iotEvents: IoTEventsClientTypes.IotEventsAction? = nil,
            iotSiteWise: IoTEventsClientTypes.IotSiteWiseAction? = nil,
            iotTopicPublish: IoTEventsClientTypes.IotTopicPublishAction? = nil,
            lambda: IoTEventsClientTypes.LambdaAction? = nil,
            resetTimer: IoTEventsClientTypes.ResetTimerAction? = nil,
            setTimer: IoTEventsClientTypes.SetTimerAction? = nil,
            setVariable: IoTEventsClientTypes.SetVariableAction? = nil,
            sns: IoTEventsClientTypes.SNSTopicPublishAction? = nil,
            sqs: IoTEventsClientTypes.SqsAction? = nil
        )
        {
            self.clearTimer = clearTimer
            self.dynamoDB = dynamoDB
            self.dynamoDBv2 = dynamoDBv2
            self.firehose = firehose
            self.iotEvents = iotEvents
            self.iotSiteWise = iotSiteWise
            self.iotTopicPublish = iotTopicPublish
            self.lambda = lambda
            self.resetTimer = resetTimer
            self.setTimer = setTimer
            self.setVariable = setVariable
            self.sns = sns
            self.sqs = sqs
        }
    }

}

extension IoTEventsClientTypes {
    /// Specifies one of the following actions to receive notifications when the alarm state changes.
    public struct AlarmAction {
        /// Defines an action to write to the Amazon DynamoDB table that you created. The standard action payload contains all the information about the detector model instance and the event that triggered the action. You can customize the [payload](https://docs.aws.amazon.com/iotevents/latest/apireference/API_Payload.html). One column of the DynamoDB table receives all attribute-value pairs in the payload that you specify. You must use expressions for all parameters in DynamoDBAction. The expressions accept literals, operators, functions, references, and substitution templates. Examples
        ///
        /// * For literal values, the expressions must contain single quotes. For example, the value for the hashKeyType parameter can be 'STRING'.
        ///
        /// * For references, you must specify either variables or input values. For example, the value for the hashKeyField parameter can be $input.GreenhouseInput.name.
        ///
        /// * For a substitution template, you must use ${}, and the template must be in single quotes. A substitution template can also contain a combination of literals, operators, functions, references, and substitution templates. In the following example, the value for the hashKeyValue parameter uses a substitution template. '${$input.GreenhouseInput.temperature * 6 / 5 + 32} in Fahrenheit'
        ///
        /// * For a string concatenation, you must use +. A string concatenation can also contain a combination of literals, operators, functions, references, and substitution templates. In the following example, the value for the tableName parameter uses a string concatenation. 'GreenhouseTemperatureTable ' + $input.GreenhouseInput.date
        ///
        ///
        /// For more information, see [Expressions](https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html) in the AWS IoT Events Developer Guide. If the defined payload type is a string, DynamoDBAction writes non-JSON data to the DynamoDB table as binary data. The DynamoDB console displays the data as Base64-encoded text. The value for the payloadField parameter is _raw.
        public var dynamoDB: IoTEventsClientTypes.DynamoDBAction?
        /// Defines an action to write to the Amazon DynamoDB table that you created. The default action payload contains all the information about the detector model instance and the event that triggered the action. You can customize the [payload](https://docs.aws.amazon.com/iotevents/latest/apireference/API_Payload.html). A separate column of the DynamoDB table receives one attribute-value pair in the payload that you specify. You must use expressions for all parameters in DynamoDBv2Action. The expressions accept literals, operators, functions, references, and substitution templates. Examples
        ///
        /// * For literal values, the expressions must contain single quotes. For example, the value for the tableName parameter can be 'GreenhouseTemperatureTable'.
        ///
        /// * For references, you must specify either variables or input values. For example, the value for the tableName parameter can be $variable.ddbtableName.
        ///
        /// * For a substitution template, you must use ${}, and the template must be in single quotes. A substitution template can also contain a combination of literals, operators, functions, references, and substitution templates. In the following example, the value for the contentExpression parameter in Payload uses a substitution template. '{\"sensorID\": \"${$input.GreenhouseInput.sensor_id}\", \"temperature\": \"${$input.GreenhouseInput.temperature * 9 / 5 + 32}\"}'
        ///
        /// * For a string concatenation, you must use +. A string concatenation can also contain a combination of literals, operators, functions, references, and substitution templates. In the following example, the value for the tableName parameter uses a string concatenation. 'GreenhouseTemperatureTable ' + $input.GreenhouseInput.date
        ///
        ///
        /// For more information, see [Expressions](https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html) in the AWS IoT Events Developer Guide. The value for the type parameter in Payload must be JSON.
        public var dynamoDBv2: IoTEventsClientTypes.DynamoDBv2Action?
        /// Sends information about the detector model instance and the event that triggered the action to an Amazon Kinesis Data Firehose delivery stream.
        public var firehose: IoTEventsClientTypes.FirehoseAction?
        /// Sends an AWS IoT Events input, passing in information about the detector model instance and the event that triggered the action.
        public var iotEvents: IoTEventsClientTypes.IotEventsAction?
        /// Sends information about the detector model instance and the event that triggered the action to a specified asset property in AWS IoT SiteWise. You must use expressions for all parameters in IotSiteWiseAction. The expressions accept literals, operators, functions, references, and substitutions templates. Examples
        ///
        /// * For literal values, the expressions must contain single quotes. For example, the value for the propertyAlias parameter can be '/company/windfarm/3/turbine/7/temperature'.
        ///
        /// * For references, you must specify either variables or input values. For example, the value for the assetId parameter can be $input.TurbineInput.assetId1.
        ///
        /// * For a substitution template, you must use ${}, and the template must be in single quotes. A substitution template can also contain a combination of literals, operators, functions, references, and substitution templates. In the following example, the value for the propertyAlias parameter uses a substitution template. 'company/windfarm/${$input.TemperatureInput.sensorData.windfarmID}/turbine/ ${$input.TemperatureInput.sensorData.turbineID}/temperature'
        ///
        ///
        /// You must specify either propertyAlias or both assetId and propertyId to identify the target asset property in AWS IoT SiteWise. For more information, see [Expressions](https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html) in the AWS IoT Events Developer Guide.
        public var iotSiteWise: IoTEventsClientTypes.IotSiteWiseAction?
        /// Information required to publish the MQTT message through the AWS IoT message broker.
        public var iotTopicPublish: IoTEventsClientTypes.IotTopicPublishAction?
        /// Calls a Lambda function, passing in information about the detector model instance and the event that triggered the action.
        public var lambda: IoTEventsClientTypes.LambdaAction?
        /// Information required to publish the Amazon SNS message.
        public var sns: IoTEventsClientTypes.SNSTopicPublishAction?
        /// Sends information about the detector model instance and the event that triggered the action to an Amazon SQS queue.
        public var sqs: IoTEventsClientTypes.SqsAction?

        public init(
            dynamoDB: IoTEventsClientTypes.DynamoDBAction? = nil,
            dynamoDBv2: IoTEventsClientTypes.DynamoDBv2Action? = nil,
            firehose: IoTEventsClientTypes.FirehoseAction? = nil,
            iotEvents: IoTEventsClientTypes.IotEventsAction? = nil,
            iotSiteWise: IoTEventsClientTypes.IotSiteWiseAction? = nil,
            iotTopicPublish: IoTEventsClientTypes.IotTopicPublishAction? = nil,
            lambda: IoTEventsClientTypes.LambdaAction? = nil,
            sns: IoTEventsClientTypes.SNSTopicPublishAction? = nil,
            sqs: IoTEventsClientTypes.SqsAction? = nil
        )
        {
            self.dynamoDB = dynamoDB
            self.dynamoDBv2 = dynamoDBv2
            self.firehose = firehose
            self.iotEvents = iotEvents
            self.iotSiteWise = iotSiteWise
            self.iotTopicPublish = iotTopicPublish
            self.lambda = lambda
            self.sns = sns
            self.sqs = sqs
        }
    }

}

extension IoTEventsClientTypes {
    /// Specifies the default alarm state. The configuration applies to all alarms that were created based on this alarm model.
    public struct InitializationConfiguration {
        /// The value must be TRUE or FALSE. If FALSE, all alarm instances created based on the alarm model are activated. The default value is TRUE.
        /// This member is required.
        public var disabledOnInitialization: Swift.Bool?

        public init(
            disabledOnInitialization: Swift.Bool? = nil
        )
        {
            self.disabledOnInitialization = disabledOnInitialization
        }
    }

}

extension IoTEventsClientTypes {
    /// Contains the configuration information of alarm state changes.
    public struct AlarmCapabilities {
        /// Specifies whether to get notified for alarm state changes.
        public var acknowledgeFlow: IoTEventsClientTypes.AcknowledgeFlow?
        /// Specifies the default alarm state. The configuration applies to all alarms that were created based on this alarm model.
        public var initializationConfiguration: IoTEventsClientTypes.InitializationConfiguration?

        public init(
            acknowledgeFlow: IoTEventsClientTypes.AcknowledgeFlow? = nil,
            initializationConfiguration: IoTEventsClientTypes.InitializationConfiguration? = nil
        )
        {
            self.acknowledgeFlow = acknowledgeFlow
            self.initializationConfiguration = initializationConfiguration
        }
    }

}

extension IoTEventsClientTypes {
    /// Contains information about one or more alarm actions.
    public struct AlarmEventActions {
        /// Specifies one or more supported actions to receive notifications when the alarm state changes.
        public var alarmActions: [IoTEventsClientTypes.AlarmAction]?

        public init(
            alarmActions: [IoTEventsClientTypes.AlarmAction]? = nil
        )
        {
            self.alarmActions = alarmActions
        }
    }

}

extension IoTEventsClientTypes {
    /// Contains a summary of an alarm model.
    public struct AlarmModelSummary {
        /// The description of the alarm model.
        public var alarmModelDescription: Swift.String?
        /// The name of the alarm model.
        public var alarmModelName: Swift.String?
        /// The time the alarm model was created, in the Unix epoch format.
        public var creationTime: Foundation.Date?

        public init(
            alarmModelDescription: Swift.String? = nil,
            alarmModelName: Swift.String? = nil,
            creationTime: Foundation.Date? = nil
        )
        {
            self.alarmModelDescription = alarmModelDescription
            self.alarmModelName = alarmModelName
            self.creationTime = creationTime
        }
    }

}

extension IoTEventsClientTypes {

    public enum AlarmModelVersionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case activating
        case active
        case failed
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [AlarmModelVersionStatus] {
            return [
                .activating,
                .active,
                .failed,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .activating: return "ACTIVATING"
            case .active: return "ACTIVE"
            case .failed: return "FAILED"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTEventsClientTypes {
    /// Contains a summary of an alarm model version.
    public struct AlarmModelVersionSummary {
        /// The ARN of the alarm model. For more information, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
        public var alarmModelArn: Swift.String?
        /// The name of the alarm model.
        public var alarmModelName: Swift.String?
        /// The version of the alarm model.
        public var alarmModelVersion: Swift.String?
        /// The time the alarm model was created, in the Unix epoch format.
        public var creationTime: Foundation.Date?
        /// The time the alarm model was last updated, in the Unix epoch format.
        public var lastUpdateTime: Foundation.Date?
        /// The ARN of the IAM role that allows the alarm to perform actions and access AWS resources. For more information, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
        public var roleArn: Swift.String?
        /// The status of the alarm model. The status can be one of the following values:
        ///
        /// * ACTIVE - The alarm model is active and it's ready to evaluate data.
        ///
        /// * ACTIVATING - AWS IoT Events is activating your alarm model. Activating an alarm model can take up to a few minutes.
        ///
        /// * INACTIVE - The alarm model is inactive, so it isn't ready to evaluate data. Check your alarm model information and update the alarm model.
        ///
        /// * FAILED - You couldn't create or update the alarm model. Check your alarm model information and try again.
        public var status: IoTEventsClientTypes.AlarmModelVersionStatus?
        /// Contains information about the status of the alarm model version.
        public var statusMessage: Swift.String?

        public init(
            alarmModelArn: Swift.String? = nil,
            alarmModelName: Swift.String? = nil,
            alarmModelVersion: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            lastUpdateTime: Foundation.Date? = nil,
            roleArn: Swift.String? = nil,
            status: IoTEventsClientTypes.AlarmModelVersionStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.alarmModelArn = alarmModelArn
            self.alarmModelName = alarmModelName
            self.alarmModelVersion = alarmModelVersion
            self.creationTime = creationTime
            self.lastUpdateTime = lastUpdateTime
            self.roleArn = roleArn
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension IoTEventsClientTypes {
    /// Specifies an AWS Lambda function to manage alarm notifications. You can create one or use the [AWS Lambda function provided by AWS IoT Events](https://docs.aws.amazon.com/iotevents/latest/developerguide/lambda-support.html).
    public struct NotificationTargetActions {
        /// Calls a Lambda function, passing in information about the detector model instance and the event that triggered the action.
        public var lambdaAction: IoTEventsClientTypes.LambdaAction?

        public init(
            lambdaAction: IoTEventsClientTypes.LambdaAction? = nil
        )
        {
            self.lambdaAction = lambdaAction
        }
    }

}

extension IoTEventsClientTypes {
    /// Contains the subject and message of an email.
    public struct EmailContent {
        /// The message that you want to send. The message can be up to 200 characters.
        public var additionalMessage: Swift.String?
        /// The subject of the email.
        public var subject: Swift.String?

        public init(
            additionalMessage: Swift.String? = nil,
            subject: Swift.String? = nil
        )
        {
            self.additionalMessage = additionalMessage
            self.subject = subject
        }
    }

}

extension IoTEventsClientTypes {
    /// Contains information about your identity source in AWS Single Sign-On. For more information, see the [AWS Single Sign-On User Guide](https://docs.aws.amazon.com/singlesignon/latest/userguide/what-is.html).
    public struct SSOIdentity {
        /// The ID of the AWS SSO identity store.
        /// This member is required.
        public var identityStoreId: Swift.String?
        /// The user ID.
        public var userId: Swift.String?

        public init(
            identityStoreId: Swift.String? = nil,
            userId: Swift.String? = nil
        )
        {
            self.identityStoreId = identityStoreId
            self.userId = userId
        }
    }

}

extension IoTEventsClientTypes {
    /// The information that identifies the recipient.
    public struct RecipientDetail {
        /// The AWS Single Sign-On (AWS SSO) authentication information.
        public var ssoIdentity: IoTEventsClientTypes.SSOIdentity?

        public init(
            ssoIdentity: IoTEventsClientTypes.SSOIdentity? = nil
        )
        {
            self.ssoIdentity = ssoIdentity
        }
    }

}

extension IoTEventsClientTypes {
    /// Contains the information of one or more recipients who receive the emails. You must [add the users that receive emails to your AWS SSO store](https://docs.aws.amazon.com/singlesignon/latest/userguide/addusers.html).
    public struct EmailRecipients {
        /// Specifies one or more recipients who receive the email.
        public var to: [IoTEventsClientTypes.RecipientDetail]?

        public init(
            to: [IoTEventsClientTypes.RecipientDetail]? = nil
        )
        {
            self.to = to
        }
    }

}

extension IoTEventsClientTypes {
    /// Contains the configuration information of email notifications.
    public struct EmailConfiguration {
        /// Contains the subject and message of an email.
        public var content: IoTEventsClientTypes.EmailContent?
        /// The email address that sends emails. If you use the AWS IoT Events managed AWS Lambda function to manage your emails, you must [verify the email address that sends emails in Amazon SES](https://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-email-addresses.html).
        /// This member is required.
        public var from: Swift.String?
        /// Contains the information of one or more recipients who receive the emails. You must [add the users that receive emails to your AWS SSO store](https://docs.aws.amazon.com/singlesignon/latest/userguide/addusers.html).
        /// This member is required.
        public var recipients: IoTEventsClientTypes.EmailRecipients?

        public init(
            content: IoTEventsClientTypes.EmailContent? = nil,
            from: Swift.String? = nil,
            recipients: IoTEventsClientTypes.EmailRecipients? = nil
        )
        {
            self.content = content
            self.from = from
            self.recipients = recipients
        }
    }

}

extension IoTEventsClientTypes {
    /// Contains the configuration information of SMS notifications.
    public struct SMSConfiguration {
        /// The message that you want to send. The message can be up to 200 characters.
        public var additionalMessage: Swift.String?
        /// Specifies one or more recipients who receive the message. You must [add the users that receive SMS messages to your AWS SSO store](https://docs.aws.amazon.com/singlesignon/latest/userguide/addusers.html).
        /// This member is required.
        public var recipients: [IoTEventsClientTypes.RecipientDetail]?
        /// The sender ID.
        public var senderId: Swift.String?

        public init(
            additionalMessage: Swift.String? = nil,
            recipients: [IoTEventsClientTypes.RecipientDetail]? = nil,
            senderId: Swift.String? = nil
        )
        {
            self.additionalMessage = additionalMessage
            self.recipients = recipients
            self.senderId = senderId
        }
    }

}

extension IoTEventsClientTypes {
    /// Contains the notification settings of an alarm model. The settings apply to all alarms that were created based on this alarm model.
    public struct NotificationAction {
        /// Specifies an AWS Lambda function to manage alarm notifications. You can create one or use the [AWS Lambda function provided by AWS IoT Events](https://docs.aws.amazon.com/iotevents/latest/developerguide/lambda-support.html).
        /// This member is required.
        public var action: IoTEventsClientTypes.NotificationTargetActions?
        /// Contains the configuration information of email notifications.
        public var emailConfigurations: [IoTEventsClientTypes.EmailConfiguration]?
        /// Contains the configuration information of SMS notifications.
        public var smsConfigurations: [IoTEventsClientTypes.SMSConfiguration]?

        public init(
            action: IoTEventsClientTypes.NotificationTargetActions? = nil,
            emailConfigurations: [IoTEventsClientTypes.EmailConfiguration]? = nil,
            smsConfigurations: [IoTEventsClientTypes.SMSConfiguration]? = nil
        )
        {
            self.action = action
            self.emailConfigurations = emailConfigurations
            self.smsConfigurations = smsConfigurations
        }
    }

}

extension IoTEventsClientTypes {
    /// Contains information about one or more notification actions.
    public struct AlarmNotification {
        /// Contains the notification settings of an alarm model. The settings apply to all alarms that were created based on this alarm model.
        public var notificationActions: [IoTEventsClientTypes.NotificationAction]?

        public init(
            notificationActions: [IoTEventsClientTypes.NotificationAction]? = nil
        )
        {
            self.notificationActions = notificationActions
        }
    }

}

extension IoTEventsClientTypes {

    public enum ComparisonOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equal
        case greater
        case greaterOrEqual
        case less
        case lessOrEqual
        case notEqual
        case sdkUnknown(Swift.String)

        public static var allCases: [ComparisonOperator] {
            return [
                .equal,
                .greater,
                .greaterOrEqual,
                .less,
                .lessOrEqual,
                .notEqual
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equal: return "EQUAL"
            case .greater: return "GREATER"
            case .greaterOrEqual: return "GREATER_OR_EQUAL"
            case .less: return "LESS"
            case .lessOrEqual: return "LESS_OR_EQUAL"
            case .notEqual: return "NOT_EQUAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTEventsClientTypes {
    /// A rule that compares an input property value to a threshold value with a comparison operator.
    public struct SimpleRule {
        /// The comparison operator.
        /// This member is required.
        public var comparisonOperator: IoTEventsClientTypes.ComparisonOperator?
        /// The value on the left side of the comparison operator. You can specify an AWS IoT Events input attribute as an input property.
        /// This member is required.
        public var inputProperty: Swift.String?
        /// The value on the right side of the comparison operator. You can enter a number or specify an AWS IoT Events input attribute.
        /// This member is required.
        public var threshold: Swift.String?

        public init(
            comparisonOperator: IoTEventsClientTypes.ComparisonOperator? = nil,
            inputProperty: Swift.String? = nil,
            threshold: Swift.String? = nil
        )
        {
            self.comparisonOperator = comparisonOperator
            self.inputProperty = inputProperty
            self.threshold = threshold
        }
    }

}

extension IoTEventsClientTypes {
    /// Defines when your alarm is invoked.
    public struct AlarmRule {
        /// A rule that compares an input property value to a threshold value with a comparison operator.
        public var simpleRule: IoTEventsClientTypes.SimpleRule?

        public init(
            simpleRule: IoTEventsClientTypes.SimpleRule? = nil
        )
        {
            self.simpleRule = simpleRule
        }
    }

}

extension IoTEventsClientTypes {

    public enum AnalysisResultLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case error
        case info
        case warning
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalysisResultLevel] {
            return [
                .error,
                .info,
                .warning
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .info: return "INFO"
            case .warning: return "WARNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTEventsClientTypes {
    /// Contains information that you can use to locate the field in your detector model that the analysis result references.
    public struct AnalysisResultLocation {
        /// A [JsonPath](https://github.com/json-path/JsonPath) expression that identifies the error field in your detector model.
        public var path: Swift.String?

        public init(
            path: Swift.String? = nil
        )
        {
            self.path = path
        }
    }

}

extension IoTEventsClientTypes {
    /// Contains the result of the analysis.
    public struct AnalysisResult {
        /// The severity level of the analysis result. Based on the severity level, analysis results fall into three general categories:
        ///
        /// * INFO - An information result tells you about a significant field in your detector model. This type of result usually doesn't require immediate action.
        ///
        /// * WARNING - A warning result draws special attention to fields that might cause issues for your detector model. We recommend that you review warnings and take necessary actions before you use your detector model in production environments. Otherwise, the detector model might not work as expected.
        ///
        /// * ERROR - An error result notifies you about a problem found in your detector model. You must fix all errors before you can publish your detector model.
        public var level: IoTEventsClientTypes.AnalysisResultLevel?
        /// Contains one or more locations that you can use to locate the fields in your detector model that the analysis result references.
        public var locations: [IoTEventsClientTypes.AnalysisResultLocation]?
        /// Contains additional information about the analysis result.
        public var message: Swift.String?
        /// The type of the analysis result. Analyses fall into the following types based on the validators used to generate the analysis result:
        ///
        /// * supported-actions - You must specify AWS IoT Events supported actions that work with other AWS services in a supported AWS Region.
        ///
        /// * service-limits - Resources or API operations can't exceed service quotas (also known as limits). Update your detector model or request a quota increase.
        ///
        /// * structure - The detector model must follow a structure that AWS IoT Events supports.
        ///
        /// * expression-syntax - Your expression must follow the required syntax.
        ///
        /// * data-type - Data types referenced in the detector model must be compatible.
        ///
        /// * referenced-data - You must define the data referenced in your detector model before you can use the data.
        ///
        /// * referenced-resource - Resources that the detector model uses must be available.
        ///
        ///
        /// For more information, see [Running detector model analyses](https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-analyze-api.html) in the AWS IoT Events Developer Guide.
        public var type: Swift.String?

        public init(
            level: IoTEventsClientTypes.AnalysisResultLevel? = nil,
            locations: [IoTEventsClientTypes.AnalysisResultLocation]? = nil,
            message: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.level = level
            self.locations = locations
            self.message = message
            self.type = type
        }
    }

}

extension IoTEventsClientTypes {

    public enum AnalysisStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case complete
        case failed
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalysisStatus] {
            return [
                .complete,
                .failed,
                .running
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTEventsClientTypes {
    /// The attributes from the JSON payload that are made available by the input. Inputs are derived from messages sent to the AWS IoT Events system using BatchPutMessage. Each such message contains a JSON payload. Those attributes (and their paired values) specified here are available for use in the condition expressions used by detectors.
    public struct Attribute {
        /// An expression that specifies an attribute-value pair in a JSON structure. Use this to specify an attribute from the JSON payload that is made available by the input. Inputs are derived from messages sent to AWS IoT Events (BatchPutMessage). Each such message contains a JSON payload. The attribute (and its paired value) specified here are available for use in the condition expressions used by detectors. Syntax: ....
        /// This member is required.
        public var jsonPath: Swift.String?

        public init(
            jsonPath: Swift.String? = nil
        )
        {
            self.jsonPath = jsonPath
        }
    }

}

/// An internal failure occurred.
public struct InternalFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalFailureException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was invalid.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A limit was exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The resource already exists.
public struct ResourceAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
        /// The ARN of the resource.
        public internal(set) var resourceArn: Swift.String? = nil
        /// The ID of the resource.
        public internal(set) var resourceId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceArn = resourceArn
        self.properties.resourceId = resourceId
    }
}

/// The resource is in use.
public struct ResourceInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUseException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The service is currently unavailable.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request could not be completed due to throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension IoTEventsClientTypes {
    /// Metadata that can be used to manage the resource.
    public struct Tag {
        /// The tag's key.
        /// This member is required.
        public var key: Swift.String?
        /// The tag's value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct CreateAlarmModelInput {
    /// Contains the configuration information of alarm state changes.
    public var alarmCapabilities: IoTEventsClientTypes.AlarmCapabilities?
    /// Contains information about one or more alarm actions.
    public var alarmEventActions: IoTEventsClientTypes.AlarmEventActions?
    /// A description that tells you what the alarm model detects.
    public var alarmModelDescription: Swift.String?
    /// A unique name that helps you identify the alarm model. You can't change this name after you create the alarm model.
    /// This member is required.
    public var alarmModelName: Swift.String?
    /// Contains information about one or more notification actions.
    public var alarmNotification: IoTEventsClientTypes.AlarmNotification?
    /// Defines when your alarm is invoked.
    /// This member is required.
    public var alarmRule: IoTEventsClientTypes.AlarmRule?
    /// An input attribute used as a key to create an alarm. AWS IoT Events routes [inputs](https://docs.aws.amazon.com/iotevents/latest/apireference/API_Input.html) associated with this key to the alarm.
    public var key: Swift.String?
    /// The ARN of the IAM role that allows the alarm to perform actions and access AWS resources. For more information, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A non-negative integer that reflects the severity level of the alarm.
    public var severity: Swift.Int?
    /// A list of key-value pairs that contain metadata for the alarm model. The tags help you manage the alarm model. For more information, see [Tagging your AWS IoT Events resources](https://docs.aws.amazon.com/iotevents/latest/developerguide/tagging-iotevents.html) in the AWS IoT Events Developer Guide. You can create up to 50 tags for one alarm model.
    public var tags: [IoTEventsClientTypes.Tag]?

    public init(
        alarmCapabilities: IoTEventsClientTypes.AlarmCapabilities? = nil,
        alarmEventActions: IoTEventsClientTypes.AlarmEventActions? = nil,
        alarmModelDescription: Swift.String? = nil,
        alarmModelName: Swift.String? = nil,
        alarmNotification: IoTEventsClientTypes.AlarmNotification? = nil,
        alarmRule: IoTEventsClientTypes.AlarmRule? = nil,
        key: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        severity: Swift.Int? = nil,
        tags: [IoTEventsClientTypes.Tag]? = nil
    )
    {
        self.alarmCapabilities = alarmCapabilities
        self.alarmEventActions = alarmEventActions
        self.alarmModelDescription = alarmModelDescription
        self.alarmModelName = alarmModelName
        self.alarmNotification = alarmNotification
        self.alarmRule = alarmRule
        self.key = key
        self.roleArn = roleArn
        self.severity = severity
        self.tags = tags
    }
}

public struct CreateAlarmModelOutput {
    /// The ARN of the alarm model. For more information, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    public var alarmModelArn: Swift.String?
    /// The version of the alarm model.
    public var alarmModelVersion: Swift.String?
    /// The time the alarm model was created, in the Unix epoch format.
    public var creationTime: Foundation.Date?
    /// The time the alarm model was last updated, in the Unix epoch format.
    public var lastUpdateTime: Foundation.Date?
    /// The status of the alarm model. The status can be one of the following values:
    ///
    /// * ACTIVE - The alarm model is active and it's ready to evaluate data.
    ///
    /// * ACTIVATING - AWS IoT Events is activating your alarm model. Activating an alarm model can take up to a few minutes.
    ///
    /// * INACTIVE - The alarm model is inactive, so it isn't ready to evaluate data. Check your alarm model information and update the alarm model.
    ///
    /// * FAILED - You couldn't create or update the alarm model. Check your alarm model information and try again.
    public var status: IoTEventsClientTypes.AlarmModelVersionStatus?

    public init(
        alarmModelArn: Swift.String? = nil,
        alarmModelVersion: Swift.String? = nil,
        creationTime: Foundation.Date? = nil,
        lastUpdateTime: Foundation.Date? = nil,
        status: IoTEventsClientTypes.AlarmModelVersionStatus? = nil
    )
    {
        self.alarmModelArn = alarmModelArn
        self.alarmModelVersion = alarmModelVersion
        self.creationTime = creationTime
        self.lastUpdateTime = lastUpdateTime
        self.status = status
    }
}

extension IoTEventsClientTypes {
    /// Specifies the actions to be performed when the condition evaluates to TRUE.
    public struct Event {
        /// The actions to be performed.
        public var actions: [IoTEventsClientTypes.Action]?
        /// Optional. The Boolean expression that, when TRUE, causes the actions to be performed. If not present, the actions are performed (=TRUE). If the expression result is not a Boolean value, the actions are not performed (=FALSE).
        public var condition: Swift.String?
        /// The name of the event.
        /// This member is required.
        public var eventName: Swift.String?

        public init(
            actions: [IoTEventsClientTypes.Action]? = nil,
            condition: Swift.String? = nil,
            eventName: Swift.String? = nil
        )
        {
            self.actions = actions
            self.condition = condition
            self.eventName = eventName
        }
    }

}

extension IoTEventsClientTypes {
    /// When entering this state, perform these actions if the condition is TRUE.
    public struct OnEnterLifecycle {
        /// Specifies the actions that are performed when the state is entered and the condition is TRUE.
        public var events: [IoTEventsClientTypes.Event]?

        public init(
            events: [IoTEventsClientTypes.Event]? = nil
        )
        {
            self.events = events
        }
    }

}

extension IoTEventsClientTypes {
    /// When exiting this state, perform these actions if the specified condition is TRUE.
    public struct OnExitLifecycle {
        /// Specifies the actions that are performed when the state is exited and the condition is TRUE.
        public var events: [IoTEventsClientTypes.Event]?

        public init(
            events: [IoTEventsClientTypes.Event]? = nil
        )
        {
            self.events = events
        }
    }

}

extension IoTEventsClientTypes {
    /// Specifies the actions performed and the next state entered when a condition evaluates to TRUE.
    public struct TransitionEvent {
        /// The actions to be performed.
        public var actions: [IoTEventsClientTypes.Action]?
        /// Required. A Boolean expression that when TRUE causes the actions to be performed and the nextState to be entered.
        /// This member is required.
        public var condition: Swift.String?
        /// The name of the transition event.
        /// This member is required.
        public var eventName: Swift.String?
        /// The next state to enter.
        /// This member is required.
        public var nextState: Swift.String?

        public init(
            actions: [IoTEventsClientTypes.Action]? = nil,
            condition: Swift.String? = nil,
            eventName: Swift.String? = nil,
            nextState: Swift.String? = nil
        )
        {
            self.actions = actions
            self.condition = condition
            self.eventName = eventName
            self.nextState = nextState
        }
    }

}

extension IoTEventsClientTypes {
    /// Specifies the actions performed when the condition evaluates to TRUE.
    public struct OnInputLifecycle {
        /// Specifies the actions performed when the condition evaluates to TRUE.
        public var events: [IoTEventsClientTypes.Event]?
        /// Specifies the actions performed, and the next state entered, when a condition evaluates to TRUE.
        public var transitionEvents: [IoTEventsClientTypes.TransitionEvent]?

        public init(
            events: [IoTEventsClientTypes.Event]? = nil,
            transitionEvents: [IoTEventsClientTypes.TransitionEvent]? = nil
        )
        {
            self.events = events
            self.transitionEvents = transitionEvents
        }
    }

}

extension IoTEventsClientTypes {
    /// Information that defines a state of a detector.
    public struct State {
        /// When entering this state, perform these actions if the condition is TRUE.
        public var onEnter: IoTEventsClientTypes.OnEnterLifecycle?
        /// When exiting this state, perform these actions if the specified condition is TRUE.
        public var onExit: IoTEventsClientTypes.OnExitLifecycle?
        /// When an input is received and the condition is TRUE, perform the specified actions.
        public var onInput: IoTEventsClientTypes.OnInputLifecycle?
        /// The name of the state.
        /// This member is required.
        public var stateName: Swift.String?

        public init(
            onEnter: IoTEventsClientTypes.OnEnterLifecycle? = nil,
            onExit: IoTEventsClientTypes.OnExitLifecycle? = nil,
            onInput: IoTEventsClientTypes.OnInputLifecycle? = nil,
            stateName: Swift.String? = nil
        )
        {
            self.onEnter = onEnter
            self.onExit = onExit
            self.onInput = onInput
            self.stateName = stateName
        }
    }

}

extension IoTEventsClientTypes {
    /// Information that defines how a detector operates.
    public struct DetectorModelDefinition {
        /// The state that is entered at the creation of each detector (instance).
        /// This member is required.
        public var initialStateName: Swift.String?
        /// Information about the states of the detector.
        /// This member is required.
        public var states: [IoTEventsClientTypes.State]?

        public init(
            initialStateName: Swift.String? = nil,
            states: [IoTEventsClientTypes.State]? = nil
        )
        {
            self.initialStateName = initialStateName
            self.states = states
        }
    }

}

extension IoTEventsClientTypes {

    public enum EvaluationMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case batch
        case serial
        case sdkUnknown(Swift.String)

        public static var allCases: [EvaluationMethod] {
            return [
                .batch,
                .serial
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .batch: return "BATCH"
            case .serial: return "SERIAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateDetectorModelInput {
    /// Information that defines how the detectors operate.
    /// This member is required.
    public var detectorModelDefinition: IoTEventsClientTypes.DetectorModelDefinition?
    /// A brief description of the detector model.
    public var detectorModelDescription: Swift.String?
    /// The name of the detector model.
    /// This member is required.
    public var detectorModelName: Swift.String?
    /// Information about the order in which events are evaluated and how actions are executed.
    public var evaluationMethod: IoTEventsClientTypes.EvaluationMethod?
    /// The input attribute key used to identify a device or system to create a detector (an instance of the detector model) and then to route each input received to the appropriate detector (instance). This parameter uses a JSON-path expression in the message payload of each input to specify the attribute-value pair that is used to identify the device associated with the input.
    public var key: Swift.String?
    /// The ARN of the role that grants permission to AWS IoT Events to perform its operations.
    /// This member is required.
    public var roleArn: Swift.String?
    /// Metadata that can be used to manage the detector model.
    public var tags: [IoTEventsClientTypes.Tag]?

    public init(
        detectorModelDefinition: IoTEventsClientTypes.DetectorModelDefinition? = nil,
        detectorModelDescription: Swift.String? = nil,
        detectorModelName: Swift.String? = nil,
        evaluationMethod: IoTEventsClientTypes.EvaluationMethod? = nil,
        key: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        tags: [IoTEventsClientTypes.Tag]? = nil
    )
    {
        self.detectorModelDefinition = detectorModelDefinition
        self.detectorModelDescription = detectorModelDescription
        self.detectorModelName = detectorModelName
        self.evaluationMethod = evaluationMethod
        self.key = key
        self.roleArn = roleArn
        self.tags = tags
    }
}

extension IoTEventsClientTypes {

    public enum DetectorModelVersionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case activating
        case active
        case deprecated
        case draft
        case failed
        case inactive
        case paused
        case sdkUnknown(Swift.String)

        public static var allCases: [DetectorModelVersionStatus] {
            return [
                .activating,
                .active,
                .deprecated,
                .draft,
                .failed,
                .inactive,
                .paused
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .activating: return "ACTIVATING"
            case .active: return "ACTIVE"
            case .deprecated: return "DEPRECATED"
            case .draft: return "DRAFT"
            case .failed: return "FAILED"
            case .inactive: return "INACTIVE"
            case .paused: return "PAUSED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTEventsClientTypes {
    /// Information about how the detector model is configured.
    public struct DetectorModelConfiguration {
        /// The time the detector model was created.
        public var creationTime: Foundation.Date?
        /// The ARN of the detector model.
        public var detectorModelArn: Swift.String?
        /// A brief description of the detector model.
        public var detectorModelDescription: Swift.String?
        /// The name of the detector model.
        public var detectorModelName: Swift.String?
        /// The version of the detector model.
        public var detectorModelVersion: Swift.String?
        /// Information about the order in which events are evaluated and how actions are executed.
        public var evaluationMethod: IoTEventsClientTypes.EvaluationMethod?
        /// The value used to identify a detector instance. When a device or system sends input, a new detector instance with a unique key value is created. AWS IoT Events can continue to route input to its corresponding detector instance based on this identifying information. This parameter uses a JSON-path expression to select the attribute-value pair in the message payload that is used for identification. To route the message to the correct detector instance, the device must send a message payload that contains the same attribute-value.
        public var key: Swift.String?
        /// The time the detector model was last updated.
        public var lastUpdateTime: Foundation.Date?
        /// The ARN of the role that grants permission to AWS IoT Events to perform its operations.
        public var roleArn: Swift.String?
        /// The status of the detector model.
        public var status: IoTEventsClientTypes.DetectorModelVersionStatus?

        public init(
            creationTime: Foundation.Date? = nil,
            detectorModelArn: Swift.String? = nil,
            detectorModelDescription: Swift.String? = nil,
            detectorModelName: Swift.String? = nil,
            detectorModelVersion: Swift.String? = nil,
            evaluationMethod: IoTEventsClientTypes.EvaluationMethod? = nil,
            key: Swift.String? = nil,
            lastUpdateTime: Foundation.Date? = nil,
            roleArn: Swift.String? = nil,
            status: IoTEventsClientTypes.DetectorModelVersionStatus? = nil
        )
        {
            self.creationTime = creationTime
            self.detectorModelArn = detectorModelArn
            self.detectorModelDescription = detectorModelDescription
            self.detectorModelName = detectorModelName
            self.detectorModelVersion = detectorModelVersion
            self.evaluationMethod = evaluationMethod
            self.key = key
            self.lastUpdateTime = lastUpdateTime
            self.roleArn = roleArn
            self.status = status
        }
    }

}

public struct CreateDetectorModelOutput {
    /// Information about how the detector model is configured.
    public var detectorModelConfiguration: IoTEventsClientTypes.DetectorModelConfiguration?

    public init(
        detectorModelConfiguration: IoTEventsClientTypes.DetectorModelConfiguration? = nil
    )
    {
        self.detectorModelConfiguration = detectorModelConfiguration
    }
}

extension IoTEventsClientTypes {
    /// The definition of the input.
    public struct InputDefinition {
        /// The attributes from the JSON payload that are made available by the input. Inputs are derived from messages sent to the AWS IoT Events system using BatchPutMessage. Each such message contains a JSON payload, and those attributes (and their paired values) specified here are available for use in the condition expressions used by detectors that monitor this input.
        /// This member is required.
        public var attributes: [IoTEventsClientTypes.Attribute]?

        public init(
            attributes: [IoTEventsClientTypes.Attribute]? = nil
        )
        {
            self.attributes = attributes
        }
    }

}

public struct CreateInputInput {
    /// The definition of the input.
    /// This member is required.
    public var inputDefinition: IoTEventsClientTypes.InputDefinition?
    /// A brief description of the input.
    public var inputDescription: Swift.String?
    /// The name you want to give to the input.
    /// This member is required.
    public var inputName: Swift.String?
    /// Metadata that can be used to manage the input.
    public var tags: [IoTEventsClientTypes.Tag]?

    public init(
        inputDefinition: IoTEventsClientTypes.InputDefinition? = nil,
        inputDescription: Swift.String? = nil,
        inputName: Swift.String? = nil,
        tags: [IoTEventsClientTypes.Tag]? = nil
    )
    {
        self.inputDefinition = inputDefinition
        self.inputDescription = inputDescription
        self.inputName = inputName
        self.tags = tags
    }
}

extension IoTEventsClientTypes {

    public enum InputStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case deleting
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [InputStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTEventsClientTypes {
    /// Information about the configuration of an input.
    public struct InputConfiguration {
        /// The time the input was created.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// The ARN of the input.
        /// This member is required.
        public var inputArn: Swift.String?
        /// A brief description of the input.
        public var inputDescription: Swift.String?
        /// The name of the input.
        /// This member is required.
        public var inputName: Swift.String?
        /// The last time the input was updated.
        /// This member is required.
        public var lastUpdateTime: Foundation.Date?
        /// The status of the input.
        /// This member is required.
        public var status: IoTEventsClientTypes.InputStatus?

        public init(
            creationTime: Foundation.Date? = nil,
            inputArn: Swift.String? = nil,
            inputDescription: Swift.String? = nil,
            inputName: Swift.String? = nil,
            lastUpdateTime: Foundation.Date? = nil,
            status: IoTEventsClientTypes.InputStatus? = nil
        )
        {
            self.creationTime = creationTime
            self.inputArn = inputArn
            self.inputDescription = inputDescription
            self.inputName = inputName
            self.lastUpdateTime = lastUpdateTime
            self.status = status
        }
    }

}

public struct CreateInputOutput {
    /// Information about the configuration of the input.
    public var inputConfiguration: IoTEventsClientTypes.InputConfiguration?

    public init(
        inputConfiguration: IoTEventsClientTypes.InputConfiguration? = nil
    )
    {
        self.inputConfiguration = inputConfiguration
    }
}

/// The resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteAlarmModelInput {
    /// The name of the alarm model.
    /// This member is required.
    public var alarmModelName: Swift.String?

    public init(
        alarmModelName: Swift.String? = nil
    )
    {
        self.alarmModelName = alarmModelName
    }
}

public struct DeleteAlarmModelOutput {

    public init() { }
}

public struct DeleteDetectorModelInput {
    /// The name of the detector model to be deleted.
    /// This member is required.
    public var detectorModelName: Swift.String?

    public init(
        detectorModelName: Swift.String? = nil
    )
    {
        self.detectorModelName = detectorModelName
    }
}

public struct DeleteDetectorModelOutput {

    public init() { }
}

public struct DeleteInputInput {
    /// The name of the input to delete.
    /// This member is required.
    public var inputName: Swift.String?

    public init(
        inputName: Swift.String? = nil
    )
    {
        self.inputName = inputName
    }
}

public struct DeleteInputOutput {

    public init() { }
}

public struct DescribeAlarmModelInput {
    /// The name of the alarm model.
    /// This member is required.
    public var alarmModelName: Swift.String?
    /// The version of the alarm model.
    public var alarmModelVersion: Swift.String?

    public init(
        alarmModelName: Swift.String? = nil,
        alarmModelVersion: Swift.String? = nil
    )
    {
        self.alarmModelName = alarmModelName
        self.alarmModelVersion = alarmModelVersion
    }
}

public struct DescribeAlarmModelOutput {
    /// Contains the configuration information of alarm state changes.
    public var alarmCapabilities: IoTEventsClientTypes.AlarmCapabilities?
    /// Contains information about one or more alarm actions.
    public var alarmEventActions: IoTEventsClientTypes.AlarmEventActions?
    /// The ARN of the alarm model. For more information, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    public var alarmModelArn: Swift.String?
    /// The description of the alarm model.
    public var alarmModelDescription: Swift.String?
    /// The name of the alarm model.
    public var alarmModelName: Swift.String?
    /// The version of the alarm model.
    public var alarmModelVersion: Swift.String?
    /// Contains information about one or more notification actions.
    public var alarmNotification: IoTEventsClientTypes.AlarmNotification?
    /// Defines when your alarm is invoked.
    public var alarmRule: IoTEventsClientTypes.AlarmRule?
    /// The time the alarm model was created, in the Unix epoch format.
    public var creationTime: Foundation.Date?
    /// An input attribute used as a key to create an alarm. AWS IoT Events routes [inputs](https://docs.aws.amazon.com/iotevents/latest/apireference/API_Input.html) associated with this key to the alarm.
    public var key: Swift.String?
    /// The time the alarm model was last updated, in the Unix epoch format.
    public var lastUpdateTime: Foundation.Date?
    /// The ARN of the IAM role that allows the alarm to perform actions and access AWS resources. For more information, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    public var roleArn: Swift.String?
    /// A non-negative integer that reflects the severity level of the alarm.
    public var severity: Swift.Int?
    /// The status of the alarm model. The status can be one of the following values:
    ///
    /// * ACTIVE - The alarm model is active and it's ready to evaluate data.
    ///
    /// * ACTIVATING - AWS IoT Events is activating your alarm model. Activating an alarm model can take up to a few minutes.
    ///
    /// * INACTIVE - The alarm model is inactive, so it isn't ready to evaluate data. Check your alarm model information and update the alarm model.
    ///
    /// * FAILED - You couldn't create or update the alarm model. Check your alarm model information and try again.
    public var status: IoTEventsClientTypes.AlarmModelVersionStatus?
    /// Contains information about the status of the alarm model.
    public var statusMessage: Swift.String?

    public init(
        alarmCapabilities: IoTEventsClientTypes.AlarmCapabilities? = nil,
        alarmEventActions: IoTEventsClientTypes.AlarmEventActions? = nil,
        alarmModelArn: Swift.String? = nil,
        alarmModelDescription: Swift.String? = nil,
        alarmModelName: Swift.String? = nil,
        alarmModelVersion: Swift.String? = nil,
        alarmNotification: IoTEventsClientTypes.AlarmNotification? = nil,
        alarmRule: IoTEventsClientTypes.AlarmRule? = nil,
        creationTime: Foundation.Date? = nil,
        key: Swift.String? = nil,
        lastUpdateTime: Foundation.Date? = nil,
        roleArn: Swift.String? = nil,
        severity: Swift.Int? = nil,
        status: IoTEventsClientTypes.AlarmModelVersionStatus? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.alarmCapabilities = alarmCapabilities
        self.alarmEventActions = alarmEventActions
        self.alarmModelArn = alarmModelArn
        self.alarmModelDescription = alarmModelDescription
        self.alarmModelName = alarmModelName
        self.alarmModelVersion = alarmModelVersion
        self.alarmNotification = alarmNotification
        self.alarmRule = alarmRule
        self.creationTime = creationTime
        self.key = key
        self.lastUpdateTime = lastUpdateTime
        self.roleArn = roleArn
        self.severity = severity
        self.status = status
        self.statusMessage = statusMessage
    }
}

public struct DescribeDetectorModelInput {
    /// The name of the detector model.
    /// This member is required.
    public var detectorModelName: Swift.String?
    /// The version of the detector model.
    public var detectorModelVersion: Swift.String?

    public init(
        detectorModelName: Swift.String? = nil,
        detectorModelVersion: Swift.String? = nil
    )
    {
        self.detectorModelName = detectorModelName
        self.detectorModelVersion = detectorModelVersion
    }
}

extension IoTEventsClientTypes {
    /// Information about the detector model.
    public struct DetectorModel {
        /// Information about how the detector is configured.
        public var detectorModelConfiguration: IoTEventsClientTypes.DetectorModelConfiguration?
        /// Information that defines how a detector operates.
        public var detectorModelDefinition: IoTEventsClientTypes.DetectorModelDefinition?

        public init(
            detectorModelConfiguration: IoTEventsClientTypes.DetectorModelConfiguration? = nil,
            detectorModelDefinition: IoTEventsClientTypes.DetectorModelDefinition? = nil
        )
        {
            self.detectorModelConfiguration = detectorModelConfiguration
            self.detectorModelDefinition = detectorModelDefinition
        }
    }

}

public struct DescribeDetectorModelOutput {
    /// Information about the detector model.
    public var detectorModel: IoTEventsClientTypes.DetectorModel?

    public init(
        detectorModel: IoTEventsClientTypes.DetectorModel? = nil
    )
    {
        self.detectorModel = detectorModel
    }
}

public struct DescribeDetectorModelAnalysisInput {
    /// The ID of the analysis result that you want to retrieve.
    /// This member is required.
    public var analysisId: Swift.String?

    public init(
        analysisId: Swift.String? = nil
    )
    {
        self.analysisId = analysisId
    }
}

public struct DescribeDetectorModelAnalysisOutput {
    /// The status of the analysis activity. The status can be one of the following values:
    ///
    /// * RUNNING - AWS IoT Events is analyzing your detector model. This process can take several minutes to complete.
    ///
    /// * COMPLETE - AWS IoT Events finished analyzing your detector model.
    ///
    /// * FAILED - AWS IoT Events couldn't analyze your detector model. Try again later.
    public var status: IoTEventsClientTypes.AnalysisStatus?

    public init(
        status: IoTEventsClientTypes.AnalysisStatus? = nil
    )
    {
        self.status = status
    }
}

public struct DescribeInputInput {
    /// The name of the input.
    /// This member is required.
    public var inputName: Swift.String?

    public init(
        inputName: Swift.String? = nil
    )
    {
        self.inputName = inputName
    }
}

extension IoTEventsClientTypes {
    /// Information about the input.
    public struct Input {
        /// Information about the configuration of an input.
        public var inputConfiguration: IoTEventsClientTypes.InputConfiguration?
        /// The definition of the input.
        public var inputDefinition: IoTEventsClientTypes.InputDefinition?

        public init(
            inputConfiguration: IoTEventsClientTypes.InputConfiguration? = nil,
            inputDefinition: IoTEventsClientTypes.InputDefinition? = nil
        )
        {
            self.inputConfiguration = inputConfiguration
            self.inputDefinition = inputDefinition
        }
    }

}

public struct DescribeInputOutput {
    /// Information about the input.
    public var input: IoTEventsClientTypes.Input?

    public init(
        input: IoTEventsClientTypes.Input? = nil
    )
    {
        self.input = input
    }
}

/// The requested operation is not supported.
public struct UnsupportedOperationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedOperationException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DescribeLoggingOptionsInput {

    public init() { }
}

extension IoTEventsClientTypes {
    /// The detector model and the specific detectors (instances) for which the logging level is given.
    public struct DetectorDebugOption {
        /// The name of the detector model.
        /// This member is required.
        public var detectorModelName: Swift.String?
        /// The value of the input attribute key used to create the detector (the instance of the detector model).
        public var keyValue: Swift.String?

        public init(
            detectorModelName: Swift.String? = nil,
            keyValue: Swift.String? = nil
        )
        {
            self.detectorModelName = detectorModelName
            self.keyValue = keyValue
        }
    }

}

extension IoTEventsClientTypes {

    public enum LoggingLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case debug
        case error
        case info
        case sdkUnknown(Swift.String)

        public static var allCases: [LoggingLevel] {
            return [
                .debug,
                .error,
                .info
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .debug: return "DEBUG"
            case .error: return "ERROR"
            case .info: return "INFO"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTEventsClientTypes {
    /// The values of the AWS IoT Events logging options.
    public struct LoggingOptions {
        /// Information that identifies those detector models and their detectors (instances) for which the logging level is given.
        public var detectorDebugOptions: [IoTEventsClientTypes.DetectorDebugOption]?
        /// If TRUE, logging is enabled for AWS IoT Events.
        /// This member is required.
        public var enabled: Swift.Bool
        /// The logging level.
        /// This member is required.
        public var level: IoTEventsClientTypes.LoggingLevel?
        /// The ARN of the role that grants permission to AWS IoT Events to perform logging.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            detectorDebugOptions: [IoTEventsClientTypes.DetectorDebugOption]? = nil,
            enabled: Swift.Bool = false,
            level: IoTEventsClientTypes.LoggingLevel? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.detectorDebugOptions = detectorDebugOptions
            self.enabled = enabled
            self.level = level
            self.roleArn = roleArn
        }
    }

}

public struct DescribeLoggingOptionsOutput {
    /// The current settings of the AWS IoT Events logging options.
    public var loggingOptions: IoTEventsClientTypes.LoggingOptions?

    public init(
        loggingOptions: IoTEventsClientTypes.LoggingOptions? = nil
    )
    {
        self.loggingOptions = loggingOptions
    }
}

extension IoTEventsClientTypes {
    /// Information about the detector model.
    public struct DetectorModelSummary {
        /// The time the detector model was created.
        public var creationTime: Foundation.Date?
        /// A brief description of the detector model.
        public var detectorModelDescription: Swift.String?
        /// The name of the detector model.
        public var detectorModelName: Swift.String?

        public init(
            creationTime: Foundation.Date? = nil,
            detectorModelDescription: Swift.String? = nil,
            detectorModelName: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.detectorModelDescription = detectorModelDescription
            self.detectorModelName = detectorModelName
        }
    }

}

extension IoTEventsClientTypes {
    /// Information about the detector model version.
    public struct DetectorModelVersionSummary {
        /// The time the detector model version was created.
        public var creationTime: Foundation.Date?
        /// The ARN of the detector model version.
        public var detectorModelArn: Swift.String?
        /// The name of the detector model.
        public var detectorModelName: Swift.String?
        /// The ID of the detector model version.
        public var detectorModelVersion: Swift.String?
        /// Information about the order in which events are evaluated and how actions are executed.
        public var evaluationMethod: IoTEventsClientTypes.EvaluationMethod?
        /// The last time the detector model version was updated.
        public var lastUpdateTime: Foundation.Date?
        /// The ARN of the role that grants the detector model permission to perform its tasks.
        public var roleArn: Swift.String?
        /// The status of the detector model version.
        public var status: IoTEventsClientTypes.DetectorModelVersionStatus?

        public init(
            creationTime: Foundation.Date? = nil,
            detectorModelArn: Swift.String? = nil,
            detectorModelName: Swift.String? = nil,
            detectorModelVersion: Swift.String? = nil,
            evaluationMethod: IoTEventsClientTypes.EvaluationMethod? = nil,
            lastUpdateTime: Foundation.Date? = nil,
            roleArn: Swift.String? = nil,
            status: IoTEventsClientTypes.DetectorModelVersionStatus? = nil
        )
        {
            self.creationTime = creationTime
            self.detectorModelArn = detectorModelArn
            self.detectorModelName = detectorModelName
            self.detectorModelVersion = detectorModelVersion
            self.evaluationMethod = evaluationMethod
            self.lastUpdateTime = lastUpdateTime
            self.roleArn = roleArn
            self.status = status
        }
    }

}

public struct GetDetectorModelAnalysisResultsInput {
    /// The ID of the analysis result that you want to retrieve.
    /// This member is required.
    public var analysisId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token that you can use to return the next set of results.
    public var nextToken: Swift.String?

    public init(
        analysisId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.analysisId = analysisId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetDetectorModelAnalysisResultsOutput {
    /// Contains information about one or more analysis results.
    public var analysisResults: [IoTEventsClientTypes.AnalysisResult]?
    /// The token that you can use to return the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        analysisResults: [IoTEventsClientTypes.AnalysisResult]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.analysisResults = analysisResults
        self.nextToken = nextToken
    }
}

extension IoTEventsClientTypes {
    /// The identifier of the input routed to AWS IoT Events.
    public struct IotEventsInputIdentifier {
        /// The name of the input routed to AWS IoT Events.
        /// This member is required.
        public var inputName: Swift.String?

        public init(
            inputName: Swift.String? = nil
        )
        {
            self.inputName = inputName
        }
    }

}

extension IoTEventsClientTypes {
    /// The asset model property identifer of the input routed from AWS IoT SiteWise.
    public struct IotSiteWiseAssetModelPropertyIdentifier {
        /// The ID of the AWS IoT SiteWise asset model.
        /// This member is required.
        public var assetModelId: Swift.String?
        /// The ID of the AWS IoT SiteWise asset property.
        /// This member is required.
        public var propertyId: Swift.String?

        public init(
            assetModelId: Swift.String? = nil,
            propertyId: Swift.String? = nil
        )
        {
            self.assetModelId = assetModelId
            self.propertyId = propertyId
        }
    }

}

extension IoTEventsClientTypes {
    /// The identifer of the input routed from AWS IoT SiteWise.
    public struct IotSiteWiseInputIdentifier {
        /// The identifier of the AWS IoT SiteWise asset model property.
        public var iotSiteWiseAssetModelPropertyIdentifier: IoTEventsClientTypes.IotSiteWiseAssetModelPropertyIdentifier?

        public init(
            iotSiteWiseAssetModelPropertyIdentifier: IoTEventsClientTypes.IotSiteWiseAssetModelPropertyIdentifier? = nil
        )
        {
            self.iotSiteWiseAssetModelPropertyIdentifier = iotSiteWiseAssetModelPropertyIdentifier
        }
    }

}

extension IoTEventsClientTypes {
    /// The identifer of the input.
    public struct InputIdentifier {
        /// The identifier of the input routed to AWS IoT Events.
        public var iotEventsInputIdentifier: IoTEventsClientTypes.IotEventsInputIdentifier?
        /// The identifer of the input routed from AWS IoT SiteWise.
        public var iotSiteWiseInputIdentifier: IoTEventsClientTypes.IotSiteWiseInputIdentifier?

        public init(
            iotEventsInputIdentifier: IoTEventsClientTypes.IotEventsInputIdentifier? = nil,
            iotSiteWiseInputIdentifier: IoTEventsClientTypes.IotSiteWiseInputIdentifier? = nil
        )
        {
            self.iotEventsInputIdentifier = iotEventsInputIdentifier
            self.iotSiteWiseInputIdentifier = iotSiteWiseInputIdentifier
        }
    }

}

extension IoTEventsClientTypes {
    /// Information about the input.
    public struct InputSummary {
        /// The time the input was created.
        public var creationTime: Foundation.Date?
        /// The ARN of the input.
        public var inputArn: Swift.String?
        /// A brief description of the input.
        public var inputDescription: Swift.String?
        /// The name of the input.
        public var inputName: Swift.String?
        /// The last time the input was updated.
        public var lastUpdateTime: Foundation.Date?
        /// The status of the input.
        public var status: IoTEventsClientTypes.InputStatus?

        public init(
            creationTime: Foundation.Date? = nil,
            inputArn: Swift.String? = nil,
            inputDescription: Swift.String? = nil,
            inputName: Swift.String? = nil,
            lastUpdateTime: Foundation.Date? = nil,
            status: IoTEventsClientTypes.InputStatus? = nil
        )
        {
            self.creationTime = creationTime
            self.inputArn = inputArn
            self.inputDescription = inputDescription
            self.inputName = inputName
            self.lastUpdateTime = lastUpdateTime
            self.status = status
        }
    }

}

public struct ListAlarmModelsInput {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token that you can use to return the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAlarmModelsOutput {
    /// A list that summarizes each alarm model.
    public var alarmModelSummaries: [IoTEventsClientTypes.AlarmModelSummary]?
    /// The token that you can use to return the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        alarmModelSummaries: [IoTEventsClientTypes.AlarmModelSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.alarmModelSummaries = alarmModelSummaries
        self.nextToken = nextToken
    }
}

public struct ListAlarmModelVersionsInput {
    /// The name of the alarm model.
    /// This member is required.
    public var alarmModelName: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token that you can use to return the next set of results.
    public var nextToken: Swift.String?

    public init(
        alarmModelName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.alarmModelName = alarmModelName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAlarmModelVersionsOutput {
    /// A list that summarizes each alarm model version.
    public var alarmModelVersionSummaries: [IoTEventsClientTypes.AlarmModelVersionSummary]?
    /// The token that you can use to return the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        alarmModelVersionSummaries: [IoTEventsClientTypes.AlarmModelVersionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.alarmModelVersionSummaries = alarmModelVersionSummaries
        self.nextToken = nextToken
    }
}

public struct ListDetectorModelsInput {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token that you can use to return the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListDetectorModelsOutput {
    /// Summary information about the detector models.
    public var detectorModelSummaries: [IoTEventsClientTypes.DetectorModelSummary]?
    /// The token that you can use to return the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        detectorModelSummaries: [IoTEventsClientTypes.DetectorModelSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.detectorModelSummaries = detectorModelSummaries
        self.nextToken = nextToken
    }
}

public struct ListDetectorModelVersionsInput {
    /// The name of the detector model whose versions are returned.
    /// This member is required.
    public var detectorModelName: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token that you can use to return the next set of results.
    public var nextToken: Swift.String?

    public init(
        detectorModelName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.detectorModelName = detectorModelName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListDetectorModelVersionsOutput {
    /// Summary information about the detector model versions.
    public var detectorModelVersionSummaries: [IoTEventsClientTypes.DetectorModelVersionSummary]?
    /// The token that you can use to return the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        detectorModelVersionSummaries: [IoTEventsClientTypes.DetectorModelVersionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.detectorModelVersionSummaries = detectorModelVersionSummaries
        self.nextToken = nextToken
    }
}

public struct ListInputRoutingsInput {
    /// The identifer of the routed input.
    /// This member is required.
    public var inputIdentifier: IoTEventsClientTypes.InputIdentifier?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token that you can use to return the next set of results.
    public var nextToken: Swift.String?

    public init(
        inputIdentifier: IoTEventsClientTypes.InputIdentifier? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.inputIdentifier = inputIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IoTEventsClientTypes {
    /// Contains information about the routed resource.
    public struct RoutedResource {
        /// The ARN of the routed resource. For more information, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
        public var arn: Swift.String?
        /// The name of the routed resource.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
        }
    }

}

public struct ListInputRoutingsOutput {
    /// The token that you can use to return the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// Summary information about the routed resources.
    public var routedResources: [IoTEventsClientTypes.RoutedResource]?

    public init(
        nextToken: Swift.String? = nil,
        routedResources: [IoTEventsClientTypes.RoutedResource]? = nil
    )
    {
        self.nextToken = nextToken
        self.routedResources = routedResources
    }
}

public struct ListInputsInput {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token that you can use to return the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListInputsOutput {
    /// Summary information about the inputs.
    public var inputSummaries: [IoTEventsClientTypes.InputSummary]?
    /// The token that you can use to return the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        inputSummaries: [IoTEventsClientTypes.InputSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.inputSummaries = inputSummaries
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    /// The list of tags assigned to the resource.
    public var tags: [IoTEventsClientTypes.Tag]?

    public init(
        tags: [IoTEventsClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

public struct PutLoggingOptionsInput {
    /// The new values of the AWS IoT Events logging options.
    /// This member is required.
    public var loggingOptions: IoTEventsClientTypes.LoggingOptions?

    public init(
        loggingOptions: IoTEventsClientTypes.LoggingOptions? = nil
    )
    {
        self.loggingOptions = loggingOptions
    }
}

public struct StartDetectorModelAnalysisInput {
    /// Information that defines how a detector operates.
    /// This member is required.
    public var detectorModelDefinition: IoTEventsClientTypes.DetectorModelDefinition?

    public init(
        detectorModelDefinition: IoTEventsClientTypes.DetectorModelDefinition? = nil
    )
    {
        self.detectorModelDefinition = detectorModelDefinition
    }
}

public struct StartDetectorModelAnalysisOutput {
    /// The ID that you can use to retrieve the analysis result.
    public var analysisId: Swift.String?

    public init(
        analysisId: Swift.String? = nil
    )
    {
        self.analysisId = analysisId
    }
}

public struct TagResourceInput {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The new or modified tags for the resource.
    /// This member is required.
    public var tags: [IoTEventsClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [IoTEventsClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of the keys of the tags to be removed from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

public struct UpdateAlarmModelInput {
    /// Contains the configuration information of alarm state changes.
    public var alarmCapabilities: IoTEventsClientTypes.AlarmCapabilities?
    /// Contains information about one or more alarm actions.
    public var alarmEventActions: IoTEventsClientTypes.AlarmEventActions?
    /// The description of the alarm model.
    public var alarmModelDescription: Swift.String?
    /// The name of the alarm model.
    /// This member is required.
    public var alarmModelName: Swift.String?
    /// Contains information about one or more notification actions.
    public var alarmNotification: IoTEventsClientTypes.AlarmNotification?
    /// Defines when your alarm is invoked.
    /// This member is required.
    public var alarmRule: IoTEventsClientTypes.AlarmRule?
    /// The ARN of the IAM role that allows the alarm to perform actions and access AWS resources. For more information, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A non-negative integer that reflects the severity level of the alarm.
    public var severity: Swift.Int?

    public init(
        alarmCapabilities: IoTEventsClientTypes.AlarmCapabilities? = nil,
        alarmEventActions: IoTEventsClientTypes.AlarmEventActions? = nil,
        alarmModelDescription: Swift.String? = nil,
        alarmModelName: Swift.String? = nil,
        alarmNotification: IoTEventsClientTypes.AlarmNotification? = nil,
        alarmRule: IoTEventsClientTypes.AlarmRule? = nil,
        roleArn: Swift.String? = nil,
        severity: Swift.Int? = nil
    )
    {
        self.alarmCapabilities = alarmCapabilities
        self.alarmEventActions = alarmEventActions
        self.alarmModelDescription = alarmModelDescription
        self.alarmModelName = alarmModelName
        self.alarmNotification = alarmNotification
        self.alarmRule = alarmRule
        self.roleArn = roleArn
        self.severity = severity
    }
}

public struct UpdateAlarmModelOutput {
    /// The ARN of the alarm model. For more information, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference.
    public var alarmModelArn: Swift.String?
    /// The version of the alarm model.
    public var alarmModelVersion: Swift.String?
    /// The time the alarm model was created, in the Unix epoch format.
    public var creationTime: Foundation.Date?
    /// The time the alarm model was last updated, in the Unix epoch format.
    public var lastUpdateTime: Foundation.Date?
    /// The status of the alarm model. The status can be one of the following values:
    ///
    /// * ACTIVE - The alarm model is active and it's ready to evaluate data.
    ///
    /// * ACTIVATING - AWS IoT Events is activating your alarm model. Activating an alarm model can take up to a few minutes.
    ///
    /// * INACTIVE - The alarm model is inactive, so it isn't ready to evaluate data. Check your alarm model information and update the alarm model.
    ///
    /// * FAILED - You couldn't create or update the alarm model. Check your alarm model information and try again.
    public var status: IoTEventsClientTypes.AlarmModelVersionStatus?

    public init(
        alarmModelArn: Swift.String? = nil,
        alarmModelVersion: Swift.String? = nil,
        creationTime: Foundation.Date? = nil,
        lastUpdateTime: Foundation.Date? = nil,
        status: IoTEventsClientTypes.AlarmModelVersionStatus? = nil
    )
    {
        self.alarmModelArn = alarmModelArn
        self.alarmModelVersion = alarmModelVersion
        self.creationTime = creationTime
        self.lastUpdateTime = lastUpdateTime
        self.status = status
    }
}

public struct UpdateDetectorModelInput {
    /// Information that defines how a detector operates.
    /// This member is required.
    public var detectorModelDefinition: IoTEventsClientTypes.DetectorModelDefinition?
    /// A brief description of the detector model.
    public var detectorModelDescription: Swift.String?
    /// The name of the detector model that is updated.
    /// This member is required.
    public var detectorModelName: Swift.String?
    /// Information about the order in which events are evaluated and how actions are executed.
    public var evaluationMethod: IoTEventsClientTypes.EvaluationMethod?
    /// The ARN of the role that grants permission to AWS IoT Events to perform its operations.
    /// This member is required.
    public var roleArn: Swift.String?

    public init(
        detectorModelDefinition: IoTEventsClientTypes.DetectorModelDefinition? = nil,
        detectorModelDescription: Swift.String? = nil,
        detectorModelName: Swift.String? = nil,
        evaluationMethod: IoTEventsClientTypes.EvaluationMethod? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.detectorModelDefinition = detectorModelDefinition
        self.detectorModelDescription = detectorModelDescription
        self.detectorModelName = detectorModelName
        self.evaluationMethod = evaluationMethod
        self.roleArn = roleArn
    }
}

public struct UpdateDetectorModelOutput {
    /// Information about how the detector model is configured.
    public var detectorModelConfiguration: IoTEventsClientTypes.DetectorModelConfiguration?

    public init(
        detectorModelConfiguration: IoTEventsClientTypes.DetectorModelConfiguration? = nil
    )
    {
        self.detectorModelConfiguration = detectorModelConfiguration
    }
}

public struct UpdateInputInput {
    /// The definition of the input.
    /// This member is required.
    public var inputDefinition: IoTEventsClientTypes.InputDefinition?
    /// A brief description of the input.
    public var inputDescription: Swift.String?
    /// The name of the input you want to update.
    /// This member is required.
    public var inputName: Swift.String?

    public init(
        inputDefinition: IoTEventsClientTypes.InputDefinition? = nil,
        inputDescription: Swift.String? = nil,
        inputName: Swift.String? = nil
    )
    {
        self.inputDefinition = inputDefinition
        self.inputDescription = inputDescription
        self.inputName = inputName
    }
}

public struct UpdateInputOutput {
    /// Information about the configuration of the input.
    public var inputConfiguration: IoTEventsClientTypes.InputConfiguration?

    public init(
        inputConfiguration: IoTEventsClientTypes.InputConfiguration? = nil
    )
    {
        self.inputConfiguration = inputConfiguration
    }
}

extension CreateAlarmModelInput {

    static func urlPathProvider(_ value: CreateAlarmModelInput) -> Swift.String? {
        return "/alarm-models"
    }
}

extension CreateDetectorModelInput {

    static func urlPathProvider(_ value: CreateDetectorModelInput) -> Swift.String? {
        return "/detector-models"
    }
}

extension CreateInputInput {

    static func urlPathProvider(_ value: CreateInputInput) -> Swift.String? {
        return "/inputs"
    }
}

extension DeleteAlarmModelInput {

    static func urlPathProvider(_ value: DeleteAlarmModelInput) -> Swift.String? {
        guard let alarmModelName = value.alarmModelName else {
            return nil
        }
        return "/alarm-models/\(alarmModelName.urlPercentEncoding())"
    }
}

extension DeleteDetectorModelInput {

    static func urlPathProvider(_ value: DeleteDetectorModelInput) -> Swift.String? {
        guard let detectorModelName = value.detectorModelName else {
            return nil
        }
        return "/detector-models/\(detectorModelName.urlPercentEncoding())"
    }
}

extension DeleteInputInput {

    static func urlPathProvider(_ value: DeleteInputInput) -> Swift.String? {
        guard let inputName = value.inputName else {
            return nil
        }
        return "/inputs/\(inputName.urlPercentEncoding())"
    }
}

extension DescribeAlarmModelInput {

    static func urlPathProvider(_ value: DescribeAlarmModelInput) -> Swift.String? {
        guard let alarmModelName = value.alarmModelName else {
            return nil
        }
        return "/alarm-models/\(alarmModelName.urlPercentEncoding())"
    }
}

extension DescribeAlarmModelInput {

    static func queryItemProvider(_ value: DescribeAlarmModelInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let alarmModelVersion = value.alarmModelVersion {
            let alarmModelVersionQueryItem = Smithy.URIQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(alarmModelVersion).urlPercentEncoding())
            items.append(alarmModelVersionQueryItem)
        }
        return items
    }
}

extension DescribeDetectorModelInput {

    static func urlPathProvider(_ value: DescribeDetectorModelInput) -> Swift.String? {
        guard let detectorModelName = value.detectorModelName else {
            return nil
        }
        return "/detector-models/\(detectorModelName.urlPercentEncoding())"
    }
}

extension DescribeDetectorModelInput {

    static func queryItemProvider(_ value: DescribeDetectorModelInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let detectorModelVersion = value.detectorModelVersion {
            let detectorModelVersionQueryItem = Smithy.URIQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(detectorModelVersion).urlPercentEncoding())
            items.append(detectorModelVersionQueryItem)
        }
        return items
    }
}

extension DescribeDetectorModelAnalysisInput {

    static func urlPathProvider(_ value: DescribeDetectorModelAnalysisInput) -> Swift.String? {
        guard let analysisId = value.analysisId else {
            return nil
        }
        return "/analysis/detector-models/\(analysisId.urlPercentEncoding())"
    }
}

extension DescribeInputInput {

    static func urlPathProvider(_ value: DescribeInputInput) -> Swift.String? {
        guard let inputName = value.inputName else {
            return nil
        }
        return "/inputs/\(inputName.urlPercentEncoding())"
    }
}

extension DescribeLoggingOptionsInput {

    static func urlPathProvider(_ value: DescribeLoggingOptionsInput) -> Swift.String? {
        return "/logging"
    }
}

extension GetDetectorModelAnalysisResultsInput {

    static func urlPathProvider(_ value: GetDetectorModelAnalysisResultsInput) -> Swift.String? {
        guard let analysisId = value.analysisId else {
            return nil
        }
        return "/analysis/detector-models/\(analysisId.urlPercentEncoding())/results"
    }
}

extension GetDetectorModelAnalysisResultsInput {

    static func queryItemProvider(_ value: GetDetectorModelAnalysisResultsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListAlarmModelsInput {

    static func urlPathProvider(_ value: ListAlarmModelsInput) -> Swift.String? {
        return "/alarm-models"
    }
}

extension ListAlarmModelsInput {

    static func queryItemProvider(_ value: ListAlarmModelsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListAlarmModelVersionsInput {

    static func urlPathProvider(_ value: ListAlarmModelVersionsInput) -> Swift.String? {
        guard let alarmModelName = value.alarmModelName else {
            return nil
        }
        return "/alarm-models/\(alarmModelName.urlPercentEncoding())/versions"
    }
}

extension ListAlarmModelVersionsInput {

    static func queryItemProvider(_ value: ListAlarmModelVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDetectorModelsInput {

    static func urlPathProvider(_ value: ListDetectorModelsInput) -> Swift.String? {
        return "/detector-models"
    }
}

extension ListDetectorModelsInput {

    static func queryItemProvider(_ value: ListDetectorModelsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDetectorModelVersionsInput {

    static func urlPathProvider(_ value: ListDetectorModelVersionsInput) -> Swift.String? {
        guard let detectorModelName = value.detectorModelName else {
            return nil
        }
        return "/detector-models/\(detectorModelName.urlPercentEncoding())/versions"
    }
}

extension ListDetectorModelVersionsInput {

    static func queryItemProvider(_ value: ListDetectorModelVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListInputRoutingsInput {

    static func urlPathProvider(_ value: ListInputRoutingsInput) -> Swift.String? {
        return "/input-routings"
    }
}

extension ListInputsInput {

    static func urlPathProvider(_ value: ListInputsInput) -> Swift.String? {
        return "/inputs"
    }
}

extension ListInputsInput {

    static func queryItemProvider(_ value: ListInputsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/tags"
    }
}

extension ListTagsForResourceInput {

    static func queryItemProvider(_ value: ListTagsForResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let resourceArn = value.resourceArn else {
            let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceArnQueryItem = Smithy.URIQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
        items.append(resourceArnQueryItem)
        return items
    }
}

extension PutLoggingOptionsInput {

    static func urlPathProvider(_ value: PutLoggingOptionsInput) -> Swift.String? {
        return "/logging"
    }
}

extension StartDetectorModelAnalysisInput {

    static func urlPathProvider(_ value: StartDetectorModelAnalysisInput) -> Swift.String? {
        return "/analysis/detector-models"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/tags"
    }
}

extension TagResourceInput {

    static func queryItemProvider(_ value: TagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let resourceArn = value.resourceArn else {
            let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceArnQueryItem = Smithy.URIQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
        items.append(resourceArnQueryItem)
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/tags"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        guard let resourceArn = value.resourceArn else {
            let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceArnQueryItem = Smithy.URIQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
        items.append(resourceArnQueryItem)
        return items
    }
}

extension UpdateAlarmModelInput {

    static func urlPathProvider(_ value: UpdateAlarmModelInput) -> Swift.String? {
        guard let alarmModelName = value.alarmModelName else {
            return nil
        }
        return "/alarm-models/\(alarmModelName.urlPercentEncoding())"
    }
}

extension UpdateDetectorModelInput {

    static func urlPathProvider(_ value: UpdateDetectorModelInput) -> Swift.String? {
        guard let detectorModelName = value.detectorModelName else {
            return nil
        }
        return "/detector-models/\(detectorModelName.urlPercentEncoding())"
    }
}

extension UpdateInputInput {

    static func urlPathProvider(_ value: UpdateInputInput) -> Swift.String? {
        guard let inputName = value.inputName else {
            return nil
        }
        return "/inputs/\(inputName.urlPercentEncoding())"
    }
}

extension CreateAlarmModelInput {

    static func write(value: CreateAlarmModelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["alarmCapabilities"].write(value.alarmCapabilities, with: IoTEventsClientTypes.AlarmCapabilities.write(value:to:))
        try writer["alarmEventActions"].write(value.alarmEventActions, with: IoTEventsClientTypes.AlarmEventActions.write(value:to:))
        try writer["alarmModelDescription"].write(value.alarmModelDescription)
        try writer["alarmModelName"].write(value.alarmModelName)
        try writer["alarmNotification"].write(value.alarmNotification, with: IoTEventsClientTypes.AlarmNotification.write(value:to:))
        try writer["alarmRule"].write(value.alarmRule, with: IoTEventsClientTypes.AlarmRule.write(value:to:))
        try writer["key"].write(value.key)
        try writer["roleArn"].write(value.roleArn)
        try writer["severity"].write(value.severity)
        try writer["tags"].writeList(value.tags, memberWritingClosure: IoTEventsClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateDetectorModelInput {

    static func write(value: CreateDetectorModelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["detectorModelDefinition"].write(value.detectorModelDefinition, with: IoTEventsClientTypes.DetectorModelDefinition.write(value:to:))
        try writer["detectorModelDescription"].write(value.detectorModelDescription)
        try writer["detectorModelName"].write(value.detectorModelName)
        try writer["evaluationMethod"].write(value.evaluationMethod)
        try writer["key"].write(value.key)
        try writer["roleArn"].write(value.roleArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: IoTEventsClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateInputInput {

    static func write(value: CreateInputInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["inputDefinition"].write(value.inputDefinition, with: IoTEventsClientTypes.InputDefinition.write(value:to:))
        try writer["inputDescription"].write(value.inputDescription)
        try writer["inputName"].write(value.inputName)
        try writer["tags"].writeList(value.tags, memberWritingClosure: IoTEventsClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ListInputRoutingsInput {

    static func write(value: ListInputRoutingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["inputIdentifier"].write(value.inputIdentifier, with: IoTEventsClientTypes.InputIdentifier.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension PutLoggingOptionsInput {

    static func write(value: PutLoggingOptionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["loggingOptions"].write(value.loggingOptions, with: IoTEventsClientTypes.LoggingOptions.write(value:to:))
    }
}

extension StartDetectorModelAnalysisInput {

    static func write(value: StartDetectorModelAnalysisInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["detectorModelDefinition"].write(value.detectorModelDefinition, with: IoTEventsClientTypes.DetectorModelDefinition.write(value:to:))
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeList(value.tags, memberWritingClosure: IoTEventsClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateAlarmModelInput {

    static func write(value: UpdateAlarmModelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["alarmCapabilities"].write(value.alarmCapabilities, with: IoTEventsClientTypes.AlarmCapabilities.write(value:to:))
        try writer["alarmEventActions"].write(value.alarmEventActions, with: IoTEventsClientTypes.AlarmEventActions.write(value:to:))
        try writer["alarmModelDescription"].write(value.alarmModelDescription)
        try writer["alarmNotification"].write(value.alarmNotification, with: IoTEventsClientTypes.AlarmNotification.write(value:to:))
        try writer["alarmRule"].write(value.alarmRule, with: IoTEventsClientTypes.AlarmRule.write(value:to:))
        try writer["roleArn"].write(value.roleArn)
        try writer["severity"].write(value.severity)
    }
}

extension UpdateDetectorModelInput {

    static func write(value: UpdateDetectorModelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["detectorModelDefinition"].write(value.detectorModelDefinition, with: IoTEventsClientTypes.DetectorModelDefinition.write(value:to:))
        try writer["detectorModelDescription"].write(value.detectorModelDescription)
        try writer["evaluationMethod"].write(value.evaluationMethod)
        try writer["roleArn"].write(value.roleArn)
    }
}

extension UpdateInputInput {

    static func write(value: UpdateInputInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["inputDefinition"].write(value.inputDefinition, with: IoTEventsClientTypes.InputDefinition.write(value:to:))
        try writer["inputDescription"].write(value.inputDescription)
    }
}

extension CreateAlarmModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAlarmModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAlarmModelOutput()
        value.alarmModelArn = try reader["alarmModelArn"].readIfPresent()
        value.alarmModelVersion = try reader["alarmModelVersion"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdateTime = try reader["lastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension CreateDetectorModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDetectorModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDetectorModelOutput()
        value.detectorModelConfiguration = try reader["detectorModelConfiguration"].readIfPresent(with: IoTEventsClientTypes.DetectorModelConfiguration.read(from:))
        return value
    }
}

extension CreateInputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateInputOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateInputOutput()
        value.inputConfiguration = try reader["inputConfiguration"].readIfPresent(with: IoTEventsClientTypes.InputConfiguration.read(from:))
        return value
    }
}

extension DeleteAlarmModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAlarmModelOutput {
        return DeleteAlarmModelOutput()
    }
}

extension DeleteDetectorModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDetectorModelOutput {
        return DeleteDetectorModelOutput()
    }
}

extension DeleteInputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteInputOutput {
        return DeleteInputOutput()
    }
}

extension DescribeAlarmModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAlarmModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAlarmModelOutput()
        value.alarmCapabilities = try reader["alarmCapabilities"].readIfPresent(with: IoTEventsClientTypes.AlarmCapabilities.read(from:))
        value.alarmEventActions = try reader["alarmEventActions"].readIfPresent(with: IoTEventsClientTypes.AlarmEventActions.read(from:))
        value.alarmModelArn = try reader["alarmModelArn"].readIfPresent()
        value.alarmModelDescription = try reader["alarmModelDescription"].readIfPresent()
        value.alarmModelName = try reader["alarmModelName"].readIfPresent()
        value.alarmModelVersion = try reader["alarmModelVersion"].readIfPresent()
        value.alarmNotification = try reader["alarmNotification"].readIfPresent(with: IoTEventsClientTypes.AlarmNotification.read(from:))
        value.alarmRule = try reader["alarmRule"].readIfPresent(with: IoTEventsClientTypes.AlarmRule.read(from:))
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.key = try reader["key"].readIfPresent()
        value.lastUpdateTime = try reader["lastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.severity = try reader["severity"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        return value
    }
}

extension DescribeDetectorModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDetectorModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDetectorModelOutput()
        value.detectorModel = try reader["detectorModel"].readIfPresent(with: IoTEventsClientTypes.DetectorModel.read(from:))
        return value
    }
}

extension DescribeDetectorModelAnalysisOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDetectorModelAnalysisOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDetectorModelAnalysisOutput()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension DescribeInputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeInputOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeInputOutput()
        value.input = try reader["input"].readIfPresent(with: IoTEventsClientTypes.Input.read(from:))
        return value
    }
}

extension DescribeLoggingOptionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeLoggingOptionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeLoggingOptionsOutput()
        value.loggingOptions = try reader["loggingOptions"].readIfPresent(with: IoTEventsClientTypes.LoggingOptions.read(from:))
        return value
    }
}

extension GetDetectorModelAnalysisResultsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDetectorModelAnalysisResultsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDetectorModelAnalysisResultsOutput()
        value.analysisResults = try reader["analysisResults"].readListIfPresent(memberReadingClosure: IoTEventsClientTypes.AnalysisResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAlarmModelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAlarmModelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAlarmModelsOutput()
        value.alarmModelSummaries = try reader["alarmModelSummaries"].readListIfPresent(memberReadingClosure: IoTEventsClientTypes.AlarmModelSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAlarmModelVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAlarmModelVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAlarmModelVersionsOutput()
        value.alarmModelVersionSummaries = try reader["alarmModelVersionSummaries"].readListIfPresent(memberReadingClosure: IoTEventsClientTypes.AlarmModelVersionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDetectorModelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDetectorModelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDetectorModelsOutput()
        value.detectorModelSummaries = try reader["detectorModelSummaries"].readListIfPresent(memberReadingClosure: IoTEventsClientTypes.DetectorModelSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDetectorModelVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDetectorModelVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDetectorModelVersionsOutput()
        value.detectorModelVersionSummaries = try reader["detectorModelVersionSummaries"].readListIfPresent(memberReadingClosure: IoTEventsClientTypes.DetectorModelVersionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListInputRoutingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListInputRoutingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListInputRoutingsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.routedResources = try reader["routedResources"].readListIfPresent(memberReadingClosure: IoTEventsClientTypes.RoutedResource.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListInputsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListInputsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListInputsOutput()
        value.inputSummaries = try reader["inputSummaries"].readListIfPresent(memberReadingClosure: IoTEventsClientTypes.InputSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: IoTEventsClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PutLoggingOptionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutLoggingOptionsOutput {
        return PutLoggingOptionsOutput()
    }
}

extension StartDetectorModelAnalysisOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartDetectorModelAnalysisOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartDetectorModelAnalysisOutput()
        value.analysisId = try reader["analysisId"].readIfPresent()
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateAlarmModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAlarmModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAlarmModelOutput()
        value.alarmModelArn = try reader["alarmModelArn"].readIfPresent()
        value.alarmModelVersion = try reader["alarmModelVersion"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdateTime = try reader["lastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension UpdateDetectorModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDetectorModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDetectorModelOutput()
        value.detectorModelConfiguration = try reader["detectorModelConfiguration"].readIfPresent(with: IoTEventsClientTypes.DetectorModelConfiguration.read(from:))
        return value
    }
}

extension UpdateInputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateInputOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateInputOutput()
        value.inputConfiguration = try reader["inputConfiguration"].readIfPresent(with: IoTEventsClientTypes.InputConfiguration.read(from:))
        return value
    }
}

enum CreateAlarmModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDetectorModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateInputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAlarmModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDetectorModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteInputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAlarmModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDetectorModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDetectorModelAnalysisOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeInputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeLoggingOptionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDetectorModelAnalysisResultsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAlarmModelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAlarmModelVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDetectorModelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDetectorModelVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListInputRoutingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListInputsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutLoggingOptionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartDetectorModelAnalysisOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAlarmModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDetectorModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateInputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InternalFailureException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalFailureException {
        let reader = baseError.errorBodyReader
        var value = InternalFailureException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidRequestException {
        let reader = baseError.errorBodyReader
        var value = InvalidRequestException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceInUseException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceInUseException {
        let reader = baseError.errorBodyReader
        var value = ResourceInUseException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = ResourceAlreadyExistsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceArn = try reader["resourceArn"].readIfPresent()
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceUnavailableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceUnavailableException {
        let reader = baseError.errorBodyReader
        var value = ServiceUnavailableException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnsupportedOperationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnsupportedOperationException {
        let reader = baseError.errorBodyReader
        var value = UnsupportedOperationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IoTEventsClientTypes.DetectorModelConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.DetectorModelConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.DetectorModelConfiguration()
        value.detectorModelName = try reader["detectorModelName"].readIfPresent()
        value.detectorModelVersion = try reader["detectorModelVersion"].readIfPresent()
        value.detectorModelDescription = try reader["detectorModelDescription"].readIfPresent()
        value.detectorModelArn = try reader["detectorModelArn"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdateTime = try reader["lastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["status"].readIfPresent()
        value.key = try reader["key"].readIfPresent()
        value.evaluationMethod = try reader["evaluationMethod"].readIfPresent()
        return value
    }
}

extension IoTEventsClientTypes.InputConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.InputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.InputConfiguration()
        value.inputName = try reader["inputName"].readIfPresent() ?? ""
        value.inputDescription = try reader["inputDescription"].readIfPresent()
        value.inputArn = try reader["inputArn"].readIfPresent() ?? ""
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdateTime = try reader["lastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension IoTEventsClientTypes.AlarmRule {

    static func write(value: IoTEventsClientTypes.AlarmRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["simpleRule"].write(value.simpleRule, with: IoTEventsClientTypes.SimpleRule.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.AlarmRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.AlarmRule()
        value.simpleRule = try reader["simpleRule"].readIfPresent(with: IoTEventsClientTypes.SimpleRule.read(from:))
        return value
    }
}

extension IoTEventsClientTypes.SimpleRule {

    static func write(value: IoTEventsClientTypes.SimpleRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["comparisonOperator"].write(value.comparisonOperator)
        try writer["inputProperty"].write(value.inputProperty)
        try writer["threshold"].write(value.threshold)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.SimpleRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.SimpleRule()
        value.inputProperty = try reader["inputProperty"].readIfPresent() ?? ""
        value.comparisonOperator = try reader["comparisonOperator"].readIfPresent() ?? .sdkUnknown("")
        value.threshold = try reader["threshold"].readIfPresent() ?? ""
        return value
    }
}

extension IoTEventsClientTypes.AlarmNotification {

    static func write(value: IoTEventsClientTypes.AlarmNotification?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["notificationActions"].writeList(value.notificationActions, memberWritingClosure: IoTEventsClientTypes.NotificationAction.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.AlarmNotification {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.AlarmNotification()
        value.notificationActions = try reader["notificationActions"].readListIfPresent(memberReadingClosure: IoTEventsClientTypes.NotificationAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTEventsClientTypes.NotificationAction {

    static func write(value: IoTEventsClientTypes.NotificationAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action, with: IoTEventsClientTypes.NotificationTargetActions.write(value:to:))
        try writer["emailConfigurations"].writeList(value.emailConfigurations, memberWritingClosure: IoTEventsClientTypes.EmailConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["smsConfigurations"].writeList(value.smsConfigurations, memberWritingClosure: IoTEventsClientTypes.SMSConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.NotificationAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.NotificationAction()
        value.action = try reader["action"].readIfPresent(with: IoTEventsClientTypes.NotificationTargetActions.read(from:))
        value.smsConfigurations = try reader["smsConfigurations"].readListIfPresent(memberReadingClosure: IoTEventsClientTypes.SMSConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.emailConfigurations = try reader["emailConfigurations"].readListIfPresent(memberReadingClosure: IoTEventsClientTypes.EmailConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTEventsClientTypes.EmailConfiguration {

    static func write(value: IoTEventsClientTypes.EmailConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["content"].write(value.content, with: IoTEventsClientTypes.EmailContent.write(value:to:))
        try writer["from"].write(value.from)
        try writer["recipients"].write(value.recipients, with: IoTEventsClientTypes.EmailRecipients.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.EmailConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.EmailConfiguration()
        value.from = try reader["from"].readIfPresent() ?? ""
        value.content = try reader["content"].readIfPresent(with: IoTEventsClientTypes.EmailContent.read(from:))
        value.recipients = try reader["recipients"].readIfPresent(with: IoTEventsClientTypes.EmailRecipients.read(from:))
        return value
    }
}

extension IoTEventsClientTypes.EmailRecipients {

    static func write(value: IoTEventsClientTypes.EmailRecipients?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["to"].writeList(value.to, memberWritingClosure: IoTEventsClientTypes.RecipientDetail.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.EmailRecipients {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.EmailRecipients()
        value.to = try reader["to"].readListIfPresent(memberReadingClosure: IoTEventsClientTypes.RecipientDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTEventsClientTypes.RecipientDetail {

    static func write(value: IoTEventsClientTypes.RecipientDetail?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ssoIdentity"].write(value.ssoIdentity, with: IoTEventsClientTypes.SSOIdentity.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.RecipientDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.RecipientDetail()
        value.ssoIdentity = try reader["ssoIdentity"].readIfPresent(with: IoTEventsClientTypes.SSOIdentity.read(from:))
        return value
    }
}

extension IoTEventsClientTypes.SSOIdentity {

    static func write(value: IoTEventsClientTypes.SSOIdentity?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["identityStoreId"].write(value.identityStoreId)
        try writer["userId"].write(value.userId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.SSOIdentity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.SSOIdentity()
        value.identityStoreId = try reader["identityStoreId"].readIfPresent() ?? ""
        value.userId = try reader["userId"].readIfPresent()
        return value
    }
}

extension IoTEventsClientTypes.EmailContent {

    static func write(value: IoTEventsClientTypes.EmailContent?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalMessage"].write(value.additionalMessage)
        try writer["subject"].write(value.subject)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.EmailContent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.EmailContent()
        value.subject = try reader["subject"].readIfPresent()
        value.additionalMessage = try reader["additionalMessage"].readIfPresent()
        return value
    }
}

extension IoTEventsClientTypes.SMSConfiguration {

    static func write(value: IoTEventsClientTypes.SMSConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalMessage"].write(value.additionalMessage)
        try writer["recipients"].writeList(value.recipients, memberWritingClosure: IoTEventsClientTypes.RecipientDetail.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["senderId"].write(value.senderId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.SMSConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.SMSConfiguration()
        value.senderId = try reader["senderId"].readIfPresent()
        value.additionalMessage = try reader["additionalMessage"].readIfPresent()
        value.recipients = try reader["recipients"].readListIfPresent(memberReadingClosure: IoTEventsClientTypes.RecipientDetail.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension IoTEventsClientTypes.NotificationTargetActions {

    static func write(value: IoTEventsClientTypes.NotificationTargetActions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["lambdaAction"].write(value.lambdaAction, with: IoTEventsClientTypes.LambdaAction.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.NotificationTargetActions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.NotificationTargetActions()
        value.lambdaAction = try reader["lambdaAction"].readIfPresent(with: IoTEventsClientTypes.LambdaAction.read(from:))
        return value
    }
}

extension IoTEventsClientTypes.LambdaAction {

    static func write(value: IoTEventsClientTypes.LambdaAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["functionArn"].write(value.functionArn)
        try writer["payload"].write(value.payload, with: IoTEventsClientTypes.Payload.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.LambdaAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.LambdaAction()
        value.functionArn = try reader["functionArn"].readIfPresent() ?? ""
        value.payload = try reader["payload"].readIfPresent(with: IoTEventsClientTypes.Payload.read(from:))
        return value
    }
}

extension IoTEventsClientTypes.Payload {

    static func write(value: IoTEventsClientTypes.Payload?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["contentExpression"].write(value.contentExpression)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.Payload {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.Payload()
        value.contentExpression = try reader["contentExpression"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension IoTEventsClientTypes.AlarmEventActions {

    static func write(value: IoTEventsClientTypes.AlarmEventActions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["alarmActions"].writeList(value.alarmActions, memberWritingClosure: IoTEventsClientTypes.AlarmAction.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.AlarmEventActions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.AlarmEventActions()
        value.alarmActions = try reader["alarmActions"].readListIfPresent(memberReadingClosure: IoTEventsClientTypes.AlarmAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTEventsClientTypes.AlarmAction {

    static func write(value: IoTEventsClientTypes.AlarmAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dynamoDB"].write(value.dynamoDB, with: IoTEventsClientTypes.DynamoDBAction.write(value:to:))
        try writer["dynamoDBv2"].write(value.dynamoDBv2, with: IoTEventsClientTypes.DynamoDBv2Action.write(value:to:))
        try writer["firehose"].write(value.firehose, with: IoTEventsClientTypes.FirehoseAction.write(value:to:))
        try writer["iotEvents"].write(value.iotEvents, with: IoTEventsClientTypes.IotEventsAction.write(value:to:))
        try writer["iotSiteWise"].write(value.iotSiteWise, with: IoTEventsClientTypes.IotSiteWiseAction.write(value:to:))
        try writer["iotTopicPublish"].write(value.iotTopicPublish, with: IoTEventsClientTypes.IotTopicPublishAction.write(value:to:))
        try writer["lambda"].write(value.lambda, with: IoTEventsClientTypes.LambdaAction.write(value:to:))
        try writer["sns"].write(value.sns, with: IoTEventsClientTypes.SNSTopicPublishAction.write(value:to:))
        try writer["sqs"].write(value.sqs, with: IoTEventsClientTypes.SqsAction.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.AlarmAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.AlarmAction()
        value.sns = try reader["sns"].readIfPresent(with: IoTEventsClientTypes.SNSTopicPublishAction.read(from:))
        value.iotTopicPublish = try reader["iotTopicPublish"].readIfPresent(with: IoTEventsClientTypes.IotTopicPublishAction.read(from:))
        value.lambda = try reader["lambda"].readIfPresent(with: IoTEventsClientTypes.LambdaAction.read(from:))
        value.iotEvents = try reader["iotEvents"].readIfPresent(with: IoTEventsClientTypes.IotEventsAction.read(from:))
        value.sqs = try reader["sqs"].readIfPresent(with: IoTEventsClientTypes.SqsAction.read(from:))
        value.firehose = try reader["firehose"].readIfPresent(with: IoTEventsClientTypes.FirehoseAction.read(from:))
        value.dynamoDB = try reader["dynamoDB"].readIfPresent(with: IoTEventsClientTypes.DynamoDBAction.read(from:))
        value.dynamoDBv2 = try reader["dynamoDBv2"].readIfPresent(with: IoTEventsClientTypes.DynamoDBv2Action.read(from:))
        value.iotSiteWise = try reader["iotSiteWise"].readIfPresent(with: IoTEventsClientTypes.IotSiteWiseAction.read(from:))
        return value
    }
}

extension IoTEventsClientTypes.IotSiteWiseAction {

    static func write(value: IoTEventsClientTypes.IotSiteWiseAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assetId"].write(value.assetId)
        try writer["entryId"].write(value.entryId)
        try writer["propertyAlias"].write(value.propertyAlias)
        try writer["propertyId"].write(value.propertyId)
        try writer["propertyValue"].write(value.propertyValue, with: IoTEventsClientTypes.AssetPropertyValue.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.IotSiteWiseAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.IotSiteWiseAction()
        value.entryId = try reader["entryId"].readIfPresent()
        value.assetId = try reader["assetId"].readIfPresent()
        value.propertyId = try reader["propertyId"].readIfPresent()
        value.propertyAlias = try reader["propertyAlias"].readIfPresent()
        value.propertyValue = try reader["propertyValue"].readIfPresent(with: IoTEventsClientTypes.AssetPropertyValue.read(from:))
        return value
    }
}

extension IoTEventsClientTypes.AssetPropertyValue {

    static func write(value: IoTEventsClientTypes.AssetPropertyValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["quality"].write(value.quality)
        try writer["timestamp"].write(value.timestamp, with: IoTEventsClientTypes.AssetPropertyTimestamp.write(value:to:))
        try writer["value"].write(value.value, with: IoTEventsClientTypes.AssetPropertyVariant.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.AssetPropertyValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.AssetPropertyValue()
        value.value = try reader["value"].readIfPresent(with: IoTEventsClientTypes.AssetPropertyVariant.read(from:))
        value.timestamp = try reader["timestamp"].readIfPresent(with: IoTEventsClientTypes.AssetPropertyTimestamp.read(from:))
        value.quality = try reader["quality"].readIfPresent()
        return value
    }
}

extension IoTEventsClientTypes.AssetPropertyTimestamp {

    static func write(value: IoTEventsClientTypes.AssetPropertyTimestamp?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["offsetInNanos"].write(value.offsetInNanos)
        try writer["timeInSeconds"].write(value.timeInSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.AssetPropertyTimestamp {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.AssetPropertyTimestamp()
        value.timeInSeconds = try reader["timeInSeconds"].readIfPresent() ?? ""
        value.offsetInNanos = try reader["offsetInNanos"].readIfPresent()
        return value
    }
}

extension IoTEventsClientTypes.AssetPropertyVariant {

    static func write(value: IoTEventsClientTypes.AssetPropertyVariant?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["booleanValue"].write(value.booleanValue)
        try writer["doubleValue"].write(value.doubleValue)
        try writer["integerValue"].write(value.integerValue)
        try writer["stringValue"].write(value.stringValue)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.AssetPropertyVariant {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.AssetPropertyVariant()
        value.stringValue = try reader["stringValue"].readIfPresent()
        value.integerValue = try reader["integerValue"].readIfPresent()
        value.doubleValue = try reader["doubleValue"].readIfPresent()
        value.booleanValue = try reader["booleanValue"].readIfPresent()
        return value
    }
}

extension IoTEventsClientTypes.DynamoDBv2Action {

    static func write(value: IoTEventsClientTypes.DynamoDBv2Action?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["payload"].write(value.payload, with: IoTEventsClientTypes.Payload.write(value:to:))
        try writer["tableName"].write(value.tableName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.DynamoDBv2Action {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.DynamoDBv2Action()
        value.tableName = try reader["tableName"].readIfPresent() ?? ""
        value.payload = try reader["payload"].readIfPresent(with: IoTEventsClientTypes.Payload.read(from:))
        return value
    }
}

extension IoTEventsClientTypes.DynamoDBAction {

    static func write(value: IoTEventsClientTypes.DynamoDBAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["hashKeyField"].write(value.hashKeyField)
        try writer["hashKeyType"].write(value.hashKeyType)
        try writer["hashKeyValue"].write(value.hashKeyValue)
        try writer["operation"].write(value.operation)
        try writer["payload"].write(value.payload, with: IoTEventsClientTypes.Payload.write(value:to:))
        try writer["payloadField"].write(value.payloadField)
        try writer["rangeKeyField"].write(value.rangeKeyField)
        try writer["rangeKeyType"].write(value.rangeKeyType)
        try writer["rangeKeyValue"].write(value.rangeKeyValue)
        try writer["tableName"].write(value.tableName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.DynamoDBAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.DynamoDBAction()
        value.hashKeyType = try reader["hashKeyType"].readIfPresent()
        value.hashKeyField = try reader["hashKeyField"].readIfPresent() ?? ""
        value.hashKeyValue = try reader["hashKeyValue"].readIfPresent() ?? ""
        value.rangeKeyType = try reader["rangeKeyType"].readIfPresent()
        value.rangeKeyField = try reader["rangeKeyField"].readIfPresent()
        value.rangeKeyValue = try reader["rangeKeyValue"].readIfPresent()
        value.operation = try reader["operation"].readIfPresent()
        value.payloadField = try reader["payloadField"].readIfPresent()
        value.tableName = try reader["tableName"].readIfPresent() ?? ""
        value.payload = try reader["payload"].readIfPresent(with: IoTEventsClientTypes.Payload.read(from:))
        return value
    }
}

extension IoTEventsClientTypes.FirehoseAction {

    static func write(value: IoTEventsClientTypes.FirehoseAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["deliveryStreamName"].write(value.deliveryStreamName)
        try writer["payload"].write(value.payload, with: IoTEventsClientTypes.Payload.write(value:to:))
        try writer["separator"].write(value.separator)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.FirehoseAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.FirehoseAction()
        value.deliveryStreamName = try reader["deliveryStreamName"].readIfPresent() ?? ""
        value.separator = try reader["separator"].readIfPresent()
        value.payload = try reader["payload"].readIfPresent(with: IoTEventsClientTypes.Payload.read(from:))
        return value
    }
}

extension IoTEventsClientTypes.SqsAction {

    static func write(value: IoTEventsClientTypes.SqsAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["payload"].write(value.payload, with: IoTEventsClientTypes.Payload.write(value:to:))
        try writer["queueUrl"].write(value.queueUrl)
        try writer["useBase64"].write(value.useBase64)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.SqsAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.SqsAction()
        value.queueUrl = try reader["queueUrl"].readIfPresent() ?? ""
        value.useBase64 = try reader["useBase64"].readIfPresent()
        value.payload = try reader["payload"].readIfPresent(with: IoTEventsClientTypes.Payload.read(from:))
        return value
    }
}

extension IoTEventsClientTypes.IotEventsAction {

    static func write(value: IoTEventsClientTypes.IotEventsAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["inputName"].write(value.inputName)
        try writer["payload"].write(value.payload, with: IoTEventsClientTypes.Payload.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.IotEventsAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.IotEventsAction()
        value.inputName = try reader["inputName"].readIfPresent() ?? ""
        value.payload = try reader["payload"].readIfPresent(with: IoTEventsClientTypes.Payload.read(from:))
        return value
    }
}

extension IoTEventsClientTypes.IotTopicPublishAction {

    static func write(value: IoTEventsClientTypes.IotTopicPublishAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["mqttTopic"].write(value.mqttTopic)
        try writer["payload"].write(value.payload, with: IoTEventsClientTypes.Payload.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.IotTopicPublishAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.IotTopicPublishAction()
        value.mqttTopic = try reader["mqttTopic"].readIfPresent() ?? ""
        value.payload = try reader["payload"].readIfPresent(with: IoTEventsClientTypes.Payload.read(from:))
        return value
    }
}

extension IoTEventsClientTypes.SNSTopicPublishAction {

    static func write(value: IoTEventsClientTypes.SNSTopicPublishAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["payload"].write(value.payload, with: IoTEventsClientTypes.Payload.write(value:to:))
        try writer["targetArn"].write(value.targetArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.SNSTopicPublishAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.SNSTopicPublishAction()
        value.targetArn = try reader["targetArn"].readIfPresent() ?? ""
        value.payload = try reader["payload"].readIfPresent(with: IoTEventsClientTypes.Payload.read(from:))
        return value
    }
}

extension IoTEventsClientTypes.AlarmCapabilities {

    static func write(value: IoTEventsClientTypes.AlarmCapabilities?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["acknowledgeFlow"].write(value.acknowledgeFlow, with: IoTEventsClientTypes.AcknowledgeFlow.write(value:to:))
        try writer["initializationConfiguration"].write(value.initializationConfiguration, with: IoTEventsClientTypes.InitializationConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.AlarmCapabilities {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.AlarmCapabilities()
        value.initializationConfiguration = try reader["initializationConfiguration"].readIfPresent(with: IoTEventsClientTypes.InitializationConfiguration.read(from:))
        value.acknowledgeFlow = try reader["acknowledgeFlow"].readIfPresent(with: IoTEventsClientTypes.AcknowledgeFlow.read(from:))
        return value
    }
}

extension IoTEventsClientTypes.AcknowledgeFlow {

    static func write(value: IoTEventsClientTypes.AcknowledgeFlow?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enabled"].write(value.enabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.AcknowledgeFlow {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.AcknowledgeFlow()
        value.enabled = try reader["enabled"].readIfPresent() ?? false
        return value
    }
}

extension IoTEventsClientTypes.InitializationConfiguration {

    static func write(value: IoTEventsClientTypes.InitializationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["disabledOnInitialization"].write(value.disabledOnInitialization)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.InitializationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.InitializationConfiguration()
        value.disabledOnInitialization = try reader["disabledOnInitialization"].readIfPresent() ?? false
        return value
    }
}

extension IoTEventsClientTypes.DetectorModel {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.DetectorModel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.DetectorModel()
        value.detectorModelDefinition = try reader["detectorModelDefinition"].readIfPresent(with: IoTEventsClientTypes.DetectorModelDefinition.read(from:))
        value.detectorModelConfiguration = try reader["detectorModelConfiguration"].readIfPresent(with: IoTEventsClientTypes.DetectorModelConfiguration.read(from:))
        return value
    }
}

extension IoTEventsClientTypes.DetectorModelDefinition {

    static func write(value: IoTEventsClientTypes.DetectorModelDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["initialStateName"].write(value.initialStateName)
        try writer["states"].writeList(value.states, memberWritingClosure: IoTEventsClientTypes.State.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.DetectorModelDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.DetectorModelDefinition()
        value.states = try reader["states"].readListIfPresent(memberReadingClosure: IoTEventsClientTypes.State.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.initialStateName = try reader["initialStateName"].readIfPresent() ?? ""
        return value
    }
}

extension IoTEventsClientTypes.State {

    static func write(value: IoTEventsClientTypes.State?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["onEnter"].write(value.onEnter, with: IoTEventsClientTypes.OnEnterLifecycle.write(value:to:))
        try writer["onExit"].write(value.onExit, with: IoTEventsClientTypes.OnExitLifecycle.write(value:to:))
        try writer["onInput"].write(value.onInput, with: IoTEventsClientTypes.OnInputLifecycle.write(value:to:))
        try writer["stateName"].write(value.stateName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.State {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.State()
        value.stateName = try reader["stateName"].readIfPresent() ?? ""
        value.onInput = try reader["onInput"].readIfPresent(with: IoTEventsClientTypes.OnInputLifecycle.read(from:))
        value.onEnter = try reader["onEnter"].readIfPresent(with: IoTEventsClientTypes.OnEnterLifecycle.read(from:))
        value.onExit = try reader["onExit"].readIfPresent(with: IoTEventsClientTypes.OnExitLifecycle.read(from:))
        return value
    }
}

extension IoTEventsClientTypes.OnExitLifecycle {

    static func write(value: IoTEventsClientTypes.OnExitLifecycle?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["events"].writeList(value.events, memberWritingClosure: IoTEventsClientTypes.Event.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.OnExitLifecycle {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.OnExitLifecycle()
        value.events = try reader["events"].readListIfPresent(memberReadingClosure: IoTEventsClientTypes.Event.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTEventsClientTypes.Event {

    static func write(value: IoTEventsClientTypes.Event?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actions"].writeList(value.actions, memberWritingClosure: IoTEventsClientTypes.Action.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["condition"].write(value.condition)
        try writer["eventName"].write(value.eventName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.Event {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.Event()
        value.eventName = try reader["eventName"].readIfPresent() ?? ""
        value.condition = try reader["condition"].readIfPresent()
        value.actions = try reader["actions"].readListIfPresent(memberReadingClosure: IoTEventsClientTypes.Action.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTEventsClientTypes.Action {

    static func write(value: IoTEventsClientTypes.Action?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clearTimer"].write(value.clearTimer, with: IoTEventsClientTypes.ClearTimerAction.write(value:to:))
        try writer["dynamoDB"].write(value.dynamoDB, with: IoTEventsClientTypes.DynamoDBAction.write(value:to:))
        try writer["dynamoDBv2"].write(value.dynamoDBv2, with: IoTEventsClientTypes.DynamoDBv2Action.write(value:to:))
        try writer["firehose"].write(value.firehose, with: IoTEventsClientTypes.FirehoseAction.write(value:to:))
        try writer["iotEvents"].write(value.iotEvents, with: IoTEventsClientTypes.IotEventsAction.write(value:to:))
        try writer["iotSiteWise"].write(value.iotSiteWise, with: IoTEventsClientTypes.IotSiteWiseAction.write(value:to:))
        try writer["iotTopicPublish"].write(value.iotTopicPublish, with: IoTEventsClientTypes.IotTopicPublishAction.write(value:to:))
        try writer["lambda"].write(value.lambda, with: IoTEventsClientTypes.LambdaAction.write(value:to:))
        try writer["resetTimer"].write(value.resetTimer, with: IoTEventsClientTypes.ResetTimerAction.write(value:to:))
        try writer["setTimer"].write(value.setTimer, with: IoTEventsClientTypes.SetTimerAction.write(value:to:))
        try writer["setVariable"].write(value.setVariable, with: IoTEventsClientTypes.SetVariableAction.write(value:to:))
        try writer["sns"].write(value.sns, with: IoTEventsClientTypes.SNSTopicPublishAction.write(value:to:))
        try writer["sqs"].write(value.sqs, with: IoTEventsClientTypes.SqsAction.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.Action {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.Action()
        value.setVariable = try reader["setVariable"].readIfPresent(with: IoTEventsClientTypes.SetVariableAction.read(from:))
        value.sns = try reader["sns"].readIfPresent(with: IoTEventsClientTypes.SNSTopicPublishAction.read(from:))
        value.iotTopicPublish = try reader["iotTopicPublish"].readIfPresent(with: IoTEventsClientTypes.IotTopicPublishAction.read(from:))
        value.setTimer = try reader["setTimer"].readIfPresent(with: IoTEventsClientTypes.SetTimerAction.read(from:))
        value.clearTimer = try reader["clearTimer"].readIfPresent(with: IoTEventsClientTypes.ClearTimerAction.read(from:))
        value.resetTimer = try reader["resetTimer"].readIfPresent(with: IoTEventsClientTypes.ResetTimerAction.read(from:))
        value.lambda = try reader["lambda"].readIfPresent(with: IoTEventsClientTypes.LambdaAction.read(from:))
        value.iotEvents = try reader["iotEvents"].readIfPresent(with: IoTEventsClientTypes.IotEventsAction.read(from:))
        value.sqs = try reader["sqs"].readIfPresent(with: IoTEventsClientTypes.SqsAction.read(from:))
        value.firehose = try reader["firehose"].readIfPresent(with: IoTEventsClientTypes.FirehoseAction.read(from:))
        value.dynamoDB = try reader["dynamoDB"].readIfPresent(with: IoTEventsClientTypes.DynamoDBAction.read(from:))
        value.dynamoDBv2 = try reader["dynamoDBv2"].readIfPresent(with: IoTEventsClientTypes.DynamoDBv2Action.read(from:))
        value.iotSiteWise = try reader["iotSiteWise"].readIfPresent(with: IoTEventsClientTypes.IotSiteWiseAction.read(from:))
        return value
    }
}

extension IoTEventsClientTypes.ResetTimerAction {

    static func write(value: IoTEventsClientTypes.ResetTimerAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["timerName"].write(value.timerName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.ResetTimerAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.ResetTimerAction()
        value.timerName = try reader["timerName"].readIfPresent() ?? ""
        return value
    }
}

extension IoTEventsClientTypes.ClearTimerAction {

    static func write(value: IoTEventsClientTypes.ClearTimerAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["timerName"].write(value.timerName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.ClearTimerAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.ClearTimerAction()
        value.timerName = try reader["timerName"].readIfPresent() ?? ""
        return value
    }
}

extension IoTEventsClientTypes.SetTimerAction {

    static func write(value: IoTEventsClientTypes.SetTimerAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["durationExpression"].write(value.durationExpression)
        try writer["seconds"].write(value.seconds)
        try writer["timerName"].write(value.timerName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.SetTimerAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.SetTimerAction()
        value.timerName = try reader["timerName"].readIfPresent() ?? ""
        value.seconds = try reader["seconds"].readIfPresent()
        value.durationExpression = try reader["durationExpression"].readIfPresent()
        return value
    }
}

extension IoTEventsClientTypes.SetVariableAction {

    static func write(value: IoTEventsClientTypes.SetVariableAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["value"].write(value.value)
        try writer["variableName"].write(value.variableName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.SetVariableAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.SetVariableAction()
        value.variableName = try reader["variableName"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension IoTEventsClientTypes.OnEnterLifecycle {

    static func write(value: IoTEventsClientTypes.OnEnterLifecycle?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["events"].writeList(value.events, memberWritingClosure: IoTEventsClientTypes.Event.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.OnEnterLifecycle {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.OnEnterLifecycle()
        value.events = try reader["events"].readListIfPresent(memberReadingClosure: IoTEventsClientTypes.Event.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTEventsClientTypes.OnInputLifecycle {

    static func write(value: IoTEventsClientTypes.OnInputLifecycle?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["events"].writeList(value.events, memberWritingClosure: IoTEventsClientTypes.Event.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["transitionEvents"].writeList(value.transitionEvents, memberWritingClosure: IoTEventsClientTypes.TransitionEvent.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.OnInputLifecycle {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.OnInputLifecycle()
        value.events = try reader["events"].readListIfPresent(memberReadingClosure: IoTEventsClientTypes.Event.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.transitionEvents = try reader["transitionEvents"].readListIfPresent(memberReadingClosure: IoTEventsClientTypes.TransitionEvent.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTEventsClientTypes.TransitionEvent {

    static func write(value: IoTEventsClientTypes.TransitionEvent?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actions"].writeList(value.actions, memberWritingClosure: IoTEventsClientTypes.Action.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["condition"].write(value.condition)
        try writer["eventName"].write(value.eventName)
        try writer["nextState"].write(value.nextState)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.TransitionEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.TransitionEvent()
        value.eventName = try reader["eventName"].readIfPresent() ?? ""
        value.condition = try reader["condition"].readIfPresent() ?? ""
        value.actions = try reader["actions"].readListIfPresent(memberReadingClosure: IoTEventsClientTypes.Action.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextState = try reader["nextState"].readIfPresent() ?? ""
        return value
    }
}

extension IoTEventsClientTypes.Input {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.Input {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.Input()
        value.inputConfiguration = try reader["inputConfiguration"].readIfPresent(with: IoTEventsClientTypes.InputConfiguration.read(from:))
        value.inputDefinition = try reader["inputDefinition"].readIfPresent(with: IoTEventsClientTypes.InputDefinition.read(from:))
        return value
    }
}

extension IoTEventsClientTypes.InputDefinition {

    static func write(value: IoTEventsClientTypes.InputDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributes"].writeList(value.attributes, memberWritingClosure: IoTEventsClientTypes.Attribute.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.InputDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.InputDefinition()
        value.attributes = try reader["attributes"].readListIfPresent(memberReadingClosure: IoTEventsClientTypes.Attribute.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension IoTEventsClientTypes.Attribute {

    static func write(value: IoTEventsClientTypes.Attribute?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["jsonPath"].write(value.jsonPath)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.Attribute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.Attribute()
        value.jsonPath = try reader["jsonPath"].readIfPresent() ?? ""
        return value
    }
}

extension IoTEventsClientTypes.LoggingOptions {

    static func write(value: IoTEventsClientTypes.LoggingOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["detectorDebugOptions"].writeList(value.detectorDebugOptions, memberWritingClosure: IoTEventsClientTypes.DetectorDebugOption.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["enabled"].write(value.enabled)
        try writer["level"].write(value.level)
        try writer["roleArn"].write(value.roleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.LoggingOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.LoggingOptions()
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.level = try reader["level"].readIfPresent() ?? .sdkUnknown("")
        value.enabled = try reader["enabled"].readIfPresent() ?? false
        value.detectorDebugOptions = try reader["detectorDebugOptions"].readListIfPresent(memberReadingClosure: IoTEventsClientTypes.DetectorDebugOption.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTEventsClientTypes.DetectorDebugOption {

    static func write(value: IoTEventsClientTypes.DetectorDebugOption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["detectorModelName"].write(value.detectorModelName)
        try writer["keyValue"].write(value.keyValue)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.DetectorDebugOption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.DetectorDebugOption()
        value.detectorModelName = try reader["detectorModelName"].readIfPresent() ?? ""
        value.keyValue = try reader["keyValue"].readIfPresent()
        return value
    }
}

extension IoTEventsClientTypes.AnalysisResult {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.AnalysisResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.AnalysisResult()
        value.type = try reader["type"].readIfPresent()
        value.level = try reader["level"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        value.locations = try reader["locations"].readListIfPresent(memberReadingClosure: IoTEventsClientTypes.AnalysisResultLocation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTEventsClientTypes.AnalysisResultLocation {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.AnalysisResultLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.AnalysisResultLocation()
        value.path = try reader["path"].readIfPresent()
        return value
    }
}

extension IoTEventsClientTypes.AlarmModelSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.AlarmModelSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.AlarmModelSummary()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.alarmModelDescription = try reader["alarmModelDescription"].readIfPresent()
        value.alarmModelName = try reader["alarmModelName"].readIfPresent()
        return value
    }
}

extension IoTEventsClientTypes.AlarmModelVersionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.AlarmModelVersionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.AlarmModelVersionSummary()
        value.alarmModelName = try reader["alarmModelName"].readIfPresent()
        value.alarmModelArn = try reader["alarmModelArn"].readIfPresent()
        value.alarmModelVersion = try reader["alarmModelVersion"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdateTime = try reader["lastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["status"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        return value
    }
}

extension IoTEventsClientTypes.DetectorModelSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.DetectorModelSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.DetectorModelSummary()
        value.detectorModelName = try reader["detectorModelName"].readIfPresent()
        value.detectorModelDescription = try reader["detectorModelDescription"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IoTEventsClientTypes.DetectorModelVersionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.DetectorModelVersionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.DetectorModelVersionSummary()
        value.detectorModelName = try reader["detectorModelName"].readIfPresent()
        value.detectorModelVersion = try reader["detectorModelVersion"].readIfPresent()
        value.detectorModelArn = try reader["detectorModelArn"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdateTime = try reader["lastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["status"].readIfPresent()
        value.evaluationMethod = try reader["evaluationMethod"].readIfPresent()
        return value
    }
}

extension IoTEventsClientTypes.RoutedResource {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.RoutedResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.RoutedResource()
        value.name = try reader["name"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        return value
    }
}

extension IoTEventsClientTypes.InputSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.InputSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.InputSummary()
        value.inputName = try reader["inputName"].readIfPresent()
        value.inputDescription = try reader["inputDescription"].readIfPresent()
        value.inputArn = try reader["inputArn"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdateTime = try reader["lastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension IoTEventsClientTypes.Tag {

    static func write(value: IoTEventsClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTEventsClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTEventsClientTypes.Tag()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension IoTEventsClientTypes.InputIdentifier {

    static func write(value: IoTEventsClientTypes.InputIdentifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["iotEventsInputIdentifier"].write(value.iotEventsInputIdentifier, with: IoTEventsClientTypes.IotEventsInputIdentifier.write(value:to:))
        try writer["iotSiteWiseInputIdentifier"].write(value.iotSiteWiseInputIdentifier, with: IoTEventsClientTypes.IotSiteWiseInputIdentifier.write(value:to:))
    }
}

extension IoTEventsClientTypes.IotSiteWiseInputIdentifier {

    static func write(value: IoTEventsClientTypes.IotSiteWiseInputIdentifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["iotSiteWiseAssetModelPropertyIdentifier"].write(value.iotSiteWiseAssetModelPropertyIdentifier, with: IoTEventsClientTypes.IotSiteWiseAssetModelPropertyIdentifier.write(value:to:))
    }
}

extension IoTEventsClientTypes.IotSiteWiseAssetModelPropertyIdentifier {

    static func write(value: IoTEventsClientTypes.IotSiteWiseAssetModelPropertyIdentifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assetModelId"].write(value.assetModelId)
        try writer["propertyId"].write(value.propertyId)
    }
}

extension IoTEventsClientTypes.IotEventsInputIdentifier {

    static func write(value: IoTEventsClientTypes.IotEventsInputIdentifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["inputName"].write(value.inputName)
    }
}

public enum IoTEventsClientTypes {}
