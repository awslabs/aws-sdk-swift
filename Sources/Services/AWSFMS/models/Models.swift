// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension FMSClientTypes {
    public enum AccountRoleStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case creating
        case deleted
        case deleting
        case pendingdeletion
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [AccountRoleStatus] {
            return [
                .creating,
                .deleted,
                .deleting,
                .pendingdeletion,
                .ready,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .pendingdeletion: return "PENDING_DELETION"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccountRoleStatus(rawValue: rawValue) ?? AccountRoleStatus.sdkUnknown(rawValue)
        }
    }
}

extension FMSClientTypes.ActionTarget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension FMSClientTypes {
    /// Describes a remediation action target.
    public struct ActionTarget: Swift.Equatable {
        /// A description of the remediation action target.
        public var description: Swift.String?
        /// The ID of the remediation target.
        public var resourceId: Swift.String?

        public init (
            description: Swift.String? = nil,
            resourceId: Swift.String? = nil
        )
        {
            self.description = description
            self.resourceId = resourceId
        }
    }

}

extension FMSClientTypes.App: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appName = "AppName"
        case port = "Port"
        case `protocol` = "Protocol"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appName = self.appName {
            try encodeContainer.encode(appName, forKey: .appName)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`, forKey: .`protocol`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appName)
        appName = appNameDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
    }
}

extension FMSClientTypes {
    /// An individual Firewall Manager application.
    public struct App: Swift.Equatable {
        /// The application's name.
        /// This member is required.
        public var appName: Swift.String?
        /// The application's port number, for example 80.
        /// This member is required.
        public var port: Swift.Int?
        /// The IP protocol name or number. The name can be one of tcp, udp, or icmp. For information on possible numbers, see [Protocol Numbers](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
        /// This member is required.
        public var `protocol`: Swift.String?

        public init (
            appName: Swift.String? = nil,
            port: Swift.Int? = nil,
            `protocol`: Swift.String? = nil
        )
        {
            self.appName = appName
            self.port = port
            self.`protocol` = `protocol`
        }
    }

}

extension FMSClientTypes.AppsListData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appsList = "AppsList"
        case createTime = "CreateTime"
        case lastUpdateTime = "LastUpdateTime"
        case listId = "ListId"
        case listName = "ListName"
        case listUpdateToken = "ListUpdateToken"
        case previousAppsList = "PreviousAppsList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appsList = appsList {
            var appsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .appsList)
            for app0 in appsList {
                try appsListContainer.encode(app0)
            }
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let lastUpdateTime = self.lastUpdateTime {
            try encodeContainer.encodeTimestamp(lastUpdateTime, format: .epochSeconds, forKey: .lastUpdateTime)
        }
        if let listId = self.listId {
            try encodeContainer.encode(listId, forKey: .listId)
        }
        if let listName = self.listName {
            try encodeContainer.encode(listName, forKey: .listName)
        }
        if let listUpdateToken = self.listUpdateToken {
            try encodeContainer.encode(listUpdateToken, forKey: .listUpdateToken)
        }
        if let previousAppsList = previousAppsList {
            var previousAppsListContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .previousAppsList)
            for (dictKey0, previousAppsList0) in previousAppsList {
                var previousAppsList0Container = previousAppsListContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for app1 in previousAppsList0 {
                    try previousAppsList0Container.encode(app1)
                }
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listId)
        listId = listIdDecoded
        let listNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listName)
        listName = listNameDecoded
        let listUpdateTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listUpdateToken)
        listUpdateToken = listUpdateTokenDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let appsListContainer = try containerValues.decodeIfPresent([FMSClientTypes.App?].self, forKey: .appsList)
        var appsListDecoded0:[FMSClientTypes.App]? = nil
        if let appsListContainer = appsListContainer {
            appsListDecoded0 = [FMSClientTypes.App]()
            for structure0 in appsListContainer {
                if let structure0 = structure0 {
                    appsListDecoded0?.append(structure0)
                }
            }
        }
        appsList = appsListDecoded0
        let previousAppsListContainer = try containerValues.decodeIfPresent([Swift.String: [FMSClientTypes.App?]?].self, forKey: .previousAppsList)
        var previousAppsListDecoded0: [Swift.String:[FMSClientTypes.App]]? = nil
        if let previousAppsListContainer = previousAppsListContainer {
            previousAppsListDecoded0 = [Swift.String:[FMSClientTypes.App]]()
            for (key0, appslist0) in previousAppsListContainer {
                var appslist0Decoded0: [FMSClientTypes.App]? = nil
                if let appslist0 = appslist0 {
                    appslist0Decoded0 = [FMSClientTypes.App]()
                    for structure1 in appslist0 {
                        if let structure1 = structure1 {
                            appslist0Decoded0?.append(structure1)
                        }
                    }
                }
                previousAppsListDecoded0?[key0] = appslist0Decoded0
            }
        }
        previousAppsList = previousAppsListDecoded0
    }
}

extension FMSClientTypes {
    /// An Firewall Manager applications list.
    public struct AppsListData: Swift.Equatable {
        /// An array of applications in the Firewall Manager applications list.
        /// This member is required.
        public var appsList: [FMSClientTypes.App]?
        /// The time that the Firewall Manager applications list was created.
        public var createTime: ClientRuntime.Date?
        /// The time that the Firewall Manager applications list was last updated.
        public var lastUpdateTime: ClientRuntime.Date?
        /// The ID of the Firewall Manager applications list.
        public var listId: Swift.String?
        /// The name of the Firewall Manager applications list.
        /// This member is required.
        public var listName: Swift.String?
        /// A unique identifier for each update to the list. When you update the list, the update token must match the token of the current version of the application list. You can retrieve the update token by getting the list.
        public var listUpdateToken: Swift.String?
        /// A map of previous version numbers to their corresponding App object arrays.
        public var previousAppsList: [Swift.String:[FMSClientTypes.App]]?

        public init (
            appsList: [FMSClientTypes.App]? = nil,
            createTime: ClientRuntime.Date? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            listId: Swift.String? = nil,
            listName: Swift.String? = nil,
            listUpdateToken: Swift.String? = nil,
            previousAppsList: [Swift.String:[FMSClientTypes.App]]? = nil
        )
        {
            self.appsList = appsList
            self.createTime = createTime
            self.lastUpdateTime = lastUpdateTime
            self.listId = listId
            self.listName = listName
            self.listUpdateToken = listUpdateToken
            self.previousAppsList = previousAppsList
        }
    }

}

extension FMSClientTypes.AppsListDataSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appsList = "AppsList"
        case listArn = "ListArn"
        case listId = "ListId"
        case listName = "ListName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appsList = appsList {
            var appsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .appsList)
            for app0 in appsList {
                try appsListContainer.encode(app0)
            }
        }
        if let listArn = self.listArn {
            try encodeContainer.encode(listArn, forKey: .listArn)
        }
        if let listId = self.listId {
            try encodeContainer.encode(listId, forKey: .listId)
        }
        if let listName = self.listName {
            try encodeContainer.encode(listName, forKey: .listName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listArn)
        listArn = listArnDecoded
        let listIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listId)
        listId = listIdDecoded
        let listNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listName)
        listName = listNameDecoded
        let appsListContainer = try containerValues.decodeIfPresent([FMSClientTypes.App?].self, forKey: .appsList)
        var appsListDecoded0:[FMSClientTypes.App]? = nil
        if let appsListContainer = appsListContainer {
            appsListDecoded0 = [FMSClientTypes.App]()
            for structure0 in appsListContainer {
                if let structure0 = structure0 {
                    appsListDecoded0?.append(structure0)
                }
            }
        }
        appsList = appsListDecoded0
    }
}

extension FMSClientTypes {
    /// Details of the Firewall Manager applications list.
    public struct AppsListDataSummary: Swift.Equatable {
        /// An array of App objects in the Firewall Manager applications list.
        public var appsList: [FMSClientTypes.App]?
        /// The Amazon Resource Name (ARN) of the applications list.
        public var listArn: Swift.String?
        /// The ID of the applications list.
        public var listId: Swift.String?
        /// The name of the applications list.
        public var listName: Swift.String?

        public init (
            appsList: [FMSClientTypes.App]? = nil,
            listArn: Swift.String? = nil,
            listId: Swift.String? = nil,
            listName: Swift.String? = nil
        )
        {
            self.appsList = appsList
            self.listArn = listArn
            self.listId = listId
            self.listName = listName
        }
    }

}

extension AssociateAdminAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccount = "AdminAccount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminAccount = self.adminAccount {
            try encodeContainer.encode(adminAccount, forKey: .adminAccount)
        }
    }
}

extension AssociateAdminAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateAdminAccountInput: Swift.Equatable {
    /// The Amazon Web Services account ID to associate with Firewall Manager as the Firewall Manager administrator account. This must be an Organizations member account. For more information about Organizations, see [Managing the Amazon Web Services Accounts in Your Organization](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_manage_accounts.html).
    /// This member is required.
    public var adminAccount: Swift.String?

    public init (
        adminAccount: Swift.String? = nil
    )
    {
        self.adminAccount = adminAccount
    }
}

struct AssociateAdminAccountInputBody: Swift.Equatable {
    let adminAccount: Swift.String?
}

extension AssociateAdminAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccount = "AdminAccount"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminAccount)
        adminAccount = adminAccountDecoded
    }
}

extension AssociateAdminAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateAdminAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateAdminAccountOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case invalidOperationException(InvalidOperationException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateAdminAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateAdminAccountOutputResponse: Swift.Equatable {

    public init () { }
}

extension AssociateThirdPartyFirewallInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case thirdPartyFirewall = "ThirdPartyFirewall"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let thirdPartyFirewall = self.thirdPartyFirewall {
            try encodeContainer.encode(thirdPartyFirewall.rawValue, forKey: .thirdPartyFirewall)
        }
    }
}

extension AssociateThirdPartyFirewallInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateThirdPartyFirewallInput: Swift.Equatable {
    /// The name of the third-party firewall vendor.
    /// This member is required.
    public var thirdPartyFirewall: FMSClientTypes.ThirdPartyFirewall?

    public init (
        thirdPartyFirewall: FMSClientTypes.ThirdPartyFirewall? = nil
    )
    {
        self.thirdPartyFirewall = thirdPartyFirewall
    }
}

struct AssociateThirdPartyFirewallInputBody: Swift.Equatable {
    let thirdPartyFirewall: FMSClientTypes.ThirdPartyFirewall?
}

extension AssociateThirdPartyFirewallInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case thirdPartyFirewall = "ThirdPartyFirewall"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thirdPartyFirewallDecoded = try containerValues.decodeIfPresent(FMSClientTypes.ThirdPartyFirewall.self, forKey: .thirdPartyFirewall)
        thirdPartyFirewall = thirdPartyFirewallDecoded
    }
}

extension AssociateThirdPartyFirewallOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateThirdPartyFirewallOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateThirdPartyFirewallOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateThirdPartyFirewallOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AssociateThirdPartyFirewallOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.thirdPartyFirewallStatus = output.thirdPartyFirewallStatus
        } else {
            self.thirdPartyFirewallStatus = nil
        }
    }
}

public struct AssociateThirdPartyFirewallOutputResponse: Swift.Equatable {
    /// The current status for setting a Firewall Manager policy administrator's account as an administrator of the third-party firewall tenant.
    ///
    /// * ONBOARDING - The Firewall Manager policy administrator is being designated as a tenant administrator.
    ///
    /// * ONBOARD_COMPLETE - The Firewall Manager policy administrator is designated as a tenant administrator.
    ///
    /// * OFFBOARDING - The Firewall Manager policy administrator is being removed as a tenant administrator.
    ///
    /// * OFFBOARD_COMPLETE - The Firewall Manager policy administrator has been removed as a tenant administrator.
    ///
    /// * NOT_EXIST - The Firewall Manager policy administrator doesn't exist as a tenant administrator.
    public var thirdPartyFirewallStatus: FMSClientTypes.ThirdPartyFirewallAssociationStatus?

    public init (
        thirdPartyFirewallStatus: FMSClientTypes.ThirdPartyFirewallAssociationStatus? = nil
    )
    {
        self.thirdPartyFirewallStatus = thirdPartyFirewallStatus
    }
}

struct AssociateThirdPartyFirewallOutputResponseBody: Swift.Equatable {
    let thirdPartyFirewallStatus: FMSClientTypes.ThirdPartyFirewallAssociationStatus?
}

extension AssociateThirdPartyFirewallOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case thirdPartyFirewallStatus = "ThirdPartyFirewallStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thirdPartyFirewallStatusDecoded = try containerValues.decodeIfPresent(FMSClientTypes.ThirdPartyFirewallAssociationStatus.self, forKey: .thirdPartyFirewallStatus)
        thirdPartyFirewallStatus = thirdPartyFirewallStatusDecoded
    }
}

extension FMSClientTypes.AwsEc2InstanceViolation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsEc2NetworkInterfaceViolations = "AwsEc2NetworkInterfaceViolations"
        case violationTarget = "ViolationTarget"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsEc2NetworkInterfaceViolations = awsEc2NetworkInterfaceViolations {
            var awsEc2NetworkInterfaceViolationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .awsEc2NetworkInterfaceViolations)
            for awsec2networkinterfaceviolation0 in awsEc2NetworkInterfaceViolations {
                try awsEc2NetworkInterfaceViolationsContainer.encode(awsec2networkinterfaceviolation0)
            }
        }
        if let violationTarget = self.violationTarget {
            try encodeContainer.encode(violationTarget, forKey: .violationTarget)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .violationTarget)
        violationTarget = violationTargetDecoded
        let awsEc2NetworkInterfaceViolationsContainer = try containerValues.decodeIfPresent([FMSClientTypes.AwsEc2NetworkInterfaceViolation?].self, forKey: .awsEc2NetworkInterfaceViolations)
        var awsEc2NetworkInterfaceViolationsDecoded0:[FMSClientTypes.AwsEc2NetworkInterfaceViolation]? = nil
        if let awsEc2NetworkInterfaceViolationsContainer = awsEc2NetworkInterfaceViolationsContainer {
            awsEc2NetworkInterfaceViolationsDecoded0 = [FMSClientTypes.AwsEc2NetworkInterfaceViolation]()
            for structure0 in awsEc2NetworkInterfaceViolationsContainer {
                if let structure0 = structure0 {
                    awsEc2NetworkInterfaceViolationsDecoded0?.append(structure0)
                }
            }
        }
        awsEc2NetworkInterfaceViolations = awsEc2NetworkInterfaceViolationsDecoded0
    }
}

extension FMSClientTypes {
    /// Violation detail for an EC2 instance resource.
    public struct AwsEc2InstanceViolation: Swift.Equatable {
        /// Violation detail for network interfaces associated with the EC2 instance.
        public var awsEc2NetworkInterfaceViolations: [FMSClientTypes.AwsEc2NetworkInterfaceViolation]?
        /// The resource ID of the EC2 instance.
        public var violationTarget: Swift.String?

        public init (
            awsEc2NetworkInterfaceViolations: [FMSClientTypes.AwsEc2NetworkInterfaceViolation]? = nil,
            violationTarget: Swift.String? = nil
        )
        {
            self.awsEc2NetworkInterfaceViolations = awsEc2NetworkInterfaceViolations
            self.violationTarget = violationTarget
        }
    }

}

extension FMSClientTypes.AwsEc2NetworkInterfaceViolation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case violatingSecurityGroups = "ViolatingSecurityGroups"
        case violationTarget = "ViolationTarget"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let violatingSecurityGroups = violatingSecurityGroups {
            var violatingSecurityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .violatingSecurityGroups)
            for resourceid0 in violatingSecurityGroups {
                try violatingSecurityGroupsContainer.encode(resourceid0)
            }
        }
        if let violationTarget = self.violationTarget {
            try encodeContainer.encode(violationTarget, forKey: .violationTarget)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .violationTarget)
        violationTarget = violationTargetDecoded
        let violatingSecurityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .violatingSecurityGroups)
        var violatingSecurityGroupsDecoded0:[Swift.String]? = nil
        if let violatingSecurityGroupsContainer = violatingSecurityGroupsContainer {
            violatingSecurityGroupsDecoded0 = [Swift.String]()
            for string0 in violatingSecurityGroupsContainer {
                if let string0 = string0 {
                    violatingSecurityGroupsDecoded0?.append(string0)
                }
            }
        }
        violatingSecurityGroups = violatingSecurityGroupsDecoded0
    }
}

extension FMSClientTypes {
    /// Violation detail for network interfaces associated with an EC2 instance.
    public struct AwsEc2NetworkInterfaceViolation: Swift.Equatable {
        /// List of security groups that violate the rules specified in the primary security group of the Firewall Manager policy.
        public var violatingSecurityGroups: [Swift.String]?
        /// The resource ID of the network interface.
        public var violationTarget: Swift.String?

        public init (
            violatingSecurityGroups: [Swift.String]? = nil,
            violationTarget: Swift.String? = nil
        )
        {
            self.violatingSecurityGroups = violatingSecurityGroups
            self.violationTarget = violationTarget
        }
    }

}

extension FMSClientTypes.AwsVPCSecurityGroupViolation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case partialMatches = "PartialMatches"
        case possibleSecurityGroupRemediationActions = "PossibleSecurityGroupRemediationActions"
        case violationTarget = "ViolationTarget"
        case violationTargetDescription = "ViolationTargetDescription"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let partialMatches = partialMatches {
            var partialMatchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partialMatches)
            for partialmatch0 in partialMatches {
                try partialMatchesContainer.encode(partialmatch0)
            }
        }
        if let possibleSecurityGroupRemediationActions = possibleSecurityGroupRemediationActions {
            var possibleSecurityGroupRemediationActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .possibleSecurityGroupRemediationActions)
            for securitygroupremediationaction0 in possibleSecurityGroupRemediationActions {
                try possibleSecurityGroupRemediationActionsContainer.encode(securitygroupremediationaction0)
            }
        }
        if let violationTarget = self.violationTarget {
            try encodeContainer.encode(violationTarget, forKey: .violationTarget)
        }
        if let violationTargetDescription = self.violationTargetDescription {
            try encodeContainer.encode(violationTargetDescription, forKey: .violationTargetDescription)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .violationTarget)
        violationTarget = violationTargetDecoded
        let violationTargetDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .violationTargetDescription)
        violationTargetDescription = violationTargetDescriptionDecoded
        let partialMatchesContainer = try containerValues.decodeIfPresent([FMSClientTypes.PartialMatch?].self, forKey: .partialMatches)
        var partialMatchesDecoded0:[FMSClientTypes.PartialMatch]? = nil
        if let partialMatchesContainer = partialMatchesContainer {
            partialMatchesDecoded0 = [FMSClientTypes.PartialMatch]()
            for structure0 in partialMatchesContainer {
                if let structure0 = structure0 {
                    partialMatchesDecoded0?.append(structure0)
                }
            }
        }
        partialMatches = partialMatchesDecoded0
        let possibleSecurityGroupRemediationActionsContainer = try containerValues.decodeIfPresent([FMSClientTypes.SecurityGroupRemediationAction?].self, forKey: .possibleSecurityGroupRemediationActions)
        var possibleSecurityGroupRemediationActionsDecoded0:[FMSClientTypes.SecurityGroupRemediationAction]? = nil
        if let possibleSecurityGroupRemediationActionsContainer = possibleSecurityGroupRemediationActionsContainer {
            possibleSecurityGroupRemediationActionsDecoded0 = [FMSClientTypes.SecurityGroupRemediationAction]()
            for structure0 in possibleSecurityGroupRemediationActionsContainer {
                if let structure0 = structure0 {
                    possibleSecurityGroupRemediationActionsDecoded0?.append(structure0)
                }
            }
        }
        possibleSecurityGroupRemediationActions = possibleSecurityGroupRemediationActionsDecoded0
    }
}

extension FMSClientTypes {
    /// Violation detail for the rule violation in a security group when compared to the primary security group of the Firewall Manager policy.
    public struct AwsVPCSecurityGroupViolation: Swift.Equatable {
        /// List of rules specified in the security group of the Firewall Manager policy that partially match the ViolationTarget rule.
        public var partialMatches: [FMSClientTypes.PartialMatch]?
        /// Remediation options for the rule specified in the ViolationTarget.
        public var possibleSecurityGroupRemediationActions: [FMSClientTypes.SecurityGroupRemediationAction]?
        /// The security group rule that is being evaluated.
        public var violationTarget: Swift.String?
        /// A description of the security group that violates the policy.
        public var violationTargetDescription: Swift.String?

        public init (
            partialMatches: [FMSClientTypes.PartialMatch]? = nil,
            possibleSecurityGroupRemediationActions: [FMSClientTypes.SecurityGroupRemediationAction]? = nil,
            violationTarget: Swift.String? = nil,
            violationTargetDescription: Swift.String? = nil
        )
        {
            self.partialMatches = partialMatches
            self.possibleSecurityGroupRemediationActions = possibleSecurityGroupRemediationActions
            self.violationTarget = violationTarget
            self.violationTargetDescription = violationTargetDescription
        }
    }

}

extension BatchAssociateResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case resourceSetIdentifier = "ResourceSetIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for identifier0 in items {
                try itemsContainer.encode(identifier0)
            }
        }
        if let resourceSetIdentifier = self.resourceSetIdentifier {
            try encodeContainer.encode(resourceSetIdentifier, forKey: .resourceSetIdentifier)
        }
    }
}

extension BatchAssociateResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchAssociateResourceInput: Swift.Equatable {
    /// The uniform resource identifiers (URIs) of resources that should be associated to the resource set. The URIs must be Amazon Resource Names (ARNs).
    /// This member is required.
    public var items: [Swift.String]?
    /// A unique identifier for the resource set, used in a TODO to refer to the resource set.
    /// This member is required.
    public var resourceSetIdentifier: Swift.String?

    public init (
        items: [Swift.String]? = nil,
        resourceSetIdentifier: Swift.String? = nil
    )
    {
        self.items = items
        self.resourceSetIdentifier = resourceSetIdentifier
    }
}

struct BatchAssociateResourceInputBody: Swift.Equatable {
    let resourceSetIdentifier: Swift.String?
    let items: [Swift.String]?
}

extension BatchAssociateResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case resourceSetIdentifier = "ResourceSetIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceSetIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetIdentifier)
        resourceSetIdentifier = resourceSetIdentifierDecoded
        let itemsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .items)
        var itemsDecoded0:[Swift.String]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [Swift.String]()
            for string0 in itemsContainer {
                if let string0 = string0 {
                    itemsDecoded0?.append(string0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension BatchAssociateResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchAssociateResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchAssociateResourceOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case invalidOperationException(InvalidOperationException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchAssociateResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchAssociateResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedItems = output.failedItems
            self.resourceSetIdentifier = output.resourceSetIdentifier
        } else {
            self.failedItems = nil
            self.resourceSetIdentifier = nil
        }
    }
}

public struct BatchAssociateResourceOutputResponse: Swift.Equatable {
    /// The resources that failed to associate to the resource set.
    /// This member is required.
    public var failedItems: [FMSClientTypes.FailedItem]?
    /// A unique identifier for the resource set, used in a TODO to refer to the resource set.
    /// This member is required.
    public var resourceSetIdentifier: Swift.String?

    public init (
        failedItems: [FMSClientTypes.FailedItem]? = nil,
        resourceSetIdentifier: Swift.String? = nil
    )
    {
        self.failedItems = failedItems
        self.resourceSetIdentifier = resourceSetIdentifier
    }
}

struct BatchAssociateResourceOutputResponseBody: Swift.Equatable {
    let resourceSetIdentifier: Swift.String?
    let failedItems: [FMSClientTypes.FailedItem]?
}

extension BatchAssociateResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedItems = "FailedItems"
        case resourceSetIdentifier = "ResourceSetIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceSetIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetIdentifier)
        resourceSetIdentifier = resourceSetIdentifierDecoded
        let failedItemsContainer = try containerValues.decodeIfPresent([FMSClientTypes.FailedItem?].self, forKey: .failedItems)
        var failedItemsDecoded0:[FMSClientTypes.FailedItem]? = nil
        if let failedItemsContainer = failedItemsContainer {
            failedItemsDecoded0 = [FMSClientTypes.FailedItem]()
            for structure0 in failedItemsContainer {
                if let structure0 = structure0 {
                    failedItemsDecoded0?.append(structure0)
                }
            }
        }
        failedItems = failedItemsDecoded0
    }
}

extension BatchDisassociateResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case resourceSetIdentifier = "ResourceSetIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for identifier0 in items {
                try itemsContainer.encode(identifier0)
            }
        }
        if let resourceSetIdentifier = self.resourceSetIdentifier {
            try encodeContainer.encode(resourceSetIdentifier, forKey: .resourceSetIdentifier)
        }
    }
}

extension BatchDisassociateResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchDisassociateResourceInput: Swift.Equatable {
    /// The uniform resource identifiers (URI) of resources that should be disassociated from the resource set. The URIs must be Amazon Resource Names (ARNs).
    /// This member is required.
    public var items: [Swift.String]?
    /// A unique identifier for the resource set, used in a TODO to refer to the resource set.
    /// This member is required.
    public var resourceSetIdentifier: Swift.String?

    public init (
        items: [Swift.String]? = nil,
        resourceSetIdentifier: Swift.String? = nil
    )
    {
        self.items = items
        self.resourceSetIdentifier = resourceSetIdentifier
    }
}

struct BatchDisassociateResourceInputBody: Swift.Equatable {
    let resourceSetIdentifier: Swift.String?
    let items: [Swift.String]?
}

extension BatchDisassociateResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case resourceSetIdentifier = "ResourceSetIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceSetIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetIdentifier)
        resourceSetIdentifier = resourceSetIdentifierDecoded
        let itemsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .items)
        var itemsDecoded0:[Swift.String]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [Swift.String]()
            for string0 in itemsContainer {
                if let string0 = string0 {
                    itemsDecoded0?.append(string0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension BatchDisassociateResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDisassociateResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchDisassociateResourceOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDisassociateResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchDisassociateResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedItems = output.failedItems
            self.resourceSetIdentifier = output.resourceSetIdentifier
        } else {
            self.failedItems = nil
            self.resourceSetIdentifier = nil
        }
    }
}

public struct BatchDisassociateResourceOutputResponse: Swift.Equatable {
    /// The resources that failed to disassociate from the resource set.
    /// This member is required.
    public var failedItems: [FMSClientTypes.FailedItem]?
    /// A unique identifier for the resource set, used in a TODO to refer to the resource set.
    /// This member is required.
    public var resourceSetIdentifier: Swift.String?

    public init (
        failedItems: [FMSClientTypes.FailedItem]? = nil,
        resourceSetIdentifier: Swift.String? = nil
    )
    {
        self.failedItems = failedItems
        self.resourceSetIdentifier = resourceSetIdentifier
    }
}

struct BatchDisassociateResourceOutputResponseBody: Swift.Equatable {
    let resourceSetIdentifier: Swift.String?
    let failedItems: [FMSClientTypes.FailedItem]?
}

extension BatchDisassociateResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedItems = "FailedItems"
        case resourceSetIdentifier = "ResourceSetIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceSetIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetIdentifier)
        resourceSetIdentifier = resourceSetIdentifierDecoded
        let failedItemsContainer = try containerValues.decodeIfPresent([FMSClientTypes.FailedItem?].self, forKey: .failedItems)
        var failedItemsDecoded0:[FMSClientTypes.FailedItem]? = nil
        if let failedItemsContainer = failedItemsContainer {
            failedItemsDecoded0 = [FMSClientTypes.FailedItem]()
            for structure0 in failedItemsContainer {
                if let structure0 = structure0 {
                    failedItemsDecoded0?.append(structure0)
                }
            }
        }
        failedItems = failedItemsDecoded0
    }
}

extension FMSClientTypes.ComplianceViolator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case violationReason = "ViolationReason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metadata)
            for (dictKey0, complianceViolatorMetadata0) in metadata {
                try metadataContainer.encode(complianceViolatorMetadata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let violationReason = self.violationReason {
            try encodeContainer.encode(violationReason.rawValue, forKey: .violationReason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let violationReasonDecoded = try containerValues.decodeIfPresent(FMSClientTypes.ViolationReason.self, forKey: .violationReason)
        violationReason = violationReasonDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:Swift.String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, lengthboundedstring0) in metadataContainer {
                if let lengthboundedstring0 = lengthboundedstring0 {
                    metadataDecoded0?[key0] = lengthboundedstring0
                }
            }
        }
        metadata = metadataDecoded0
    }
}

extension FMSClientTypes {
    /// Details of the resource that is not protected by the policy.
    public struct ComplianceViolator: Swift.Equatable {
        /// Metadata about the resource that doesn't comply with the policy scope.
        public var metadata: [Swift.String:Swift.String]?
        /// The resource ID.
        public var resourceId: Swift.String?
        /// The resource type. This is in the format shown in the [Amazon Web Services Resource Types Reference](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html). For example: AWS::ElasticLoadBalancingV2::LoadBalancer, AWS::CloudFront::Distribution, or AWS::NetworkFirewall::FirewallPolicy.
        public var resourceType: Swift.String?
        /// The reason that the resource is not protected by the policy.
        public var violationReason: FMSClientTypes.ViolationReason?

        public init (
            metadata: [Swift.String:Swift.String]? = nil,
            resourceId: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            violationReason: FMSClientTypes.ViolationReason? = nil
        )
        {
            self.metadata = metadata
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.violationReason = violationReason
        }
    }

}

extension FMSClientTypes {
    public enum CustomerPolicyScopeIdType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case account
        case orgUnit
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomerPolicyScopeIdType] {
            return [
                .account,
                .orgUnit,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .account: return "ACCOUNT"
            case .orgUnit: return "ORG_UNIT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CustomerPolicyScopeIdType(rawValue: rawValue) ?? CustomerPolicyScopeIdType.sdkUnknown(rawValue)
        }
    }
}

extension DeleteAppsListInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listId = "ListId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listId = self.listId {
            try encodeContainer.encode(listId, forKey: .listId)
        }
    }
}

extension DeleteAppsListInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAppsListInput: Swift.Equatable {
    /// The ID of the applications list that you want to delete. You can retrieve this ID from PutAppsList, ListAppsLists, and GetAppsList.
    /// This member is required.
    public var listId: Swift.String?

    public init (
        listId: Swift.String? = nil
    )
    {
        self.listId = listId
    }
}

struct DeleteAppsListInputBody: Swift.Equatable {
    let listId: Swift.String?
}

extension DeleteAppsListInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listId = "ListId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listId)
        listId = listIdDecoded
    }
}

extension DeleteAppsListOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAppsListOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteAppsListOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAppsListOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAppsListOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteNotificationChannelInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeleteNotificationChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteNotificationChannelInput: Swift.Equatable {

    public init () { }
}

struct DeleteNotificationChannelInputBody: Swift.Equatable {
}

extension DeleteNotificationChannelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteNotificationChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteNotificationChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteNotificationChannelOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteNotificationChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteNotificationChannelOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeletePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteAllPolicyResources = "DeleteAllPolicyResources"
        case policyId = "PolicyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if deleteAllPolicyResources != false {
            try encodeContainer.encode(deleteAllPolicyResources, forKey: .deleteAllPolicyResources)
        }
        if let policyId = self.policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
    }
}

extension DeletePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeletePolicyInput: Swift.Equatable {
    /// If True, the request performs cleanup according to the policy type. For WAF and Shield Advanced policies, the cleanup does the following:
    ///
    /// * Deletes rule groups created by Firewall Manager
    ///
    /// * Removes web ACLs from in-scope resources
    ///
    /// * Deletes web ACLs that contain no rules or rule groups
    ///
    ///
    /// For security group policies, the cleanup does the following for each security group in the policy:
    ///
    /// * Disassociates the security group from in-scope resources
    ///
    /// * Deletes the security group if it was created through Firewall Manager and if it's no longer associated with any resources through another policy
    ///
    ///
    /// After the cleanup, in-scope resources are no longer protected by web ACLs in this policy. Protection of out-of-scope resources remains unchanged. Scope is determined by tags that you create and accounts that you associate with the policy. When creating the policy, if you specify that only resources in specific accounts or with specific tags are in scope of the policy, those accounts and resources are handled by the policy. All others are out of scope. If you don't specify tags or accounts, all resources are in scope.
    public var deleteAllPolicyResources: Swift.Bool
    /// The ID of the policy that you want to delete. You can retrieve this ID from PutPolicy and ListPolicies.
    /// This member is required.
    public var policyId: Swift.String?

    public init (
        deleteAllPolicyResources: Swift.Bool = false,
        policyId: Swift.String? = nil
    )
    {
        self.deleteAllPolicyResources = deleteAllPolicyResources
        self.policyId = policyId
    }
}

struct DeletePolicyInputBody: Swift.Equatable {
    let policyId: Swift.String?
    let deleteAllPolicyResources: Swift.Bool
}

extension DeletePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteAllPolicyResources = "DeleteAllPolicyResources"
        case policyId = "PolicyId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let deleteAllPolicyResourcesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleteAllPolicyResources) ?? false
        deleteAllPolicyResources = deleteAllPolicyResourcesDecoded
    }
}

extension DeletePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeletePolicyOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case invalidOperationException(InvalidOperationException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteProtocolsListInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listId = "ListId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listId = self.listId {
            try encodeContainer.encode(listId, forKey: .listId)
        }
    }
}

extension DeleteProtocolsListInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteProtocolsListInput: Swift.Equatable {
    /// The ID of the protocols list that you want to delete. You can retrieve this ID from PutProtocolsList, ListProtocolsLists, and GetProtocolsLost.
    /// This member is required.
    public var listId: Swift.String?

    public init (
        listId: Swift.String? = nil
    )
    {
        self.listId = listId
    }
}

struct DeleteProtocolsListInputBody: Swift.Equatable {
    let listId: Swift.String?
}

extension DeleteProtocolsListInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listId = "ListId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listId)
        listId = listIdDecoded
    }
}

extension DeleteProtocolsListOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProtocolsListOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteProtocolsListOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProtocolsListOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteProtocolsListOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteResourceSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier = "Identifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
    }
}

extension DeleteResourceSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteResourceSetInput: Swift.Equatable {
    /// A unique identifier for the resource set, used in a TODO to refer to the resource set.
    /// This member is required.
    public var identifier: Swift.String?

    public init (
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

struct DeleteResourceSetInputBody: Swift.Equatable {
    let identifier: Swift.String?
}

extension DeleteResourceSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier = "Identifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
    }
}

extension DeleteResourceSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourceSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteResourceSetOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourceSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteResourceSetOutputResponse: Swift.Equatable {

    public init () { }
}

extension FMSClientTypes {
    public enum DependentServiceName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsconfig
        case awsshieldadvanced
        case awsvirtualprivatecloud
        case awswaf
        case sdkUnknown(Swift.String)

        public static var allCases: [DependentServiceName] {
            return [
                .awsconfig,
                .awsshieldadvanced,
                .awsvirtualprivatecloud,
                .awswaf,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsconfig: return "AWSCONFIG"
            case .awsshieldadvanced: return "AWSSHIELD_ADVANCED"
            case .awsvirtualprivatecloud: return "AWSVPC"
            case .awswaf: return "AWSWAF"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DependentServiceName(rawValue: rawValue) ?? DependentServiceName.sdkUnknown(rawValue)
        }
    }
}

extension FMSClientTypes {
    public enum DestinationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ipv4
        case ipv6
        case prefixlist
        case sdkUnknown(Swift.String)

        public static var allCases: [DestinationType] {
            return [
                .ipv4,
                .ipv6,
                .prefixlist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ipv4: return "IPV4"
            case .ipv6: return "IPV6"
            case .prefixlist: return "PREFIX_LIST"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DestinationType(rawValue: rawValue) ?? DestinationType.sdkUnknown(rawValue)
        }
    }
}

extension DisassociateAdminAccountInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DisassociateAdminAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateAdminAccountInput: Swift.Equatable {

    public init () { }
}

struct DisassociateAdminAccountInputBody: Swift.Equatable {
}

extension DisassociateAdminAccountInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateAdminAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateAdminAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateAdminAccountOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateAdminAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateAdminAccountOutputResponse: Swift.Equatable {

    public init () { }
}

extension DisassociateThirdPartyFirewallInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case thirdPartyFirewall = "ThirdPartyFirewall"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let thirdPartyFirewall = self.thirdPartyFirewall {
            try encodeContainer.encode(thirdPartyFirewall.rawValue, forKey: .thirdPartyFirewall)
        }
    }
}

extension DisassociateThirdPartyFirewallInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateThirdPartyFirewallInput: Swift.Equatable {
    /// The name of the third-party firewall vendor.
    /// This member is required.
    public var thirdPartyFirewall: FMSClientTypes.ThirdPartyFirewall?

    public init (
        thirdPartyFirewall: FMSClientTypes.ThirdPartyFirewall? = nil
    )
    {
        self.thirdPartyFirewall = thirdPartyFirewall
    }
}

struct DisassociateThirdPartyFirewallInputBody: Swift.Equatable {
    let thirdPartyFirewall: FMSClientTypes.ThirdPartyFirewall?
}

extension DisassociateThirdPartyFirewallInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case thirdPartyFirewall = "ThirdPartyFirewall"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thirdPartyFirewallDecoded = try containerValues.decodeIfPresent(FMSClientTypes.ThirdPartyFirewall.self, forKey: .thirdPartyFirewall)
        thirdPartyFirewall = thirdPartyFirewallDecoded
    }
}

extension DisassociateThirdPartyFirewallOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateThirdPartyFirewallOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateThirdPartyFirewallOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateThirdPartyFirewallOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DisassociateThirdPartyFirewallOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.thirdPartyFirewallStatus = output.thirdPartyFirewallStatus
        } else {
            self.thirdPartyFirewallStatus = nil
        }
    }
}

public struct DisassociateThirdPartyFirewallOutputResponse: Swift.Equatable {
    /// The current status for the disassociation of a Firewall Manager administrators account with a third-party firewall.
    public var thirdPartyFirewallStatus: FMSClientTypes.ThirdPartyFirewallAssociationStatus?

    public init (
        thirdPartyFirewallStatus: FMSClientTypes.ThirdPartyFirewallAssociationStatus? = nil
    )
    {
        self.thirdPartyFirewallStatus = thirdPartyFirewallStatus
    }
}

struct DisassociateThirdPartyFirewallOutputResponseBody: Swift.Equatable {
    let thirdPartyFirewallStatus: FMSClientTypes.ThirdPartyFirewallAssociationStatus?
}

extension DisassociateThirdPartyFirewallOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case thirdPartyFirewallStatus = "ThirdPartyFirewallStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thirdPartyFirewallStatusDecoded = try containerValues.decodeIfPresent(FMSClientTypes.ThirdPartyFirewallAssociationStatus.self, forKey: .thirdPartyFirewallStatus)
        thirdPartyFirewallStatus = thirdPartyFirewallStatusDecoded
    }
}

extension FMSClientTypes.DiscoveredResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case name = "Name"
        case type = "Type"
        case uri = "URI"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let uri = self.uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension FMSClientTypes {
    /// A resource in the organization that's available to be associated with a Firewall Manager resource set.
    public struct DiscoveredResource: Swift.Equatable {
        /// The Amazon Web Services account ID associated with the discovered resource.
        public var accountId: Swift.String?
        /// The name of the discovered resource.
        public var name: Swift.String?
        /// The type of the discovered resource.
        public var type: Swift.String?
        /// The universal resource identifier (URI) of the discovered resource.
        public var uri: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil,
            uri: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.name = name
            self.type = type
            self.uri = uri
        }
    }

}

extension FMSClientTypes.DnsDuplicateRuleGroupViolation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case violationTarget = "ViolationTarget"
        case violationTargetDescription = "ViolationTargetDescription"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let violationTarget = self.violationTarget {
            try encodeContainer.encode(violationTarget, forKey: .violationTarget)
        }
        if let violationTargetDescription = self.violationTargetDescription {
            try encodeContainer.encode(violationTargetDescription, forKey: .violationTargetDescription)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .violationTarget)
        violationTarget = violationTargetDecoded
        let violationTargetDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .violationTargetDescription)
        violationTargetDescription = violationTargetDescriptionDecoded
    }
}

extension FMSClientTypes {
    /// A DNS Firewall rule group that Firewall Manager tried to associate with a VPC is already associated with the VPC and can't be associated again.
    public struct DnsDuplicateRuleGroupViolation: Swift.Equatable {
        /// Information about the VPC ID.
        public var violationTarget: Swift.String?
        /// A description of the violation that specifies the rule group and VPC.
        public var violationTargetDescription: Swift.String?

        public init (
            violationTarget: Swift.String? = nil,
            violationTargetDescription: Swift.String? = nil
        )
        {
            self.violationTarget = violationTarget
            self.violationTargetDescription = violationTargetDescription
        }
    }

}

extension FMSClientTypes.DnsRuleGroupLimitExceededViolation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case numberOfRuleGroupsAlreadyAssociated = "NumberOfRuleGroupsAlreadyAssociated"
        case violationTarget = "ViolationTarget"
        case violationTargetDescription = "ViolationTargetDescription"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if numberOfRuleGroupsAlreadyAssociated != 0 {
            try encodeContainer.encode(numberOfRuleGroupsAlreadyAssociated, forKey: .numberOfRuleGroupsAlreadyAssociated)
        }
        if let violationTarget = self.violationTarget {
            try encodeContainer.encode(violationTarget, forKey: .violationTarget)
        }
        if let violationTargetDescription = self.violationTargetDescription {
            try encodeContainer.encode(violationTargetDescription, forKey: .violationTargetDescription)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .violationTarget)
        violationTarget = violationTargetDecoded
        let violationTargetDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .violationTargetDescription)
        violationTargetDescription = violationTargetDescriptionDecoded
        let numberOfRuleGroupsAlreadyAssociatedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfRuleGroupsAlreadyAssociated) ?? 0
        numberOfRuleGroupsAlreadyAssociated = numberOfRuleGroupsAlreadyAssociatedDecoded
    }
}

extension FMSClientTypes {
    /// The VPC that Firewall Manager was applying a DNS Fireall policy to reached the limit for associated DNS Firewall rule groups. Firewall Manager tried to associate another rule group with the VPC and failed due to the limit.
    public struct DnsRuleGroupLimitExceededViolation: Swift.Equatable {
        /// The number of rule groups currently associated with the VPC.
        public var numberOfRuleGroupsAlreadyAssociated: Swift.Int
        /// Information about the VPC ID.
        public var violationTarget: Swift.String?
        /// A description of the violation that specifies the rule group and VPC.
        public var violationTargetDescription: Swift.String?

        public init (
            numberOfRuleGroupsAlreadyAssociated: Swift.Int = 0,
            violationTarget: Swift.String? = nil,
            violationTargetDescription: Swift.String? = nil
        )
        {
            self.numberOfRuleGroupsAlreadyAssociated = numberOfRuleGroupsAlreadyAssociated
            self.violationTarget = violationTarget
            self.violationTargetDescription = violationTargetDescription
        }
    }

}

extension FMSClientTypes.DnsRuleGroupPriorityConflictViolation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictingPolicyId = "ConflictingPolicyId"
        case conflictingPriority = "ConflictingPriority"
        case unavailablePriorities = "UnavailablePriorities"
        case violationTarget = "ViolationTarget"
        case violationTargetDescription = "ViolationTargetDescription"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conflictingPolicyId = self.conflictingPolicyId {
            try encodeContainer.encode(conflictingPolicyId, forKey: .conflictingPolicyId)
        }
        if conflictingPriority != 0 {
            try encodeContainer.encode(conflictingPriority, forKey: .conflictingPriority)
        }
        if let unavailablePriorities = unavailablePriorities {
            var unavailablePrioritiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .unavailablePriorities)
            for dnsrulegrouppriority0 in unavailablePriorities {
                try unavailablePrioritiesContainer.encode(dnsrulegrouppriority0)
            }
        }
        if let violationTarget = self.violationTarget {
            try encodeContainer.encode(violationTarget, forKey: .violationTarget)
        }
        if let violationTargetDescription = self.violationTargetDescription {
            try encodeContainer.encode(violationTargetDescription, forKey: .violationTargetDescription)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .violationTarget)
        violationTarget = violationTargetDecoded
        let violationTargetDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .violationTargetDescription)
        violationTargetDescription = violationTargetDescriptionDecoded
        let conflictingPriorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .conflictingPriority) ?? 0
        conflictingPriority = conflictingPriorityDecoded
        let conflictingPolicyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conflictingPolicyId)
        conflictingPolicyId = conflictingPolicyIdDecoded
        let unavailablePrioritiesContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .unavailablePriorities)
        var unavailablePrioritiesDecoded0:[Swift.Int]? = nil
        if let unavailablePrioritiesContainer = unavailablePrioritiesContainer {
            unavailablePrioritiesDecoded0 = [Swift.Int]()
            for integer0 in unavailablePrioritiesContainer {
                if let integer0 = integer0 {
                    unavailablePrioritiesDecoded0?.append(integer0)
                }
            }
        }
        unavailablePriorities = unavailablePrioritiesDecoded0
    }
}

extension FMSClientTypes {
    /// A rule group that Firewall Manager tried to associate with a VPC has the same priority as a rule group that's already associated.
    public struct DnsRuleGroupPriorityConflictViolation: Swift.Equatable {
        /// The ID of the Firewall Manager DNS Firewall policy that was already applied to the VPC. This policy contains the rule group that's already associated with the VPC.
        public var conflictingPolicyId: Swift.String?
        /// The priority setting of the two conflicting rule groups.
        public var conflictingPriority: Swift.Int
        /// The priorities of rule groups that are already associated with the VPC. To retry your operation, choose priority settings that aren't in this list for the rule groups in your new DNS Firewall policy.
        public var unavailablePriorities: [Swift.Int]?
        /// Information about the VPC ID.
        public var violationTarget: Swift.String?
        /// A description of the violation that specifies the VPC and the rule group that's already associated with it.
        public var violationTargetDescription: Swift.String?

        public init (
            conflictingPolicyId: Swift.String? = nil,
            conflictingPriority: Swift.Int = 0,
            unavailablePriorities: [Swift.Int]? = nil,
            violationTarget: Swift.String? = nil,
            violationTargetDescription: Swift.String? = nil
        )
        {
            self.conflictingPolicyId = conflictingPolicyId
            self.conflictingPriority = conflictingPriority
            self.unavailablePriorities = unavailablePriorities
            self.violationTarget = violationTarget
            self.violationTargetDescription = violationTargetDescription
        }
    }

}

extension FMSClientTypes.EC2AssociateRouteTableAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case gatewayId = "GatewayId"
        case routeTableId = "RouteTableId"
        case subnetId = "SubnetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let gatewayId = self.gatewayId {
            try encodeContainer.encode(gatewayId, forKey: .gatewayId)
        }
        if let routeTableId = self.routeTableId {
            try encodeContainer.encode(routeTableId, forKey: .routeTableId)
        }
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let routeTableIdDecoded = try containerValues.decodeIfPresent(FMSClientTypes.ActionTarget.self, forKey: .routeTableId)
        routeTableId = routeTableIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(FMSClientTypes.ActionTarget.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let gatewayIdDecoded = try containerValues.decodeIfPresent(FMSClientTypes.ActionTarget.self, forKey: .gatewayId)
        gatewayId = gatewayIdDecoded
    }
}

extension FMSClientTypes {
    /// The action of associating an EC2 resource, such as a subnet or internet gateway, with a route table.
    public struct EC2AssociateRouteTableAction: Swift.Equatable {
        /// A description of the EC2 route table that is associated with the remediation action.
        public var description: Swift.String?
        /// The ID of the gateway to be used with the EC2 route table that is associated with the remediation action.
        public var gatewayId: FMSClientTypes.ActionTarget?
        /// The ID of the EC2 route table that is associated with the remediation action.
        /// This member is required.
        public var routeTableId: FMSClientTypes.ActionTarget?
        /// The ID of the subnet for the EC2 route table that is associated with the remediation action.
        public var subnetId: FMSClientTypes.ActionTarget?

        public init (
            description: Swift.String? = nil,
            gatewayId: FMSClientTypes.ActionTarget? = nil,
            routeTableId: FMSClientTypes.ActionTarget? = nil,
            subnetId: FMSClientTypes.ActionTarget? = nil
        )
        {
            self.description = description
            self.gatewayId = gatewayId
            self.routeTableId = routeTableId
            self.subnetId = subnetId
        }
    }

}

extension FMSClientTypes.EC2CopyRouteTableAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case routeTableId = "RouteTableId"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let routeTableId = self.routeTableId {
            try encodeContainer.encode(routeTableId, forKey: .routeTableId)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(FMSClientTypes.ActionTarget.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let routeTableIdDecoded = try containerValues.decodeIfPresent(FMSClientTypes.ActionTarget.self, forKey: .routeTableId)
        routeTableId = routeTableIdDecoded
    }
}

extension FMSClientTypes {
    /// An action that copies the EC2 route table for use in remediation.
    public struct EC2CopyRouteTableAction: Swift.Equatable {
        /// A description of the copied EC2 route table that is associated with the remediation action.
        public var description: Swift.String?
        /// The ID of the copied EC2 route table that is associated with the remediation action.
        /// This member is required.
        public var routeTableId: FMSClientTypes.ActionTarget?
        /// The VPC ID of the copied EC2 route table that is associated with the remediation action.
        /// This member is required.
        public var vpcId: FMSClientTypes.ActionTarget?

        public init (
            description: Swift.String? = nil,
            routeTableId: FMSClientTypes.ActionTarget? = nil,
            vpcId: FMSClientTypes.ActionTarget? = nil
        )
        {
            self.description = description
            self.routeTableId = routeTableId
            self.vpcId = vpcId
        }
    }

}

extension FMSClientTypes.EC2CreateRouteAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case destinationCidrBlock = "DestinationCidrBlock"
        case destinationIpv6CidrBlock = "DestinationIpv6CidrBlock"
        case destinationPrefixListId = "DestinationPrefixListId"
        case gatewayId = "GatewayId"
        case routeTableId = "RouteTableId"
        case vpcEndpointId = "VpcEndpointId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationCidrBlock = self.destinationCidrBlock {
            try encodeContainer.encode(destinationCidrBlock, forKey: .destinationCidrBlock)
        }
        if let destinationIpv6CidrBlock = self.destinationIpv6CidrBlock {
            try encodeContainer.encode(destinationIpv6CidrBlock, forKey: .destinationIpv6CidrBlock)
        }
        if let destinationPrefixListId = self.destinationPrefixListId {
            try encodeContainer.encode(destinationPrefixListId, forKey: .destinationPrefixListId)
        }
        if let gatewayId = self.gatewayId {
            try encodeContainer.encode(gatewayId, forKey: .gatewayId)
        }
        if let routeTableId = self.routeTableId {
            try encodeContainer.encode(routeTableId, forKey: .routeTableId)
        }
        if let vpcEndpointId = self.vpcEndpointId {
            try encodeContainer.encode(vpcEndpointId, forKey: .vpcEndpointId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let destinationCidrBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCidrBlock)
        destinationCidrBlock = destinationCidrBlockDecoded
        let destinationPrefixListIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationPrefixListId)
        destinationPrefixListId = destinationPrefixListIdDecoded
        let destinationIpv6CidrBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationIpv6CidrBlock)
        destinationIpv6CidrBlock = destinationIpv6CidrBlockDecoded
        let vpcEndpointIdDecoded = try containerValues.decodeIfPresent(FMSClientTypes.ActionTarget.self, forKey: .vpcEndpointId)
        vpcEndpointId = vpcEndpointIdDecoded
        let gatewayIdDecoded = try containerValues.decodeIfPresent(FMSClientTypes.ActionTarget.self, forKey: .gatewayId)
        gatewayId = gatewayIdDecoded
        let routeTableIdDecoded = try containerValues.decodeIfPresent(FMSClientTypes.ActionTarget.self, forKey: .routeTableId)
        routeTableId = routeTableIdDecoded
    }
}

extension FMSClientTypes {
    /// Information about the CreateRoute action in Amazon EC2.
    public struct EC2CreateRouteAction: Swift.Equatable {
        /// A description of CreateRoute action in Amazon EC2.
        public var description: Swift.String?
        /// Information about the IPv4 CIDR address block used for the destination match.
        public var destinationCidrBlock: Swift.String?
        /// Information about the IPv6 CIDR block destination.
        public var destinationIpv6CidrBlock: Swift.String?
        /// Information about the ID of a prefix list used for the destination match.
        public var destinationPrefixListId: Swift.String?
        /// Information about the ID of an internet gateway or virtual private gateway attached to your VPC.
        public var gatewayId: FMSClientTypes.ActionTarget?
        /// Information about the ID of the route table for the route.
        /// This member is required.
        public var routeTableId: FMSClientTypes.ActionTarget?
        /// Information about the ID of a VPC endpoint. Supported for Gateway Load Balancer endpoints only.
        public var vpcEndpointId: FMSClientTypes.ActionTarget?

        public init (
            description: Swift.String? = nil,
            destinationCidrBlock: Swift.String? = nil,
            destinationIpv6CidrBlock: Swift.String? = nil,
            destinationPrefixListId: Swift.String? = nil,
            gatewayId: FMSClientTypes.ActionTarget? = nil,
            routeTableId: FMSClientTypes.ActionTarget? = nil,
            vpcEndpointId: FMSClientTypes.ActionTarget? = nil
        )
        {
            self.description = description
            self.destinationCidrBlock = destinationCidrBlock
            self.destinationIpv6CidrBlock = destinationIpv6CidrBlock
            self.destinationPrefixListId = destinationPrefixListId
            self.gatewayId = gatewayId
            self.routeTableId = routeTableId
            self.vpcEndpointId = vpcEndpointId
        }
    }

}

extension FMSClientTypes.EC2CreateRouteTableAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(FMSClientTypes.ActionTarget.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension FMSClientTypes {
    /// Information about the CreateRouteTable action in Amazon EC2.
    public struct EC2CreateRouteTableAction: Swift.Equatable {
        /// A description of the CreateRouteTable action.
        public var description: Swift.String?
        /// Information about the ID of a VPC.
        /// This member is required.
        public var vpcId: FMSClientTypes.ActionTarget?

        public init (
            description: Swift.String? = nil,
            vpcId: FMSClientTypes.ActionTarget? = nil
        )
        {
            self.description = description
            self.vpcId = vpcId
        }
    }

}

extension FMSClientTypes.EC2DeleteRouteAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case destinationCidrBlock = "DestinationCidrBlock"
        case destinationIpv6CidrBlock = "DestinationIpv6CidrBlock"
        case destinationPrefixListId = "DestinationPrefixListId"
        case routeTableId = "RouteTableId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationCidrBlock = self.destinationCidrBlock {
            try encodeContainer.encode(destinationCidrBlock, forKey: .destinationCidrBlock)
        }
        if let destinationIpv6CidrBlock = self.destinationIpv6CidrBlock {
            try encodeContainer.encode(destinationIpv6CidrBlock, forKey: .destinationIpv6CidrBlock)
        }
        if let destinationPrefixListId = self.destinationPrefixListId {
            try encodeContainer.encode(destinationPrefixListId, forKey: .destinationPrefixListId)
        }
        if let routeTableId = self.routeTableId {
            try encodeContainer.encode(routeTableId, forKey: .routeTableId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let destinationCidrBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCidrBlock)
        destinationCidrBlock = destinationCidrBlockDecoded
        let destinationPrefixListIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationPrefixListId)
        destinationPrefixListId = destinationPrefixListIdDecoded
        let destinationIpv6CidrBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationIpv6CidrBlock)
        destinationIpv6CidrBlock = destinationIpv6CidrBlockDecoded
        let routeTableIdDecoded = try containerValues.decodeIfPresent(FMSClientTypes.ActionTarget.self, forKey: .routeTableId)
        routeTableId = routeTableIdDecoded
    }
}

extension FMSClientTypes {
    /// Information about the DeleteRoute action in Amazon EC2.
    public struct EC2DeleteRouteAction: Swift.Equatable {
        /// A description of the DeleteRoute action.
        public var description: Swift.String?
        /// Information about the IPv4 CIDR range for the route. The value you specify must match the CIDR for the route exactly.
        public var destinationCidrBlock: Swift.String?
        /// Information about the IPv6 CIDR range for the route. The value you specify must match the CIDR for the route exactly.
        public var destinationIpv6CidrBlock: Swift.String?
        /// Information about the ID of the prefix list for the route.
        public var destinationPrefixListId: Swift.String?
        /// Information about the ID of the route table.
        /// This member is required.
        public var routeTableId: FMSClientTypes.ActionTarget?

        public init (
            description: Swift.String? = nil,
            destinationCidrBlock: Swift.String? = nil,
            destinationIpv6CidrBlock: Swift.String? = nil,
            destinationPrefixListId: Swift.String? = nil,
            routeTableId: FMSClientTypes.ActionTarget? = nil
        )
        {
            self.description = description
            self.destinationCidrBlock = destinationCidrBlock
            self.destinationIpv6CidrBlock = destinationIpv6CidrBlock
            self.destinationPrefixListId = destinationPrefixListId
            self.routeTableId = routeTableId
        }
    }

}

extension FMSClientTypes.EC2ReplaceRouteAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case destinationCidrBlock = "DestinationCidrBlock"
        case destinationIpv6CidrBlock = "DestinationIpv6CidrBlock"
        case destinationPrefixListId = "DestinationPrefixListId"
        case gatewayId = "GatewayId"
        case routeTableId = "RouteTableId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationCidrBlock = self.destinationCidrBlock {
            try encodeContainer.encode(destinationCidrBlock, forKey: .destinationCidrBlock)
        }
        if let destinationIpv6CidrBlock = self.destinationIpv6CidrBlock {
            try encodeContainer.encode(destinationIpv6CidrBlock, forKey: .destinationIpv6CidrBlock)
        }
        if let destinationPrefixListId = self.destinationPrefixListId {
            try encodeContainer.encode(destinationPrefixListId, forKey: .destinationPrefixListId)
        }
        if let gatewayId = self.gatewayId {
            try encodeContainer.encode(gatewayId, forKey: .gatewayId)
        }
        if let routeTableId = self.routeTableId {
            try encodeContainer.encode(routeTableId, forKey: .routeTableId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let destinationCidrBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCidrBlock)
        destinationCidrBlock = destinationCidrBlockDecoded
        let destinationPrefixListIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationPrefixListId)
        destinationPrefixListId = destinationPrefixListIdDecoded
        let destinationIpv6CidrBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationIpv6CidrBlock)
        destinationIpv6CidrBlock = destinationIpv6CidrBlockDecoded
        let gatewayIdDecoded = try containerValues.decodeIfPresent(FMSClientTypes.ActionTarget.self, forKey: .gatewayId)
        gatewayId = gatewayIdDecoded
        let routeTableIdDecoded = try containerValues.decodeIfPresent(FMSClientTypes.ActionTarget.self, forKey: .routeTableId)
        routeTableId = routeTableIdDecoded
    }
}

extension FMSClientTypes {
    /// Information about the ReplaceRoute action in Amazon EC2.
    public struct EC2ReplaceRouteAction: Swift.Equatable {
        /// A description of the ReplaceRoute action in Amazon EC2.
        public var description: Swift.String?
        /// Information about the IPv4 CIDR address block used for the destination match. The value that you provide must match the CIDR of an existing route in the table.
        public var destinationCidrBlock: Swift.String?
        /// Information about the IPv6 CIDR address block used for the destination match. The value that you provide must match the CIDR of an existing route in the table.
        public var destinationIpv6CidrBlock: Swift.String?
        /// Information about the ID of the prefix list for the route.
        public var destinationPrefixListId: Swift.String?
        /// Information about the ID of an internet gateway or virtual private gateway.
        public var gatewayId: FMSClientTypes.ActionTarget?
        /// Information about the ID of the route table.
        /// This member is required.
        public var routeTableId: FMSClientTypes.ActionTarget?

        public init (
            description: Swift.String? = nil,
            destinationCidrBlock: Swift.String? = nil,
            destinationIpv6CidrBlock: Swift.String? = nil,
            destinationPrefixListId: Swift.String? = nil,
            gatewayId: FMSClientTypes.ActionTarget? = nil,
            routeTableId: FMSClientTypes.ActionTarget? = nil
        )
        {
            self.description = description
            self.destinationCidrBlock = destinationCidrBlock
            self.destinationIpv6CidrBlock = destinationIpv6CidrBlock
            self.destinationPrefixListId = destinationPrefixListId
            self.gatewayId = gatewayId
            self.routeTableId = routeTableId
        }
    }

}

extension FMSClientTypes.EC2ReplaceRouteTableAssociationAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case description = "Description"
        case routeTableId = "RouteTableId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = self.associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let routeTableId = self.routeTableId {
            try encodeContainer.encode(routeTableId, forKey: .routeTableId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let associationIdDecoded = try containerValues.decodeIfPresent(FMSClientTypes.ActionTarget.self, forKey: .associationId)
        associationId = associationIdDecoded
        let routeTableIdDecoded = try containerValues.decodeIfPresent(FMSClientTypes.ActionTarget.self, forKey: .routeTableId)
        routeTableId = routeTableIdDecoded
    }
}

extension FMSClientTypes {
    /// Information about the ReplaceRouteTableAssociation action in Amazon EC2.
    public struct EC2ReplaceRouteTableAssociationAction: Swift.Equatable {
        /// Information about the association ID.
        /// This member is required.
        public var associationId: FMSClientTypes.ActionTarget?
        /// A description of the ReplaceRouteTableAssociation action in Amazon EC2.
        public var description: Swift.String?
        /// Information about the ID of the new route table to associate with the subnet.
        /// This member is required.
        public var routeTableId: FMSClientTypes.ActionTarget?

        public init (
            associationId: FMSClientTypes.ActionTarget? = nil,
            description: Swift.String? = nil,
            routeTableId: FMSClientTypes.ActionTarget? = nil
        )
        {
            self.associationId = associationId
            self.description = description
            self.routeTableId = routeTableId
        }
    }

}

extension FMSClientTypes.EvaluationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceStatus = "ComplianceStatus"
        case evaluationLimitExceeded = "EvaluationLimitExceeded"
        case violatorCount = "ViolatorCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceStatus = self.complianceStatus {
            try encodeContainer.encode(complianceStatus.rawValue, forKey: .complianceStatus)
        }
        if evaluationLimitExceeded != false {
            try encodeContainer.encode(evaluationLimitExceeded, forKey: .evaluationLimitExceeded)
        }
        if violatorCount != 0 {
            try encodeContainer.encode(violatorCount, forKey: .violatorCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceStatusDecoded = try containerValues.decodeIfPresent(FMSClientTypes.PolicyComplianceStatusType.self, forKey: .complianceStatus)
        complianceStatus = complianceStatusDecoded
        let violatorCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .violatorCount) ?? 0
        violatorCount = violatorCountDecoded
        let evaluationLimitExceededDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .evaluationLimitExceeded) ?? false
        evaluationLimitExceeded = evaluationLimitExceededDecoded
    }
}

extension FMSClientTypes {
    /// Describes the compliance status for the account. An account is considered noncompliant if it includes resources that are not protected by the specified policy or that don't comply with the policy.
    public struct EvaluationResult: Swift.Equatable {
        /// Describes an Amazon Web Services account's compliance with the Firewall Manager policy.
        public var complianceStatus: FMSClientTypes.PolicyComplianceStatusType?
        /// Indicates that over 100 resources are noncompliant with the Firewall Manager policy.
        public var evaluationLimitExceeded: Swift.Bool
        /// The number of resources that are noncompliant with the specified policy. For WAF and Shield Advanced policies, a resource is considered noncompliant if it is not associated with the policy. For security group policies, a resource is considered noncompliant if it doesn't comply with the rules of the policy and remediation is disabled or not possible.
        public var violatorCount: Swift.Int

        public init (
            complianceStatus: FMSClientTypes.PolicyComplianceStatusType? = nil,
            evaluationLimitExceeded: Swift.Bool = false,
            violatorCount: Swift.Int = 0
        )
        {
            self.complianceStatus = complianceStatus
            self.evaluationLimitExceeded = evaluationLimitExceeded
            self.violatorCount = violatorCount
        }
    }

}

extension FMSClientTypes.ExpectedRoute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedTargets = "AllowedTargets"
        case contributingSubnets = "ContributingSubnets"
        case ipV4Cidr = "IpV4Cidr"
        case ipV6Cidr = "IpV6Cidr"
        case prefixListId = "PrefixListId"
        case routeTableId = "RouteTableId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedTargets = allowedTargets {
            var allowedTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedTargets)
            for lengthboundedstring0 in allowedTargets {
                try allowedTargetsContainer.encode(lengthboundedstring0)
            }
        }
        if let contributingSubnets = contributingSubnets {
            var contributingSubnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .contributingSubnets)
            for resourceid0 in contributingSubnets {
                try contributingSubnetsContainer.encode(resourceid0)
            }
        }
        if let ipV4Cidr = self.ipV4Cidr {
            try encodeContainer.encode(ipV4Cidr, forKey: .ipV4Cidr)
        }
        if let ipV6Cidr = self.ipV6Cidr {
            try encodeContainer.encode(ipV6Cidr, forKey: .ipV6Cidr)
        }
        if let prefixListId = self.prefixListId {
            try encodeContainer.encode(prefixListId, forKey: .prefixListId)
        }
        if let routeTableId = self.routeTableId {
            try encodeContainer.encode(routeTableId, forKey: .routeTableId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipV4CidrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipV4Cidr)
        ipV4Cidr = ipV4CidrDecoded
        let prefixListIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefixListId)
        prefixListId = prefixListIdDecoded
        let ipV6CidrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipV6Cidr)
        ipV6Cidr = ipV6CidrDecoded
        let contributingSubnetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .contributingSubnets)
        var contributingSubnetsDecoded0:[Swift.String]? = nil
        if let contributingSubnetsContainer = contributingSubnetsContainer {
            contributingSubnetsDecoded0 = [Swift.String]()
            for string0 in contributingSubnetsContainer {
                if let string0 = string0 {
                    contributingSubnetsDecoded0?.append(string0)
                }
            }
        }
        contributingSubnets = contributingSubnetsDecoded0
        let allowedTargetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowedTargets)
        var allowedTargetsDecoded0:[Swift.String]? = nil
        if let allowedTargetsContainer = allowedTargetsContainer {
            allowedTargetsDecoded0 = [Swift.String]()
            for string0 in allowedTargetsContainer {
                if let string0 = string0 {
                    allowedTargetsDecoded0?.append(string0)
                }
            }
        }
        allowedTargets = allowedTargetsDecoded0
        let routeTableIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeTableId)
        routeTableId = routeTableIdDecoded
    }
}

extension FMSClientTypes {
    /// Information about the expected route in the route table.
    public struct ExpectedRoute: Swift.Equatable {
        /// Information about the allowed targets.
        public var allowedTargets: [Swift.String]?
        /// Information about the contributing subnets.
        public var contributingSubnets: [Swift.String]?
        /// Information about the IPv4 CIDR block.
        public var ipV4Cidr: Swift.String?
        /// Information about the IPv6 CIDR block.
        public var ipV6Cidr: Swift.String?
        /// Information about the ID of the prefix list for the route.
        public var prefixListId: Swift.String?
        /// Information about the route table ID.
        public var routeTableId: Swift.String?

        public init (
            allowedTargets: [Swift.String]? = nil,
            contributingSubnets: [Swift.String]? = nil,
            ipV4Cidr: Swift.String? = nil,
            ipV6Cidr: Swift.String? = nil,
            prefixListId: Swift.String? = nil,
            routeTableId: Swift.String? = nil
        )
        {
            self.allowedTargets = allowedTargets
            self.contributingSubnets = contributingSubnets
            self.ipV4Cidr = ipV4Cidr
            self.ipV6Cidr = ipV6Cidr
            self.prefixListId = prefixListId
            self.routeTableId = routeTableId
        }
    }

}

extension FMSClientTypes.FMSPolicyUpdateFirewallCreationConfigAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case firewallCreationConfig = "FirewallCreationConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let firewallCreationConfig = self.firewallCreationConfig {
            try encodeContainer.encode(firewallCreationConfig, forKey: .firewallCreationConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let firewallCreationConfigDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallCreationConfig)
        firewallCreationConfig = firewallCreationConfigDecoded
    }
}

extension FMSClientTypes {
    /// Contains information about the actions that you can take to remediate scope violations caused by your policy's FirewallCreationConfig. FirewallCreationConfig is an optional configuration that you can use to choose which Availability Zones Firewall Manager creates Network Firewall endpoints in.
    public struct FMSPolicyUpdateFirewallCreationConfigAction: Swift.Equatable {
        /// Describes the remedial action.
        public var description: Swift.String?
        /// A FirewallCreationConfig that you can copy into your current policy's [SecurityServiceData](https://docs.aws.amazon.com/fms/2018-01-01/APIReference/API_SecurityServicePolicyData.html) in order to remedy scope violations.
        public var firewallCreationConfig: Swift.String?

        public init (
            description: Swift.String? = nil,
            firewallCreationConfig: Swift.String? = nil
        )
        {
            self.description = description
            self.firewallCreationConfig = firewallCreationConfig
        }
    }

}

extension FMSClientTypes.FailedItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason = "Reason"
        case uri = "URI"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = self.reason {
            try encodeContainer.encode(reason.rawValue, forKey: .reason)
        }
        if let uri = self.uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(FMSClientTypes.FailedItemReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension FMSClientTypes {
    /// Details of a resource that failed when trying to update it's association to a resource set.
    public struct FailedItem: Swift.Equatable {
        /// The reason the resource's association could not be updated.
        public var reason: FMSClientTypes.FailedItemReason?
        /// The univeral resource indicator (URI) of the resource that failed.
        public var uri: Swift.String?

        public init (
            reason: FMSClientTypes.FailedItemReason? = nil,
            uri: Swift.String? = nil
        )
        {
            self.reason = reason
            self.uri = uri
        }
    }

}

extension FMSClientTypes {
    public enum FailedItemReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case notvalidaccountid
        case notvalidarn
        case notvalidpartition
        case notvalidregion
        case notvalidresourcetype
        case notvalidservice
        case sdkUnknown(Swift.String)

        public static var allCases: [FailedItemReason] {
            return [
                .notvalidaccountid,
                .notvalidarn,
                .notvalidpartition,
                .notvalidregion,
                .notvalidresourcetype,
                .notvalidservice,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .notvalidaccountid: return "NOT_VALID_ACCOUNT_ID"
            case .notvalidarn: return "NOT_VALID_ARN"
            case .notvalidpartition: return "NOT_VALID_PARTITION"
            case .notvalidregion: return "NOT_VALID_REGION"
            case .notvalidresourcetype: return "NOT_VALID_RESOURCE_TYPE"
            case .notvalidservice: return "NOT_VALID_SERVICE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FailedItemReason(rawValue: rawValue) ?? FailedItemReason.sdkUnknown(rawValue)
        }
    }
}

extension FMSClientTypes {
    public enum FirewallDeploymentModel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case centralized
        case distributed
        case sdkUnknown(Swift.String)

        public static var allCases: [FirewallDeploymentModel] {
            return [
                .centralized,
                .distributed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .centralized: return "CENTRALIZED"
            case .distributed: return "DISTRIBUTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FirewallDeploymentModel(rawValue: rawValue) ?? FirewallDeploymentModel.sdkUnknown(rawValue)
        }
    }
}

extension FMSClientTypes.FirewallSubnetIsOutOfScopeViolation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallSubnetId = "FirewallSubnetId"
        case subnetAvailabilityZone = "SubnetAvailabilityZone"
        case subnetAvailabilityZoneId = "SubnetAvailabilityZoneId"
        case vpcEndpointId = "VpcEndpointId"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallSubnetId = self.firewallSubnetId {
            try encodeContainer.encode(firewallSubnetId, forKey: .firewallSubnetId)
        }
        if let subnetAvailabilityZone = self.subnetAvailabilityZone {
            try encodeContainer.encode(subnetAvailabilityZone, forKey: .subnetAvailabilityZone)
        }
        if let subnetAvailabilityZoneId = self.subnetAvailabilityZoneId {
            try encodeContainer.encode(subnetAvailabilityZoneId, forKey: .subnetAvailabilityZoneId)
        }
        if let vpcEndpointId = self.vpcEndpointId {
            try encodeContainer.encode(vpcEndpointId, forKey: .vpcEndpointId)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallSubnetId)
        firewallSubnetId = firewallSubnetIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetAvailabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetAvailabilityZone)
        subnetAvailabilityZone = subnetAvailabilityZoneDecoded
        let subnetAvailabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetAvailabilityZoneId)
        subnetAvailabilityZoneId = subnetAvailabilityZoneIdDecoded
        let vpcEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcEndpointId)
        vpcEndpointId = vpcEndpointIdDecoded
    }
}

extension FMSClientTypes {
    /// Contains details about the firewall subnet that violates the policy scope.
    public struct FirewallSubnetIsOutOfScopeViolation: Swift.Equatable {
        /// The ID of the firewall subnet that violates the policy scope.
        public var firewallSubnetId: Swift.String?
        /// The Availability Zone of the firewall subnet that violates the policy scope.
        public var subnetAvailabilityZone: Swift.String?
        /// The Availability Zone ID of the firewall subnet that violates the policy scope.
        public var subnetAvailabilityZoneId: Swift.String?
        /// The VPC endpoint ID of the firewall subnet that violates the policy scope.
        public var vpcEndpointId: Swift.String?
        /// The VPC ID of the firewall subnet that violates the policy scope.
        public var vpcId: Swift.String?

        public init (
            firewallSubnetId: Swift.String? = nil,
            subnetAvailabilityZone: Swift.String? = nil,
            subnetAvailabilityZoneId: Swift.String? = nil,
            vpcEndpointId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.firewallSubnetId = firewallSubnetId
            self.subnetAvailabilityZone = subnetAvailabilityZone
            self.subnetAvailabilityZoneId = subnetAvailabilityZoneId
            self.vpcEndpointId = vpcEndpointId
            self.vpcId = vpcId
        }
    }

}

extension FMSClientTypes.FirewallSubnetMissingVPCEndpointViolation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallSubnetId = "FirewallSubnetId"
        case subnetAvailabilityZone = "SubnetAvailabilityZone"
        case subnetAvailabilityZoneId = "SubnetAvailabilityZoneId"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallSubnetId = self.firewallSubnetId {
            try encodeContainer.encode(firewallSubnetId, forKey: .firewallSubnetId)
        }
        if let subnetAvailabilityZone = self.subnetAvailabilityZone {
            try encodeContainer.encode(subnetAvailabilityZone, forKey: .subnetAvailabilityZone)
        }
        if let subnetAvailabilityZoneId = self.subnetAvailabilityZoneId {
            try encodeContainer.encode(subnetAvailabilityZoneId, forKey: .subnetAvailabilityZoneId)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallSubnetId)
        firewallSubnetId = firewallSubnetIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetAvailabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetAvailabilityZone)
        subnetAvailabilityZone = subnetAvailabilityZoneDecoded
        let subnetAvailabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetAvailabilityZoneId)
        subnetAvailabilityZoneId = subnetAvailabilityZoneIdDecoded
    }
}

extension FMSClientTypes {
    /// The violation details for a firewall subnet's VPC endpoint that's deleted or missing.
    public struct FirewallSubnetMissingVPCEndpointViolation: Swift.Equatable {
        /// The ID of the firewall that this VPC endpoint is associated with.
        public var firewallSubnetId: Swift.String?
        /// The name of the Availability Zone of the deleted VPC subnet.
        public var subnetAvailabilityZone: Swift.String?
        /// The ID of the Availability Zone of the deleted VPC subnet.
        public var subnetAvailabilityZoneId: Swift.String?
        /// The resource ID of the VPC associated with the deleted VPC subnet.
        public var vpcId: Swift.String?

        public init (
            firewallSubnetId: Swift.String? = nil,
            subnetAvailabilityZone: Swift.String? = nil,
            subnetAvailabilityZoneId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.firewallSubnetId = firewallSubnetId
            self.subnetAvailabilityZone = subnetAvailabilityZone
            self.subnetAvailabilityZoneId = subnetAvailabilityZoneId
            self.vpcId = vpcId
        }
    }

}

extension GetAdminAccountInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetAdminAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAdminAccountInput: Swift.Equatable {

    public init () { }
}

struct GetAdminAccountInputBody: Swift.Equatable {
}

extension GetAdminAccountInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAdminAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAdminAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetAdminAccountOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAdminAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetAdminAccountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.adminAccount = output.adminAccount
            self.roleStatus = output.roleStatus
        } else {
            self.adminAccount = nil
            self.roleStatus = nil
        }
    }
}

public struct GetAdminAccountOutputResponse: Swift.Equatable {
    /// The Amazon Web Services account that is set as the Firewall Manager administrator.
    public var adminAccount: Swift.String?
    /// The status of the Amazon Web Services account that you set as the Firewall Manager administrator.
    public var roleStatus: FMSClientTypes.AccountRoleStatus?

    public init (
        adminAccount: Swift.String? = nil,
        roleStatus: FMSClientTypes.AccountRoleStatus? = nil
    )
    {
        self.adminAccount = adminAccount
        self.roleStatus = roleStatus
    }
}

struct GetAdminAccountOutputResponseBody: Swift.Equatable {
    let adminAccount: Swift.String?
    let roleStatus: FMSClientTypes.AccountRoleStatus?
}

extension GetAdminAccountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccount = "AdminAccount"
        case roleStatus = "RoleStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminAccount)
        adminAccount = adminAccountDecoded
        let roleStatusDecoded = try containerValues.decodeIfPresent(FMSClientTypes.AccountRoleStatus.self, forKey: .roleStatus)
        roleStatus = roleStatusDecoded
    }
}

extension GetAppsListInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultList = "DefaultList"
        case listId = "ListId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if defaultList != false {
            try encodeContainer.encode(defaultList, forKey: .defaultList)
        }
        if let listId = self.listId {
            try encodeContainer.encode(listId, forKey: .listId)
        }
    }
}

extension GetAppsListInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAppsListInput: Swift.Equatable {
    /// Specifies whether the list to retrieve is a default list owned by Firewall Manager.
    public var defaultList: Swift.Bool
    /// The ID of the Firewall Manager applications list that you want the details for.
    /// This member is required.
    public var listId: Swift.String?

    public init (
        defaultList: Swift.Bool = false,
        listId: Swift.String? = nil
    )
    {
        self.defaultList = defaultList
        self.listId = listId
    }
}

struct GetAppsListInputBody: Swift.Equatable {
    let listId: Swift.String?
    let defaultList: Swift.Bool
}

extension GetAppsListInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultList = "DefaultList"
        case listId = "ListId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listId)
        listId = listIdDecoded
        let defaultListDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .defaultList) ?? false
        defaultList = defaultListDecoded
    }
}

extension GetAppsListOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAppsListOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetAppsListOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAppsListOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetAppsListOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appsList = output.appsList
            self.appsListArn = output.appsListArn
        } else {
            self.appsList = nil
            self.appsListArn = nil
        }
    }
}

public struct GetAppsListOutputResponse: Swift.Equatable {
    /// Information about the specified Firewall Manager applications list.
    public var appsList: FMSClientTypes.AppsListData?
    /// The Amazon Resource Name (ARN) of the applications list.
    public var appsListArn: Swift.String?

    public init (
        appsList: FMSClientTypes.AppsListData? = nil,
        appsListArn: Swift.String? = nil
    )
    {
        self.appsList = appsList
        self.appsListArn = appsListArn
    }
}

struct GetAppsListOutputResponseBody: Swift.Equatable {
    let appsList: FMSClientTypes.AppsListData?
    let appsListArn: Swift.String?
}

extension GetAppsListOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appsList = "AppsList"
        case appsListArn = "AppsListArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appsListDecoded = try containerValues.decodeIfPresent(FMSClientTypes.AppsListData.self, forKey: .appsList)
        appsList = appsListDecoded
        let appsListArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appsListArn)
        appsListArn = appsListArnDecoded
    }
}

extension GetComplianceDetailInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberAccount = "MemberAccount"
        case policyId = "PolicyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberAccount = self.memberAccount {
            try encodeContainer.encode(memberAccount, forKey: .memberAccount)
        }
        if let policyId = self.policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
    }
}

extension GetComplianceDetailInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetComplianceDetailInput: Swift.Equatable {
    /// The Amazon Web Services account that owns the resources that you want to get the details for.
    /// This member is required.
    public var memberAccount: Swift.String?
    /// The ID of the policy that you want to get the details for. PolicyId is returned by PutPolicy and by ListPolicies.
    /// This member is required.
    public var policyId: Swift.String?

    public init (
        memberAccount: Swift.String? = nil,
        policyId: Swift.String? = nil
    )
    {
        self.memberAccount = memberAccount
        self.policyId = policyId
    }
}

struct GetComplianceDetailInputBody: Swift.Equatable {
    let policyId: Swift.String?
    let memberAccount: Swift.String?
}

extension GetComplianceDetailInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberAccount = "MemberAccount"
        case policyId = "PolicyId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let memberAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberAccount)
        memberAccount = memberAccountDecoded
    }
}

extension GetComplianceDetailOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetComplianceDetailOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetComplianceDetailOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetComplianceDetailOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetComplianceDetailOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policyComplianceDetail = output.policyComplianceDetail
        } else {
            self.policyComplianceDetail = nil
        }
    }
}

public struct GetComplianceDetailOutputResponse: Swift.Equatable {
    /// Information about the resources and the policy that you specified in the GetComplianceDetail request.
    public var policyComplianceDetail: FMSClientTypes.PolicyComplianceDetail?

    public init (
        policyComplianceDetail: FMSClientTypes.PolicyComplianceDetail? = nil
    )
    {
        self.policyComplianceDetail = policyComplianceDetail
    }
}

struct GetComplianceDetailOutputResponseBody: Swift.Equatable {
    let policyComplianceDetail: FMSClientTypes.PolicyComplianceDetail?
}

extension GetComplianceDetailOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyComplianceDetail = "PolicyComplianceDetail"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyComplianceDetailDecoded = try containerValues.decodeIfPresent(FMSClientTypes.PolicyComplianceDetail.self, forKey: .policyComplianceDetail)
        policyComplianceDetail = policyComplianceDetailDecoded
    }
}

extension GetNotificationChannelInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetNotificationChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetNotificationChannelInput: Swift.Equatable {

    public init () { }
}

struct GetNotificationChannelInputBody: Swift.Equatable {
}

extension GetNotificationChannelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetNotificationChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetNotificationChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetNotificationChannelOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetNotificationChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetNotificationChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.snsRoleName = output.snsRoleName
            self.snsTopicArn = output.snsTopicArn
        } else {
            self.snsRoleName = nil
            self.snsTopicArn = nil
        }
    }
}

public struct GetNotificationChannelOutputResponse: Swift.Equatable {
    /// The IAM role that is used by Firewall Manager to record activity to SNS.
    public var snsRoleName: Swift.String?
    /// The SNS topic that records Firewall Manager activity.
    public var snsTopicArn: Swift.String?

    public init (
        snsRoleName: Swift.String? = nil,
        snsTopicArn: Swift.String? = nil
    )
    {
        self.snsRoleName = snsRoleName
        self.snsTopicArn = snsTopicArn
    }
}

struct GetNotificationChannelOutputResponseBody: Swift.Equatable {
    let snsTopicArn: Swift.String?
    let snsRoleName: Swift.String?
}

extension GetNotificationChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snsRoleName = "SnsRoleName"
        case snsTopicArn = "SnsTopicArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let snsRoleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsRoleName)
        snsRoleName = snsRoleNameDecoded
    }
}

extension GetPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyId = "PolicyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyId = self.policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
    }
}

extension GetPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetPolicyInput: Swift.Equatable {
    /// The ID of the Firewall Manager policy that you want the details for.
    /// This member is required.
    public var policyId: Swift.String?

    public init (
        policyId: Swift.String? = nil
    )
    {
        self.policyId = policyId
    }
}

struct GetPolicyInputBody: Swift.Equatable {
    let policyId: Swift.String?
}

extension GetPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyId = "PolicyId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
    }
}

extension GetPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTypeException" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetPolicyOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case invalidTypeException(InvalidTypeException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
            self.policyArn = output.policyArn
        } else {
            self.policy = nil
            self.policyArn = nil
        }
    }
}

public struct GetPolicyOutputResponse: Swift.Equatable {
    /// Information about the specified Firewall Manager policy.
    public var policy: FMSClientTypes.Policy?
    /// The Amazon Resource Name (ARN) of the specified policy.
    public var policyArn: Swift.String?

    public init (
        policy: FMSClientTypes.Policy? = nil,
        policyArn: Swift.String? = nil
    )
    {
        self.policy = policy
        self.policyArn = policyArn
    }
}

struct GetPolicyOutputResponseBody: Swift.Equatable {
    let policy: FMSClientTypes.Policy?
    let policyArn: Swift.String?
}

extension GetPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
        case policyArn = "PolicyArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(FMSClientTypes.Policy.self, forKey: .policy)
        policy = policyDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
    }
}

extension GetProtectionStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case maxResults = "MaxResults"
        case memberAccountId = "MemberAccountId"
        case nextToken = "NextToken"
        case policyId = "PolicyId"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let memberAccountId = self.memberAccountId {
            try encodeContainer.encode(memberAccountId, forKey: .memberAccountId)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let policyId = self.policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }
}

extension GetProtectionStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetProtectionStatusInput: Swift.Equatable {
    /// The end of the time period to query for the attacks. This is a timestamp type. The request syntax listing indicates a number type because the default used by Firewall Manager is Unix time in seconds. However, any valid timestamp format is allowed.
    public var endTime: ClientRuntime.Date?
    /// Specifies the number of objects that you want Firewall Manager to return for this request. If you have more objects than the number that you specify for MaxResults, the response includes a NextToken value that you can use to get another batch of objects.
    public var maxResults: Swift.Int?
    /// The Amazon Web Services account that is in scope of the policy that you want to get the details for.
    public var memberAccountId: Swift.String?
    /// If you specify a value for MaxResults and you have more objects than the number that you specify for MaxResults, Firewall Manager returns a NextToken value in the response, which you can use to retrieve another group of objects. For the second and subsequent GetProtectionStatus requests, specify the value of NextToken from the previous response to get information about another batch of objects.
    public var nextToken: Swift.String?
    /// The ID of the policy for which you want to get the attack information.
    /// This member is required.
    public var policyId: Swift.String?
    /// The start of the time period to query for the attacks. This is a timestamp type. The request syntax listing indicates a number type because the default used by Firewall Manager is Unix time in seconds. However, any valid timestamp format is allowed.
    public var startTime: ClientRuntime.Date?

    public init (
        endTime: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        memberAccountId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        policyId: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.endTime = endTime
        self.maxResults = maxResults
        self.memberAccountId = memberAccountId
        self.nextToken = nextToken
        self.policyId = policyId
        self.startTime = startTime
    }
}

struct GetProtectionStatusInputBody: Swift.Equatable {
    let policyId: Swift.String?
    let memberAccountId: Swift.String?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetProtectionStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case maxResults = "MaxResults"
        case memberAccountId = "MemberAccountId"
        case nextToken = "NextToken"
        case policyId = "PolicyId"
        case startTime = "StartTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let memberAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberAccountId)
        memberAccountId = memberAccountIdDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetProtectionStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetProtectionStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetProtectionStatusOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetProtectionStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetProtectionStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.adminAccountId = output.adminAccountId
            self.data = output.data
            self.nextToken = output.nextToken
            self.serviceType = output.serviceType
        } else {
            self.adminAccountId = nil
            self.data = nil
            self.nextToken = nil
            self.serviceType = nil
        }
    }
}

public struct GetProtectionStatusOutputResponse: Swift.Equatable {
    /// The ID of the Firewall Manager administrator account for this policy.
    public var adminAccountId: Swift.String?
    /// Details about the attack, including the following:
    ///
    /// * Attack type
    ///
    /// * Account ID
    ///
    /// * ARN of the resource attacked
    ///
    /// * Start time of the attack
    ///
    /// * End time of the attack (ongoing attacks will not have an end time)
    ///
    ///
    /// The details are in JSON format.
    public var data: Swift.String?
    /// If you have more objects than the number that you specified for MaxResults in the request, the response includes a NextToken value. To list more objects, submit another GetProtectionStatus request, and specify the NextToken value from the response in the NextToken value in the next request. Amazon Web Services SDKs provide auto-pagination that identify NextToken in a response and make subsequent request calls automatically on your behalf. However, this feature is not supported by GetProtectionStatus. You must submit subsequent requests with NextToken using your own processes.
    public var nextToken: Swift.String?
    /// The service type that is protected by the policy. Currently, this is always SHIELD_ADVANCED.
    public var serviceType: FMSClientTypes.SecurityServiceType?

    public init (
        adminAccountId: Swift.String? = nil,
        data: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        serviceType: FMSClientTypes.SecurityServiceType? = nil
    )
    {
        self.adminAccountId = adminAccountId
        self.data = data
        self.nextToken = nextToken
        self.serviceType = serviceType
    }
}

struct GetProtectionStatusOutputResponseBody: Swift.Equatable {
    let adminAccountId: Swift.String?
    let serviceType: FMSClientTypes.SecurityServiceType?
    let data: Swift.String?
    let nextToken: Swift.String?
}

extension GetProtectionStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccountId = "AdminAccountId"
        case data = "Data"
        case nextToken = "NextToken"
        case serviceType = "ServiceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminAccountId)
        adminAccountId = adminAccountIdDecoded
        let serviceTypeDecoded = try containerValues.decodeIfPresent(FMSClientTypes.SecurityServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let dataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .data)
        data = dataDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetProtocolsListInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultList = "DefaultList"
        case listId = "ListId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if defaultList != false {
            try encodeContainer.encode(defaultList, forKey: .defaultList)
        }
        if let listId = self.listId {
            try encodeContainer.encode(listId, forKey: .listId)
        }
    }
}

extension GetProtocolsListInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetProtocolsListInput: Swift.Equatable {
    /// Specifies whether the list to retrieve is a default list owned by Firewall Manager.
    public var defaultList: Swift.Bool
    /// The ID of the Firewall Manager protocols list that you want the details for.
    /// This member is required.
    public var listId: Swift.String?

    public init (
        defaultList: Swift.Bool = false,
        listId: Swift.String? = nil
    )
    {
        self.defaultList = defaultList
        self.listId = listId
    }
}

struct GetProtocolsListInputBody: Swift.Equatable {
    let listId: Swift.String?
    let defaultList: Swift.Bool
}

extension GetProtocolsListInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultList = "DefaultList"
        case listId = "ListId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listId)
        listId = listIdDecoded
        let defaultListDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .defaultList) ?? false
        defaultList = defaultListDecoded
    }
}

extension GetProtocolsListOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetProtocolsListOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetProtocolsListOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetProtocolsListOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetProtocolsListOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.protocolsList = output.protocolsList
            self.protocolsListArn = output.protocolsListArn
        } else {
            self.protocolsList = nil
            self.protocolsListArn = nil
        }
    }
}

public struct GetProtocolsListOutputResponse: Swift.Equatable {
    /// Information about the specified Firewall Manager protocols list.
    public var protocolsList: FMSClientTypes.ProtocolsListData?
    /// The Amazon Resource Name (ARN) of the specified protocols list.
    public var protocolsListArn: Swift.String?

    public init (
        protocolsList: FMSClientTypes.ProtocolsListData? = nil,
        protocolsListArn: Swift.String? = nil
    )
    {
        self.protocolsList = protocolsList
        self.protocolsListArn = protocolsListArn
    }
}

struct GetProtocolsListOutputResponseBody: Swift.Equatable {
    let protocolsList: FMSClientTypes.ProtocolsListData?
    let protocolsListArn: Swift.String?
}

extension GetProtocolsListOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protocolsList = "ProtocolsList"
        case protocolsListArn = "ProtocolsListArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protocolsListDecoded = try containerValues.decodeIfPresent(FMSClientTypes.ProtocolsListData.self, forKey: .protocolsList)
        protocolsList = protocolsListDecoded
        let protocolsListArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protocolsListArn)
        protocolsListArn = protocolsListArnDecoded
    }
}

extension GetResourceSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier = "Identifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
    }
}

extension GetResourceSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetResourceSetInput: Swift.Equatable {
    /// A unique identifier for the resource set, used in a TODO to refer to the resource set.
    /// This member is required.
    public var identifier: Swift.String?

    public init (
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

struct GetResourceSetInputBody: Swift.Equatable {
    let identifier: Swift.String?
}

extension GetResourceSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier = "Identifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
    }
}

extension GetResourceSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourceSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetResourceSetOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourceSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetResourceSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourceSet = output.resourceSet
            self.resourceSetArn = output.resourceSetArn
        } else {
            self.resourceSet = nil
            self.resourceSetArn = nil
        }
    }
}

public struct GetResourceSetOutputResponse: Swift.Equatable {
    /// Information about the specified resource set.
    /// This member is required.
    public var resourceSet: FMSClientTypes.ResourceSet?
    /// The Amazon Resource Name (ARN) of the resource set.
    /// This member is required.
    public var resourceSetArn: Swift.String?

    public init (
        resourceSet: FMSClientTypes.ResourceSet? = nil,
        resourceSetArn: Swift.String? = nil
    )
    {
        self.resourceSet = resourceSet
        self.resourceSetArn = resourceSetArn
    }
}

struct GetResourceSetOutputResponseBody: Swift.Equatable {
    let resourceSet: FMSClientTypes.ResourceSet?
    let resourceSetArn: Swift.String?
}

extension GetResourceSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceSet = "ResourceSet"
        case resourceSetArn = "ResourceSetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceSetDecoded = try containerValues.decodeIfPresent(FMSClientTypes.ResourceSet.self, forKey: .resourceSet)
        resourceSet = resourceSetDecoded
        let resourceSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetArn)
        resourceSetArn = resourceSetArnDecoded
    }
}

extension GetThirdPartyFirewallAssociationStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case thirdPartyFirewall = "ThirdPartyFirewall"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let thirdPartyFirewall = self.thirdPartyFirewall {
            try encodeContainer.encode(thirdPartyFirewall.rawValue, forKey: .thirdPartyFirewall)
        }
    }
}

extension GetThirdPartyFirewallAssociationStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetThirdPartyFirewallAssociationStatusInput: Swift.Equatable {
    /// The name of the third-party firewall vendor.
    /// This member is required.
    public var thirdPartyFirewall: FMSClientTypes.ThirdPartyFirewall?

    public init (
        thirdPartyFirewall: FMSClientTypes.ThirdPartyFirewall? = nil
    )
    {
        self.thirdPartyFirewall = thirdPartyFirewall
    }
}

struct GetThirdPartyFirewallAssociationStatusInputBody: Swift.Equatable {
    let thirdPartyFirewall: FMSClientTypes.ThirdPartyFirewall?
}

extension GetThirdPartyFirewallAssociationStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case thirdPartyFirewall = "ThirdPartyFirewall"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thirdPartyFirewallDecoded = try containerValues.decodeIfPresent(FMSClientTypes.ThirdPartyFirewall.self, forKey: .thirdPartyFirewall)
        thirdPartyFirewall = thirdPartyFirewallDecoded
    }
}

extension GetThirdPartyFirewallAssociationStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetThirdPartyFirewallAssociationStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetThirdPartyFirewallAssociationStatusOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetThirdPartyFirewallAssociationStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetThirdPartyFirewallAssociationStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marketplaceOnboardingStatus = output.marketplaceOnboardingStatus
            self.thirdPartyFirewallStatus = output.thirdPartyFirewallStatus
        } else {
            self.marketplaceOnboardingStatus = nil
            self.thirdPartyFirewallStatus = nil
        }
    }
}

public struct GetThirdPartyFirewallAssociationStatusOutputResponse: Swift.Equatable {
    /// The status for subscribing to the third-party firewall vendor in the Amazon Web Services Marketplace.
    ///
    /// * NO_SUBSCRIPTION - The Firewall Manager policy administrator isn't subscribed to the third-party firewall service in the Amazon Web Services Marketplace.
    ///
    /// * NOT_COMPLETE - The Firewall Manager policy administrator is in the process of subscribing to the third-party firewall service in the Amazon Web Services Marketplace, but doesn't yet have an active subscription.
    ///
    /// * COMPLETE - The Firewall Manager policy administrator has an active subscription to the third-party firewall service in the Amazon Web Services Marketplace.
    public var marketplaceOnboardingStatus: FMSClientTypes.MarketplaceSubscriptionOnboardingStatus?
    /// The current status for setting a Firewall Manager policy administrators account as an administrator of the third-party firewall tenant.
    ///
    /// * ONBOARDING - The Firewall Manager policy administrator is being designated as a tenant administrator.
    ///
    /// * ONBOARD_COMPLETE - The Firewall Manager policy administrator is designated as a tenant administrator.
    ///
    /// * OFFBOARDING - The Firewall Manager policy administrator is being removed as a tenant administrator.
    ///
    /// * OFFBOARD_COMPLETE - The Firewall Manager policy administrator has been removed as a tenant administrator.
    ///
    /// * NOT_EXIST - The Firewall Manager policy administrator doesn't exist as a tenant administrator.
    public var thirdPartyFirewallStatus: FMSClientTypes.ThirdPartyFirewallAssociationStatus?

    public init (
        marketplaceOnboardingStatus: FMSClientTypes.MarketplaceSubscriptionOnboardingStatus? = nil,
        thirdPartyFirewallStatus: FMSClientTypes.ThirdPartyFirewallAssociationStatus? = nil
    )
    {
        self.marketplaceOnboardingStatus = marketplaceOnboardingStatus
        self.thirdPartyFirewallStatus = thirdPartyFirewallStatus
    }
}

struct GetThirdPartyFirewallAssociationStatusOutputResponseBody: Swift.Equatable {
    let thirdPartyFirewallStatus: FMSClientTypes.ThirdPartyFirewallAssociationStatus?
    let marketplaceOnboardingStatus: FMSClientTypes.MarketplaceSubscriptionOnboardingStatus?
}

extension GetThirdPartyFirewallAssociationStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marketplaceOnboardingStatus = "MarketplaceOnboardingStatus"
        case thirdPartyFirewallStatus = "ThirdPartyFirewallStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thirdPartyFirewallStatusDecoded = try containerValues.decodeIfPresent(FMSClientTypes.ThirdPartyFirewallAssociationStatus.self, forKey: .thirdPartyFirewallStatus)
        thirdPartyFirewallStatus = thirdPartyFirewallStatusDecoded
        let marketplaceOnboardingStatusDecoded = try containerValues.decodeIfPresent(FMSClientTypes.MarketplaceSubscriptionOnboardingStatus.self, forKey: .marketplaceOnboardingStatus)
        marketplaceOnboardingStatus = marketplaceOnboardingStatusDecoded
    }
}

extension GetViolationDetailsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberAccount = "MemberAccount"
        case policyId = "PolicyId"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberAccount = self.memberAccount {
            try encodeContainer.encode(memberAccount, forKey: .memberAccount)
        }
        if let policyId = self.policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }
}

extension GetViolationDetailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetViolationDetailsInput: Swift.Equatable {
    /// The Amazon Web Services account ID that you want the details for.
    /// This member is required.
    public var memberAccount: Swift.String?
    /// The ID of the Firewall Manager policy that you want the details for. This currently only supports security group content audit policies.
    /// This member is required.
    public var policyId: Swift.String?
    /// The ID of the resource that has violations.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The resource type. This is in the format shown in the [Amazon Web Services Resource Types Reference](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html). Supported resource types are: AWS::EC2::Instance, AWS::EC2::NetworkInterface, AWS::EC2::SecurityGroup, AWS::NetworkFirewall::FirewallPolicy, and AWS::EC2::Subnet.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        memberAccount: Swift.String? = nil,
        policyId: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.memberAccount = memberAccount
        self.policyId = policyId
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct GetViolationDetailsInputBody: Swift.Equatable {
    let policyId: Swift.String?
    let memberAccount: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension GetViolationDetailsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberAccount = "MemberAccount"
        case policyId = "PolicyId"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let memberAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberAccount)
        memberAccount = memberAccountDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension GetViolationDetailsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetViolationDetailsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetViolationDetailsOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetViolationDetailsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetViolationDetailsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.violationDetail = output.violationDetail
        } else {
            self.violationDetail = nil
        }
    }
}

public struct GetViolationDetailsOutputResponse: Swift.Equatable {
    /// Violation detail for a resource.
    public var violationDetail: FMSClientTypes.ViolationDetail?

    public init (
        violationDetail: FMSClientTypes.ViolationDetail? = nil
    )
    {
        self.violationDetail = violationDetail
    }
}

struct GetViolationDetailsOutputResponseBody: Swift.Equatable {
    let violationDetail: FMSClientTypes.ViolationDetail?
}

extension GetViolationDetailsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case violationDetail = "ViolationDetail"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationDetailDecoded = try containerValues.decodeIfPresent(FMSClientTypes.ViolationDetail.self, forKey: .violationDetail)
        violationDetail = violationDetailDecoded
    }
}

extension InternalErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation failed because of a system problem, even though the request was valid. Retry your request.
public struct InternalErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInputException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidInputExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The parameters of the request were invalid.
public struct InvalidInputException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInputExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidInputExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOperationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidOperationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation failed because there was nothing to do or the operation wasn't possible. For example, you might have submitted an AssociateAdminAccount request for an account ID that was already set as the Firewall Manager administrator. Or you might have tried to access a Region that's disabled by default, and that you need to enable for the Firewall Manager administrator account and for Organizations before you can access it.
public struct InvalidOperationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidOperationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidOperationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTypeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidTypeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The value of the Type parameter is invalid.
public struct InvalidTypeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTypeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTypeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation exceeds a resource limit, for example, the maximum number of policy objects that you can create for an Amazon Web Services account. For more information, see [Firewall Manager Limits](https://docs.aws.amazon.com/waf/latest/developerguide/fms-limits.html) in the WAF Developer Guide.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAppsListsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultLists = "DefaultLists"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if defaultLists != false {
            try encodeContainer.encode(defaultLists, forKey: .defaultLists)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAppsListsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAppsListsInput: Swift.Equatable {
    /// Specifies whether the lists to retrieve are default lists owned by Firewall Manager.
    public var defaultLists: Swift.Bool
    /// The maximum number of objects that you want Firewall Manager to return for this request. If more objects are available, in the response, Firewall Manager provides a NextToken value that you can use in a subsequent call to get the next batch of objects. If you don't specify this, Firewall Manager returns all available objects.
    /// This member is required.
    public var maxResults: Swift.Int?
    /// If you specify a value for MaxResults in your list request, and you have more objects than the maximum, Firewall Manager returns this token in the response. For all but the first request, you provide the token returned by the prior request in the request parameters, to retrieve the next batch of objects.
    public var nextToken: Swift.String?

    public init (
        defaultLists: Swift.Bool = false,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.defaultLists = defaultLists
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppsListsInputBody: Swift.Equatable {
    let defaultLists: Swift.Bool
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListAppsListsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultLists = "DefaultLists"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultListsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .defaultLists) ?? false
        defaultLists = defaultListsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAppsListsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAppsListsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAppsListsOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAppsListsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAppsListsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appsLists = output.appsLists
            self.nextToken = output.nextToken
        } else {
            self.appsLists = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppsListsOutputResponse: Swift.Equatable {
    /// An array of AppsListDataSummary objects.
    public var appsLists: [FMSClientTypes.AppsListDataSummary]?
    /// If you specify a value for MaxResults in your list request, and you have more objects than the maximum, Firewall Manager returns this token in the response. You can use this token in subsequent requests to retrieve the next batch of objects.
    public var nextToken: Swift.String?

    public init (
        appsLists: [FMSClientTypes.AppsListDataSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appsLists = appsLists
        self.nextToken = nextToken
    }
}

struct ListAppsListsOutputResponseBody: Swift.Equatable {
    let appsLists: [FMSClientTypes.AppsListDataSummary]?
    let nextToken: Swift.String?
}

extension ListAppsListsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appsLists = "AppsLists"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appsListsContainer = try containerValues.decodeIfPresent([FMSClientTypes.AppsListDataSummary?].self, forKey: .appsLists)
        var appsListsDecoded0:[FMSClientTypes.AppsListDataSummary]? = nil
        if let appsListsContainer = appsListsContainer {
            appsListsDecoded0 = [FMSClientTypes.AppsListDataSummary]()
            for structure0 in appsListsContainer {
                if let structure0 = structure0 {
                    appsListsDecoded0?.append(structure0)
                }
            }
        }
        appsLists = appsListsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListComplianceStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case policyId = "PolicyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let policyId = self.policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
    }
}

extension ListComplianceStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListComplianceStatusInput: Swift.Equatable {
    /// Specifies the number of PolicyComplianceStatus objects that you want Firewall Manager to return for this request. If you have more PolicyComplianceStatus objects than the number that you specify for MaxResults, the response includes a NextToken value that you can use to get another batch of PolicyComplianceStatus objects.
    public var maxResults: Swift.Int?
    /// If you specify a value for MaxResults and you have more PolicyComplianceStatus objects than the number that you specify for MaxResults, Firewall Manager returns a NextToken value in the response that allows you to list another group of PolicyComplianceStatus objects. For the second and subsequent ListComplianceStatus requests, specify the value of NextToken from the previous response to get information about another batch of PolicyComplianceStatus objects.
    public var nextToken: Swift.String?
    /// The ID of the Firewall Manager policy that you want the details for.
    /// This member is required.
    public var policyId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        policyId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.policyId = policyId
    }
}

struct ListComplianceStatusInputBody: Swift.Equatable {
    let policyId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListComplianceStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case policyId = "PolicyId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListComplianceStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListComplianceStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListComplianceStatusOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListComplianceStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListComplianceStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.policyComplianceStatusList = output.policyComplianceStatusList
        } else {
            self.nextToken = nil
            self.policyComplianceStatusList = nil
        }
    }
}

public struct ListComplianceStatusOutputResponse: Swift.Equatable {
    /// If you have more PolicyComplianceStatus objects than the number that you specified for MaxResults in the request, the response includes a NextToken value. To list more PolicyComplianceStatus objects, submit another ListComplianceStatus request, and specify the NextToken value from the response in the NextToken value in the next request.
    public var nextToken: Swift.String?
    /// An array of PolicyComplianceStatus objects.
    public var policyComplianceStatusList: [FMSClientTypes.PolicyComplianceStatus]?

    public init (
        nextToken: Swift.String? = nil,
        policyComplianceStatusList: [FMSClientTypes.PolicyComplianceStatus]? = nil
    )
    {
        self.nextToken = nextToken
        self.policyComplianceStatusList = policyComplianceStatusList
    }
}

struct ListComplianceStatusOutputResponseBody: Swift.Equatable {
    let policyComplianceStatusList: [FMSClientTypes.PolicyComplianceStatus]?
    let nextToken: Swift.String?
}

extension ListComplianceStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case policyComplianceStatusList = "PolicyComplianceStatusList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyComplianceStatusListContainer = try containerValues.decodeIfPresent([FMSClientTypes.PolicyComplianceStatus?].self, forKey: .policyComplianceStatusList)
        var policyComplianceStatusListDecoded0:[FMSClientTypes.PolicyComplianceStatus]? = nil
        if let policyComplianceStatusListContainer = policyComplianceStatusListContainer {
            policyComplianceStatusListDecoded0 = [FMSClientTypes.PolicyComplianceStatus]()
            for structure0 in policyComplianceStatusListContainer {
                if let structure0 = structure0 {
                    policyComplianceStatusListDecoded0?.append(structure0)
                }
            }
        }
        policyComplianceStatusList = policyComplianceStatusListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDiscoveredResourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case memberAccountIds = "MemberAccountIds"
        case nextToken = "NextToken"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let memberAccountIds = memberAccountIds {
            var memberAccountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .memberAccountIds)
            for awsaccountid0 in memberAccountIds {
                try memberAccountIdsContainer.encode(awsaccountid0)
            }
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }
}

extension ListDiscoveredResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDiscoveredResourcesInput: Swift.Equatable {
    /// The maximum number of objects that you want Firewall Manager to return for this request. If more objects are available, in the response, Firewall Manager provides a NextToken value that you can use in a subsequent call to get the next batch of objects.
    public var maxResults: Swift.Int?
    /// The Amazon Web Services account IDs to discover resources in. Only one account is supported per request. The account must be a member of your organization.
    /// This member is required.
    public var memberAccountIds: [Swift.String]?
    /// When you request a list of objects with a MaxResults setting, if the number of objects that are still available for retrieval exceeds the maximum you requested, Firewall Manager returns a NextToken value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.
    public var nextToken: Swift.String?
    /// The type of resources to discover.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        memberAccountIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.memberAccountIds = memberAccountIds
        self.nextToken = nextToken
        self.resourceType = resourceType
    }
}

struct ListDiscoveredResourcesInputBody: Swift.Equatable {
    let memberAccountIds: [Swift.String]?
    let resourceType: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListDiscoveredResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case memberAccountIds = "MemberAccountIds"
        case nextToken = "NextToken"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberAccountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .memberAccountIds)
        var memberAccountIdsDecoded0:[Swift.String]? = nil
        if let memberAccountIdsContainer = memberAccountIdsContainer {
            memberAccountIdsDecoded0 = [Swift.String]()
            for string0 in memberAccountIdsContainer {
                if let string0 = string0 {
                    memberAccountIdsDecoded0?.append(string0)
                }
            }
        }
        memberAccountIds = memberAccountIdsDecoded0
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDiscoveredResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDiscoveredResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDiscoveredResourcesOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case invalidOperationException(InvalidOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDiscoveredResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDiscoveredResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListDiscoveredResourcesOutputResponse: Swift.Equatable {
    /// Details of the resources that were discovered.
    public var items: [FMSClientTypes.DiscoveredResource]?
    /// When you request a list of objects with a MaxResults setting, if the number of objects that are still available for retrieval exceeds the maximum you requested, Firewall Manager returns a NextToken value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.
    public var nextToken: Swift.String?

    public init (
        items: [FMSClientTypes.DiscoveredResource]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListDiscoveredResourcesOutputResponseBody: Swift.Equatable {
    let items: [FMSClientTypes.DiscoveredResource]?
    let nextToken: Swift.String?
}

extension ListDiscoveredResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([FMSClientTypes.DiscoveredResource?].self, forKey: .items)
        var itemsDecoded0:[FMSClientTypes.DiscoveredResource]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [FMSClientTypes.DiscoveredResource]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListMemberAccountsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListMemberAccountsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListMemberAccountsInput: Swift.Equatable {
    /// Specifies the number of member account IDs that you want Firewall Manager to return for this request. If you have more IDs than the number that you specify for MaxResults, the response includes a NextToken value that you can use to get another batch of member account IDs.
    public var maxResults: Swift.Int?
    /// If you specify a value for MaxResults and you have more account IDs than the number that you specify for MaxResults, Firewall Manager returns a NextToken value in the response that allows you to list another group of IDs. For the second and subsequent ListMemberAccountsRequest requests, specify the value of NextToken from the previous response to get information about another batch of member account IDs.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMemberAccountsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListMemberAccountsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListMemberAccountsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMemberAccountsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListMemberAccountsOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMemberAccountsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListMemberAccountsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.memberAccounts = output.memberAccounts
            self.nextToken = output.nextToken
        } else {
            self.memberAccounts = nil
            self.nextToken = nil
        }
    }
}

public struct ListMemberAccountsOutputResponse: Swift.Equatable {
    /// An array of account IDs.
    public var memberAccounts: [Swift.String]?
    /// If you have more member account IDs than the number that you specified for MaxResults in the request, the response includes a NextToken value. To list more IDs, submit another ListMemberAccounts request, and specify the NextToken value from the response in the NextToken value in the next request.
    public var nextToken: Swift.String?

    public init (
        memberAccounts: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.memberAccounts = memberAccounts
        self.nextToken = nextToken
    }
}

struct ListMemberAccountsOutputResponseBody: Swift.Equatable {
    let memberAccounts: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListMemberAccountsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberAccounts = "MemberAccounts"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberAccountsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .memberAccounts)
        var memberAccountsDecoded0:[Swift.String]? = nil
        if let memberAccountsContainer = memberAccountsContainer {
            memberAccountsDecoded0 = [Swift.String]()
            for string0 in memberAccountsContainer {
                if let string0 = string0 {
                    memberAccountsDecoded0?.append(string0)
                }
            }
        }
        memberAccounts = memberAccountsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPoliciesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListPoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPoliciesInput: Swift.Equatable {
    /// Specifies the number of PolicySummary objects that you want Firewall Manager to return for this request. If you have more PolicySummary objects than the number that you specify for MaxResults, the response includes a NextToken value that you can use to get another batch of PolicySummary objects.
    public var maxResults: Swift.Int?
    /// If you specify a value for MaxResults and you have more PolicySummary objects than the number that you specify for MaxResults, Firewall Manager returns a NextToken value in the response that allows you to list another group of PolicySummary objects. For the second and subsequent ListPolicies requests, specify the value of NextToken from the previous response to get information about another batch of PolicySummary objects.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPoliciesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListPoliciesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPoliciesOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.policyList = output.policyList
        } else {
            self.nextToken = nil
            self.policyList = nil
        }
    }
}

public struct ListPoliciesOutputResponse: Swift.Equatable {
    /// If you have more PolicySummary objects than the number that you specified for MaxResults in the request, the response includes a NextToken value. To list more PolicySummary objects, submit another ListPolicies request, and specify the NextToken value from the response in the NextToken value in the next request.
    public var nextToken: Swift.String?
    /// An array of PolicySummary objects.
    public var policyList: [FMSClientTypes.PolicySummary]?

    public init (
        nextToken: Swift.String? = nil,
        policyList: [FMSClientTypes.PolicySummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.policyList = policyList
    }
}

struct ListPoliciesOutputResponseBody: Swift.Equatable {
    let policyList: [FMSClientTypes.PolicySummary]?
    let nextToken: Swift.String?
}

extension ListPoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case policyList = "PolicyList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyListContainer = try containerValues.decodeIfPresent([FMSClientTypes.PolicySummary?].self, forKey: .policyList)
        var policyListDecoded0:[FMSClientTypes.PolicySummary]? = nil
        if let policyListContainer = policyListContainer {
            policyListDecoded0 = [FMSClientTypes.PolicySummary]()
            for structure0 in policyListContainer {
                if let structure0 = structure0 {
                    policyListDecoded0?.append(structure0)
                }
            }
        }
        policyList = policyListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProtocolsListsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultLists = "DefaultLists"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if defaultLists != false {
            try encodeContainer.encode(defaultLists, forKey: .defaultLists)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListProtocolsListsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListProtocolsListsInput: Swift.Equatable {
    /// Specifies whether the lists to retrieve are default lists owned by Firewall Manager.
    public var defaultLists: Swift.Bool
    /// The maximum number of objects that you want Firewall Manager to return for this request. If more objects are available, in the response, Firewall Manager provides a NextToken value that you can use in a subsequent call to get the next batch of objects. If you don't specify this, Firewall Manager returns all available objects.
    /// This member is required.
    public var maxResults: Swift.Int?
    /// If you specify a value for MaxResults in your list request, and you have more objects than the maximum, Firewall Manager returns this token in the response. For all but the first request, you provide the token returned by the prior request in the request parameters, to retrieve the next batch of objects.
    public var nextToken: Swift.String?

    public init (
        defaultLists: Swift.Bool = false,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.defaultLists = defaultLists
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProtocolsListsInputBody: Swift.Equatable {
    let defaultLists: Swift.Bool
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListProtocolsListsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultLists = "DefaultLists"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultListsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .defaultLists) ?? false
        defaultLists = defaultListsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListProtocolsListsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProtocolsListsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListProtocolsListsOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProtocolsListsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListProtocolsListsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.protocolsLists = output.protocolsLists
        } else {
            self.nextToken = nil
            self.protocolsLists = nil
        }
    }
}

public struct ListProtocolsListsOutputResponse: Swift.Equatable {
    /// If you specify a value for MaxResults in your list request, and you have more objects than the maximum, Firewall Manager returns this token in the response. You can use this token in subsequent requests to retrieve the next batch of objects.
    public var nextToken: Swift.String?
    /// An array of ProtocolsListDataSummary objects.
    public var protocolsLists: [FMSClientTypes.ProtocolsListDataSummary]?

    public init (
        nextToken: Swift.String? = nil,
        protocolsLists: [FMSClientTypes.ProtocolsListDataSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.protocolsLists = protocolsLists
    }
}

struct ListProtocolsListsOutputResponseBody: Swift.Equatable {
    let protocolsLists: [FMSClientTypes.ProtocolsListDataSummary]?
    let nextToken: Swift.String?
}

extension ListProtocolsListsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case protocolsLists = "ProtocolsLists"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protocolsListsContainer = try containerValues.decodeIfPresent([FMSClientTypes.ProtocolsListDataSummary?].self, forKey: .protocolsLists)
        var protocolsListsDecoded0:[FMSClientTypes.ProtocolsListDataSummary]? = nil
        if let protocolsListsContainer = protocolsListsContainer {
            protocolsListsDecoded0 = [FMSClientTypes.ProtocolsListDataSummary]()
            for structure0 in protocolsListsContainer {
                if let structure0 = structure0 {
                    protocolsListsDecoded0?.append(structure0)
                }
            }
        }
        protocolsLists = protocolsListsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListResourceSetResourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier = "Identifier"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListResourceSetResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListResourceSetResourcesInput: Swift.Equatable {
    /// A unique identifier for the resource set, used in a TODO to refer to the resource set.
    /// This member is required.
    public var identifier: Swift.String?
    /// The maximum number of objects that you want Firewall Manager to return for this request. If more objects are available, in the response, Firewall Manager provides a NextToken value that you can use in a subsequent call to get the next batch of objects.
    public var maxResults: Swift.Int?
    /// When you request a list of objects with a MaxResults setting, if the number of objects that are still available for retrieval exceeds the maximum you requested, Firewall Manager returns a NextToken value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.
    public var nextToken: Swift.String?

    public init (
        identifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.identifier = identifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResourceSetResourcesInputBody: Swift.Equatable {
    let identifier: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListResourceSetResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier = "Identifier"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListResourceSetResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourceSetResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListResourceSetResourcesOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourceSetResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListResourceSetResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListResourceSetResourcesOutputResponse: Swift.Equatable {
    /// An array of the associated resources' uniform resource identifiers (URI).
    /// This member is required.
    public var items: [FMSClientTypes.Resource]?
    /// When you request a list of objects with a MaxResults setting, if the number of objects that are still available for retrieval exceeds the maximum you requested, Firewall Manager returns a NextToken value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.
    public var nextToken: Swift.String?

    public init (
        items: [FMSClientTypes.Resource]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListResourceSetResourcesOutputResponseBody: Swift.Equatable {
    let items: [FMSClientTypes.Resource]?
    let nextToken: Swift.String?
}

extension ListResourceSetResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([FMSClientTypes.Resource?].self, forKey: .items)
        var itemsDecoded0:[FMSClientTypes.Resource]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [FMSClientTypes.Resource]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListResourceSetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListResourceSetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListResourceSetsInput: Swift.Equatable {
    /// The maximum number of objects that you want Firewall Manager to return for this request. If more objects are available, in the response, Firewall Manager provides a NextToken value that you can use in a subsequent call to get the next batch of objects.
    public var maxResults: Swift.Int?
    /// When you request a list of objects with a MaxResults setting, if the number of objects that are still available for retrieval exceeds the maximum you requested, Firewall Manager returns a NextToken value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResourceSetsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListResourceSetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListResourceSetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourceSetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListResourceSetsOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case invalidOperationException(InvalidOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourceSetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListResourceSetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceSets = output.resourceSets
        } else {
            self.nextToken = nil
            self.resourceSets = nil
        }
    }
}

public struct ListResourceSetsOutputResponse: Swift.Equatable {
    /// When you request a list of objects with a MaxResults setting, if the number of objects that are still available for retrieval exceeds the maximum you requested, Firewall Manager returns a NextToken value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.
    public var nextToken: Swift.String?
    /// An array of ResourceSetSummary objects.
    public var resourceSets: [FMSClientTypes.ResourceSetSummary]?

    public init (
        nextToken: Swift.String? = nil,
        resourceSets: [FMSClientTypes.ResourceSetSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceSets = resourceSets
    }
}

struct ListResourceSetsOutputResponseBody: Swift.Equatable {
    let resourceSets: [FMSClientTypes.ResourceSetSummary]?
    let nextToken: Swift.String?
}

extension ListResourceSetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceSets = "ResourceSets"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceSetsContainer = try containerValues.decodeIfPresent([FMSClientTypes.ResourceSetSummary?].self, forKey: .resourceSets)
        var resourceSetsDecoded0:[FMSClientTypes.ResourceSetSummary]? = nil
        if let resourceSetsContainer = resourceSetsContainer {
            resourceSetsDecoded0 = [FMSClientTypes.ResourceSetSummary]()
            for structure0 in resourceSetsContainer {
                if let structure0 = structure0 {
                    resourceSetsDecoded0?.append(structure0)
                }
            }
        }
        resourceSets = resourceSetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to return tags for. The Firewall Manager resources that support tagging are policies, applications lists, and protocols lists.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tagList = output.tagList
        } else {
            self.tagList = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags associated with the resource.
    public var tagList: [FMSClientTypes.Tag]?

    public init (
        tagList: [FMSClientTypes.Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tagList: [FMSClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagList = "TagList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagListContainer = try containerValues.decodeIfPresent([FMSClientTypes.Tag?].self, forKey: .tagList)
        var tagListDecoded0:[FMSClientTypes.Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [FMSClientTypes.Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension ListThirdPartyFirewallFirewallPoliciesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case thirdPartyFirewall = "ThirdPartyFirewall"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let thirdPartyFirewall = self.thirdPartyFirewall {
            try encodeContainer.encode(thirdPartyFirewall.rawValue, forKey: .thirdPartyFirewall)
        }
    }
}

extension ListThirdPartyFirewallFirewallPoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListThirdPartyFirewallFirewallPoliciesInput: Swift.Equatable {
    /// The maximum number of third-party firewall policies that you want Firewall Manager to return. If the specified third-party firewall vendor is associated with more than MaxResults firewall policies, the response includes a NextToken element. NextToken contains an encrypted token that identifies the first third-party firewall policies that Firewall Manager will return if you submit another request.
    /// This member is required.
    public var maxResults: Swift.Int?
    /// If the previous response included a NextToken element, the specified third-party firewall vendor is associated with more third-party firewall policies. To get more third-party firewall policies, submit another ListThirdPartyFirewallFirewallPoliciesRequest request. For the value of NextToken, specify the value of NextToken from the previous response. If the previous response didn't include a NextToken element, there are no more third-party firewall policies to get.
    public var nextToken: Swift.String?
    /// The name of the third-party firewall vendor.
    /// This member is required.
    public var thirdPartyFirewall: FMSClientTypes.ThirdPartyFirewall?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        thirdPartyFirewall: FMSClientTypes.ThirdPartyFirewall? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.thirdPartyFirewall = thirdPartyFirewall
    }
}

struct ListThirdPartyFirewallFirewallPoliciesInputBody: Swift.Equatable {
    let thirdPartyFirewall: FMSClientTypes.ThirdPartyFirewall?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListThirdPartyFirewallFirewallPoliciesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case thirdPartyFirewall = "ThirdPartyFirewall"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thirdPartyFirewallDecoded = try containerValues.decodeIfPresent(FMSClientTypes.ThirdPartyFirewall.self, forKey: .thirdPartyFirewall)
        thirdPartyFirewall = thirdPartyFirewallDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListThirdPartyFirewallFirewallPoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListThirdPartyFirewallFirewallPoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListThirdPartyFirewallFirewallPoliciesOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListThirdPartyFirewallFirewallPoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListThirdPartyFirewallFirewallPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.thirdPartyFirewallFirewallPolicies = output.thirdPartyFirewallFirewallPolicies
        } else {
            self.nextToken = nil
            self.thirdPartyFirewallFirewallPolicies = nil
        }
    }
}

public struct ListThirdPartyFirewallFirewallPoliciesOutputResponse: Swift.Equatable {
    /// The value that you will use for NextToken in the next ListThirdPartyFirewallFirewallPolicies request.
    public var nextToken: Swift.String?
    /// A list that contains one ThirdPartyFirewallFirewallPolicies element for each third-party firewall policies that the specified third-party firewall vendor is associated with. Each ThirdPartyFirewallFirewallPolicies element contains the firewall policy name and ID.
    public var thirdPartyFirewallFirewallPolicies: [FMSClientTypes.ThirdPartyFirewallFirewallPolicy]?

    public init (
        nextToken: Swift.String? = nil,
        thirdPartyFirewallFirewallPolicies: [FMSClientTypes.ThirdPartyFirewallFirewallPolicy]? = nil
    )
    {
        self.nextToken = nextToken
        self.thirdPartyFirewallFirewallPolicies = thirdPartyFirewallFirewallPolicies
    }
}

struct ListThirdPartyFirewallFirewallPoliciesOutputResponseBody: Swift.Equatable {
    let thirdPartyFirewallFirewallPolicies: [FMSClientTypes.ThirdPartyFirewallFirewallPolicy]?
    let nextToken: Swift.String?
}

extension ListThirdPartyFirewallFirewallPoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case thirdPartyFirewallFirewallPolicies = "ThirdPartyFirewallFirewallPolicies"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thirdPartyFirewallFirewallPoliciesContainer = try containerValues.decodeIfPresent([FMSClientTypes.ThirdPartyFirewallFirewallPolicy?].self, forKey: .thirdPartyFirewallFirewallPolicies)
        var thirdPartyFirewallFirewallPoliciesDecoded0:[FMSClientTypes.ThirdPartyFirewallFirewallPolicy]? = nil
        if let thirdPartyFirewallFirewallPoliciesContainer = thirdPartyFirewallFirewallPoliciesContainer {
            thirdPartyFirewallFirewallPoliciesDecoded0 = [FMSClientTypes.ThirdPartyFirewallFirewallPolicy]()
            for structure0 in thirdPartyFirewallFirewallPoliciesContainer {
                if let structure0 = structure0 {
                    thirdPartyFirewallFirewallPoliciesDecoded0?.append(structure0)
                }
            }
        }
        thirdPartyFirewallFirewallPolicies = thirdPartyFirewallFirewallPoliciesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension FMSClientTypes {
    public enum MarketplaceSubscriptionOnboardingStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case notComplete
        case noSubscription
        case sdkUnknown(Swift.String)

        public static var allCases: [MarketplaceSubscriptionOnboardingStatus] {
            return [
                .complete,
                .notComplete,
                .noSubscription,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .notComplete: return "NOT_COMPLETE"
            case .noSubscription: return "NO_SUBSCRIPTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MarketplaceSubscriptionOnboardingStatus(rawValue: rawValue) ?? MarketplaceSubscriptionOnboardingStatus.sdkUnknown(rawValue)
        }
    }
}

extension FMSClientTypes.NetworkFirewallBlackHoleRouteDetectedViolation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case routeTableId = "RouteTableId"
        case violatingRoutes = "ViolatingRoutes"
        case violationTarget = "ViolationTarget"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let routeTableId = self.routeTableId {
            try encodeContainer.encode(routeTableId, forKey: .routeTableId)
        }
        if let violatingRoutes = violatingRoutes {
            var violatingRoutesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .violatingRoutes)
            for route0 in violatingRoutes {
                try violatingRoutesContainer.encode(route0)
            }
        }
        if let violationTarget = self.violationTarget {
            try encodeContainer.encode(violationTarget, forKey: .violationTarget)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .violationTarget)
        violationTarget = violationTargetDecoded
        let routeTableIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeTableId)
        routeTableId = routeTableIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let violatingRoutesContainer = try containerValues.decodeIfPresent([FMSClientTypes.Route?].self, forKey: .violatingRoutes)
        var violatingRoutesDecoded0:[FMSClientTypes.Route]? = nil
        if let violatingRoutesContainer = violatingRoutesContainer {
            violatingRoutesDecoded0 = [FMSClientTypes.Route]()
            for structure0 in violatingRoutesContainer {
                if let structure0 = structure0 {
                    violatingRoutesDecoded0?.append(structure0)
                }
            }
        }
        violatingRoutes = violatingRoutesDecoded0
    }
}

extension FMSClientTypes {
    /// Violation detail for an internet gateway route with an inactive state in the customer subnet route table or Network Firewall subnet route table.
    public struct NetworkFirewallBlackHoleRouteDetectedViolation: Swift.Equatable {
        /// Information about the route table ID.
        public var routeTableId: Swift.String?
        /// Information about the route or routes that are in violation.
        public var violatingRoutes: [FMSClientTypes.Route]?
        /// The subnet that has an inactive state.
        public var violationTarget: Swift.String?
        /// Information about the VPC ID.
        public var vpcId: Swift.String?

        public init (
            routeTableId: Swift.String? = nil,
            violatingRoutes: [FMSClientTypes.Route]? = nil,
            violationTarget: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.routeTableId = routeTableId
            self.violatingRoutes = violatingRoutes
            self.violationTarget = violationTarget
            self.vpcId = vpcId
        }
    }

}

extension FMSClientTypes.NetworkFirewallInternetTrafficNotInspectedViolation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actualFirewallSubnetRoutes = "ActualFirewallSubnetRoutes"
        case actualInternetGatewayRoutes = "ActualInternetGatewayRoutes"
        case currentFirewallSubnetRouteTable = "CurrentFirewallSubnetRouteTable"
        case currentInternetGatewayRouteTable = "CurrentInternetGatewayRouteTable"
        case expectedFirewallEndpoint = "ExpectedFirewallEndpoint"
        case expectedFirewallSubnetRoutes = "ExpectedFirewallSubnetRoutes"
        case expectedInternetGatewayRoutes = "ExpectedInternetGatewayRoutes"
        case firewallSubnetId = "FirewallSubnetId"
        case internetGatewayId = "InternetGatewayId"
        case isRouteTableUsedInDifferentAZ = "IsRouteTableUsedInDifferentAZ"
        case routeTableId = "RouteTableId"
        case subnetAvailabilityZone = "SubnetAvailabilityZone"
        case subnetId = "SubnetId"
        case violatingRoutes = "ViolatingRoutes"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actualFirewallSubnetRoutes = actualFirewallSubnetRoutes {
            var actualFirewallSubnetRoutesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actualFirewallSubnetRoutes)
            for route0 in actualFirewallSubnetRoutes {
                try actualFirewallSubnetRoutesContainer.encode(route0)
            }
        }
        if let actualInternetGatewayRoutes = actualInternetGatewayRoutes {
            var actualInternetGatewayRoutesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actualInternetGatewayRoutes)
            for route0 in actualInternetGatewayRoutes {
                try actualInternetGatewayRoutesContainer.encode(route0)
            }
        }
        if let currentFirewallSubnetRouteTable = self.currentFirewallSubnetRouteTable {
            try encodeContainer.encode(currentFirewallSubnetRouteTable, forKey: .currentFirewallSubnetRouteTable)
        }
        if let currentInternetGatewayRouteTable = self.currentInternetGatewayRouteTable {
            try encodeContainer.encode(currentInternetGatewayRouteTable, forKey: .currentInternetGatewayRouteTable)
        }
        if let expectedFirewallEndpoint = self.expectedFirewallEndpoint {
            try encodeContainer.encode(expectedFirewallEndpoint, forKey: .expectedFirewallEndpoint)
        }
        if let expectedFirewallSubnetRoutes = expectedFirewallSubnetRoutes {
            var expectedFirewallSubnetRoutesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .expectedFirewallSubnetRoutes)
            for expectedroute0 in expectedFirewallSubnetRoutes {
                try expectedFirewallSubnetRoutesContainer.encode(expectedroute0)
            }
        }
        if let expectedInternetGatewayRoutes = expectedInternetGatewayRoutes {
            var expectedInternetGatewayRoutesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .expectedInternetGatewayRoutes)
            for expectedroute0 in expectedInternetGatewayRoutes {
                try expectedInternetGatewayRoutesContainer.encode(expectedroute0)
            }
        }
        if let firewallSubnetId = self.firewallSubnetId {
            try encodeContainer.encode(firewallSubnetId, forKey: .firewallSubnetId)
        }
        if let internetGatewayId = self.internetGatewayId {
            try encodeContainer.encode(internetGatewayId, forKey: .internetGatewayId)
        }
        if isRouteTableUsedInDifferentAZ != false {
            try encodeContainer.encode(isRouteTableUsedInDifferentAZ, forKey: .isRouteTableUsedInDifferentAZ)
        }
        if let routeTableId = self.routeTableId {
            try encodeContainer.encode(routeTableId, forKey: .routeTableId)
        }
        if let subnetAvailabilityZone = self.subnetAvailabilityZone {
            try encodeContainer.encode(subnetAvailabilityZone, forKey: .subnetAvailabilityZone)
        }
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let violatingRoutes = violatingRoutes {
            var violatingRoutesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .violatingRoutes)
            for route0 in violatingRoutes {
                try violatingRoutesContainer.encode(route0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let subnetAvailabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetAvailabilityZone)
        subnetAvailabilityZone = subnetAvailabilityZoneDecoded
        let routeTableIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeTableId)
        routeTableId = routeTableIdDecoded
        let violatingRoutesContainer = try containerValues.decodeIfPresent([FMSClientTypes.Route?].self, forKey: .violatingRoutes)
        var violatingRoutesDecoded0:[FMSClientTypes.Route]? = nil
        if let violatingRoutesContainer = violatingRoutesContainer {
            violatingRoutesDecoded0 = [FMSClientTypes.Route]()
            for structure0 in violatingRoutesContainer {
                if let structure0 = structure0 {
                    violatingRoutesDecoded0?.append(structure0)
                }
            }
        }
        violatingRoutes = violatingRoutesDecoded0
        let isRouteTableUsedInDifferentAZDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isRouteTableUsedInDifferentAZ) ?? false
        isRouteTableUsedInDifferentAZ = isRouteTableUsedInDifferentAZDecoded
        let currentFirewallSubnetRouteTableDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentFirewallSubnetRouteTable)
        currentFirewallSubnetRouteTable = currentFirewallSubnetRouteTableDecoded
        let expectedFirewallEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expectedFirewallEndpoint)
        expectedFirewallEndpoint = expectedFirewallEndpointDecoded
        let firewallSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallSubnetId)
        firewallSubnetId = firewallSubnetIdDecoded
        let expectedFirewallSubnetRoutesContainer = try containerValues.decodeIfPresent([FMSClientTypes.ExpectedRoute?].self, forKey: .expectedFirewallSubnetRoutes)
        var expectedFirewallSubnetRoutesDecoded0:[FMSClientTypes.ExpectedRoute]? = nil
        if let expectedFirewallSubnetRoutesContainer = expectedFirewallSubnetRoutesContainer {
            expectedFirewallSubnetRoutesDecoded0 = [FMSClientTypes.ExpectedRoute]()
            for structure0 in expectedFirewallSubnetRoutesContainer {
                if let structure0 = structure0 {
                    expectedFirewallSubnetRoutesDecoded0?.append(structure0)
                }
            }
        }
        expectedFirewallSubnetRoutes = expectedFirewallSubnetRoutesDecoded0
        let actualFirewallSubnetRoutesContainer = try containerValues.decodeIfPresent([FMSClientTypes.Route?].self, forKey: .actualFirewallSubnetRoutes)
        var actualFirewallSubnetRoutesDecoded0:[FMSClientTypes.Route]? = nil
        if let actualFirewallSubnetRoutesContainer = actualFirewallSubnetRoutesContainer {
            actualFirewallSubnetRoutesDecoded0 = [FMSClientTypes.Route]()
            for structure0 in actualFirewallSubnetRoutesContainer {
                if let structure0 = structure0 {
                    actualFirewallSubnetRoutesDecoded0?.append(structure0)
                }
            }
        }
        actualFirewallSubnetRoutes = actualFirewallSubnetRoutesDecoded0
        let internetGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .internetGatewayId)
        internetGatewayId = internetGatewayIdDecoded
        let currentInternetGatewayRouteTableDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentInternetGatewayRouteTable)
        currentInternetGatewayRouteTable = currentInternetGatewayRouteTableDecoded
        let expectedInternetGatewayRoutesContainer = try containerValues.decodeIfPresent([FMSClientTypes.ExpectedRoute?].self, forKey: .expectedInternetGatewayRoutes)
        var expectedInternetGatewayRoutesDecoded0:[FMSClientTypes.ExpectedRoute]? = nil
        if let expectedInternetGatewayRoutesContainer = expectedInternetGatewayRoutesContainer {
            expectedInternetGatewayRoutesDecoded0 = [FMSClientTypes.ExpectedRoute]()
            for structure0 in expectedInternetGatewayRoutesContainer {
                if let structure0 = structure0 {
                    expectedInternetGatewayRoutesDecoded0?.append(structure0)
                }
            }
        }
        expectedInternetGatewayRoutes = expectedInternetGatewayRoutesDecoded0
        let actualInternetGatewayRoutesContainer = try containerValues.decodeIfPresent([FMSClientTypes.Route?].self, forKey: .actualInternetGatewayRoutes)
        var actualInternetGatewayRoutesDecoded0:[FMSClientTypes.Route]? = nil
        if let actualInternetGatewayRoutesContainer = actualInternetGatewayRoutesContainer {
            actualInternetGatewayRoutesDecoded0 = [FMSClientTypes.Route]()
            for structure0 in actualInternetGatewayRoutesContainer {
                if let structure0 = structure0 {
                    actualInternetGatewayRoutesDecoded0?.append(structure0)
                }
            }
        }
        actualInternetGatewayRoutes = actualInternetGatewayRoutesDecoded0
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension FMSClientTypes {
    /// Violation detail for the subnet for which internet traffic that hasn't been inspected.
    public struct NetworkFirewallInternetTrafficNotInspectedViolation: Swift.Equatable {
        /// The actual firewall subnet routes.
        public var actualFirewallSubnetRoutes: [FMSClientTypes.Route]?
        /// The actual internet gateway routes.
        public var actualInternetGatewayRoutes: [FMSClientTypes.Route]?
        /// Information about the subnet route table for the current firewall.
        public var currentFirewallSubnetRouteTable: Swift.String?
        /// The current route table for the internet gateway.
        public var currentInternetGatewayRouteTable: Swift.String?
        /// The expected endpoint for the current firewall.
        public var expectedFirewallEndpoint: Swift.String?
        /// The firewall subnet routes that are expected.
        public var expectedFirewallSubnetRoutes: [FMSClientTypes.ExpectedRoute]?
        /// The internet gateway routes that are expected.
        public var expectedInternetGatewayRoutes: [FMSClientTypes.ExpectedRoute]?
        /// The firewall subnet ID.
        public var firewallSubnetId: Swift.String?
        /// The internet gateway ID.
        public var internetGatewayId: Swift.String?
        /// Information about whether the route table is used in another Availability Zone.
        public var isRouteTableUsedInDifferentAZ: Swift.Bool
        /// Information about the route table ID.
        public var routeTableId: Swift.String?
        /// The subnet Availability Zone.
        public var subnetAvailabilityZone: Swift.String?
        /// The subnet ID.
        public var subnetId: Swift.String?
        /// The route or routes that are in violation.
        public var violatingRoutes: [FMSClientTypes.Route]?
        /// Information about the VPC ID.
        public var vpcId: Swift.String?

        public init (
            actualFirewallSubnetRoutes: [FMSClientTypes.Route]? = nil,
            actualInternetGatewayRoutes: [FMSClientTypes.Route]? = nil,
            currentFirewallSubnetRouteTable: Swift.String? = nil,
            currentInternetGatewayRouteTable: Swift.String? = nil,
            expectedFirewallEndpoint: Swift.String? = nil,
            expectedFirewallSubnetRoutes: [FMSClientTypes.ExpectedRoute]? = nil,
            expectedInternetGatewayRoutes: [FMSClientTypes.ExpectedRoute]? = nil,
            firewallSubnetId: Swift.String? = nil,
            internetGatewayId: Swift.String? = nil,
            isRouteTableUsedInDifferentAZ: Swift.Bool = false,
            routeTableId: Swift.String? = nil,
            subnetAvailabilityZone: Swift.String? = nil,
            subnetId: Swift.String? = nil,
            violatingRoutes: [FMSClientTypes.Route]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.actualFirewallSubnetRoutes = actualFirewallSubnetRoutes
            self.actualInternetGatewayRoutes = actualInternetGatewayRoutes
            self.currentFirewallSubnetRouteTable = currentFirewallSubnetRouteTable
            self.currentInternetGatewayRouteTable = currentInternetGatewayRouteTable
            self.expectedFirewallEndpoint = expectedFirewallEndpoint
            self.expectedFirewallSubnetRoutes = expectedFirewallSubnetRoutes
            self.expectedInternetGatewayRoutes = expectedInternetGatewayRoutes
            self.firewallSubnetId = firewallSubnetId
            self.internetGatewayId = internetGatewayId
            self.isRouteTableUsedInDifferentAZ = isRouteTableUsedInDifferentAZ
            self.routeTableId = routeTableId
            self.subnetAvailabilityZone = subnetAvailabilityZone
            self.subnetId = subnetId
            self.violatingRoutes = violatingRoutes
            self.vpcId = vpcId
        }
    }

}

extension FMSClientTypes.NetworkFirewallInvalidRouteConfigurationViolation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actualFirewallEndpoint = "ActualFirewallEndpoint"
        case actualFirewallSubnetId = "ActualFirewallSubnetId"
        case actualFirewallSubnetRoutes = "ActualFirewallSubnetRoutes"
        case actualInternetGatewayRoutes = "ActualInternetGatewayRoutes"
        case affectedSubnets = "AffectedSubnets"
        case currentFirewallSubnetRouteTable = "CurrentFirewallSubnetRouteTable"
        case currentInternetGatewayRouteTable = "CurrentInternetGatewayRouteTable"
        case expectedFirewallEndpoint = "ExpectedFirewallEndpoint"
        case expectedFirewallSubnetId = "ExpectedFirewallSubnetId"
        case expectedFirewallSubnetRoutes = "ExpectedFirewallSubnetRoutes"
        case expectedInternetGatewayRoutes = "ExpectedInternetGatewayRoutes"
        case internetGatewayId = "InternetGatewayId"
        case isRouteTableUsedInDifferentAZ = "IsRouteTableUsedInDifferentAZ"
        case routeTableId = "RouteTableId"
        case violatingRoute = "ViolatingRoute"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actualFirewallEndpoint = self.actualFirewallEndpoint {
            try encodeContainer.encode(actualFirewallEndpoint, forKey: .actualFirewallEndpoint)
        }
        if let actualFirewallSubnetId = self.actualFirewallSubnetId {
            try encodeContainer.encode(actualFirewallSubnetId, forKey: .actualFirewallSubnetId)
        }
        if let actualFirewallSubnetRoutes = actualFirewallSubnetRoutes {
            var actualFirewallSubnetRoutesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actualFirewallSubnetRoutes)
            for route0 in actualFirewallSubnetRoutes {
                try actualFirewallSubnetRoutesContainer.encode(route0)
            }
        }
        if let actualInternetGatewayRoutes = actualInternetGatewayRoutes {
            var actualInternetGatewayRoutesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actualInternetGatewayRoutes)
            for route0 in actualInternetGatewayRoutes {
                try actualInternetGatewayRoutesContainer.encode(route0)
            }
        }
        if let affectedSubnets = affectedSubnets {
            var affectedSubnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .affectedSubnets)
            for resourceid0 in affectedSubnets {
                try affectedSubnetsContainer.encode(resourceid0)
            }
        }
        if let currentFirewallSubnetRouteTable = self.currentFirewallSubnetRouteTable {
            try encodeContainer.encode(currentFirewallSubnetRouteTable, forKey: .currentFirewallSubnetRouteTable)
        }
        if let currentInternetGatewayRouteTable = self.currentInternetGatewayRouteTable {
            try encodeContainer.encode(currentInternetGatewayRouteTable, forKey: .currentInternetGatewayRouteTable)
        }
        if let expectedFirewallEndpoint = self.expectedFirewallEndpoint {
            try encodeContainer.encode(expectedFirewallEndpoint, forKey: .expectedFirewallEndpoint)
        }
        if let expectedFirewallSubnetId = self.expectedFirewallSubnetId {
            try encodeContainer.encode(expectedFirewallSubnetId, forKey: .expectedFirewallSubnetId)
        }
        if let expectedFirewallSubnetRoutes = expectedFirewallSubnetRoutes {
            var expectedFirewallSubnetRoutesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .expectedFirewallSubnetRoutes)
            for expectedroute0 in expectedFirewallSubnetRoutes {
                try expectedFirewallSubnetRoutesContainer.encode(expectedroute0)
            }
        }
        if let expectedInternetGatewayRoutes = expectedInternetGatewayRoutes {
            var expectedInternetGatewayRoutesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .expectedInternetGatewayRoutes)
            for expectedroute0 in expectedInternetGatewayRoutes {
                try expectedInternetGatewayRoutesContainer.encode(expectedroute0)
            }
        }
        if let internetGatewayId = self.internetGatewayId {
            try encodeContainer.encode(internetGatewayId, forKey: .internetGatewayId)
        }
        if isRouteTableUsedInDifferentAZ != false {
            try encodeContainer.encode(isRouteTableUsedInDifferentAZ, forKey: .isRouteTableUsedInDifferentAZ)
        }
        if let routeTableId = self.routeTableId {
            try encodeContainer.encode(routeTableId, forKey: .routeTableId)
        }
        if let violatingRoute = self.violatingRoute {
            try encodeContainer.encode(violatingRoute, forKey: .violatingRoute)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let affectedSubnetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .affectedSubnets)
        var affectedSubnetsDecoded0:[Swift.String]? = nil
        if let affectedSubnetsContainer = affectedSubnetsContainer {
            affectedSubnetsDecoded0 = [Swift.String]()
            for string0 in affectedSubnetsContainer {
                if let string0 = string0 {
                    affectedSubnetsDecoded0?.append(string0)
                }
            }
        }
        affectedSubnets = affectedSubnetsDecoded0
        let routeTableIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeTableId)
        routeTableId = routeTableIdDecoded
        let isRouteTableUsedInDifferentAZDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isRouteTableUsedInDifferentAZ) ?? false
        isRouteTableUsedInDifferentAZ = isRouteTableUsedInDifferentAZDecoded
        let violatingRouteDecoded = try containerValues.decodeIfPresent(FMSClientTypes.Route.self, forKey: .violatingRoute)
        violatingRoute = violatingRouteDecoded
        let currentFirewallSubnetRouteTableDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentFirewallSubnetRouteTable)
        currentFirewallSubnetRouteTable = currentFirewallSubnetRouteTableDecoded
        let expectedFirewallEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expectedFirewallEndpoint)
        expectedFirewallEndpoint = expectedFirewallEndpointDecoded
        let actualFirewallEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actualFirewallEndpoint)
        actualFirewallEndpoint = actualFirewallEndpointDecoded
        let expectedFirewallSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expectedFirewallSubnetId)
        expectedFirewallSubnetId = expectedFirewallSubnetIdDecoded
        let actualFirewallSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actualFirewallSubnetId)
        actualFirewallSubnetId = actualFirewallSubnetIdDecoded
        let expectedFirewallSubnetRoutesContainer = try containerValues.decodeIfPresent([FMSClientTypes.ExpectedRoute?].self, forKey: .expectedFirewallSubnetRoutes)
        var expectedFirewallSubnetRoutesDecoded0:[FMSClientTypes.ExpectedRoute]? = nil
        if let expectedFirewallSubnetRoutesContainer = expectedFirewallSubnetRoutesContainer {
            expectedFirewallSubnetRoutesDecoded0 = [FMSClientTypes.ExpectedRoute]()
            for structure0 in expectedFirewallSubnetRoutesContainer {
                if let structure0 = structure0 {
                    expectedFirewallSubnetRoutesDecoded0?.append(structure0)
                }
            }
        }
        expectedFirewallSubnetRoutes = expectedFirewallSubnetRoutesDecoded0
        let actualFirewallSubnetRoutesContainer = try containerValues.decodeIfPresent([FMSClientTypes.Route?].self, forKey: .actualFirewallSubnetRoutes)
        var actualFirewallSubnetRoutesDecoded0:[FMSClientTypes.Route]? = nil
        if let actualFirewallSubnetRoutesContainer = actualFirewallSubnetRoutesContainer {
            actualFirewallSubnetRoutesDecoded0 = [FMSClientTypes.Route]()
            for structure0 in actualFirewallSubnetRoutesContainer {
                if let structure0 = structure0 {
                    actualFirewallSubnetRoutesDecoded0?.append(structure0)
                }
            }
        }
        actualFirewallSubnetRoutes = actualFirewallSubnetRoutesDecoded0
        let internetGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .internetGatewayId)
        internetGatewayId = internetGatewayIdDecoded
        let currentInternetGatewayRouteTableDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentInternetGatewayRouteTable)
        currentInternetGatewayRouteTable = currentInternetGatewayRouteTableDecoded
        let expectedInternetGatewayRoutesContainer = try containerValues.decodeIfPresent([FMSClientTypes.ExpectedRoute?].self, forKey: .expectedInternetGatewayRoutes)
        var expectedInternetGatewayRoutesDecoded0:[FMSClientTypes.ExpectedRoute]? = nil
        if let expectedInternetGatewayRoutesContainer = expectedInternetGatewayRoutesContainer {
            expectedInternetGatewayRoutesDecoded0 = [FMSClientTypes.ExpectedRoute]()
            for structure0 in expectedInternetGatewayRoutesContainer {
                if let structure0 = structure0 {
                    expectedInternetGatewayRoutesDecoded0?.append(structure0)
                }
            }
        }
        expectedInternetGatewayRoutes = expectedInternetGatewayRoutesDecoded0
        let actualInternetGatewayRoutesContainer = try containerValues.decodeIfPresent([FMSClientTypes.Route?].self, forKey: .actualInternetGatewayRoutes)
        var actualInternetGatewayRoutesDecoded0:[FMSClientTypes.Route]? = nil
        if let actualInternetGatewayRoutesContainer = actualInternetGatewayRoutesContainer {
            actualInternetGatewayRoutesDecoded0 = [FMSClientTypes.Route]()
            for structure0 in actualInternetGatewayRoutesContainer {
                if let structure0 = structure0 {
                    actualInternetGatewayRoutesDecoded0?.append(structure0)
                }
            }
        }
        actualInternetGatewayRoutes = actualInternetGatewayRoutesDecoded0
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension FMSClientTypes {
    /// Violation detail for the improperly configured subnet route. It's possible there is a missing route table route, or a configuration that causes traffic to cross an Availability Zone boundary.
    public struct NetworkFirewallInvalidRouteConfigurationViolation: Swift.Equatable {
        /// The actual firewall endpoint.
        public var actualFirewallEndpoint: Swift.String?
        /// The actual subnet ID for the firewall.
        public var actualFirewallSubnetId: Swift.String?
        /// The actual firewall subnet routes that are expected.
        public var actualFirewallSubnetRoutes: [FMSClientTypes.Route]?
        /// The actual internet gateway routes.
        public var actualInternetGatewayRoutes: [FMSClientTypes.Route]?
        /// The subnets that are affected.
        public var affectedSubnets: [Swift.String]?
        /// The subnet route table for the current firewall.
        public var currentFirewallSubnetRouteTable: Swift.String?
        /// The route table for the current internet gateway.
        public var currentInternetGatewayRouteTable: Swift.String?
        /// The firewall endpoint that's expected.
        public var expectedFirewallEndpoint: Swift.String?
        /// The expected subnet ID for the firewall.
        public var expectedFirewallSubnetId: Swift.String?
        /// The firewall subnet routes that are expected.
        public var expectedFirewallSubnetRoutes: [FMSClientTypes.ExpectedRoute]?
        /// The expected routes for the internet gateway.
        public var expectedInternetGatewayRoutes: [FMSClientTypes.ExpectedRoute]?
        /// The internet gateway ID.
        public var internetGatewayId: Swift.String?
        /// Information about whether the route table is used in another Availability Zone.
        public var isRouteTableUsedInDifferentAZ: Swift.Bool
        /// The route table ID.
        public var routeTableId: Swift.String?
        /// The route that's in violation.
        public var violatingRoute: FMSClientTypes.Route?
        /// Information about the VPC ID.
        public var vpcId: Swift.String?

        public init (
            actualFirewallEndpoint: Swift.String? = nil,
            actualFirewallSubnetId: Swift.String? = nil,
            actualFirewallSubnetRoutes: [FMSClientTypes.Route]? = nil,
            actualInternetGatewayRoutes: [FMSClientTypes.Route]? = nil,
            affectedSubnets: [Swift.String]? = nil,
            currentFirewallSubnetRouteTable: Swift.String? = nil,
            currentInternetGatewayRouteTable: Swift.String? = nil,
            expectedFirewallEndpoint: Swift.String? = nil,
            expectedFirewallSubnetId: Swift.String? = nil,
            expectedFirewallSubnetRoutes: [FMSClientTypes.ExpectedRoute]? = nil,
            expectedInternetGatewayRoutes: [FMSClientTypes.ExpectedRoute]? = nil,
            internetGatewayId: Swift.String? = nil,
            isRouteTableUsedInDifferentAZ: Swift.Bool = false,
            routeTableId: Swift.String? = nil,
            violatingRoute: FMSClientTypes.Route? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.actualFirewallEndpoint = actualFirewallEndpoint
            self.actualFirewallSubnetId = actualFirewallSubnetId
            self.actualFirewallSubnetRoutes = actualFirewallSubnetRoutes
            self.actualInternetGatewayRoutes = actualInternetGatewayRoutes
            self.affectedSubnets = affectedSubnets
            self.currentFirewallSubnetRouteTable = currentFirewallSubnetRouteTable
            self.currentInternetGatewayRouteTable = currentInternetGatewayRouteTable
            self.expectedFirewallEndpoint = expectedFirewallEndpoint
            self.expectedFirewallSubnetId = expectedFirewallSubnetId
            self.expectedFirewallSubnetRoutes = expectedFirewallSubnetRoutes
            self.expectedInternetGatewayRoutes = expectedInternetGatewayRoutes
            self.internetGatewayId = internetGatewayId
            self.isRouteTableUsedInDifferentAZ = isRouteTableUsedInDifferentAZ
            self.routeTableId = routeTableId
            self.violatingRoute = violatingRoute
            self.vpcId = vpcId
        }
    }

}

extension FMSClientTypes.NetworkFirewallMissingExpectedRTViolation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "AvailabilityZone"
        case currentRouteTable = "CurrentRouteTable"
        case expectedRouteTable = "ExpectedRouteTable"
        case vpc = "VPC"
        case violationTarget = "ViolationTarget"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let currentRouteTable = self.currentRouteTable {
            try encodeContainer.encode(currentRouteTable, forKey: .currentRouteTable)
        }
        if let expectedRouteTable = self.expectedRouteTable {
            try encodeContainer.encode(expectedRouteTable, forKey: .expectedRouteTable)
        }
        if let vpc = self.vpc {
            try encodeContainer.encode(vpc, forKey: .vpc)
        }
        if let violationTarget = self.violationTarget {
            try encodeContainer.encode(violationTarget, forKey: .violationTarget)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .violationTarget)
        violationTarget = violationTargetDecoded
        let vpcDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpc)
        vpc = vpcDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let currentRouteTableDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentRouteTable)
        currentRouteTable = currentRouteTableDecoded
        let expectedRouteTableDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expectedRouteTable)
        expectedRouteTable = expectedRouteTableDecoded
    }
}

extension FMSClientTypes {
    /// Violation detail for Network Firewall for a subnet that's not associated to the expected Firewall Manager managed route table.
    public struct NetworkFirewallMissingExpectedRTViolation: Swift.Equatable {
        /// The Availability Zone of a violating subnet.
        public var availabilityZone: Swift.String?
        /// The resource ID of the current route table that's associated with the subnet, if one is available.
        public var currentRouteTable: Swift.String?
        /// The resource ID of the route table that should be associated with the subnet.
        public var expectedRouteTable: Swift.String?
        /// The ID of the Network Firewall or VPC resource that's in violation.
        public var violationTarget: Swift.String?
        /// The resource ID of the VPC associated with a violating subnet.
        public var vpc: Swift.String?

        public init (
            availabilityZone: Swift.String? = nil,
            currentRouteTable: Swift.String? = nil,
            expectedRouteTable: Swift.String? = nil,
            violationTarget: Swift.String? = nil,
            vpc: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.currentRouteTable = currentRouteTable
            self.expectedRouteTable = expectedRouteTable
            self.violationTarget = violationTarget
            self.vpc = vpc
        }
    }

}

extension FMSClientTypes.NetworkFirewallMissingExpectedRoutesViolation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expectedRoutes = "ExpectedRoutes"
        case violationTarget = "ViolationTarget"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expectedRoutes = expectedRoutes {
            var expectedRoutesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .expectedRoutes)
            for expectedroute0 in expectedRoutes {
                try expectedRoutesContainer.encode(expectedroute0)
            }
        }
        if let violationTarget = self.violationTarget {
            try encodeContainer.encode(violationTarget, forKey: .violationTarget)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .violationTarget)
        violationTarget = violationTargetDecoded
        let expectedRoutesContainer = try containerValues.decodeIfPresent([FMSClientTypes.ExpectedRoute?].self, forKey: .expectedRoutes)
        var expectedRoutesDecoded0:[FMSClientTypes.ExpectedRoute]? = nil
        if let expectedRoutesContainer = expectedRoutesContainer {
            expectedRoutesDecoded0 = [FMSClientTypes.ExpectedRoute]()
            for structure0 in expectedRoutesContainer {
                if let structure0 = structure0 {
                    expectedRoutesDecoded0?.append(structure0)
                }
            }
        }
        expectedRoutes = expectedRoutesDecoded0
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension FMSClientTypes {
    /// Violation detail for an expected route missing in Network Firewall.
    public struct NetworkFirewallMissingExpectedRoutesViolation: Swift.Equatable {
        /// The expected routes.
        public var expectedRoutes: [FMSClientTypes.ExpectedRoute]?
        /// The target of the violation.
        public var violationTarget: Swift.String?
        /// Information about the VPC ID.
        public var vpcId: Swift.String?

        public init (
            expectedRoutes: [FMSClientTypes.ExpectedRoute]? = nil,
            violationTarget: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.expectedRoutes = expectedRoutes
            self.violationTarget = violationTarget
            self.vpcId = vpcId
        }
    }

}

extension FMSClientTypes.NetworkFirewallMissingFirewallViolation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "AvailabilityZone"
        case targetViolationReason = "TargetViolationReason"
        case vpc = "VPC"
        case violationTarget = "ViolationTarget"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let targetViolationReason = self.targetViolationReason {
            try encodeContainer.encode(targetViolationReason, forKey: .targetViolationReason)
        }
        if let vpc = self.vpc {
            try encodeContainer.encode(vpc, forKey: .vpc)
        }
        if let violationTarget = self.violationTarget {
            try encodeContainer.encode(violationTarget, forKey: .violationTarget)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .violationTarget)
        violationTarget = violationTargetDecoded
        let vpcDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpc)
        vpc = vpcDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let targetViolationReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetViolationReason)
        targetViolationReason = targetViolationReasonDecoded
    }
}

extension FMSClientTypes {
    /// Violation detail for Network Firewall for a subnet that doesn't have a Firewall Manager managed firewall in its VPC.
    public struct NetworkFirewallMissingFirewallViolation: Swift.Equatable {
        /// The Availability Zone of a violating subnet.
        public var availabilityZone: Swift.String?
        /// The reason the resource has this violation, if one is available.
        public var targetViolationReason: Swift.String?
        /// The ID of the Network Firewall or VPC resource that's in violation.
        public var violationTarget: Swift.String?
        /// The resource ID of the VPC associated with a violating subnet.
        public var vpc: Swift.String?

        public init (
            availabilityZone: Swift.String? = nil,
            targetViolationReason: Swift.String? = nil,
            violationTarget: Swift.String? = nil,
            vpc: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.targetViolationReason = targetViolationReason
            self.violationTarget = violationTarget
            self.vpc = vpc
        }
    }

}

extension FMSClientTypes.NetworkFirewallMissingSubnetViolation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "AvailabilityZone"
        case targetViolationReason = "TargetViolationReason"
        case vpc = "VPC"
        case violationTarget = "ViolationTarget"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let targetViolationReason = self.targetViolationReason {
            try encodeContainer.encode(targetViolationReason, forKey: .targetViolationReason)
        }
        if let vpc = self.vpc {
            try encodeContainer.encode(vpc, forKey: .vpc)
        }
        if let violationTarget = self.violationTarget {
            try encodeContainer.encode(violationTarget, forKey: .violationTarget)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .violationTarget)
        violationTarget = violationTargetDecoded
        let vpcDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpc)
        vpc = vpcDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let targetViolationReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetViolationReason)
        targetViolationReason = targetViolationReasonDecoded
    }
}

extension FMSClientTypes {
    /// Violation detail for Network Firewall for an Availability Zone that's missing the expected Firewall Manager managed subnet.
    public struct NetworkFirewallMissingSubnetViolation: Swift.Equatable {
        /// The Availability Zone of a violating subnet.
        public var availabilityZone: Swift.String?
        /// The reason the resource has this violation, if one is available.
        public var targetViolationReason: Swift.String?
        /// The ID of the Network Firewall or VPC resource that's in violation.
        public var violationTarget: Swift.String?
        /// The resource ID of the VPC associated with a violating subnet.
        public var vpc: Swift.String?

        public init (
            availabilityZone: Swift.String? = nil,
            targetViolationReason: Swift.String? = nil,
            violationTarget: Swift.String? = nil,
            vpc: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.targetViolationReason = targetViolationReason
            self.violationTarget = violationTarget
            self.vpc = vpc
        }
    }

}

extension FMSClientTypes {
    public enum NetworkFirewallOverrideAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dropToAlert
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkFirewallOverrideAction] {
            return [
                .dropToAlert,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dropToAlert: return "DROP_TO_ALERT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NetworkFirewallOverrideAction(rawValue: rawValue) ?? NetworkFirewallOverrideAction.sdkUnknown(rawValue)
        }
    }
}

extension FMSClientTypes.NetworkFirewallPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallDeploymentModel = "FirewallDeploymentModel"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallDeploymentModel = self.firewallDeploymentModel {
            try encodeContainer.encode(firewallDeploymentModel.rawValue, forKey: .firewallDeploymentModel)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallDeploymentModelDecoded = try containerValues.decodeIfPresent(FMSClientTypes.FirewallDeploymentModel.self, forKey: .firewallDeploymentModel)
        firewallDeploymentModel = firewallDeploymentModelDecoded
    }
}

extension FMSClientTypes {
    /// Configures the firewall policy deployment model of Network Firewall. For information about Network Firewall deployment models, see [Network Firewall example architectures with routing](https://docs.aws.amazon.com/network-firewall/latest/developerguide/architectures.html) in the Network Firewall Developer Guide.
    public struct NetworkFirewallPolicy: Swift.Equatable {
        /// Defines the deployment model to use for the firewall policy. To use a distributed model, set [PolicyOption](https://docs.aws.amazon.com/fms/2018-01-01/APIReference/API_PolicyOption.html) to NULL.
        public var firewallDeploymentModel: FMSClientTypes.FirewallDeploymentModel?

        public init (
            firewallDeploymentModel: FMSClientTypes.FirewallDeploymentModel? = nil
        )
        {
            self.firewallDeploymentModel = firewallDeploymentModel
        }
    }

}

extension FMSClientTypes.NetworkFirewallPolicyDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statefulDefaultActions = "StatefulDefaultActions"
        case statefulEngineOptions = "StatefulEngineOptions"
        case statefulRuleGroups = "StatefulRuleGroups"
        case statelessCustomActions = "StatelessCustomActions"
        case statelessDefaultActions = "StatelessDefaultActions"
        case statelessFragmentDefaultActions = "StatelessFragmentDefaultActions"
        case statelessRuleGroups = "StatelessRuleGroups"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statefulDefaultActions = statefulDefaultActions {
            var statefulDefaultActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statefulDefaultActions)
            for networkfirewallaction0 in statefulDefaultActions {
                try statefulDefaultActionsContainer.encode(networkfirewallaction0)
            }
        }
        if let statefulEngineOptions = self.statefulEngineOptions {
            try encodeContainer.encode(statefulEngineOptions, forKey: .statefulEngineOptions)
        }
        if let statefulRuleGroups = statefulRuleGroups {
            var statefulRuleGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statefulRuleGroups)
            for statefulrulegroup0 in statefulRuleGroups {
                try statefulRuleGroupsContainer.encode(statefulrulegroup0)
            }
        }
        if let statelessCustomActions = statelessCustomActions {
            var statelessCustomActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statelessCustomActions)
            for networkfirewallaction0 in statelessCustomActions {
                try statelessCustomActionsContainer.encode(networkfirewallaction0)
            }
        }
        if let statelessDefaultActions = statelessDefaultActions {
            var statelessDefaultActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statelessDefaultActions)
            for networkfirewallaction0 in statelessDefaultActions {
                try statelessDefaultActionsContainer.encode(networkfirewallaction0)
            }
        }
        if let statelessFragmentDefaultActions = statelessFragmentDefaultActions {
            var statelessFragmentDefaultActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statelessFragmentDefaultActions)
            for networkfirewallaction0 in statelessFragmentDefaultActions {
                try statelessFragmentDefaultActionsContainer.encode(networkfirewallaction0)
            }
        }
        if let statelessRuleGroups = statelessRuleGroups {
            var statelessRuleGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statelessRuleGroups)
            for statelessrulegroup0 in statelessRuleGroups {
                try statelessRuleGroupsContainer.encode(statelessrulegroup0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statelessRuleGroupsContainer = try containerValues.decodeIfPresent([FMSClientTypes.StatelessRuleGroup?].self, forKey: .statelessRuleGroups)
        var statelessRuleGroupsDecoded0:[FMSClientTypes.StatelessRuleGroup]? = nil
        if let statelessRuleGroupsContainer = statelessRuleGroupsContainer {
            statelessRuleGroupsDecoded0 = [FMSClientTypes.StatelessRuleGroup]()
            for structure0 in statelessRuleGroupsContainer {
                if let structure0 = structure0 {
                    statelessRuleGroupsDecoded0?.append(structure0)
                }
            }
        }
        statelessRuleGroups = statelessRuleGroupsDecoded0
        let statelessDefaultActionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .statelessDefaultActions)
        var statelessDefaultActionsDecoded0:[Swift.String]? = nil
        if let statelessDefaultActionsContainer = statelessDefaultActionsContainer {
            statelessDefaultActionsDecoded0 = [Swift.String]()
            for string0 in statelessDefaultActionsContainer {
                if let string0 = string0 {
                    statelessDefaultActionsDecoded0?.append(string0)
                }
            }
        }
        statelessDefaultActions = statelessDefaultActionsDecoded0
        let statelessFragmentDefaultActionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .statelessFragmentDefaultActions)
        var statelessFragmentDefaultActionsDecoded0:[Swift.String]? = nil
        if let statelessFragmentDefaultActionsContainer = statelessFragmentDefaultActionsContainer {
            statelessFragmentDefaultActionsDecoded0 = [Swift.String]()
            for string0 in statelessFragmentDefaultActionsContainer {
                if let string0 = string0 {
                    statelessFragmentDefaultActionsDecoded0?.append(string0)
                }
            }
        }
        statelessFragmentDefaultActions = statelessFragmentDefaultActionsDecoded0
        let statelessCustomActionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .statelessCustomActions)
        var statelessCustomActionsDecoded0:[Swift.String]? = nil
        if let statelessCustomActionsContainer = statelessCustomActionsContainer {
            statelessCustomActionsDecoded0 = [Swift.String]()
            for string0 in statelessCustomActionsContainer {
                if let string0 = string0 {
                    statelessCustomActionsDecoded0?.append(string0)
                }
            }
        }
        statelessCustomActions = statelessCustomActionsDecoded0
        let statefulRuleGroupsContainer = try containerValues.decodeIfPresent([FMSClientTypes.StatefulRuleGroup?].self, forKey: .statefulRuleGroups)
        var statefulRuleGroupsDecoded0:[FMSClientTypes.StatefulRuleGroup]? = nil
        if let statefulRuleGroupsContainer = statefulRuleGroupsContainer {
            statefulRuleGroupsDecoded0 = [FMSClientTypes.StatefulRuleGroup]()
            for structure0 in statefulRuleGroupsContainer {
                if let structure0 = structure0 {
                    statefulRuleGroupsDecoded0?.append(structure0)
                }
            }
        }
        statefulRuleGroups = statefulRuleGroupsDecoded0
        let statefulDefaultActionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .statefulDefaultActions)
        var statefulDefaultActionsDecoded0:[Swift.String]? = nil
        if let statefulDefaultActionsContainer = statefulDefaultActionsContainer {
            statefulDefaultActionsDecoded0 = [Swift.String]()
            for string0 in statefulDefaultActionsContainer {
                if let string0 = string0 {
                    statefulDefaultActionsDecoded0?.append(string0)
                }
            }
        }
        statefulDefaultActions = statefulDefaultActionsDecoded0
        let statefulEngineOptionsDecoded = try containerValues.decodeIfPresent(FMSClientTypes.StatefulEngineOptions.self, forKey: .statefulEngineOptions)
        statefulEngineOptions = statefulEngineOptionsDecoded
    }
}

extension FMSClientTypes {
    /// The definition of the Network Firewall firewall policy.
    public struct NetworkFirewallPolicyDescription: Swift.Equatable {
        /// The default actions to take on a packet that doesn't match any stateful rules. The stateful default action is optional, and is only valid when using the strict rule order. Valid values of the stateful default action:
        ///
        /// * aws:drop_strict
        ///
        /// * aws:drop_established
        ///
        /// * aws:alert_strict
        ///
        /// * aws:alert_established
        public var statefulDefaultActions: [Swift.String]?
        /// Additional options governing how Network Firewall handles stateful rules. The stateful rule groups that you use in your policy must have stateful rule options settings that are compatible with these settings.
        public var statefulEngineOptions: FMSClientTypes.StatefulEngineOptions?
        /// The stateful rule groups that are used in the Network Firewall firewall policy.
        public var statefulRuleGroups: [FMSClientTypes.StatefulRuleGroup]?
        /// Names of custom actions that are available for use in the stateless default actions settings.
        public var statelessCustomActions: [Swift.String]?
        /// The actions to take on packets that don't match any of the stateless rule groups.
        public var statelessDefaultActions: [Swift.String]?
        /// The actions to take on packet fragments that don't match any of the stateless rule groups.
        public var statelessFragmentDefaultActions: [Swift.String]?
        /// The stateless rule groups that are used in the Network Firewall firewall policy.
        public var statelessRuleGroups: [FMSClientTypes.StatelessRuleGroup]?

        public init (
            statefulDefaultActions: [Swift.String]? = nil,
            statefulEngineOptions: FMSClientTypes.StatefulEngineOptions? = nil,
            statefulRuleGroups: [FMSClientTypes.StatefulRuleGroup]? = nil,
            statelessCustomActions: [Swift.String]? = nil,
            statelessDefaultActions: [Swift.String]? = nil,
            statelessFragmentDefaultActions: [Swift.String]? = nil,
            statelessRuleGroups: [FMSClientTypes.StatelessRuleGroup]? = nil
        )
        {
            self.statefulDefaultActions = statefulDefaultActions
            self.statefulEngineOptions = statefulEngineOptions
            self.statefulRuleGroups = statefulRuleGroups
            self.statelessCustomActions = statelessCustomActions
            self.statelessDefaultActions = statelessDefaultActions
            self.statelessFragmentDefaultActions = statelessFragmentDefaultActions
            self.statelessRuleGroups = statelessRuleGroups
        }
    }

}

extension FMSClientTypes.NetworkFirewallPolicyModifiedViolation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentPolicyDescription = "CurrentPolicyDescription"
        case expectedPolicyDescription = "ExpectedPolicyDescription"
        case violationTarget = "ViolationTarget"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentPolicyDescription = self.currentPolicyDescription {
            try encodeContainer.encode(currentPolicyDescription, forKey: .currentPolicyDescription)
        }
        if let expectedPolicyDescription = self.expectedPolicyDescription {
            try encodeContainer.encode(expectedPolicyDescription, forKey: .expectedPolicyDescription)
        }
        if let violationTarget = self.violationTarget {
            try encodeContainer.encode(violationTarget, forKey: .violationTarget)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .violationTarget)
        violationTarget = violationTargetDecoded
        let currentPolicyDescriptionDecoded = try containerValues.decodeIfPresent(FMSClientTypes.NetworkFirewallPolicyDescription.self, forKey: .currentPolicyDescription)
        currentPolicyDescription = currentPolicyDescriptionDecoded
        let expectedPolicyDescriptionDecoded = try containerValues.decodeIfPresent(FMSClientTypes.NetworkFirewallPolicyDescription.self, forKey: .expectedPolicyDescription)
        expectedPolicyDescription = expectedPolicyDescriptionDecoded
    }
}

extension FMSClientTypes {
    /// Violation detail for Network Firewall for a firewall policy that has a different [NetworkFirewallPolicyDescription] than is required by the Firewall Manager policy.
    public struct NetworkFirewallPolicyModifiedViolation: Swift.Equatable {
        /// The policy that's currently in use in the individual account.
        public var currentPolicyDescription: FMSClientTypes.NetworkFirewallPolicyDescription?
        /// The policy that should be in use in the individual account in order to be compliant.
        public var expectedPolicyDescription: FMSClientTypes.NetworkFirewallPolicyDescription?
        /// The ID of the Network Firewall or VPC resource that's in violation.
        public var violationTarget: Swift.String?

        public init (
            currentPolicyDescription: FMSClientTypes.NetworkFirewallPolicyDescription? = nil,
            expectedPolicyDescription: FMSClientTypes.NetworkFirewallPolicyDescription? = nil,
            violationTarget: Swift.String? = nil
        )
        {
            self.currentPolicyDescription = currentPolicyDescription
            self.expectedPolicyDescription = expectedPolicyDescription
            self.violationTarget = violationTarget
        }
    }

}

extension FMSClientTypes.NetworkFirewallStatefulRuleGroupOverride: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(FMSClientTypes.NetworkFirewallOverrideAction.self, forKey: .action)
        action = actionDecoded
    }
}

extension FMSClientTypes {
    /// The setting that allows the policy owner to change the behavior of the rule group within a policy.
    public struct NetworkFirewallStatefulRuleGroupOverride: Swift.Equatable {
        /// The action that changes the rule group from DROP to ALERT. This only applies to managed rule groups.
        public var action: FMSClientTypes.NetworkFirewallOverrideAction?

        public init (
            action: FMSClientTypes.NetworkFirewallOverrideAction? = nil
        )
        {
            self.action = action
        }
    }

}

extension FMSClientTypes.NetworkFirewallUnexpectedFirewallRoutesViolation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallEndpoint = "FirewallEndpoint"
        case firewallSubnetId = "FirewallSubnetId"
        case routeTableId = "RouteTableId"
        case violatingRoutes = "ViolatingRoutes"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallEndpoint = self.firewallEndpoint {
            try encodeContainer.encode(firewallEndpoint, forKey: .firewallEndpoint)
        }
        if let firewallSubnetId = self.firewallSubnetId {
            try encodeContainer.encode(firewallSubnetId, forKey: .firewallSubnetId)
        }
        if let routeTableId = self.routeTableId {
            try encodeContainer.encode(routeTableId, forKey: .routeTableId)
        }
        if let violatingRoutes = violatingRoutes {
            var violatingRoutesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .violatingRoutes)
            for route0 in violatingRoutes {
                try violatingRoutesContainer.encode(route0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallSubnetId)
        firewallSubnetId = firewallSubnetIdDecoded
        let violatingRoutesContainer = try containerValues.decodeIfPresent([FMSClientTypes.Route?].self, forKey: .violatingRoutes)
        var violatingRoutesDecoded0:[FMSClientTypes.Route]? = nil
        if let violatingRoutesContainer = violatingRoutesContainer {
            violatingRoutesDecoded0 = [FMSClientTypes.Route]()
            for structure0 in violatingRoutesContainer {
                if let structure0 = structure0 {
                    violatingRoutesDecoded0?.append(structure0)
                }
            }
        }
        violatingRoutes = violatingRoutesDecoded0
        let routeTableIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeTableId)
        routeTableId = routeTableIdDecoded
        let firewallEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallEndpoint)
        firewallEndpoint = firewallEndpointDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension FMSClientTypes {
    /// Violation detail for an unexpected route that's present in a route table.
    public struct NetworkFirewallUnexpectedFirewallRoutesViolation: Swift.Equatable {
        /// The endpoint of the firewall.
        public var firewallEndpoint: Swift.String?
        /// The subnet ID for the firewall.
        public var firewallSubnetId: Swift.String?
        /// The ID of the route table.
        public var routeTableId: Swift.String?
        /// The routes that are in violation.
        public var violatingRoutes: [FMSClientTypes.Route]?
        /// Information about the VPC ID.
        public var vpcId: Swift.String?

        public init (
            firewallEndpoint: Swift.String? = nil,
            firewallSubnetId: Swift.String? = nil,
            routeTableId: Swift.String? = nil,
            violatingRoutes: [FMSClientTypes.Route]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.firewallEndpoint = firewallEndpoint
            self.firewallSubnetId = firewallSubnetId
            self.routeTableId = routeTableId
            self.violatingRoutes = violatingRoutes
            self.vpcId = vpcId
        }
    }

}

extension FMSClientTypes.NetworkFirewallUnexpectedGatewayRoutesViolation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayId = "GatewayId"
        case routeTableId = "RouteTableId"
        case violatingRoutes = "ViolatingRoutes"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayId = self.gatewayId {
            try encodeContainer.encode(gatewayId, forKey: .gatewayId)
        }
        if let routeTableId = self.routeTableId {
            try encodeContainer.encode(routeTableId, forKey: .routeTableId)
        }
        if let violatingRoutes = violatingRoutes {
            var violatingRoutesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .violatingRoutes)
            for route0 in violatingRoutes {
                try violatingRoutesContainer.encode(route0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayId)
        gatewayId = gatewayIdDecoded
        let violatingRoutesContainer = try containerValues.decodeIfPresent([FMSClientTypes.Route?].self, forKey: .violatingRoutes)
        var violatingRoutesDecoded0:[FMSClientTypes.Route]? = nil
        if let violatingRoutesContainer = violatingRoutesContainer {
            violatingRoutesDecoded0 = [FMSClientTypes.Route]()
            for structure0 in violatingRoutesContainer {
                if let structure0 = structure0 {
                    violatingRoutesDecoded0?.append(structure0)
                }
            }
        }
        violatingRoutes = violatingRoutesDecoded0
        let routeTableIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeTableId)
        routeTableId = routeTableIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension FMSClientTypes {
    /// Violation detail for an unexpected gateway route that’s present in a route table.
    public struct NetworkFirewallUnexpectedGatewayRoutesViolation: Swift.Equatable {
        /// Information about the gateway ID.
        public var gatewayId: Swift.String?
        /// Information about the route table.
        public var routeTableId: Swift.String?
        /// The routes that are in violation.
        public var violatingRoutes: [FMSClientTypes.Route]?
        /// Information about the VPC ID.
        public var vpcId: Swift.String?

        public init (
            gatewayId: Swift.String? = nil,
            routeTableId: Swift.String? = nil,
            violatingRoutes: [FMSClientTypes.Route]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.gatewayId = gatewayId
            self.routeTableId = routeTableId
            self.violatingRoutes = violatingRoutes
            self.vpcId = vpcId
        }
    }

}

extension FMSClientTypes.PartialMatch: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reference = "Reference"
        case targetViolationReasons = "TargetViolationReasons"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reference = self.reference {
            try encodeContainer.encode(reference, forKey: .reference)
        }
        if let targetViolationReasons = targetViolationReasons {
            var targetViolationReasonsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetViolationReasons)
            for targetviolationreason0 in targetViolationReasons {
                try targetViolationReasonsContainer.encode(targetviolationreason0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let referenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reference)
        reference = referenceDecoded
        let targetViolationReasonsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetViolationReasons)
        var targetViolationReasonsDecoded0:[Swift.String]? = nil
        if let targetViolationReasonsContainer = targetViolationReasonsContainer {
            targetViolationReasonsDecoded0 = [Swift.String]()
            for string0 in targetViolationReasonsContainer {
                if let string0 = string0 {
                    targetViolationReasonsDecoded0?.append(string0)
                }
            }
        }
        targetViolationReasons = targetViolationReasonsDecoded0
    }
}

extension FMSClientTypes {
    /// The reference rule that partially matches the ViolationTarget rule and violation reason.
    public struct PartialMatch: Swift.Equatable {
        /// The reference rule from the primary security group of the Firewall Manager policy.
        public var reference: Swift.String?
        /// The violation reason.
        public var targetViolationReasons: [Swift.String]?

        public init (
            reference: Swift.String? = nil,
            targetViolationReasons: [Swift.String]? = nil
        )
        {
            self.reference = reference
            self.targetViolationReasons = targetViolationReasons
        }
    }

}

extension FMSClientTypes.Policy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteUnusedFMManagedResources = "DeleteUnusedFMManagedResources"
        case excludeMap = "ExcludeMap"
        case excludeResourceTags = "ExcludeResourceTags"
        case includeMap = "IncludeMap"
        case policyDescription = "PolicyDescription"
        case policyId = "PolicyId"
        case policyName = "PolicyName"
        case policyUpdateToken = "PolicyUpdateToken"
        case remediationEnabled = "RemediationEnabled"
        case resourceSetIds = "ResourceSetIds"
        case resourceTags = "ResourceTags"
        case resourceType = "ResourceType"
        case resourceTypeList = "ResourceTypeList"
        case securityServicePolicyData = "SecurityServicePolicyData"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if deleteUnusedFMManagedResources != false {
            try encodeContainer.encode(deleteUnusedFMManagedResources, forKey: .deleteUnusedFMManagedResources)
        }
        if let excludeMap = excludeMap {
            var excludeMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .excludeMap)
            for (dictKey0, customerPolicyScopeMap0) in excludeMap {
                var customerPolicyScopeMap0Container = excludeMapContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for customerpolicyscopeid1 in customerPolicyScopeMap0 {
                    try customerPolicyScopeMap0Container.encode(customerpolicyscopeid1)
                }
            }
        }
        if excludeResourceTags != false {
            try encodeContainer.encode(excludeResourceTags, forKey: .excludeResourceTags)
        }
        if let includeMap = includeMap {
            var includeMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .includeMap)
            for (dictKey0, customerPolicyScopeMap0) in includeMap {
                var customerPolicyScopeMap0Container = includeMapContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for customerpolicyscopeid1 in customerPolicyScopeMap0 {
                    try customerPolicyScopeMap0Container.encode(customerpolicyscopeid1)
                }
            }
        }
        if let policyDescription = self.policyDescription {
            try encodeContainer.encode(policyDescription, forKey: .policyDescription)
        }
        if let policyId = self.policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let policyName = self.policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
        if let policyUpdateToken = self.policyUpdateToken {
            try encodeContainer.encode(policyUpdateToken, forKey: .policyUpdateToken)
        }
        if remediationEnabled != false {
            try encodeContainer.encode(remediationEnabled, forKey: .remediationEnabled)
        }
        if let resourceSetIds = resourceSetIds {
            var resourceSetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceSetIds)
            for base62id0 in resourceSetIds {
                try resourceSetIdsContainer.encode(base62id0)
            }
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTags)
            for resourcetag0 in resourceTags {
                try resourceTagsContainer.encode(resourcetag0)
            }
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let resourceTypeList = resourceTypeList {
            var resourceTypeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTypeList)
            for resourcetype0 in resourceTypeList {
                try resourceTypeListContainer.encode(resourcetype0)
            }
        }
        if let securityServicePolicyData = self.securityServicePolicyData {
            try encodeContainer.encode(securityServicePolicyData, forKey: .securityServicePolicyData)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyUpdateTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyUpdateToken)
        policyUpdateToken = policyUpdateTokenDecoded
        let securityServicePolicyDataDecoded = try containerValues.decodeIfPresent(FMSClientTypes.SecurityServicePolicyData.self, forKey: .securityServicePolicyData)
        securityServicePolicyData = securityServicePolicyDataDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceTypeListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceTypeList)
        var resourceTypeListDecoded0:[Swift.String]? = nil
        if let resourceTypeListContainer = resourceTypeListContainer {
            resourceTypeListDecoded0 = [Swift.String]()
            for string0 in resourceTypeListContainer {
                if let string0 = string0 {
                    resourceTypeListDecoded0?.append(string0)
                }
            }
        }
        resourceTypeList = resourceTypeListDecoded0
        let resourceTagsContainer = try containerValues.decodeIfPresent([FMSClientTypes.ResourceTag?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[FMSClientTypes.ResourceTag]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [FMSClientTypes.ResourceTag]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let excludeResourceTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .excludeResourceTags) ?? false
        excludeResourceTags = excludeResourceTagsDecoded
        let remediationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .remediationEnabled) ?? false
        remediationEnabled = remediationEnabledDecoded
        let deleteUnusedFMManagedResourcesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleteUnusedFMManagedResources) ?? false
        deleteUnusedFMManagedResources = deleteUnusedFMManagedResourcesDecoded
        let includeMapContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .includeMap)
        var includeMapDecoded0: [Swift.String:[Swift.String]]? = nil
        if let includeMapContainer = includeMapContainer {
            includeMapDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, customerpolicyscopeidlist0) in includeMapContainer {
                var customerpolicyscopeidlist0Decoded0: [Swift.String]? = nil
                if let customerpolicyscopeidlist0 = customerpolicyscopeidlist0 {
                    customerpolicyscopeidlist0Decoded0 = [Swift.String]()
                    for string1 in customerpolicyscopeidlist0 {
                        if let string1 = string1 {
                            customerpolicyscopeidlist0Decoded0?.append(string1)
                        }
                    }
                }
                includeMapDecoded0?[key0] = customerpolicyscopeidlist0Decoded0
            }
        }
        includeMap = includeMapDecoded0
        let excludeMapContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .excludeMap)
        var excludeMapDecoded0: [Swift.String:[Swift.String]]? = nil
        if let excludeMapContainer = excludeMapContainer {
            excludeMapDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, customerpolicyscopeidlist0) in excludeMapContainer {
                var customerpolicyscopeidlist0Decoded0: [Swift.String]? = nil
                if let customerpolicyscopeidlist0 = customerpolicyscopeidlist0 {
                    customerpolicyscopeidlist0Decoded0 = [Swift.String]()
                    for string1 in customerpolicyscopeidlist0 {
                        if let string1 = string1 {
                            customerpolicyscopeidlist0Decoded0?.append(string1)
                        }
                    }
                }
                excludeMapDecoded0?[key0] = customerpolicyscopeidlist0Decoded0
            }
        }
        excludeMap = excludeMapDecoded0
        let resourceSetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceSetIds)
        var resourceSetIdsDecoded0:[Swift.String]? = nil
        if let resourceSetIdsContainer = resourceSetIdsContainer {
            resourceSetIdsDecoded0 = [Swift.String]()
            for string0 in resourceSetIdsContainer {
                if let string0 = string0 {
                    resourceSetIdsDecoded0?.append(string0)
                }
            }
        }
        resourceSetIds = resourceSetIdsDecoded0
        let policyDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDescription)
        policyDescription = policyDescriptionDecoded
    }
}

extension FMSClientTypes {
    /// An Firewall Manager policy.
    public struct Policy: Swift.Equatable {
        /// Indicates whether Firewall Manager should automatically remove protections from resources that leave the policy scope and clean up resources that Firewall Manager is managing for accounts when those accounts leave policy scope. For example, Firewall Manager will disassociate a Firewall Manager managed web ACL from a protected customer resource when the customer resource leaves policy scope. By default, Firewall Manager doesn't remove protections or delete Firewall Manager managed resources. This option is not available for Shield Advanced or WAF Classic policies.
        public var deleteUnusedFMManagedResources: Swift.Bool
        /// Specifies the Amazon Web Services account IDs and Organizations organizational units (OUs) to exclude from the policy. Specifying an OU is the equivalent of specifying all accounts in the OU and in any of its child OUs, including any child OUs and accounts that are added at a later time. You can specify inclusions or exclusions, but not both. If you specify an IncludeMap, Firewall Manager applies the policy to all accounts specified by the IncludeMap, and does not evaluate any ExcludeMap specifications. If you do not specify an IncludeMap, then Firewall Manager applies the policy to all accounts except for those specified by the ExcludeMap. You can specify account IDs, OUs, or a combination:
        ///
        /// * Specify account IDs by setting the key to ACCOUNT. For example, the following is a valid map: {“ACCOUNT” : [“accountID1”, “accountID2”]}.
        ///
        /// * Specify OUs by setting the key to ORG_UNIT. For example, the following is a valid map: {“ORG_UNIT” : [“ouid111”, “ouid112”]}.
        ///
        /// * Specify accounts and OUs together in a single map, separated with a comma. For example, the following is a valid map: {“ACCOUNT” : [“accountID1”, “accountID2”], “ORG_UNIT” : [“ouid111”, “ouid112”]}.
        public var excludeMap: [Swift.String:[Swift.String]]?
        /// If set to True, resources with the tags that are specified in the ResourceTag array are not in scope of the policy. If set to False, and the ResourceTag array is not null, only resources with the specified tags are in scope of the policy.
        /// This member is required.
        public var excludeResourceTags: Swift.Bool
        /// Specifies the Amazon Web Services account IDs and Organizations organizational units (OUs) to include in the policy. Specifying an OU is the equivalent of specifying all accounts in the OU and in any of its child OUs, including any child OUs and accounts that are added at a later time. You can specify inclusions or exclusions, but not both. If you specify an IncludeMap, Firewall Manager applies the policy to all accounts specified by the IncludeMap, and does not evaluate any ExcludeMap specifications. If you do not specify an IncludeMap, then Firewall Manager applies the policy to all accounts except for those specified by the ExcludeMap. You can specify account IDs, OUs, or a combination:
        ///
        /// * Specify account IDs by setting the key to ACCOUNT. For example, the following is a valid map: {“ACCOUNT” : [“accountID1”, “accountID2”]}.
        ///
        /// * Specify OUs by setting the key to ORG_UNIT. For example, the following is a valid map: {“ORG_UNIT” : [“ouid111”, “ouid112”]}.
        ///
        /// * Specify accounts and OUs together in a single map, separated with a comma. For example, the following is a valid map: {“ACCOUNT” : [“accountID1”, “accountID2”], “ORG_UNIT” : [“ouid111”, “ouid112”]}.
        public var includeMap: [Swift.String:[Swift.String]]?
        /// The definition of the Network Firewall firewall policy.
        public var policyDescription: Swift.String?
        /// The ID of the Firewall Manager policy.
        public var policyId: Swift.String?
        /// The name of the Firewall Manager policy.
        /// This member is required.
        public var policyName: Swift.String?
        /// A unique identifier for each update to the policy. When issuing a PutPolicy request, the PolicyUpdateToken in the request must match the PolicyUpdateToken of the current policy version. To get the PolicyUpdateToken of the current policy version, use a GetPolicy request.
        public var policyUpdateToken: Swift.String?
        /// Indicates if the policy should be automatically applied to new resources.
        /// This member is required.
        public var remediationEnabled: Swift.Bool
        /// The unique identifiers of the resource sets used by the policy.
        public var resourceSetIds: [Swift.String]?
        /// An array of ResourceTag objects.
        public var resourceTags: [FMSClientTypes.ResourceTag]?
        /// The type of resource protected by or in scope of the policy. This is in the format shown in the [Amazon Web Services Resource Types Reference](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html). To apply this policy to multiple resource types, specify a resource type of ResourceTypeList and then specify the resource types in a ResourceTypeList. For WAF and Shield Advanced, resource types include AWS::ElasticLoadBalancingV2::LoadBalancer, AWS::ElasticLoadBalancing::LoadBalancer, AWS::EC2::EIP, and AWS::CloudFront::Distribution. For a security group common policy, valid values are AWS::EC2::NetworkInterface and AWS::EC2::Instance. For a security group content audit policy, valid values are AWS::EC2::SecurityGroup, AWS::EC2::NetworkInterface, and AWS::EC2::Instance. For a security group usage audit policy, the value is AWS::EC2::SecurityGroup. For an Network Firewall policy or DNS Firewall policy, the value is AWS::EC2::VPC.
        /// This member is required.
        public var resourceType: Swift.String?
        /// An array of ResourceType objects. Use this only to specify multiple resource types. To specify a single resource type, use ResourceType.
        public var resourceTypeList: [Swift.String]?
        /// Details about the security service that is being used to protect the resources.
        /// This member is required.
        public var securityServicePolicyData: FMSClientTypes.SecurityServicePolicyData?

        public init (
            deleteUnusedFMManagedResources: Swift.Bool = false,
            excludeMap: [Swift.String:[Swift.String]]? = nil,
            excludeResourceTags: Swift.Bool = false,
            includeMap: [Swift.String:[Swift.String]]? = nil,
            policyDescription: Swift.String? = nil,
            policyId: Swift.String? = nil,
            policyName: Swift.String? = nil,
            policyUpdateToken: Swift.String? = nil,
            remediationEnabled: Swift.Bool = false,
            resourceSetIds: [Swift.String]? = nil,
            resourceTags: [FMSClientTypes.ResourceTag]? = nil,
            resourceType: Swift.String? = nil,
            resourceTypeList: [Swift.String]? = nil,
            securityServicePolicyData: FMSClientTypes.SecurityServicePolicyData? = nil
        )
        {
            self.deleteUnusedFMManagedResources = deleteUnusedFMManagedResources
            self.excludeMap = excludeMap
            self.excludeResourceTags = excludeResourceTags
            self.includeMap = includeMap
            self.policyDescription = policyDescription
            self.policyId = policyId
            self.policyName = policyName
            self.policyUpdateToken = policyUpdateToken
            self.remediationEnabled = remediationEnabled
            self.resourceSetIds = resourceSetIds
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.resourceTypeList = resourceTypeList
            self.securityServicePolicyData = securityServicePolicyData
        }
    }

}

extension FMSClientTypes.PolicyComplianceDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluationLimitExceeded = "EvaluationLimitExceeded"
        case expiredAt = "ExpiredAt"
        case issueInfoMap = "IssueInfoMap"
        case memberAccount = "MemberAccount"
        case policyId = "PolicyId"
        case policyOwner = "PolicyOwner"
        case violators = "Violators"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if evaluationLimitExceeded != false {
            try encodeContainer.encode(evaluationLimitExceeded, forKey: .evaluationLimitExceeded)
        }
        if let expiredAt = self.expiredAt {
            try encodeContainer.encodeTimestamp(expiredAt, format: .epochSeconds, forKey: .expiredAt)
        }
        if let issueInfoMap = issueInfoMap {
            var issueInfoMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .issueInfoMap)
            for (dictKey0, issueInfoMap0) in issueInfoMap {
                try issueInfoMapContainer.encode(issueInfoMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let memberAccount = self.memberAccount {
            try encodeContainer.encode(memberAccount, forKey: .memberAccount)
        }
        if let policyId = self.policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let policyOwner = self.policyOwner {
            try encodeContainer.encode(policyOwner, forKey: .policyOwner)
        }
        if let violators = violators {
            var violatorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .violators)
            for complianceviolator0 in violators {
                try violatorsContainer.encode(complianceviolator0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyOwner)
        policyOwner = policyOwnerDecoded
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let memberAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberAccount)
        memberAccount = memberAccountDecoded
        let violatorsContainer = try containerValues.decodeIfPresent([FMSClientTypes.ComplianceViolator?].self, forKey: .violators)
        var violatorsDecoded0:[FMSClientTypes.ComplianceViolator]? = nil
        if let violatorsContainer = violatorsContainer {
            violatorsDecoded0 = [FMSClientTypes.ComplianceViolator]()
            for structure0 in violatorsContainer {
                if let structure0 = structure0 {
                    violatorsDecoded0?.append(structure0)
                }
            }
        }
        violators = violatorsDecoded0
        let evaluationLimitExceededDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .evaluationLimitExceeded) ?? false
        evaluationLimitExceeded = evaluationLimitExceededDecoded
        let expiredAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expiredAt)
        expiredAt = expiredAtDecoded
        let issueInfoMapContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .issueInfoMap)
        var issueInfoMapDecoded0: [Swift.String:Swift.String]? = nil
        if let issueInfoMapContainer = issueInfoMapContainer {
            issueInfoMapDecoded0 = [Swift.String:Swift.String]()
            for (key0, detailedinfo0) in issueInfoMapContainer {
                if let detailedinfo0 = detailedinfo0 {
                    issueInfoMapDecoded0?[key0] = detailedinfo0
                }
            }
        }
        issueInfoMap = issueInfoMapDecoded0
    }
}

extension FMSClientTypes {
    /// Describes the noncompliant resources in a member account for a specific Firewall Manager policy. A maximum of 100 entries are displayed. If more than 100 resources are noncompliant, EvaluationLimitExceeded is set to True.
    public struct PolicyComplianceDetail: Swift.Equatable {
        /// Indicates if over 100 resources are noncompliant with the Firewall Manager policy.
        public var evaluationLimitExceeded: Swift.Bool
        /// A timestamp that indicates when the returned information should be considered out of date.
        public var expiredAt: ClientRuntime.Date?
        /// Details about problems with dependent services, such as WAF or Config, and the error message received that indicates the problem with the service.
        public var issueInfoMap: [Swift.String:Swift.String]?
        /// The Amazon Web Services account ID.
        public var memberAccount: Swift.String?
        /// The ID of the Firewall Manager policy.
        public var policyId: Swift.String?
        /// The Amazon Web Services account that created the Firewall Manager policy.
        public var policyOwner: Swift.String?
        /// An array of resources that aren't protected by the WAF or Shield Advanced policy or that aren't in compliance with the security group policy.
        public var violators: [FMSClientTypes.ComplianceViolator]?

        public init (
            evaluationLimitExceeded: Swift.Bool = false,
            expiredAt: ClientRuntime.Date? = nil,
            issueInfoMap: [Swift.String:Swift.String]? = nil,
            memberAccount: Swift.String? = nil,
            policyId: Swift.String? = nil,
            policyOwner: Swift.String? = nil,
            violators: [FMSClientTypes.ComplianceViolator]? = nil
        )
        {
            self.evaluationLimitExceeded = evaluationLimitExceeded
            self.expiredAt = expiredAt
            self.issueInfoMap = issueInfoMap
            self.memberAccount = memberAccount
            self.policyId = policyId
            self.policyOwner = policyOwner
            self.violators = violators
        }
    }

}

extension FMSClientTypes.PolicyComplianceStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluationResults = "EvaluationResults"
        case issueInfoMap = "IssueInfoMap"
        case lastUpdated = "LastUpdated"
        case memberAccount = "MemberAccount"
        case policyId = "PolicyId"
        case policyName = "PolicyName"
        case policyOwner = "PolicyOwner"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evaluationResults = evaluationResults {
            var evaluationResultsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .evaluationResults)
            for evaluationresult0 in evaluationResults {
                try evaluationResultsContainer.encode(evaluationresult0)
            }
        }
        if let issueInfoMap = issueInfoMap {
            var issueInfoMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .issueInfoMap)
            for (dictKey0, issueInfoMap0) in issueInfoMap {
                try issueInfoMapContainer.encode(issueInfoMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .epochSeconds, forKey: .lastUpdated)
        }
        if let memberAccount = self.memberAccount {
            try encodeContainer.encode(memberAccount, forKey: .memberAccount)
        }
        if let policyId = self.policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let policyName = self.policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
        if let policyOwner = self.policyOwner {
            try encodeContainer.encode(policyOwner, forKey: .policyOwner)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyOwner)
        policyOwner = policyOwnerDecoded
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let memberAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberAccount)
        memberAccount = memberAccountDecoded
        let evaluationResultsContainer = try containerValues.decodeIfPresent([FMSClientTypes.EvaluationResult?].self, forKey: .evaluationResults)
        var evaluationResultsDecoded0:[FMSClientTypes.EvaluationResult]? = nil
        if let evaluationResultsContainer = evaluationResultsContainer {
            evaluationResultsDecoded0 = [FMSClientTypes.EvaluationResult]()
            for structure0 in evaluationResultsContainer {
                if let structure0 = structure0 {
                    evaluationResultsDecoded0?.append(structure0)
                }
            }
        }
        evaluationResults = evaluationResultsDecoded0
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
        let issueInfoMapContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .issueInfoMap)
        var issueInfoMapDecoded0: [Swift.String:Swift.String]? = nil
        if let issueInfoMapContainer = issueInfoMapContainer {
            issueInfoMapDecoded0 = [Swift.String:Swift.String]()
            for (key0, detailedinfo0) in issueInfoMapContainer {
                if let detailedinfo0 = detailedinfo0 {
                    issueInfoMapDecoded0?[key0] = detailedinfo0
                }
            }
        }
        issueInfoMap = issueInfoMapDecoded0
    }
}

extension FMSClientTypes {
    /// Indicates whether the account is compliant with the specified policy. An account is considered noncompliant if it includes resources that are not protected by the policy, for WAF and Shield Advanced policies, or that are noncompliant with the policy, for security group policies.
    public struct PolicyComplianceStatus: Swift.Equatable {
        /// An array of EvaluationResult objects.
        public var evaluationResults: [FMSClientTypes.EvaluationResult]?
        /// Details about problems with dependent services, such as WAF or Config, and the error message received that indicates the problem with the service.
        public var issueInfoMap: [Swift.String:Swift.String]?
        /// Timestamp of the last update to the EvaluationResult objects.
        public var lastUpdated: ClientRuntime.Date?
        /// The member account ID.
        public var memberAccount: Swift.String?
        /// The ID of the Firewall Manager policy.
        public var policyId: Swift.String?
        /// The name of the Firewall Manager policy.
        public var policyName: Swift.String?
        /// The Amazon Web Services account that created the Firewall Manager policy.
        public var policyOwner: Swift.String?

        public init (
            evaluationResults: [FMSClientTypes.EvaluationResult]? = nil,
            issueInfoMap: [Swift.String:Swift.String]? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            memberAccount: Swift.String? = nil,
            policyId: Swift.String? = nil,
            policyName: Swift.String? = nil,
            policyOwner: Swift.String? = nil
        )
        {
            self.evaluationResults = evaluationResults
            self.issueInfoMap = issueInfoMap
            self.lastUpdated = lastUpdated
            self.memberAccount = memberAccount
            self.policyId = policyId
            self.policyName = policyName
            self.policyOwner = policyOwner
        }
    }

}

extension FMSClientTypes {
    public enum PolicyComplianceStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case compliant
        case noncompliant
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicyComplianceStatusType] {
            return [
                .compliant,
                .noncompliant,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .compliant: return "COMPLIANT"
            case .noncompliant: return "NON_COMPLIANT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PolicyComplianceStatusType(rawValue: rawValue) ?? PolicyComplianceStatusType.sdkUnknown(rawValue)
        }
    }
}

extension FMSClientTypes.PolicyOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkFirewallPolicy = "NetworkFirewallPolicy"
        case thirdPartyFirewallPolicy = "ThirdPartyFirewallPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let networkFirewallPolicy = self.networkFirewallPolicy {
            try encodeContainer.encode(networkFirewallPolicy, forKey: .networkFirewallPolicy)
        }
        if let thirdPartyFirewallPolicy = self.thirdPartyFirewallPolicy {
            try encodeContainer.encode(thirdPartyFirewallPolicy, forKey: .thirdPartyFirewallPolicy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkFirewallPolicyDecoded = try containerValues.decodeIfPresent(FMSClientTypes.NetworkFirewallPolicy.self, forKey: .networkFirewallPolicy)
        networkFirewallPolicy = networkFirewallPolicyDecoded
        let thirdPartyFirewallPolicyDecoded = try containerValues.decodeIfPresent(FMSClientTypes.ThirdPartyFirewallPolicy.self, forKey: .thirdPartyFirewallPolicy)
        thirdPartyFirewallPolicy = thirdPartyFirewallPolicyDecoded
    }
}

extension FMSClientTypes {
    /// Contains the Network Firewall firewall policy options to configure the policy's deployment model and third-party firewall policy settings.
    public struct PolicyOption: Swift.Equatable {
        /// Defines the deployment model to use for the firewall policy.
        public var networkFirewallPolicy: FMSClientTypes.NetworkFirewallPolicy?
        /// Defines the policy options for a third-party firewall policy.
        public var thirdPartyFirewallPolicy: FMSClientTypes.ThirdPartyFirewallPolicy?

        public init (
            networkFirewallPolicy: FMSClientTypes.NetworkFirewallPolicy? = nil,
            thirdPartyFirewallPolicy: FMSClientTypes.ThirdPartyFirewallPolicy? = nil
        )
        {
            self.networkFirewallPolicy = networkFirewallPolicy
            self.thirdPartyFirewallPolicy = thirdPartyFirewallPolicy
        }
    }

}

extension FMSClientTypes.PolicySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteUnusedFMManagedResources = "DeleteUnusedFMManagedResources"
        case policyArn = "PolicyArn"
        case policyId = "PolicyId"
        case policyName = "PolicyName"
        case remediationEnabled = "RemediationEnabled"
        case resourceType = "ResourceType"
        case securityServiceType = "SecurityServiceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if deleteUnusedFMManagedResources != false {
            try encodeContainer.encode(deleteUnusedFMManagedResources, forKey: .deleteUnusedFMManagedResources)
        }
        if let policyArn = self.policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
        if let policyId = self.policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let policyName = self.policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
        if remediationEnabled != false {
            try encodeContainer.encode(remediationEnabled, forKey: .remediationEnabled)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let securityServiceType = self.securityServiceType {
            try encodeContainer.encode(securityServiceType.rawValue, forKey: .securityServiceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let securityServiceTypeDecoded = try containerValues.decodeIfPresent(FMSClientTypes.SecurityServiceType.self, forKey: .securityServiceType)
        securityServiceType = securityServiceTypeDecoded
        let remediationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .remediationEnabled) ?? false
        remediationEnabled = remediationEnabledDecoded
        let deleteUnusedFMManagedResourcesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleteUnusedFMManagedResources) ?? false
        deleteUnusedFMManagedResources = deleteUnusedFMManagedResourcesDecoded
    }
}

extension FMSClientTypes {
    /// Details of the Firewall Manager policy.
    public struct PolicySummary: Swift.Equatable {
        /// Indicates whether Firewall Manager should automatically remove protections from resources that leave the policy scope and clean up resources that Firewall Manager is managing for accounts when those accounts leave policy scope. For example, Firewall Manager will disassociate a Firewall Manager managed web ACL from a protected customer resource when the customer resource leaves policy scope. By default, Firewall Manager doesn't remove protections or delete Firewall Manager managed resources. This option is not available for Shield Advanced or WAF Classic policies.
        public var deleteUnusedFMManagedResources: Swift.Bool
        /// The Amazon Resource Name (ARN) of the specified policy.
        public var policyArn: Swift.String?
        /// The ID of the specified policy.
        public var policyId: Swift.String?
        /// The name of the specified policy.
        public var policyName: Swift.String?
        /// Indicates if the policy should be automatically applied to new resources.
        public var remediationEnabled: Swift.Bool
        /// The type of resource protected by or in scope of the policy. This is in the format shown in the [Amazon Web Services Resource Types Reference](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html). For WAF and Shield Advanced, examples include AWS::ElasticLoadBalancingV2::LoadBalancer and AWS::CloudFront::Distribution. For a security group common policy, valid values are AWS::EC2::NetworkInterface and AWS::EC2::Instance. For a security group content audit policy, valid values are AWS::EC2::SecurityGroup, AWS::EC2::NetworkInterface, and AWS::EC2::Instance. For a security group usage audit policy, the value is AWS::EC2::SecurityGroup. For an Network Firewall policy or DNS Firewall policy, the value is AWS::EC2::VPC.
        public var resourceType: Swift.String?
        /// The service that the policy is using to protect the resources. This specifies the type of policy that is created, either an WAF policy, a Shield Advanced policy, or a security group policy.
        public var securityServiceType: FMSClientTypes.SecurityServiceType?

        public init (
            deleteUnusedFMManagedResources: Swift.Bool = false,
            policyArn: Swift.String? = nil,
            policyId: Swift.String? = nil,
            policyName: Swift.String? = nil,
            remediationEnabled: Swift.Bool = false,
            resourceType: Swift.String? = nil,
            securityServiceType: FMSClientTypes.SecurityServiceType? = nil
        )
        {
            self.deleteUnusedFMManagedResources = deleteUnusedFMManagedResources
            self.policyArn = policyArn
            self.policyId = policyId
            self.policyName = policyName
            self.remediationEnabled = remediationEnabled
            self.resourceType = resourceType
            self.securityServiceType = securityServiceType
        }
    }

}

extension FMSClientTypes.PossibleRemediationAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case isDefaultAction = "IsDefaultAction"
        case orderedRemediationActions = "OrderedRemediationActions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if isDefaultAction != false {
            try encodeContainer.encode(isDefaultAction, forKey: .isDefaultAction)
        }
        if let orderedRemediationActions = orderedRemediationActions {
            var orderedRemediationActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .orderedRemediationActions)
            for remediationactionwithorder0 in orderedRemediationActions {
                try orderedRemediationActionsContainer.encode(remediationactionwithorder0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let orderedRemediationActionsContainer = try containerValues.decodeIfPresent([FMSClientTypes.RemediationActionWithOrder?].self, forKey: .orderedRemediationActions)
        var orderedRemediationActionsDecoded0:[FMSClientTypes.RemediationActionWithOrder]? = nil
        if let orderedRemediationActionsContainer = orderedRemediationActionsContainer {
            orderedRemediationActionsDecoded0 = [FMSClientTypes.RemediationActionWithOrder]()
            for structure0 in orderedRemediationActionsContainer {
                if let structure0 = structure0 {
                    orderedRemediationActionsDecoded0?.append(structure0)
                }
            }
        }
        orderedRemediationActions = orderedRemediationActionsDecoded0
        let isDefaultActionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isDefaultAction) ?? false
        isDefaultAction = isDefaultActionDecoded
    }
}

extension FMSClientTypes {
    /// A list of remediation actions.
    public struct PossibleRemediationAction: Swift.Equatable {
        /// A description of the list of remediation actions.
        public var description: Swift.String?
        /// Information about whether an action is taken by default.
        public var isDefaultAction: Swift.Bool
        /// The ordered list of remediation actions.
        /// This member is required.
        public var orderedRemediationActions: [FMSClientTypes.RemediationActionWithOrder]?

        public init (
            description: Swift.String? = nil,
            isDefaultAction: Swift.Bool = false,
            orderedRemediationActions: [FMSClientTypes.RemediationActionWithOrder]? = nil
        )
        {
            self.description = description
            self.isDefaultAction = isDefaultAction
            self.orderedRemediationActions = orderedRemediationActions
        }
    }

}

extension FMSClientTypes.PossibleRemediationActions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for possibleremediationaction0 in actions {
                try actionsContainer.encode(possibleremediationaction0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let actionsContainer = try containerValues.decodeIfPresent([FMSClientTypes.PossibleRemediationAction?].self, forKey: .actions)
        var actionsDecoded0:[FMSClientTypes.PossibleRemediationAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [FMSClientTypes.PossibleRemediationAction]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
    }
}

extension FMSClientTypes {
    /// A list of possible remediation action lists. Each individual possible remediation action is a list of individual remediation actions.
    public struct PossibleRemediationActions: Swift.Equatable {
        /// Information about the actions.
        public var actions: [FMSClientTypes.PossibleRemediationAction]?
        /// A description of the possible remediation actions list.
        public var description: Swift.String?

        public init (
            actions: [FMSClientTypes.PossibleRemediationAction]? = nil,
            description: Swift.String? = nil
        )
        {
            self.actions = actions
            self.description = description
        }
    }

}

extension FMSClientTypes.ProtocolsListData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case lastUpdateTime = "LastUpdateTime"
        case listId = "ListId"
        case listName = "ListName"
        case listUpdateToken = "ListUpdateToken"
        case previousProtocolsList = "PreviousProtocolsList"
        case protocolsList = "ProtocolsList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let lastUpdateTime = self.lastUpdateTime {
            try encodeContainer.encodeTimestamp(lastUpdateTime, format: .epochSeconds, forKey: .lastUpdateTime)
        }
        if let listId = self.listId {
            try encodeContainer.encode(listId, forKey: .listId)
        }
        if let listName = self.listName {
            try encodeContainer.encode(listName, forKey: .listName)
        }
        if let listUpdateToken = self.listUpdateToken {
            try encodeContainer.encode(listUpdateToken, forKey: .listUpdateToken)
        }
        if let previousProtocolsList = previousProtocolsList {
            var previousProtocolsListContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .previousProtocolsList)
            for (dictKey0, previousProtocolsList0) in previousProtocolsList {
                var previousProtocolsList0Container = previousProtocolsListContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for protocol1 in previousProtocolsList0 {
                    try previousProtocolsList0Container.encode(protocol1)
                }
            }
        }
        if let protocolsList = protocolsList {
            var protocolsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocolsList)
            for protocol0 in protocolsList {
                try protocolsListContainer.encode(protocol0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listId)
        listId = listIdDecoded
        let listNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listName)
        listName = listNameDecoded
        let listUpdateTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listUpdateToken)
        listUpdateToken = listUpdateTokenDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let protocolsListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .protocolsList)
        var protocolsListDecoded0:[Swift.String]? = nil
        if let protocolsListContainer = protocolsListContainer {
            protocolsListDecoded0 = [Swift.String]()
            for string0 in protocolsListContainer {
                if let string0 = string0 {
                    protocolsListDecoded0?.append(string0)
                }
            }
        }
        protocolsList = protocolsListDecoded0
        let previousProtocolsListContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .previousProtocolsList)
        var previousProtocolsListDecoded0: [Swift.String:[Swift.String]]? = nil
        if let previousProtocolsListContainer = previousProtocolsListContainer {
            previousProtocolsListDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, protocolslist0) in previousProtocolsListContainer {
                var protocolslist0Decoded0: [Swift.String]? = nil
                if let protocolslist0 = protocolslist0 {
                    protocolslist0Decoded0 = [Swift.String]()
                    for string1 in protocolslist0 {
                        if let string1 = string1 {
                            protocolslist0Decoded0?.append(string1)
                        }
                    }
                }
                previousProtocolsListDecoded0?[key0] = protocolslist0Decoded0
            }
        }
        previousProtocolsList = previousProtocolsListDecoded0
    }
}

extension FMSClientTypes {
    /// An Firewall Manager protocols list.
    public struct ProtocolsListData: Swift.Equatable {
        /// The time that the Firewall Manager protocols list was created.
        public var createTime: ClientRuntime.Date?
        /// The time that the Firewall Manager protocols list was last updated.
        public var lastUpdateTime: ClientRuntime.Date?
        /// The ID of the Firewall Manager protocols list.
        public var listId: Swift.String?
        /// The name of the Firewall Manager protocols list.
        /// This member is required.
        public var listName: Swift.String?
        /// A unique identifier for each update to the list. When you update the list, the update token must match the token of the current version of the application list. You can retrieve the update token by getting the list.
        public var listUpdateToken: Swift.String?
        /// A map of previous version numbers to their corresponding protocol arrays.
        public var previousProtocolsList: [Swift.String:[Swift.String]]?
        /// An array of protocols in the Firewall Manager protocols list.
        /// This member is required.
        public var protocolsList: [Swift.String]?

        public init (
            createTime: ClientRuntime.Date? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            listId: Swift.String? = nil,
            listName: Swift.String? = nil,
            listUpdateToken: Swift.String? = nil,
            previousProtocolsList: [Swift.String:[Swift.String]]? = nil,
            protocolsList: [Swift.String]? = nil
        )
        {
            self.createTime = createTime
            self.lastUpdateTime = lastUpdateTime
            self.listId = listId
            self.listName = listName
            self.listUpdateToken = listUpdateToken
            self.previousProtocolsList = previousProtocolsList
            self.protocolsList = protocolsList
        }
    }

}

extension FMSClientTypes.ProtocolsListDataSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listArn = "ListArn"
        case listId = "ListId"
        case listName = "ListName"
        case protocolsList = "ProtocolsList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listArn = self.listArn {
            try encodeContainer.encode(listArn, forKey: .listArn)
        }
        if let listId = self.listId {
            try encodeContainer.encode(listId, forKey: .listId)
        }
        if let listName = self.listName {
            try encodeContainer.encode(listName, forKey: .listName)
        }
        if let protocolsList = protocolsList {
            var protocolsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocolsList)
            for protocol0 in protocolsList {
                try protocolsListContainer.encode(protocol0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listArn)
        listArn = listArnDecoded
        let listIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listId)
        listId = listIdDecoded
        let listNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listName)
        listName = listNameDecoded
        let protocolsListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .protocolsList)
        var protocolsListDecoded0:[Swift.String]? = nil
        if let protocolsListContainer = protocolsListContainer {
            protocolsListDecoded0 = [Swift.String]()
            for string0 in protocolsListContainer {
                if let string0 = string0 {
                    protocolsListDecoded0?.append(string0)
                }
            }
        }
        protocolsList = protocolsListDecoded0
    }
}

extension FMSClientTypes {
    /// Details of the Firewall Manager protocols list.
    public struct ProtocolsListDataSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the specified protocols list.
        public var listArn: Swift.String?
        /// The ID of the specified protocols list.
        public var listId: Swift.String?
        /// The name of the specified protocols list.
        public var listName: Swift.String?
        /// An array of protocols in the Firewall Manager protocols list.
        public var protocolsList: [Swift.String]?

        public init (
            listArn: Swift.String? = nil,
            listId: Swift.String? = nil,
            listName: Swift.String? = nil,
            protocolsList: [Swift.String]? = nil
        )
        {
            self.listArn = listArn
            self.listId = listId
            self.listName = listName
            self.protocolsList = protocolsList
        }
    }

}

extension PutAppsListInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appsList = "AppsList"
        case tagList = "TagList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appsList = self.appsList {
            try encodeContainer.encode(appsList, forKey: .appsList)
        }
        if let tagList = tagList {
            var tagListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagList)
            for tag0 in tagList {
                try tagListContainer.encode(tag0)
            }
        }
    }
}

extension PutAppsListInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutAppsListInput: Swift.Equatable {
    /// The details of the Firewall Manager applications list to be created.
    /// This member is required.
    public var appsList: FMSClientTypes.AppsListData?
    /// The tags associated with the resource.
    public var tagList: [FMSClientTypes.Tag]?

    public init (
        appsList: FMSClientTypes.AppsListData? = nil,
        tagList: [FMSClientTypes.Tag]? = nil
    )
    {
        self.appsList = appsList
        self.tagList = tagList
    }
}

struct PutAppsListInputBody: Swift.Equatable {
    let appsList: FMSClientTypes.AppsListData?
    let tagList: [FMSClientTypes.Tag]?
}

extension PutAppsListInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appsList = "AppsList"
        case tagList = "TagList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appsListDecoded = try containerValues.decodeIfPresent(FMSClientTypes.AppsListData.self, forKey: .appsList)
        appsList = appsListDecoded
        let tagListContainer = try containerValues.decodeIfPresent([FMSClientTypes.Tag?].self, forKey: .tagList)
        var tagListDecoded0:[FMSClientTypes.Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [FMSClientTypes.Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension PutAppsListOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutAppsListOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutAppsListOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case invalidOperationException(InvalidOperationException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutAppsListOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutAppsListOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appsList = output.appsList
            self.appsListArn = output.appsListArn
        } else {
            self.appsList = nil
            self.appsListArn = nil
        }
    }
}

public struct PutAppsListOutputResponse: Swift.Equatable {
    /// The details of the Firewall Manager applications list.
    public var appsList: FMSClientTypes.AppsListData?
    /// The Amazon Resource Name (ARN) of the applications list.
    public var appsListArn: Swift.String?

    public init (
        appsList: FMSClientTypes.AppsListData? = nil,
        appsListArn: Swift.String? = nil
    )
    {
        self.appsList = appsList
        self.appsListArn = appsListArn
    }
}

struct PutAppsListOutputResponseBody: Swift.Equatable {
    let appsList: FMSClientTypes.AppsListData?
    let appsListArn: Swift.String?
}

extension PutAppsListOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appsList = "AppsList"
        case appsListArn = "AppsListArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appsListDecoded = try containerValues.decodeIfPresent(FMSClientTypes.AppsListData.self, forKey: .appsList)
        appsList = appsListDecoded
        let appsListArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appsListArn)
        appsListArn = appsListArnDecoded
    }
}

extension PutNotificationChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snsRoleName = "SnsRoleName"
        case snsTopicArn = "SnsTopicArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let snsRoleName = self.snsRoleName {
            try encodeContainer.encode(snsRoleName, forKey: .snsRoleName)
        }
        if let snsTopicArn = self.snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
    }
}

extension PutNotificationChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutNotificationChannelInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the IAM role that allows Amazon SNS to record Firewall Manager activity.
    /// This member is required.
    public var snsRoleName: Swift.String?
    /// The Amazon Resource Name (ARN) of the SNS topic that collects notifications from Firewall Manager.
    /// This member is required.
    public var snsTopicArn: Swift.String?

    public init (
        snsRoleName: Swift.String? = nil,
        snsTopicArn: Swift.String? = nil
    )
    {
        self.snsRoleName = snsRoleName
        self.snsTopicArn = snsTopicArn
    }
}

struct PutNotificationChannelInputBody: Swift.Equatable {
    let snsTopicArn: Swift.String?
    let snsRoleName: Swift.String?
}

extension PutNotificationChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snsRoleName = "SnsRoleName"
        case snsTopicArn = "SnsTopicArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let snsRoleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsRoleName)
        snsRoleName = snsRoleNameDecoded
    }
}

extension PutNotificationChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutNotificationChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutNotificationChannelOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutNotificationChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutNotificationChannelOutputResponse: Swift.Equatable {

    public init () { }
}

extension PutPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
        case tagList = "TagList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let tagList = tagList {
            var tagListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagList)
            for tag0 in tagList {
                try tagListContainer.encode(tag0)
            }
        }
    }
}

extension PutPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutPolicyInput: Swift.Equatable {
    /// The details of the Firewall Manager policy to be created.
    /// This member is required.
    public var policy: FMSClientTypes.Policy?
    /// The tags to add to the Amazon Web Services resource.
    public var tagList: [FMSClientTypes.Tag]?

    public init (
        policy: FMSClientTypes.Policy? = nil,
        tagList: [FMSClientTypes.Tag]? = nil
    )
    {
        self.policy = policy
        self.tagList = tagList
    }
}

struct PutPolicyInputBody: Swift.Equatable {
    let policy: FMSClientTypes.Policy?
    let tagList: [FMSClientTypes.Tag]?
}

extension PutPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
        case tagList = "TagList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(FMSClientTypes.Policy.self, forKey: .policy)
        policy = policyDecoded
        let tagListContainer = try containerValues.decodeIfPresent([FMSClientTypes.Tag?].self, forKey: .tagList)
        var tagListDecoded0:[FMSClientTypes.Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [FMSClientTypes.Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension PutPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTypeException" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutPolicyOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case invalidOperationException(InvalidOperationException)
    case invalidTypeException(InvalidTypeException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
            self.policyArn = output.policyArn
        } else {
            self.policy = nil
            self.policyArn = nil
        }
    }
}

public struct PutPolicyOutputResponse: Swift.Equatable {
    /// The details of the Firewall Manager policy.
    public var policy: FMSClientTypes.Policy?
    /// The Amazon Resource Name (ARN) of the policy.
    public var policyArn: Swift.String?

    public init (
        policy: FMSClientTypes.Policy? = nil,
        policyArn: Swift.String? = nil
    )
    {
        self.policy = policy
        self.policyArn = policyArn
    }
}

struct PutPolicyOutputResponseBody: Swift.Equatable {
    let policy: FMSClientTypes.Policy?
    let policyArn: Swift.String?
}

extension PutPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
        case policyArn = "PolicyArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(FMSClientTypes.Policy.self, forKey: .policy)
        policy = policyDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
    }
}

extension PutProtocolsListInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protocolsList = "ProtocolsList"
        case tagList = "TagList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let protocolsList = self.protocolsList {
            try encodeContainer.encode(protocolsList, forKey: .protocolsList)
        }
        if let tagList = tagList {
            var tagListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagList)
            for tag0 in tagList {
                try tagListContainer.encode(tag0)
            }
        }
    }
}

extension PutProtocolsListInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutProtocolsListInput: Swift.Equatable {
    /// The details of the Firewall Manager protocols list to be created.
    /// This member is required.
    public var protocolsList: FMSClientTypes.ProtocolsListData?
    /// The tags associated with the resource.
    public var tagList: [FMSClientTypes.Tag]?

    public init (
        protocolsList: FMSClientTypes.ProtocolsListData? = nil,
        tagList: [FMSClientTypes.Tag]? = nil
    )
    {
        self.protocolsList = protocolsList
        self.tagList = tagList
    }
}

struct PutProtocolsListInputBody: Swift.Equatable {
    let protocolsList: FMSClientTypes.ProtocolsListData?
    let tagList: [FMSClientTypes.Tag]?
}

extension PutProtocolsListInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protocolsList = "ProtocolsList"
        case tagList = "TagList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protocolsListDecoded = try containerValues.decodeIfPresent(FMSClientTypes.ProtocolsListData.self, forKey: .protocolsList)
        protocolsList = protocolsListDecoded
        let tagListContainer = try containerValues.decodeIfPresent([FMSClientTypes.Tag?].self, forKey: .tagList)
        var tagListDecoded0:[FMSClientTypes.Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [FMSClientTypes.Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension PutProtocolsListOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutProtocolsListOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutProtocolsListOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case invalidOperationException(InvalidOperationException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutProtocolsListOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutProtocolsListOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.protocolsList = output.protocolsList
            self.protocolsListArn = output.protocolsListArn
        } else {
            self.protocolsList = nil
            self.protocolsListArn = nil
        }
    }
}

public struct PutProtocolsListOutputResponse: Swift.Equatable {
    /// The details of the Firewall Manager protocols list.
    public var protocolsList: FMSClientTypes.ProtocolsListData?
    /// The Amazon Resource Name (ARN) of the protocols list.
    public var protocolsListArn: Swift.String?

    public init (
        protocolsList: FMSClientTypes.ProtocolsListData? = nil,
        protocolsListArn: Swift.String? = nil
    )
    {
        self.protocolsList = protocolsList
        self.protocolsListArn = protocolsListArn
    }
}

struct PutProtocolsListOutputResponseBody: Swift.Equatable {
    let protocolsList: FMSClientTypes.ProtocolsListData?
    let protocolsListArn: Swift.String?
}

extension PutProtocolsListOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protocolsList = "ProtocolsList"
        case protocolsListArn = "ProtocolsListArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protocolsListDecoded = try containerValues.decodeIfPresent(FMSClientTypes.ProtocolsListData.self, forKey: .protocolsList)
        protocolsList = protocolsListDecoded
        let protocolsListArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protocolsListArn)
        protocolsListArn = protocolsListArnDecoded
    }
}

extension PutResourceSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceSet = "ResourceSet"
        case tagList = "TagList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceSet = self.resourceSet {
            try encodeContainer.encode(resourceSet, forKey: .resourceSet)
        }
        if let tagList = tagList {
            var tagListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagList)
            for tag0 in tagList {
                try tagListContainer.encode(tag0)
            }
        }
    }
}

extension PutResourceSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutResourceSetInput: Swift.Equatable {
    /// Details about the resource set to be created or updated.>
    /// This member is required.
    public var resourceSet: FMSClientTypes.ResourceSet?
    /// Retrieves the tags associated with the specified resource set. Tags are key:value pairs that you can use to categorize and manage your resources, for purposes like billing. For example, you might set the tag key to "customer" and the value to the customer name or ID. You can specify one or more tags to add to each Amazon Web Services resource, up to 50 tags for a resource.
    public var tagList: [FMSClientTypes.Tag]?

    public init (
        resourceSet: FMSClientTypes.ResourceSet? = nil,
        tagList: [FMSClientTypes.Tag]? = nil
    )
    {
        self.resourceSet = resourceSet
        self.tagList = tagList
    }
}

struct PutResourceSetInputBody: Swift.Equatable {
    let resourceSet: FMSClientTypes.ResourceSet?
    let tagList: [FMSClientTypes.Tag]?
}

extension PutResourceSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceSet = "ResourceSet"
        case tagList = "TagList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceSetDecoded = try containerValues.decodeIfPresent(FMSClientTypes.ResourceSet.self, forKey: .resourceSet)
        resourceSet = resourceSetDecoded
        let tagListContainer = try containerValues.decodeIfPresent([FMSClientTypes.Tag?].self, forKey: .tagList)
        var tagListDecoded0:[FMSClientTypes.Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [FMSClientTypes.Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension PutResourceSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutResourceSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutResourceSetOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case invalidOperationException(InvalidOperationException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutResourceSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutResourceSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourceSet = output.resourceSet
            self.resourceSetArn = output.resourceSetArn
        } else {
            self.resourceSet = nil
            self.resourceSetArn = nil
        }
    }
}

public struct PutResourceSetOutputResponse: Swift.Equatable {
    /// Details about the resource set.
    /// This member is required.
    public var resourceSet: FMSClientTypes.ResourceSet?
    /// The Amazon Resource Name (ARN) of the resource set.
    /// This member is required.
    public var resourceSetArn: Swift.String?

    public init (
        resourceSet: FMSClientTypes.ResourceSet? = nil,
        resourceSetArn: Swift.String? = nil
    )
    {
        self.resourceSet = resourceSet
        self.resourceSetArn = resourceSetArn
    }
}

struct PutResourceSetOutputResponseBody: Swift.Equatable {
    let resourceSet: FMSClientTypes.ResourceSet?
    let resourceSetArn: Swift.String?
}

extension PutResourceSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceSet = "ResourceSet"
        case resourceSetArn = "ResourceSetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceSetDecoded = try containerValues.decodeIfPresent(FMSClientTypes.ResourceSet.self, forKey: .resourceSet)
        resourceSet = resourceSetDecoded
        let resourceSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetArn)
        resourceSetArn = resourceSetArnDecoded
    }
}

extension FMSClientTypes.RemediationAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case ec2AssociateRouteTableAction = "EC2AssociateRouteTableAction"
        case ec2CopyRouteTableAction = "EC2CopyRouteTableAction"
        case ec2CreateRouteAction = "EC2CreateRouteAction"
        case ec2CreateRouteTableAction = "EC2CreateRouteTableAction"
        case ec2DeleteRouteAction = "EC2DeleteRouteAction"
        case ec2ReplaceRouteAction = "EC2ReplaceRouteAction"
        case ec2ReplaceRouteTableAssociationAction = "EC2ReplaceRouteTableAssociationAction"
        case fmsPolicyUpdateFirewallCreationConfigAction = "FMSPolicyUpdateFirewallCreationConfigAction"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let ec2AssociateRouteTableAction = self.ec2AssociateRouteTableAction {
            try encodeContainer.encode(ec2AssociateRouteTableAction, forKey: .ec2AssociateRouteTableAction)
        }
        if let ec2CopyRouteTableAction = self.ec2CopyRouteTableAction {
            try encodeContainer.encode(ec2CopyRouteTableAction, forKey: .ec2CopyRouteTableAction)
        }
        if let ec2CreateRouteAction = self.ec2CreateRouteAction {
            try encodeContainer.encode(ec2CreateRouteAction, forKey: .ec2CreateRouteAction)
        }
        if let ec2CreateRouteTableAction = self.ec2CreateRouteTableAction {
            try encodeContainer.encode(ec2CreateRouteTableAction, forKey: .ec2CreateRouteTableAction)
        }
        if let ec2DeleteRouteAction = self.ec2DeleteRouteAction {
            try encodeContainer.encode(ec2DeleteRouteAction, forKey: .ec2DeleteRouteAction)
        }
        if let ec2ReplaceRouteAction = self.ec2ReplaceRouteAction {
            try encodeContainer.encode(ec2ReplaceRouteAction, forKey: .ec2ReplaceRouteAction)
        }
        if let ec2ReplaceRouteTableAssociationAction = self.ec2ReplaceRouteTableAssociationAction {
            try encodeContainer.encode(ec2ReplaceRouteTableAssociationAction, forKey: .ec2ReplaceRouteTableAssociationAction)
        }
        if let fmsPolicyUpdateFirewallCreationConfigAction = self.fmsPolicyUpdateFirewallCreationConfigAction {
            try encodeContainer.encode(fmsPolicyUpdateFirewallCreationConfigAction, forKey: .fmsPolicyUpdateFirewallCreationConfigAction)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ec2CreateRouteActionDecoded = try containerValues.decodeIfPresent(FMSClientTypes.EC2CreateRouteAction.self, forKey: .ec2CreateRouteAction)
        ec2CreateRouteAction = ec2CreateRouteActionDecoded
        let ec2ReplaceRouteActionDecoded = try containerValues.decodeIfPresent(FMSClientTypes.EC2ReplaceRouteAction.self, forKey: .ec2ReplaceRouteAction)
        ec2ReplaceRouteAction = ec2ReplaceRouteActionDecoded
        let ec2DeleteRouteActionDecoded = try containerValues.decodeIfPresent(FMSClientTypes.EC2DeleteRouteAction.self, forKey: .ec2DeleteRouteAction)
        ec2DeleteRouteAction = ec2DeleteRouteActionDecoded
        let ec2CopyRouteTableActionDecoded = try containerValues.decodeIfPresent(FMSClientTypes.EC2CopyRouteTableAction.self, forKey: .ec2CopyRouteTableAction)
        ec2CopyRouteTableAction = ec2CopyRouteTableActionDecoded
        let ec2ReplaceRouteTableAssociationActionDecoded = try containerValues.decodeIfPresent(FMSClientTypes.EC2ReplaceRouteTableAssociationAction.self, forKey: .ec2ReplaceRouteTableAssociationAction)
        ec2ReplaceRouteTableAssociationAction = ec2ReplaceRouteTableAssociationActionDecoded
        let ec2AssociateRouteTableActionDecoded = try containerValues.decodeIfPresent(FMSClientTypes.EC2AssociateRouteTableAction.self, forKey: .ec2AssociateRouteTableAction)
        ec2AssociateRouteTableAction = ec2AssociateRouteTableActionDecoded
        let ec2CreateRouteTableActionDecoded = try containerValues.decodeIfPresent(FMSClientTypes.EC2CreateRouteTableAction.self, forKey: .ec2CreateRouteTableAction)
        ec2CreateRouteTableAction = ec2CreateRouteTableActionDecoded
        let fmsPolicyUpdateFirewallCreationConfigActionDecoded = try containerValues.decodeIfPresent(FMSClientTypes.FMSPolicyUpdateFirewallCreationConfigAction.self, forKey: .fmsPolicyUpdateFirewallCreationConfigAction)
        fmsPolicyUpdateFirewallCreationConfigAction = fmsPolicyUpdateFirewallCreationConfigActionDecoded
    }
}

extension FMSClientTypes {
    /// Information about an individual action you can take to remediate a violation.
    public struct RemediationAction: Swift.Equatable {
        /// A description of a remediation action.
        public var description: Swift.String?
        /// Information about the AssociateRouteTable action in the Amazon EC2 API.
        public var ec2AssociateRouteTableAction: FMSClientTypes.EC2AssociateRouteTableAction?
        /// Information about the CopyRouteTable action in the Amazon EC2 API.
        public var ec2CopyRouteTableAction: FMSClientTypes.EC2CopyRouteTableAction?
        /// Information about the CreateRoute action in the Amazon EC2 API.
        public var ec2CreateRouteAction: FMSClientTypes.EC2CreateRouteAction?
        /// Information about the CreateRouteTable action in the Amazon EC2 API.
        public var ec2CreateRouteTableAction: FMSClientTypes.EC2CreateRouteTableAction?
        /// Information about the DeleteRoute action in the Amazon EC2 API.
        public var ec2DeleteRouteAction: FMSClientTypes.EC2DeleteRouteAction?
        /// Information about the ReplaceRoute action in the Amazon EC2 API.
        public var ec2ReplaceRouteAction: FMSClientTypes.EC2ReplaceRouteAction?
        /// Information about the ReplaceRouteTableAssociation action in the Amazon EC2 API.
        public var ec2ReplaceRouteTableAssociationAction: FMSClientTypes.EC2ReplaceRouteTableAssociationAction?
        /// The remedial action to take when updating a firewall configuration.
        public var fmsPolicyUpdateFirewallCreationConfigAction: FMSClientTypes.FMSPolicyUpdateFirewallCreationConfigAction?

        public init (
            description: Swift.String? = nil,
            ec2AssociateRouteTableAction: FMSClientTypes.EC2AssociateRouteTableAction? = nil,
            ec2CopyRouteTableAction: FMSClientTypes.EC2CopyRouteTableAction? = nil,
            ec2CreateRouteAction: FMSClientTypes.EC2CreateRouteAction? = nil,
            ec2CreateRouteTableAction: FMSClientTypes.EC2CreateRouteTableAction? = nil,
            ec2DeleteRouteAction: FMSClientTypes.EC2DeleteRouteAction? = nil,
            ec2ReplaceRouteAction: FMSClientTypes.EC2ReplaceRouteAction? = nil,
            ec2ReplaceRouteTableAssociationAction: FMSClientTypes.EC2ReplaceRouteTableAssociationAction? = nil,
            fmsPolicyUpdateFirewallCreationConfigAction: FMSClientTypes.FMSPolicyUpdateFirewallCreationConfigAction? = nil
        )
        {
            self.description = description
            self.ec2AssociateRouteTableAction = ec2AssociateRouteTableAction
            self.ec2CopyRouteTableAction = ec2CopyRouteTableAction
            self.ec2CreateRouteAction = ec2CreateRouteAction
            self.ec2CreateRouteTableAction = ec2CreateRouteTableAction
            self.ec2DeleteRouteAction = ec2DeleteRouteAction
            self.ec2ReplaceRouteAction = ec2ReplaceRouteAction
            self.ec2ReplaceRouteTableAssociationAction = ec2ReplaceRouteTableAssociationAction
            self.fmsPolicyUpdateFirewallCreationConfigAction = fmsPolicyUpdateFirewallCreationConfigAction
        }
    }

}

extension FMSClientTypes {
    public enum RemediationActionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case modify
        case remove
        case sdkUnknown(Swift.String)

        public static var allCases: [RemediationActionType] {
            return [
                .modify,
                .remove,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .modify: return "MODIFY"
            case .remove: return "REMOVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RemediationActionType(rawValue: rawValue) ?? RemediationActionType.sdkUnknown(rawValue)
        }
    }
}

extension FMSClientTypes.RemediationActionWithOrder: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case order = "Order"
        case remediationAction = "RemediationAction"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if order != 0 {
            try encodeContainer.encode(order, forKey: .order)
        }
        if let remediationAction = self.remediationAction {
            try encodeContainer.encode(remediationAction, forKey: .remediationAction)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let remediationActionDecoded = try containerValues.decodeIfPresent(FMSClientTypes.RemediationAction.self, forKey: .remediationAction)
        remediationAction = remediationActionDecoded
        let orderDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .order) ?? 0
        order = orderDecoded
    }
}

extension FMSClientTypes {
    /// An ordered list of actions you can take to remediate a violation.
    public struct RemediationActionWithOrder: Swift.Equatable {
        /// The order of the remediation actions in the list.
        public var order: Swift.Int
        /// Information about an action you can take to remediate a violation.
        public var remediationAction: FMSClientTypes.RemediationAction?

        public init (
            order: Swift.Int = 0,
            remediationAction: FMSClientTypes.RemediationAction? = nil
        )
        {
            self.order = order
            self.remediationAction = remediationAction
        }
    }

}

extension FMSClientTypes.Resource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case uri = "URI"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let uri = self.uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension FMSClientTypes {
    /// Details of a resource that is associated to an Firewall Manager resource set.
    public struct Resource: Swift.Equatable {
        /// The Amazon Web Services account ID that the associated resource belongs to.
        public var accountId: Swift.String?
        /// The resource's universal resource indicator (URI).
        /// This member is required.
        public var uri: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            uri: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.uri = uri
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource was not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FMSClientTypes.ResourceSet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case id = "Id"
        case lastUpdateTime = "LastUpdateTime"
        case name = "Name"
        case resourceTypeList = "ResourceTypeList"
        case updateToken = "UpdateToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateTime = self.lastUpdateTime {
            try encodeContainer.encodeTimestamp(lastUpdateTime, format: .epochSeconds, forKey: .lastUpdateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceTypeList = resourceTypeList {
            var resourceTypeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTypeList)
            for resourcetype0 in resourceTypeList {
                try resourceTypeListContainer.encode(resourcetype0)
            }
        }
        if let updateToken = self.updateToken {
            try encodeContainer.encode(updateToken, forKey: .updateToken)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let updateTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updateToken)
        updateToken = updateTokenDecoded
        let resourceTypeListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceTypeList)
        var resourceTypeListDecoded0:[Swift.String]? = nil
        if let resourceTypeListContainer = resourceTypeListContainer {
            resourceTypeListDecoded0 = [Swift.String]()
            for string0 in resourceTypeListContainer {
                if let string0 = string0 {
                    resourceTypeListDecoded0?.append(string0)
                }
            }
        }
        resourceTypeList = resourceTypeListDecoded0
        let lastUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension FMSClientTypes {
    /// A set of resources to include in a policy.
    public struct ResourceSet: Swift.Equatable {
        /// A description of the resource set.
        public var description: Swift.String?
        /// A unique identifier for the resource set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.
        public var id: Swift.String?
        /// The last time that the resource set was changed.
        public var lastUpdateTime: ClientRuntime.Date?
        /// The descriptive name of the resource set. You can't change the name of a resource set after you create it.
        /// This member is required.
        public var name: Swift.String?
        /// Determines the resources that can be associated to the resource set. Depending on your setting for max results and the number of resource sets, a single call might not return the full list.
        /// This member is required.
        public var resourceTypeList: [Swift.String]?
        /// An optional token that you can use for optimistic locking. Firewall Manager returns a token to your requests that access the resource set. The token marks the state of the resource set resource at the time of the request. Update tokens are not allowed when creating a resource set. After creation, each subsequent update call to the resource set requires the update token. To make an unconditional change to the resource set, omit the token in your update request. Without the token, Firewall Manager performs your updates regardless of whether the resource set has changed since you last retrieved it. To make a conditional change to the resource set, provide the token in your update request. Firewall Manager uses the token to ensure that the resource set hasn't changed since you last retrieved it. If it has changed, the operation fails with an InvalidTokenException. If this happens, retrieve the resource set again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token.
        public var updateToken: Swift.String?

        public init (
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            resourceTypeList: [Swift.String]? = nil,
            updateToken: Swift.String? = nil
        )
        {
            self.description = description
            self.id = id
            self.lastUpdateTime = lastUpdateTime
            self.name = name
            self.resourceTypeList = resourceTypeList
            self.updateToken = updateToken
        }
    }

}

extension FMSClientTypes.ResourceSetSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case id = "Id"
        case lastUpdateTime = "LastUpdateTime"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateTime = self.lastUpdateTime {
            try encodeContainer.encodeTimestamp(lastUpdateTime, format: .epochSeconds, forKey: .lastUpdateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension FMSClientTypes {
    /// Summarizes the resource sets used in a policy.
    public struct ResourceSetSummary: Swift.Equatable {
        /// A description of the resource set.
        public var description: Swift.String?
        /// A unique identifier for the resource set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.
        public var id: Swift.String?
        /// The last time that the resource set was changed.
        public var lastUpdateTime: ClientRuntime.Date?
        /// The descriptive name of the resource set. You can't change the name of a resource set after you create it.
        public var name: Swift.String?

        public init (
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.description = description
            self.id = id
            self.lastUpdateTime = lastUpdateTime
            self.name = name
        }
    }

}

extension FMSClientTypes.ResourceTag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension FMSClientTypes {
    /// The resource tags that Firewall Manager uses to determine if a particular resource should be included or excluded from the Firewall Manager policy. Tags enable you to categorize your Amazon Web Services resources in different ways, for example, by purpose, owner, or environment. Each tag consists of a key and an optional value. Firewall Manager combines the tags with "AND" so that, if you add more than one tag to a policy scope, a resource must have all the specified tags to be included or excluded. For more information, see [Working with Tag Editor](https://docs.aws.amazon.com/awsconsolehelpdocs/latest/gsg/tag-editor.html).
    public struct ResourceTag: Swift.Equatable {
        /// The resource tag key.
        /// This member is required.
        public var key: Swift.String?
        /// The resource tag value.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension FMSClientTypes.ResourceViolation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsEc2InstanceViolation = "AwsEc2InstanceViolation"
        case awsEc2NetworkInterfaceViolation = "AwsEc2NetworkInterfaceViolation"
        case awsVPCSecurityGroupViolation = "AwsVPCSecurityGroupViolation"
        case dnsDuplicateRuleGroupViolation = "DnsDuplicateRuleGroupViolation"
        case dnsRuleGroupLimitExceededViolation = "DnsRuleGroupLimitExceededViolation"
        case dnsRuleGroupPriorityConflictViolation = "DnsRuleGroupPriorityConflictViolation"
        case firewallSubnetIsOutOfScopeViolation = "FirewallSubnetIsOutOfScopeViolation"
        case firewallSubnetMissingVPCEndpointViolation = "FirewallSubnetMissingVPCEndpointViolation"
        case networkFirewallBlackHoleRouteDetectedViolation = "NetworkFirewallBlackHoleRouteDetectedViolation"
        case networkFirewallInternetTrafficNotInspectedViolation = "NetworkFirewallInternetTrafficNotInspectedViolation"
        case networkFirewallInvalidRouteConfigurationViolation = "NetworkFirewallInvalidRouteConfigurationViolation"
        case networkFirewallMissingExpectedRTViolation = "NetworkFirewallMissingExpectedRTViolation"
        case networkFirewallMissingExpectedRoutesViolation = "NetworkFirewallMissingExpectedRoutesViolation"
        case networkFirewallMissingFirewallViolation = "NetworkFirewallMissingFirewallViolation"
        case networkFirewallMissingSubnetViolation = "NetworkFirewallMissingSubnetViolation"
        case networkFirewallPolicyModifiedViolation = "NetworkFirewallPolicyModifiedViolation"
        case networkFirewallUnexpectedFirewallRoutesViolation = "NetworkFirewallUnexpectedFirewallRoutesViolation"
        case networkFirewallUnexpectedGatewayRoutesViolation = "NetworkFirewallUnexpectedGatewayRoutesViolation"
        case possibleRemediationActions = "PossibleRemediationActions"
        case routeHasOutOfScopeEndpointViolation = "RouteHasOutOfScopeEndpointViolation"
        case thirdPartyFirewallMissingExpectedRouteTableViolation = "ThirdPartyFirewallMissingExpectedRouteTableViolation"
        case thirdPartyFirewallMissingFirewallViolation = "ThirdPartyFirewallMissingFirewallViolation"
        case thirdPartyFirewallMissingSubnetViolation = "ThirdPartyFirewallMissingSubnetViolation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsEc2InstanceViolation = self.awsEc2InstanceViolation {
            try encodeContainer.encode(awsEc2InstanceViolation, forKey: .awsEc2InstanceViolation)
        }
        if let awsEc2NetworkInterfaceViolation = self.awsEc2NetworkInterfaceViolation {
            try encodeContainer.encode(awsEc2NetworkInterfaceViolation, forKey: .awsEc2NetworkInterfaceViolation)
        }
        if let awsVPCSecurityGroupViolation = self.awsVPCSecurityGroupViolation {
            try encodeContainer.encode(awsVPCSecurityGroupViolation, forKey: .awsVPCSecurityGroupViolation)
        }
        if let dnsDuplicateRuleGroupViolation = self.dnsDuplicateRuleGroupViolation {
            try encodeContainer.encode(dnsDuplicateRuleGroupViolation, forKey: .dnsDuplicateRuleGroupViolation)
        }
        if let dnsRuleGroupLimitExceededViolation = self.dnsRuleGroupLimitExceededViolation {
            try encodeContainer.encode(dnsRuleGroupLimitExceededViolation, forKey: .dnsRuleGroupLimitExceededViolation)
        }
        if let dnsRuleGroupPriorityConflictViolation = self.dnsRuleGroupPriorityConflictViolation {
            try encodeContainer.encode(dnsRuleGroupPriorityConflictViolation, forKey: .dnsRuleGroupPriorityConflictViolation)
        }
        if let firewallSubnetIsOutOfScopeViolation = self.firewallSubnetIsOutOfScopeViolation {
            try encodeContainer.encode(firewallSubnetIsOutOfScopeViolation, forKey: .firewallSubnetIsOutOfScopeViolation)
        }
        if let firewallSubnetMissingVPCEndpointViolation = self.firewallSubnetMissingVPCEndpointViolation {
            try encodeContainer.encode(firewallSubnetMissingVPCEndpointViolation, forKey: .firewallSubnetMissingVPCEndpointViolation)
        }
        if let networkFirewallBlackHoleRouteDetectedViolation = self.networkFirewallBlackHoleRouteDetectedViolation {
            try encodeContainer.encode(networkFirewallBlackHoleRouteDetectedViolation, forKey: .networkFirewallBlackHoleRouteDetectedViolation)
        }
        if let networkFirewallInternetTrafficNotInspectedViolation = self.networkFirewallInternetTrafficNotInspectedViolation {
            try encodeContainer.encode(networkFirewallInternetTrafficNotInspectedViolation, forKey: .networkFirewallInternetTrafficNotInspectedViolation)
        }
        if let networkFirewallInvalidRouteConfigurationViolation = self.networkFirewallInvalidRouteConfigurationViolation {
            try encodeContainer.encode(networkFirewallInvalidRouteConfigurationViolation, forKey: .networkFirewallInvalidRouteConfigurationViolation)
        }
        if let networkFirewallMissingExpectedRTViolation = self.networkFirewallMissingExpectedRTViolation {
            try encodeContainer.encode(networkFirewallMissingExpectedRTViolation, forKey: .networkFirewallMissingExpectedRTViolation)
        }
        if let networkFirewallMissingExpectedRoutesViolation = self.networkFirewallMissingExpectedRoutesViolation {
            try encodeContainer.encode(networkFirewallMissingExpectedRoutesViolation, forKey: .networkFirewallMissingExpectedRoutesViolation)
        }
        if let networkFirewallMissingFirewallViolation = self.networkFirewallMissingFirewallViolation {
            try encodeContainer.encode(networkFirewallMissingFirewallViolation, forKey: .networkFirewallMissingFirewallViolation)
        }
        if let networkFirewallMissingSubnetViolation = self.networkFirewallMissingSubnetViolation {
            try encodeContainer.encode(networkFirewallMissingSubnetViolation, forKey: .networkFirewallMissingSubnetViolation)
        }
        if let networkFirewallPolicyModifiedViolation = self.networkFirewallPolicyModifiedViolation {
            try encodeContainer.encode(networkFirewallPolicyModifiedViolation, forKey: .networkFirewallPolicyModifiedViolation)
        }
        if let networkFirewallUnexpectedFirewallRoutesViolation = self.networkFirewallUnexpectedFirewallRoutesViolation {
            try encodeContainer.encode(networkFirewallUnexpectedFirewallRoutesViolation, forKey: .networkFirewallUnexpectedFirewallRoutesViolation)
        }
        if let networkFirewallUnexpectedGatewayRoutesViolation = self.networkFirewallUnexpectedGatewayRoutesViolation {
            try encodeContainer.encode(networkFirewallUnexpectedGatewayRoutesViolation, forKey: .networkFirewallUnexpectedGatewayRoutesViolation)
        }
        if let possibleRemediationActions = self.possibleRemediationActions {
            try encodeContainer.encode(possibleRemediationActions, forKey: .possibleRemediationActions)
        }
        if let routeHasOutOfScopeEndpointViolation = self.routeHasOutOfScopeEndpointViolation {
            try encodeContainer.encode(routeHasOutOfScopeEndpointViolation, forKey: .routeHasOutOfScopeEndpointViolation)
        }
        if let thirdPartyFirewallMissingExpectedRouteTableViolation = self.thirdPartyFirewallMissingExpectedRouteTableViolation {
            try encodeContainer.encode(thirdPartyFirewallMissingExpectedRouteTableViolation, forKey: .thirdPartyFirewallMissingExpectedRouteTableViolation)
        }
        if let thirdPartyFirewallMissingFirewallViolation = self.thirdPartyFirewallMissingFirewallViolation {
            try encodeContainer.encode(thirdPartyFirewallMissingFirewallViolation, forKey: .thirdPartyFirewallMissingFirewallViolation)
        }
        if let thirdPartyFirewallMissingSubnetViolation = self.thirdPartyFirewallMissingSubnetViolation {
            try encodeContainer.encode(thirdPartyFirewallMissingSubnetViolation, forKey: .thirdPartyFirewallMissingSubnetViolation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsVPCSecurityGroupViolationDecoded = try containerValues.decodeIfPresent(FMSClientTypes.AwsVPCSecurityGroupViolation.self, forKey: .awsVPCSecurityGroupViolation)
        awsVPCSecurityGroupViolation = awsVPCSecurityGroupViolationDecoded
        let awsEc2NetworkInterfaceViolationDecoded = try containerValues.decodeIfPresent(FMSClientTypes.AwsEc2NetworkInterfaceViolation.self, forKey: .awsEc2NetworkInterfaceViolation)
        awsEc2NetworkInterfaceViolation = awsEc2NetworkInterfaceViolationDecoded
        let awsEc2InstanceViolationDecoded = try containerValues.decodeIfPresent(FMSClientTypes.AwsEc2InstanceViolation.self, forKey: .awsEc2InstanceViolation)
        awsEc2InstanceViolation = awsEc2InstanceViolationDecoded
        let networkFirewallMissingFirewallViolationDecoded = try containerValues.decodeIfPresent(FMSClientTypes.NetworkFirewallMissingFirewallViolation.self, forKey: .networkFirewallMissingFirewallViolation)
        networkFirewallMissingFirewallViolation = networkFirewallMissingFirewallViolationDecoded
        let networkFirewallMissingSubnetViolationDecoded = try containerValues.decodeIfPresent(FMSClientTypes.NetworkFirewallMissingSubnetViolation.self, forKey: .networkFirewallMissingSubnetViolation)
        networkFirewallMissingSubnetViolation = networkFirewallMissingSubnetViolationDecoded
        let networkFirewallMissingExpectedRTViolationDecoded = try containerValues.decodeIfPresent(FMSClientTypes.NetworkFirewallMissingExpectedRTViolation.self, forKey: .networkFirewallMissingExpectedRTViolation)
        networkFirewallMissingExpectedRTViolation = networkFirewallMissingExpectedRTViolationDecoded
        let networkFirewallPolicyModifiedViolationDecoded = try containerValues.decodeIfPresent(FMSClientTypes.NetworkFirewallPolicyModifiedViolation.self, forKey: .networkFirewallPolicyModifiedViolation)
        networkFirewallPolicyModifiedViolation = networkFirewallPolicyModifiedViolationDecoded
        let networkFirewallInternetTrafficNotInspectedViolationDecoded = try containerValues.decodeIfPresent(FMSClientTypes.NetworkFirewallInternetTrafficNotInspectedViolation.self, forKey: .networkFirewallInternetTrafficNotInspectedViolation)
        networkFirewallInternetTrafficNotInspectedViolation = networkFirewallInternetTrafficNotInspectedViolationDecoded
        let networkFirewallInvalidRouteConfigurationViolationDecoded = try containerValues.decodeIfPresent(FMSClientTypes.NetworkFirewallInvalidRouteConfigurationViolation.self, forKey: .networkFirewallInvalidRouteConfigurationViolation)
        networkFirewallInvalidRouteConfigurationViolation = networkFirewallInvalidRouteConfigurationViolationDecoded
        let networkFirewallBlackHoleRouteDetectedViolationDecoded = try containerValues.decodeIfPresent(FMSClientTypes.NetworkFirewallBlackHoleRouteDetectedViolation.self, forKey: .networkFirewallBlackHoleRouteDetectedViolation)
        networkFirewallBlackHoleRouteDetectedViolation = networkFirewallBlackHoleRouteDetectedViolationDecoded
        let networkFirewallUnexpectedFirewallRoutesViolationDecoded = try containerValues.decodeIfPresent(FMSClientTypes.NetworkFirewallUnexpectedFirewallRoutesViolation.self, forKey: .networkFirewallUnexpectedFirewallRoutesViolation)
        networkFirewallUnexpectedFirewallRoutesViolation = networkFirewallUnexpectedFirewallRoutesViolationDecoded
        let networkFirewallUnexpectedGatewayRoutesViolationDecoded = try containerValues.decodeIfPresent(FMSClientTypes.NetworkFirewallUnexpectedGatewayRoutesViolation.self, forKey: .networkFirewallUnexpectedGatewayRoutesViolation)
        networkFirewallUnexpectedGatewayRoutesViolation = networkFirewallUnexpectedGatewayRoutesViolationDecoded
        let networkFirewallMissingExpectedRoutesViolationDecoded = try containerValues.decodeIfPresent(FMSClientTypes.NetworkFirewallMissingExpectedRoutesViolation.self, forKey: .networkFirewallMissingExpectedRoutesViolation)
        networkFirewallMissingExpectedRoutesViolation = networkFirewallMissingExpectedRoutesViolationDecoded
        let dnsRuleGroupPriorityConflictViolationDecoded = try containerValues.decodeIfPresent(FMSClientTypes.DnsRuleGroupPriorityConflictViolation.self, forKey: .dnsRuleGroupPriorityConflictViolation)
        dnsRuleGroupPriorityConflictViolation = dnsRuleGroupPriorityConflictViolationDecoded
        let dnsDuplicateRuleGroupViolationDecoded = try containerValues.decodeIfPresent(FMSClientTypes.DnsDuplicateRuleGroupViolation.self, forKey: .dnsDuplicateRuleGroupViolation)
        dnsDuplicateRuleGroupViolation = dnsDuplicateRuleGroupViolationDecoded
        let dnsRuleGroupLimitExceededViolationDecoded = try containerValues.decodeIfPresent(FMSClientTypes.DnsRuleGroupLimitExceededViolation.self, forKey: .dnsRuleGroupLimitExceededViolation)
        dnsRuleGroupLimitExceededViolation = dnsRuleGroupLimitExceededViolationDecoded
        let possibleRemediationActionsDecoded = try containerValues.decodeIfPresent(FMSClientTypes.PossibleRemediationActions.self, forKey: .possibleRemediationActions)
        possibleRemediationActions = possibleRemediationActionsDecoded
        let firewallSubnetIsOutOfScopeViolationDecoded = try containerValues.decodeIfPresent(FMSClientTypes.FirewallSubnetIsOutOfScopeViolation.self, forKey: .firewallSubnetIsOutOfScopeViolation)
        firewallSubnetIsOutOfScopeViolation = firewallSubnetIsOutOfScopeViolationDecoded
        let routeHasOutOfScopeEndpointViolationDecoded = try containerValues.decodeIfPresent(FMSClientTypes.RouteHasOutOfScopeEndpointViolation.self, forKey: .routeHasOutOfScopeEndpointViolation)
        routeHasOutOfScopeEndpointViolation = routeHasOutOfScopeEndpointViolationDecoded
        let thirdPartyFirewallMissingFirewallViolationDecoded = try containerValues.decodeIfPresent(FMSClientTypes.ThirdPartyFirewallMissingFirewallViolation.self, forKey: .thirdPartyFirewallMissingFirewallViolation)
        thirdPartyFirewallMissingFirewallViolation = thirdPartyFirewallMissingFirewallViolationDecoded
        let thirdPartyFirewallMissingSubnetViolationDecoded = try containerValues.decodeIfPresent(FMSClientTypes.ThirdPartyFirewallMissingSubnetViolation.self, forKey: .thirdPartyFirewallMissingSubnetViolation)
        thirdPartyFirewallMissingSubnetViolation = thirdPartyFirewallMissingSubnetViolationDecoded
        let thirdPartyFirewallMissingExpectedRouteTableViolationDecoded = try containerValues.decodeIfPresent(FMSClientTypes.ThirdPartyFirewallMissingExpectedRouteTableViolation.self, forKey: .thirdPartyFirewallMissingExpectedRouteTableViolation)
        thirdPartyFirewallMissingExpectedRouteTableViolation = thirdPartyFirewallMissingExpectedRouteTableViolationDecoded
        let firewallSubnetMissingVPCEndpointViolationDecoded = try containerValues.decodeIfPresent(FMSClientTypes.FirewallSubnetMissingVPCEndpointViolation.self, forKey: .firewallSubnetMissingVPCEndpointViolation)
        firewallSubnetMissingVPCEndpointViolation = firewallSubnetMissingVPCEndpointViolationDecoded
    }
}

extension FMSClientTypes {
    /// Violation detail based on resource type.
    public struct ResourceViolation: Swift.Equatable {
        /// Violation detail for an EC2 instance.
        public var awsEc2InstanceViolation: FMSClientTypes.AwsEc2InstanceViolation?
        /// Violation detail for a network interface.
        public var awsEc2NetworkInterfaceViolation: FMSClientTypes.AwsEc2NetworkInterfaceViolation?
        /// Violation detail for security groups.
        public var awsVPCSecurityGroupViolation: FMSClientTypes.AwsVPCSecurityGroupViolation?
        /// Violation detail for a DNS Firewall policy that indicates that a rule group that Firewall Manager tried to associate with a VPC is already associated with the VPC and can't be associated again.
        public var dnsDuplicateRuleGroupViolation: FMSClientTypes.DnsDuplicateRuleGroupViolation?
        /// Violation detail for a DNS Firewall policy that indicates that the VPC reached the limit for associated DNS Firewall rule groups. Firewall Manager tried to associate another rule group with the VPC and failed.
        public var dnsRuleGroupLimitExceededViolation: FMSClientTypes.DnsRuleGroupLimitExceededViolation?
        /// Violation detail for a DNS Firewall policy that indicates that a rule group that Firewall Manager tried to associate with a VPC has the same priority as a rule group that's already associated.
        public var dnsRuleGroupPriorityConflictViolation: FMSClientTypes.DnsRuleGroupPriorityConflictViolation?
        /// Contains details about the firewall subnet that violates the policy scope.
        public var firewallSubnetIsOutOfScopeViolation: FMSClientTypes.FirewallSubnetIsOutOfScopeViolation?
        /// The violation details for a third-party firewall's VPC endpoint subnet that was deleted.
        public var firewallSubnetMissingVPCEndpointViolation: FMSClientTypes.FirewallSubnetMissingVPCEndpointViolation?
        /// Violation detail for an internet gateway route with an inactive state in the customer subnet route table or Network Firewall subnet route table.
        public var networkFirewallBlackHoleRouteDetectedViolation: FMSClientTypes.NetworkFirewallBlackHoleRouteDetectedViolation?
        /// Violation detail for the subnet for which internet traffic hasn't been inspected.
        public var networkFirewallInternetTrafficNotInspectedViolation: FMSClientTypes.NetworkFirewallInternetTrafficNotInspectedViolation?
        /// The route configuration is invalid.
        public var networkFirewallInvalidRouteConfigurationViolation: FMSClientTypes.NetworkFirewallInvalidRouteConfigurationViolation?
        /// Violation detail for an Network Firewall policy that indicates that a subnet is not associated with the expected Firewall Manager managed route table.
        public var networkFirewallMissingExpectedRTViolation: FMSClientTypes.NetworkFirewallMissingExpectedRTViolation?
        /// Expected routes are missing from Network Firewall.
        public var networkFirewallMissingExpectedRoutesViolation: FMSClientTypes.NetworkFirewallMissingExpectedRoutesViolation?
        /// Violation detail for an Network Firewall policy that indicates that a subnet has no Firewall Manager managed firewall in its VPC.
        public var networkFirewallMissingFirewallViolation: FMSClientTypes.NetworkFirewallMissingFirewallViolation?
        /// Violation detail for an Network Firewall policy that indicates that an Availability Zone is missing the expected Firewall Manager managed subnet.
        public var networkFirewallMissingSubnetViolation: FMSClientTypes.NetworkFirewallMissingSubnetViolation?
        /// Violation detail for an Network Firewall policy that indicates that a firewall policy in an individual account has been modified in a way that makes it noncompliant. For example, the individual account owner might have deleted a rule group, changed the priority of a stateless rule group, or changed a policy default action.
        public var networkFirewallPolicyModifiedViolation: FMSClientTypes.NetworkFirewallPolicyModifiedViolation?
        /// There's an unexpected firewall route.
        public var networkFirewallUnexpectedFirewallRoutesViolation: FMSClientTypes.NetworkFirewallUnexpectedFirewallRoutesViolation?
        /// There's an unexpected gateway route.
        public var networkFirewallUnexpectedGatewayRoutesViolation: FMSClientTypes.NetworkFirewallUnexpectedGatewayRoutesViolation?
        /// A list of possible remediation action lists. Each individual possible remediation action is a list of individual remediation actions.
        public var possibleRemediationActions: FMSClientTypes.PossibleRemediationActions?
        /// Contains details about the route endpoint that violates the policy scope.
        public var routeHasOutOfScopeEndpointViolation: FMSClientTypes.RouteHasOutOfScopeEndpointViolation?
        /// The violation details for a third-party firewall that has the Firewall Manager managed route table that was associated with the third-party firewall has been deleted.
        public var thirdPartyFirewallMissingExpectedRouteTableViolation: FMSClientTypes.ThirdPartyFirewallMissingExpectedRouteTableViolation?
        /// The violation details for a third-party firewall that's been deleted.
        public var thirdPartyFirewallMissingFirewallViolation: FMSClientTypes.ThirdPartyFirewallMissingFirewallViolation?
        /// The violation details for a third-party firewall's subnet that's been deleted.
        public var thirdPartyFirewallMissingSubnetViolation: FMSClientTypes.ThirdPartyFirewallMissingSubnetViolation?

        public init (
            awsEc2InstanceViolation: FMSClientTypes.AwsEc2InstanceViolation? = nil,
            awsEc2NetworkInterfaceViolation: FMSClientTypes.AwsEc2NetworkInterfaceViolation? = nil,
            awsVPCSecurityGroupViolation: FMSClientTypes.AwsVPCSecurityGroupViolation? = nil,
            dnsDuplicateRuleGroupViolation: FMSClientTypes.DnsDuplicateRuleGroupViolation? = nil,
            dnsRuleGroupLimitExceededViolation: FMSClientTypes.DnsRuleGroupLimitExceededViolation? = nil,
            dnsRuleGroupPriorityConflictViolation: FMSClientTypes.DnsRuleGroupPriorityConflictViolation? = nil,
            firewallSubnetIsOutOfScopeViolation: FMSClientTypes.FirewallSubnetIsOutOfScopeViolation? = nil,
            firewallSubnetMissingVPCEndpointViolation: FMSClientTypes.FirewallSubnetMissingVPCEndpointViolation? = nil,
            networkFirewallBlackHoleRouteDetectedViolation: FMSClientTypes.NetworkFirewallBlackHoleRouteDetectedViolation? = nil,
            networkFirewallInternetTrafficNotInspectedViolation: FMSClientTypes.NetworkFirewallInternetTrafficNotInspectedViolation? = nil,
            networkFirewallInvalidRouteConfigurationViolation: FMSClientTypes.NetworkFirewallInvalidRouteConfigurationViolation? = nil,
            networkFirewallMissingExpectedRTViolation: FMSClientTypes.NetworkFirewallMissingExpectedRTViolation? = nil,
            networkFirewallMissingExpectedRoutesViolation: FMSClientTypes.NetworkFirewallMissingExpectedRoutesViolation? = nil,
            networkFirewallMissingFirewallViolation: FMSClientTypes.NetworkFirewallMissingFirewallViolation? = nil,
            networkFirewallMissingSubnetViolation: FMSClientTypes.NetworkFirewallMissingSubnetViolation? = nil,
            networkFirewallPolicyModifiedViolation: FMSClientTypes.NetworkFirewallPolicyModifiedViolation? = nil,
            networkFirewallUnexpectedFirewallRoutesViolation: FMSClientTypes.NetworkFirewallUnexpectedFirewallRoutesViolation? = nil,
            networkFirewallUnexpectedGatewayRoutesViolation: FMSClientTypes.NetworkFirewallUnexpectedGatewayRoutesViolation? = nil,
            possibleRemediationActions: FMSClientTypes.PossibleRemediationActions? = nil,
            routeHasOutOfScopeEndpointViolation: FMSClientTypes.RouteHasOutOfScopeEndpointViolation? = nil,
            thirdPartyFirewallMissingExpectedRouteTableViolation: FMSClientTypes.ThirdPartyFirewallMissingExpectedRouteTableViolation? = nil,
            thirdPartyFirewallMissingFirewallViolation: FMSClientTypes.ThirdPartyFirewallMissingFirewallViolation? = nil,
            thirdPartyFirewallMissingSubnetViolation: FMSClientTypes.ThirdPartyFirewallMissingSubnetViolation? = nil
        )
        {
            self.awsEc2InstanceViolation = awsEc2InstanceViolation
            self.awsEc2NetworkInterfaceViolation = awsEc2NetworkInterfaceViolation
            self.awsVPCSecurityGroupViolation = awsVPCSecurityGroupViolation
            self.dnsDuplicateRuleGroupViolation = dnsDuplicateRuleGroupViolation
            self.dnsRuleGroupLimitExceededViolation = dnsRuleGroupLimitExceededViolation
            self.dnsRuleGroupPriorityConflictViolation = dnsRuleGroupPriorityConflictViolation
            self.firewallSubnetIsOutOfScopeViolation = firewallSubnetIsOutOfScopeViolation
            self.firewallSubnetMissingVPCEndpointViolation = firewallSubnetMissingVPCEndpointViolation
            self.networkFirewallBlackHoleRouteDetectedViolation = networkFirewallBlackHoleRouteDetectedViolation
            self.networkFirewallInternetTrafficNotInspectedViolation = networkFirewallInternetTrafficNotInspectedViolation
            self.networkFirewallInvalidRouteConfigurationViolation = networkFirewallInvalidRouteConfigurationViolation
            self.networkFirewallMissingExpectedRTViolation = networkFirewallMissingExpectedRTViolation
            self.networkFirewallMissingExpectedRoutesViolation = networkFirewallMissingExpectedRoutesViolation
            self.networkFirewallMissingFirewallViolation = networkFirewallMissingFirewallViolation
            self.networkFirewallMissingSubnetViolation = networkFirewallMissingSubnetViolation
            self.networkFirewallPolicyModifiedViolation = networkFirewallPolicyModifiedViolation
            self.networkFirewallUnexpectedFirewallRoutesViolation = networkFirewallUnexpectedFirewallRoutesViolation
            self.networkFirewallUnexpectedGatewayRoutesViolation = networkFirewallUnexpectedGatewayRoutesViolation
            self.possibleRemediationActions = possibleRemediationActions
            self.routeHasOutOfScopeEndpointViolation = routeHasOutOfScopeEndpointViolation
            self.thirdPartyFirewallMissingExpectedRouteTableViolation = thirdPartyFirewallMissingExpectedRouteTableViolation
            self.thirdPartyFirewallMissingFirewallViolation = thirdPartyFirewallMissingFirewallViolation
            self.thirdPartyFirewallMissingSubnetViolation = thirdPartyFirewallMissingSubnetViolation
        }
    }

}

extension FMSClientTypes.Route: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case destinationType = "DestinationType"
        case target = "Target"
        case targetType = "TargetType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let destinationType = self.destinationType {
            try encodeContainer.encode(destinationType.rawValue, forKey: .destinationType)
        }
        if let target = self.target {
            try encodeContainer.encode(target, forKey: .target)
        }
        if let targetType = self.targetType {
            try encodeContainer.encode(targetType.rawValue, forKey: .targetType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationTypeDecoded = try containerValues.decodeIfPresent(FMSClientTypes.DestinationType.self, forKey: .destinationType)
        destinationType = destinationTypeDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(FMSClientTypes.TargetType.self, forKey: .targetType)
        targetType = targetTypeDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
    }
}

extension FMSClientTypes {
    /// Describes a route in a route table.
    public struct Route: Swift.Equatable {
        /// The destination of the route.
        public var destination: Swift.String?
        /// The type of destination for the route.
        public var destinationType: FMSClientTypes.DestinationType?
        /// The route's target.
        public var target: Swift.String?
        /// The type of target for the route.
        public var targetType: FMSClientTypes.TargetType?

        public init (
            destination: Swift.String? = nil,
            destinationType: FMSClientTypes.DestinationType? = nil,
            target: Swift.String? = nil,
            targetType: FMSClientTypes.TargetType? = nil
        )
        {
            self.destination = destination
            self.destinationType = destinationType
            self.target = target
            self.targetType = targetType
        }
    }

}

extension FMSClientTypes.RouteHasOutOfScopeEndpointViolation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentFirewallSubnetRouteTable = "CurrentFirewallSubnetRouteTable"
        case currentInternetGatewayRouteTable = "CurrentInternetGatewayRouteTable"
        case firewallSubnetId = "FirewallSubnetId"
        case firewallSubnetRoutes = "FirewallSubnetRoutes"
        case internetGatewayId = "InternetGatewayId"
        case internetGatewayRoutes = "InternetGatewayRoutes"
        case routeTableId = "RouteTableId"
        case subnetAvailabilityZone = "SubnetAvailabilityZone"
        case subnetAvailabilityZoneId = "SubnetAvailabilityZoneId"
        case subnetId = "SubnetId"
        case violatingRoutes = "ViolatingRoutes"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentFirewallSubnetRouteTable = self.currentFirewallSubnetRouteTable {
            try encodeContainer.encode(currentFirewallSubnetRouteTable, forKey: .currentFirewallSubnetRouteTable)
        }
        if let currentInternetGatewayRouteTable = self.currentInternetGatewayRouteTable {
            try encodeContainer.encode(currentInternetGatewayRouteTable, forKey: .currentInternetGatewayRouteTable)
        }
        if let firewallSubnetId = self.firewallSubnetId {
            try encodeContainer.encode(firewallSubnetId, forKey: .firewallSubnetId)
        }
        if let firewallSubnetRoutes = firewallSubnetRoutes {
            var firewallSubnetRoutesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .firewallSubnetRoutes)
            for route0 in firewallSubnetRoutes {
                try firewallSubnetRoutesContainer.encode(route0)
            }
        }
        if let internetGatewayId = self.internetGatewayId {
            try encodeContainer.encode(internetGatewayId, forKey: .internetGatewayId)
        }
        if let internetGatewayRoutes = internetGatewayRoutes {
            var internetGatewayRoutesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .internetGatewayRoutes)
            for route0 in internetGatewayRoutes {
                try internetGatewayRoutesContainer.encode(route0)
            }
        }
        if let routeTableId = self.routeTableId {
            try encodeContainer.encode(routeTableId, forKey: .routeTableId)
        }
        if let subnetAvailabilityZone = self.subnetAvailabilityZone {
            try encodeContainer.encode(subnetAvailabilityZone, forKey: .subnetAvailabilityZone)
        }
        if let subnetAvailabilityZoneId = self.subnetAvailabilityZoneId {
            try encodeContainer.encode(subnetAvailabilityZoneId, forKey: .subnetAvailabilityZoneId)
        }
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let violatingRoutes = violatingRoutes {
            var violatingRoutesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .violatingRoutes)
            for route0 in violatingRoutes {
                try violatingRoutesContainer.encode(route0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let routeTableIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeTableId)
        routeTableId = routeTableIdDecoded
        let violatingRoutesContainer = try containerValues.decodeIfPresent([FMSClientTypes.Route?].self, forKey: .violatingRoutes)
        var violatingRoutesDecoded0:[FMSClientTypes.Route]? = nil
        if let violatingRoutesContainer = violatingRoutesContainer {
            violatingRoutesDecoded0 = [FMSClientTypes.Route]()
            for structure0 in violatingRoutesContainer {
                if let structure0 = structure0 {
                    violatingRoutesDecoded0?.append(structure0)
                }
            }
        }
        violatingRoutes = violatingRoutesDecoded0
        let subnetAvailabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetAvailabilityZone)
        subnetAvailabilityZone = subnetAvailabilityZoneDecoded
        let subnetAvailabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetAvailabilityZoneId)
        subnetAvailabilityZoneId = subnetAvailabilityZoneIdDecoded
        let currentFirewallSubnetRouteTableDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentFirewallSubnetRouteTable)
        currentFirewallSubnetRouteTable = currentFirewallSubnetRouteTableDecoded
        let firewallSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallSubnetId)
        firewallSubnetId = firewallSubnetIdDecoded
        let firewallSubnetRoutesContainer = try containerValues.decodeIfPresent([FMSClientTypes.Route?].self, forKey: .firewallSubnetRoutes)
        var firewallSubnetRoutesDecoded0:[FMSClientTypes.Route]? = nil
        if let firewallSubnetRoutesContainer = firewallSubnetRoutesContainer {
            firewallSubnetRoutesDecoded0 = [FMSClientTypes.Route]()
            for structure0 in firewallSubnetRoutesContainer {
                if let structure0 = structure0 {
                    firewallSubnetRoutesDecoded0?.append(structure0)
                }
            }
        }
        firewallSubnetRoutes = firewallSubnetRoutesDecoded0
        let internetGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .internetGatewayId)
        internetGatewayId = internetGatewayIdDecoded
        let currentInternetGatewayRouteTableDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentInternetGatewayRouteTable)
        currentInternetGatewayRouteTable = currentInternetGatewayRouteTableDecoded
        let internetGatewayRoutesContainer = try containerValues.decodeIfPresent([FMSClientTypes.Route?].self, forKey: .internetGatewayRoutes)
        var internetGatewayRoutesDecoded0:[FMSClientTypes.Route]? = nil
        if let internetGatewayRoutesContainer = internetGatewayRoutesContainer {
            internetGatewayRoutesDecoded0 = [FMSClientTypes.Route]()
            for structure0 in internetGatewayRoutesContainer {
                if let structure0 = structure0 {
                    internetGatewayRoutesDecoded0?.append(structure0)
                }
            }
        }
        internetGatewayRoutes = internetGatewayRoutesDecoded0
    }
}

extension FMSClientTypes {
    /// Contains details about the route endpoint that violates the policy scope.
    public struct RouteHasOutOfScopeEndpointViolation: Swift.Equatable {
        /// The route table associated with the current firewall subnet.
        public var currentFirewallSubnetRouteTable: Swift.String?
        /// The current route table associated with the Internet Gateway.
        public var currentInternetGatewayRouteTable: Swift.String?
        /// The ID of the firewall subnet.
        public var firewallSubnetId: Swift.String?
        /// The list of firewall subnet routes.
        public var firewallSubnetRoutes: [FMSClientTypes.Route]?
        /// The ID of the Internet Gateway.
        public var internetGatewayId: Swift.String?
        /// The routes in the route table associated with the Internet Gateway.
        public var internetGatewayRoutes: [FMSClientTypes.Route]?
        /// The ID of the route table.
        public var routeTableId: Swift.String?
        /// The subnet's Availability Zone.
        public var subnetAvailabilityZone: Swift.String?
        /// The ID of the subnet's Availability Zone.
        public var subnetAvailabilityZoneId: Swift.String?
        /// The ID of the subnet associated with the route that violates the policy scope.
        public var subnetId: Swift.String?
        /// The list of routes that violate the route table.
        public var violatingRoutes: [FMSClientTypes.Route]?
        /// The VPC ID of the route that violates the policy scope.
        public var vpcId: Swift.String?

        public init (
            currentFirewallSubnetRouteTable: Swift.String? = nil,
            currentInternetGatewayRouteTable: Swift.String? = nil,
            firewallSubnetId: Swift.String? = nil,
            firewallSubnetRoutes: [FMSClientTypes.Route]? = nil,
            internetGatewayId: Swift.String? = nil,
            internetGatewayRoutes: [FMSClientTypes.Route]? = nil,
            routeTableId: Swift.String? = nil,
            subnetAvailabilityZone: Swift.String? = nil,
            subnetAvailabilityZoneId: Swift.String? = nil,
            subnetId: Swift.String? = nil,
            violatingRoutes: [FMSClientTypes.Route]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.currentFirewallSubnetRouteTable = currentFirewallSubnetRouteTable
            self.currentInternetGatewayRouteTable = currentInternetGatewayRouteTable
            self.firewallSubnetId = firewallSubnetId
            self.firewallSubnetRoutes = firewallSubnetRoutes
            self.internetGatewayId = internetGatewayId
            self.internetGatewayRoutes = internetGatewayRoutes
            self.routeTableId = routeTableId
            self.subnetAvailabilityZone = subnetAvailabilityZone
            self.subnetAvailabilityZoneId = subnetAvailabilityZoneId
            self.subnetId = subnetId
            self.violatingRoutes = violatingRoutes
            self.vpcId = vpcId
        }
    }

}

extension FMSClientTypes {
    public enum RuleOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case defaultActionOrder
        case strictOrder
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleOrder] {
            return [
                .defaultActionOrder,
                .strictOrder,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .defaultActionOrder: return "DEFAULT_ACTION_ORDER"
            case .strictOrder: return "STRICT_ORDER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RuleOrder(rawValue: rawValue) ?? RuleOrder.sdkUnknown(rawValue)
        }
    }
}

extension FMSClientTypes.SecurityGroupRemediationAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case isDefaultAction = "IsDefaultAction"
        case remediationActionType = "RemediationActionType"
        case remediationResult = "RemediationResult"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if isDefaultAction != false {
            try encodeContainer.encode(isDefaultAction, forKey: .isDefaultAction)
        }
        if let remediationActionType = self.remediationActionType {
            try encodeContainer.encode(remediationActionType.rawValue, forKey: .remediationActionType)
        }
        if let remediationResult = self.remediationResult {
            try encodeContainer.encode(remediationResult, forKey: .remediationResult)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let remediationActionTypeDecoded = try containerValues.decodeIfPresent(FMSClientTypes.RemediationActionType.self, forKey: .remediationActionType)
        remediationActionType = remediationActionTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let remediationResultDecoded = try containerValues.decodeIfPresent(FMSClientTypes.SecurityGroupRuleDescription.self, forKey: .remediationResult)
        remediationResult = remediationResultDecoded
        let isDefaultActionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isDefaultAction) ?? false
        isDefaultAction = isDefaultActionDecoded
    }
}

extension FMSClientTypes {
    /// Remediation option for the rule specified in the ViolationTarget.
    public struct SecurityGroupRemediationAction: Swift.Equatable {
        /// Brief description of the action that will be performed.
        public var description: Swift.String?
        /// Indicates if the current action is the default action.
        public var isDefaultAction: Swift.Bool
        /// The remediation action that will be performed.
        public var remediationActionType: FMSClientTypes.RemediationActionType?
        /// The final state of the rule specified in the ViolationTarget after it is remediated.
        public var remediationResult: FMSClientTypes.SecurityGroupRuleDescription?

        public init (
            description: Swift.String? = nil,
            isDefaultAction: Swift.Bool = false,
            remediationActionType: FMSClientTypes.RemediationActionType? = nil,
            remediationResult: FMSClientTypes.SecurityGroupRuleDescription? = nil
        )
        {
            self.description = description
            self.isDefaultAction = isDefaultAction
            self.remediationActionType = remediationActionType
            self.remediationResult = remediationResult
        }
    }

}

extension FMSClientTypes.SecurityGroupRuleDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromPort = "FromPort"
        case ipv4Range = "IPV4Range"
        case ipv6Range = "IPV6Range"
        case prefixListId = "PrefixListId"
        case `protocol` = "Protocol"
        case toPort = "ToPort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromPort = self.fromPort {
            try encodeContainer.encode(fromPort, forKey: .fromPort)
        }
        if let ipv4Range = self.ipv4Range {
            try encodeContainer.encode(ipv4Range, forKey: .ipv4Range)
        }
        if let ipv6Range = self.ipv6Range {
            try encodeContainer.encode(ipv6Range, forKey: .ipv6Range)
        }
        if let prefixListId = self.prefixListId {
            try encodeContainer.encode(prefixListId, forKey: .prefixListId)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`, forKey: .`protocol`)
        }
        if let toPort = self.toPort {
            try encodeContainer.encode(toPort, forKey: .toPort)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipv4RangeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipv4Range)
        ipv4Range = ipv4RangeDecoded
        let ipv6RangeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipv6Range)
        ipv6Range = ipv6RangeDecoded
        let prefixListIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefixListId)
        prefixListId = prefixListIdDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let fromPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fromPort)
        fromPort = fromPortDecoded
        let toPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .toPort)
        toPort = toPortDecoded
    }
}

extension FMSClientTypes {
    /// Describes a set of permissions for a security group rule.
    public struct SecurityGroupRuleDescription: Swift.Equatable {
        /// The start of the port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number. A value of -1 indicates all ICMP/ICMPv6 types.
        public var fromPort: Swift.Int?
        /// The IPv4 ranges for the security group rule.
        public var ipv4Range: Swift.String?
        /// The IPv6 ranges for the security group rule.
        public var ipv6Range: Swift.String?
        /// The ID of the prefix list for the security group rule.
        public var prefixListId: Swift.String?
        /// The IP protocol name (tcp, udp, icmp, icmpv6) or number.
        public var `protocol`: Swift.String?
        /// The end of the port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code. A value of -1 indicates all ICMP/ICMPv6 codes.
        public var toPort: Swift.Int?

        public init (
            fromPort: Swift.Int? = nil,
            ipv4Range: Swift.String? = nil,
            ipv6Range: Swift.String? = nil,
            prefixListId: Swift.String? = nil,
            `protocol`: Swift.String? = nil,
            toPort: Swift.Int? = nil
        )
        {
            self.fromPort = fromPort
            self.ipv4Range = ipv4Range
            self.ipv6Range = ipv6Range
            self.prefixListId = prefixListId
            self.`protocol` = `protocol`
            self.toPort = toPort
        }
    }

}

extension FMSClientTypes.SecurityServicePolicyData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case managedServiceData = "ManagedServiceData"
        case policyOption = "PolicyOption"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let managedServiceData = self.managedServiceData {
            try encodeContainer.encode(managedServiceData, forKey: .managedServiceData)
        }
        if let policyOption = self.policyOption {
            try encodeContainer.encode(policyOption, forKey: .policyOption)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(FMSClientTypes.SecurityServiceType.self, forKey: .type)
        type = typeDecoded
        let managedServiceDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .managedServiceData)
        managedServiceData = managedServiceDataDecoded
        let policyOptionDecoded = try containerValues.decodeIfPresent(FMSClientTypes.PolicyOption.self, forKey: .policyOption)
        policyOption = policyOptionDecoded
    }
}

extension FMSClientTypes {
    /// Details about the security service that is being used to protect the resources.
    public struct SecurityServicePolicyData: Swift.Equatable {
        /// Details about the service that are specific to the service type, in JSON format.
        ///
        /// * Example: DNS_FIREWALL"{\"type\":\"DNS_FIREWALL\",\"preProcessRuleGroups\":[{\"ruleGroupId\":\"rslvr-frg-1\",\"priority\":10}],\"postProcessRuleGroups\":[{\"ruleGroupId\":\"rslvr-frg-2\",\"priority\":9911}]}" Valid values for preProcessRuleGroups are between 1 and 99. Valid values for postProcessRuleGroups are between 9901 and 10000.
        ///
        /// * Example: NETWORK_FIREWALL - Centralized deployment model "{\"type\":\"NETWORK_FIREWALL\",\"awsNetworkFirewallConfig\":{\"networkFirewallStatelessRuleGroupReferences\":[{\"resourceARN\":\"arn:aws:network-firewall:us-east-1:123456789011:stateless-rulegroup/test\",\"priority\":1}],\"networkFirewallStatelessDefaultActions\":[\"aws:forward_to_sfe\",\"customActionName\"],\"networkFirewallStatelessFragmentDefaultActions\":[\"aws:forward_to_sfe\",\"customActionName\"],\"networkFirewallStatelessCustomActions\":[{\"actionName\":\"customActionName\",\"actionDefinition\":{\"publishMetricAction\":{\"dimensions\":[{\"value\":\"metricdimensionvalue\"}]}}}],\"networkFirewallStatefulRuleGroupReferences\":[{\"resourceARN\":\"arn:aws:network-firewall:us-east-1:123456789011:stateful-rulegroup/test\"}],\"networkFirewallLoggingConfiguration\":{\"logDestinationConfigs\":[{\"logDestinationType\":\"S3\",\"logType\":\"ALERT\",\"logDestination\":{\"bucketName\":\"s3-bucket-name\"}},{\"logDestinationType\":\"S3\",\"logType\":\"FLOW\",\"logDestination\":{\"bucketName\":\"s3-bucket-name\"}}],\"overrideExistingConfig\":true}},\"firewallDeploymentModel\":{\"centralizedFirewallDeploymentModel\":{\"centralizedFirewallOrchestrationConfig\":{\"inspectionVpcIds\":[{\"resourceId\":\"vpc-1234\",\"accountId\":\"123456789011\"}],\"firewallCreationConfig\":{\"endpointLocation\":{\"availabilityZoneConfigList\":[{\"availabilityZoneId\":null,\"availabilityZoneName\":\"us-east-1a\",\"allowedIPV4CidrList\":[\"10.0.0.0/28\"]}]}},\"allowedIPV4CidrList\":[]}}}}" To use the centralized deployment model, you must set [PolicyOption](https://docs.aws.amazon.com/fms/2018-01-01/APIReference/API_PolicyOption.html) to CENTRALIZED.
        ///
        /// * Example: NETWORK_FIREWALL - Distributed deployment model with automatic Availability Zone configuration  "{\"type\":\"NETWORK_FIREWALL\",\"networkFirewallStatelessRuleGroupReferences\":[{\"resourceARN\":\"arn:aws:network-firewall:us-east-1:123456789011:stateless-rulegroup/test\",\"priority\":1}],\"networkFirewallStatelessDefaultActions\":[\"aws:forward_to_sfe\",\"customActionName\"],\"networkFirewallStatelessFragmentDefaultActions\":[\"aws:forward_to_sfe\",\"customActionName\"],\"networkFirewallStatelessCustomActions\":[{\"actionName\":\"customActionName\",\"actionDefinition\":{\"publishMetricAction\":{\"dimensions\":[{\"value\":\"metricdimensionvalue\"}]}}}],\"networkFirewallStatefulRuleGroupReferences\":[{\"resourceARN\":\"arn:aws:network-firewall:us-east-1:123456789011:stateful-rulegroup/test\"}],\"networkFirewallOrchestrationConfig\":{\"singleFirewallEndpointPerVPC\":false,\"allowedIPV4CidrList\":[\"10.0.0.0/28\",\"192.168.0.0/28\"],\"routeManagementAction\":\"OFF\"},\"networkFirewallLoggingConfiguration\":{\"logDestinationConfigs\":[{\"logDestinationType\":\"S3\",\"logType\":\"ALERT\",\"logDestination\":{\"bucketName\":\"s3-bucket-name\"}},{\"logDestinationType\":\"S3\",\"logType\":\"FLOW\",\"logDestination\":{\"bucketName\":\"s3-bucket-name\"}}],\"overrideExistingConfig\":true}}"  With automatic Availbility Zone configuration, Firewall Manager chooses which Availability Zones to create the endpoints in. To use the distributed deployment model, you must set [PolicyOption](https://docs.aws.amazon.com/fms/2018-01-01/APIReference/API_PolicyOption.html) to NULL.
        ///
        /// * Example: NETWORK_FIREWALL - Distributed deployment model with automatic Availability Zone configuration and route management  "{\"type\":\"NETWORK_FIREWALL\",\"networkFirewallStatelessRuleGroupReferences\":[{\"resourceARN\":\"arn:aws:network-firewall:us-east-1:123456789011:stateless-rulegroup/test\",\"priority\":1}],\"networkFirewallStatelessDefaultActions\":[\"aws:forward_to_sfe\",\"customActionName\"],\"networkFirewallStatelessFragmentDefaultActions\":[\"aws:forward_to_sfe\",\"customActionName\"],\"networkFirewallStatelessCustomActions\":[{\"actionName\":\"customActionName\",\"actionDefinition\":{\"publishMetricAction\":{\"dimensions\":[{\"value\":\"metricdimensionvalue\"}]}}}],\"networkFirewallStatefulRuleGroupReferences\":[{\"resourceARN\":\"arn:aws:network-firewall:us-east-1:123456789011:stateful-rulegroup/test\"}],\"networkFirewallOrchestrationConfig\":{\"singleFirewallEndpointPerVPC\":false,\"allowedIPV4CidrList\":[\"10.0.0.0/28\",\"192.168.0.0/28\"],\"routeManagementAction\":\"MONITOR\",\"routeManagementTargetTypes\":[\"InternetGateway\"]},\"networkFirewallLoggingConfiguration\":{\"logDestinationConfigs\":[{\"logDestinationType\":\"S3\",\"logType\":\"ALERT\",\"logDestination\":{\"bucketName\":\"s3-bucket-name\"}},{\"logDestinationType\":\"S3\",\"logType\": \"FLOW\",\"logDestination\":{\"bucketName\":\"s3-bucket-name\"}}],\"overrideExistingConfig\":true}}"  To use the distributed deployment model, you must set [PolicyOption](https://docs.aws.amazon.com/fms/2018-01-01/APIReference/API_PolicyOption.html) to NULL.
        ///
        /// * Example: NETWORK_FIREWALL - Distributed deployment model with custom Availability Zone configuration "{\"type\":\"NETWORK_FIREWALL\",\"networkFirewallStatelessRuleGroupReferences\":[{\"resourceARN\":\"arn:aws:network-firewall:us-east-1:123456789011:stateless-rulegroup/test\",\"priority\":1}],\"networkFirewallStatelessDefaultActions\":[\"aws:forward_to_sfe\",\"customActionName\"],\"networkFirewallStatelessFragmentDefaultActions\":[\"aws:forward_to_sfe\",\"fragmentcustomactionname\"],\"networkFirewallStatelessCustomActions\":[{\"actionName\":\"customActionName\", \"actionDefinition\":{\"publishMetricAction\":{\"dimensions\":[{\"value\":\"metricdimensionvalue\"}]}}},{\"actionName\":\"fragmentcustomactionname\",\"actionDefinition\":{\"publishMetricAction\":{\"dimensions\":[{\"value\":\"fragmentmetricdimensionvalue\"}]}}}],\"networkFirewallStatefulRuleGroupReferences\":[{\"resourceARN\":\"arn:aws:network-firewall:us-east-1:123456789011:stateful-rulegroup/test\"}],\"networkFirewallOrchestrationConfig\":{\"firewallCreationConfig\":{ \"endpointLocation\":{\"availabilityZoneConfigList\":[{\"availabilityZoneName\":\"us-east-1a\",\"allowedIPV4CidrList\":[\"10.0.0.0/28\"]},{\"availabilityZoneName\":\"us-east-1b\",\"allowedIPV4CidrList\":[ \"10.0.0.0/28\"]}]} },\"singleFirewallEndpointPerVPC\":false,\"allowedIPV4CidrList\":null,\"routeManagementAction\":\"OFF\",\"networkFirewallLoggingConfiguration\":{\"logDestinationConfigs\":[{\"logDestinationType\":\"S3\",\"logType\":\"ALERT\",\"logDestination\":{\"bucketName\":\"s3-bucket-name\"}},{\"logDestinationType\":\"S3\",\"logType\":\"FLOW\",\"logDestination\":{\"bucketName\":\"s3-bucket-name\"}}],\"overrideExistingConfig\":boolean}}"  With custom Availability Zone configuration, you define which specific Availability Zones to create endpoints in by configuring firewallCreationConfig. To configure the Availability Zones in firewallCreationConfig, specify either the availabilityZoneName or availabilityZoneId parameter, not both parameters. To use the distributed deployment model, you must set [PolicyOption](https://docs.aws.amazon.com/fms/2018-01-01/APIReference/API_PolicyOption.html) to NULL.
        ///
        /// * Example: NETWORK_FIREWALL - Distributed deployment model with custom Availability Zone configuration and route management "{\"type\":\"NETWORK_FIREWALL\",\"networkFirewallStatelessRuleGroupReferences\":[{\"resourceARN\":\"arn:aws:network-firewall:us-east-1:123456789011:stateless-rulegroup/test\",\"priority\":1}],\"networkFirewallStatelessDefaultActions\":[\"aws:forward_to_sfe\",\"customActionName\"],\"networkFirewallStatelessFragmentDefaultActions\":[\"aws:forward_to_sfe\",\"fragmentcustomactionname\"],\"networkFirewallStatelessCustomActions\":[{\"actionName\":\"customActionName\",\"actionDefinition\":{\"publishMetricAction\":{\"dimensions\":[{\"value\":\"metricdimensionvalue\"}]}}},{\"actionName\":\"fragmentcustomactionname\",\"actionDefinition\":{\"publishMetricAction\":{\"dimensions\":[{\"value\":\"fragmentmetricdimensionvalue\"}]}}}],\"networkFirewallStatefulRuleGroupReferences\":[{\"resourceARN\":\"arn:aws:network-firewall:us-east-1:123456789011:stateful-rulegroup/test\"}],\"networkFirewallOrchestrationConfig\":{\"firewallCreationConfig\":{\"endpointLocation\":{\"availabilityZoneConfigList\":[{\"availabilityZoneName\":\"us-east-1a\",\"allowedIPV4CidrList\":[\"10.0.0.0/28\"]},{\"availabilityZoneName\":\"us-east-1b\",\"allowedIPV4CidrList\":[\"10.0.0.0/28\"]}]}},\"singleFirewallEndpointPerVPC\":false,\"allowedIPV4CidrList\":null,\"routeManagementAction\":\"MONITOR\",\"routeManagementTargetTypes\":[\"InternetGateway\"],\"routeManagementConfig\":{\"allowCrossAZTrafficIfNoEndpoint\":true}},\"networkFirewallLoggingConfiguration\":{\"logDestinationConfigs\":[{\"logDestinationType\":\"S3\",\"logType\":\"ALERT\",\"logDestination\":{\"bucketName\":\"s3-bucket-name\"}},{\"logDestinationType\":\"S3\",\"logType\":\"FLOW\",\"logDestination\":{\"bucketName\":\"s3-bucket-name\"}}],\"overrideExistingConfig\":boolean}}"  To use the distributed deployment model, you must set [PolicyOption](https://docs.aws.amazon.com/fms/2018-01-01/APIReference/API_PolicyOption.html) to NULL.
        ///
        /// * Example: THIRD_PARTY_FIREWALL"{ "type":"THIRD_PARTY_FIREWALL", "thirdPartyFirewall":"PALO_ALTO_NETWORKS_CLOUD_NGFW", "thirdPartyFirewallConfig":{ "thirdPartyFirewallPolicyList":["global-1"] }, "firewallDeploymentModel":{ "distributedFirewallDeploymentModel":{ "distributedFirewallOrchestrationConfig":{ "firewallCreationConfig":{ "endpointLocation":{ "availabilityZoneConfigList":[ { "availabilityZoneName":"${AvailabilityZone}" } ] } }, "allowedIPV4CidrList":[ ] } } } }"
        ///
        /// * Example: SECURITY_GROUPS_COMMON"{\"type\":\"SECURITY_GROUPS_COMMON\",\"revertManualSecurityGroupChanges\":false,\"exclusiveResourceSecurityGroupManagement\":false, \"applyToAllEC2InstanceENIs\":false,\"securityGroups\":[{\"id\":\" sg-000e55995d61a06bd\"}]}"
        ///
        /// * Example: SECURITY_GROUPS_COMMON - Security group tag distribution ""{\"type\":\"SECURITY_GROUPS_COMMON\",\"securityGroups\":[{\"id\":\"sg-000e55995d61a06bd\"}],\"revertManualSecurityGroupChanges\":true,\"exclusiveResourceSecurityGroupManagement\":false,\"applyToAllEC2InstanceENIs\":false,\"includeSharedVPC\":false,\"enableTagDistribution\":true}"" Firewall Manager automatically distributes tags from the primary group to the security groups created by this policy. To use security group tag distribution, you must also set revertManualSecurityGroupChanges to true, otherwise Firewall Manager won't be able to create the policy. When you enable revertManualSecurityGroupChanges, Firewall Manager identifies and reports when the security groups created by this policy become non-compliant. Firewall Manager won't distrubute system tags added by Amazon Web Services services into the replica security groups. System tags begin with the aws: prefix.
        ///
        /// * Example: Shared VPCs. Apply the preceding policy to resources in shared VPCs as well as to those in VPCs that the account owns "{\"type\":\"SECURITY_GROUPS_COMMON\",\"revertManualSecurityGroupChanges\":false,\"exclusiveResourceSecurityGroupManagement\":false, \"applyToAllEC2InstanceENIs\":false,\"includeSharedVPC\":true,\"securityGroups\":[{\"id\":\" sg-000e55995d61a06bd\"}]}"
        ///
        /// * Example: SECURITY_GROUPS_CONTENT_AUDIT"{\"type\":\"SECURITY_GROUPS_CONTENT_AUDIT\",\"securityGroups\":[{\"id\":\"sg-000e55995d61a06bd\"}],\"securityGroupAction\":{\"type\":\"ALLOW\"}}" The security group action for content audit can be ALLOW or DENY. For ALLOW, all in-scope security group rules must be within the allowed range of the policy's security group rules. For DENY, all in-scope security group rules must not contain a value or a range that matches a rule value or range in the policy security group.
        ///
        /// * Example: SECURITY_GROUPS_USAGE_AUDIT"{\"type\":\"SECURITY_GROUPS_USAGE_AUDIT\",\"deleteUnusedSecurityGroups\":true,\"coalesceRedundantSecurityGroups\":true}"
        ///
        /// * Specification for SHIELD_ADVANCED for Amazon CloudFront distributions "{\"type\":\"SHIELD_ADVANCED\",\"automaticResponseConfiguration\": {\"automaticResponseStatus\":\"ENABLED|IGNORED|DISABLED\", \"automaticResponseAction\":\"BLOCK|COUNT\"}, \"overrideCustomerWebaclClassic\":true|false}" For example: "{\"type\":\"SHIELD_ADVANCED\",\"automaticResponseConfiguration\": {\"automaticResponseStatus\":\"ENABLED\", \"automaticResponseAction\":\"COUNT\"}}" The default value for automaticResponseStatus is IGNORED. The value for automaticResponseAction is only required when automaticResponseStatus is set to ENABLED. The default value for overrideCustomerWebaclClassic is false. For other resource types that you can protect with a Shield Advanced policy, this ManagedServiceData configuration is an empty string.
        ///
        /// * Example: WAFV2"{\"type\":\"WAFV2\",\"preProcessRuleGroups\":[{\"ruleGroupArn\":null,\"overrideAction\":{\"type\":\"NONE\"},\"managedRuleGroupIdentifier\":{\"version\":null,\"vendorName\":\"AWS\",\"managedRuleGroupName\":\"AWSManagedRulesAmazonIpReputationList\"},\"ruleGroupType\":\"ManagedRuleGroup\",\"excludeRules\":[{\"name\":\"NoUserAgent_HEADER\"}]}],\"postProcessRuleGroups\":[],\"defaultAction\":{\"type\":\"ALLOW\"},\"overrideCustomerWebACLAssociation\":false,\"loggingConfiguration\":{\"logDestinationConfigs\":[\"arn:aws:firehose:us-west-2:12345678912:deliverystream/aws-waf-logs-fms-admin-destination\"],\"redactedFields\":[{\"redactedFieldType\":\"SingleHeader\",\"redactedFieldValue\":\"Cookies\"},{\"redactedFieldType\":\"Method\"}]}}" In the loggingConfiguration, you can specify one logDestinationConfigs, you can optionally provide up to 20 redactedFields, and the RedactedFieldType must be one of URI, QUERY_STRING, HEADER, or METHOD.
        ///
        /// * Example: WAFV2 - Firewall Manager support for WAF managed rule group versioning "{\"type\":\"WAFV2\",\"preProcessRuleGroups\":[{\"ruleGroupArn\":null,\"overrideAction\":{\"type\":\"NONE\"},\"managedRuleGroupIdentifier\":{\"versionEnabled\":true,\"version\":\"Version_2.0\",\"vendorName\":\"AWS\",\"managedRuleGroupName\":\"AWSManagedRulesCommonRuleSet\"},\"ruleGroupType\":\"ManagedRuleGroup\",\"excludeRules\":[{\"name\":\"NoUserAgent_HEADER\"}]}],\"postProcessRuleGroups\":[],\"defaultAction\":{\"type\":\"ALLOW\"},\"overrideCustomerWebACLAssociation\":false,\"loggingConfiguration\":{\"logDestinationConfigs\":[\"arn:aws:firehose:us-west-2:12345678912:deliverystream/aws-waf-logs-fms-admin-destination\"],\"redactedFields\":[{\"redactedFieldType\":\"SingleHeader\",\"redactedFieldValue\":\"Cookies\"},{\"redactedFieldType\":\"Method\"}]}}" To use a specific version of a WAF managed rule group in your Firewall Manager policy, you must set versionEnabled to true, and set version to the version you'd like to use. If you don't set versionEnabled to true, or if you omit versionEnabled, then Firewall Manager uses the default version of the WAF managed rule group.
        ///
        /// * Example: WAF Classic"{\"type\": \"WAF\", \"ruleGroups\": [{\"id\":\"12345678-1bcd-9012-efga-0987654321ab\", \"overrideAction\" : {\"type\": \"COUNT\"}}], \"defaultAction\": {\"type\": \"BLOCK\"}}"
        public var managedServiceData: Swift.String?
        /// Contains the Network Firewall firewall policy options to configure a centralized deployment model.
        public var policyOption: FMSClientTypes.PolicyOption?
        /// The service that the policy is using to protect the resources. This specifies the type of policy that is created, either an WAF policy, a Shield Advanced policy, or a security group policy. For security group policies, Firewall Manager supports one security group for each common policy and for each content audit policy. This is an adjustable limit that you can increase by contacting Amazon Web Services Support.
        /// This member is required.
        public var type: FMSClientTypes.SecurityServiceType?

        public init (
            managedServiceData: Swift.String? = nil,
            policyOption: FMSClientTypes.PolicyOption? = nil,
            type: FMSClientTypes.SecurityServiceType? = nil
        )
        {
            self.managedServiceData = managedServiceData
            self.policyOption = policyOption
            self.type = type
        }
    }

}

extension FMSClientTypes {
    public enum SecurityServiceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dnsFirewall
        case importNetworkFirewall
        case networkFirewall
        case securityGroupsCommon
        case securityGroupsContentAudit
        case securityGroupsUsageAudit
        case shieldAdvanced
        case thirdPartyFirewall
        case waf
        case wafv2
        case sdkUnknown(Swift.String)

        public static var allCases: [SecurityServiceType] {
            return [
                .dnsFirewall,
                .importNetworkFirewall,
                .networkFirewall,
                .securityGroupsCommon,
                .securityGroupsContentAudit,
                .securityGroupsUsageAudit,
                .shieldAdvanced,
                .thirdPartyFirewall,
                .waf,
                .wafv2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dnsFirewall: return "DNS_FIREWALL"
            case .importNetworkFirewall: return "IMPORT_NETWORK_FIREWALL"
            case .networkFirewall: return "NETWORK_FIREWALL"
            case .securityGroupsCommon: return "SECURITY_GROUPS_COMMON"
            case .securityGroupsContentAudit: return "SECURITY_GROUPS_CONTENT_AUDIT"
            case .securityGroupsUsageAudit: return "SECURITY_GROUPS_USAGE_AUDIT"
            case .shieldAdvanced: return "SHIELD_ADVANCED"
            case .thirdPartyFirewall: return "THIRD_PARTY_FIREWALL"
            case .waf: return "WAF"
            case .wafv2: return "WAFV2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SecurityServiceType(rawValue: rawValue) ?? SecurityServiceType.sdkUnknown(rawValue)
        }
    }
}

extension FMSClientTypes.StatefulEngineOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ruleOrder = "RuleOrder"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ruleOrder = self.ruleOrder {
            try encodeContainer.encode(ruleOrder.rawValue, forKey: .ruleOrder)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleOrderDecoded = try containerValues.decodeIfPresent(FMSClientTypes.RuleOrder.self, forKey: .ruleOrder)
        ruleOrder = ruleOrderDecoded
    }
}

extension FMSClientTypes {
    /// Configuration settings for the handling of the stateful rule groups in a Network Firewall firewall policy.
    public struct StatefulEngineOptions: Swift.Equatable {
        /// Indicates how to manage the order of stateful rule evaluation for the policy. DEFAULT_ACTION_ORDER is the default behavior. Stateful rules are provided to the rule engine as Suricata compatible strings, and Suricata evaluates them based on certain settings. For more information, see [Evaluation order for stateful rules](https://docs.aws.amazon.com/network-firewall/latest/developerguide/suricata-rule-evaluation-order.html) in the Network Firewall Developer Guide.
        public var ruleOrder: FMSClientTypes.RuleOrder?

        public init (
            ruleOrder: FMSClientTypes.RuleOrder? = nil
        )
        {
            self.ruleOrder = ruleOrder
        }
    }

}

extension FMSClientTypes.StatefulRuleGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case `override` = "Override"
        case priority = "Priority"
        case resourceId = "ResourceId"
        case ruleGroupName = "RuleGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let `override` = self.`override` {
            try encodeContainer.encode(`override`, forKey: .`override`)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let ruleGroupName = self.ruleGroupName {
            try encodeContainer.encode(ruleGroupName, forKey: .ruleGroupName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleGroupName)
        ruleGroupName = ruleGroupNameDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let overrideDecoded = try containerValues.decodeIfPresent(FMSClientTypes.NetworkFirewallStatefulRuleGroupOverride.self, forKey: .override)
        `override` = overrideDecoded
    }
}

extension FMSClientTypes {
    /// Network Firewall stateful rule group, used in a [NetworkFirewallPolicyDescription].
    public struct StatefulRuleGroup: Swift.Equatable {
        /// The action that allows the policy owner to override the behavior of the rule group within a policy.
        public var `override`: FMSClientTypes.NetworkFirewallStatefulRuleGroupOverride?
        /// An integer setting that indicates the order in which to run the stateful rule groups in a single Network Firewall firewall policy. This setting only applies to firewall policies that specify the STRICT_ORDER rule order in the stateful engine options settings. Network Firewall evalutes each stateful rule group against a packet starting with the group that has the lowest priority setting. You must ensure that the priority settings are unique within each policy. For information about You can change the priority settings of your rule groups at any time. To make it easier to insert rule groups later, number them so there's a wide range in between, for example use 100, 200, and so on.
        public var priority: Swift.Int?
        /// The resource ID of the rule group.
        public var resourceId: Swift.String?
        /// The name of the rule group.
        public var ruleGroupName: Swift.String?

        public init (
            `override`: FMSClientTypes.NetworkFirewallStatefulRuleGroupOverride? = nil,
            priority: Swift.Int? = nil,
            resourceId: Swift.String? = nil,
            ruleGroupName: Swift.String? = nil
        )
        {
            self.`override` = `override`
            self.priority = priority
            self.resourceId = resourceId
            self.ruleGroupName = ruleGroupName
        }
    }

}

extension FMSClientTypes.StatelessRuleGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case priority = "Priority"
        case resourceId = "ResourceId"
        case ruleGroupName = "RuleGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if priority != 0 {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let ruleGroupName = self.ruleGroupName {
            try encodeContainer.encode(ruleGroupName, forKey: .ruleGroupName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleGroupName)
        ruleGroupName = ruleGroupNameDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority) ?? 0
        priority = priorityDecoded
    }
}

extension FMSClientTypes {
    /// Network Firewall stateless rule group, used in a [NetworkFirewallPolicyDescription].
    public struct StatelessRuleGroup: Swift.Equatable {
        /// The priority of the rule group. Network Firewall evaluates the stateless rule groups in a firewall policy starting from the lowest priority setting.
        public var priority: Swift.Int
        /// The resource ID of the rule group.
        public var resourceId: Swift.String?
        /// The name of the rule group.
        public var ruleGroupName: Swift.String?

        public init (
            priority: Swift.Int = 0,
            resourceId: Swift.String? = nil,
            ruleGroupName: Swift.String? = nil
        )
        {
            self.priority = priority
            self.resourceId = resourceId
            self.ruleGroupName = ruleGroupName
        }
    }

}

extension FMSClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension FMSClientTypes {
    /// A collection of key:value pairs associated with an Amazon Web Services resource. The key:value pair can be anything you define. Typically, the tag key represents a category (such as "environment") and the tag value represents a specific value within that category (such as "test," "development," or "production"). You can add up to 50 tags to each Amazon Web Services resource.
    public struct Tag: Swift.Equatable {
        /// Part of the key:value pair that defines a tag. You can use a tag key to describe a category of information, such as "customer." Tag keys are case-sensitive.
        /// This member is required.
        public var key: Swift.String?
        /// Part of the key:value pair that defines a tag. You can use a tag value to describe a specific value within a category, such as "companyA" or "companyB." Tag values are case-sensitive.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagList = "TagList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagList = tagList {
            var tagListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagList)
            for tag0 in tagList {
                try tagListContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to return tags for. The Firewall Manager resources that support tagging are policies, applications lists, and protocols lists.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to the resource.
    /// This member is required.
    public var tagList: [FMSClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tagList: [FMSClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagList = tagList
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagList: [FMSClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagList = "TagList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagListContainer = try containerValues.decodeIfPresent([FMSClientTypes.Tag?].self, forKey: .tagList)
        var tagListDecoded0:[FMSClientTypes.Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [FMSClientTypes.Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case invalidOperationException(InvalidOperationException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension FMSClientTypes {
    public enum TargetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case carriergateway
        case egressonlyinternetgateway
        case gateway
        case instance
        case localgateway
        case natgateway
        case networkinterface
        case transitgateway
        case vpcendpoint
        case vpcpeeringconnection
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetType] {
            return [
                .carriergateway,
                .egressonlyinternetgateway,
                .gateway,
                .instance,
                .localgateway,
                .natgateway,
                .networkinterface,
                .transitgateway,
                .vpcendpoint,
                .vpcpeeringconnection,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .carriergateway: return "CARRIER_GATEWAY"
            case .egressonlyinternetgateway: return "EGRESS_ONLY_INTERNET_GATEWAY"
            case .gateway: return "GATEWAY"
            case .instance: return "INSTANCE"
            case .localgateway: return "LOCAL_GATEWAY"
            case .natgateway: return "NAT_GATEWAY"
            case .networkinterface: return "NETWORK_INTERFACE"
            case .transitgateway: return "TRANSIT_GATEWAY"
            case .vpcendpoint: return "VPC_ENDPOINT"
            case .vpcpeeringconnection: return "VPC_PEERING_CONNECTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetType(rawValue: rawValue) ?? TargetType.sdkUnknown(rawValue)
        }
    }
}

extension FMSClientTypes {
    public enum ThirdPartyFirewall: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fortigateCloudNativeFirewall
        case paloAltoNetworksCloudNgfw
        case sdkUnknown(Swift.String)

        public static var allCases: [ThirdPartyFirewall] {
            return [
                .fortigateCloudNativeFirewall,
                .paloAltoNetworksCloudNgfw,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fortigateCloudNativeFirewall: return "FORTIGATE_CLOUD_NATIVE_FIREWALL"
            case .paloAltoNetworksCloudNgfw: return "PALO_ALTO_NETWORKS_CLOUD_NGFW"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ThirdPartyFirewall(rawValue: rawValue) ?? ThirdPartyFirewall.sdkUnknown(rawValue)
        }
    }
}

extension FMSClientTypes {
    public enum ThirdPartyFirewallAssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case notExist
        case offboarding
        case offboardComplete
        case onboarding
        case onboardComplete
        case sdkUnknown(Swift.String)

        public static var allCases: [ThirdPartyFirewallAssociationStatus] {
            return [
                .notExist,
                .offboarding,
                .offboardComplete,
                .onboarding,
                .onboardComplete,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .notExist: return "NOT_EXIST"
            case .offboarding: return "OFFBOARDING"
            case .offboardComplete: return "OFFBOARD_COMPLETE"
            case .onboarding: return "ONBOARDING"
            case .onboardComplete: return "ONBOARD_COMPLETE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ThirdPartyFirewallAssociationStatus(rawValue: rawValue) ?? ThirdPartyFirewallAssociationStatus.sdkUnknown(rawValue)
        }
    }
}

extension FMSClientTypes.ThirdPartyFirewallFirewallPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallPolicyId = "FirewallPolicyId"
        case firewallPolicyName = "FirewallPolicyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallPolicyId = self.firewallPolicyId {
            try encodeContainer.encode(firewallPolicyId, forKey: .firewallPolicyId)
        }
        if let firewallPolicyName = self.firewallPolicyName {
            try encodeContainer.encode(firewallPolicyName, forKey: .firewallPolicyName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallPolicyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallPolicyId)
        firewallPolicyId = firewallPolicyIdDecoded
        let firewallPolicyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallPolicyName)
        firewallPolicyName = firewallPolicyNameDecoded
    }
}

extension FMSClientTypes {
    /// Configures the third-party firewall's firewall policy.
    public struct ThirdPartyFirewallFirewallPolicy: Swift.Equatable {
        /// The ID of the specified firewall policy.
        public var firewallPolicyId: Swift.String?
        /// The name of the specified firewall policy.
        public var firewallPolicyName: Swift.String?

        public init (
            firewallPolicyId: Swift.String? = nil,
            firewallPolicyName: Swift.String? = nil
        )
        {
            self.firewallPolicyId = firewallPolicyId
            self.firewallPolicyName = firewallPolicyName
        }
    }

}

extension FMSClientTypes.ThirdPartyFirewallMissingExpectedRouteTableViolation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "AvailabilityZone"
        case currentRouteTable = "CurrentRouteTable"
        case expectedRouteTable = "ExpectedRouteTable"
        case vpc = "VPC"
        case violationTarget = "ViolationTarget"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let currentRouteTable = self.currentRouteTable {
            try encodeContainer.encode(currentRouteTable, forKey: .currentRouteTable)
        }
        if let expectedRouteTable = self.expectedRouteTable {
            try encodeContainer.encode(expectedRouteTable, forKey: .expectedRouteTable)
        }
        if let vpc = self.vpc {
            try encodeContainer.encode(vpc, forKey: .vpc)
        }
        if let violationTarget = self.violationTarget {
            try encodeContainer.encode(violationTarget, forKey: .violationTarget)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .violationTarget)
        violationTarget = violationTargetDecoded
        let vpcDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpc)
        vpc = vpcDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let currentRouteTableDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentRouteTable)
        currentRouteTable = currentRouteTableDecoded
        let expectedRouteTableDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expectedRouteTable)
        expectedRouteTable = expectedRouteTableDecoded
    }
}

extension FMSClientTypes {
    /// The violation details for a third-party firewall that's not associated with an Firewall Manager managed route table.
    public struct ThirdPartyFirewallMissingExpectedRouteTableViolation: Swift.Equatable {
        /// The Availability Zone of the firewall subnet that's causing the violation.
        public var availabilityZone: Swift.String?
        /// The resource ID of the current route table that's associated with the subnet, if one is available.
        public var currentRouteTable: Swift.String?
        /// The resource ID of the route table that should be associated with the subnet.
        public var expectedRouteTable: Swift.String?
        /// The ID of the third-party firewall or VPC resource that's causing the violation.
        public var violationTarget: Swift.String?
        /// The resource ID of the VPC associated with a fireawll subnet that's causing the violation.
        public var vpc: Swift.String?

        public init (
            availabilityZone: Swift.String? = nil,
            currentRouteTable: Swift.String? = nil,
            expectedRouteTable: Swift.String? = nil,
            violationTarget: Swift.String? = nil,
            vpc: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.currentRouteTable = currentRouteTable
            self.expectedRouteTable = expectedRouteTable
            self.violationTarget = violationTarget
            self.vpc = vpc
        }
    }

}

extension FMSClientTypes.ThirdPartyFirewallMissingFirewallViolation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "AvailabilityZone"
        case targetViolationReason = "TargetViolationReason"
        case vpc = "VPC"
        case violationTarget = "ViolationTarget"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let targetViolationReason = self.targetViolationReason {
            try encodeContainer.encode(targetViolationReason, forKey: .targetViolationReason)
        }
        if let vpc = self.vpc {
            try encodeContainer.encode(vpc, forKey: .vpc)
        }
        if let violationTarget = self.violationTarget {
            try encodeContainer.encode(violationTarget, forKey: .violationTarget)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .violationTarget)
        violationTarget = violationTargetDecoded
        let vpcDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpc)
        vpc = vpcDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let targetViolationReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetViolationReason)
        targetViolationReason = targetViolationReasonDecoded
    }
}

extension FMSClientTypes {
    /// The violation details about a third-party firewall's subnet that doesn't have a Firewall Manager managed firewall in its VPC.
    public struct ThirdPartyFirewallMissingFirewallViolation: Swift.Equatable {
        /// The Availability Zone of the third-party firewall that's causing the violation.
        public var availabilityZone: Swift.String?
        /// The reason the resource is causing this violation, if a reason is available.
        public var targetViolationReason: Swift.String?
        /// The ID of the third-party firewall that's causing the violation.
        public var violationTarget: Swift.String?
        /// The resource ID of the VPC associated with a third-party firewall.
        public var vpc: Swift.String?

        public init (
            availabilityZone: Swift.String? = nil,
            targetViolationReason: Swift.String? = nil,
            violationTarget: Swift.String? = nil,
            vpc: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.targetViolationReason = targetViolationReason
            self.violationTarget = violationTarget
            self.vpc = vpc
        }
    }

}

extension FMSClientTypes.ThirdPartyFirewallMissingSubnetViolation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "AvailabilityZone"
        case targetViolationReason = "TargetViolationReason"
        case vpc = "VPC"
        case violationTarget = "ViolationTarget"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let targetViolationReason = self.targetViolationReason {
            try encodeContainer.encode(targetViolationReason, forKey: .targetViolationReason)
        }
        if let vpc = self.vpc {
            try encodeContainer.encode(vpc, forKey: .vpc)
        }
        if let violationTarget = self.violationTarget {
            try encodeContainer.encode(violationTarget, forKey: .violationTarget)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .violationTarget)
        violationTarget = violationTargetDecoded
        let vpcDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpc)
        vpc = vpcDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let targetViolationReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetViolationReason)
        targetViolationReason = targetViolationReasonDecoded
    }
}

extension FMSClientTypes {
    /// The violation details for a third-party firewall for an Availability Zone that's missing the Firewall Manager managed subnet.
    public struct ThirdPartyFirewallMissingSubnetViolation: Swift.Equatable {
        /// The Availability Zone of a subnet that's causing the violation.
        public var availabilityZone: Swift.String?
        /// The reason the resource is causing the violation, if a reason is available.
        public var targetViolationReason: Swift.String?
        /// The ID of the third-party firewall or VPC resource that's causing the violation.
        public var violationTarget: Swift.String?
        /// The resource ID of the VPC associated with a subnet that's causing the violation.
        public var vpc: Swift.String?

        public init (
            availabilityZone: Swift.String? = nil,
            targetViolationReason: Swift.String? = nil,
            violationTarget: Swift.String? = nil,
            vpc: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.targetViolationReason = targetViolationReason
            self.violationTarget = violationTarget
            self.vpc = vpc
        }
    }

}

extension FMSClientTypes.ThirdPartyFirewallPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallDeploymentModel = "FirewallDeploymentModel"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallDeploymentModel = self.firewallDeploymentModel {
            try encodeContainer.encode(firewallDeploymentModel.rawValue, forKey: .firewallDeploymentModel)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallDeploymentModelDecoded = try containerValues.decodeIfPresent(FMSClientTypes.FirewallDeploymentModel.self, forKey: .firewallDeploymentModel)
        firewallDeploymentModel = firewallDeploymentModelDecoded
    }
}

extension FMSClientTypes {
    /// Configures the deployment model for the third-party firewall.
    public struct ThirdPartyFirewallPolicy: Swift.Equatable {
        /// Defines the deployment model to use for the third-party firewall policy.
        public var firewallDeploymentModel: FMSClientTypes.FirewallDeploymentModel?

        public init (
            firewallDeploymentModel: FMSClientTypes.FirewallDeploymentModel? = nil
        )
        {
            self.firewallDeploymentModel = firewallDeploymentModel
        }
    }

}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to return tags for. The Firewall Manager resources that support tagging are policies, applications lists, and protocols lists.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension FMSClientTypes.ViolationDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberAccount = "MemberAccount"
        case policyId = "PolicyId"
        case resourceDescription = "ResourceDescription"
        case resourceId = "ResourceId"
        case resourceTags = "ResourceTags"
        case resourceType = "ResourceType"
        case resourceViolations = "ResourceViolations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberAccount = self.memberAccount {
            try encodeContainer.encode(memberAccount, forKey: .memberAccount)
        }
        if let policyId = self.policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let resourceDescription = self.resourceDescription {
            try encodeContainer.encode(resourceDescription, forKey: .resourceDescription)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTags)
            for tag0 in resourceTags {
                try resourceTagsContainer.encode(tag0)
            }
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let resourceViolations = resourceViolations {
            var resourceViolationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceViolations)
            for resourceviolation0 in resourceViolations {
                try resourceViolationsContainer.encode(resourceviolation0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let memberAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberAccount)
        memberAccount = memberAccountDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceViolationsContainer = try containerValues.decodeIfPresent([FMSClientTypes.ResourceViolation?].self, forKey: .resourceViolations)
        var resourceViolationsDecoded0:[FMSClientTypes.ResourceViolation]? = nil
        if let resourceViolationsContainer = resourceViolationsContainer {
            resourceViolationsDecoded0 = [FMSClientTypes.ResourceViolation]()
            for structure0 in resourceViolationsContainer {
                if let structure0 = structure0 {
                    resourceViolationsDecoded0?.append(structure0)
                }
            }
        }
        resourceViolations = resourceViolationsDecoded0
        let resourceTagsContainer = try containerValues.decodeIfPresent([FMSClientTypes.Tag?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[FMSClientTypes.Tag]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [FMSClientTypes.Tag]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let resourceDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceDescription)
        resourceDescription = resourceDescriptionDecoded
    }
}

extension FMSClientTypes {
    /// Violations for a resource based on the specified Firewall Manager policy and Amazon Web Services account.
    public struct ViolationDetail: Swift.Equatable {
        /// The Amazon Web Services account that the violation details were requested for.
        /// This member is required.
        public var memberAccount: Swift.String?
        /// The ID of the Firewall Manager policy that the violation details were requested for.
        /// This member is required.
        public var policyId: Swift.String?
        /// Brief description for the requested resource.
        public var resourceDescription: Swift.String?
        /// The resource ID that the violation details were requested for.
        /// This member is required.
        public var resourceId: Swift.String?
        /// The ResourceTag objects associated with the resource.
        public var resourceTags: [FMSClientTypes.Tag]?
        /// The resource type that the violation details were requested for.
        /// This member is required.
        public var resourceType: Swift.String?
        /// List of violations for the requested resource.
        /// This member is required.
        public var resourceViolations: [FMSClientTypes.ResourceViolation]?

        public init (
            memberAccount: Swift.String? = nil,
            policyId: Swift.String? = nil,
            resourceDescription: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceTags: [FMSClientTypes.Tag]? = nil,
            resourceType: Swift.String? = nil,
            resourceViolations: [FMSClientTypes.ResourceViolation]? = nil
        )
        {
            self.memberAccount = memberAccount
            self.policyId = policyId
            self.resourceDescription = resourceDescription
            self.resourceId = resourceId
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.resourceViolations = resourceViolations
        }
    }

}

extension FMSClientTypes {
    public enum ViolationReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case blackholeroutedetected
        case blackholeroutedetectedinfirewallsubnet
        case fmscreatedsecuritygroupedited
        case firewallsubnetisoutofscope
        case firewallsubnetmissingexpectedroute
        case firewallsubnetmissingvpcendpoint
        case internetgatewaymissingexpectedroute
        case internettrafficnotinspected
        case invalidrouteconfiguration
        case missingexpectedroutetable
        case missingfirewall
        case missingfirewallsubnetinaz
        case missingtargetgateway
        case networkfirewallpolicymodified
        case resourceincorrectwebacl
        case resourcemissingdnsfirewall
        case resourcemissingsecuritygroup
        case resourcemissingshieldprotection
        case resourcemissingwebacl
        case resourcemissingwebaclorshieldprotection
        case resourceviolatesauditsecuritygroup
        case routehasoutofscopeendpoint
        case securitygroupredundant
        case securitygroupunused
        case trafficinspectioncrossesazboundary
        case unexpectedfirewallroutes
        case unexpectedtargetgatewayroutes
        case webaclmissingrulegroup
        case sdkUnknown(Swift.String)

        public static var allCases: [ViolationReason] {
            return [
                .blackholeroutedetected,
                .blackholeroutedetectedinfirewallsubnet,
                .fmscreatedsecuritygroupedited,
                .firewallsubnetisoutofscope,
                .firewallsubnetmissingexpectedroute,
                .firewallsubnetmissingvpcendpoint,
                .internetgatewaymissingexpectedroute,
                .internettrafficnotinspected,
                .invalidrouteconfiguration,
                .missingexpectedroutetable,
                .missingfirewall,
                .missingfirewallsubnetinaz,
                .missingtargetgateway,
                .networkfirewallpolicymodified,
                .resourceincorrectwebacl,
                .resourcemissingdnsfirewall,
                .resourcemissingsecuritygroup,
                .resourcemissingshieldprotection,
                .resourcemissingwebacl,
                .resourcemissingwebaclorshieldprotection,
                .resourceviolatesauditsecuritygroup,
                .routehasoutofscopeendpoint,
                .securitygroupredundant,
                .securitygroupunused,
                .trafficinspectioncrossesazboundary,
                .unexpectedfirewallroutes,
                .unexpectedtargetgatewayroutes,
                .webaclmissingrulegroup,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .blackholeroutedetected: return "BLACK_HOLE_ROUTE_DETECTED"
            case .blackholeroutedetectedinfirewallsubnet: return "BLACK_HOLE_ROUTE_DETECTED_IN_FIREWALL_SUBNET"
            case .fmscreatedsecuritygroupedited: return "FMS_CREATED_SECURITY_GROUP_EDITED"
            case .firewallsubnetisoutofscope: return "FIREWALL_SUBNET_IS_OUT_OF_SCOPE"
            case .firewallsubnetmissingexpectedroute: return "FIREWALL_SUBNET_MISSING_EXPECTED_ROUTE"
            case .firewallsubnetmissingvpcendpoint: return "FIREWALL_SUBNET_MISSING_VPCE_ENDPOINT"
            case .internetgatewaymissingexpectedroute: return "INTERNET_GATEWAY_MISSING_EXPECTED_ROUTE"
            case .internettrafficnotinspected: return "INTERNET_TRAFFIC_NOT_INSPECTED"
            case .invalidrouteconfiguration: return "INVALID_ROUTE_CONFIGURATION"
            case .missingexpectedroutetable: return "MISSING_EXPECTED_ROUTE_TABLE"
            case .missingfirewall: return "MISSING_FIREWALL"
            case .missingfirewallsubnetinaz: return "MISSING_FIREWALL_SUBNET_IN_AZ"
            case .missingtargetgateway: return "MISSING_TARGET_GATEWAY"
            case .networkfirewallpolicymodified: return "NETWORK_FIREWALL_POLICY_MODIFIED"
            case .resourceincorrectwebacl: return "RESOURCE_INCORRECT_WEB_ACL"
            case .resourcemissingdnsfirewall: return "RESOURCE_MISSING_DNS_FIREWALL"
            case .resourcemissingsecuritygroup: return "RESOURCE_MISSING_SECURITY_GROUP"
            case .resourcemissingshieldprotection: return "RESOURCE_MISSING_SHIELD_PROTECTION"
            case .resourcemissingwebacl: return "RESOURCE_MISSING_WEB_ACL"
            case .resourcemissingwebaclorshieldprotection: return "RESOURCE_MISSING_WEB_ACL_OR_SHIELD_PROTECTION"
            case .resourceviolatesauditsecuritygroup: return "RESOURCE_VIOLATES_AUDIT_SECURITY_GROUP"
            case .routehasoutofscopeendpoint: return "ROUTE_HAS_OUT_OF_SCOPE_ENDPOINT"
            case .securitygroupredundant: return "SECURITY_GROUP_REDUNDANT"
            case .securitygroupunused: return "SECURITY_GROUP_UNUSED"
            case .trafficinspectioncrossesazboundary: return "TRAFFIC_INSPECTION_CROSSES_AZ_BOUNDARY"
            case .unexpectedfirewallroutes: return "UNEXPECTED_FIREWALL_ROUTES"
            case .unexpectedtargetgatewayroutes: return "UNEXPECTED_TARGET_GATEWAY_ROUTES"
            case .webaclmissingrulegroup: return "WEB_ACL_MISSING_RULE_GROUP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ViolationReason(rawValue: rawValue) ?? ViolationReason.sdkUnknown(rawValue)
        }
    }
}
