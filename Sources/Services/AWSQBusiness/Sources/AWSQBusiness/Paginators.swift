//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import Foundation
import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension QBusinessClient {
    /// Paginate over `[GetChatControlsConfigurationOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetChatControlsConfigurationInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetChatControlsConfigurationOutput`
    public func getChatControlsConfigurationPaginated(input: GetChatControlsConfigurationInput) -> ClientRuntime.PaginatorSequence<GetChatControlsConfigurationInput, GetChatControlsConfigurationOutput> {
        return ClientRuntime.PaginatorSequence<GetChatControlsConfigurationInput, GetChatControlsConfigurationOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getChatControlsConfiguration(input:))
    }
}

extension GetChatControlsConfigurationInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetChatControlsConfigurationInput {
        return GetChatControlsConfigurationInput(
            applicationId: self.applicationId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == GetChatControlsConfigurationInput, OperationStackOutput == GetChatControlsConfigurationOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getChatControlsConfigurationPaginated`
    /// to access the nested member `[QBusinessClientTypes.TopicConfiguration]`
    /// - Returns: `[QBusinessClientTypes.TopicConfiguration]`
    public func topicConfigurations() async throws -> [QBusinessClientTypes.TopicConfiguration] {
        return try await self.asyncCompactMap { item in item.topicConfigurations }
    }
}
extension QBusinessClient {
    /// Paginate over `[ListAttachmentsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAttachmentsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAttachmentsOutput`
    public func listAttachmentsPaginated(input: ListAttachmentsInput) -> ClientRuntime.PaginatorSequence<ListAttachmentsInput, ListAttachmentsOutput> {
        return ClientRuntime.PaginatorSequence<ListAttachmentsInput, ListAttachmentsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAttachments(input:))
    }
}

extension ListAttachmentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAttachmentsInput {
        return ListAttachmentsInput(
            applicationId: self.applicationId,
            conversationId: self.conversationId,
            maxResults: self.maxResults,
            nextToken: token,
            userId: self.userId
        )}
}

extension PaginatorSequence where OperationStackInput == ListAttachmentsInput, OperationStackOutput == ListAttachmentsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAttachmentsPaginated`
    /// to access the nested member `[QBusinessClientTypes.Attachment]`
    /// - Returns: `[QBusinessClientTypes.Attachment]`
    public func attachments() async throws -> [QBusinessClientTypes.Attachment] {
        return try await self.asyncCompactMap { item in item.attachments }
    }
}
extension QBusinessClient {
    /// Paginate over `[ListChatResponseConfigurationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListChatResponseConfigurationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListChatResponseConfigurationsOutput`
    public func listChatResponseConfigurationsPaginated(input: ListChatResponseConfigurationsInput) -> ClientRuntime.PaginatorSequence<ListChatResponseConfigurationsInput, ListChatResponseConfigurationsOutput> {
        return ClientRuntime.PaginatorSequence<ListChatResponseConfigurationsInput, ListChatResponseConfigurationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listChatResponseConfigurations(input:))
    }
}

extension ListChatResponseConfigurationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListChatResponseConfigurationsInput {
        return ListChatResponseConfigurationsInput(
            applicationId: self.applicationId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListChatResponseConfigurationsInput, OperationStackOutput == ListChatResponseConfigurationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listChatResponseConfigurationsPaginated`
    /// to access the nested member `[QBusinessClientTypes.ChatResponseConfiguration]`
    /// - Returns: `[QBusinessClientTypes.ChatResponseConfiguration]`
    public func chatResponseConfigurations() async throws -> [QBusinessClientTypes.ChatResponseConfiguration] {
        return try await self.asyncCompactMap { item in item.chatResponseConfigurations }
    }
}
extension QBusinessClient {
    /// Paginate over `[ListConversationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListConversationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListConversationsOutput`
    public func listConversationsPaginated(input: ListConversationsInput) -> ClientRuntime.PaginatorSequence<ListConversationsInput, ListConversationsOutput> {
        return ClientRuntime.PaginatorSequence<ListConversationsInput, ListConversationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listConversations(input:))
    }
}

extension ListConversationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListConversationsInput {
        return ListConversationsInput(
            applicationId: self.applicationId,
            maxResults: self.maxResults,
            nextToken: token,
            userId: self.userId
        )}
}

extension PaginatorSequence where OperationStackInput == ListConversationsInput, OperationStackOutput == ListConversationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listConversationsPaginated`
    /// to access the nested member `[QBusinessClientTypes.Conversation]`
    /// - Returns: `[QBusinessClientTypes.Conversation]`
    public func conversations() async throws -> [QBusinessClientTypes.Conversation] {
        return try await self.asyncCompactMap { item in item.conversations }
    }
}
extension QBusinessClient {
    /// Paginate over `[ListDataSourceSyncJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDataSourceSyncJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDataSourceSyncJobsOutput`
    public func listDataSourceSyncJobsPaginated(input: ListDataSourceSyncJobsInput) -> ClientRuntime.PaginatorSequence<ListDataSourceSyncJobsInput, ListDataSourceSyncJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListDataSourceSyncJobsInput, ListDataSourceSyncJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDataSourceSyncJobs(input:))
    }
}

extension ListDataSourceSyncJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDataSourceSyncJobsInput {
        return ListDataSourceSyncJobsInput(
            applicationId: self.applicationId,
            dataSourceId: self.dataSourceId,
            endTime: self.endTime,
            indexId: self.indexId,
            maxResults: self.maxResults,
            nextToken: token,
            startTime: self.startTime,
            statusFilter: self.statusFilter
        )}
}

extension PaginatorSequence where OperationStackInput == ListDataSourceSyncJobsInput, OperationStackOutput == ListDataSourceSyncJobsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listDataSourceSyncJobsPaginated`
    /// to access the nested member `[QBusinessClientTypes.DataSourceSyncJob]`
    /// - Returns: `[QBusinessClientTypes.DataSourceSyncJob]`
    public func history() async throws -> [QBusinessClientTypes.DataSourceSyncJob] {
        return try await self.asyncCompactMap { item in item.history }
    }
}
extension QBusinessClient {
    /// Paginate over `[ListDocumentsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDocumentsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDocumentsOutput`
    public func listDocumentsPaginated(input: ListDocumentsInput) -> ClientRuntime.PaginatorSequence<ListDocumentsInput, ListDocumentsOutput> {
        return ClientRuntime.PaginatorSequence<ListDocumentsInput, ListDocumentsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDocuments(input:))
    }
}

extension ListDocumentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDocumentsInput {
        return ListDocumentsInput(
            applicationId: self.applicationId,
            dataSourceIds: self.dataSourceIds,
            indexId: self.indexId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListDocumentsInput, OperationStackOutput == ListDocumentsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listDocumentsPaginated`
    /// to access the nested member `[QBusinessClientTypes.DocumentDetails]`
    /// - Returns: `[QBusinessClientTypes.DocumentDetails]`
    public func documentDetailList() async throws -> [QBusinessClientTypes.DocumentDetails] {
        return try await self.asyncCompactMap { item in item.documentDetailList }
    }
}
extension QBusinessClient {
    /// Paginate over `[ListGroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListGroupsOutput`
    public func listGroupsPaginated(input: ListGroupsInput) -> ClientRuntime.PaginatorSequence<ListGroupsInput, ListGroupsOutput> {
        return ClientRuntime.PaginatorSequence<ListGroupsInput, ListGroupsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listGroups(input:))
    }
}

extension ListGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListGroupsInput {
        return ListGroupsInput(
            applicationId: self.applicationId,
            dataSourceId: self.dataSourceId,
            indexId: self.indexId,
            maxResults: self.maxResults,
            nextToken: token,
            updatedEarlierThan: self.updatedEarlierThan
        )}
}

extension PaginatorSequence where OperationStackInput == ListGroupsInput, OperationStackOutput == ListGroupsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listGroupsPaginated`
    /// to access the nested member `[QBusinessClientTypes.GroupSummary]`
    /// - Returns: `[QBusinessClientTypes.GroupSummary]`
    public func items() async throws -> [QBusinessClientTypes.GroupSummary] {
        return try await self.asyncCompactMap { item in item.items }
    }
}
extension QBusinessClient {
    /// Paginate over `[ListMessagesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListMessagesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListMessagesOutput`
    public func listMessagesPaginated(input: ListMessagesInput) -> ClientRuntime.PaginatorSequence<ListMessagesInput, ListMessagesOutput> {
        return ClientRuntime.PaginatorSequence<ListMessagesInput, ListMessagesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listMessages(input:))
    }
}

extension ListMessagesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMessagesInput {
        return ListMessagesInput(
            applicationId: self.applicationId,
            conversationId: self.conversationId,
            maxResults: self.maxResults,
            nextToken: token,
            userId: self.userId
        )}
}

extension PaginatorSequence where OperationStackInput == ListMessagesInput, OperationStackOutput == ListMessagesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listMessagesPaginated`
    /// to access the nested member `[QBusinessClientTypes.Message]`
    /// - Returns: `[QBusinessClientTypes.Message]`
    public func messages() async throws -> [QBusinessClientTypes.Message] {
        return try await self.asyncCompactMap { item in item.messages }
    }
}
extension QBusinessClient {
    /// Paginate over `[ListPluginActionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPluginActionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPluginActionsOutput`
    public func listPluginActionsPaginated(input: ListPluginActionsInput) -> ClientRuntime.PaginatorSequence<ListPluginActionsInput, ListPluginActionsOutput> {
        return ClientRuntime.PaginatorSequence<ListPluginActionsInput, ListPluginActionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listPluginActions(input:))
    }
}

extension ListPluginActionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPluginActionsInput {
        return ListPluginActionsInput(
            applicationId: self.applicationId,
            maxResults: self.maxResults,
            nextToken: token,
            pluginId: self.pluginId
        )}
}

extension PaginatorSequence where OperationStackInput == ListPluginActionsInput, OperationStackOutput == ListPluginActionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listPluginActionsPaginated`
    /// to access the nested member `[QBusinessClientTypes.ActionSummary]`
    /// - Returns: `[QBusinessClientTypes.ActionSummary]`
    public func items() async throws -> [QBusinessClientTypes.ActionSummary] {
        return try await self.asyncCompactMap { item in item.items }
    }
}
extension QBusinessClient {
    /// Paginate over `[ListPluginTypeActionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPluginTypeActionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPluginTypeActionsOutput`
    public func listPluginTypeActionsPaginated(input: ListPluginTypeActionsInput) -> ClientRuntime.PaginatorSequence<ListPluginTypeActionsInput, ListPluginTypeActionsOutput> {
        return ClientRuntime.PaginatorSequence<ListPluginTypeActionsInput, ListPluginTypeActionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listPluginTypeActions(input:))
    }
}

extension ListPluginTypeActionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPluginTypeActionsInput {
        return ListPluginTypeActionsInput(
            maxResults: self.maxResults,
            nextToken: token,
            pluginType: self.pluginType
        )}
}

extension PaginatorSequence where OperationStackInput == ListPluginTypeActionsInput, OperationStackOutput == ListPluginTypeActionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listPluginTypeActionsPaginated`
    /// to access the nested member `[QBusinessClientTypes.ActionSummary]`
    /// - Returns: `[QBusinessClientTypes.ActionSummary]`
    public func items() async throws -> [QBusinessClientTypes.ActionSummary] {
        return try await self.asyncCompactMap { item in item.items }
    }
}
extension QBusinessClient {
    /// Paginate over `[ListPluginTypeMetadataOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPluginTypeMetadataInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPluginTypeMetadataOutput`
    public func listPluginTypeMetadataPaginated(input: ListPluginTypeMetadataInput) -> ClientRuntime.PaginatorSequence<ListPluginTypeMetadataInput, ListPluginTypeMetadataOutput> {
        return ClientRuntime.PaginatorSequence<ListPluginTypeMetadataInput, ListPluginTypeMetadataOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listPluginTypeMetadata(input:))
    }
}

extension ListPluginTypeMetadataInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPluginTypeMetadataInput {
        return ListPluginTypeMetadataInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListPluginTypeMetadataInput, OperationStackOutput == ListPluginTypeMetadataOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listPluginTypeMetadataPaginated`
    /// to access the nested member `[QBusinessClientTypes.PluginTypeMetadataSummary]`
    /// - Returns: `[QBusinessClientTypes.PluginTypeMetadataSummary]`
    public func items() async throws -> [QBusinessClientTypes.PluginTypeMetadataSummary] {
        return try await self.asyncCompactMap { item in item.items }
    }
}
extension QBusinessClient {
    /// Paginate over `[ListSubscriptionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSubscriptionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSubscriptionsOutput`
    public func listSubscriptionsPaginated(input: ListSubscriptionsInput) -> ClientRuntime.PaginatorSequence<ListSubscriptionsInput, ListSubscriptionsOutput> {
        return ClientRuntime.PaginatorSequence<ListSubscriptionsInput, ListSubscriptionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listSubscriptions(input:))
    }
}

extension ListSubscriptionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSubscriptionsInput {
        return ListSubscriptionsInput(
            applicationId: self.applicationId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListSubscriptionsInput, OperationStackOutput == ListSubscriptionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listSubscriptionsPaginated`
    /// to access the nested member `[QBusinessClientTypes.Subscription]`
    /// - Returns: `[QBusinessClientTypes.Subscription]`
    public func subscriptions() async throws -> [QBusinessClientTypes.Subscription] {
        return try await self.asyncCompactMap { item in item.subscriptions }
    }
}
extension QBusinessClient {
    /// Paginate over `[SearchRelevantContentOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[SearchRelevantContentInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `SearchRelevantContentOutput`
    public func searchRelevantContentPaginated(input: SearchRelevantContentInput) -> ClientRuntime.PaginatorSequence<SearchRelevantContentInput, SearchRelevantContentOutput> {
        return ClientRuntime.PaginatorSequence<SearchRelevantContentInput, SearchRelevantContentOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.searchRelevantContent(input:))
    }
}

extension SearchRelevantContentInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchRelevantContentInput {
        return SearchRelevantContentInput(
            applicationId: self.applicationId,
            attributeFilter: self.attributeFilter,
            contentSource: self.contentSource,
            maxResults: self.maxResults,
            nextToken: token,
            queryText: self.queryText
        )}
}

extension PaginatorSequence where OperationStackInput == SearchRelevantContentInput, OperationStackOutput == SearchRelevantContentOutput {
    /// This paginator transforms the `AsyncSequence` returned by `searchRelevantContentPaginated`
    /// to access the nested member `[QBusinessClientTypes.RelevantContent]`
    /// - Returns: `[QBusinessClientTypes.RelevantContent]`
    public func relevantContent() async throws -> [QBusinessClientTypes.RelevantContent] {
        return try await self.asyncCompactMap { item in item.relevantContent }
    }
}
