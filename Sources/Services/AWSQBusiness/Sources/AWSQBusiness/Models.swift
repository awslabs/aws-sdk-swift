//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import SmithyJSON
import class ClientRuntime.Indirect
import class SmithyEventStreams.DefaultMessageDecoder
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyEventStreamsAPI.MessageType
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.mapWritingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.optionalFormOf
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.Document
import struct Smithy.URIQueryItem
import struct SmithyEventStreams.DefaultMessageDecoderStream
import struct SmithyEventStreamsAPI.Header
import struct SmithyEventStreamsAPI.Message
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter
import typealias SmithyEventStreamsAPI.MarshalClosure
import typealias SmithyEventStreamsAPI.UnmarshalClosure


public struct PutFeedbackOutput: Swift.Sendable {

    public init() { }
}

extension QBusinessClientTypes {

    public enum MemberRelation: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case and
        case or
        case sdkUnknown(Swift.String)

        public static var allCases: [MemberRelation] {
            return [
                .and,
                .or
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .and: return "AND"
            case .or: return "OR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QBusinessClientTypes {

    public enum ReadAccessType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [ReadAccessType] {
            return [
                .allow,
                .deny
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allow: return "ALLOW"
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QBusinessClientTypes {

    public enum MembershipType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case datasource
        case index
        case sdkUnknown(Swift.String)

        public static var allCases: [MembershipType] {
            return [
                .datasource,
                .index
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .datasource: return "DATASOURCE"
            case .index: return "INDEX"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QBusinessClientTypes {

    /// Provides information about a group associated with the principal.
    public struct PrincipalGroup: Swift.Sendable {
        /// Provides information about whether to allow or deny access to the principal.
        /// This member is required.
        public var access: QBusinessClientTypes.ReadAccessType?
        /// The type of group.
        public var membershipType: QBusinessClientTypes.MembershipType?
        /// The name of the group.
        public var name: Swift.String?

        public init(
            access: QBusinessClientTypes.ReadAccessType? = nil,
            membershipType: QBusinessClientTypes.MembershipType? = nil,
            name: Swift.String? = nil
        )
        {
            self.access = access
            self.membershipType = membershipType
            self.name = name
        }
    }
}

extension QBusinessClientTypes {

    /// Provides information about a user associated with a principal.
    public struct PrincipalUser: Swift.Sendable {
        /// Provides information about whether to allow or deny access to the principal.
        /// This member is required.
        public var access: QBusinessClientTypes.ReadAccessType?
        /// The identifier of the user.
        public var id: Swift.String?
        /// The type of group.
        public var membershipType: QBusinessClientTypes.MembershipType?

        public init(
            access: QBusinessClientTypes.ReadAccessType? = nil,
            id: Swift.String? = nil,
            membershipType: QBusinessClientTypes.MembershipType? = nil
        )
        {
            self.access = access
            self.id = id
            self.membershipType = membershipType
        }
    }
}

extension QBusinessClientTypes {

    /// Provides user and group information used for filtering documents to use for generating Amazon Q Business conversation responses.
    public enum Principal: Swift.Sendable {
        /// The user associated with the principal.
        case user(QBusinessClientTypes.PrincipalUser)
        /// The group associated with the principal.
        case group(QBusinessClientTypes.PrincipalGroup)
        case sdkUnknown(Swift.String)
    }
}

extension QBusinessClientTypes {

    /// A list of principals. Each principal can be either a USER or a GROUP and can be designated document access permissions of either ALLOW or DENY.
    public struct AccessControl: Swift.Sendable {
        /// Describes the member relation within a principal list.
        public var memberRelation: QBusinessClientTypes.MemberRelation?
        /// Contains a list of principals, where a principal can be either a USER or a GROUP. Each principal can be have the following type of document access: ALLOW or DENY.
        /// This member is required.
        public var principals: [QBusinessClientTypes.Principal]?

        public init(
            memberRelation: QBusinessClientTypes.MemberRelation? = nil,
            principals: [QBusinessClientTypes.Principal]? = nil
        )
        {
            self.memberRelation = memberRelation
            self.principals = principals
        }
    }
}

extension QBusinessClientTypes {

    /// Used to configure access permissions for a document.
    public struct AccessConfiguration: Swift.Sendable {
        /// A list of AccessControlList objects.
        /// This member is required.
        public var accessControls: [QBusinessClientTypes.AccessControl]?
        /// Describes the member relation within the AccessControlList object.
        public var memberRelation: QBusinessClientTypes.MemberRelation?

        public init(
            accessControls: [QBusinessClientTypes.AccessControl]? = nil,
            memberRelation: QBusinessClientTypes.MemberRelation? = nil
        )
        {
            self.accessControls = accessControls
            self.memberRelation = memberRelation
        }
    }
}

/// You don't have access to perform this action. Make sure you have the required permission policies and user accounts and try again.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension QBusinessClientTypes {

    /// A user input field in an plugin action execution payload.
    public struct ActionExecutionPayloadField: Swift.Sendable {
        /// The content of a user input field in an plugin action execution payload.
        /// This member is required.
        public var value: Smithy.Document?

        public init(
            value: Smithy.Document? = nil
        )
        {
            self.value = value
        }
    }
}

extension QBusinessClientTypes {

    /// Performs an Amazon Q Business plugin action during a non-streaming chat conversation.
    public struct ActionExecution: Swift.Sendable {
        /// A mapping of field names to the field values in input that an end user provides to Amazon Q Business requests to perform their plugin action.
        /// This member is required.
        public var payload: [Swift.String: QBusinessClientTypes.ActionExecutionPayloadField]?
        /// A string used to retain information about the hierarchical contexts within an action execution event payload.
        /// This member is required.
        public var payloadFieldNameSeparator: Swift.String?
        /// The identifier of the plugin the action is attached to.
        /// This member is required.
        public var pluginId: Swift.String?

        public init(
            payload: [Swift.String: QBusinessClientTypes.ActionExecutionPayloadField]? = nil,
            payloadFieldNameSeparator: Swift.String? = nil,
            pluginId: Swift.String? = nil
        )
        {
            self.payload = payload
            self.payloadFieldNameSeparator = payloadFieldNameSeparator
            self.pluginId = pluginId
        }
    }
}

extension QBusinessClientTypes {

    /// A request from an end user signalling an intent to perform an Amazon Q Business plugin action during a streaming chat.
    public struct ActionExecutionEvent: Swift.Sendable {
        /// A mapping of field names to the field values in input that an end user provides to Amazon Q Business requests to perform their plugin action.
        /// This member is required.
        public var payload: [Swift.String: QBusinessClientTypes.ActionExecutionPayloadField]?
        /// A string used to retain information about the hierarchical contexts within a action execution event payload.
        /// This member is required.
        public var payloadFieldNameSeparator: Swift.String?
        /// The identifier of the plugin for which the action is being requested.
        /// This member is required.
        public var pluginId: Swift.String?

        public init(
            payload: [Swift.String: QBusinessClientTypes.ActionExecutionPayloadField]? = nil,
            payloadFieldNameSeparator: Swift.String? = nil,
            pluginId: Swift.String? = nil
        )
        {
            self.payload = payload
            self.payloadFieldNameSeparator = payloadFieldNameSeparator
            self.pluginId = pluginId
        }
    }
}

extension QBusinessClientTypes {

    public enum ActionPayloadFieldType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case array
        case boolean
        case number
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionPayloadFieldType] {
            return [
                .array,
                .boolean,
                .number,
                .string
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .array: return "ARRAY"
            case .boolean: return "BOOLEAN"
            case .number: return "NUMBER"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QBusinessClientTypes {

    /// Information about the field values that an end user can use to provide to Amazon Q Business for Amazon Q Business to perform the requested plugin action.
    public struct ActionReviewPayloadFieldAllowedValue: Swift.Sendable {
        /// The name of the field.
        public var displayValue: Smithy.Document?
        /// The field value.
        public var value: Smithy.Document?

        public init(
            displayValue: Smithy.Document? = nil,
            value: Smithy.Document? = nil
        )
        {
            self.displayValue = displayValue
            self.value = value
        }
    }
}

extension QBusinessClientTypes {

    /// A user input field in an plugin action review payload.
    public struct ActionReviewPayloadField: Swift.Sendable {
        /// The expected data format for the action review input field value. For example, in PTO request, from and to would be of datetime allowed format.
        public var allowedFormat: Swift.String?
        /// Information about the field values that an end user can use to provide to Amazon Q Business for Amazon Q Business to perform the requested plugin action.
        public var allowedValues: [QBusinessClientTypes.ActionReviewPayloadFieldAllowedValue]?
        /// Use to create a custom form with array fields (fields with nested objects inside an array).
        public var arrayItemJsonSchema: Smithy.Document?
        /// The field level description of each action review input field. This could be an explanation of the field. In the Amazon Q Business web experience, these descriptions could be used to display as tool tips to help users understand the field.
        public var displayDescription: Swift.String?
        /// The name of the field.
        public var displayName: Swift.String?
        /// The display order of fields in a payload.
        public var displayOrder: Swift.Int?
        /// Information about whether the field is required.
        public var `required`: Swift.Bool?
        /// The type of field.
        public var type: QBusinessClientTypes.ActionPayloadFieldType?
        /// The field value.
        public var value: Smithy.Document?

        public init(
            allowedFormat: Swift.String? = nil,
            allowedValues: [QBusinessClientTypes.ActionReviewPayloadFieldAllowedValue]? = nil,
            arrayItemJsonSchema: Smithy.Document? = nil,
            displayDescription: Swift.String? = nil,
            displayName: Swift.String? = nil,
            displayOrder: Swift.Int? = nil,
            `required`: Swift.Bool? = nil,
            type: QBusinessClientTypes.ActionPayloadFieldType? = nil,
            value: Smithy.Document? = nil
        )
        {
            self.allowedFormat = allowedFormat
            self.allowedValues = allowedValues
            self.arrayItemJsonSchema = arrayItemJsonSchema
            self.displayDescription = displayDescription
            self.displayName = displayName
            self.displayOrder = displayOrder
            self.`required` = `required`
            self.type = type
            self.value = value
        }
    }
}

extension QBusinessClientTypes {

    public enum PluginType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case custom
        case jira
        case salesforce
        case serviceNow
        case zendesk
        case sdkUnknown(Swift.String)

        public static var allCases: [PluginType] {
            return [
                .custom,
                .jira,
                .salesforce,
                .serviceNow,
                .zendesk
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .custom: return "CUSTOM"
            case .jira: return "JIRA"
            case .salesforce: return "SALESFORCE"
            case .serviceNow: return "SERVICE_NOW"
            case .zendesk: return "ZENDESK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QBusinessClientTypes {

    /// An output event that Amazon Q Business returns to an user who wants to perform a plugin action during a non-streaming chat conversation. It contains information about the selected action with a list of possible user input fields, some pre-populated by Amazon Q Business.
    public struct ActionReview: Swift.Sendable {
        /// Field values that an end user needs to provide to Amazon Q Business for Amazon Q Business to perform the requested plugin action.
        public var payload: [Swift.String: QBusinessClientTypes.ActionReviewPayloadField]?
        /// A string used to retain information about the hierarchical contexts within an action review payload.
        public var payloadFieldNameSeparator: Swift.String?
        /// The identifier of the plugin associated with the action review.
        public var pluginId: Swift.String?
        /// The type of plugin.
        public var pluginType: QBusinessClientTypes.PluginType?

        public init(
            payload: [Swift.String: QBusinessClientTypes.ActionReviewPayloadField]? = nil,
            payloadFieldNameSeparator: Swift.String? = nil,
            pluginId: Swift.String? = nil,
            pluginType: QBusinessClientTypes.PluginType? = nil
        )
        {
            self.payload = payload
            self.payloadFieldNameSeparator = payloadFieldNameSeparator
            self.pluginId = pluginId
            self.pluginType = pluginType
        }
    }
}

extension QBusinessClientTypes {

    /// An output event that Amazon Q Business returns to an user who wants to perform a plugin action during a streaming chat conversation. It contains information about the selected action with a list of possible user input fields, some pre-populated by Amazon Q Business.
    public struct ActionReviewEvent: Swift.Sendable {
        /// The identifier of the conversation with which the action review event is associated.
        public var conversationId: Swift.String?
        /// Field values that an end user needs to provide to Amazon Q Business for Amazon Q Business to perform the requested plugin action.
        public var payload: [Swift.String: QBusinessClientTypes.ActionReviewPayloadField]?
        /// A string used to retain information about the hierarchical contexts within an action review event payload.
        public var payloadFieldNameSeparator: Swift.String?
        /// The identifier of the plugin associated with the action review event.
        public var pluginId: Swift.String?
        /// The type of plugin.
        public var pluginType: QBusinessClientTypes.PluginType?
        /// The identifier of an Amazon Q Business AI generated associated with the action review event.
        public var systemMessageId: Swift.String?
        /// The identifier of the conversation with which the plugin action is associated.
        public var userMessageId: Swift.String?

        public init(
            conversationId: Swift.String? = nil,
            payload: [Swift.String: QBusinessClientTypes.ActionReviewPayloadField]? = nil,
            payloadFieldNameSeparator: Swift.String? = nil,
            pluginId: Swift.String? = nil,
            pluginType: QBusinessClientTypes.PluginType? = nil,
            systemMessageId: Swift.String? = nil,
            userMessageId: Swift.String? = nil
        )
        {
            self.conversationId = conversationId
            self.payload = payload
            self.payloadFieldNameSeparator = payloadFieldNameSeparator
            self.pluginId = pluginId
            self.pluginType = pluginType
            self.systemMessageId = systemMessageId
            self.userMessageId = userMessageId
        }
    }
}

extension QBusinessClientTypes {

    /// Information required for Amazon Q Business to find a specific file in an Amazon S3 bucket.
    public struct S3: Swift.Sendable {
        /// The name of the S3 bucket that contains the file.
        /// This member is required.
        public var bucket: Swift.String?
        /// The name of the file.
        /// This member is required.
        public var key: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.key = key
        }
    }
}

extension QBusinessClientTypes {

    /// Contains details about the OpenAPI schema for a custom plugin. For more information, see [custom plugin OpenAPI schemas](https://docs.aws.amazon.com/amazonq/latest/qbusiness-ug/custom-plugin.html#plugins-api-schema). You can either include the schema directly in the payload field or you can upload it to an S3 bucket and specify the S3 bucket location in the s3 field.
    public enum APISchema: Swift.Sendable {
        /// The JSON or YAML-formatted payload defining the OpenAPI schema for a custom plugin.
        case payload(Swift.String)
        /// Contains details about the S3 object containing the OpenAPI schema for a custom plugin. The schema could be in either JSON or YAML format.
        case s3(QBusinessClientTypes.S3)
        case sdkUnknown(Swift.String)
    }
}

extension QBusinessClientTypes {

    public enum APISchemaType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case openApiV3
        case sdkUnknown(Swift.String)

        public static var allCases: [APISchemaType] {
            return [
                .openApiV3
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .openApiV3: return "OPEN_API_V3"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QBusinessClientTypes {

    public enum IdentityType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsIamIdc
        case awsIamIdpOidc
        case awsIamIdpSaml
        case sdkUnknown(Swift.String)

        public static var allCases: [IdentityType] {
            return [
                .awsIamIdc,
                .awsIamIdpOidc,
                .awsIamIdpSaml
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsIamIdc: return "AWS_IAM_IDC"
            case .awsIamIdpOidc: return "AWS_IAM_IDP_OIDC"
            case .awsIamIdpSaml: return "AWS_IAM_IDP_SAML"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QBusinessClientTypes {

    public enum ApplicationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QBusinessClientTypes {

    /// Summary information for an Amazon Q Business application.
    public struct Application: Swift.Sendable {
        /// The identifier for the Amazon Q Business application.
        public var applicationId: Swift.String?
        /// The Unix timestamp when the Amazon Q Business application was created.
        public var createdAt: Foundation.Date?
        /// The name of the Amazon Q Business application.
        public var displayName: Swift.String?
        /// The authentication type being used by a Amazon Q Business application.
        public var identityType: QBusinessClientTypes.IdentityType?
        /// The status of the Amazon Q Business application. The application is ready to use when the status is ACTIVE.
        public var status: QBusinessClientTypes.ApplicationStatus?
        /// The Unix timestamp when the Amazon Q Business application was last updated.
        public var updatedAt: Foundation.Date?

        public init(
            applicationId: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            displayName: Swift.String? = nil,
            identityType: QBusinessClientTypes.IdentityType? = nil,
            status: QBusinessClientTypes.ApplicationStatus? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.applicationId = applicationId
            self.createdAt = createdAt
            self.displayName = displayName
            self.identityType = identityType
            self.status = status
            self.updatedAt = updatedAt
        }
    }
}

/// You are trying to perform an action that conflicts with the current status of your resource. Fix any inconsistences with your resources and try again.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message describing a ConflictException.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier of the resource affected.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource affected.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// An issue occurred with the internal server used for your Amazon Q Business service. Wait some minutes and try again, or contact [Support](http://aws.amazon.com/contact-us/) for help.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The resource you want to use doesn’t exist. Make sure you have provided the correct resource and try again.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message describing a ResourceNotFoundException.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier of the resource affected.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource affected.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// You have exceeded the set limits for your Amazon Q Business service.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message describing a ServiceQuotaExceededException.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier of the resource affected.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource affected.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// The request was denied due to throttling. Reduce the number of requests and try again.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension QBusinessClientTypes {

    /// The input failed to meet the constraints specified by Amazon Q Business in a specified field.
    public struct ValidationExceptionField: Swift.Sendable {
        /// A message about the validation exception.
        /// This member is required.
        public var message: Swift.String?
        /// The field name where the invalid entry was detected.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }
}

extension QBusinessClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CANNOT_PARSE"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The input doesn't meet the constraints set by the Amazon Q Business service. Provide the correct input and try again.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The input field(s) that failed validation.
        public internal(set) var fields: [QBusinessClientTypes.ValidationExceptionField]? = nil
        /// The message describing the ValidationException.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason for the ValidationException.
        /// This member is required.
        public internal(set) var reason: QBusinessClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fields: [QBusinessClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: QBusinessClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fields = fields
        self.properties.message = message
        self.properties.reason = reason
    }
}

extension QBusinessClientTypes {

    public enum AttachmentsControlMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AttachmentsControlMode] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QBusinessClientTypes {

    /// Configuration information for the file upload during chat feature.
    public struct AttachmentsConfiguration: Swift.Sendable {
        /// Status information about whether file upload functionality is activated or deactivated for your end user.
        /// This member is required.
        public var attachmentsControlMode: QBusinessClientTypes.AttachmentsControlMode?

        public init(
            attachmentsControlMode: QBusinessClientTypes.AttachmentsControlMode? = nil
        )
        {
            self.attachmentsControlMode = attachmentsControlMode
        }
    }
}

extension QBusinessClientTypes {

    /// Provides the identifier of the KMS key used to encrypt data indexed by Amazon Q Business. Amazon Q Business doesn't support asymmetric keys.
    public struct EncryptionConfiguration: Swift.Sendable {
        /// The identifier of the KMS key. Amazon Q Business doesn't support asymmetric keys.
        public var kmsKeyId: Swift.String?

        public init(
            kmsKeyId: Swift.String? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
        }
    }
}

extension QBusinessClientTypes.EncryptionConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EncryptionConfiguration(kmsKeyId: \"CONTENT_REDACTED\")"}
}

extension QBusinessClientTypes {

    public enum PersonalizationControlMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [PersonalizationControlMode] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QBusinessClientTypes {

    /// Configuration information about chat response personalization. For more information, see [Personalizing chat responses](https://docs.aws.amazon.com/amazonq/latest/qbusiness-ug/personalizing-chat-responses.html).
    public struct PersonalizationConfiguration: Swift.Sendable {
        /// An option to allow Amazon Q Business to customize chat responses using user specific metadata—specifically, location and job information—in your IAM Identity Center instance.
        /// This member is required.
        public var personalizationControlMode: QBusinessClientTypes.PersonalizationControlMode?

        public init(
            personalizationControlMode: QBusinessClientTypes.PersonalizationControlMode? = nil
        )
        {
            self.personalizationControlMode = personalizationControlMode
        }
    }
}

extension QBusinessClientTypes {

    public enum QAppsControlMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [QAppsControlMode] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QBusinessClientTypes {

    /// Configuration information about Amazon Q Apps.
    public struct QAppsConfiguration: Swift.Sendable {
        /// Status information about whether end users can create and use Amazon Q Apps in the web experience.
        /// This member is required.
        public var qAppsControlMode: QBusinessClientTypes.QAppsControlMode?

        public init(
            qAppsControlMode: QBusinessClientTypes.QAppsControlMode? = nil
        )
        {
            self.qAppsControlMode = qAppsControlMode
        }
    }
}

extension QBusinessClientTypes {

    /// A list of key/value pairs that identify an index, FAQ, or data source. Tag keys and values can consist of Unicode letters, digits, white space, and any of the following symbols: _ . : / = + - @.
    public struct Tag: Swift.Sendable {
        /// The key for the tag. Keys are not case sensitive and must be unique for the Amazon Q Business application or data source.
        /// This member is required.
        public var key: Swift.String?
        /// The value associated with the tag. The value may be an empty string but it can't be null.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

public struct CreateApplicationInput: Swift.Sendable {
    /// An option to allow end users to upload files directly during chat.
    public var attachmentsConfiguration: QBusinessClientTypes.AttachmentsConfiguration?
    /// The OIDC client ID for a Amazon Q Business application.
    public var clientIdsForOIDC: [Swift.String]?
    /// A token that you provide to identify the request to create your Amazon Q Business application.
    public var clientToken: Swift.String?
    /// A description for the Amazon Q Business application.
    public var description: Swift.String?
    /// A name for the Amazon Q Business application.
    /// This member is required.
    public var displayName: Swift.String?
    /// The identifier of the KMS key that is used to encrypt your data. Amazon Q Business doesn't support asymmetric keys.
    public var encryptionConfiguration: QBusinessClientTypes.EncryptionConfiguration?
    /// The Amazon Resource Name (ARN) of an identity provider being used by an Amazon Q Business application.
    public var iamIdentityProviderArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM Identity Center instance you are either creating for—or connecting to—your Amazon Q Business application.
    public var identityCenterInstanceArn: Swift.String?
    /// The authentication type being used by a Amazon Q Business application.
    public var identityType: QBusinessClientTypes.IdentityType?
    /// Configuration information about chat response personalization. For more information, see [Personalizing chat responses](https://docs.aws.amazon.com/amazonq/latest/qbusiness-ug/personalizing-chat-responses.html)
    public var personalizationConfiguration: QBusinessClientTypes.PersonalizationConfiguration?
    /// An option to allow end users to create and use Amazon Q Apps in the web experience.
    public var qAppsConfiguration: QBusinessClientTypes.QAppsConfiguration?
    /// The Amazon Resource Name (ARN) of an IAM role with permissions to access your Amazon CloudWatch logs and metrics. If this property is not specified, Amazon Q Business will create a [service linked role (SLR)](https://docs.aws.amazon.com/amazonq/latest/qbusiness-ug/using-service-linked-roles.html#slr-permissions) and use it as the application's role.
    public var roleArn: Swift.String?
    /// A list of key-value pairs that identify or categorize your Amazon Q Business application. You can also use tags to help control access to the application. Tag keys and values can consist of Unicode letters, digits, white space, and any of the following symbols: _ . : / = + - @.
    public var tags: [QBusinessClientTypes.Tag]?

    public init(
        attachmentsConfiguration: QBusinessClientTypes.AttachmentsConfiguration? = nil,
        clientIdsForOIDC: [Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        encryptionConfiguration: QBusinessClientTypes.EncryptionConfiguration? = nil,
        iamIdentityProviderArn: Swift.String? = nil,
        identityCenterInstanceArn: Swift.String? = nil,
        identityType: QBusinessClientTypes.IdentityType? = nil,
        personalizationConfiguration: QBusinessClientTypes.PersonalizationConfiguration? = nil,
        qAppsConfiguration: QBusinessClientTypes.QAppsConfiguration? = nil,
        roleArn: Swift.String? = nil,
        tags: [QBusinessClientTypes.Tag]? = nil
    )
    {
        self.attachmentsConfiguration = attachmentsConfiguration
        self.clientIdsForOIDC = clientIdsForOIDC
        self.clientToken = clientToken
        self.description = description
        self.displayName = displayName
        self.encryptionConfiguration = encryptionConfiguration
        self.iamIdentityProviderArn = iamIdentityProviderArn
        self.identityCenterInstanceArn = identityCenterInstanceArn
        self.identityType = identityType
        self.personalizationConfiguration = personalizationConfiguration
        self.qAppsConfiguration = qAppsConfiguration
        self.roleArn = roleArn
        self.tags = tags
    }
}

public struct CreateApplicationOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the Amazon Q Business application.
    public var applicationArn: Swift.String?
    /// The identifier of the Amazon Q Business application.
    public var applicationId: Swift.String?

    public init(
        applicationArn: Swift.String? = nil,
        applicationId: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
        self.applicationId = applicationId
    }
}

public struct DeleteApplicationInput: Swift.Sendable {
    /// The identifier of the Amazon Q Business application.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

public struct DeleteApplicationOutput: Swift.Sendable {

    public init() { }
}

public struct GetApplicationInput: Swift.Sendable {
    /// The identifier of the Amazon Q Business application.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

extension QBusinessClientTypes {

    /// Configuration information about the file upload during chat feature for your application.
    public struct AppliedAttachmentsConfiguration: Swift.Sendable {
        /// Information about whether file upload during chat functionality is activated for your application.
        public var attachmentsControlMode: QBusinessClientTypes.AttachmentsControlMode?

        public init(
            attachmentsControlMode: QBusinessClientTypes.AttachmentsControlMode? = nil
        )
        {
            self.attachmentsControlMode = attachmentsControlMode
        }
    }
}

extension QBusinessClientTypes {

    public enum AutoSubscriptionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoSubscriptionStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QBusinessClientTypes {

    public enum SubscriptionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case qBusiness
        case qLite
        case sdkUnknown(Swift.String)

        public static var allCases: [SubscriptionType] {
            return [
                .qBusiness,
                .qLite
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .qBusiness: return "Q_BUSINESS"
            case .qLite: return "Q_LITE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QBusinessClientTypes {

    /// Subscription configuration information for an Amazon Q Business application using IAM identity federation for user management.
    public struct AutoSubscriptionConfiguration: Swift.Sendable {
        /// Describes whether automatic subscriptions are enabled for an Amazon Q Business application using IAM identity federation for user management.
        /// This member is required.
        public var autoSubscribe: QBusinessClientTypes.AutoSubscriptionStatus?
        /// Describes the default subscription type assigned to an Amazon Q Business application using IAM identity federation for user management. If the value for autoSubscribe is set to ENABLED you must select a value for this field.
        public var defaultSubscriptionType: QBusinessClientTypes.SubscriptionType?

        public init(
            autoSubscribe: QBusinessClientTypes.AutoSubscriptionStatus? = nil,
            defaultSubscriptionType: QBusinessClientTypes.SubscriptionType? = nil
        )
        {
            self.autoSubscribe = autoSubscribe
            self.defaultSubscriptionType = defaultSubscriptionType
        }
    }
}

extension QBusinessClientTypes {

    public enum ErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case internalError
        case invalidRequest
        case resourceInactive
        case resourceNotFound
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .internalError,
                .invalidRequest,
                .resourceInactive,
                .resourceNotFound
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .internalError: return "InternalError"
            case .invalidRequest: return "InvalidRequest"
            case .resourceInactive: return "ResourceInactive"
            case .resourceNotFound: return "ResourceNotFound"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QBusinessClientTypes {

    /// Provides information about a data source sync error.
    public struct ErrorDetail: Swift.Sendable {
        /// The code associated with the data source sync error.
        public var errorCode: QBusinessClientTypes.ErrorCode?
        /// The message explaining the data source sync error.
        public var errorMessage: Swift.String?

        public init(
            errorCode: QBusinessClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }
}

public struct GetApplicationOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the Amazon Q Business application.
    public var applicationArn: Swift.String?
    /// The identifier of the Amazon Q Business application.
    public var applicationId: Swift.String?
    /// Settings for whether end users can upload files directly during chat.
    public var attachmentsConfiguration: QBusinessClientTypes.AppliedAttachmentsConfiguration?
    /// Settings for auto-subscription behavior for this application. This is only applicable to SAML and OIDC applications.
    public var autoSubscriptionConfiguration: QBusinessClientTypes.AutoSubscriptionConfiguration?
    /// The OIDC client ID for a Amazon Q Business application.
    public var clientIdsForOIDC: [Swift.String]?
    /// The Unix timestamp when the Amazon Q Business application was last updated.
    public var createdAt: Foundation.Date?
    /// A description for the Amazon Q Business application.
    public var description: Swift.String?
    /// The name of the Amazon Q Business application.
    public var displayName: Swift.String?
    /// The identifier of the Amazon Web Services KMS key that is used to encrypt your data. Amazon Q Business doesn't support asymmetric keys.
    public var encryptionConfiguration: QBusinessClientTypes.EncryptionConfiguration?
    /// If the Status field is set to ERROR, the ErrorMessage field contains a description of the error that caused the synchronization to fail.
    public var error: QBusinessClientTypes.ErrorDetail?
    /// The Amazon Resource Name (ARN) of an identity provider being used by an Amazon Q Business application.
    public var iamIdentityProviderArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the AWS IAM Identity Center instance attached to your Amazon Q Business application.
    public var identityCenterApplicationArn: Swift.String?
    /// The authentication type being used by a Amazon Q Business application.
    public var identityType: QBusinessClientTypes.IdentityType?
    /// Configuration information about chat response personalization. For more information, see [Personalizing chat responses](https://docs.aws.amazon.com/amazonq/latest/qbusiness-ug/personalizing-chat-responses.html).
    public var personalizationConfiguration: QBusinessClientTypes.PersonalizationConfiguration?
    /// Settings for whether end users can create and use Amazon Q Apps in the web experience.
    public var qAppsConfiguration: QBusinessClientTypes.QAppsConfiguration?
    /// The Amazon Resource Name (ARN) of the IAM with permissions to access your CloudWatch logs and metrics.
    public var roleArn: Swift.String?
    /// The status of the Amazon Q Business application.
    public var status: QBusinessClientTypes.ApplicationStatus?
    /// The Unix timestamp when the Amazon Q Business application was last updated.
    public var updatedAt: Foundation.Date?

    public init(
        applicationArn: Swift.String? = nil,
        applicationId: Swift.String? = nil,
        attachmentsConfiguration: QBusinessClientTypes.AppliedAttachmentsConfiguration? = nil,
        autoSubscriptionConfiguration: QBusinessClientTypes.AutoSubscriptionConfiguration? = nil,
        clientIdsForOIDC: [Swift.String]? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        encryptionConfiguration: QBusinessClientTypes.EncryptionConfiguration? = nil,
        error: QBusinessClientTypes.ErrorDetail? = nil,
        iamIdentityProviderArn: Swift.String? = nil,
        identityCenterApplicationArn: Swift.String? = nil,
        identityType: QBusinessClientTypes.IdentityType? = nil,
        personalizationConfiguration: QBusinessClientTypes.PersonalizationConfiguration? = nil,
        qAppsConfiguration: QBusinessClientTypes.QAppsConfiguration? = nil,
        roleArn: Swift.String? = nil,
        status: QBusinessClientTypes.ApplicationStatus? = nil,
        updatedAt: Foundation.Date? = nil
    )
    {
        self.applicationArn = applicationArn
        self.applicationId = applicationId
        self.attachmentsConfiguration = attachmentsConfiguration
        self.autoSubscriptionConfiguration = autoSubscriptionConfiguration
        self.clientIdsForOIDC = clientIdsForOIDC
        self.createdAt = createdAt
        self.description = description
        self.displayName = displayName
        self.encryptionConfiguration = encryptionConfiguration
        self.error = error
        self.iamIdentityProviderArn = iamIdentityProviderArn
        self.identityCenterApplicationArn = identityCenterApplicationArn
        self.identityType = identityType
        self.personalizationConfiguration = personalizationConfiguration
        self.qAppsConfiguration = qAppsConfiguration
        self.roleArn = roleArn
        self.status = status
        self.updatedAt = updatedAt
    }
}

extension QBusinessClientTypes {

    /// Provides information about index capacity configuration.
    public struct IndexCapacityConfiguration: Swift.Sendable {
        /// The number of storage units configured for an Amazon Q Business index.
        public var units: Swift.Int?

        public init(
            units: Swift.Int? = nil
        )
        {
            self.units = units
        }
    }
}

extension QBusinessClientTypes {

    public enum IndexType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case enterprise
        case starter
        case sdkUnknown(Swift.String)

        public static var allCases: [IndexType] {
            return [
                .enterprise,
                .starter
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .enterprise: return "ENTERPRISE"
            case .starter: return "STARTER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateIndexInput: Swift.Sendable {
    /// The identifier of the Amazon Q Business application using the index.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The capacity units you want to provision for your index. You can add and remove capacity to fit your usage needs.
    public var capacityConfiguration: QBusinessClientTypes.IndexCapacityConfiguration?
    /// A token that you provide to identify the request to create an index. Multiple calls to the CreateIndex API with the same client token will create only one index.
    public var clientToken: Swift.String?
    /// A description for the Amazon Q Business index.
    public var description: Swift.String?
    /// A name for the Amazon Q Business index.
    /// This member is required.
    public var displayName: Swift.String?
    /// A list of key-value pairs that identify or categorize the index. You can also use tags to help control access to the index. Tag keys and values can consist of Unicode letters, digits, white space, and any of the following symbols: _ . : / = + - @.
    public var tags: [QBusinessClientTypes.Tag]?
    /// The index type that's suitable for your needs. For more information on what's included in each type of index, see [Amazon Q Business tiers](https://docs.aws.amazon.com/amazonq/latest/qbusiness-ug/tiers.html#index-tiers).
    public var type: QBusinessClientTypes.IndexType?

    public init(
        applicationId: Swift.String? = nil,
        capacityConfiguration: QBusinessClientTypes.IndexCapacityConfiguration? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        tags: [QBusinessClientTypes.Tag]? = nil,
        type: QBusinessClientTypes.IndexType? = nil
    )
    {
        self.applicationId = applicationId
        self.capacityConfiguration = capacityConfiguration
        self.clientToken = clientToken
        self.description = description
        self.displayName = displayName
        self.tags = tags
        self.type = type
    }
}

public struct CreateIndexOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of an Amazon Q Business index.
    public var indexArn: Swift.String?
    /// The identifier for the Amazon Q Business index.
    public var indexId: Swift.String?

    public init(
        indexArn: Swift.String? = nil,
        indexId: Swift.String? = nil
    )
    {
        self.indexArn = indexArn
        self.indexId = indexId
    }
}

extension QBusinessClientTypes {

    public enum DocumentEnrichmentConditionOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case beginsWith
        case contains
        case equals
        case exists
        case greaterThan
        case greaterThanOrEquals
        case lessThan
        case lessThanOrEquals
        case notContains
        case notEquals
        case notExists
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentEnrichmentConditionOperator] {
            return [
                .beginsWith,
                .contains,
                .equals,
                .exists,
                .greaterThan,
                .greaterThanOrEquals,
                .lessThan,
                .lessThanOrEquals,
                .notContains,
                .notEquals,
                .notExists
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .beginsWith: return "BEGINS_WITH"
            case .contains: return "CONTAINS"
            case .equals: return "EQUALS"
            case .exists: return "EXISTS"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEquals: return "GREATER_THAN_OR_EQUALS"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEquals: return "LESS_THAN_OR_EQUALS"
            case .notContains: return "NOT_CONTAINS"
            case .notEquals: return "NOT_EQUALS"
            case .notExists: return "NOT_EXISTS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QBusinessClientTypes {

    /// The value of a document attribute. You can only provide one value for a document attribute.
    public enum DocumentAttributeValue: Swift.Sendable {
        /// A string.
        case stringvalue(Swift.String)
        /// A list of strings.
        case stringlistvalue([Swift.String])
        /// A long integer value.
        case longvalue(Swift.Int)
        /// A date expressed as an ISO 8601 string. It's important for the time zone to be included in the ISO 8601 date-time format. For example, 2012-03-25T12:30:10+01:00 is the ISO 8601 date-time format for March 25th 2012 at 12:30PM (plus 10 seconds) in Central European Time.
        case datevalue(Foundation.Date)
        case sdkUnknown(Swift.String)
    }
}

extension QBusinessClientTypes {

    /// The condition used for the target document attribute or metadata field when ingesting documents into Amazon Q Business. You use this with [DocumentAttributeTarget](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeTarget.html) to apply the condition. For example, you can create the 'Department' target field and have it prefill department names associated with the documents based on information in the 'Source_URI' field. Set the condition that if the 'Source_URI' field contains 'financial' in its URI value, then prefill the target field 'Department' with the target value 'Finance' for the document. Amazon Q Business can't create a target field if it has not already been created as an index field. After you create your index field, you can create a document metadata field using DocumentAttributeTarget. Amazon Q Business then will map your newly created metadata field to your index field.
    public struct DocumentAttributeCondition: Swift.Sendable {
        /// The identifier of the document attribute used for the condition. For example, 'Source_URI' could be an identifier for the attribute or metadata field that contains source URIs associated with the documents. Amazon Q Business currently doesn't support _document_body as an attribute key used for the condition.
        /// This member is required.
        public var key: Swift.String?
        /// The identifier of the document attribute used for the condition. For example, 'Source_URI' could be an identifier for the attribute or metadata field that contains source URIs associated with the documents. Amazon Q Business currently does not support _document_body as an attribute key used for the condition.
        /// This member is required.
        public var `operator`: QBusinessClientTypes.DocumentEnrichmentConditionOperator?
        /// The value of a document attribute. You can only provide one value for a document attribute.
        public var value: QBusinessClientTypes.DocumentAttributeValue?

        public init(
            key: Swift.String? = nil,
            `operator`: QBusinessClientTypes.DocumentEnrichmentConditionOperator? = nil,
            value: QBusinessClientTypes.DocumentAttributeValue? = nil
        )
        {
            self.key = key
            self.`operator` = `operator`
            self.value = value
        }
    }
}

extension QBusinessClientTypes {

    public enum DocumentContentOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case delete
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentContentOperator] {
            return [
                .delete
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .delete: return "DELETE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QBusinessClientTypes {

    public enum AttributeValueOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case delete
        case sdkUnknown(Swift.String)

        public static var allCases: [AttributeValueOperator] {
            return [
                .delete
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .delete: return "DELETE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QBusinessClientTypes {

    /// The target document attribute or metadata field you want to alter when ingesting documents into Amazon Q Business. For example, you can delete all customer identification numbers associated with the documents, stored in the document metadata field called 'Customer_ID' by setting the target key as 'Customer_ID' and the deletion flag to TRUE. This removes all customer ID values in the field 'Customer_ID'. This would scrub personally identifiable information from each document's metadata. Amazon Q Business can't create a target field if it has not already been created as an index field. After you create your index field, you can create a document metadata field using [DocumentAttributeTarget](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeTarget.html). Amazon Q Business will then map your newly created document attribute to your index field. You can also use this with [DocumentAttributeCondition](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeCondition.html).
    public struct DocumentAttributeTarget: Swift.Sendable {
        /// TRUE to delete the existing target value for your specified target attribute key. You cannot create a target value and set this to TRUE.
        public var attributeValueOperator: QBusinessClientTypes.AttributeValueOperator?
        /// The identifier of the target document attribute or metadata field. For example, 'Department' could be an identifier for the target attribute or metadata field that includes the department names associated with the documents.
        /// This member is required.
        public var key: Swift.String?
        /// The value of a document attribute. You can only provide one value for a document attribute.
        public var value: QBusinessClientTypes.DocumentAttributeValue?

        public init(
            attributeValueOperator: QBusinessClientTypes.AttributeValueOperator? = nil,
            key: Swift.String? = nil,
            value: QBusinessClientTypes.DocumentAttributeValue? = nil
        )
        {
            self.attributeValueOperator = attributeValueOperator
            self.key = key
            self.value = value
        }
    }
}

extension QBusinessClientTypes {

    /// Provides the configuration information for applying basic logic to alter document metadata and content when ingesting documents into Amazon Q Business. To apply advanced logic, to go beyond what you can do with basic logic, see [HookConfiguration](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_HookConfiguration.html). For more information, see [Custom document enrichment](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/custom-document-enrichment.html).
    public struct InlineDocumentEnrichmentConfiguration: Swift.Sendable {
        /// The condition used for the target document attribute or metadata field when ingesting documents into Amazon Q Business. You use this with [DocumentAttributeTarget](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeTarget.html) to apply the condition. For example, you can create the 'Department' target field and have it prefill department names associated with the documents based on information in the 'Source_URI' field. Set the condition that if the 'Source_URI' field contains 'financial' in its URI value, then prefill the target field 'Department' with the target value 'Finance' for the document. Amazon Q Business can't create a target field if it has not already been created as an index field. After you create your index field, you can create a document metadata field using DocumentAttributeTarget. Amazon Q Business then will map your newly created metadata field to your index field.
        public var condition: QBusinessClientTypes.DocumentAttributeCondition?
        /// TRUE to delete content if the condition used for the target attribute is met.
        public var documentContentOperator: QBusinessClientTypes.DocumentContentOperator?
        /// The target document attribute or metadata field you want to alter when ingesting documents into Amazon Q Business. For example, you can delete all customer identification numbers associated with the documents, stored in the document metadata field called 'Customer_ID' by setting the target key as 'Customer_ID' and the deletion flag to TRUE. This removes all customer ID values in the field 'Customer_ID'. This would scrub personally identifiable information from each document's metadata. Amazon Q Business can't create a target field if it has not already been created as an index field. After you create your index field, you can create a document metadata field using [DocumentAttributeTarget](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeTarget.html). Amazon Q Business will then map your newly created document attribute to your index field. You can also use this with [DocumentAttributeCondition](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeCondition.html).
        public var target: QBusinessClientTypes.DocumentAttributeTarget?

        public init(
            condition: QBusinessClientTypes.DocumentAttributeCondition? = nil,
            documentContentOperator: QBusinessClientTypes.DocumentContentOperator? = nil,
            target: QBusinessClientTypes.DocumentAttributeTarget? = nil
        )
        {
            self.condition = condition
            self.documentContentOperator = documentContentOperator
            self.target = target
        }
    }
}

extension QBusinessClientTypes {

    /// Provides the configuration information for invoking a Lambda function in Lambda to alter document metadata and content when ingesting documents into Amazon Q Business. You can configure your Lambda function using the PreExtractionHookConfiguration parameter if you want to apply advanced alterations on the original or raw documents. If you want to apply advanced alterations on the Amazon Q Business structured documents, you must configure your Lambda function using PostExtractionHookConfiguration. You can only invoke one Lambda function. However, this function can invoke other functions it requires. For more information, see [Custom document enrichment](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/custom-document-enrichment.html).
    public struct HookConfiguration: Swift.Sendable {
        /// The condition used for when a Lambda function should be invoked. For example, you can specify a condition that if there are empty date-time values, then Amazon Q Business should invoke a function that inserts the current date-time.
        public var invocationCondition: QBusinessClientTypes.DocumentAttributeCondition?
        /// The Amazon Resource Name (ARN) of a role with permission to run a Lambda function during ingestion. For more information, see [IAM roles for Custom Document Enrichment (CDE)](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/iam-roles.html#cde-iam-role).
        public var lambdaArn: Swift.String?
        /// The Amazon Resource Name (ARN) of a role with permission to run PreExtractionHookConfiguration and PostExtractionHookConfiguration for altering document metadata and content during the document ingestion process.
        public var roleArn: Swift.String?
        /// Stores the original, raw documents or the structured, parsed documents before and after altering them. For more information, see [Data contracts for Lambda functions](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/cde-lambda-operations.html#cde-lambda-operations-data-contracts).
        public var s3BucketName: Swift.String?

        public init(
            invocationCondition: QBusinessClientTypes.DocumentAttributeCondition? = nil,
            lambdaArn: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            s3BucketName: Swift.String? = nil
        )
        {
            self.invocationCondition = invocationCondition
            self.lambdaArn = lambdaArn
            self.roleArn = roleArn
            self.s3BucketName = s3BucketName
        }
    }
}

extension QBusinessClientTypes {

    /// Provides the configuration information for altering document metadata and content during the document ingestion process. For more information, see [Custom document enrichment](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/custom-document-enrichment.html).
    public struct DocumentEnrichmentConfiguration: Swift.Sendable {
        /// Configuration information to alter document attributes or metadata fields and content when ingesting documents into Amazon Q Business.
        public var inlineConfigurations: [QBusinessClientTypes.InlineDocumentEnrichmentConfiguration]?
        /// Provides the configuration information for invoking a Lambda function in Lambda to alter document metadata and content when ingesting documents into Amazon Q Business. You can configure your Lambda function using the PreExtractionHookConfiguration parameter if you want to apply advanced alterations on the original or raw documents. If you want to apply advanced alterations on the Amazon Q Business structured documents, you must configure your Lambda function using PostExtractionHookConfiguration. You can only invoke one Lambda function. However, this function can invoke other functions it requires. For more information, see [Custom document enrichment](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/custom-document-enrichment.html).
        public var postExtractionHookConfiguration: QBusinessClientTypes.HookConfiguration?
        /// Provides the configuration information for invoking a Lambda function in Lambda to alter document metadata and content when ingesting documents into Amazon Q Business. You can configure your Lambda function using the PreExtractionHookConfiguration parameter if you want to apply advanced alterations on the original or raw documents. If you want to apply advanced alterations on the Amazon Q Business structured documents, you must configure your Lambda function using PostExtractionHookConfiguration. You can only invoke one Lambda function. However, this function can invoke other functions it requires. For more information, see [Custom document enrichment](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/custom-document-enrichment.html).
        public var preExtractionHookConfiguration: QBusinessClientTypes.HookConfiguration?

        public init(
            inlineConfigurations: [QBusinessClientTypes.InlineDocumentEnrichmentConfiguration]? = nil,
            postExtractionHookConfiguration: QBusinessClientTypes.HookConfiguration? = nil,
            preExtractionHookConfiguration: QBusinessClientTypes.HookConfiguration? = nil
        )
        {
            self.inlineConfigurations = inlineConfigurations
            self.postExtractionHookConfiguration = postExtractionHookConfiguration
            self.preExtractionHookConfiguration = preExtractionHookConfiguration
        }
    }
}

extension QBusinessClientTypes {

    /// Provides configuration information needed to connect to an Amazon VPC (Virtual Private Cloud).
    public struct DataSourceVpcConfiguration: Swift.Sendable {
        /// A list of identifiers of security groups within your Amazon VPC. The security groups should enable Amazon Q Business to connect to the data source.
        /// This member is required.
        public var securityGroupIds: [Swift.String]?
        /// A list of identifiers for subnets within your Amazon VPC. The subnets should be able to connect to each other in the VPC, and they should have outgoing access to the Internet through a NAT device.
        /// This member is required.
        public var subnetIds: [Swift.String]?

        public init(
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }
}

public struct CreateDataSourceInput: Swift.Sendable {
    /// The identifier of the Amazon Q Business application the data source will be attached to.
    /// This member is required.
    public var applicationId: Swift.String?
    /// A token you provide to identify a request to create a data source connector. Multiple calls to the CreateDataSource API with the same client token will create only one data source connector.
    public var clientToken: Swift.String?
    /// Configuration information to connect your data source repository to Amazon Q Business. Use this parameter to provide a JSON schema with configuration information specific to your data source connector. Each data source has a JSON schema provided by Amazon Q Business that you must use. For example, the Amazon S3 and Web Crawler connectors require the following JSON schemas:
    ///
    /// * [Amazon S3 JSON schema](https://docs.aws.amazon.com/amazonq/latest/qbusiness-ug/s3-api.html)
    ///
    /// * [Web Crawler JSON schema](https://docs.aws.amazon.com/amazonq/latest/qbusiness-ug/web-crawler-api.html)
    ///
    ///
    /// You can find configuration templates for your specific data source using the following steps:
    ///
    /// * Navigate to the [Supported connectors](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/connectors-list.html) page in the Amazon Q Business User Guide, and select the data source of your choice.
    ///
    /// * Then, from your specific data source connector page, select Using the API. You will find the JSON schema for your data source, including parameter descriptions, in this section.
    /// This member is required.
    public var configuration: Smithy.Document?
    /// A description for the data source connector.
    public var description: Swift.String?
    /// A name for the data source connector.
    /// This member is required.
    public var displayName: Swift.String?
    /// Provides the configuration information for altering document metadata and content during the document ingestion process. For more information, see [Custom document enrichment](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/custom-document-enrichment.html).
    public var documentEnrichmentConfiguration: QBusinessClientTypes.DocumentEnrichmentConfiguration?
    /// The identifier of the index that you want to use with the data source connector.
    /// This member is required.
    public var indexId: Swift.String?
    /// The Amazon Resource Name (ARN) of an IAM role with permission to access the data source and required resources.
    public var roleArn: Swift.String?
    /// Sets the frequency for Amazon Q Business to check the documents in your data source repository and update your index. If you don't set a schedule, Amazon Q Business won't periodically update the index. Specify a cron- format schedule string or an empty string to indicate that the index is updated on demand. You can't specify the Schedule parameter when the Type parameter is set to CUSTOM. If you do, you receive a ValidationException exception.
    public var syncSchedule: Swift.String?
    /// A list of key-value pairs that identify or categorize the data source connector. You can also use tags to help control access to the data source connector. Tag keys and values can consist of Unicode letters, digits, white space, and any of the following symbols: _ . : / = + - @.
    public var tags: [QBusinessClientTypes.Tag]?
    /// Configuration information for an Amazon VPC (Virtual Private Cloud) to connect to your data source. For more information, see [Using Amazon VPC with Amazon Q Business connectors](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/connector-vpc.html).
    public var vpcConfiguration: QBusinessClientTypes.DataSourceVpcConfiguration?

    public init(
        applicationId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        configuration: Smithy.Document? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        documentEnrichmentConfiguration: QBusinessClientTypes.DocumentEnrichmentConfiguration? = nil,
        indexId: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        syncSchedule: Swift.String? = nil,
        tags: [QBusinessClientTypes.Tag]? = nil,
        vpcConfiguration: QBusinessClientTypes.DataSourceVpcConfiguration? = nil
    )
    {
        self.applicationId = applicationId
        self.clientToken = clientToken
        self.configuration = configuration
        self.description = description
        self.displayName = displayName
        self.documentEnrichmentConfiguration = documentEnrichmentConfiguration
        self.indexId = indexId
        self.roleArn = roleArn
        self.syncSchedule = syncSchedule
        self.tags = tags
        self.vpcConfiguration = vpcConfiguration
    }
}

public struct CreateDataSourceOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of a data source in an Amazon Q Business application.
    public var dataSourceArn: Swift.String?
    /// The identifier of the data source connector.
    public var dataSourceId: Swift.String?

    public init(
        dataSourceArn: Swift.String? = nil,
        dataSourceId: Swift.String? = nil
    )
    {
        self.dataSourceArn = dataSourceArn
        self.dataSourceId = dataSourceId
    }
}

public struct DeleteDataSourceInput: Swift.Sendable {
    /// The identifier of the Amazon Q Business application used with the data source connector.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the data source connector that you want to delete.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// The identifier of the index used with the data source connector.
    /// This member is required.
    public var indexId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        indexId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.dataSourceId = dataSourceId
        self.indexId = indexId
    }
}

public struct DeleteDataSourceOutput: Swift.Sendable {

    public init() { }
}

public struct GetDataSourceInput: Swift.Sendable {
    /// The identifier of the Amazon Q Business application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the data source connector.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// The identfier of the index used with the data source connector.
    /// This member is required.
    public var indexId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        indexId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.dataSourceId = dataSourceId
        self.indexId = indexId
    }
}

extension QBusinessClientTypes {

    public enum DataSourceStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case pendingCreation
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .pendingCreation,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .pendingCreation: return "PENDING_CREATION"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetDataSourceOutput: Swift.Sendable {
    /// The identifier of the Amazon Q Business application.
    public var applicationId: Swift.String?
    /// The details of how the data source connector is configured.
    public var configuration: Smithy.Document?
    /// The Unix timestamp when the data source connector was created.
    public var createdAt: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the data source.
    public var dataSourceArn: Swift.String?
    /// The identifier of the data source connector.
    public var dataSourceId: Swift.String?
    /// The description for the data source connector.
    public var description: Swift.String?
    /// The name for the data source connector.
    public var displayName: Swift.String?
    /// Provides the configuration information for altering document metadata and content during the document ingestion process. For more information, see [Custom document enrichment](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/custom-document-enrichment.html).
    public var documentEnrichmentConfiguration: QBusinessClientTypes.DocumentEnrichmentConfiguration?
    /// When the Status field value is FAILED, the ErrorMessage field contains a description of the error that caused the data source connector to fail.
    public var error: QBusinessClientTypes.ErrorDetail?
    /// The identifier of the index linked to the data source connector.
    public var indexId: Swift.String?
    /// The Amazon Resource Name (ARN) of the role with permission to access the data source and required resources.
    public var roleArn: Swift.String?
    /// The current status of the data source connector. When the Status field value is FAILED, the ErrorMessage field contains a description of the error that caused the data source connector to fail.
    public var status: QBusinessClientTypes.DataSourceStatus?
    /// The schedule for Amazon Q Business to update the index.
    public var syncSchedule: Swift.String?
    /// The type of the data source connector. For example, S3.
    public var type: Swift.String?
    /// The Unix timestamp when the data source connector was last updated.
    public var updatedAt: Foundation.Date?
    /// Configuration information for an Amazon VPC (Virtual Private Cloud) to connect to your data source.
    public var vpcConfiguration: QBusinessClientTypes.DataSourceVpcConfiguration?

    public init(
        applicationId: Swift.String? = nil,
        configuration: Smithy.Document? = nil,
        createdAt: Foundation.Date? = nil,
        dataSourceArn: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        documentEnrichmentConfiguration: QBusinessClientTypes.DocumentEnrichmentConfiguration? = nil,
        error: QBusinessClientTypes.ErrorDetail? = nil,
        indexId: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        status: QBusinessClientTypes.DataSourceStatus? = nil,
        syncSchedule: Swift.String? = nil,
        type: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        vpcConfiguration: QBusinessClientTypes.DataSourceVpcConfiguration? = nil
    )
    {
        self.applicationId = applicationId
        self.configuration = configuration
        self.createdAt = createdAt
        self.dataSourceArn = dataSourceArn
        self.dataSourceId = dataSourceId
        self.description = description
        self.displayName = displayName
        self.documentEnrichmentConfiguration = documentEnrichmentConfiguration
        self.error = error
        self.indexId = indexId
        self.roleArn = roleArn
        self.status = status
        self.syncSchedule = syncSchedule
        self.type = type
        self.updatedAt = updatedAt
        self.vpcConfiguration = vpcConfiguration
    }
}

public struct ListDataSourcesInput: Swift.Sendable {
    /// The identifier of the Amazon Q Business application linked to the data source connectors.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the index used with one or more data source connectors.
    /// This member is required.
    public var indexId: Swift.String?
    /// The maximum number of data source connectors to return.
    public var maxResults: Swift.Int?
    /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q Business returns a pagination token in the response. You can use this pagination token to retrieve the next set of Amazon Q Business data source connectors.
    public var nextToken: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        indexId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.indexId = indexId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension QBusinessClientTypes {

    /// A data source in an Amazon Q Business application.
    public struct DataSource: Swift.Sendable {
        /// The Unix timestamp when the Amazon Q Business data source was created.
        public var createdAt: Foundation.Date?
        /// The identifier of the Amazon Q Business data source.
        public var dataSourceId: Swift.String?
        /// The name of the Amazon Q Business data source.
        public var displayName: Swift.String?
        /// The status of the Amazon Q Business data source.
        public var status: QBusinessClientTypes.DataSourceStatus?
        /// The type of the Amazon Q Business data source.
        public var type: Swift.String?
        /// The Unix timestamp when the Amazon Q Business data source was last updated.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            dataSourceId: Swift.String? = nil,
            displayName: Swift.String? = nil,
            status: QBusinessClientTypes.DataSourceStatus? = nil,
            type: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.dataSourceId = dataSourceId
            self.displayName = displayName
            self.status = status
            self.type = type
            self.updatedAt = updatedAt
        }
    }
}

public struct ListDataSourcesOutput: Swift.Sendable {
    /// An array of summary information for one or more data source connector.
    public var dataSources: [QBusinessClientTypes.DataSource]?
    /// If the response is truncated, Amazon Q Business returns this token. You can use this token in a subsequent request to retrieve the next set of data source connectors.
    public var nextToken: Swift.String?

    public init(
        dataSources: [QBusinessClientTypes.DataSource]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataSources = dataSources
        self.nextToken = nextToken
    }
}

public struct UpdateDataSourceInput: Swift.Sendable {
    /// The identifier of the Amazon Q Business application the data source is attached to.
    /// This member is required.
    public var applicationId: Swift.String?
    /// Provides the configuration information for an Amazon Q Business data source.
    public var configuration: Smithy.Document?
    /// The identifier of the data source connector.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// The description of the data source connector.
    public var description: Swift.String?
    /// A name of the data source connector.
    public var displayName: Swift.String?
    /// Provides the configuration information for altering document metadata and content during the document ingestion process. For more information, see [Custom document enrichment](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/custom-document-enrichment.html).
    public var documentEnrichmentConfiguration: QBusinessClientTypes.DocumentEnrichmentConfiguration?
    /// The identifier of the index attached to the data source connector.
    /// This member is required.
    public var indexId: Swift.String?
    /// The Amazon Resource Name (ARN) of an IAM role with permission to access the data source and required resources.
    public var roleArn: Swift.String?
    /// The chosen update frequency for your data source.
    public var syncSchedule: Swift.String?
    /// Provides configuration information needed to connect to an Amazon VPC (Virtual Private Cloud).
    public var vpcConfiguration: QBusinessClientTypes.DataSourceVpcConfiguration?

    public init(
        applicationId: Swift.String? = nil,
        configuration: Smithy.Document? = nil,
        dataSourceId: Swift.String? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        documentEnrichmentConfiguration: QBusinessClientTypes.DocumentEnrichmentConfiguration? = nil,
        indexId: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        syncSchedule: Swift.String? = nil,
        vpcConfiguration: QBusinessClientTypes.DataSourceVpcConfiguration? = nil
    )
    {
        self.applicationId = applicationId
        self.configuration = configuration
        self.dataSourceId = dataSourceId
        self.description = description
        self.displayName = displayName
        self.documentEnrichmentConfiguration = documentEnrichmentConfiguration
        self.indexId = indexId
        self.roleArn = roleArn
        self.syncSchedule = syncSchedule
        self.vpcConfiguration = vpcConfiguration
    }
}

public struct UpdateDataSourceOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteIndexInput: Swift.Sendable {
    /// The identifier of the Amazon Q Business application the Amazon Q Business index is linked to.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the Amazon Q Business index.
    /// This member is required.
    public var indexId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        indexId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.indexId = indexId
    }
}

public struct DeleteIndexOutput: Swift.Sendable {

    public init() { }
}

public struct GetIndexInput: Swift.Sendable {
    /// The identifier of the Amazon Q Business application connected to the index.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the Amazon Q Business index you want information on.
    /// This member is required.
    public var indexId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        indexId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.indexId = indexId
    }
}

extension QBusinessClientTypes {

    public enum Status: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QBusinessClientTypes {

    public enum AttributeType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case date
        case number
        case string
        case stringList
        case sdkUnknown(Swift.String)

        public static var allCases: [AttributeType] {
            return [
                .date,
                .number,
                .string,
                .stringList
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .date: return "DATE"
            case .number: return "NUMBER"
            case .string: return "STRING"
            case .stringList: return "STRING_LIST"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QBusinessClientTypes {

    /// Configuration information for document attributes. Document attributes are metadata or fields associated with your documents. For example, the company department name associated with each document. For more information, see [Understanding document attributes](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/doc-attributes.html).
    public struct DocumentAttributeConfiguration: Swift.Sendable {
        /// The name of the document attribute.
        public var name: Swift.String?
        /// Information about whether the document attribute can be used by an end user to search for information on their web experience.
        public var search: QBusinessClientTypes.Status?
        /// The type of document attribute.
        public var type: QBusinessClientTypes.AttributeType?

        public init(
            name: Swift.String? = nil,
            search: QBusinessClientTypes.Status? = nil,
            type: QBusinessClientTypes.AttributeType? = nil
        )
        {
            self.name = name
            self.search = search
            self.type = type
        }
    }
}

extension QBusinessClientTypes {

    /// Provides information about text documents in an index.
    public struct TextDocumentStatistics: Swift.Sendable {
        /// The total size, in bytes, of the indexed documents.
        public var indexedTextBytes: Swift.Int?
        /// The number of text documents indexed.
        public var indexedTextDocumentCount: Swift.Int?

        public init(
            indexedTextBytes: Swift.Int? = nil,
            indexedTextDocumentCount: Swift.Int? = nil
        )
        {
            self.indexedTextBytes = indexedTextBytes
            self.indexedTextDocumentCount = indexedTextDocumentCount
        }
    }
}

extension QBusinessClientTypes {

    /// Provides information about the number of documents in an index.
    public struct IndexStatistics: Swift.Sendable {
        /// The number of documents indexed.
        public var textDocumentStatistics: QBusinessClientTypes.TextDocumentStatistics?

        public init(
            textDocumentStatistics: QBusinessClientTypes.TextDocumentStatistics? = nil
        )
        {
            self.textDocumentStatistics = textDocumentStatistics
        }
    }
}

extension QBusinessClientTypes {

    public enum IndexStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [IndexStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetIndexOutput: Swift.Sendable {
    /// The identifier of the Amazon Q Business application associated with the index.
    public var applicationId: Swift.String?
    /// The storage capacity units chosen for your Amazon Q Business index.
    public var capacityConfiguration: QBusinessClientTypes.IndexCapacityConfiguration?
    /// The Unix timestamp when the Amazon Q Business index was created.
    public var createdAt: Foundation.Date?
    /// The description for the Amazon Q Business index.
    public var description: Swift.String?
    /// The name of the Amazon Q Business index.
    public var displayName: Swift.String?
    /// Configuration information for document attributes or metadata. Document metadata are fields associated with your documents. For example, the company department name associated with each document. For more information, see [Understanding document attributes](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/doc-attributes-types.html#doc-attributes).
    public var documentAttributeConfigurations: [QBusinessClientTypes.DocumentAttributeConfiguration]?
    /// When the Status field value is FAILED, the ErrorMessage field contains a message that explains why.
    public var error: QBusinessClientTypes.ErrorDetail?
    /// The Amazon Resource Name (ARN) of the Amazon Q Business index.
    public var indexArn: Swift.String?
    /// The identifier of the Amazon Q Business index.
    public var indexId: Swift.String?
    /// Provides information about the number of documents indexed.
    public var indexStatistics: QBusinessClientTypes.IndexStatistics?
    /// The current status of the index. When the value is ACTIVE, the index is ready for use. If the Status field value is FAILED, the ErrorMessage field contains a message that explains why.
    public var status: QBusinessClientTypes.IndexStatus?
    /// The type of index attached to your Amazon Q Business application.
    public var type: QBusinessClientTypes.IndexType?
    /// The Unix timestamp when the Amazon Q Business index was last updated.
    public var updatedAt: Foundation.Date?

    public init(
        applicationId: Swift.String? = nil,
        capacityConfiguration: QBusinessClientTypes.IndexCapacityConfiguration? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        documentAttributeConfigurations: [QBusinessClientTypes.DocumentAttributeConfiguration]? = nil,
        error: QBusinessClientTypes.ErrorDetail? = nil,
        indexArn: Swift.String? = nil,
        indexId: Swift.String? = nil,
        indexStatistics: QBusinessClientTypes.IndexStatistics? = nil,
        status: QBusinessClientTypes.IndexStatus? = nil,
        type: QBusinessClientTypes.IndexType? = nil,
        updatedAt: Foundation.Date? = nil
    )
    {
        self.applicationId = applicationId
        self.capacityConfiguration = capacityConfiguration
        self.createdAt = createdAt
        self.description = description
        self.displayName = displayName
        self.documentAttributeConfigurations = documentAttributeConfigurations
        self.error = error
        self.indexArn = indexArn
        self.indexId = indexId
        self.indexStatistics = indexStatistics
        self.status = status
        self.type = type
        self.updatedAt = updatedAt
    }
}

public struct ListIndicesInput: Swift.Sendable {
    /// The identifier of the Amazon Q Business application connected to the index.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The maximum number of indices to return.
    public var maxResults: Swift.Int?
    /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q Business returns a pagination token in the response. You can use this pagination token to retrieve the next set of Amazon Q Business indices.
    public var nextToken: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension QBusinessClientTypes {

    /// Summary information for your Amazon Q Business index.
    public struct Index: Swift.Sendable {
        /// The Unix timestamp when the index was created.
        public var createdAt: Foundation.Date?
        /// The name of the index.
        public var displayName: Swift.String?
        /// The identifier for the index.
        public var indexId: Swift.String?
        /// The current status of the index. When the status is ACTIVE, the index is ready.
        public var status: QBusinessClientTypes.IndexStatus?
        /// The Unix timestamp when the index was last updated.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            displayName: Swift.String? = nil,
            indexId: Swift.String? = nil,
            status: QBusinessClientTypes.IndexStatus? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.displayName = displayName
            self.indexId = indexId
            self.status = status
            self.updatedAt = updatedAt
        }
    }
}

public struct ListIndicesOutput: Swift.Sendable {
    /// An array of information on the items in one or more indexes.
    public var indices: [QBusinessClientTypes.Index]?
    /// If the response is truncated, Amazon Q Business returns this token that you can use in the subsequent request to retrieve the next set of indexes.
    public var nextToken: Swift.String?

    public init(
        indices: [QBusinessClientTypes.Index]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.indices = indices
        self.nextToken = nextToken
    }
}

public struct UpdateIndexInput: Swift.Sendable {
    /// The identifier of the Amazon Q Business application connected to the index.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The storage capacity units you want to provision for your Amazon Q Business index. You can add and remove capacity to fit your usage needs.
    public var capacityConfiguration: QBusinessClientTypes.IndexCapacityConfiguration?
    /// The description of the Amazon Q Business index.
    public var description: Swift.String?
    /// The name of the Amazon Q Business index.
    public var displayName: Swift.String?
    /// Configuration information for document metadata or fields. Document metadata are fields or attributes associated with your documents. For example, the company department name associated with each document. For more information, see [Understanding document attributes](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/doc-attributes-types.html#doc-attributes).
    public var documentAttributeConfigurations: [QBusinessClientTypes.DocumentAttributeConfiguration]?
    /// The identifier of the Amazon Q Business index.
    /// This member is required.
    public var indexId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        capacityConfiguration: QBusinessClientTypes.IndexCapacityConfiguration? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        documentAttributeConfigurations: [QBusinessClientTypes.DocumentAttributeConfiguration]? = nil,
        indexId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.capacityConfiguration = capacityConfiguration
        self.description = description
        self.displayName = displayName
        self.documentAttributeConfigurations = documentAttributeConfigurations
        self.indexId = indexId
    }
}

public struct UpdateIndexOutput: Swift.Sendable {

    public init() { }
}

public struct ListApplicationsInput: Swift.Sendable {
    /// The maximum number of Amazon Q Business applications to return.
    public var maxResults: Swift.Int?
    /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q Business returns a pagination token in the response. You can use this pagination token to retrieve the next set of Amazon Q Business applications.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListApplicationsOutput: Swift.Sendable {
    /// An array of summary information on the configuration of one or more Amazon Q Business applications.
    public var applications: [QBusinessClientTypes.Application]?
    /// If the response is truncated, Amazon Q Business returns this token. You can use this token in a subsequent request to retrieve the next set of applications.
    public var nextToken: Swift.String?

    public init(
        applications: [QBusinessClientTypes.Application]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applications = applications
        self.nextToken = nextToken
    }
}

extension QBusinessClientTypes {

    /// Information about the basic authentication credentials used to configure a plugin.
    public struct BasicAuthConfiguration: Swift.Sendable {
        /// The ARN of an IAM role used by Amazon Q Business to access the basic authentication credentials stored in a Secrets Manager secret.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The ARN of the Secrets Manager secret that stores the basic authentication credentials used for plugin configuration..
        /// This member is required.
        public var secretArn: Swift.String?

        public init(
            roleArn: Swift.String? = nil,
            secretArn: Swift.String? = nil
        )
        {
            self.roleArn = roleArn
            self.secretArn = secretArn
        }
    }
}

extension QBusinessClientTypes {

    /// Information about invoking a custom plugin without any authentication or authorization requirement.
    public struct NoAuthConfiguration: Swift.Sendable {

        public init() { }
    }
}

extension QBusinessClientTypes {

    /// Information about the OAuth 2.0 authentication credential/token used to configure a plugin.
    public struct OAuth2ClientCredentialConfiguration: Swift.Sendable {
        /// The ARN of an IAM role used by Amazon Q Business to access the OAuth 2.0 authentication credentials stored in a Secrets Manager secret.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The ARN of the Secrets Manager secret that stores the OAuth 2.0 credentials/token used for plugin configuration.
        /// This member is required.
        public var secretArn: Swift.String?

        public init(
            roleArn: Swift.String? = nil,
            secretArn: Swift.String? = nil
        )
        {
            self.roleArn = roleArn
            self.secretArn = secretArn
        }
    }
}

extension QBusinessClientTypes {

    /// Authentication configuration information for an Amazon Q Business plugin.
    public enum PluginAuthConfiguration: Swift.Sendable {
        /// Information about the basic authentication credentials used to configure a plugin.
        case basicauthconfiguration(QBusinessClientTypes.BasicAuthConfiguration)
        /// Information about the OAuth 2.0 authentication credential/token used to configure a plugin.
        case oauth2clientcredentialconfiguration(QBusinessClientTypes.OAuth2ClientCredentialConfiguration)
        /// Information about invoking a custom plugin without any authentication.
        case noauthconfiguration(QBusinessClientTypes.NoAuthConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension QBusinessClientTypes {

    /// Configuration information required to create a custom plugin.
    public struct CustomPluginConfiguration: Swift.Sendable {
        /// Contains either details about the S3 object containing the OpenAPI schema for the action group or the JSON or YAML-formatted payload defining the schema.
        /// This member is required.
        public var apiSchema: QBusinessClientTypes.APISchema?
        /// The type of OpenAPI schema to use.
        /// This member is required.
        public var apiSchemaType: QBusinessClientTypes.APISchemaType?
        /// A description for your custom plugin configuration.
        /// This member is required.
        public var description: Swift.String?

        public init(
            apiSchema: QBusinessClientTypes.APISchema? = nil,
            apiSchemaType: QBusinessClientTypes.APISchemaType? = nil,
            description: Swift.String? = nil
        )
        {
            self.apiSchema = apiSchema
            self.apiSchemaType = apiSchemaType
            self.description = description
        }
    }
}

public struct CreatePluginInput: Swift.Sendable {
    /// The identifier of the application that will contain the plugin.
    /// This member is required.
    public var applicationId: Swift.String?
    /// Authentication configuration information for an Amazon Q Business plugin.
    /// This member is required.
    public var authConfiguration: QBusinessClientTypes.PluginAuthConfiguration?
    /// A token that you provide to identify the request to create your Amazon Q Business plugin.
    public var clientToken: Swift.String?
    /// Contains configuration for a custom plugin.
    public var customPluginConfiguration: QBusinessClientTypes.CustomPluginConfiguration?
    /// A the name for your plugin.
    /// This member is required.
    public var displayName: Swift.String?
    /// The source URL used for plugin configuration.
    public var serverUrl: Swift.String?
    /// A list of key-value pairs that identify or categorize the data source connector. You can also use tags to help control access to the data source connector. Tag keys and values can consist of Unicode letters, digits, white space, and any of the following symbols: _ . : / = + - @.
    public var tags: [QBusinessClientTypes.Tag]?
    /// The type of plugin you want to create.
    /// This member is required.
    public var type: QBusinessClientTypes.PluginType?

    public init(
        applicationId: Swift.String? = nil,
        authConfiguration: QBusinessClientTypes.PluginAuthConfiguration? = nil,
        clientToken: Swift.String? = nil,
        customPluginConfiguration: QBusinessClientTypes.CustomPluginConfiguration? = nil,
        displayName: Swift.String? = nil,
        serverUrl: Swift.String? = nil,
        tags: [QBusinessClientTypes.Tag]? = nil,
        type: QBusinessClientTypes.PluginType? = nil
    )
    {
        self.applicationId = applicationId
        self.authConfiguration = authConfiguration
        self.clientToken = clientToken
        self.customPluginConfiguration = customPluginConfiguration
        self.displayName = displayName
        self.serverUrl = serverUrl
        self.tags = tags
        self.type = type
    }
}

extension QBusinessClientTypes {

    public enum PluginBuildStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createFailed
        case createInProgress
        case deleteFailed
        case deleteInProgress
        case ready
        case updateFailed
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [PluginBuildStatus] {
            return [
                .createFailed,
                .createInProgress,
                .deleteFailed,
                .deleteInProgress,
                .ready,
                .updateFailed,
                .updateInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .ready: return "READY"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreatePluginOutput: Swift.Sendable {
    /// The current status of a plugin. A plugin is modified asynchronously.
    public var buildStatus: QBusinessClientTypes.PluginBuildStatus?
    /// The Amazon Resource Name (ARN) of a plugin.
    public var pluginArn: Swift.String?
    /// The identifier of the plugin created.
    public var pluginId: Swift.String?

    public init(
        buildStatus: QBusinessClientTypes.PluginBuildStatus? = nil,
        pluginArn: Swift.String? = nil,
        pluginId: Swift.String? = nil
    )
    {
        self.buildStatus = buildStatus
        self.pluginArn = pluginArn
        self.pluginId = pluginId
    }
}

public struct DeletePluginInput: Swift.Sendable {
    /// The identifier the application attached to the Amazon Q Business plugin.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the plugin being deleted.
    /// This member is required.
    public var pluginId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        pluginId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.pluginId = pluginId
    }
}

public struct DeletePluginOutput: Swift.Sendable {

    public init() { }
}

public struct GetPluginInput: Swift.Sendable {
    /// The identifier of the application which contains the plugin.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the plugin.
    /// This member is required.
    public var pluginId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        pluginId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.pluginId = pluginId
    }
}

extension QBusinessClientTypes {

    public enum PluginState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [PluginState] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetPluginOutput: Swift.Sendable {
    /// The identifier of the application which contains the plugin.
    public var applicationId: Swift.String?
    /// Authentication configuration information for an Amazon Q Business plugin.
    public var authConfiguration: QBusinessClientTypes.PluginAuthConfiguration?
    /// The current status of a plugin. A plugin is modified asynchronously.
    public var buildStatus: QBusinessClientTypes.PluginBuildStatus?
    /// The timestamp for when the plugin was created.
    public var createdAt: Foundation.Date?
    /// Configuration information required to create a custom plugin.
    public var customPluginConfiguration: QBusinessClientTypes.CustomPluginConfiguration?
    /// The name of the plugin.
    public var displayName: Swift.String?
    /// The Amazon Resource Name (ARN) of the role with permission to access resources needed to create the plugin.
    public var pluginArn: Swift.String?
    /// The identifier of the plugin.
    public var pluginId: Swift.String?
    /// The source URL used for plugin configuration.
    public var serverUrl: Swift.String?
    /// The current state of the plugin.
    public var state: QBusinessClientTypes.PluginState?
    /// The type of the plugin.
    public var type: QBusinessClientTypes.PluginType?
    /// The timestamp for when the plugin was last updated.
    public var updatedAt: Foundation.Date?

    public init(
        applicationId: Swift.String? = nil,
        authConfiguration: QBusinessClientTypes.PluginAuthConfiguration? = nil,
        buildStatus: QBusinessClientTypes.PluginBuildStatus? = nil,
        createdAt: Foundation.Date? = nil,
        customPluginConfiguration: QBusinessClientTypes.CustomPluginConfiguration? = nil,
        displayName: Swift.String? = nil,
        pluginArn: Swift.String? = nil,
        pluginId: Swift.String? = nil,
        serverUrl: Swift.String? = nil,
        state: QBusinessClientTypes.PluginState? = nil,
        type: QBusinessClientTypes.PluginType? = nil,
        updatedAt: Foundation.Date? = nil
    )
    {
        self.applicationId = applicationId
        self.authConfiguration = authConfiguration
        self.buildStatus = buildStatus
        self.createdAt = createdAt
        self.customPluginConfiguration = customPluginConfiguration
        self.displayName = displayName
        self.pluginArn = pluginArn
        self.pluginId = pluginId
        self.serverUrl = serverUrl
        self.state = state
        self.type = type
        self.updatedAt = updatedAt
    }
}

public struct ListPluginsInput: Swift.Sendable {
    /// The identifier of the application the plugin is attached to.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The maximum number of documents to return.
    public var maxResults: Swift.Int?
    /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q Business returns a pagination token in the response. You can use this pagination token to retrieve the next set of plugins.
    public var nextToken: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension QBusinessClientTypes {

    /// Information about an Amazon Q Business plugin and its configuration.
    public struct Plugin: Swift.Sendable {
        /// The status of the plugin.
        public var buildStatus: QBusinessClientTypes.PluginBuildStatus?
        /// The timestamp for when the plugin was created.
        public var createdAt: Foundation.Date?
        /// The name of the plugin.
        public var displayName: Swift.String?
        /// The identifier of the plugin.
        public var pluginId: Swift.String?
        /// The plugin server URL used for configuration.
        public var serverUrl: Swift.String?
        /// The current status of the plugin.
        public var state: QBusinessClientTypes.PluginState?
        /// The type of the plugin.
        public var type: QBusinessClientTypes.PluginType?
        /// The timestamp for when the plugin was last updated.
        public var updatedAt: Foundation.Date?

        public init(
            buildStatus: QBusinessClientTypes.PluginBuildStatus? = nil,
            createdAt: Foundation.Date? = nil,
            displayName: Swift.String? = nil,
            pluginId: Swift.String? = nil,
            serverUrl: Swift.String? = nil,
            state: QBusinessClientTypes.PluginState? = nil,
            type: QBusinessClientTypes.PluginType? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.buildStatus = buildStatus
            self.createdAt = createdAt
            self.displayName = displayName
            self.pluginId = pluginId
            self.serverUrl = serverUrl
            self.state = state
            self.type = type
            self.updatedAt = updatedAt
        }
    }
}

public struct ListPluginsOutput: Swift.Sendable {
    /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q Business returns a pagination token in the response. You can use this pagination token to retrieve the next set of plugins.
    public var nextToken: Swift.String?
    /// Information about a configured plugin.
    public var plugins: [QBusinessClientTypes.Plugin]?

    public init(
        nextToken: Swift.String? = nil,
        plugins: [QBusinessClientTypes.Plugin]? = nil
    )
    {
        self.nextToken = nextToken
        self.plugins = plugins
    }
}

public struct UpdatePluginInput: Swift.Sendable {
    /// The identifier of the application the plugin is attached to.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The authentication configuration the plugin is using.
    public var authConfiguration: QBusinessClientTypes.PluginAuthConfiguration?
    /// The configuration for a custom plugin.
    public var customPluginConfiguration: QBusinessClientTypes.CustomPluginConfiguration?
    /// The name of the plugin.
    public var displayName: Swift.String?
    /// The identifier of the plugin.
    /// This member is required.
    public var pluginId: Swift.String?
    /// The source URL used for plugin configuration.
    public var serverUrl: Swift.String?
    /// The status of the plugin.
    public var state: QBusinessClientTypes.PluginState?

    public init(
        applicationId: Swift.String? = nil,
        authConfiguration: QBusinessClientTypes.PluginAuthConfiguration? = nil,
        customPluginConfiguration: QBusinessClientTypes.CustomPluginConfiguration? = nil,
        displayName: Swift.String? = nil,
        pluginId: Swift.String? = nil,
        serverUrl: Swift.String? = nil,
        state: QBusinessClientTypes.PluginState? = nil
    )
    {
        self.applicationId = applicationId
        self.authConfiguration = authConfiguration
        self.customPluginConfiguration = customPluginConfiguration
        self.displayName = displayName
        self.pluginId = pluginId
        self.serverUrl = serverUrl
        self.state = state
    }
}

public struct UpdatePluginOutput: Swift.Sendable {

    public init() { }
}

extension QBusinessClientTypes {

    /// Stores an Amazon Kendra index as a retriever.
    public struct KendraIndexConfiguration: Swift.Sendable {
        /// The identifier of the Amazon Kendra index.
        /// This member is required.
        public var indexId: Swift.String?

        public init(
            indexId: Swift.String? = nil
        )
        {
            self.indexId = indexId
        }
    }
}

extension QBusinessClientTypes {

    public enum DocumentAttributeBoostingLevel: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case high
        case low
        case medium
        case `none`
        case veryHigh
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentAttributeBoostingLevel] {
            return [
                .high,
                .low,
                .medium,
                .none,
                .veryHigh
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case .none: return "NONE"
            case .veryHigh: return "VERY_HIGH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QBusinessClientTypes {

    /// Provides information on boosting DATE type document attributes. For more information on how boosting document attributes work in Amazon Q Business, see [Boosting using document attributes](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/metadata-boosting.html).
    public struct DateAttributeBoostingConfiguration: Swift.Sendable {
        /// Specifies the duration, in seconds, of a boost applies to a DATE type document attribute.
        public var boostingDurationInSeconds: Swift.Int?
        /// Specifies how much a document attribute is boosted.
        /// This member is required.
        public var boostingLevel: QBusinessClientTypes.DocumentAttributeBoostingLevel?

        public init(
            boostingDurationInSeconds: Swift.Int? = nil,
            boostingLevel: QBusinessClientTypes.DocumentAttributeBoostingLevel? = nil
        )
        {
            self.boostingDurationInSeconds = boostingDurationInSeconds
            self.boostingLevel = boostingLevel
        }
    }
}

extension QBusinessClientTypes {

    public enum NumberAttributeBoostingType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case prioritizeLargerValues
        case prioritizeSmallerValues
        case sdkUnknown(Swift.String)

        public static var allCases: [NumberAttributeBoostingType] {
            return [
                .prioritizeLargerValues,
                .prioritizeSmallerValues
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .prioritizeLargerValues: return "PRIORITIZE_LARGER_VALUES"
            case .prioritizeSmallerValues: return "PRIORITIZE_SMALLER_VALUES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QBusinessClientTypes {

    /// Provides information on boosting NUMBER type document attributes. For more information on how boosting document attributes work in Amazon Q Business, see [Boosting using document attributes](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/metadata-boosting.html).
    public struct NumberAttributeBoostingConfiguration: Swift.Sendable {
        /// Specifies the duration, in seconds, of a boost applies to a NUMBER type document attribute.
        /// This member is required.
        public var boostingLevel: QBusinessClientTypes.DocumentAttributeBoostingLevel?
        /// Specifies how much a document attribute is boosted.
        public var boostingType: QBusinessClientTypes.NumberAttributeBoostingType?

        public init(
            boostingLevel: QBusinessClientTypes.DocumentAttributeBoostingLevel? = nil,
            boostingType: QBusinessClientTypes.NumberAttributeBoostingType? = nil
        )
        {
            self.boostingLevel = boostingLevel
            self.boostingType = boostingType
        }
    }
}

extension QBusinessClientTypes {

    public enum StringAttributeValueBoostingLevel: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case high
        case low
        case medium
        case veryHigh
        case sdkUnknown(Swift.String)

        public static var allCases: [StringAttributeValueBoostingLevel] {
            return [
                .high,
                .low,
                .medium,
                .veryHigh
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case .veryHigh: return "VERY_HIGH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QBusinessClientTypes {

    /// Provides information on boosting STRING type document attributes. For STRING and STRING_LIST type document attributes to be used for boosting on the console and the API, they must be enabled for search using the [DocumentAttributeConfiguration](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeConfiguration.html) object of the [UpdateIndex](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_UpdateIndex.html) API. If you haven't enabled searching on these attributes, you can't boost attributes of these data types on either the console or the API. For more information on how boosting document attributes work in Amazon Q Business, see [Boosting using document attributes](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/metadata-boosting.html).
    public struct StringAttributeBoostingConfiguration: Swift.Sendable {
        /// Specifies specific values of a STRING type document attribute being boosted.
        public var attributeValueBoosting: [Swift.String: QBusinessClientTypes.StringAttributeValueBoostingLevel]?
        /// Specifies how much a document attribute is boosted.
        /// This member is required.
        public var boostingLevel: QBusinessClientTypes.DocumentAttributeBoostingLevel?

        public init(
            attributeValueBoosting: [Swift.String: QBusinessClientTypes.StringAttributeValueBoostingLevel]? = nil,
            boostingLevel: QBusinessClientTypes.DocumentAttributeBoostingLevel? = nil
        )
        {
            self.attributeValueBoosting = attributeValueBoosting
            self.boostingLevel = boostingLevel
        }
    }
}

extension QBusinessClientTypes {

    /// Provides information on boosting STRING_LIST type document attributes. For STRING and STRING_LIST type document attributes to be used for boosting on the console and the API, they must be enabled for search using the [DocumentAttributeConfiguration](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeConfiguration.html) object of the [UpdateIndex](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_UpdateIndex.html) API. If you haven't enabled searching on these attributes, you can't boost attributes of these data types on either the console or the API. For more information on how boosting document attributes work in Amazon Q Business, see [Boosting using document attributes](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/metadata-boosting.html).
    public struct StringListAttributeBoostingConfiguration: Swift.Sendable {
        /// Specifies how much a document attribute is boosted.
        /// This member is required.
        public var boostingLevel: QBusinessClientTypes.DocumentAttributeBoostingLevel?

        public init(
            boostingLevel: QBusinessClientTypes.DocumentAttributeBoostingLevel? = nil
        )
        {
            self.boostingLevel = boostingLevel
        }
    }
}

extension QBusinessClientTypes {

    /// Provides information on boosting supported Amazon Q Business document attribute types. When an end user chat query matches document attributes that have been boosted, Amazon Q Business prioritizes generating responses from content that matches the boosted document attributes. For STRING and STRING_LIST type document attributes to be used for boosting on the console and the API, they must be enabled for search using the [DocumentAttributeConfiguration](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeConfiguration.html) object of the [UpdateIndex](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_UpdateIndex.html) API. If you haven't enabled searching on these attributes, you can't boost attributes of these data types on either the console or the API. For more information on how boosting document attributes work in Amazon Q Business, see [Boosting using document attributes](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/metadata-boosting.html).
    public enum DocumentAttributeBoostingConfiguration: Swift.Sendable {
        /// Provides information on boosting NUMBER type document attributes.
        case numberconfiguration(QBusinessClientTypes.NumberAttributeBoostingConfiguration)
        /// Provides information on boosting STRING type document attributes.
        case stringconfiguration(QBusinessClientTypes.StringAttributeBoostingConfiguration)
        /// Provides information on boosting DATE type document attributes.
        case dateconfiguration(QBusinessClientTypes.DateAttributeBoostingConfiguration)
        /// Provides information on boosting STRING_LIST type document attributes.
        case stringlistconfiguration(QBusinessClientTypes.StringListAttributeBoostingConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension QBusinessClientTypes {

    /// Configuration information for an Amazon Q Business index.
    public struct NativeIndexConfiguration: Swift.Sendable {
        /// Overrides the default boosts applied by Amazon Q Business to supported document attribute data types.
        public var boostingOverride: [Swift.String: QBusinessClientTypes.DocumentAttributeBoostingConfiguration]?
        /// The identifier for the Amazon Q Business index.
        /// This member is required.
        public var indexId: Swift.String?

        public init(
            boostingOverride: [Swift.String: QBusinessClientTypes.DocumentAttributeBoostingConfiguration]? = nil,
            indexId: Swift.String? = nil
        )
        {
            self.boostingOverride = boostingOverride
            self.indexId = indexId
        }
    }
}

extension QBusinessClientTypes {

    /// Provides information on how the retriever used for your Amazon Q Business application is configured.
    public enum RetrieverConfiguration: Swift.Sendable {
        /// Provides information on how a Amazon Q Business index used as a retriever for your Amazon Q Business application is configured.
        case nativeindexconfiguration(QBusinessClientTypes.NativeIndexConfiguration)
        /// Provides information on how the Amazon Kendra index used as a retriever for your Amazon Q Business application is configured.
        case kendraindexconfiguration(QBusinessClientTypes.KendraIndexConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension QBusinessClientTypes {

    public enum RetrieverType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case kendraIndex
        case nativeIndex
        case sdkUnknown(Swift.String)

        public static var allCases: [RetrieverType] {
            return [
                .kendraIndex,
                .nativeIndex
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .kendraIndex: return "KENDRA_INDEX"
            case .nativeIndex: return "NATIVE_INDEX"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateRetrieverInput: Swift.Sendable {
    /// The identifier of your Amazon Q Business application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// A token that you provide to identify the request to create your Amazon Q Business application retriever.
    public var clientToken: Swift.String?
    /// Provides information on how the retriever used for your Amazon Q Business application is configured.
    /// This member is required.
    public var configuration: QBusinessClientTypes.RetrieverConfiguration?
    /// The name of your retriever.
    /// This member is required.
    public var displayName: Swift.String?
    /// The ARN of an IAM role used by Amazon Q Business to access the basic authentication credentials stored in a Secrets Manager secret.
    public var roleArn: Swift.String?
    /// A list of key-value pairs that identify or categorize the retriever. You can also use tags to help control access to the retriever. Tag keys and values can consist of Unicode letters, digits, white space, and any of the following symbols: _ . : / = + - @.
    public var tags: [QBusinessClientTypes.Tag]?
    /// The type of retriever you are using.
    /// This member is required.
    public var type: QBusinessClientTypes.RetrieverType?

    public init(
        applicationId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        configuration: QBusinessClientTypes.RetrieverConfiguration? = nil,
        displayName: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        tags: [QBusinessClientTypes.Tag]? = nil,
        type: QBusinessClientTypes.RetrieverType? = nil
    )
    {
        self.applicationId = applicationId
        self.clientToken = clientToken
        self.configuration = configuration
        self.displayName = displayName
        self.roleArn = roleArn
        self.tags = tags
        self.type = type
    }
}

public struct CreateRetrieverOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of an IAM role associated with a retriever.
    public var retrieverArn: Swift.String?
    /// The identifier of the retriever you are using.
    public var retrieverId: Swift.String?

    public init(
        retrieverArn: Swift.String? = nil,
        retrieverId: Swift.String? = nil
    )
    {
        self.retrieverArn = retrieverArn
        self.retrieverId = retrieverId
    }
}

public struct DeleteRetrieverInput: Swift.Sendable {
    /// The identifier of the Amazon Q Business application using the retriever.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the retriever being deleted.
    /// This member is required.
    public var retrieverId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        retrieverId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.retrieverId = retrieverId
    }
}

public struct DeleteRetrieverOutput: Swift.Sendable {

    public init() { }
}

public struct GetRetrieverInput: Swift.Sendable {
    /// The identifier of the Amazon Q Business application using the retriever.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the retriever.
    /// This member is required.
    public var retrieverId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        retrieverId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.retrieverId = retrieverId
    }
}

extension QBusinessClientTypes {

    public enum RetrieverStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [RetrieverStatus] {
            return [
                .active,
                .creating,
                .failed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetRetrieverOutput: Swift.Sendable {
    /// The identifier of the Amazon Q Business application using the retriever.
    public var applicationId: Swift.String?
    /// Provides information on how the retriever used for your Amazon Q Business application is configured.
    public var configuration: QBusinessClientTypes.RetrieverConfiguration?
    /// The Unix timestamp when the retriever was created.
    public var createdAt: Foundation.Date?
    /// The name of the retriever.
    public var displayName: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role associated with the retriever.
    public var retrieverArn: Swift.String?
    /// The identifier of the retriever.
    public var retrieverId: Swift.String?
    /// The Amazon Resource Name (ARN) of the role with the permission to access the retriever and required resources.
    public var roleArn: Swift.String?
    /// The status of the retriever.
    public var status: QBusinessClientTypes.RetrieverStatus?
    /// The type of the retriever.
    public var type: QBusinessClientTypes.RetrieverType?
    /// The Unix timestamp when the retriever was last updated.
    public var updatedAt: Foundation.Date?

    public init(
        applicationId: Swift.String? = nil,
        configuration: QBusinessClientTypes.RetrieverConfiguration? = nil,
        createdAt: Foundation.Date? = nil,
        displayName: Swift.String? = nil,
        retrieverArn: Swift.String? = nil,
        retrieverId: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        status: QBusinessClientTypes.RetrieverStatus? = nil,
        type: QBusinessClientTypes.RetrieverType? = nil,
        updatedAt: Foundation.Date? = nil
    )
    {
        self.applicationId = applicationId
        self.configuration = configuration
        self.createdAt = createdAt
        self.displayName = displayName
        self.retrieverArn = retrieverArn
        self.retrieverId = retrieverId
        self.roleArn = roleArn
        self.status = status
        self.type = type
        self.updatedAt = updatedAt
    }
}

public struct ListRetrieversInput: Swift.Sendable {
    /// The identifier of the Amazon Q Business application using the retriever.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The maximum number of retrievers returned.
    public var maxResults: Swift.Int?
    /// If the number of retrievers returned exceeds maxResults, Amazon Q Business returns a next token as a pagination token to retrieve the next set of retrievers.
    public var nextToken: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension QBusinessClientTypes {

    /// Summary information for the retriever used for your Amazon Q Business application.
    public struct Retriever: Swift.Sendable {
        /// The identifier of the Amazon Q Business application using the retriever.
        public var applicationId: Swift.String?
        /// The name of your retriever.
        public var displayName: Swift.String?
        /// The identifier of the retriever used by your Amazon Q Business application.
        public var retrieverId: Swift.String?
        /// The status of your retriever.
        public var status: QBusinessClientTypes.RetrieverStatus?
        /// The type of your retriever.
        public var type: QBusinessClientTypes.RetrieverType?

        public init(
            applicationId: Swift.String? = nil,
            displayName: Swift.String? = nil,
            retrieverId: Swift.String? = nil,
            status: QBusinessClientTypes.RetrieverStatus? = nil,
            type: QBusinessClientTypes.RetrieverType? = nil
        )
        {
            self.applicationId = applicationId
            self.displayName = displayName
            self.retrieverId = retrieverId
            self.status = status
            self.type = type
        }
    }
}

public struct ListRetrieversOutput: Swift.Sendable {
    /// If the response is truncated, Amazon Q Business returns this token, which you can use in a later request to list the next set of retrievers.
    public var nextToken: Swift.String?
    /// An array of summary information for one or more retrievers.
    public var retrievers: [QBusinessClientTypes.Retriever]?

    public init(
        nextToken: Swift.String? = nil,
        retrievers: [QBusinessClientTypes.Retriever]? = nil
    )
    {
        self.nextToken = nextToken
        self.retrievers = retrievers
    }
}

public struct UpdateRetrieverInput: Swift.Sendable {
    /// The identifier of your Amazon Q Business application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// Provides information on how the retriever used for your Amazon Q Business application is configured.
    public var configuration: QBusinessClientTypes.RetrieverConfiguration?
    /// The name of your retriever.
    public var displayName: Swift.String?
    /// The identifier of your retriever.
    /// This member is required.
    public var retrieverId: Swift.String?
    /// The Amazon Resource Name (ARN) of an IAM role with permission to access the retriever and required resources.
    public var roleArn: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        configuration: QBusinessClientTypes.RetrieverConfiguration? = nil,
        displayName: Swift.String? = nil,
        retrieverId: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.configuration = configuration
        self.displayName = displayName
        self.retrieverId = retrieverId
        self.roleArn = roleArn
    }
}

public struct UpdateRetrieverOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateApplicationInput: Swift.Sendable {
    /// The identifier of the Amazon Q Business application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// An option to allow end users to upload files directly during chat.
    public var attachmentsConfiguration: QBusinessClientTypes.AttachmentsConfiguration?
    /// An option to enable updating the default subscription type assigned to an Amazon Q Business application using IAM identity federation for user management.
    public var autoSubscriptionConfiguration: QBusinessClientTypes.AutoSubscriptionConfiguration?
    /// A description for the Amazon Q Business application.
    public var description: Swift.String?
    /// A name for the Amazon Q Business application.
    public var displayName: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM Identity Center instance you are either creating for—or connecting to—your Amazon Q Business application.
    public var identityCenterInstanceArn: Swift.String?
    /// Configuration information about chat response personalization. For more information, see [Personalizing chat responses](https://docs.aws.amazon.com/amazonq/latest/qbusiness-ug/personalizing-chat-responses.html).
    public var personalizationConfiguration: QBusinessClientTypes.PersonalizationConfiguration?
    /// An option to allow end users to create and use Amazon Q Apps in the web experience.
    public var qAppsConfiguration: QBusinessClientTypes.QAppsConfiguration?
    /// An Amazon Web Services Identity and Access Management (IAM) role that gives Amazon Q Business permission to access Amazon CloudWatch logs and metrics.
    public var roleArn: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        attachmentsConfiguration: QBusinessClientTypes.AttachmentsConfiguration? = nil,
        autoSubscriptionConfiguration: QBusinessClientTypes.AutoSubscriptionConfiguration? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        identityCenterInstanceArn: Swift.String? = nil,
        personalizationConfiguration: QBusinessClientTypes.PersonalizationConfiguration? = nil,
        qAppsConfiguration: QBusinessClientTypes.QAppsConfiguration? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.attachmentsConfiguration = attachmentsConfiguration
        self.autoSubscriptionConfiguration = autoSubscriptionConfiguration
        self.description = description
        self.displayName = displayName
        self.identityCenterInstanceArn = identityCenterInstanceArn
        self.personalizationConfiguration = personalizationConfiguration
        self.qAppsConfiguration = qAppsConfiguration
        self.roleArn = roleArn
    }
}

public struct UpdateApplicationOutput: Swift.Sendable {

    public init() { }
}

extension QBusinessClientTypes {

    /// Information about the OIDC-compliant identity provider (IdP) used to authenticate end users of an Amazon Q Business web experience.
    public struct OpenIDConnectProviderConfiguration: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of a Secrets Manager secret containing the OIDC client secret.
        /// This member is required.
        public var secretsArn: Swift.String?
        /// An IAM role with permissions to access KMS to decrypt the Secrets Manager secret containing your OIDC client secret.
        /// This member is required.
        public var secretsRole: Swift.String?

        public init(
            secretsArn: Swift.String? = nil,
            secretsRole: Swift.String? = nil
        )
        {
            self.secretsArn = secretsArn
            self.secretsRole = secretsRole
        }
    }
}

extension QBusinessClientTypes {

    /// Information about the SAML 2.0-compliant identity provider (IdP) used to authenticate end users of an Amazon Q Business web experience.
    public struct SamlProviderConfiguration: Swift.Sendable {
        /// The URL where Amazon Q Business end users will be redirected for authentication.
        /// This member is required.
        public var authenticationUrl: Swift.String?

        public init(
            authenticationUrl: Swift.String? = nil
        )
        {
            self.authenticationUrl = authenticationUrl
        }
    }
}

extension QBusinessClientTypes {

    /// Provides information about the identity provider (IdP) used to authenticate end users of an Amazon Q Business web experience.
    public enum IdentityProviderConfiguration: Swift.Sendable {
        /// Information about the SAML 2.0-compliant identity provider (IdP) used to authenticate end users of an Amazon Q Business web experience.
        case samlconfiguration(QBusinessClientTypes.SamlProviderConfiguration)
        /// Information about the OIDC-compliant identity provider (IdP) used to authenticate end users of an Amazon Q Business web experience.
        case openidconnectconfiguration(QBusinessClientTypes.OpenIDConnectProviderConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension QBusinessClientTypes {

    public enum WebExperienceSamplePromptsControlMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [WebExperienceSamplePromptsControlMode] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateWebExperienceInput: Swift.Sendable {
    /// The identifier of the Amazon Q Business web experience.
    /// This member is required.
    public var applicationId: Swift.String?
    /// A token you provide to identify a request to create an Amazon Q Business web experience.
    public var clientToken: Swift.String?
    /// Information about the identity provider (IdP) used to authenticate end users of an Amazon Q Business web experience.
    public var identityProviderConfiguration: QBusinessClientTypes.IdentityProviderConfiguration?
    /// Sets the website domain origins that are allowed to embed the Amazon Q Business web experience. The domain origin refers to the base URL for accessing a website including the protocol (http/https), the domain name, and the port number (if specified). You must only submit a base URL and not a full path. For example, https://docs.aws.amazon.com.
    public var origins: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the service role attached to your web experience. You must provide this value if you're using IAM Identity Center to manage end user access to your application. If you're using legacy identity management to manage user access, you don't need to provide this value.
    public var roleArn: Swift.String?
    /// Determines whether sample prompts are enabled in the web experience for an end user.
    public var samplePromptsControlMode: QBusinessClientTypes.WebExperienceSamplePromptsControlMode?
    /// A subtitle to personalize your Amazon Q Business web experience.
    public var subtitle: Swift.String?
    /// A list of key-value pairs that identify or categorize your Amazon Q Business web experience. You can also use tags to help control access to the web experience. Tag keys and values can consist of Unicode letters, digits, white space, and any of the following symbols: _ . : / = + - @.
    public var tags: [QBusinessClientTypes.Tag]?
    /// The title for your Amazon Q Business web experience.
    public var title: Swift.String?
    /// The customized welcome message for end users of an Amazon Q Business web experience.
    public var welcomeMessage: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        identityProviderConfiguration: QBusinessClientTypes.IdentityProviderConfiguration? = nil,
        origins: [Swift.String]? = nil,
        roleArn: Swift.String? = nil,
        samplePromptsControlMode: QBusinessClientTypes.WebExperienceSamplePromptsControlMode? = nil,
        subtitle: Swift.String? = nil,
        tags: [QBusinessClientTypes.Tag]? = nil,
        title: Swift.String? = nil,
        welcomeMessage: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.clientToken = clientToken
        self.identityProviderConfiguration = identityProviderConfiguration
        self.origins = origins
        self.roleArn = roleArn
        self.samplePromptsControlMode = samplePromptsControlMode
        self.subtitle = subtitle
        self.tags = tags
        self.title = title
        self.welcomeMessage = welcomeMessage
    }
}

public struct CreateWebExperienceOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of an Amazon Q Business web experience.
    public var webExperienceArn: Swift.String?
    /// The identifier of the Amazon Q Business web experience.
    public var webExperienceId: Swift.String?

    public init(
        webExperienceArn: Swift.String? = nil,
        webExperienceId: Swift.String? = nil
    )
    {
        self.webExperienceArn = webExperienceArn
        self.webExperienceId = webExperienceId
    }
}

public struct DeleteWebExperienceInput: Swift.Sendable {
    /// The identifier of the Amazon Q Business application linked to the Amazon Q Business web experience.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the Amazon Q Business web experience being deleted.
    /// This member is required.
    public var webExperienceId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        webExperienceId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.webExperienceId = webExperienceId
    }
}

public struct DeleteWebExperienceOutput: Swift.Sendable {

    public init() { }
}

public struct GetWebExperienceInput: Swift.Sendable {
    /// The identifier of the Amazon Q Business application linked to the web experience.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the Amazon Q Business web experience.
    /// This member is required.
    public var webExperienceId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        webExperienceId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.webExperienceId = webExperienceId
    }
}

extension QBusinessClientTypes {

    /// Provides the SAML 2.0 compliant identity provider (IdP) configuration information Amazon Q Business needs to deploy a Amazon Q Business web experience.
    public struct SamlConfiguration: Swift.Sendable {
        /// The metadata XML that your IdP generated.
        /// This member is required.
        public var metadataXML: Swift.String?
        /// The Amazon Resource Name (ARN) of an IAM role assumed by users when they authenticate into their Amazon Q Business web experience, containing the relevant Amazon Q Business permissions for conversing with Amazon Q Business.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The group attribute name in your IdP that maps to user groups.
        public var userGroupAttribute: Swift.String?
        /// The user attribute name in your IdP that maps to the user email.
        /// This member is required.
        public var userIdAttribute: Swift.String?

        public init(
            metadataXML: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            userGroupAttribute: Swift.String? = nil,
            userIdAttribute: Swift.String? = nil
        )
        {
            self.metadataXML = metadataXML
            self.roleArn = roleArn
            self.userGroupAttribute = userGroupAttribute
            self.userIdAttribute = userIdAttribute
        }
    }
}

extension QBusinessClientTypes {

    /// Provides the authorization configuration information needed to deploy a Amazon Q Business web experience to end users.
    public enum WebExperienceAuthConfiguration: Swift.Sendable {
        /// Provides the SAML 2.0 compliant identity provider (IdP) configuration information Amazon Q Business needs to deploy a Amazon Q Business web experience.
        case samlconfiguration(QBusinessClientTypes.SamlConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension QBusinessClientTypes {

    public enum WebExperienceStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case pendingAuthConfig
        case sdkUnknown(Swift.String)

        public static var allCases: [WebExperienceStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .pendingAuthConfig
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .pendingAuthConfig: return "PENDING_AUTH_CONFIG"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetWebExperienceOutput: Swift.Sendable {
    /// The identifier of the Amazon Q Business application linked to the web experience.
    public var applicationId: Swift.String?
    /// The authentication configuration information for your Amazon Q Business web experience.
    @available(*, deprecated, message: "Property associated with legacy SAML IdP flow. Deprecated in favor of using AWS IAM Identity Center for user management.")
    public var authenticationConfiguration: QBusinessClientTypes.WebExperienceAuthConfiguration?
    /// The Unix timestamp when the Amazon Q Business web experience was last created.
    public var createdAt: Foundation.Date?
    /// The endpoint of your Amazon Q Business web experience.
    public var defaultEndpoint: Swift.String?
    /// When the Status field value is FAILED, the ErrorMessage field contains a description of the error that caused the data source connector to fail.
    public var error: QBusinessClientTypes.ErrorDetail?
    /// Information about the identity provider (IdP) used to authenticate end users of an Amazon Q Business web experience.
    public var identityProviderConfiguration: QBusinessClientTypes.IdentityProviderConfiguration?
    /// Gets the website domain origins that are allowed to embed the Amazon Q Business web experience. The domain origin refers to the base URL for accessing a website including the protocol (http/https), the domain name, and the port number (if specified).
    public var origins: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the service role attached to your web experience.
    public var roleArn: Swift.String?
    /// Determines whether sample prompts are enabled in the web experience for an end user.
    public var samplePromptsControlMode: QBusinessClientTypes.WebExperienceSamplePromptsControlMode?
    /// The current status of the Amazon Q Business web experience. When the Status field value is FAILED, the ErrorMessage field contains a description of the error that caused the data source connector to fail.
    public var status: QBusinessClientTypes.WebExperienceStatus?
    /// The subtitle for your Amazon Q Business web experience.
    public var subtitle: Swift.String?
    /// The title for your Amazon Q Business web experience.
    public var title: Swift.String?
    /// The Unix timestamp when the Amazon Q Business web experience was last updated.
    public var updatedAt: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the role with the permission to access the Amazon Q Business web experience and required resources.
    public var webExperienceArn: Swift.String?
    /// The identifier of the Amazon Q Business web experience.
    public var webExperienceId: Swift.String?
    /// The customized welcome message for end users of an Amazon Q Business web experience.
    public var welcomeMessage: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        authenticationConfiguration: QBusinessClientTypes.WebExperienceAuthConfiguration? = nil,
        createdAt: Foundation.Date? = nil,
        defaultEndpoint: Swift.String? = nil,
        error: QBusinessClientTypes.ErrorDetail? = nil,
        identityProviderConfiguration: QBusinessClientTypes.IdentityProviderConfiguration? = nil,
        origins: [Swift.String]? = nil,
        roleArn: Swift.String? = nil,
        samplePromptsControlMode: QBusinessClientTypes.WebExperienceSamplePromptsControlMode? = nil,
        status: QBusinessClientTypes.WebExperienceStatus? = nil,
        subtitle: Swift.String? = nil,
        title: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        webExperienceArn: Swift.String? = nil,
        webExperienceId: Swift.String? = nil,
        welcomeMessage: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.authenticationConfiguration = authenticationConfiguration
        self.createdAt = createdAt
        self.defaultEndpoint = defaultEndpoint
        self.error = error
        self.identityProviderConfiguration = identityProviderConfiguration
        self.origins = origins
        self.roleArn = roleArn
        self.samplePromptsControlMode = samplePromptsControlMode
        self.status = status
        self.subtitle = subtitle
        self.title = title
        self.updatedAt = updatedAt
        self.webExperienceArn = webExperienceArn
        self.webExperienceId = webExperienceId
        self.welcomeMessage = welcomeMessage
    }
}

public struct ListWebExperiencesInput: Swift.Sendable {
    /// The identifier of the Amazon Q Business application linked to the listed web experiences.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The maximum number of Amazon Q Business Web Experiences to return.
    public var maxResults: Swift.Int?
    /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q Business returns a pagination token in the response. You can use this pagination token to retrieve the next set of Amazon Q Business conversations.
    public var nextToken: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension QBusinessClientTypes {

    /// Provides information for an Amazon Q Business web experience.
    public struct WebExperience: Swift.Sendable {
        /// The Unix timestamp when the Amazon Q Business application was last updated.
        public var createdAt: Foundation.Date?
        /// The endpoint URLs for your Amazon Q Business web experience. The URLs are unique and fully hosted by Amazon Web Services.
        public var defaultEndpoint: Swift.String?
        /// The status of your Amazon Q Business web experience.
        public var status: QBusinessClientTypes.WebExperienceStatus?
        /// The Unix timestamp when your Amazon Q Business web experience was updated.
        public var updatedAt: Foundation.Date?
        /// The identifier of your Amazon Q Business web experience.
        public var webExperienceId: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            defaultEndpoint: Swift.String? = nil,
            status: QBusinessClientTypes.WebExperienceStatus? = nil,
            updatedAt: Foundation.Date? = nil,
            webExperienceId: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.defaultEndpoint = defaultEndpoint
            self.status = status
            self.updatedAt = updatedAt
            self.webExperienceId = webExperienceId
        }
    }
}

public struct ListWebExperiencesOutput: Swift.Sendable {
    /// If the response is truncated, Amazon Q Business returns this token, which you can use in a later request to list the next set of messages.
    public var nextToken: Swift.String?
    /// An array of summary information for one or more Amazon Q Business experiences.
    public var webExperiences: [QBusinessClientTypes.WebExperience]?

    public init(
        nextToken: Swift.String? = nil,
        webExperiences: [QBusinessClientTypes.WebExperience]? = nil
    )
    {
        self.nextToken = nextToken
        self.webExperiences = webExperiences
    }
}

public struct UpdateWebExperienceInput: Swift.Sendable {
    /// The identifier of the Amazon Q Business application attached to the web experience.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The authentication configuration of the Amazon Q Business web experience.
    @available(*, deprecated, message: "Property associated with legacy SAML IdP flow. Deprecated in favor of using AWS IAM Identity Center for user management.")
    public var authenticationConfiguration: QBusinessClientTypes.WebExperienceAuthConfiguration?
    /// Information about the identity provider (IdP) used to authenticate end users of an Amazon Q Business web experience.
    public var identityProviderConfiguration: QBusinessClientTypes.IdentityProviderConfiguration?
    /// Updates the website domain origins that are allowed to embed the Amazon Q Business web experience. The domain origin refers to the base URL for accessing a website including the protocol (http/https), the domain name, and the port number (if specified).
    ///
    /// * Any values except null submitted as part of this update will replace all previous values.
    ///
    /// * You must only submit a base URL and not a full path. For example, https://docs.aws.amazon.com.
    public var origins: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the role with permission to access the Amazon Q Business web experience and required resources.
    public var roleArn: Swift.String?
    /// Determines whether sample prompts are enabled in the web experience for an end user.
    public var samplePromptsControlMode: QBusinessClientTypes.WebExperienceSamplePromptsControlMode?
    /// The subtitle of the Amazon Q Business web experience.
    public var subtitle: Swift.String?
    /// The title of the Amazon Q Business web experience.
    public var title: Swift.String?
    /// The identifier of the Amazon Q Business web experience.
    /// This member is required.
    public var webExperienceId: Swift.String?
    /// A customized welcome message for an end user in an Amazon Q Business web experience.
    public var welcomeMessage: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        authenticationConfiguration: QBusinessClientTypes.WebExperienceAuthConfiguration? = nil,
        identityProviderConfiguration: QBusinessClientTypes.IdentityProviderConfiguration? = nil,
        origins: [Swift.String]? = nil,
        roleArn: Swift.String? = nil,
        samplePromptsControlMode: QBusinessClientTypes.WebExperienceSamplePromptsControlMode? = nil,
        subtitle: Swift.String? = nil,
        title: Swift.String? = nil,
        webExperienceId: Swift.String? = nil,
        welcomeMessage: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.authenticationConfiguration = authenticationConfiguration
        self.identityProviderConfiguration = identityProviderConfiguration
        self.origins = origins
        self.roleArn = roleArn
        self.samplePromptsControlMode = samplePromptsControlMode
        self.subtitle = subtitle
        self.title = title
        self.webExperienceId = webExperienceId
        self.welcomeMessage = welcomeMessage
    }
}

public struct UpdateWebExperienceOutput: Swift.Sendable {

    public init() { }
}

extension QBusinessClientTypes {

    public enum CreatorModeControl: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [CreatorModeControl] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QBusinessClientTypes {

    /// The creator mode specific admin controls configured for an Amazon Q Business application. Determines whether an end user can generate LLM-only responses when they use the web experience. For more information, see [Admin controls and guardrails](https://docs.aws.amazon.com/amazonq/latest/qbusiness-ug/guardrails.html) and [Conversation settings](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/using-web-experience.html#chat-source-scope).
    public struct AppliedCreatorModeConfiguration: Swift.Sendable {
        /// Information about whether creator mode is enabled or disabled for an Amazon Q Business application.
        /// This member is required.
        public var creatorModeControl: QBusinessClientTypes.CreatorModeControl?

        public init(
            creatorModeControl: QBusinessClientTypes.CreatorModeControl? = nil
        )
        {
            self.creatorModeControl = creatorModeControl
        }
    }
}

extension QBusinessClientTypes {

    /// A file directly uploaded into a web experience chat.
    public struct AttachmentInput: Swift.Sendable {
        /// The data contained within the uploaded file.
        /// This member is required.
        public var data: Foundation.Data?
        /// The name of the file.
        /// This member is required.
        public var name: Swift.String?

        public init(
            data: Foundation.Data? = nil,
            name: Swift.String? = nil
        )
        {
            self.data = data
            self.name = name
        }
    }
}

extension QBusinessClientTypes {

    /// A file input event activated by a end user request to upload files into their web experience chat.
    public struct AttachmentInputEvent: Swift.Sendable {
        /// A file directly uploaded into a web experience chat.
        public var attachment: QBusinessClientTypes.AttachmentInput?

        public init(
            attachment: QBusinessClientTypes.AttachmentInput? = nil
        )
        {
            self.attachment = attachment
        }
    }
}

extension QBusinessClientTypes {

    public enum AttachmentStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [AttachmentStatus] {
            return [
                .failed,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QBusinessClientTypes {

    /// The details of a file uploaded during chat.
    public struct AttachmentOutput: Swift.Sendable {
        /// An error associated with a file uploaded during chat.
        public var error: QBusinessClientTypes.ErrorDetail?
        /// The name of a file uploaded during chat.
        public var name: Swift.String?
        /// The status of a file uploaded during chat.
        public var status: QBusinessClientTypes.AttachmentStatus?

        public init(
            error: QBusinessClientTypes.ErrorDetail? = nil,
            name: Swift.String? = nil,
            status: QBusinessClientTypes.AttachmentStatus? = nil
        )
        {
            self.error = error
            self.name = name
            self.status = status
        }
    }
}

extension QBusinessClientTypes {

    /// A document attribute or metadata field.
    public struct DocumentAttribute: Swift.Sendable {
        /// The identifier for the attribute.
        /// This member is required.
        public var name: Swift.String?
        /// The value of the attribute.
        /// This member is required.
        public var value: QBusinessClientTypes.DocumentAttributeValue?

        public init(
            name: Swift.String? = nil,
            value: QBusinessClientTypes.DocumentAttributeValue? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }
}

extension QBusinessClientTypes {

    /// A request made by Amazon Q Business to a third paty authentication server to authenticate a custom plugin user.
    public struct AuthChallengeRequest: Swift.Sendable {
        /// The URL sent by Amazon Q Business to the third party authentication server to authenticate a custom plugin user through an OAuth protocol.
        /// This member is required.
        public var authorizationUrl: Swift.String?

        public init(
            authorizationUrl: Swift.String? = nil
        )
        {
            self.authorizationUrl = authorizationUrl
        }
    }
}

extension QBusinessClientTypes {

    /// An authentication verification event activated by an end user request to use a custom plugin.
    public struct AuthChallengeRequestEvent: Swift.Sendable {
        /// The URL sent by Amazon Q Business to a third party authentication server in response to an authentication verification event activated by an end user request to use a custom plugin.
        /// This member is required.
        public var authorizationUrl: Swift.String?

        public init(
            authorizationUrl: Swift.String? = nil
        )
        {
            self.authorizationUrl = authorizationUrl
        }
    }
}

extension QBusinessClientTypes {

    /// Contains details of the authentication information received from a third party authentication server in response to an authentication challenge.
    public struct AuthChallengeResponse: Swift.Sendable {
        /// The mapping of key-value pairs in an authentication challenge response.
        /// This member is required.
        public var responseMap: [Swift.String: Swift.String]?

        public init(
            responseMap: [Swift.String: Swift.String]? = nil
        )
        {
            self.responseMap = responseMap
        }
    }
}

extension QBusinessClientTypes {

    /// An authentication verification event response by a third party authentication server to Amazon Q Business.
    public struct AuthChallengeResponseEvent: Swift.Sendable {
        /// The mapping of key-value pairs in an authentication challenge response.
        /// This member is required.
        public var responseMap: [Swift.String: Swift.String]?

        public init(
            responseMap: [Swift.String: Swift.String]? = nil
        )
        {
            self.responseMap = responseMap
        }
    }
}

extension QBusinessClientTypes {

    /// A document deleted from an Amazon Q Business data source connector.
    public struct DeleteDocument: Swift.Sendable {
        /// The identifier of the deleted document.
        /// This member is required.
        public var documentId: Swift.String?

        public init(
            documentId: Swift.String? = nil
        )
        {
            self.documentId = documentId
        }
    }
}

public struct BatchDeleteDocumentInput: Swift.Sendable {
    /// The identifier of the Amazon Q Business application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the data source sync during which the documents were deleted.
    public var dataSourceSyncId: Swift.String?
    /// Documents deleted from the Amazon Q Business index.
    /// This member is required.
    public var documents: [QBusinessClientTypes.DeleteDocument]?
    /// The identifier of the Amazon Q Business index that contains the documents to delete.
    /// This member is required.
    public var indexId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        dataSourceSyncId: Swift.String? = nil,
        documents: [QBusinessClientTypes.DeleteDocument]? = nil,
        indexId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.dataSourceSyncId = dataSourceSyncId
        self.documents = documents
        self.indexId = indexId
    }
}

extension QBusinessClientTypes {

    /// A list of documents that could not be removed from an Amazon Q Business index. Each entry contains an error message that indicates why the document couldn't be removed from the index.
    public struct FailedDocument: Swift.Sendable {
        /// The identifier of the Amazon Q Business data source connector that contains the failed document.
        public var dataSourceId: Swift.String?
        /// An explanation for why the document couldn't be removed from the index.
        public var error: QBusinessClientTypes.ErrorDetail?
        /// The identifier of the document that couldn't be removed from the Amazon Q Business index.
        public var id: Swift.String?

        public init(
            dataSourceId: Swift.String? = nil,
            error: QBusinessClientTypes.ErrorDetail? = nil,
            id: Swift.String? = nil
        )
        {
            self.dataSourceId = dataSourceId
            self.error = error
            self.id = id
        }
    }
}

public struct BatchDeleteDocumentOutput: Swift.Sendable {
    /// A list of documents that couldn't be removed from the Amazon Q Business index. Each entry contains an error message that indicates why the document couldn't be removed from the index.
    public var failedDocuments: [QBusinessClientTypes.FailedDocument]?

    public init(
        failedDocuments: [QBusinessClientTypes.FailedDocument]? = nil
    )
    {
        self.failedDocuments = failedDocuments
    }
}

extension QBusinessClientTypes {

    /// The contents of a document.
    public enum DocumentContent: Swift.Sendable {
        /// The contents of the document. Documents passed to the blob parameter must be base64 encoded. Your code might not need to encode the document file bytes if you're using an Amazon Web Services SDK to call Amazon Q Business APIs. If you are calling the Amazon Q Business endpoint directly using REST, you must base64 encode the contents before sending.
        case blob(Foundation.Data)
        /// The path to the document in an Amazon S3 bucket.
        case s3(QBusinessClientTypes.S3)
        case sdkUnknown(Swift.String)
    }
}

extension QBusinessClientTypes {

    public enum ContentType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case csv
        case html
        case json
        case md
        case msExcel
        case msWord
        case pdf
        case plainText
        case ppt
        case rtf
        case xml
        case xslt
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentType] {
            return [
                .csv,
                .html,
                .json,
                .md,
                .msExcel,
                .msWord,
                .pdf,
                .plainText,
                .ppt,
                .rtf,
                .xml,
                .xslt
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .html: return "HTML"
            case .json: return "JSON"
            case .md: return "MD"
            case .msExcel: return "MS_EXCEL"
            case .msWord: return "MS_WORD"
            case .pdf: return "PDF"
            case .plainText: return "PLAIN_TEXT"
            case .ppt: return "PPT"
            case .rtf: return "RTF"
            case .xml: return "XML"
            case .xslt: return "XSLT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QBusinessClientTypes {

    /// A document in an Amazon Q Business application.
    public struct Document: Swift.Sendable {
        /// Configuration information for access permission to a document.
        public var accessConfiguration: QBusinessClientTypes.AccessConfiguration?
        /// Custom attributes to apply to the document for refining Amazon Q Business web experience responses.
        public var attributes: [QBusinessClientTypes.DocumentAttribute]?
        /// The contents of the document.
        public var content: QBusinessClientTypes.DocumentContent?
        /// The file type of the document in the Blob field. If you want to index snippets or subsets of HTML documents instead of the entirety of the HTML documents, you add the HTML start and closing tags (<HTML>content</HTML>) around the content.
        public var contentType: QBusinessClientTypes.ContentType?
        /// The configuration information for altering document metadata and content during the document ingestion process.
        public var documentEnrichmentConfiguration: QBusinessClientTypes.DocumentEnrichmentConfiguration?
        /// The identifier of the document.
        /// This member is required.
        public var id: Swift.String?
        /// The title of the document.
        public var title: Swift.String?

        public init(
            accessConfiguration: QBusinessClientTypes.AccessConfiguration? = nil,
            attributes: [QBusinessClientTypes.DocumentAttribute]? = nil,
            content: QBusinessClientTypes.DocumentContent? = nil,
            contentType: QBusinessClientTypes.ContentType? = nil,
            documentEnrichmentConfiguration: QBusinessClientTypes.DocumentEnrichmentConfiguration? = nil,
            id: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.accessConfiguration = accessConfiguration
            self.attributes = attributes
            self.content = content
            self.contentType = contentType
            self.documentEnrichmentConfiguration = documentEnrichmentConfiguration
            self.id = id
            self.title = title
        }
    }
}

public struct BatchPutDocumentInput: Swift.Sendable {
    /// The identifier of the Amazon Q Business application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the data source sync during which the documents were added.
    public var dataSourceSyncId: Swift.String?
    /// One or more documents to add to the index.
    /// This member is required.
    public var documents: [QBusinessClientTypes.Document]?
    /// The identifier of the Amazon Q Business index to add the documents to.
    /// This member is required.
    public var indexId: Swift.String?
    /// The Amazon Resource Name (ARN) of an IAM role with permission to access your S3 bucket.
    public var roleArn: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        dataSourceSyncId: Swift.String? = nil,
        documents: [QBusinessClientTypes.Document]? = nil,
        indexId: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.dataSourceSyncId = dataSourceSyncId
        self.documents = documents
        self.indexId = indexId
        self.roleArn = roleArn
    }
}

public struct BatchPutDocumentOutput: Swift.Sendable {
    /// A list of documents that were not added to the Amazon Q Business index because the document failed a validation check. Each document contains an error message that indicates why the document couldn't be added to the index.
    public var failedDocuments: [QBusinessClientTypes.FailedDocument]?

    public init(
        failedDocuments: [QBusinessClientTypes.FailedDocument]? = nil
    )
    {
        self.failedDocuments = failedDocuments
    }
}

extension QBusinessClientTypes {

    /// Provides information about the phrases blocked from chat by your chat control configuration.
    public struct BlockedPhrasesConfiguration: Swift.Sendable {
        /// A list of phrases blocked from a Amazon Q Business web experience chat.
        public var blockedPhrases: [Swift.String]?
        /// The configured custom message displayed to an end user informing them that they've used a blocked phrase during chat.
        public var systemMessageOverride: Swift.String?

        public init(
            blockedPhrases: [Swift.String]? = nil,
            systemMessageOverride: Swift.String? = nil
        )
        {
            self.blockedPhrases = blockedPhrases
            self.systemMessageOverride = systemMessageOverride
        }
    }
}

extension QBusinessClientTypes {

    /// Updates a blocked phrases configuration in your Amazon Q Business application.
    public struct BlockedPhrasesConfigurationUpdate: Swift.Sendable {
        /// Creates or updates a blocked phrases configuration in your Amazon Q Business application.
        public var blockedPhrasesToCreateOrUpdate: [Swift.String]?
        /// Deletes a blocked phrases configuration in your Amazon Q Business application.
        public var blockedPhrasesToDelete: [Swift.String]?
        /// The configured custom message displayed to your end user when they use blocked phrase during chat.
        public var systemMessageOverride: Swift.String?

        public init(
            blockedPhrasesToCreateOrUpdate: [Swift.String]? = nil,
            blockedPhrasesToDelete: [Swift.String]? = nil,
            systemMessageOverride: Swift.String? = nil
        )
        {
            self.blockedPhrasesToCreateOrUpdate = blockedPhrasesToCreateOrUpdate
            self.blockedPhrasesToDelete = blockedPhrasesToDelete
            self.systemMessageOverride = systemMessageOverride
        }
    }
}

/// You don't have permissions to perform the action because your license is inactive. Ask your admin to activate your license and try again after your licence is active.
public struct LicenseNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LicenseNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension QBusinessClientTypes {

    public enum ChatMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creatorMode
        case pluginMode
        case retrievalMode
        case sdkUnknown(Swift.String)

        public static var allCases: [ChatMode] {
            return [
                .creatorMode,
                .pluginMode,
                .retrievalMode
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creatorMode: return "CREATOR_MODE"
            case .pluginMode: return "PLUGIN_MODE"
            case .retrievalMode: return "RETRIEVAL_MODE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QBusinessClientTypes {

    /// Configuration information required to invoke chat in PLUGIN_MODE. For more information, see [Admin controls and guardrails](https://docs.aws.amazon.com/amazonq/latest/qbusiness-ug/guardrails.html), [Plugins](https://docs.aws.amazon.com/amazonq/latest/qbusiness-ug/plugins.html), and [Conversation settings](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/using-web-experience.html#chat-source-scope).
    public struct PluginConfiguration: Swift.Sendable {
        /// The identifier of the plugin you want to use.
        /// This member is required.
        public var pluginId: Swift.String?

        public init(
            pluginId: Swift.String? = nil
        )
        {
            self.pluginId = pluginId
        }
    }
}

extension QBusinessClientTypes {

    /// Configuration information for Amazon Q Business conversation modes. For more information, see [Admin controls and guardrails](https://docs.aws.amazon.com/amazonq/latest/qbusiness-ug/guardrails.html) and [Conversation settings](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/using-web-experience.html#chat-source-scope).
    public enum ChatModeConfiguration: Swift.Sendable {
        /// Configuration information required to invoke chat in PLUGIN_MODE.
        case pluginconfiguration(QBusinessClientTypes.PluginConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension QBusinessClientTypes {

    /// The end of the streaming input for the Chat API.
    public struct EndOfInputEvent: Swift.Sendable {

        public init() { }
    }
}

extension QBusinessClientTypes {

    /// An input event for a end user message in an Amazon Q Business web experience.
    public struct TextInputEvent: Swift.Sendable {
        /// A user message in a text message input event.
        /// This member is required.
        public var userMessage: Swift.String?

        public init(
            userMessage: Swift.String? = nil
        )
        {
            self.userMessage = userMessage
        }
    }
}

extension QBusinessClientTypes {

    /// A failed file upload during web experience chat.
    public struct FailedAttachmentEvent: Swift.Sendable {
        /// The details of a file uploaded during chat.
        public var attachment: QBusinessClientTypes.AttachmentOutput?
        /// The identifier of the conversation associated with the failed file upload.
        public var conversationId: Swift.String?
        /// The identifier of the AI-generated message associated with the file upload.
        public var systemMessageId: Swift.String?
        /// The identifier of the end user chat message associated with the file upload.
        public var userMessageId: Swift.String?

        public init(
            attachment: QBusinessClientTypes.AttachmentOutput? = nil,
            conversationId: Swift.String? = nil,
            systemMessageId: Swift.String? = nil,
            userMessageId: Swift.String? = nil
        )
        {
            self.attachment = attachment
            self.conversationId = conversationId
            self.systemMessageId = systemMessageId
            self.userMessageId = userMessageId
        }
    }
}

extension QBusinessClientTypes {

    /// Contains the relevant text excerpt from a source that was used to generate a citation text segment in an Amazon Q Business chat response.
    public struct SnippetExcerpt: Swift.Sendable {
        /// The relevant text excerpt from a source that was used to generate a citation text segment in an Amazon Q chat response.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        )
        {
            self.text = text
        }
    }
}

extension QBusinessClientTypes {

    /// Provides information about a text extract in a chat response that can be attributed to a source document.
    public struct TextSegment: Swift.Sendable {
        /// The zero-based location in the response string where the source attribution starts.
        public var beginOffset: Swift.Int?
        /// The zero-based location in the response string where the source attribution ends.
        public var endOffset: Swift.Int?
        /// The relevant text excerpt from a source that was used to generate a citation text segment in an Amazon Q Business chat response.
        public var snippetExcerpt: QBusinessClientTypes.SnippetExcerpt?

        public init(
            beginOffset: Swift.Int? = nil,
            endOffset: Swift.Int? = nil,
            snippetExcerpt: QBusinessClientTypes.SnippetExcerpt? = nil
        )
        {
            self.beginOffset = beginOffset
            self.endOffset = endOffset
            self.snippetExcerpt = snippetExcerpt
        }
    }
}

extension QBusinessClientTypes {

    /// The documents used to generate an Amazon Q Business web experience response.
    public struct SourceAttribution: Swift.Sendable {
        /// The number attached to a citation in an Amazon Q Business generated response.
        public var citationNumber: Swift.Int?
        /// The content extract from the document on which the generated response is based.
        public var snippet: Swift.String?
        /// A text extract from a source document that is used for source attribution.
        public var textMessageSegments: [QBusinessClientTypes.TextSegment]?
        /// The title of the document which is the source for the Amazon Q Business generated response.
        public var title: Swift.String?
        /// The Unix timestamp when the Amazon Q Business application was last updated.
        public var updatedAt: Foundation.Date?
        /// The URL of the document which is the source for the Amazon Q Business generated response.
        public var url: Swift.String?

        public init(
            citationNumber: Swift.Int? = nil,
            snippet: Swift.String? = nil,
            textMessageSegments: [QBusinessClientTypes.TextSegment]? = nil,
            title: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil,
            url: Swift.String? = nil
        )
        {
            self.citationNumber = citationNumber
            self.snippet = snippet
            self.textMessageSegments = textMessageSegments
            self.title = title
            self.updatedAt = updatedAt
            self.url = url
        }
    }
}

extension QBusinessClientTypes {

    /// A metadata event for a AI-generated text output message in a Amazon Q Business conversation, containing associated metadata generated.
    public struct MetadataEvent: Swift.Sendable {
        /// The identifier of the conversation with which the generated metadata is associated.
        public var conversationId: Swift.String?
        /// The final text output message generated by the system.
        public var finalTextMessage: Swift.String?
        /// The source documents used to generate the conversation response.
        public var sourceAttributions: [QBusinessClientTypes.SourceAttribution?]?
        /// The identifier of an Amazon Q Business AI generated message within the conversation.
        public var systemMessageId: Swift.String?
        /// The identifier of an Amazon Q Business end user text input message within the conversation.
        public var userMessageId: Swift.String?

        public init(
            conversationId: Swift.String? = nil,
            finalTextMessage: Swift.String? = nil,
            sourceAttributions: [QBusinessClientTypes.SourceAttribution?]? = nil,
            systemMessageId: Swift.String? = nil,
            userMessageId: Swift.String? = nil
        )
        {
            self.conversationId = conversationId
            self.finalTextMessage = finalTextMessage
            self.sourceAttributions = sourceAttributions
            self.systemMessageId = systemMessageId
            self.userMessageId = userMessageId
        }
    }
}

extension QBusinessClientTypes {

    /// An output event for an AI-generated response in an Amazon Q Business web experience.
    public struct TextOutputEvent: Swift.Sendable {
        /// The identifier of the conversation with which the text output event is associated.
        public var conversationId: Swift.String?
        /// An AI-generated message in a TextOutputEvent.
        public var systemMessage: Swift.String?
        /// The identifier of an AI-generated message in a TextOutputEvent.
        public var systemMessageId: Swift.String?
        /// The identifier of an end user message in a TextOutputEvent.
        public var userMessageId: Swift.String?

        public init(
            conversationId: Swift.String? = nil,
            systemMessage: Swift.String? = nil,
            systemMessageId: Swift.String? = nil,
            userMessageId: Swift.String? = nil
        )
        {
            self.conversationId = conversationId
            self.systemMessage = systemMessage
            self.systemMessageId = systemMessageId
            self.userMessageId = userMessageId
        }
    }
}

extension QBusinessClientTypes {

    /// The streaming output for the Chat API.
    public enum ChatOutputStream: Swift.Sendable {
        /// Information about the payload of the ChatOutputStream event containing the AI-generated message output.
        case textevent(QBusinessClientTypes.TextOutputEvent)
        /// A metadata event for a AI-generated text output message in a Amazon Q Business conversation.
        case metadataevent(QBusinessClientTypes.MetadataEvent)
        /// A request from Amazon Q Business to the end user for information Amazon Q Business needs to successfully complete a requested plugin action.
        case actionreviewevent(QBusinessClientTypes.ActionReviewEvent)
        /// A failed file upload event during a web experience chat.
        case failedattachmentevent(QBusinessClientTypes.FailedAttachmentEvent)
        /// An authentication verification event activated by an end user request to use a custom plugin.
        case authchallengerequestevent(QBusinessClientTypes.AuthChallengeRequestEvent)
        case sdkUnknown(Swift.String)
    }
}

public struct ChatOutput: Swift.Sendable {
    /// The streaming output for the Chat API.
    public var outputStream: AsyncThrowingStream<QBusinessClientTypes.ChatOutputStream, Swift.Error>?

    public init(
        outputStream: AsyncThrowingStream<QBusinessClientTypes.ChatOutputStream, Swift.Error>? = nil
    )
    {
        self.outputStream = outputStream
    }
}

public struct ChatSyncOutput: Swift.Sendable {
    /// A request from Amazon Q Business to the end user for information Amazon Q Business needs to successfully complete a requested plugin action.
    public var actionReview: QBusinessClientTypes.ActionReview?
    /// An authentication verification event activated by an end user request to use a custom plugin.
    public var authChallengeRequest: QBusinessClientTypes.AuthChallengeRequest?
    /// The identifier of the Amazon Q Business conversation.
    public var conversationId: Swift.String?
    /// A list of files which failed to upload during chat.
    public var failedAttachments: [QBusinessClientTypes.AttachmentOutput]?
    /// The source documents used to generate the conversation response.
    public var sourceAttributions: [QBusinessClientTypes.SourceAttribution?]?
    /// An AI-generated message in a conversation.
    public var systemMessage: Swift.String?
    /// The identifier of an Amazon Q Business AI generated message within the conversation.
    public var systemMessageId: Swift.String?
    /// The identifier of an Amazon Q Business end user text input message within the conversation.
    public var userMessageId: Swift.String?

    public init(
        actionReview: QBusinessClientTypes.ActionReview? = nil,
        authChallengeRequest: QBusinessClientTypes.AuthChallengeRequest? = nil,
        conversationId: Swift.String? = nil,
        failedAttachments: [QBusinessClientTypes.AttachmentOutput]? = nil,
        sourceAttributions: [QBusinessClientTypes.SourceAttribution?]? = nil,
        systemMessage: Swift.String? = nil,
        systemMessageId: Swift.String? = nil,
        userMessageId: Swift.String? = nil
    )
    {
        self.actionReview = actionReview
        self.authChallengeRequest = authChallengeRequest
        self.conversationId = conversationId
        self.failedAttachments = failedAttachments
        self.sourceAttributions = sourceAttributions
        self.systemMessage = systemMessage
        self.systemMessageId = systemMessageId
        self.userMessageId = userMessageId
    }
}

extension QBusinessClientTypes {

    /// A rule for configuring how Amazon Q Business responds when it encounters a a blocked topic. You can configure a custom message to inform your end users that they have asked about a restricted topic and suggest any next steps they should take.
    public struct ContentBlockerRule: Swift.Sendable {
        /// The configured custom message displayed to an end user informing them that they've used a blocked phrase during chat.
        public var systemMessageOverride: Swift.String?

        public init(
            systemMessageOverride: Swift.String? = nil
        )
        {
            self.systemMessageOverride = systemMessageOverride
        }
    }
}

extension QBusinessClientTypes {

    /// The identifier of the data source Amazon Q Business will generate responses from.
    public struct EligibleDataSource: Swift.Sendable {
        /// The identifier of the data source.
        public var dataSourceId: Swift.String?
        /// The identifier of the index the data source is attached to.
        public var indexId: Swift.String?

        public init(
            dataSourceId: Swift.String? = nil,
            indexId: Swift.String? = nil
        )
        {
            self.dataSourceId = dataSourceId
            self.indexId = indexId
        }
    }
}

extension QBusinessClientTypes {

    /// Rules for retrieving content from data sources connected to a Amazon Q Business application for a specific topic control configuration.
    public struct ContentRetrievalRule: Swift.Sendable {
        /// Specifies data sources in a Amazon Q Business application to use for content generation.
        public var eligibleDataSources: [QBusinessClientTypes.EligibleDataSource]?

        public init(
            eligibleDataSources: [QBusinessClientTypes.EligibleDataSource]? = nil
        )
        {
            self.eligibleDataSources = eligibleDataSources
        }
    }
}

extension QBusinessClientTypes {

    /// A conversation in an Amazon Q Business application.
    public struct Conversation: Swift.Sendable {
        /// The identifier of the Amazon Q Business conversation.
        public var conversationId: Swift.String?
        /// The start time of the conversation.
        public var startTime: Foundation.Date?
        /// The title of the conversation.
        public var title: Swift.String?

        public init(
            conversationId: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            title: Swift.String? = nil
        )
        {
            self.conversationId = conversationId
            self.startTime = startTime
            self.title = title
        }
    }
}

extension QBusinessClientTypes {

    /// Aliases attached to a user id within an Amazon Q Business application.
    public struct UserAlias: Swift.Sendable {
        /// The identifier of the data source that the user aliases are associated with.
        public var dataSourceId: Swift.String?
        /// The identifier of the index that the user aliases are associated with.
        public var indexId: Swift.String?
        /// The identifier of the user id associated with the user aliases.
        /// This member is required.
        public var userId: Swift.String?

        public init(
            dataSourceId: Swift.String? = nil,
            indexId: Swift.String? = nil,
            userId: Swift.String? = nil
        )
        {
            self.dataSourceId = dataSourceId
            self.indexId = indexId
            self.userId = userId
        }
    }
}

public struct CreateUserInput: Swift.Sendable {
    /// The identifier of the application for which the user mapping will be created.
    /// This member is required.
    public var applicationId: Swift.String?
    /// A token that you provide to identify the request to create your Amazon Q Business user mapping.
    public var clientToken: Swift.String?
    /// The list of user aliases in the mapping.
    public var userAliases: [QBusinessClientTypes.UserAlias]?
    /// The user emails attached to a user mapping.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        userAliases: [QBusinessClientTypes.UserAlias]? = nil,
        userId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.clientToken = clientToken
        self.userAliases = userAliases
        self.userId = userId
    }
}

public struct CreateUserOutput: Swift.Sendable {

    public init() { }
}

extension QBusinessClientTypes {

    /// Configuration information required to invoke chat in CREATOR_MODE. For more information, see [Admin controls and guardrails](https://docs.aws.amazon.com/amazonq/latest/qbusiness-ug/guardrails.html) and [Conversation settings](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/using-web-experience.html#chat-source-scope).
    public struct CreatorModeConfiguration: Swift.Sendable {
        /// Status information about whether CREATOR_MODE has been enabled or disabled. The default status is DISABLED.
        /// This member is required.
        public var creatorModeControl: QBusinessClientTypes.CreatorModeControl?

        public init(
            creatorModeControl: QBusinessClientTypes.CreatorModeControl? = nil
        )
        {
            self.creatorModeControl = creatorModeControl
        }
    }
}

extension QBusinessClientTypes {

    /// Maps a batch delete document request to a specific Amazon Q Business data source connector sync job.
    public struct DataSourceSyncJobMetrics: Swift.Sendable {
        /// The current count of documents added from the data source during the data source sync.
        public var documentsAdded: Swift.String?
        /// The current count of documents deleted from the data source during the data source sync.
        public var documentsDeleted: Swift.String?
        /// The current count of documents that failed to sync from the data source during the data source sync.
        public var documentsFailed: Swift.String?
        /// The current count of documents modified in the data source during the data source sync.
        public var documentsModified: Swift.String?
        /// The current count of documents crawled by the ongoing sync job in the data source.
        public var documentsScanned: Swift.String?

        public init(
            documentsAdded: Swift.String? = nil,
            documentsDeleted: Swift.String? = nil,
            documentsFailed: Swift.String? = nil,
            documentsModified: Swift.String? = nil,
            documentsScanned: Swift.String? = nil
        )
        {
            self.documentsAdded = documentsAdded
            self.documentsDeleted = documentsDeleted
            self.documentsFailed = documentsFailed
            self.documentsModified = documentsModified
            self.documentsScanned = documentsScanned
        }
    }
}

extension QBusinessClientTypes {

    public enum DataSourceSyncJobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aborted
        case failed
        case incomplete
        case stopping
        case succeeded
        case syncing
        case syncingIndexing
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceSyncJobStatus] {
            return [
                .aborted,
                .failed,
                .incomplete,
                .stopping,
                .succeeded,
                .syncing,
                .syncingIndexing
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aborted: return "ABORTED"
            case .failed: return "FAILED"
            case .incomplete: return "INCOMPLETE"
            case .stopping: return "STOPPING"
            case .succeeded: return "SUCCEEDED"
            case .syncing: return "SYNCING"
            case .syncingIndexing: return "SYNCING_INDEXING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QBusinessClientTypes {

    /// Provides information about an Amazon Q Business data source connector synchronization job.
    public struct DataSourceSyncJob: Swift.Sendable {
        /// If the reason that the synchronization failed is due to an error with the underlying data source, this field contains a code that identifies the error.
        public var dataSourceErrorCode: Swift.String?
        /// The Unix timestamp when the synchronization job completed.
        public var endTime: Foundation.Date?
        /// If the Status field is set to FAILED, the ErrorCode field indicates the reason the synchronization failed.
        public var error: QBusinessClientTypes.ErrorDetail?
        /// The identifier of a data source synchronization job.
        public var executionId: Swift.String?
        /// Maps a batch delete document request to a specific data source sync job. This is optional and should only be supplied when documents are deleted by a data source connector.
        public var metrics: QBusinessClientTypes.DataSourceSyncJobMetrics?
        /// The Unix time stamp when the data source synchronization job started.
        public var startTime: Foundation.Date?
        /// The status of the synchronization job. When the Status field is set to SUCCEEDED, the synchronization job is done. If the status code is FAILED, the ErrorCode and ErrorMessage fields give you the reason for the failure.
        public var status: QBusinessClientTypes.DataSourceSyncJobStatus?

        public init(
            dataSourceErrorCode: Swift.String? = nil,
            endTime: Foundation.Date? = nil,
            error: QBusinessClientTypes.ErrorDetail? = nil,
            executionId: Swift.String? = nil,
            metrics: QBusinessClientTypes.DataSourceSyncJobMetrics? = nil,
            startTime: Foundation.Date? = nil,
            status: QBusinessClientTypes.DataSourceSyncJobStatus? = nil
        )
        {
            self.dataSourceErrorCode = dataSourceErrorCode
            self.endTime = endTime
            self.error = error
            self.executionId = executionId
            self.metrics = metrics
            self.startTime = startTime
            self.status = status
        }
    }
}

public struct DeleteChatControlsConfigurationInput: Swift.Sendable {
    /// The identifier of the application the chat controls have been configured for.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

public struct DeleteChatControlsConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteConversationInput: Swift.Sendable {
    /// The identifier of the Amazon Q Business application associated with the conversation.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the Amazon Q Business web experience conversation being deleted.
    /// This member is required.
    public var conversationId: Swift.String?
    /// The identifier of the user who is deleting the conversation.
    public var userId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        conversationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.conversationId = conversationId
        self.userId = userId
    }
}

public struct DeleteConversationOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteGroupInput: Swift.Sendable {
    /// The identifier of the application in which the group mapping belongs.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the data source linked to the group A group can be tied to multiple data sources. You can delete a group from accessing documents in a certain data source. For example, the groups "Research", "Engineering", and "Sales and Marketing" are all tied to the company's documents stored in the data sources Confluence and Salesforce. You want to delete "Research" and "Engineering" groups from Salesforce, so that these groups cannot access customer-related documents stored in Salesforce. Only "Sales and Marketing" should access documents in the Salesforce data source.
    public var dataSourceId: Swift.String?
    /// The name of the group you want to delete.
    /// This member is required.
    public var groupName: Swift.String?
    /// The identifier of the index you want to delete the group from.
    /// This member is required.
    public var indexId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        groupName: Swift.String? = nil,
        indexId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.dataSourceId = dataSourceId
        self.groupName = groupName
        self.indexId = indexId
    }
}

public struct DeleteGroupOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteUserInput: Swift.Sendable {
    /// The identifier of the application from which the user is being deleted.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The user email being deleted.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.userId = userId
    }
}

public struct DeleteUserOutput: Swift.Sendable {

    public init() { }
}

extension QBusinessClientTypes {

    public enum DocumentStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deleted
        case deleting
        case documentFailedToIndex
        case failed
        case indexed
        case processing
        case received
        case updated
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentStatus] {
            return [
                .deleted,
                .deleting,
                .documentFailedToIndex,
                .failed,
                .indexed,
                .processing,
                .received,
                .updated
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .documentFailedToIndex: return "DOCUMENT_FAILED_TO_INDEX"
            case .failed: return "FAILED"
            case .indexed: return "INDEXED"
            case .processing: return "PROCESSING"
            case .received: return "RECEIVED"
            case .updated: return "UPDATED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QBusinessClientTypes {

    /// The details of a document within an Amazon Q Business index.
    public struct DocumentDetails: Swift.Sendable {
        /// The timestamp for when the document was created.
        public var createdAt: Foundation.Date?
        /// The identifier of the document.
        public var documentId: Swift.String?
        /// An error message associated with the document.
        public var error: QBusinessClientTypes.ErrorDetail?
        /// The current status of the document.
        public var status: QBusinessClientTypes.DocumentStatus?
        /// The timestamp for when the document was last updated.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            documentId: Swift.String? = nil,
            error: QBusinessClientTypes.ErrorDetail? = nil,
            status: QBusinessClientTypes.DocumentStatus? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.documentId = documentId
            self.error = error
            self.status = status
            self.updatedAt = updatedAt
        }
    }
}

public struct GetChatControlsConfigurationInput: Swift.Sendable {
    /// The identifier of the application for which the chat controls are configured.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The maximum number of configured chat controls to return.
    public var maxResults: Swift.Int?
    /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q Business returns a pagination token in the response. You can use this pagination token to retrieve the next set of Amazon Q Business chat controls configured.
    public var nextToken: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension QBusinessClientTypes {

    public enum ResponseScope: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case enterpriseContentOnly
        case extendedKnowledgeEnabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ResponseScope] {
            return [
                .enterpriseContentOnly,
                .extendedKnowledgeEnabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .enterpriseContentOnly: return "ENTERPRISE_CONTENT_ONLY"
            case .extendedKnowledgeEnabled: return "EXTENDED_KNOWLEDGE_ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QBusinessClientTypes {

    /// Provides information about users and group names associated with a topic control rule.
    public struct UsersAndGroups: Swift.Sendable {
        /// The user group names associated with a topic control rule.
        public var userGroups: [Swift.String]?
        /// The user ids associated with a topic control rule.
        public var userIds: [Swift.String]?

        public init(
            userGroups: [Swift.String]? = nil,
            userIds: [Swift.String]? = nil
        )
        {
            self.userGroups = userGroups
            self.userIds = userIds
        }
    }
}

extension QBusinessClientTypes {

    /// Provides configuration information about a rule.
    public enum RuleConfiguration: Swift.Sendable {
        /// A rule for configuring how Amazon Q Business responds when it encounters a a blocked topic.
        case contentblockerrule(QBusinessClientTypes.ContentBlockerRule)
        /// Rules for retrieving content from data sources connected to a Amazon Q Business application for a specific topic control configuration.
        case contentretrievalrule(QBusinessClientTypes.ContentRetrievalRule)
        case sdkUnknown(Swift.String)
    }
}

extension QBusinessClientTypes {

    public enum RuleType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case contentBlockerRule
        case contentRetrievalRule
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleType] {
            return [
                .contentBlockerRule,
                .contentRetrievalRule
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .contentBlockerRule: return "CONTENT_BLOCKER_RULE"
            case .contentRetrievalRule: return "CONTENT_RETRIEVAL_RULE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QBusinessClientTypes {

    /// Guardrail rules for an Amazon Q Business application. Amazon Q Business supports only one rule at a time.
    public struct Rule: Swift.Sendable {
        /// Users and groups to be excluded from a rule.
        public var excludedUsersAndGroups: QBusinessClientTypes.UsersAndGroups?
        /// Users and groups to be included in a rule.
        public var includedUsersAndGroups: QBusinessClientTypes.UsersAndGroups?
        /// The configuration information for a rule.
        public var ruleConfiguration: QBusinessClientTypes.RuleConfiguration?
        /// The type of rule.
        /// This member is required.
        public var ruleType: QBusinessClientTypes.RuleType?

        public init(
            excludedUsersAndGroups: QBusinessClientTypes.UsersAndGroups? = nil,
            includedUsersAndGroups: QBusinessClientTypes.UsersAndGroups? = nil,
            ruleConfiguration: QBusinessClientTypes.RuleConfiguration? = nil,
            ruleType: QBusinessClientTypes.RuleType? = nil
        )
        {
            self.excludedUsersAndGroups = excludedUsersAndGroups
            self.includedUsersAndGroups = includedUsersAndGroups
            self.ruleConfiguration = ruleConfiguration
            self.ruleType = ruleType
        }
    }
}

extension QBusinessClientTypes {

    /// The topic specific controls configured for an Amazon Q Business application.
    public struct TopicConfiguration: Swift.Sendable {
        /// A description for your topic control configuration. Use this to outline how the large language model (LLM) should use this topic control configuration.
        public var description: Swift.String?
        /// A list of example phrases that you expect the end user to use in relation to the topic.
        public var exampleChatMessages: [Swift.String]?
        /// A name for your topic control configuration.
        /// This member is required.
        public var name: Swift.String?
        /// Rules defined for a topic configuration.
        /// This member is required.
        public var rules: [QBusinessClientTypes.Rule]?

        public init(
            description: Swift.String? = nil,
            exampleChatMessages: [Swift.String]? = nil,
            name: Swift.String? = nil,
            rules: [QBusinessClientTypes.Rule]? = nil
        )
        {
            self.description = description
            self.exampleChatMessages = exampleChatMessages
            self.name = name
            self.rules = rules
        }
    }
}

public struct GetChatControlsConfigurationOutput: Swift.Sendable {
    /// The phrases blocked from chat by your chat control configuration.
    public var blockedPhrases: QBusinessClientTypes.BlockedPhrasesConfiguration?
    /// The configuration details for CREATOR_MODE.
    public var creatorModeConfiguration: QBusinessClientTypes.AppliedCreatorModeConfiguration?
    /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q Business returns a pagination token in the response. You can use this pagination token to retrieve the next set of Amazon Q Business chat controls configured.
    public var nextToken: Swift.String?
    /// The response scope configured for a Amazon Q Business application. This determines whether your application uses its retrieval augmented generation (RAG) system to generate answers only from your enterprise data, or also uses the large language models (LLM) knowledge to respons to end user questions in chat.
    public var responseScope: QBusinessClientTypes.ResponseScope?
    /// The topic specific controls configured for a Amazon Q Business application.
    public var topicConfigurations: [QBusinessClientTypes.TopicConfiguration]?

    public init(
        blockedPhrases: QBusinessClientTypes.BlockedPhrasesConfiguration? = nil,
        creatorModeConfiguration: QBusinessClientTypes.AppliedCreatorModeConfiguration? = nil,
        nextToken: Swift.String? = nil,
        responseScope: QBusinessClientTypes.ResponseScope? = nil,
        topicConfigurations: [QBusinessClientTypes.TopicConfiguration]? = nil
    )
    {
        self.blockedPhrases = blockedPhrases
        self.creatorModeConfiguration = creatorModeConfiguration
        self.nextToken = nextToken
        self.responseScope = responseScope
        self.topicConfigurations = topicConfigurations
    }
}

public struct GetGroupInput: Swift.Sendable {
    /// The identifier of the application id the group is attached to.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the data source the group is attached to.
    public var dataSourceId: Swift.String?
    /// The name of the group.
    /// This member is required.
    public var groupName: Swift.String?
    /// The identifier of the index the group is attached to.
    /// This member is required.
    public var indexId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        groupName: Swift.String? = nil,
        indexId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.dataSourceId = dataSourceId
        self.groupName = groupName
        self.indexId = indexId
    }
}

extension QBusinessClientTypes {

    public enum GroupStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deleted
        case deleting
        case failed
        case processing
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [GroupStatus] {
            return [
                .deleted,
                .deleting,
                .failed,
                .processing,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .processing: return "PROCESSING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QBusinessClientTypes {

    /// Provides the details of a group's status.
    public struct GroupStatusDetail: Swift.Sendable {
        /// The details of an error associated a group status.
        public var errorDetail: QBusinessClientTypes.ErrorDetail?
        /// The Unix timestamp when the Amazon Q Business application was last updated.
        public var lastUpdatedAt: Foundation.Date?
        /// The status of a group.
        public var status: QBusinessClientTypes.GroupStatus?

        public init(
            errorDetail: QBusinessClientTypes.ErrorDetail? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            status: QBusinessClientTypes.GroupStatus? = nil
        )
        {
            self.errorDetail = errorDetail
            self.lastUpdatedAt = lastUpdatedAt
            self.status = status
        }
    }
}

public struct GetGroupOutput: Swift.Sendable {
    /// The current status of the group.
    public var status: QBusinessClientTypes.GroupStatusDetail?
    /// The status history of the group.
    public var statusHistory: [QBusinessClientTypes.GroupStatusDetail]?

    public init(
        status: QBusinessClientTypes.GroupStatusDetail? = nil,
        statusHistory: [QBusinessClientTypes.GroupStatusDetail]? = nil
    )
    {
        self.status = status
        self.statusHistory = statusHistory
    }
}

public struct GetUserInput: Swift.Sendable {
    /// The identifier of the application connected to the user.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The user email address attached to the user.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.userId = userId
    }
}

public struct GetUserOutput: Swift.Sendable {
    /// A list of user aliases attached to a user.
    public var userAliases: [QBusinessClientTypes.UserAlias]?

    public init(
        userAliases: [QBusinessClientTypes.UserAlias]? = nil
    )
    {
        self.userAliases = userAliases
    }
}

public struct ListConversationsInput: Swift.Sendable {
    /// The identifier of the Amazon Q Business application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The maximum number of Amazon Q Business conversations to return.
    public var maxResults: Swift.Int?
    /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q Business returns a pagination token in the response. You can use this pagination token to retrieve the next set of Amazon Q Business conversations.
    public var nextToken: Swift.String?
    /// The identifier of the user involved in the Amazon Q Business web experience conversation.
    public var userId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.userId = userId
    }
}

public struct ListConversationsOutput: Swift.Sendable {
    /// An array of summary information on the configuration of one or more Amazon Q Business web experiences.
    public var conversations: [QBusinessClientTypes.Conversation]?
    /// If the response is truncated, Amazon Q Business returns this token, which you can use in a later request to list the next set of messages.
    public var nextToken: Swift.String?

    public init(
        conversations: [QBusinessClientTypes.Conversation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.conversations = conversations
        self.nextToken = nextToken
    }
}

public struct ListDataSourceSyncJobsInput: Swift.Sendable {
    /// The identifier of the Amazon Q Business application connected to the data source.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the data source connector.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// The end time of the data source connector sync.
    public var endTime: Foundation.Date?
    /// The identifier of the index used with the Amazon Q Business data source connector.
    /// This member is required.
    public var indexId: Swift.String?
    /// The maximum number of synchronization jobs to return in the response.
    public var maxResults: Swift.Int?
    /// If the maxResults response was incpmplete because there is more data to retriever, Amazon Q Business returns a pagination token in the response. You can use this pagination token to retrieve the next set of responses.
    public var nextToken: Swift.String?
    /// The start time of the data source connector sync.
    public var startTime: Foundation.Date?
    /// Only returns synchronization jobs with the Status field equal to the specified status.
    public var statusFilter: QBusinessClientTypes.DataSourceSyncJobStatus?

    public init(
        applicationId: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        endTime: Foundation.Date? = nil,
        indexId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTime: Foundation.Date? = nil,
        statusFilter: QBusinessClientTypes.DataSourceSyncJobStatus? = nil
    )
    {
        self.applicationId = applicationId
        self.dataSourceId = dataSourceId
        self.endTime = endTime
        self.indexId = indexId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTime = startTime
        self.statusFilter = statusFilter
    }
}

public struct ListDataSourceSyncJobsOutput: Swift.Sendable {
    /// A history of synchronization jobs for the data source connector.
    public var history: [QBusinessClientTypes.DataSourceSyncJob]?
    /// If the response is truncated, Amazon Q Business returns this token. You can use this token in any subsequent request to retrieve the next set of jobs.
    public var nextToken: Swift.String?

    public init(
        history: [QBusinessClientTypes.DataSourceSyncJob]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.history = history
        self.nextToken = nextToken
    }
}

public struct ListDocumentsInput: Swift.Sendable {
    /// The identifier of the application id the documents are attached to.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the data sources the documents are attached to.
    public var dataSourceIds: [Swift.String]?
    /// The identifier of the index the documents are attached to.
    /// This member is required.
    public var indexId: Swift.String?
    /// The maximum number of documents to return.
    public var maxResults: Swift.Int?
    /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q Business returns a pagination token in the response. You can use this pagination token to retrieve the next set of documents.
    public var nextToken: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        dataSourceIds: [Swift.String]? = nil,
        indexId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.dataSourceIds = dataSourceIds
        self.indexId = indexId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListDocumentsOutput: Swift.Sendable {
    /// A list of document details.
    public var documentDetailList: [QBusinessClientTypes.DocumentDetails]?
    /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q Business returns a pagination token in the response. You can use this pagination token to retrieve the next set of documents.
    public var nextToken: Swift.String?

    public init(
        documentDetailList: [QBusinessClientTypes.DocumentDetails]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.documentDetailList = documentDetailList
        self.nextToken = nextToken
    }
}

public struct ListGroupsInput: Swift.Sendable {
    /// The identifier of the application for getting a list of groups mapped to users.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the data source for getting a list of groups mapped to users.
    public var dataSourceId: Swift.String?
    /// The identifier of the index for getting a list of groups mapped to users.
    /// This member is required.
    public var indexId: Swift.String?
    /// The maximum number of returned groups that are mapped to users.
    public var maxResults: Swift.Int?
    /// If the previous response was incomplete (because there is more data to retrieve), Amazon Q Business returns a pagination token in the response. You can use this pagination token to retrieve the next set of groups that are mapped to users.
    public var nextToken: Swift.String?
    /// The timestamp identifier used for the latest PUT or DELETE action for mapping users to their groups.
    /// This member is required.
    public var updatedEarlierThan: Foundation.Date?

    public init(
        applicationId: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        indexId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        updatedEarlierThan: Foundation.Date? = nil
    )
    {
        self.applicationId = applicationId
        self.dataSourceId = dataSourceId
        self.indexId = indexId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.updatedEarlierThan = updatedEarlierThan
    }
}

extension QBusinessClientTypes {

    /// Summary information for groups.
    public struct GroupSummary: Swift.Sendable {
        /// The name of the group the summary information is for.
        public var groupName: Swift.String?

        public init(
            groupName: Swift.String? = nil
        )
        {
            self.groupName = groupName
        }
    }
}

public struct ListGroupsOutput: Swift.Sendable {
    /// Summary information for list of groups that are mapped to users.
    public var items: [QBusinessClientTypes.GroupSummary]?
    /// If the response is truncated, Amazon Q Business returns this token that you can use in the subsequent request to retrieve the next set of groups that are mapped to users.
    public var nextToken: Swift.String?

    public init(
        items: [QBusinessClientTypes.GroupSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListMessagesInput: Swift.Sendable {
    /// The identifier for the Amazon Q Business application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the Amazon Q Business web experience conversation.
    /// This member is required.
    public var conversationId: Swift.String?
    /// The maximum number of messages to return.
    public var maxResults: Swift.Int?
    /// If the number of retrievers returned exceeds maxResults, Amazon Q Business returns a next token as a pagination token to retrieve the next set of messages.
    public var nextToken: Swift.String?
    /// The identifier of the user involved in the Amazon Q Business web experience conversation.
    public var userId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        conversationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.conversationId = conversationId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.userId = userId
    }
}

extension QBusinessClientTypes {

    public enum MessageType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case system
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [MessageType] {
            return [
                .system,
                .user
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .system: return "SYSTEM"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QBusinessClientTypes {

    /// A message in an Amazon Q Business web experience.
    public struct Message: Swift.Sendable {
        /// Performs an Amazon Q Business plugin action during a non-streaming chat conversation.
        public var actionExecution: QBusinessClientTypes.ActionExecution?
        /// An output event that Amazon Q Business returns to an user who wants to perform a plugin action during a non-streaming chat conversation. It contains information about the selected action with a list of possible user input fields, some pre-populated by Amazon Q Business.
        public var actionReview: QBusinessClientTypes.ActionReview?
        /// A file directly uploaded into an Amazon Q Business web experience chat.
        public var attachments: [QBusinessClientTypes.AttachmentOutput]?
        /// The content of the Amazon Q Business web experience message.
        public var body: Swift.String?
        /// The identifier of the Amazon Q Business web experience message.
        public var messageId: Swift.String?
        /// The source documents used to generate Amazon Q Business web experience message.
        public var sourceAttribution: [QBusinessClientTypes.SourceAttribution?]?
        /// The timestamp of the first Amazon Q Business web experience message.
        public var time: Foundation.Date?
        /// The type of Amazon Q Business message, whether HUMAN or AI generated.
        public var type: QBusinessClientTypes.MessageType?

        public init(
            actionExecution: QBusinessClientTypes.ActionExecution? = nil,
            actionReview: QBusinessClientTypes.ActionReview? = nil,
            attachments: [QBusinessClientTypes.AttachmentOutput]? = nil,
            body: Swift.String? = nil,
            messageId: Swift.String? = nil,
            sourceAttribution: [QBusinessClientTypes.SourceAttribution?]? = nil,
            time: Foundation.Date? = nil,
            type: QBusinessClientTypes.MessageType? = nil
        )
        {
            self.actionExecution = actionExecution
            self.actionReview = actionReview
            self.attachments = attachments
            self.body = body
            self.messageId = messageId
            self.sourceAttribution = sourceAttribution
            self.time = time
            self.type = type
        }
    }
}

public struct ListMessagesOutput: Swift.Sendable {
    /// An array of information on one or more messages.
    public var messages: [QBusinessClientTypes.Message]?
    /// If the response is truncated, Amazon Q Business returns this token, which you can use in a later request to list the next set of messages.
    public var nextToken: Swift.String?

    public init(
        messages: [QBusinessClientTypes.Message]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.messages = messages
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the Amazon Q Business application or data source to get a list of tags for.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// A list of tags associated with the Amazon Q Business application or data source.
    public var tags: [QBusinessClientTypes.Tag]?

    public init(
        tags: [QBusinessClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

extension QBusinessClientTypes {

    public enum MessageUsefulnessReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case complete
        case factuallyCorrect
        case harmfulOrUnsafe
        case helpful
        case incorrectOrMissingSources
        case notBasedOnDocuments
        case notComplete
        case notConcise
        case notFactuallyCorrect
        case notHelpful
        case other
        case relevantSources
        case sdkUnknown(Swift.String)

        public static var allCases: [MessageUsefulnessReason] {
            return [
                .complete,
                .factuallyCorrect,
                .harmfulOrUnsafe,
                .helpful,
                .incorrectOrMissingSources,
                .notBasedOnDocuments,
                .notComplete,
                .notConcise,
                .notFactuallyCorrect,
                .notHelpful,
                .other,
                .relevantSources
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .factuallyCorrect: return "FACTUALLY_CORRECT"
            case .harmfulOrUnsafe: return "HARMFUL_OR_UNSAFE"
            case .helpful: return "HELPFUL"
            case .incorrectOrMissingSources: return "INCORRECT_OR_MISSING_SOURCES"
            case .notBasedOnDocuments: return "NOT_BASED_ON_DOCUMENTS"
            case .notComplete: return "NOT_COMPLETE"
            case .notConcise: return "NOT_CONCISE"
            case .notFactuallyCorrect: return "NOT_FACTUALLY_CORRECT"
            case .notHelpful: return "NOT_HELPFUL"
            case .other: return "OTHER"
            case .relevantSources: return "RELEVANT_SOURCES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QBusinessClientTypes {

    public enum MessageUsefulness: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case notUseful
        case useful
        case sdkUnknown(Swift.String)

        public static var allCases: [MessageUsefulness] {
            return [
                .notUseful,
                .useful
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .notUseful: return "NOT_USEFUL"
            case .useful: return "USEFUL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QBusinessClientTypes {

    /// End user feedback on an AI-generated web experience chat message usefulness.
    public struct MessageUsefulnessFeedback: Swift.Sendable {
        /// A comment given by an end user on the usefulness of an AI-generated chat message.
        public var comment: Swift.String?
        /// The reason for a usefulness rating.
        public var reason: QBusinessClientTypes.MessageUsefulnessReason?
        /// The timestamp for when the feedback was submitted.
        /// This member is required.
        public var submittedAt: Foundation.Date?
        /// The usefulness value assigned by an end user to a message.
        /// This member is required.
        public var usefulness: QBusinessClientTypes.MessageUsefulness?

        public init(
            comment: Swift.String? = nil,
            reason: QBusinessClientTypes.MessageUsefulnessReason? = nil,
            submittedAt: Foundation.Date? = nil,
            usefulness: QBusinessClientTypes.MessageUsefulness? = nil
        )
        {
            self.comment = comment
            self.reason = reason
            self.submittedAt = submittedAt
            self.usefulness = usefulness
        }
    }
}

public struct PutFeedbackInput: Swift.Sendable {
    /// The identifier of the application associated with the feedback.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the conversation the feedback is attached to.
    /// This member is required.
    public var conversationId: Swift.String?
    /// The timestamp for when the feedback was recorded.
    public var messageCopiedAt: Foundation.Date?
    /// The identifier of the chat message that the feedback was given for.
    /// This member is required.
    public var messageId: Swift.String?
    /// The feedback usefulness value given by the user to the chat message.
    public var messageUsefulness: QBusinessClientTypes.MessageUsefulnessFeedback?
    /// The identifier of the user giving the feedback.
    public var userId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        conversationId: Swift.String? = nil,
        messageCopiedAt: Foundation.Date? = nil,
        messageId: Swift.String? = nil,
        messageUsefulness: QBusinessClientTypes.MessageUsefulnessFeedback? = nil,
        userId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.conversationId = conversationId
        self.messageCopiedAt = messageCopiedAt
        self.messageId = messageId
        self.messageUsefulness = messageUsefulness
        self.userId = userId
    }
}

extension QBusinessClientTypes {

    /// The sub groups that belong to a group.
    public struct MemberGroup: Swift.Sendable {
        /// The name of the sub group.
        /// This member is required.
        public var groupName: Swift.String?
        /// The type of the sub group.
        public var type: QBusinessClientTypes.MembershipType?

        public init(
            groupName: Swift.String? = nil,
            type: QBusinessClientTypes.MembershipType? = nil
        )
        {
            self.groupName = groupName
            self.type = type
        }
    }
}

extension QBusinessClientTypes {

    /// The users that belong to a group.
    public struct MemberUser: Swift.Sendable {
        /// The type of the user.
        public var type: QBusinessClientTypes.MembershipType?
        /// The identifier of the user you want to map to a group.
        /// This member is required.
        public var userId: Swift.String?

        public init(
            type: QBusinessClientTypes.MembershipType? = nil,
            userId: Swift.String? = nil
        )
        {
            self.type = type
            self.userId = userId
        }
    }
}

extension QBusinessClientTypes {

    /// A list of users or sub groups that belong to a group. This is for generating Amazon Q Business chat results only from document a user has access to.
    public struct GroupMembers: Swift.Sendable {
        /// A list of sub groups that belong to a group. For example, the sub groups "Research", "Engineering", and "Sales and Marketing" all belong to the group "Company".
        public var memberGroups: [QBusinessClientTypes.MemberGroup]?
        /// A list of users that belong to a group. For example, a list of interns all belong to the "Interns" group.
        public var memberUsers: [QBusinessClientTypes.MemberUser]?
        /// Information required for Amazon Q Business to find a specific file in an Amazon S3 bucket.
        public var s3PathForGroupMembers: QBusinessClientTypes.S3?

        public init(
            memberGroups: [QBusinessClientTypes.MemberGroup]? = nil,
            memberUsers: [QBusinessClientTypes.MemberUser]? = nil,
            s3PathForGroupMembers: QBusinessClientTypes.S3? = nil
        )
        {
            self.memberGroups = memberGroups
            self.memberUsers = memberUsers
            self.s3PathForGroupMembers = s3PathForGroupMembers
        }
    }
}

public struct PutGroupInput: Swift.Sendable {
    /// The identifier of the application in which the user and group mapping belongs.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the data source for which you want to map users to their groups. This is useful if a group is tied to multiple data sources, but you only want the group to access documents of a certain data source. For example, the groups "Research", "Engineering", and "Sales and Marketing" are all tied to the company's documents stored in the data sources Confluence and Salesforce. However, "Sales and Marketing" team only needs access to customer-related documents stored in Salesforce.
    public var dataSourceId: Swift.String?
    /// A list of users or sub groups that belong to a group. This is for generating Amazon Q Business chat results only from document a user has access to.
    /// This member is required.
    public var groupMembers: QBusinessClientTypes.GroupMembers?
    /// The list that contains your users or sub groups that belong the same group. For example, the group "Company" includes the user "CEO" and the sub groups "Research", "Engineering", and "Sales and Marketing".
    /// This member is required.
    public var groupName: Swift.String?
    /// The identifier of the index in which you want to map users to their groups.
    /// This member is required.
    public var indexId: Swift.String?
    /// The Amazon Resource Name (ARN) of an IAM role that has access to the S3 file that contains your list of users that belong to a group.The Amazon Resource Name (ARN) of an IAM role that has access to the S3 file that contains your list of users that belong to a group.
    public var roleArn: Swift.String?
    /// The type of the group.
    /// This member is required.
    public var type: QBusinessClientTypes.MembershipType?

    public init(
        applicationId: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        groupMembers: QBusinessClientTypes.GroupMembers? = nil,
        groupName: Swift.String? = nil,
        indexId: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        type: QBusinessClientTypes.MembershipType? = nil
    )
    {
        self.applicationId = applicationId
        self.dataSourceId = dataSourceId
        self.groupMembers = groupMembers
        self.groupName = groupName
        self.indexId = indexId
        self.roleArn = roleArn
        self.type = type
    }
}

public struct PutGroupOutput: Swift.Sendable {

    public init() { }
}

public struct StartDataSourceSyncJobInput: Swift.Sendable {
    /// The identifier of Amazon Q Business application the data source is connected to.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the data source connector.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// The identifier of the index used with the data source connector.
    /// This member is required.
    public var indexId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        indexId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.dataSourceId = dataSourceId
        self.indexId = indexId
    }
}

public struct StartDataSourceSyncJobOutput: Swift.Sendable {
    /// The identifier for a particular synchronization job.
    public var executionId: Swift.String?

    public init(
        executionId: Swift.String? = nil
    )
    {
        self.executionId = executionId
    }
}

public struct StopDataSourceSyncJobInput: Swift.Sendable {
    /// The identifier of the Amazon Q Business application that the data source is connected to.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the data source connector.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// The identifier of the index used with the Amazon Q Business data source connector.
    /// This member is required.
    public var indexId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        indexId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.dataSourceId = dataSourceId
        self.indexId = indexId
    }
}

public struct StopDataSourceSyncJobOutput: Swift.Sendable {

    public init() { }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the Amazon Q Business application or data source to tag.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of tag keys to add to the Amazon Q Business application or data source. If a tag already exists, the existing value is replaced with the new value.
    /// This member is required.
    public var tags: [QBusinessClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [QBusinessClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the Amazon Q Business application, or data source to remove the tag from.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of tag keys to remove from the Amazon Q Business application or data source. If a tag key does not exist on the resource, it is ignored.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateChatControlsConfigurationInput: Swift.Sendable {
    /// The identifier of the application for which the chat controls are configured.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The phrases blocked from chat by your chat control configuration.
    public var blockedPhrasesConfigurationUpdate: QBusinessClientTypes.BlockedPhrasesConfigurationUpdate?
    /// A token that you provide to identify the request to update a Amazon Q Business application chat configuration.
    public var clientToken: Swift.String?
    /// The configuration details for CREATOR_MODE.
    public var creatorModeConfiguration: QBusinessClientTypes.CreatorModeConfiguration?
    /// The response scope configured for your application. This determines whether your application uses its retrieval augmented generation (RAG) system to generate answers only from your enterprise data, or also uses the large language models (LLM) knowledge to respons to end user questions in chat.
    public var responseScope: QBusinessClientTypes.ResponseScope?
    /// The configured topic specific chat controls you want to update.
    public var topicConfigurationsToCreateOrUpdate: [QBusinessClientTypes.TopicConfiguration]?
    /// The configured topic specific chat controls you want to delete.
    public var topicConfigurationsToDelete: [QBusinessClientTypes.TopicConfiguration]?

    public init(
        applicationId: Swift.String? = nil,
        blockedPhrasesConfigurationUpdate: QBusinessClientTypes.BlockedPhrasesConfigurationUpdate? = nil,
        clientToken: Swift.String? = nil,
        creatorModeConfiguration: QBusinessClientTypes.CreatorModeConfiguration? = nil,
        responseScope: QBusinessClientTypes.ResponseScope? = nil,
        topicConfigurationsToCreateOrUpdate: [QBusinessClientTypes.TopicConfiguration]? = nil,
        topicConfigurationsToDelete: [QBusinessClientTypes.TopicConfiguration]? = nil
    )
    {
        self.applicationId = applicationId
        self.blockedPhrasesConfigurationUpdate = blockedPhrasesConfigurationUpdate
        self.clientToken = clientToken
        self.creatorModeConfiguration = creatorModeConfiguration
        self.responseScope = responseScope
        self.topicConfigurationsToCreateOrUpdate = topicConfigurationsToCreateOrUpdate
        self.topicConfigurationsToDelete = topicConfigurationsToDelete
    }
}

public struct UpdateChatControlsConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateUserInput: Swift.Sendable {
    /// The identifier of the application the user is attached to.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The user aliases attached to the user id that are to be deleted.
    public var userAliasesToDelete: [QBusinessClientTypes.UserAlias]?
    /// The user aliases attached to the user id that are to be updated.
    public var userAliasesToUpdate: [QBusinessClientTypes.UserAlias]?
    /// The email id attached to the user.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        userAliasesToDelete: [QBusinessClientTypes.UserAlias]? = nil,
        userAliasesToUpdate: [QBusinessClientTypes.UserAlias]? = nil,
        userId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.userAliasesToDelete = userAliasesToDelete
        self.userAliasesToUpdate = userAliasesToUpdate
        self.userId = userId
    }
}

public struct UpdateUserOutput: Swift.Sendable {
    /// The user aliases that have been to be added to a user id.
    public var userAliasesAdded: [QBusinessClientTypes.UserAlias]?
    /// The user aliases that have been deleted from a user id.
    public var userAliasesDeleted: [QBusinessClientTypes.UserAlias]?
    /// The user aliases attached to a user id that have been updated.
    public var userAliasesUpdated: [QBusinessClientTypes.UserAlias]?

    public init(
        userAliasesAdded: [QBusinessClientTypes.UserAlias]? = nil,
        userAliasesDeleted: [QBusinessClientTypes.UserAlias]? = nil,
        userAliasesUpdated: [QBusinessClientTypes.UserAlias]? = nil
    )
    {
        self.userAliasesAdded = userAliasesAdded
        self.userAliasesDeleted = userAliasesDeleted
        self.userAliasesUpdated = userAliasesUpdated
    }
}

extension QBusinessClientTypes {

    /// Enables filtering of responses based on document attributes or metadata fields.
    public struct AttributeFilter: Swift.Sendable {
        /// Performs a logical AND operation on all supplied filters.
        public var andAllFilters: [QBusinessClientTypes.AttributeFilter]?
        /// Returns true when a document contains all the specified document attributes or metadata fields. Supported for the following [document attribute value types](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html): stringListValue.
        public var containsAll: QBusinessClientTypes.DocumentAttribute?
        /// Returns true when a document contains any of the specified document attributes or metadata fields. Supported for the following [document attribute value types](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html): stringListValue.
        public var containsAny: QBusinessClientTypes.DocumentAttribute?
        /// Performs an equals operation on two document attributes or metadata fields. Supported for the following [document attribute value types](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html): dateValue, longValue, stringListValue and stringValue.
        public var equalsTo: QBusinessClientTypes.DocumentAttribute?
        /// Performs a greater than operation on two document attributes or metadata fields. Supported for the following [document attribute value types](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html): dateValue and longValue.
        public var greaterThan: QBusinessClientTypes.DocumentAttribute?
        /// Performs a greater or equals than operation on two document attributes or metadata fields. Supported for the following [document attribute value types](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html): dateValue and longValue.
        public var greaterThanOrEquals: QBusinessClientTypes.DocumentAttribute?
        /// Performs a less than operation on two document attributes or metadata fields. Supported for the following [document attribute value types](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html): dateValue and longValue.
        public var lessThan: QBusinessClientTypes.DocumentAttribute?
        /// Performs a less than or equals operation on two document attributes or metadata fields.Supported for the following [document attribute value type](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html): dateValue and longValue.
        public var lessThanOrEquals: QBusinessClientTypes.DocumentAttribute?
        /// Performs a logical NOT operation on all supplied filters.
        @Indirect public var notFilter: QBusinessClientTypes.AttributeFilter?
        /// Performs a logical OR operation on all supplied filters.
        public var orAllFilters: [QBusinessClientTypes.AttributeFilter]?

        public init(
            andAllFilters: [QBusinessClientTypes.AttributeFilter]? = nil,
            containsAll: QBusinessClientTypes.DocumentAttribute? = nil,
            containsAny: QBusinessClientTypes.DocumentAttribute? = nil,
            equalsTo: QBusinessClientTypes.DocumentAttribute? = nil,
            greaterThan: QBusinessClientTypes.DocumentAttribute? = nil,
            greaterThanOrEquals: QBusinessClientTypes.DocumentAttribute? = nil,
            lessThan: QBusinessClientTypes.DocumentAttribute? = nil,
            lessThanOrEquals: QBusinessClientTypes.DocumentAttribute? = nil,
            notFilter: QBusinessClientTypes.AttributeFilter? = nil,
            orAllFilters: [QBusinessClientTypes.AttributeFilter]? = nil
        )
        {
            self.andAllFilters = andAllFilters
            self.containsAll = containsAll
            self.containsAny = containsAny
            self.equalsTo = equalsTo
            self.greaterThan = greaterThan
            self.greaterThanOrEquals = greaterThanOrEquals
            self.lessThan = lessThan
            self.lessThanOrEquals = lessThanOrEquals
            self.notFilter = notFilter
            self.orAllFilters = orAllFilters
        }
    }
}

extension QBusinessClientTypes {

    /// A configuration event activated by an end user request to select a specific chat mode.
    public struct ConfigurationEvent: Swift.Sendable {
        /// Enables filtering of responses based on document attributes or metadata fields.
        public var attributeFilter: QBusinessClientTypes.AttributeFilter?
        /// The chat modes available to an Amazon Q Business end user.
        ///
        /// * RETRIEVAL_MODE - The default chat mode for an Amazon Q Business application. When this mode is enabled, Amazon Q Business generates responses only from data sources connected to an Amazon Q Business application.
        ///
        /// * CREATOR_MODE - By selecting this mode, users can choose to generate responses only from the LLM knowledge, without consulting connected data sources, for a chat request.
        ///
        /// * PLUGIN_MODE - By selecting this mode, users can choose to use plugins in chat.
        ///
        ///
        /// For more information, see [Admin controls and guardrails](https://docs.aws.amazon.com/amazonq/latest/qbusiness-ug/guardrails.html), [Plugins](https://docs.aws.amazon.com/amazonq/latest/qbusiness-ug/plugins.html), and [Conversation settings](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/using-web-experience.html#chat-source-scope).
        public var chatMode: QBusinessClientTypes.ChatMode?
        /// Configuration information for Amazon Q Business conversation modes. For more information, see [Admin controls and guardrails](https://docs.aws.amazon.com/amazonq/latest/qbusiness-ug/guardrails.html) and [Conversation settings](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/using-web-experience.html#chat-source-scope).
        public var chatModeConfiguration: QBusinessClientTypes.ChatModeConfiguration?

        public init(
            attributeFilter: QBusinessClientTypes.AttributeFilter? = nil,
            chatMode: QBusinessClientTypes.ChatMode? = nil,
            chatModeConfiguration: QBusinessClientTypes.ChatModeConfiguration? = nil
        )
        {
            self.attributeFilter = attributeFilter
            self.chatMode = chatMode
            self.chatModeConfiguration = chatModeConfiguration
        }
    }
}

public struct ChatSyncInput: Swift.Sendable {
    /// A request from an end user to perform an Amazon Q Business plugin action.
    public var actionExecution: QBusinessClientTypes.ActionExecution?
    /// The identifier of the Amazon Q Business application linked to the Amazon Q Business conversation.
    /// This member is required.
    public var applicationId: Swift.String?
    /// A list of files uploaded directly during chat. You can upload a maximum of 5 files of upto 10 MB each.
    public var attachments: [QBusinessClientTypes.AttachmentInput]?
    /// Enables filtering of Amazon Q Business web experience responses based on document attributes or metadata fields.
    public var attributeFilter: QBusinessClientTypes.AttributeFilter?
    /// An authentication verification event response by a third party authentication server to Amazon Q Business.
    public var authChallengeResponse: QBusinessClientTypes.AuthChallengeResponse?
    /// The chat modes available to an Amazon Q Business end user.
    ///
    /// * RETRIEVAL_MODE - The default chat mode for an Amazon Q Business application. When this mode is enabled, Amazon Q Business generates responses only from data sources connected to an Amazon Q Business application.
    ///
    /// * CREATOR_MODE - By selecting this mode, users can choose to generate responses only from the LLM knowledge, without consulting connected data sources, for a chat request.
    ///
    /// * PLUGIN_MODE - By selecting this mode, users can choose to use plugins in chat.
    ///
    ///
    /// For more information, see [Admin controls and guardrails](https://docs.aws.amazon.com/amazonq/latest/qbusiness-ug/guardrails.html), [Plugins](https://docs.aws.amazon.com/amazonq/latest/qbusiness-ug/plugins.html), and [Conversation settings](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/using-web-experience.html#chat-source-scope).
    public var chatMode: QBusinessClientTypes.ChatMode?
    /// The chat mode configuration for an Amazon Q Business application.
    public var chatModeConfiguration: QBusinessClientTypes.ChatModeConfiguration?
    /// A token that you provide to identify a chat request.
    public var clientToken: Swift.String?
    /// The identifier of the Amazon Q Business conversation.
    public var conversationId: Swift.String?
    /// The identifier of the previous system message in a conversation.
    public var parentMessageId: Swift.String?
    /// The group names that a user associated with the chat input belongs to.
    public var userGroups: [Swift.String]?
    /// The identifier of the user attached to the chat input.
    public var userId: Swift.String?
    /// A end user message in a conversation.
    public var userMessage: Swift.String?

    public init(
        actionExecution: QBusinessClientTypes.ActionExecution? = nil,
        applicationId: Swift.String? = nil,
        attachments: [QBusinessClientTypes.AttachmentInput]? = nil,
        attributeFilter: QBusinessClientTypes.AttributeFilter? = nil,
        authChallengeResponse: QBusinessClientTypes.AuthChallengeResponse? = nil,
        chatMode: QBusinessClientTypes.ChatMode? = nil,
        chatModeConfiguration: QBusinessClientTypes.ChatModeConfiguration? = nil,
        clientToken: Swift.String? = nil,
        conversationId: Swift.String? = nil,
        parentMessageId: Swift.String? = nil,
        userGroups: [Swift.String]? = nil,
        userId: Swift.String? = nil,
        userMessage: Swift.String? = nil
    )
    {
        self.actionExecution = actionExecution
        self.applicationId = applicationId
        self.attachments = attachments
        self.attributeFilter = attributeFilter
        self.authChallengeResponse = authChallengeResponse
        self.chatMode = chatMode
        self.chatModeConfiguration = chatModeConfiguration
        self.clientToken = clientToken
        self.conversationId = conversationId
        self.parentMessageId = parentMessageId
        self.userGroups = userGroups
        self.userId = userId
        self.userMessage = userMessage
    }
}

extension QBusinessClientTypes {

    /// The streaming input for the Chat API.
    public indirect enum ChatInputStream: Swift.Sendable {
        /// A configuration event activated by an end user request to select a specific chat mode.
        case configurationevent(QBusinessClientTypes.ConfigurationEvent)
        /// Information about the payload of the ChatInputStream event containing the end user message input.
        case textevent(QBusinessClientTypes.TextInputEvent)
        /// A request by an end user to upload a file during chat.
        case attachmentevent(QBusinessClientTypes.AttachmentInputEvent)
        /// A request from an end user to perform an Amazon Q Business plugin action.
        case actionexecutionevent(QBusinessClientTypes.ActionExecutionEvent)
        /// The end of the streaming input for the Chat API.
        case endofinputevent(QBusinessClientTypes.EndOfInputEvent)
        /// An authentication verification event response by a third party authentication server to Amazon Q Business.
        case authchallengeresponseevent(QBusinessClientTypes.AuthChallengeResponseEvent)
        case sdkUnknown(Swift.String)
    }
}

public struct ChatInput: Swift.Sendable {
    /// The identifier of the Amazon Q Business application linked to a streaming Amazon Q Business conversation.
    /// This member is required.
    public var applicationId: Swift.String?
    /// A token that you provide to identify the chat input.
    public var clientToken: Swift.String?
    /// The identifier of the Amazon Q Business conversation.
    public var conversationId: Swift.String?
    /// The streaming input for the Chat API.
    public var inputStream: AsyncThrowingStream<QBusinessClientTypes.ChatInputStream, Swift.Error>?
    /// The identifier used to associate a user message with a AI generated response.
    public var parentMessageId: Swift.String?
    /// The group names that a user associated with the chat input belongs to.
    public var userGroups: [Swift.String]?
    /// The identifier of the user attached to the chat input.
    public var userId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        conversationId: Swift.String? = nil,
        inputStream: AsyncThrowingStream<QBusinessClientTypes.ChatInputStream, Swift.Error>? = nil,
        parentMessageId: Swift.String? = nil,
        userGroups: [Swift.String]? = nil,
        userId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.clientToken = clientToken
        self.conversationId = conversationId
        self.inputStream = inputStream
        self.parentMessageId = parentMessageId
        self.userGroups = userGroups
        self.userId = userId
    }
}

extension BatchDeleteDocumentInput {

    static func urlPathProvider(_ value: BatchDeleteDocumentInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let indexId = value.indexId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/indices/\(indexId.urlPercentEncoding())/documents/delete"
    }
}

extension BatchPutDocumentInput {

    static func urlPathProvider(_ value: BatchPutDocumentInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let indexId = value.indexId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/indices/\(indexId.urlPercentEncoding())/documents"
    }
}

extension ChatInput {

    static func urlPathProvider(_ value: ChatInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/conversations"
    }
}

extension ChatInput {

    static func queryItemProvider(_ value: ChatInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let userGroups = value.userGroups {
            userGroups.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "userGroups".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let conversationId = value.conversationId {
            let conversationIdQueryItem = Smithy.URIQueryItem(name: "conversationId".urlPercentEncoding(), value: Swift.String(conversationId).urlPercentEncoding())
            items.append(conversationIdQueryItem)
        }
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        if let parentMessageId = value.parentMessageId {
            let parentMessageIdQueryItem = Smithy.URIQueryItem(name: "parentMessageId".urlPercentEncoding(), value: Swift.String(parentMessageId).urlPercentEncoding())
            items.append(parentMessageIdQueryItem)
        }
        if let userId = value.userId {
            let userIdQueryItem = Smithy.URIQueryItem(name: "userId".urlPercentEncoding(), value: Swift.String(userId).urlPercentEncoding())
            items.append(userIdQueryItem)
        }
        return items
    }
}

extension ChatSyncInput {

    static func urlPathProvider(_ value: ChatSyncInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/conversations"
    }
}

extension ChatSyncInput {

    static func queryItemProvider(_ value: ChatSyncInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "sync", value: nil))
        if let userId = value.userId {
            let userIdQueryItem = Smithy.URIQueryItem(name: "userId".urlPercentEncoding(), value: Swift.String(userId).urlPercentEncoding())
            items.append(userIdQueryItem)
        }
        if let userGroups = value.userGroups {
            userGroups.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "userGroups".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension CreateApplicationInput {

    static func urlPathProvider(_ value: CreateApplicationInput) -> Swift.String? {
        return "/applications"
    }
}

extension CreateDataSourceInput {

    static func urlPathProvider(_ value: CreateDataSourceInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let indexId = value.indexId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/indices/\(indexId.urlPercentEncoding())/datasources"
    }
}

extension CreateIndexInput {

    static func urlPathProvider(_ value: CreateIndexInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/indices"
    }
}

extension CreatePluginInput {

    static func urlPathProvider(_ value: CreatePluginInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/plugins"
    }
}

extension CreateRetrieverInput {

    static func urlPathProvider(_ value: CreateRetrieverInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/retrievers"
    }
}

extension CreateUserInput {

    static func urlPathProvider(_ value: CreateUserInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/users"
    }
}

extension CreateWebExperienceInput {

    static func urlPathProvider(_ value: CreateWebExperienceInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/experiences"
    }
}

extension DeleteApplicationInput {

    static func urlPathProvider(_ value: DeleteApplicationInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())"
    }
}

extension DeleteChatControlsConfigurationInput {

    static func urlPathProvider(_ value: DeleteChatControlsConfigurationInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/chatcontrols"
    }
}

extension DeleteConversationInput {

    static func urlPathProvider(_ value: DeleteConversationInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let conversationId = value.conversationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/conversations/\(conversationId.urlPercentEncoding())"
    }
}

extension DeleteConversationInput {

    static func queryItemProvider(_ value: DeleteConversationInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let userId = value.userId {
            let userIdQueryItem = Smithy.URIQueryItem(name: "userId".urlPercentEncoding(), value: Swift.String(userId).urlPercentEncoding())
            items.append(userIdQueryItem)
        }
        return items
    }
}

extension DeleteDataSourceInput {

    static func urlPathProvider(_ value: DeleteDataSourceInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let indexId = value.indexId else {
            return nil
        }
        guard let dataSourceId = value.dataSourceId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/indices/\(indexId.urlPercentEncoding())/datasources/\(dataSourceId.urlPercentEncoding())"
    }
}

extension DeleteGroupInput {

    static func urlPathProvider(_ value: DeleteGroupInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let indexId = value.indexId else {
            return nil
        }
        guard let groupName = value.groupName else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/indices/\(indexId.urlPercentEncoding())/groups/\(groupName.urlPercentEncoding())"
    }
}

extension DeleteGroupInput {

    static func queryItemProvider(_ value: DeleteGroupInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let dataSourceId = value.dataSourceId {
            let dataSourceIdQueryItem = Smithy.URIQueryItem(name: "dataSourceId".urlPercentEncoding(), value: Swift.String(dataSourceId).urlPercentEncoding())
            items.append(dataSourceIdQueryItem)
        }
        return items
    }
}

extension DeleteIndexInput {

    static func urlPathProvider(_ value: DeleteIndexInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let indexId = value.indexId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/indices/\(indexId.urlPercentEncoding())"
    }
}

extension DeletePluginInput {

    static func urlPathProvider(_ value: DeletePluginInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let pluginId = value.pluginId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/plugins/\(pluginId.urlPercentEncoding())"
    }
}

extension DeleteRetrieverInput {

    static func urlPathProvider(_ value: DeleteRetrieverInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let retrieverId = value.retrieverId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/retrievers/\(retrieverId.urlPercentEncoding())"
    }
}

extension DeleteUserInput {

    static func urlPathProvider(_ value: DeleteUserInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let userId = value.userId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/users/\(userId.urlPercentEncoding())"
    }
}

extension DeleteWebExperienceInput {

    static func urlPathProvider(_ value: DeleteWebExperienceInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let webExperienceId = value.webExperienceId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/experiences/\(webExperienceId.urlPercentEncoding())"
    }
}

extension GetApplicationInput {

    static func urlPathProvider(_ value: GetApplicationInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())"
    }
}

extension GetChatControlsConfigurationInput {

    static func urlPathProvider(_ value: GetChatControlsConfigurationInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/chatcontrols"
    }
}

extension GetChatControlsConfigurationInput {

    static func queryItemProvider(_ value: GetChatControlsConfigurationInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension GetDataSourceInput {

    static func urlPathProvider(_ value: GetDataSourceInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let indexId = value.indexId else {
            return nil
        }
        guard let dataSourceId = value.dataSourceId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/indices/\(indexId.urlPercentEncoding())/datasources/\(dataSourceId.urlPercentEncoding())"
    }
}

extension GetGroupInput {

    static func urlPathProvider(_ value: GetGroupInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let indexId = value.indexId else {
            return nil
        }
        guard let groupName = value.groupName else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/indices/\(indexId.urlPercentEncoding())/groups/\(groupName.urlPercentEncoding())"
    }
}

extension GetGroupInput {

    static func queryItemProvider(_ value: GetGroupInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let dataSourceId = value.dataSourceId {
            let dataSourceIdQueryItem = Smithy.URIQueryItem(name: "dataSourceId".urlPercentEncoding(), value: Swift.String(dataSourceId).urlPercentEncoding())
            items.append(dataSourceIdQueryItem)
        }
        return items
    }
}

extension GetIndexInput {

    static func urlPathProvider(_ value: GetIndexInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let indexId = value.indexId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/indices/\(indexId.urlPercentEncoding())"
    }
}

extension GetPluginInput {

    static func urlPathProvider(_ value: GetPluginInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let pluginId = value.pluginId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/plugins/\(pluginId.urlPercentEncoding())"
    }
}

extension GetRetrieverInput {

    static func urlPathProvider(_ value: GetRetrieverInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let retrieverId = value.retrieverId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/retrievers/\(retrieverId.urlPercentEncoding())"
    }
}

extension GetUserInput {

    static func urlPathProvider(_ value: GetUserInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let userId = value.userId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/users/\(userId.urlPercentEncoding())"
    }
}

extension GetWebExperienceInput {

    static func urlPathProvider(_ value: GetWebExperienceInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let webExperienceId = value.webExperienceId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/experiences/\(webExperienceId.urlPercentEncoding())"
    }
}

extension ListApplicationsInput {

    static func urlPathProvider(_ value: ListApplicationsInput) -> Swift.String? {
        return "/applications"
    }
}

extension ListApplicationsInput {

    static func queryItemProvider(_ value: ListApplicationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListConversationsInput {

    static func urlPathProvider(_ value: ListConversationsInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/conversations"
    }
}

extension ListConversationsInput {

    static func queryItemProvider(_ value: ListConversationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let userId = value.userId {
            let userIdQueryItem = Smithy.URIQueryItem(name: "userId".urlPercentEncoding(), value: Swift.String(userId).urlPercentEncoding())
            items.append(userIdQueryItem)
        }
        return items
    }
}

extension ListDataSourcesInput {

    static func urlPathProvider(_ value: ListDataSourcesInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let indexId = value.indexId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/indices/\(indexId.urlPercentEncoding())/datasources"
    }
}

extension ListDataSourcesInput {

    static func queryItemProvider(_ value: ListDataSourcesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDataSourceSyncJobsInput {

    static func urlPathProvider(_ value: ListDataSourceSyncJobsInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let indexId = value.indexId else {
            return nil
        }
        guard let dataSourceId = value.dataSourceId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/indices/\(indexId.urlPercentEncoding())/datasources/\(dataSourceId.urlPercentEncoding())/syncjobs"
    }
}

extension ListDataSourceSyncJobsInput {

    static func queryItemProvider(_ value: ListDataSourceSyncJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let statusFilter = value.statusFilter {
            let statusFilterQueryItem = Smithy.URIQueryItem(name: "syncStatus".urlPercentEncoding(), value: Swift.String(statusFilter.rawValue).urlPercentEncoding())
            items.append(statusFilterQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let startTime = value.startTime {
            let startTimeQueryItem = Smithy.URIQueryItem(name: "startTime".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: startTime)).urlPercentEncoding())
            items.append(startTimeQueryItem)
        }
        if let endTime = value.endTime {
            let endTimeQueryItem = Smithy.URIQueryItem(name: "endTime".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: endTime)).urlPercentEncoding())
            items.append(endTimeQueryItem)
        }
        return items
    }
}

extension ListDocumentsInput {

    static func urlPathProvider(_ value: ListDocumentsInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let indexId = value.indexId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/index/\(indexId.urlPercentEncoding())/documents"
    }
}

extension ListDocumentsInput {

    static func queryItemProvider(_ value: ListDocumentsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let dataSourceIds = value.dataSourceIds {
            dataSourceIds.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "dataSourceIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension ListGroupsInput {

    static func urlPathProvider(_ value: ListGroupsInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let indexId = value.indexId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/indices/\(indexId.urlPercentEncoding())/groups"
    }
}

extension ListGroupsInput {

    static func queryItemProvider(_ value: ListGroupsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let updatedEarlierThan = value.updatedEarlierThan else {
            let message = "Creating a URL Query Item failed. updatedEarlierThan is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let updatedEarlierThanQueryItem = Smithy.URIQueryItem(name: "updatedEarlierThan".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: updatedEarlierThan)).urlPercentEncoding())
        items.append(updatedEarlierThanQueryItem)
        if let dataSourceId = value.dataSourceId {
            let dataSourceIdQueryItem = Smithy.URIQueryItem(name: "dataSourceId".urlPercentEncoding(), value: Swift.String(dataSourceId).urlPercentEncoding())
            items.append(dataSourceIdQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListIndicesInput {

    static func urlPathProvider(_ value: ListIndicesInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/indices"
    }
}

extension ListIndicesInput {

    static func queryItemProvider(_ value: ListIndicesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListMessagesInput {

    static func urlPathProvider(_ value: ListMessagesInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let conversationId = value.conversationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/conversations/\(conversationId.urlPercentEncoding())"
    }
}

extension ListMessagesInput {

    static func queryItemProvider(_ value: ListMessagesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let userId = value.userId {
            let userIdQueryItem = Smithy.URIQueryItem(name: "userId".urlPercentEncoding(), value: Swift.String(userId).urlPercentEncoding())
            items.append(userIdQueryItem)
        }
        return items
    }
}

extension ListPluginsInput {

    static func urlPathProvider(_ value: ListPluginsInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/plugins"
    }
}

extension ListPluginsInput {

    static func queryItemProvider(_ value: ListPluginsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListRetrieversInput {

    static func urlPathProvider(_ value: ListRetrieversInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/retrievers"
    }
}

extension ListRetrieversInput {

    static func queryItemProvider(_ value: ListRetrieversInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceARN = value.resourceARN else {
            return nil
        }
        return "/v1/tags/\(resourceARN.urlPercentEncoding())"
    }
}

extension ListWebExperiencesInput {

    static func urlPathProvider(_ value: ListWebExperiencesInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/experiences"
    }
}

extension ListWebExperiencesInput {

    static func queryItemProvider(_ value: ListWebExperiencesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension PutFeedbackInput {

    static func urlPathProvider(_ value: PutFeedbackInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let conversationId = value.conversationId else {
            return nil
        }
        guard let messageId = value.messageId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/conversations/\(conversationId.urlPercentEncoding())/messages/\(messageId.urlPercentEncoding())/feedback"
    }
}

extension PutFeedbackInput {

    static func queryItemProvider(_ value: PutFeedbackInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let userId = value.userId {
            let userIdQueryItem = Smithy.URIQueryItem(name: "userId".urlPercentEncoding(), value: Swift.String(userId).urlPercentEncoding())
            items.append(userIdQueryItem)
        }
        return items
    }
}

extension PutGroupInput {

    static func urlPathProvider(_ value: PutGroupInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let indexId = value.indexId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/indices/\(indexId.urlPercentEncoding())/groups"
    }
}

extension StartDataSourceSyncJobInput {

    static func urlPathProvider(_ value: StartDataSourceSyncJobInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let indexId = value.indexId else {
            return nil
        }
        guard let dataSourceId = value.dataSourceId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/indices/\(indexId.urlPercentEncoding())/datasources/\(dataSourceId.urlPercentEncoding())/startsync"
    }
}

extension StopDataSourceSyncJobInput {

    static func urlPathProvider(_ value: StopDataSourceSyncJobInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let indexId = value.indexId else {
            return nil
        }
        guard let dataSourceId = value.dataSourceId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/indices/\(indexId.urlPercentEncoding())/datasources/\(dataSourceId.urlPercentEncoding())/stopsync"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceARN = value.resourceARN else {
            return nil
        }
        return "/v1/tags/\(resourceARN.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceARN = value.resourceARN else {
            return nil
        }
        return "/v1/tags/\(resourceARN.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateApplicationInput {

    static func urlPathProvider(_ value: UpdateApplicationInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())"
    }
}

extension UpdateChatControlsConfigurationInput {

    static func urlPathProvider(_ value: UpdateChatControlsConfigurationInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/chatcontrols"
    }
}

extension UpdateDataSourceInput {

    static func urlPathProvider(_ value: UpdateDataSourceInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let indexId = value.indexId else {
            return nil
        }
        guard let dataSourceId = value.dataSourceId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/indices/\(indexId.urlPercentEncoding())/datasources/\(dataSourceId.urlPercentEncoding())"
    }
}

extension UpdateIndexInput {

    static func urlPathProvider(_ value: UpdateIndexInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let indexId = value.indexId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/indices/\(indexId.urlPercentEncoding())"
    }
}

extension UpdatePluginInput {

    static func urlPathProvider(_ value: UpdatePluginInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let pluginId = value.pluginId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/plugins/\(pluginId.urlPercentEncoding())"
    }
}

extension UpdateRetrieverInput {

    static func urlPathProvider(_ value: UpdateRetrieverInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let retrieverId = value.retrieverId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/retrievers/\(retrieverId.urlPercentEncoding())"
    }
}

extension UpdateUserInput {

    static func urlPathProvider(_ value: UpdateUserInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let userId = value.userId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/users/\(userId.urlPercentEncoding())"
    }
}

extension UpdateWebExperienceInput {

    static func urlPathProvider(_ value: UpdateWebExperienceInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let webExperienceId = value.webExperienceId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/experiences/\(webExperienceId.urlPercentEncoding())"
    }
}

extension BatchDeleteDocumentInput {

    static func write(value: BatchDeleteDocumentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dataSourceSyncId"].write(value.dataSourceSyncId)
        try writer["documents"].writeList(value.documents, memberWritingClosure: QBusinessClientTypes.DeleteDocument.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchPutDocumentInput {

    static func write(value: BatchPutDocumentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dataSourceSyncId"].write(value.dataSourceSyncId)
        try writer["documents"].writeList(value.documents, memberWritingClosure: QBusinessClientTypes.Document.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["roleArn"].write(value.roleArn)
    }
}

extension ChatSyncInput {

    static func write(value: ChatSyncInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actionExecution"].write(value.actionExecution, with: QBusinessClientTypes.ActionExecution.write(value:to:))
        try writer["attachments"].writeList(value.attachments, memberWritingClosure: QBusinessClientTypes.AttachmentInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["attributeFilter"].write(value.attributeFilter, with: QBusinessClientTypes.AttributeFilter.write(value:to:))
        try writer["authChallengeResponse"].write(value.authChallengeResponse, with: QBusinessClientTypes.AuthChallengeResponse.write(value:to:))
        try writer["chatMode"].write(value.chatMode)
        try writer["chatModeConfiguration"].write(value.chatModeConfiguration, with: QBusinessClientTypes.ChatModeConfiguration.write(value:to:))
        try writer["clientToken"].write(value.clientToken)
        try writer["conversationId"].write(value.conversationId)
        try writer["parentMessageId"].write(value.parentMessageId)
        try writer["userMessage"].write(value.userMessage)
    }
}

extension CreateApplicationInput {

    static func write(value: CreateApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attachmentsConfiguration"].write(value.attachmentsConfiguration, with: QBusinessClientTypes.AttachmentsConfiguration.write(value:to:))
        try writer["clientIdsForOIDC"].writeList(value.clientIdsForOIDC, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["displayName"].write(value.displayName)
        try writer["encryptionConfiguration"].write(value.encryptionConfiguration, with: QBusinessClientTypes.EncryptionConfiguration.write(value:to:))
        try writer["iamIdentityProviderArn"].write(value.iamIdentityProviderArn)
        try writer["identityCenterInstanceArn"].write(value.identityCenterInstanceArn)
        try writer["identityType"].write(value.identityType)
        try writer["personalizationConfiguration"].write(value.personalizationConfiguration, with: QBusinessClientTypes.PersonalizationConfiguration.write(value:to:))
        try writer["qAppsConfiguration"].write(value.qAppsConfiguration, with: QBusinessClientTypes.QAppsConfiguration.write(value:to:))
        try writer["roleArn"].write(value.roleArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: QBusinessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateDataSourceInput {

    static func write(value: CreateDataSourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["configuration"].write(value.configuration)
        try writer["description"].write(value.description)
        try writer["displayName"].write(value.displayName)
        try writer["documentEnrichmentConfiguration"].write(value.documentEnrichmentConfiguration, with: QBusinessClientTypes.DocumentEnrichmentConfiguration.write(value:to:))
        try writer["roleArn"].write(value.roleArn)
        try writer["syncSchedule"].write(value.syncSchedule)
        try writer["tags"].writeList(value.tags, memberWritingClosure: QBusinessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["vpcConfiguration"].write(value.vpcConfiguration, with: QBusinessClientTypes.DataSourceVpcConfiguration.write(value:to:))
    }
}

extension CreateIndexInput {

    static func write(value: CreateIndexInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["capacityConfiguration"].write(value.capacityConfiguration, with: QBusinessClientTypes.IndexCapacityConfiguration.write(value:to:))
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["displayName"].write(value.displayName)
        try writer["tags"].writeList(value.tags, memberWritingClosure: QBusinessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["type"].write(value.type)
    }
}

extension CreatePluginInput {

    static func write(value: CreatePluginInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authConfiguration"].write(value.authConfiguration, with: QBusinessClientTypes.PluginAuthConfiguration.write(value:to:))
        try writer["clientToken"].write(value.clientToken)
        try writer["customPluginConfiguration"].write(value.customPluginConfiguration, with: QBusinessClientTypes.CustomPluginConfiguration.write(value:to:))
        try writer["displayName"].write(value.displayName)
        try writer["serverUrl"].write(value.serverUrl)
        try writer["tags"].writeList(value.tags, memberWritingClosure: QBusinessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["type"].write(value.type)
    }
}

extension CreateRetrieverInput {

    static func write(value: CreateRetrieverInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["configuration"].write(value.configuration, with: QBusinessClientTypes.RetrieverConfiguration.write(value:to:))
        try writer["displayName"].write(value.displayName)
        try writer["roleArn"].write(value.roleArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: QBusinessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["type"].write(value.type)
    }
}

extension CreateUserInput {

    static func write(value: CreateUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["userAliases"].writeList(value.userAliases, memberWritingClosure: QBusinessClientTypes.UserAlias.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["userId"].write(value.userId)
    }
}

extension CreateWebExperienceInput {

    static func write(value: CreateWebExperienceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["identityProviderConfiguration"].write(value.identityProviderConfiguration, with: QBusinessClientTypes.IdentityProviderConfiguration.write(value:to:))
        try writer["origins"].writeList(value.origins, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["roleArn"].write(value.roleArn)
        try writer["samplePromptsControlMode"].write(value.samplePromptsControlMode)
        try writer["subtitle"].write(value.subtitle)
        try writer["tags"].writeList(value.tags, memberWritingClosure: QBusinessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["title"].write(value.title)
        try writer["welcomeMessage"].write(value.welcomeMessage)
    }
}

extension PutFeedbackInput {

    static func write(value: PutFeedbackInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["messageCopiedAt"].writeTimestamp(value.messageCopiedAt, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["messageUsefulness"].write(value.messageUsefulness, with: QBusinessClientTypes.MessageUsefulnessFeedback.write(value:to:))
    }
}

extension PutGroupInput {

    static func write(value: PutGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dataSourceId"].write(value.dataSourceId)
        try writer["groupMembers"].write(value.groupMembers, with: QBusinessClientTypes.GroupMembers.write(value:to:))
        try writer["groupName"].write(value.groupName)
        try writer["roleArn"].write(value.roleArn)
        try writer["type"].write(value.type)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeList(value.tags, memberWritingClosure: QBusinessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateApplicationInput {

    static func write(value: UpdateApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attachmentsConfiguration"].write(value.attachmentsConfiguration, with: QBusinessClientTypes.AttachmentsConfiguration.write(value:to:))
        try writer["autoSubscriptionConfiguration"].write(value.autoSubscriptionConfiguration, with: QBusinessClientTypes.AutoSubscriptionConfiguration.write(value:to:))
        try writer["description"].write(value.description)
        try writer["displayName"].write(value.displayName)
        try writer["identityCenterInstanceArn"].write(value.identityCenterInstanceArn)
        try writer["personalizationConfiguration"].write(value.personalizationConfiguration, with: QBusinessClientTypes.PersonalizationConfiguration.write(value:to:))
        try writer["qAppsConfiguration"].write(value.qAppsConfiguration, with: QBusinessClientTypes.QAppsConfiguration.write(value:to:))
        try writer["roleArn"].write(value.roleArn)
    }
}

extension UpdateChatControlsConfigurationInput {

    static func write(value: UpdateChatControlsConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["blockedPhrasesConfigurationUpdate"].write(value.blockedPhrasesConfigurationUpdate, with: QBusinessClientTypes.BlockedPhrasesConfigurationUpdate.write(value:to:))
        try writer["clientToken"].write(value.clientToken)
        try writer["creatorModeConfiguration"].write(value.creatorModeConfiguration, with: QBusinessClientTypes.CreatorModeConfiguration.write(value:to:))
        try writer["responseScope"].write(value.responseScope)
        try writer["topicConfigurationsToCreateOrUpdate"].writeList(value.topicConfigurationsToCreateOrUpdate, memberWritingClosure: QBusinessClientTypes.TopicConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["topicConfigurationsToDelete"].writeList(value.topicConfigurationsToDelete, memberWritingClosure: QBusinessClientTypes.TopicConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateDataSourceInput {

    static func write(value: UpdateDataSourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["configuration"].write(value.configuration)
        try writer["description"].write(value.description)
        try writer["displayName"].write(value.displayName)
        try writer["documentEnrichmentConfiguration"].write(value.documentEnrichmentConfiguration, with: QBusinessClientTypes.DocumentEnrichmentConfiguration.write(value:to:))
        try writer["roleArn"].write(value.roleArn)
        try writer["syncSchedule"].write(value.syncSchedule)
        try writer["vpcConfiguration"].write(value.vpcConfiguration, with: QBusinessClientTypes.DataSourceVpcConfiguration.write(value:to:))
    }
}

extension UpdateIndexInput {

    static func write(value: UpdateIndexInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["capacityConfiguration"].write(value.capacityConfiguration, with: QBusinessClientTypes.IndexCapacityConfiguration.write(value:to:))
        try writer["description"].write(value.description)
        try writer["displayName"].write(value.displayName)
        try writer["documentAttributeConfigurations"].writeList(value.documentAttributeConfigurations, memberWritingClosure: QBusinessClientTypes.DocumentAttributeConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdatePluginInput {

    static func write(value: UpdatePluginInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authConfiguration"].write(value.authConfiguration, with: QBusinessClientTypes.PluginAuthConfiguration.write(value:to:))
        try writer["customPluginConfiguration"].write(value.customPluginConfiguration, with: QBusinessClientTypes.CustomPluginConfiguration.write(value:to:))
        try writer["displayName"].write(value.displayName)
        try writer["serverUrl"].write(value.serverUrl)
        try writer["state"].write(value.state)
    }
}

extension UpdateRetrieverInput {

    static func write(value: UpdateRetrieverInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["configuration"].write(value.configuration, with: QBusinessClientTypes.RetrieverConfiguration.write(value:to:))
        try writer["displayName"].write(value.displayName)
        try writer["roleArn"].write(value.roleArn)
    }
}

extension UpdateUserInput {

    static func write(value: UpdateUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["userAliasesToDelete"].writeList(value.userAliasesToDelete, memberWritingClosure: QBusinessClientTypes.UserAlias.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["userAliasesToUpdate"].writeList(value.userAliasesToUpdate, memberWritingClosure: QBusinessClientTypes.UserAlias.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateWebExperienceInput {

    static func write(value: UpdateWebExperienceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authenticationConfiguration"].write(value.authenticationConfiguration, with: QBusinessClientTypes.WebExperienceAuthConfiguration.write(value:to:))
        try writer["identityProviderConfiguration"].write(value.identityProviderConfiguration, with: QBusinessClientTypes.IdentityProviderConfiguration.write(value:to:))
        try writer["origins"].writeList(value.origins, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["roleArn"].write(value.roleArn)
        try writer["samplePromptsControlMode"].write(value.samplePromptsControlMode)
        try writer["subtitle"].write(value.subtitle)
        try writer["title"].write(value.title)
        try writer["welcomeMessage"].write(value.welcomeMessage)
    }
}

extension BatchDeleteDocumentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchDeleteDocumentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDeleteDocumentOutput()
        value.failedDocuments = try reader["failedDocuments"].readListIfPresent(memberReadingClosure: QBusinessClientTypes.FailedDocument.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchPutDocumentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchPutDocumentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchPutDocumentOutput()
        value.failedDocuments = try reader["failedDocuments"].readListIfPresent(memberReadingClosure: QBusinessClientTypes.FailedDocument.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ChatOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ChatOutput {
        var value = ChatOutput()
        if case .stream(let stream) = httpResponse.body {
            let messageDecoder = SmithyEventStreams.DefaultMessageDecoder()
            let decoderStream = SmithyEventStreams.DefaultMessageDecoderStream(stream: stream, messageDecoder: messageDecoder, unmarshalClosure: QBusinessClientTypes.ChatOutputStream.unmarshal)
            value.outputStream = decoderStream.toAsyncStream()
        }
        return value
    }
}

extension ChatSyncOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ChatSyncOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ChatSyncOutput()
        value.actionReview = try reader["actionReview"].readIfPresent(with: QBusinessClientTypes.ActionReview.read(from:))
        value.authChallengeRequest = try reader["authChallengeRequest"].readIfPresent(with: QBusinessClientTypes.AuthChallengeRequest.read(from:))
        value.conversationId = try reader["conversationId"].readIfPresent()
        value.failedAttachments = try reader["failedAttachments"].readListIfPresent(memberReadingClosure: QBusinessClientTypes.AttachmentOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.sourceAttributions = try reader["sourceAttributions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.optionalFormOf(readingClosure: QBusinessClientTypes.SourceAttribution.read(from:)), memberNodeInfo: "member", isFlattened: false)
        value.systemMessage = try reader["systemMessage"].readIfPresent()
        value.systemMessageId = try reader["systemMessageId"].readIfPresent()
        value.userMessageId = try reader["userMessageId"].readIfPresent()
        return value
    }
}

extension CreateApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateApplicationOutput()
        value.applicationArn = try reader["applicationArn"].readIfPresent()
        value.applicationId = try reader["applicationId"].readIfPresent()
        return value
    }
}

extension CreateDataSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDataSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDataSourceOutput()
        value.dataSourceArn = try reader["dataSourceArn"].readIfPresent()
        value.dataSourceId = try reader["dataSourceId"].readIfPresent()
        return value
    }
}

extension CreateIndexOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateIndexOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateIndexOutput()
        value.indexArn = try reader["indexArn"].readIfPresent()
        value.indexId = try reader["indexId"].readIfPresent()
        return value
    }
}

extension CreatePluginOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePluginOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePluginOutput()
        value.buildStatus = try reader["buildStatus"].readIfPresent()
        value.pluginArn = try reader["pluginArn"].readIfPresent()
        value.pluginId = try reader["pluginId"].readIfPresent()
        return value
    }
}

extension CreateRetrieverOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRetrieverOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRetrieverOutput()
        value.retrieverArn = try reader["retrieverArn"].readIfPresent()
        value.retrieverId = try reader["retrieverId"].readIfPresent()
        return value
    }
}

extension CreateUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateUserOutput {
        return CreateUserOutput()
    }
}

extension CreateWebExperienceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateWebExperienceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateWebExperienceOutput()
        value.webExperienceArn = try reader["webExperienceArn"].readIfPresent()
        value.webExperienceId = try reader["webExperienceId"].readIfPresent()
        return value
    }
}

extension DeleteApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteApplicationOutput {
        return DeleteApplicationOutput()
    }
}

extension DeleteChatControlsConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteChatControlsConfigurationOutput {
        return DeleteChatControlsConfigurationOutput()
    }
}

extension DeleteConversationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteConversationOutput {
        return DeleteConversationOutput()
    }
}

extension DeleteDataSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDataSourceOutput {
        return DeleteDataSourceOutput()
    }
}

extension DeleteGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteGroupOutput {
        return DeleteGroupOutput()
    }
}

extension DeleteIndexOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteIndexOutput {
        return DeleteIndexOutput()
    }
}

extension DeletePluginOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePluginOutput {
        return DeletePluginOutput()
    }
}

extension DeleteRetrieverOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRetrieverOutput {
        return DeleteRetrieverOutput()
    }
}

extension DeleteUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteUserOutput {
        return DeleteUserOutput()
    }
}

extension DeleteWebExperienceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteWebExperienceOutput {
        return DeleteWebExperienceOutput()
    }
}

extension GetApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetApplicationOutput()
        value.applicationArn = try reader["applicationArn"].readIfPresent()
        value.applicationId = try reader["applicationId"].readIfPresent()
        value.attachmentsConfiguration = try reader["attachmentsConfiguration"].readIfPresent(with: QBusinessClientTypes.AppliedAttachmentsConfiguration.read(from:))
        value.autoSubscriptionConfiguration = try reader["autoSubscriptionConfiguration"].readIfPresent(with: QBusinessClientTypes.AutoSubscriptionConfiguration.read(from:))
        value.clientIdsForOIDC = try reader["clientIdsForOIDC"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.displayName = try reader["displayName"].readIfPresent()
        value.encryptionConfiguration = try reader["encryptionConfiguration"].readIfPresent(with: QBusinessClientTypes.EncryptionConfiguration.read(from:))
        value.error = try reader["error"].readIfPresent(with: QBusinessClientTypes.ErrorDetail.read(from:))
        value.iamIdentityProviderArn = try reader["iamIdentityProviderArn"].readIfPresent()
        value.identityCenterApplicationArn = try reader["identityCenterApplicationArn"].readIfPresent()
        value.identityType = try reader["identityType"].readIfPresent()
        value.personalizationConfiguration = try reader["personalizationConfiguration"].readIfPresent(with: QBusinessClientTypes.PersonalizationConfiguration.read(from:))
        value.qAppsConfiguration = try reader["qAppsConfiguration"].readIfPresent(with: QBusinessClientTypes.QAppsConfiguration.read(from:))
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GetChatControlsConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetChatControlsConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetChatControlsConfigurationOutput()
        value.blockedPhrases = try reader["blockedPhrases"].readIfPresent(with: QBusinessClientTypes.BlockedPhrasesConfiguration.read(from:))
        value.creatorModeConfiguration = try reader["creatorModeConfiguration"].readIfPresent(with: QBusinessClientTypes.AppliedCreatorModeConfiguration.read(from:))
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.responseScope = try reader["responseScope"].readIfPresent()
        value.topicConfigurations = try reader["topicConfigurations"].readListIfPresent(memberReadingClosure: QBusinessClientTypes.TopicConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetDataSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDataSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDataSourceOutput()
        value.applicationId = try reader["applicationId"].readIfPresent()
        value.configuration = try reader["configuration"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.dataSourceArn = try reader["dataSourceArn"].readIfPresent()
        value.dataSourceId = try reader["dataSourceId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.displayName = try reader["displayName"].readIfPresent()
        value.documentEnrichmentConfiguration = try reader["documentEnrichmentConfiguration"].readIfPresent(with: QBusinessClientTypes.DocumentEnrichmentConfiguration.read(from:))
        value.error = try reader["error"].readIfPresent(with: QBusinessClientTypes.ErrorDetail.read(from:))
        value.indexId = try reader["indexId"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.syncSchedule = try reader["syncSchedule"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.vpcConfiguration = try reader["vpcConfiguration"].readIfPresent(with: QBusinessClientTypes.DataSourceVpcConfiguration.read(from:))
        return value
    }
}

extension GetGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGroupOutput()
        value.status = try reader["status"].readIfPresent(with: QBusinessClientTypes.GroupStatusDetail.read(from:))
        value.statusHistory = try reader["statusHistory"].readListIfPresent(memberReadingClosure: QBusinessClientTypes.GroupStatusDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetIndexOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetIndexOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetIndexOutput()
        value.applicationId = try reader["applicationId"].readIfPresent()
        value.capacityConfiguration = try reader["capacityConfiguration"].readIfPresent(with: QBusinessClientTypes.IndexCapacityConfiguration.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.displayName = try reader["displayName"].readIfPresent()
        value.documentAttributeConfigurations = try reader["documentAttributeConfigurations"].readListIfPresent(memberReadingClosure: QBusinessClientTypes.DocumentAttributeConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.error = try reader["error"].readIfPresent(with: QBusinessClientTypes.ErrorDetail.read(from:))
        value.indexArn = try reader["indexArn"].readIfPresent()
        value.indexId = try reader["indexId"].readIfPresent()
        value.indexStatistics = try reader["indexStatistics"].readIfPresent(with: QBusinessClientTypes.IndexStatistics.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GetPluginOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPluginOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPluginOutput()
        value.applicationId = try reader["applicationId"].readIfPresent()
        value.authConfiguration = try reader["authConfiguration"].readIfPresent(with: QBusinessClientTypes.PluginAuthConfiguration.read(from:))
        value.buildStatus = try reader["buildStatus"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.customPluginConfiguration = try reader["customPluginConfiguration"].readIfPresent(with: QBusinessClientTypes.CustomPluginConfiguration.read(from:))
        value.displayName = try reader["displayName"].readIfPresent()
        value.pluginArn = try reader["pluginArn"].readIfPresent()
        value.pluginId = try reader["pluginId"].readIfPresent()
        value.serverUrl = try reader["serverUrl"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GetRetrieverOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRetrieverOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRetrieverOutput()
        value.applicationId = try reader["applicationId"].readIfPresent()
        value.configuration = try reader["configuration"].readIfPresent(with: QBusinessClientTypes.RetrieverConfiguration.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.displayName = try reader["displayName"].readIfPresent()
        value.retrieverArn = try reader["retrieverArn"].readIfPresent()
        value.retrieverId = try reader["retrieverId"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GetUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetUserOutput()
        value.userAliases = try reader["userAliases"].readListIfPresent(memberReadingClosure: QBusinessClientTypes.UserAlias.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetWebExperienceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWebExperienceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWebExperienceOutput()
        value.applicationId = try reader["applicationId"].readIfPresent()
        value.authenticationConfiguration = try reader["authenticationConfiguration"].readIfPresent(with: QBusinessClientTypes.WebExperienceAuthConfiguration.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.defaultEndpoint = try reader["defaultEndpoint"].readIfPresent()
        value.error = try reader["error"].readIfPresent(with: QBusinessClientTypes.ErrorDetail.read(from:))
        value.identityProviderConfiguration = try reader["identityProviderConfiguration"].readIfPresent(with: QBusinessClientTypes.IdentityProviderConfiguration.read(from:))
        value.origins = try reader["origins"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.samplePromptsControlMode = try reader["samplePromptsControlMode"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.subtitle = try reader["subtitle"].readIfPresent()
        value.title = try reader["title"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.webExperienceArn = try reader["webExperienceArn"].readIfPresent()
        value.webExperienceId = try reader["webExperienceId"].readIfPresent()
        value.welcomeMessage = try reader["welcomeMessage"].readIfPresent()
        return value
    }
}

extension ListApplicationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListApplicationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListApplicationsOutput()
        value.applications = try reader["applications"].readListIfPresent(memberReadingClosure: QBusinessClientTypes.Application.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListConversationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListConversationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListConversationsOutput()
        value.conversations = try reader["conversations"].readListIfPresent(memberReadingClosure: QBusinessClientTypes.Conversation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDataSourcesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDataSourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDataSourcesOutput()
        value.dataSources = try reader["dataSources"].readListIfPresent(memberReadingClosure: QBusinessClientTypes.DataSource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDataSourceSyncJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDataSourceSyncJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDataSourceSyncJobsOutput()
        value.history = try reader["history"].readListIfPresent(memberReadingClosure: QBusinessClientTypes.DataSourceSyncJob.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDocumentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDocumentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDocumentsOutput()
        value.documentDetailList = try reader["documentDetailList"].readListIfPresent(memberReadingClosure: QBusinessClientTypes.DocumentDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListGroupsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: QBusinessClientTypes.GroupSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListIndicesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListIndicesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListIndicesOutput()
        value.indices = try reader["indices"].readListIfPresent(memberReadingClosure: QBusinessClientTypes.Index.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListMessagesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMessagesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMessagesOutput()
        value.messages = try reader["messages"].readListIfPresent(memberReadingClosure: QBusinessClientTypes.Message.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListPluginsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPluginsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPluginsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.plugins = try reader["plugins"].readListIfPresent(memberReadingClosure: QBusinessClientTypes.Plugin.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListRetrieversOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRetrieversOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRetrieversOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.retrievers = try reader["retrievers"].readListIfPresent(memberReadingClosure: QBusinessClientTypes.Retriever.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: QBusinessClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListWebExperiencesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWebExperiencesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWebExperiencesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.webExperiences = try reader["webExperiences"].readListIfPresent(memberReadingClosure: QBusinessClientTypes.WebExperience.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PutFeedbackOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutFeedbackOutput {
        return PutFeedbackOutput()
    }
}

extension PutGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutGroupOutput {
        return PutGroupOutput()
    }
}

extension StartDataSourceSyncJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartDataSourceSyncJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartDataSourceSyncJobOutput()
        value.executionId = try reader["executionId"].readIfPresent()
        return value
    }
}

extension StopDataSourceSyncJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopDataSourceSyncJobOutput {
        return StopDataSourceSyncJobOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateApplicationOutput {
        return UpdateApplicationOutput()
    }
}

extension UpdateChatControlsConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateChatControlsConfigurationOutput {
        return UpdateChatControlsConfigurationOutput()
    }
}

extension UpdateDataSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDataSourceOutput {
        return UpdateDataSourceOutput()
    }
}

extension UpdateIndexOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateIndexOutput {
        return UpdateIndexOutput()
    }
}

extension UpdatePluginOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePluginOutput {
        return UpdatePluginOutput()
    }
}

extension UpdateRetrieverOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRetrieverOutput {
        return UpdateRetrieverOutput()
    }
}

extension UpdateUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateUserOutput()
        value.userAliasesAdded = try reader["userAliasesAdded"].readListIfPresent(memberReadingClosure: QBusinessClientTypes.UserAlias.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.userAliasesDeleted = try reader["userAliasesDeleted"].readListIfPresent(memberReadingClosure: QBusinessClientTypes.UserAlias.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.userAliasesUpdated = try reader["userAliasesUpdated"].readListIfPresent(memberReadingClosure: QBusinessClientTypes.UserAlias.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension UpdateWebExperienceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateWebExperienceOutput {
        return UpdateWebExperienceOutput()
    }
}

enum BatchDeleteDocumentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchPutDocumentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ChatOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LicenseNotFoundException": return try LicenseNotFoundException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ChatSyncOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LicenseNotFoundException": return try LicenseNotFoundException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDataSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateIndexOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePluginOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRetrieverOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateWebExperienceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteChatControlsConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteConversationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LicenseNotFoundException": return try LicenseNotFoundException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDataSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteIndexOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePluginOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRetrieverOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteWebExperienceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetChatControlsConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDataSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetIndexOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPluginOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRetrieverOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWebExperienceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListApplicationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListConversationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LicenseNotFoundException": return try LicenseNotFoundException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDataSourcesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDataSourceSyncJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDocumentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListIndicesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMessagesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LicenseNotFoundException": return try LicenseNotFoundException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPluginsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRetrieversOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWebExperiencesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutFeedbackOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartDataSourceSyncJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopDataSourceSyncJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateChatControlsConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDataSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateIndexOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePluginOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRetrieverOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateWebExperienceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fields = try reader["fields"].readListIfPresent(memberReadingClosure: QBusinessClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LicenseNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> LicenseNotFoundException {
        let reader = baseError.errorBodyReader
        var value = LicenseNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension QBusinessClientTypes.ChatInputStream {
    static var marshal: SmithyEventStreamsAPI.MarshalClosure<QBusinessClientTypes.ChatInputStream> {
        { (self) in
            var headers: [SmithyEventStreamsAPI.Header] = [.init(name: ":message-type", value: .string("event"))]
            var payload: Foundation.Data? = nil
            switch self {
            case .configurationevent(let value):
                headers.append(.init(name: ":event-type", value: .string("configurationEvent")))
                headers.append(.init(name: ":content-type", value: .string("application/json")))
                let writer = SmithyJSON.Writer(nodeInfo: "")
                try writer["chatMode"].write(value.chatMode, with: SmithyReadWrite.WritingClosureBox<QBusinessClientTypes.ChatMode>().write(value:to:))
                try writer["chatModeConfiguration"].write(value.chatModeConfiguration, with: QBusinessClientTypes.ChatModeConfiguration.write(value:to:))
                try writer["attributeFilter"].write(value.attributeFilter, with: QBusinessClientTypes.AttributeFilter.write(value:to:))
                payload = try writer.data()
            case .textevent(let value):
                headers.append(.init(name: ":event-type", value: .string("textEvent")))
                headers.append(.init(name: ":content-type", value: .string("application/json")))
                let writer = SmithyJSON.Writer(nodeInfo: "")
                try writer["userMessage"].write(value.userMessage, with: SmithyReadWrite.WritingClosures.writeString(value:to:))
                payload = try writer.data()
            case .attachmentevent(let value):
                headers.append(.init(name: ":event-type", value: .string("attachmentEvent")))
                headers.append(.init(name: ":content-type", value: .string("application/json")))
                let writer = SmithyJSON.Writer(nodeInfo: "")
                try writer["attachment"].write(value.attachment, with: QBusinessClientTypes.AttachmentInput.write(value:to:))
                payload = try writer.data()
            case .actionexecutionevent(let value):
                headers.append(.init(name: ":event-type", value: .string("actionExecutionEvent")))
                headers.append(.init(name: ":content-type", value: .string("application/json")))
                let writer = SmithyJSON.Writer(nodeInfo: "")
                try writer["pluginId"].write(value.pluginId, with: SmithyReadWrite.WritingClosures.writeString(value:to:))
                try writer["payload"].write(value.payload, with: SmithyReadWrite.mapWritingClosure(valueWritingClosure: QBusinessClientTypes.ActionExecutionPayloadField.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false))
                try writer["payloadFieldNameSeparator"].write(value.payloadFieldNameSeparator, with: SmithyReadWrite.WritingClosures.writeString(value:to:))
                payload = try writer.data()
            case .endofinputevent:
                headers.append(.init(name: ":event-type", value: .string("endOfInputEvent")))
            case .authchallengeresponseevent(let value):
                headers.append(.init(name: ":event-type", value: .string("authChallengeResponseEvent")))
                headers.append(.init(name: ":content-type", value: .string("application/json")))
                let writer = SmithyJSON.Writer(nodeInfo: "")
                try writer["responseMap"].write(value.responseMap, with: SmithyReadWrite.mapWritingClosure(valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false))
                payload = try writer.data()
            case .sdkUnknown(_):
                throw Smithy.ClientError.unknownError("cannot serialize the unknown event type!")
            }
            return SmithyEventStreamsAPI.Message(headers: headers, payload: payload ?? .init())
        }
    }
}

extension QBusinessClientTypes.ChatOutputStream {
    static var unmarshal: SmithyEventStreamsAPI.UnmarshalClosure<QBusinessClientTypes.ChatOutputStream> {
        { message in
            switch try message.type() {
            case .event(let params):
                switch params.eventType {
                case "textEvent":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: QBusinessClientTypes.TextOutputEvent.read(from:))
                    return .textevent(value)
                case "metadataEvent":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: QBusinessClientTypes.MetadataEvent.read(from:))
                    return .metadataevent(value)
                case "actionReviewEvent":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: QBusinessClientTypes.ActionReviewEvent.read(from:))
                    return .actionreviewevent(value)
                case "failedAttachmentEvent":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: QBusinessClientTypes.FailedAttachmentEvent.read(from:))
                    return .failedattachmentevent(value)
                case "authChallengeRequestEvent":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: QBusinessClientTypes.AuthChallengeRequestEvent.read(from:))
                    return .authchallengerequestevent(value)
                default:
                    return .sdkUnknown("error processing event stream, unrecognized event: \(params.eventType)")
                }
            case .exception(let params):
                let makeError: (SmithyEventStreamsAPI.Message, SmithyEventStreamsAPI.MessageType.ExceptionParams) throws -> Swift.Error = { message, params in
                    switch params.exceptionType {
                    default:
                        let httpResponse = SmithyHTTPAPI.HTTPResponse(body: .data(message.payload), statusCode: .ok)
                        return AWSClientRuntime.UnknownAWSHTTPServiceError(httpResponse: httpResponse, message: "error processing event stream, unrecognized ':exceptionType': \(params.exceptionType); contentType: \(params.contentType ?? "nil")", requestID: nil, typeName: nil)
                    }
                }
                let error = try makeError(message, params)
                throw error
            case .error(let params):
                let httpResponse = SmithyHTTPAPI.HTTPResponse(body: .data(message.payload), statusCode: .ok)
                throw AWSClientRuntime.UnknownAWSHTTPServiceError(httpResponse: httpResponse, message: "error processing event stream, unrecognized ':errorType': \(params.errorCode); message: \(params.message ?? "nil")", requestID: nil, typeName: nil)
            case .unknown(messageType: let messageType):
                throw Smithy.ClientError.unknownError("unrecognized event stream message ':message-type': \(messageType)")
            }
        }
    }
}

extension QBusinessClientTypes.FailedDocument {

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.FailedDocument {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.FailedDocument()
        value.id = try reader["id"].readIfPresent()
        value.error = try reader["error"].readIfPresent(with: QBusinessClientTypes.ErrorDetail.read(from:))
        value.dataSourceId = try reader["dataSourceId"].readIfPresent()
        return value
    }
}

extension QBusinessClientTypes.ErrorDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.ErrorDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.ErrorDetail()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        value.errorCode = try reader["errorCode"].readIfPresent()
        return value
    }
}

extension QBusinessClientTypes.AuthChallengeRequestEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.AuthChallengeRequestEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.AuthChallengeRequestEvent()
        value.authorizationUrl = try reader["authorizationUrl"].readIfPresent() ?? ""
        return value
    }
}

extension QBusinessClientTypes.FailedAttachmentEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.FailedAttachmentEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.FailedAttachmentEvent()
        value.conversationId = try reader["conversationId"].readIfPresent()
        value.userMessageId = try reader["userMessageId"].readIfPresent()
        value.systemMessageId = try reader["systemMessageId"].readIfPresent()
        value.attachment = try reader["attachment"].readIfPresent(with: QBusinessClientTypes.AttachmentOutput.read(from:))
        return value
    }
}

extension QBusinessClientTypes.AttachmentOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.AttachmentOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.AttachmentOutput()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.error = try reader["error"].readIfPresent(with: QBusinessClientTypes.ErrorDetail.read(from:))
        return value
    }
}

extension QBusinessClientTypes.ActionReviewEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.ActionReviewEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.ActionReviewEvent()
        value.conversationId = try reader["conversationId"].readIfPresent()
        value.userMessageId = try reader["userMessageId"].readIfPresent()
        value.systemMessageId = try reader["systemMessageId"].readIfPresent()
        value.pluginId = try reader["pluginId"].readIfPresent()
        value.pluginType = try reader["pluginType"].readIfPresent()
        value.payload = try reader["payload"].readMapIfPresent(valueReadingClosure: QBusinessClientTypes.ActionReviewPayloadField.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.payloadFieldNameSeparator = try reader["payloadFieldNameSeparator"].readIfPresent()
        return value
    }
}

extension QBusinessClientTypes.ActionReviewPayloadField {

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.ActionReviewPayloadField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.ActionReviewPayloadField()
        value.displayName = try reader["displayName"].readIfPresent()
        value.displayOrder = try reader["displayOrder"].readIfPresent()
        value.displayDescription = try reader["displayDescription"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        value.allowedValues = try reader["allowedValues"].readListIfPresent(memberReadingClosure: QBusinessClientTypes.ActionReviewPayloadFieldAllowedValue.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.allowedFormat = try reader["allowedFormat"].readIfPresent()
        value.arrayItemJsonSchema = try reader["arrayItemJsonSchema"].readIfPresent()
        value.`required` = try reader["required"].readIfPresent()
        return value
    }
}

extension QBusinessClientTypes.ActionReviewPayloadFieldAllowedValue {

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.ActionReviewPayloadFieldAllowedValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.ActionReviewPayloadFieldAllowedValue()
        value.value = try reader["value"].readIfPresent()
        value.displayValue = try reader["displayValue"].readIfPresent()
        return value
    }
}

extension QBusinessClientTypes.MetadataEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.MetadataEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.MetadataEvent()
        value.conversationId = try reader["conversationId"].readIfPresent()
        value.userMessageId = try reader["userMessageId"].readIfPresent()
        value.systemMessageId = try reader["systemMessageId"].readIfPresent()
        value.sourceAttributions = try reader["sourceAttributions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.optionalFormOf(readingClosure: QBusinessClientTypes.SourceAttribution.read(from:)), memberNodeInfo: "member", isFlattened: false)
        value.finalTextMessage = try reader["finalTextMessage"].readIfPresent()
        return value
    }
}

extension QBusinessClientTypes.SourceAttribution {

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.SourceAttribution {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.SourceAttribution()
        value.title = try reader["title"].readIfPresent()
        value.snippet = try reader["snippet"].readIfPresent()
        value.url = try reader["url"].readIfPresent()
        value.citationNumber = try reader["citationNumber"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.textMessageSegments = try reader["textMessageSegments"].readListIfPresent(memberReadingClosure: QBusinessClientTypes.TextSegment.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QBusinessClientTypes.TextSegment {

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.TextSegment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.TextSegment()
        value.beginOffset = try reader["beginOffset"].readIfPresent()
        value.endOffset = try reader["endOffset"].readIfPresent()
        value.snippetExcerpt = try reader["snippetExcerpt"].readIfPresent(with: QBusinessClientTypes.SnippetExcerpt.read(from:))
        return value
    }
}

extension QBusinessClientTypes.SnippetExcerpt {

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.SnippetExcerpt {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.SnippetExcerpt()
        value.text = try reader["text"].readIfPresent()
        return value
    }
}

extension QBusinessClientTypes.TextOutputEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.TextOutputEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.TextOutputEvent()
        value.conversationId = try reader["conversationId"].readIfPresent()
        value.userMessageId = try reader["userMessageId"].readIfPresent()
        value.systemMessageId = try reader["systemMessageId"].readIfPresent()
        value.systemMessage = try reader["systemMessage"].readIfPresent()
        return value
    }
}

extension QBusinessClientTypes.ActionReview {

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.ActionReview {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.ActionReview()
        value.pluginId = try reader["pluginId"].readIfPresent()
        value.pluginType = try reader["pluginType"].readIfPresent()
        value.payload = try reader["payload"].readMapIfPresent(valueReadingClosure: QBusinessClientTypes.ActionReviewPayloadField.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.payloadFieldNameSeparator = try reader["payloadFieldNameSeparator"].readIfPresent()
        return value
    }
}

extension QBusinessClientTypes.AuthChallengeRequest {

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.AuthChallengeRequest {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.AuthChallengeRequest()
        value.authorizationUrl = try reader["authorizationUrl"].readIfPresent() ?? ""
        return value
    }
}

extension QBusinessClientTypes.EncryptionConfiguration {

    static func write(value: QBusinessClientTypes.EncryptionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["kmsKeyId"].write(value.kmsKeyId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.EncryptionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.EncryptionConfiguration()
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent()
        return value
    }
}

extension QBusinessClientTypes.AppliedAttachmentsConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.AppliedAttachmentsConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.AppliedAttachmentsConfiguration()
        value.attachmentsControlMode = try reader["attachmentsControlMode"].readIfPresent()
        return value
    }
}

extension QBusinessClientTypes.QAppsConfiguration {

    static func write(value: QBusinessClientTypes.QAppsConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["qAppsControlMode"].write(value.qAppsControlMode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.QAppsConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.QAppsConfiguration()
        value.qAppsControlMode = try reader["qAppsControlMode"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension QBusinessClientTypes.PersonalizationConfiguration {

    static func write(value: QBusinessClientTypes.PersonalizationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["personalizationControlMode"].write(value.personalizationControlMode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.PersonalizationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.PersonalizationConfiguration()
        value.personalizationControlMode = try reader["personalizationControlMode"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension QBusinessClientTypes.AutoSubscriptionConfiguration {

    static func write(value: QBusinessClientTypes.AutoSubscriptionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["autoSubscribe"].write(value.autoSubscribe)
        try writer["defaultSubscriptionType"].write(value.defaultSubscriptionType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.AutoSubscriptionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.AutoSubscriptionConfiguration()
        value.autoSubscribe = try reader["autoSubscribe"].readIfPresent() ?? .sdkUnknown("")
        value.defaultSubscriptionType = try reader["defaultSubscriptionType"].readIfPresent()
        return value
    }
}

extension QBusinessClientTypes.BlockedPhrasesConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.BlockedPhrasesConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.BlockedPhrasesConfiguration()
        value.blockedPhrases = try reader["blockedPhrases"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.systemMessageOverride = try reader["systemMessageOverride"].readIfPresent()
        return value
    }
}

extension QBusinessClientTypes.TopicConfiguration {

    static func write(value: QBusinessClientTypes.TopicConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["exampleChatMessages"].writeList(value.exampleChatMessages, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["rules"].writeList(value.rules, memberWritingClosure: QBusinessClientTypes.Rule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.TopicConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.TopicConfiguration()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.exampleChatMessages = try reader["exampleChatMessages"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.rules = try reader["rules"].readListIfPresent(memberReadingClosure: QBusinessClientTypes.Rule.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension QBusinessClientTypes.Rule {

    static func write(value: QBusinessClientTypes.Rule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["excludedUsersAndGroups"].write(value.excludedUsersAndGroups, with: QBusinessClientTypes.UsersAndGroups.write(value:to:))
        try writer["includedUsersAndGroups"].write(value.includedUsersAndGroups, with: QBusinessClientTypes.UsersAndGroups.write(value:to:))
        try writer["ruleConfiguration"].write(value.ruleConfiguration, with: QBusinessClientTypes.RuleConfiguration.write(value:to:))
        try writer["ruleType"].write(value.ruleType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.Rule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.Rule()
        value.includedUsersAndGroups = try reader["includedUsersAndGroups"].readIfPresent(with: QBusinessClientTypes.UsersAndGroups.read(from:))
        value.excludedUsersAndGroups = try reader["excludedUsersAndGroups"].readIfPresent(with: QBusinessClientTypes.UsersAndGroups.read(from:))
        value.ruleType = try reader["ruleType"].readIfPresent() ?? .sdkUnknown("")
        value.ruleConfiguration = try reader["ruleConfiguration"].readIfPresent(with: QBusinessClientTypes.RuleConfiguration.read(from:))
        return value
    }
}

extension QBusinessClientTypes.RuleConfiguration {

    static func write(value: QBusinessClientTypes.RuleConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .contentblockerrule(contentblockerrule):
                try writer["contentBlockerRule"].write(contentblockerrule, with: QBusinessClientTypes.ContentBlockerRule.write(value:to:))
            case let .contentretrievalrule(contentretrievalrule):
                try writer["contentRetrievalRule"].write(contentretrievalrule, with: QBusinessClientTypes.ContentRetrievalRule.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.RuleConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "contentBlockerRule":
                return .contentblockerrule(try reader["contentBlockerRule"].read(with: QBusinessClientTypes.ContentBlockerRule.read(from:)))
            case "contentRetrievalRule":
                return .contentretrievalrule(try reader["contentRetrievalRule"].read(with: QBusinessClientTypes.ContentRetrievalRule.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension QBusinessClientTypes.ContentRetrievalRule {

    static func write(value: QBusinessClientTypes.ContentRetrievalRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["eligibleDataSources"].writeList(value.eligibleDataSources, memberWritingClosure: QBusinessClientTypes.EligibleDataSource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.ContentRetrievalRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.ContentRetrievalRule()
        value.eligibleDataSources = try reader["eligibleDataSources"].readListIfPresent(memberReadingClosure: QBusinessClientTypes.EligibleDataSource.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QBusinessClientTypes.EligibleDataSource {

    static func write(value: QBusinessClientTypes.EligibleDataSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dataSourceId"].write(value.dataSourceId)
        try writer["indexId"].write(value.indexId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.EligibleDataSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.EligibleDataSource()
        value.indexId = try reader["indexId"].readIfPresent()
        value.dataSourceId = try reader["dataSourceId"].readIfPresent()
        return value
    }
}

extension QBusinessClientTypes.ContentBlockerRule {

    static func write(value: QBusinessClientTypes.ContentBlockerRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["systemMessageOverride"].write(value.systemMessageOverride)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.ContentBlockerRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.ContentBlockerRule()
        value.systemMessageOverride = try reader["systemMessageOverride"].readIfPresent()
        return value
    }
}

extension QBusinessClientTypes.UsersAndGroups {

    static func write(value: QBusinessClientTypes.UsersAndGroups?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["userGroups"].writeList(value.userGroups, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["userIds"].writeList(value.userIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.UsersAndGroups {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.UsersAndGroups()
        value.userIds = try reader["userIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.userGroups = try reader["userGroups"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QBusinessClientTypes.AppliedCreatorModeConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.AppliedCreatorModeConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.AppliedCreatorModeConfiguration()
        value.creatorModeControl = try reader["creatorModeControl"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension QBusinessClientTypes.DataSourceVpcConfiguration {

    static func write(value: QBusinessClientTypes.DataSourceVpcConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["subnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.DataSourceVpcConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.DataSourceVpcConfiguration()
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension QBusinessClientTypes.DocumentEnrichmentConfiguration {

    static func write(value: QBusinessClientTypes.DocumentEnrichmentConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["inlineConfigurations"].writeList(value.inlineConfigurations, memberWritingClosure: QBusinessClientTypes.InlineDocumentEnrichmentConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["postExtractionHookConfiguration"].write(value.postExtractionHookConfiguration, with: QBusinessClientTypes.HookConfiguration.write(value:to:))
        try writer["preExtractionHookConfiguration"].write(value.preExtractionHookConfiguration, with: QBusinessClientTypes.HookConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.DocumentEnrichmentConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.DocumentEnrichmentConfiguration()
        value.inlineConfigurations = try reader["inlineConfigurations"].readListIfPresent(memberReadingClosure: QBusinessClientTypes.InlineDocumentEnrichmentConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.preExtractionHookConfiguration = try reader["preExtractionHookConfiguration"].readIfPresent(with: QBusinessClientTypes.HookConfiguration.read(from:))
        value.postExtractionHookConfiguration = try reader["postExtractionHookConfiguration"].readIfPresent(with: QBusinessClientTypes.HookConfiguration.read(from:))
        return value
    }
}

extension QBusinessClientTypes.HookConfiguration {

    static func write(value: QBusinessClientTypes.HookConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["invocationCondition"].write(value.invocationCondition, with: QBusinessClientTypes.DocumentAttributeCondition.write(value:to:))
        try writer["lambdaArn"].write(value.lambdaArn)
        try writer["roleArn"].write(value.roleArn)
        try writer["s3BucketName"].write(value.s3BucketName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.HookConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.HookConfiguration()
        value.invocationCondition = try reader["invocationCondition"].readIfPresent(with: QBusinessClientTypes.DocumentAttributeCondition.read(from:))
        value.lambdaArn = try reader["lambdaArn"].readIfPresent()
        value.s3BucketName = try reader["s3BucketName"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent()
        return value
    }
}

extension QBusinessClientTypes.DocumentAttributeCondition {

    static func write(value: QBusinessClientTypes.DocumentAttributeCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["operator"].write(value.`operator`)
        try writer["value"].write(value.value, with: QBusinessClientTypes.DocumentAttributeValue.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.DocumentAttributeCondition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.DocumentAttributeCondition()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.`operator` = try reader["operator"].readIfPresent() ?? .sdkUnknown("")
        value.value = try reader["value"].readIfPresent(with: QBusinessClientTypes.DocumentAttributeValue.read(from:))
        return value
    }
}

extension QBusinessClientTypes.DocumentAttributeValue {

    static func write(value: QBusinessClientTypes.DocumentAttributeValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .datevalue(datevalue):
                try writer["dateValue"].writeTimestamp(datevalue, format: SmithyTimestamps.TimestampFormat.epochSeconds)
            case let .longvalue(longvalue):
                try writer["longValue"].write(longvalue)
            case let .stringlistvalue(stringlistvalue):
                try writer["stringListValue"].writeList(stringlistvalue, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .stringvalue(stringvalue):
                try writer["stringValue"].write(stringvalue)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.DocumentAttributeValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "stringValue":
                return .stringvalue(try reader["stringValue"].read())
            case "stringListValue":
                return .stringlistvalue(try reader["stringListValue"].readList(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false))
            case "longValue":
                return .longvalue(try reader["longValue"].read())
            case "dateValue":
                return .datevalue(try reader["dateValue"].readTimestamp(format: SmithyTimestamps.TimestampFormat.epochSeconds))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension QBusinessClientTypes.InlineDocumentEnrichmentConfiguration {

    static func write(value: QBusinessClientTypes.InlineDocumentEnrichmentConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["condition"].write(value.condition, with: QBusinessClientTypes.DocumentAttributeCondition.write(value:to:))
        try writer["documentContentOperator"].write(value.documentContentOperator)
        try writer["target"].write(value.target, with: QBusinessClientTypes.DocumentAttributeTarget.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.InlineDocumentEnrichmentConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.InlineDocumentEnrichmentConfiguration()
        value.condition = try reader["condition"].readIfPresent(with: QBusinessClientTypes.DocumentAttributeCondition.read(from:))
        value.target = try reader["target"].readIfPresent(with: QBusinessClientTypes.DocumentAttributeTarget.read(from:))
        value.documentContentOperator = try reader["documentContentOperator"].readIfPresent()
        return value
    }
}

extension QBusinessClientTypes.DocumentAttributeTarget {

    static func write(value: QBusinessClientTypes.DocumentAttributeTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributeValueOperator"].write(value.attributeValueOperator)
        try writer["key"].write(value.key)
        try writer["value"].write(value.value, with: QBusinessClientTypes.DocumentAttributeValue.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.DocumentAttributeTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.DocumentAttributeTarget()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent(with: QBusinessClientTypes.DocumentAttributeValue.read(from:))
        value.attributeValueOperator = try reader["attributeValueOperator"].readIfPresent()
        return value
    }
}

extension QBusinessClientTypes.GroupStatusDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.GroupStatusDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.GroupStatusDetail()
        value.status = try reader["status"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.errorDetail = try reader["errorDetail"].readIfPresent(with: QBusinessClientTypes.ErrorDetail.read(from:))
        return value
    }
}

extension QBusinessClientTypes.IndexCapacityConfiguration {

    static func write(value: QBusinessClientTypes.IndexCapacityConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["units"].write(value.units)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.IndexCapacityConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.IndexCapacityConfiguration()
        value.units = try reader["units"].readIfPresent()
        return value
    }
}

extension QBusinessClientTypes.DocumentAttributeConfiguration {

    static func write(value: QBusinessClientTypes.DocumentAttributeConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["search"].write(value.search)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.DocumentAttributeConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.DocumentAttributeConfiguration()
        value.name = try reader["name"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.search = try reader["search"].readIfPresent()
        return value
    }
}

extension QBusinessClientTypes.IndexStatistics {

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.IndexStatistics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.IndexStatistics()
        value.textDocumentStatistics = try reader["textDocumentStatistics"].readIfPresent(with: QBusinessClientTypes.TextDocumentStatistics.read(from:))
        return value
    }
}

extension QBusinessClientTypes.TextDocumentStatistics {

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.TextDocumentStatistics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.TextDocumentStatistics()
        value.indexedTextBytes = try reader["indexedTextBytes"].readIfPresent()
        value.indexedTextDocumentCount = try reader["indexedTextDocumentCount"].readIfPresent()
        return value
    }
}

extension QBusinessClientTypes.PluginAuthConfiguration {

    static func write(value: QBusinessClientTypes.PluginAuthConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .basicauthconfiguration(basicauthconfiguration):
                try writer["basicAuthConfiguration"].write(basicauthconfiguration, with: QBusinessClientTypes.BasicAuthConfiguration.write(value:to:))
            case let .noauthconfiguration(noauthconfiguration):
                try writer["noAuthConfiguration"].write(noauthconfiguration, with: QBusinessClientTypes.NoAuthConfiguration.write(value:to:))
            case let .oauth2clientcredentialconfiguration(oauth2clientcredentialconfiguration):
                try writer["oAuth2ClientCredentialConfiguration"].write(oauth2clientcredentialconfiguration, with: QBusinessClientTypes.OAuth2ClientCredentialConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.PluginAuthConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "basicAuthConfiguration":
                return .basicauthconfiguration(try reader["basicAuthConfiguration"].read(with: QBusinessClientTypes.BasicAuthConfiguration.read(from:)))
            case "oAuth2ClientCredentialConfiguration":
                return .oauth2clientcredentialconfiguration(try reader["oAuth2ClientCredentialConfiguration"].read(with: QBusinessClientTypes.OAuth2ClientCredentialConfiguration.read(from:)))
            case "noAuthConfiguration":
                return .noauthconfiguration(try reader["noAuthConfiguration"].read(with: QBusinessClientTypes.NoAuthConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension QBusinessClientTypes.NoAuthConfiguration {

    static func write(value: QBusinessClientTypes.NoAuthConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.NoAuthConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return QBusinessClientTypes.NoAuthConfiguration()
    }
}

extension QBusinessClientTypes.OAuth2ClientCredentialConfiguration {

    static func write(value: QBusinessClientTypes.OAuth2ClientCredentialConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["roleArn"].write(value.roleArn)
        try writer["secretArn"].write(value.secretArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.OAuth2ClientCredentialConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.OAuth2ClientCredentialConfiguration()
        value.secretArn = try reader["secretArn"].readIfPresent() ?? ""
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        return value
    }
}

extension QBusinessClientTypes.BasicAuthConfiguration {

    static func write(value: QBusinessClientTypes.BasicAuthConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["roleArn"].write(value.roleArn)
        try writer["secretArn"].write(value.secretArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.BasicAuthConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.BasicAuthConfiguration()
        value.secretArn = try reader["secretArn"].readIfPresent() ?? ""
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        return value
    }
}

extension QBusinessClientTypes.CustomPluginConfiguration {

    static func write(value: QBusinessClientTypes.CustomPluginConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["apiSchema"].write(value.apiSchema, with: QBusinessClientTypes.APISchema.write(value:to:))
        try writer["apiSchemaType"].write(value.apiSchemaType)
        try writer["description"].write(value.description)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.CustomPluginConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.CustomPluginConfiguration()
        value.description = try reader["description"].readIfPresent() ?? ""
        value.apiSchemaType = try reader["apiSchemaType"].readIfPresent() ?? .sdkUnknown("")
        value.apiSchema = try reader["apiSchema"].readIfPresent(with: QBusinessClientTypes.APISchema.read(from:))
        return value
    }
}

extension QBusinessClientTypes.APISchema {

    static func write(value: QBusinessClientTypes.APISchema?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .payload(payload):
                try writer["payload"].write(payload)
            case let .s3(s3):
                try writer["s3"].write(s3, with: QBusinessClientTypes.S3.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.APISchema {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "payload":
                return .payload(try reader["payload"].read())
            case "s3":
                return .s3(try reader["s3"].read(with: QBusinessClientTypes.S3.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension QBusinessClientTypes.S3 {

    static func write(value: QBusinessClientTypes.S3?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucket"].write(value.bucket)
        try writer["key"].write(value.key)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.S3 {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.S3()
        value.bucket = try reader["bucket"].readIfPresent() ?? ""
        value.key = try reader["key"].readIfPresent() ?? ""
        return value
    }
}

extension QBusinessClientTypes.RetrieverConfiguration {

    static func write(value: QBusinessClientTypes.RetrieverConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .kendraindexconfiguration(kendraindexconfiguration):
                try writer["kendraIndexConfiguration"].write(kendraindexconfiguration, with: QBusinessClientTypes.KendraIndexConfiguration.write(value:to:))
            case let .nativeindexconfiguration(nativeindexconfiguration):
                try writer["nativeIndexConfiguration"].write(nativeindexconfiguration, with: QBusinessClientTypes.NativeIndexConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.RetrieverConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "nativeIndexConfiguration":
                return .nativeindexconfiguration(try reader["nativeIndexConfiguration"].read(with: QBusinessClientTypes.NativeIndexConfiguration.read(from:)))
            case "kendraIndexConfiguration":
                return .kendraindexconfiguration(try reader["kendraIndexConfiguration"].read(with: QBusinessClientTypes.KendraIndexConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension QBusinessClientTypes.KendraIndexConfiguration {

    static func write(value: QBusinessClientTypes.KendraIndexConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["indexId"].write(value.indexId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.KendraIndexConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.KendraIndexConfiguration()
        value.indexId = try reader["indexId"].readIfPresent() ?? ""
        return value
    }
}

extension QBusinessClientTypes.NativeIndexConfiguration {

    static func write(value: QBusinessClientTypes.NativeIndexConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["boostingOverride"].writeMap(value.boostingOverride, valueWritingClosure: QBusinessClientTypes.DocumentAttributeBoostingConfiguration.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["indexId"].write(value.indexId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.NativeIndexConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.NativeIndexConfiguration()
        value.indexId = try reader["indexId"].readIfPresent() ?? ""
        value.boostingOverride = try reader["boostingOverride"].readMapIfPresent(valueReadingClosure: QBusinessClientTypes.DocumentAttributeBoostingConfiguration.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension QBusinessClientTypes.DocumentAttributeBoostingConfiguration {

    static func write(value: QBusinessClientTypes.DocumentAttributeBoostingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .dateconfiguration(dateconfiguration):
                try writer["dateConfiguration"].write(dateconfiguration, with: QBusinessClientTypes.DateAttributeBoostingConfiguration.write(value:to:))
            case let .numberconfiguration(numberconfiguration):
                try writer["numberConfiguration"].write(numberconfiguration, with: QBusinessClientTypes.NumberAttributeBoostingConfiguration.write(value:to:))
            case let .stringconfiguration(stringconfiguration):
                try writer["stringConfiguration"].write(stringconfiguration, with: QBusinessClientTypes.StringAttributeBoostingConfiguration.write(value:to:))
            case let .stringlistconfiguration(stringlistconfiguration):
                try writer["stringListConfiguration"].write(stringlistconfiguration, with: QBusinessClientTypes.StringListAttributeBoostingConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.DocumentAttributeBoostingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "numberConfiguration":
                return .numberconfiguration(try reader["numberConfiguration"].read(with: QBusinessClientTypes.NumberAttributeBoostingConfiguration.read(from:)))
            case "stringConfiguration":
                return .stringconfiguration(try reader["stringConfiguration"].read(with: QBusinessClientTypes.StringAttributeBoostingConfiguration.read(from:)))
            case "dateConfiguration":
                return .dateconfiguration(try reader["dateConfiguration"].read(with: QBusinessClientTypes.DateAttributeBoostingConfiguration.read(from:)))
            case "stringListConfiguration":
                return .stringlistconfiguration(try reader["stringListConfiguration"].read(with: QBusinessClientTypes.StringListAttributeBoostingConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension QBusinessClientTypes.StringListAttributeBoostingConfiguration {

    static func write(value: QBusinessClientTypes.StringListAttributeBoostingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["boostingLevel"].write(value.boostingLevel)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.StringListAttributeBoostingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.StringListAttributeBoostingConfiguration()
        value.boostingLevel = try reader["boostingLevel"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension QBusinessClientTypes.DateAttributeBoostingConfiguration {

    static func write(value: QBusinessClientTypes.DateAttributeBoostingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["boostingDurationInSeconds"].write(value.boostingDurationInSeconds)
        try writer["boostingLevel"].write(value.boostingLevel)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.DateAttributeBoostingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.DateAttributeBoostingConfiguration()
        value.boostingLevel = try reader["boostingLevel"].readIfPresent() ?? .sdkUnknown("")
        value.boostingDurationInSeconds = try reader["boostingDurationInSeconds"].readIfPresent()
        return value
    }
}

extension QBusinessClientTypes.StringAttributeBoostingConfiguration {

    static func write(value: QBusinessClientTypes.StringAttributeBoostingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributeValueBoosting"].writeMap(value.attributeValueBoosting, valueWritingClosure: SmithyReadWrite.WritingClosureBox<QBusinessClientTypes.StringAttributeValueBoostingLevel>().write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["boostingLevel"].write(value.boostingLevel)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.StringAttributeBoostingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.StringAttributeBoostingConfiguration()
        value.boostingLevel = try reader["boostingLevel"].readIfPresent() ?? .sdkUnknown("")
        value.attributeValueBoosting = try reader["attributeValueBoosting"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosureBox<QBusinessClientTypes.StringAttributeValueBoostingLevel>().read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension QBusinessClientTypes.NumberAttributeBoostingConfiguration {

    static func write(value: QBusinessClientTypes.NumberAttributeBoostingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["boostingLevel"].write(value.boostingLevel)
        try writer["boostingType"].write(value.boostingType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.NumberAttributeBoostingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.NumberAttributeBoostingConfiguration()
        value.boostingLevel = try reader["boostingLevel"].readIfPresent() ?? .sdkUnknown("")
        value.boostingType = try reader["boostingType"].readIfPresent()
        return value
    }
}

extension QBusinessClientTypes.UserAlias {

    static func write(value: QBusinessClientTypes.UserAlias?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dataSourceId"].write(value.dataSourceId)
        try writer["indexId"].write(value.indexId)
        try writer["userId"].write(value.userId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.UserAlias {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.UserAlias()
        value.indexId = try reader["indexId"].readIfPresent()
        value.dataSourceId = try reader["dataSourceId"].readIfPresent()
        value.userId = try reader["userId"].readIfPresent() ?? ""
        return value
    }
}

extension QBusinessClientTypes.IdentityProviderConfiguration {

    static func write(value: QBusinessClientTypes.IdentityProviderConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .openidconnectconfiguration(openidconnectconfiguration):
                try writer["openIDConnectConfiguration"].write(openidconnectconfiguration, with: QBusinessClientTypes.OpenIDConnectProviderConfiguration.write(value:to:))
            case let .samlconfiguration(samlconfiguration):
                try writer["samlConfiguration"].write(samlconfiguration, with: QBusinessClientTypes.SamlProviderConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.IdentityProviderConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "samlConfiguration":
                return .samlconfiguration(try reader["samlConfiguration"].read(with: QBusinessClientTypes.SamlProviderConfiguration.read(from:)))
            case "openIDConnectConfiguration":
                return .openidconnectconfiguration(try reader["openIDConnectConfiguration"].read(with: QBusinessClientTypes.OpenIDConnectProviderConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension QBusinessClientTypes.OpenIDConnectProviderConfiguration {

    static func write(value: QBusinessClientTypes.OpenIDConnectProviderConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["secretsArn"].write(value.secretsArn)
        try writer["secretsRole"].write(value.secretsRole)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.OpenIDConnectProviderConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.OpenIDConnectProviderConfiguration()
        value.secretsArn = try reader["secretsArn"].readIfPresent() ?? ""
        value.secretsRole = try reader["secretsRole"].readIfPresent() ?? ""
        return value
    }
}

extension QBusinessClientTypes.SamlProviderConfiguration {

    static func write(value: QBusinessClientTypes.SamlProviderConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authenticationUrl"].write(value.authenticationUrl)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.SamlProviderConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.SamlProviderConfiguration()
        value.authenticationUrl = try reader["authenticationUrl"].readIfPresent() ?? ""
        return value
    }
}

extension QBusinessClientTypes.WebExperienceAuthConfiguration {

    static func write(value: QBusinessClientTypes.WebExperienceAuthConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .samlconfiguration(samlconfiguration):
                try writer["samlConfiguration"].write(samlconfiguration, with: QBusinessClientTypes.SamlConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.WebExperienceAuthConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "samlConfiguration":
                return .samlconfiguration(try reader["samlConfiguration"].read(with: QBusinessClientTypes.SamlConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension QBusinessClientTypes.SamlConfiguration {

    static func write(value: QBusinessClientTypes.SamlConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["metadataXML"].write(value.metadataXML)
        try writer["roleArn"].write(value.roleArn)
        try writer["userGroupAttribute"].write(value.userGroupAttribute)
        try writer["userIdAttribute"].write(value.userIdAttribute)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.SamlConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.SamlConfiguration()
        value.metadataXML = try reader["metadataXML"].readIfPresent() ?? ""
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.userIdAttribute = try reader["userIdAttribute"].readIfPresent() ?? ""
        value.userGroupAttribute = try reader["userGroupAttribute"].readIfPresent()
        return value
    }
}

extension QBusinessClientTypes.Application {

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.Application {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.Application()
        value.displayName = try reader["displayName"].readIfPresent()
        value.applicationId = try reader["applicationId"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["status"].readIfPresent()
        value.identityType = try reader["identityType"].readIfPresent()
        return value
    }
}

extension QBusinessClientTypes.Conversation {

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.Conversation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.Conversation()
        value.conversationId = try reader["conversationId"].readIfPresent()
        value.title = try reader["title"].readIfPresent()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension QBusinessClientTypes.DataSource {

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.DataSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.DataSource()
        value.displayName = try reader["displayName"].readIfPresent()
        value.dataSourceId = try reader["dataSourceId"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension QBusinessClientTypes.DataSourceSyncJob {

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.DataSourceSyncJob {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.DataSourceSyncJob()
        value.executionId = try reader["executionId"].readIfPresent()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["status"].readIfPresent()
        value.error = try reader["error"].readIfPresent(with: QBusinessClientTypes.ErrorDetail.read(from:))
        value.dataSourceErrorCode = try reader["dataSourceErrorCode"].readIfPresent()
        value.metrics = try reader["metrics"].readIfPresent(with: QBusinessClientTypes.DataSourceSyncJobMetrics.read(from:))
        return value
    }
}

extension QBusinessClientTypes.DataSourceSyncJobMetrics {

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.DataSourceSyncJobMetrics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.DataSourceSyncJobMetrics()
        value.documentsAdded = try reader["documentsAdded"].readIfPresent()
        value.documentsModified = try reader["documentsModified"].readIfPresent()
        value.documentsDeleted = try reader["documentsDeleted"].readIfPresent()
        value.documentsFailed = try reader["documentsFailed"].readIfPresent()
        value.documentsScanned = try reader["documentsScanned"].readIfPresent()
        return value
    }
}

extension QBusinessClientTypes.DocumentDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.DocumentDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.DocumentDetails()
        value.documentId = try reader["documentId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.error = try reader["error"].readIfPresent(with: QBusinessClientTypes.ErrorDetail.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension QBusinessClientTypes.GroupSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.GroupSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.GroupSummary()
        value.groupName = try reader["groupName"].readIfPresent()
        return value
    }
}

extension QBusinessClientTypes.Index {

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.Index {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.Index()
        value.displayName = try reader["displayName"].readIfPresent()
        value.indexId = try reader["indexId"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension QBusinessClientTypes.Message {

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.Message {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.Message()
        value.messageId = try reader["messageId"].readIfPresent()
        value.body = try reader["body"].readIfPresent()
        value.time = try reader["time"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.type = try reader["type"].readIfPresent()
        value.attachments = try reader["attachments"].readListIfPresent(memberReadingClosure: QBusinessClientTypes.AttachmentOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.sourceAttribution = try reader["sourceAttribution"].readListIfPresent(memberReadingClosure: SmithyReadWrite.optionalFormOf(readingClosure: QBusinessClientTypes.SourceAttribution.read(from:)), memberNodeInfo: "member", isFlattened: false)
        value.actionReview = try reader["actionReview"].readIfPresent(with: QBusinessClientTypes.ActionReview.read(from:))
        value.actionExecution = try reader["actionExecution"].readIfPresent(with: QBusinessClientTypes.ActionExecution.read(from:))
        return value
    }
}

extension QBusinessClientTypes.ActionExecution {

    static func write(value: QBusinessClientTypes.ActionExecution?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["payload"].writeMap(value.payload, valueWritingClosure: QBusinessClientTypes.ActionExecutionPayloadField.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["payloadFieldNameSeparator"].write(value.payloadFieldNameSeparator)
        try writer["pluginId"].write(value.pluginId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.ActionExecution {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.ActionExecution()
        value.pluginId = try reader["pluginId"].readIfPresent() ?? ""
        value.payload = try reader["payload"].readMapIfPresent(valueReadingClosure: QBusinessClientTypes.ActionExecutionPayloadField.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.payloadFieldNameSeparator = try reader["payloadFieldNameSeparator"].readIfPresent() ?? ""
        return value
    }
}

extension QBusinessClientTypes.ActionExecutionPayloadField {

    static func write(value: QBusinessClientTypes.ActionExecutionPayloadField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.ActionExecutionPayloadField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.ActionExecutionPayloadField()
        value.value = try reader["value"].readIfPresent() ?? [:]
        return value
    }
}

extension QBusinessClientTypes.Plugin {

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.Plugin {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.Plugin()
        value.pluginId = try reader["pluginId"].readIfPresent()
        value.displayName = try reader["displayName"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.serverUrl = try reader["serverUrl"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        value.buildStatus = try reader["buildStatus"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension QBusinessClientTypes.Retriever {

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.Retriever {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.Retriever()
        value.applicationId = try reader["applicationId"].readIfPresent()
        value.retrieverId = try reader["retrieverId"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.displayName = try reader["displayName"].readIfPresent()
        return value
    }
}

extension QBusinessClientTypes.Tag {

    static func write(value: QBusinessClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.Tag()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension QBusinessClientTypes.WebExperience {

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.WebExperience {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.WebExperience()
        value.webExperienceId = try reader["webExperienceId"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.defaultEndpoint = try reader["defaultEndpoint"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension QBusinessClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> QBusinessClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QBusinessClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension QBusinessClientTypes.DeleteDocument {

    static func write(value: QBusinessClientTypes.DeleteDocument?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["documentId"].write(value.documentId)
    }
}

extension QBusinessClientTypes.Document {

    static func write(value: QBusinessClientTypes.Document?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accessConfiguration"].write(value.accessConfiguration, with: QBusinessClientTypes.AccessConfiguration.write(value:to:))
        try writer["attributes"].writeList(value.attributes, memberWritingClosure: QBusinessClientTypes.DocumentAttribute.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["content"].write(value.content, with: QBusinessClientTypes.DocumentContent.write(value:to:))
        try writer["contentType"].write(value.contentType)
        try writer["documentEnrichmentConfiguration"].write(value.documentEnrichmentConfiguration, with: QBusinessClientTypes.DocumentEnrichmentConfiguration.write(value:to:))
        try writer["id"].write(value.id)
        try writer["title"].write(value.title)
    }
}

extension QBusinessClientTypes.AccessConfiguration {

    static func write(value: QBusinessClientTypes.AccessConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accessControls"].writeList(value.accessControls, memberWritingClosure: QBusinessClientTypes.AccessControl.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["memberRelation"].write(value.memberRelation)
    }
}

extension QBusinessClientTypes.AccessControl {

    static func write(value: QBusinessClientTypes.AccessControl?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["memberRelation"].write(value.memberRelation)
        try writer["principals"].writeList(value.principals, memberWritingClosure: QBusinessClientTypes.Principal.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension QBusinessClientTypes.Principal {

    static func write(value: QBusinessClientTypes.Principal?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .group(group):
                try writer["group"].write(group, with: QBusinessClientTypes.PrincipalGroup.write(value:to:))
            case let .user(user):
                try writer["user"].write(user, with: QBusinessClientTypes.PrincipalUser.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension QBusinessClientTypes.PrincipalGroup {

    static func write(value: QBusinessClientTypes.PrincipalGroup?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["access"].write(value.access)
        try writer["membershipType"].write(value.membershipType)
        try writer["name"].write(value.name)
    }
}

extension QBusinessClientTypes.PrincipalUser {

    static func write(value: QBusinessClientTypes.PrincipalUser?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["access"].write(value.access)
        try writer["id"].write(value.id)
        try writer["membershipType"].write(value.membershipType)
    }
}

extension QBusinessClientTypes.DocumentContent {

    static func write(value: QBusinessClientTypes.DocumentContent?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .blob(blob):
                try writer["blob"].write(blob)
            case let .s3(s3):
                try writer["s3"].write(s3, with: QBusinessClientTypes.S3.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension QBusinessClientTypes.DocumentAttribute {

    static func write(value: QBusinessClientTypes.DocumentAttribute?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["value"].write(value.value, with: QBusinessClientTypes.DocumentAttributeValue.write(value:to:))
    }
}

extension QBusinessClientTypes.AuthChallengeResponseEvent {

    static func write(value: QBusinessClientTypes.AuthChallengeResponseEvent?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["responseMap"].writeMap(value.responseMap, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension QBusinessClientTypes.EndOfInputEvent {

    static func write(value: QBusinessClientTypes.EndOfInputEvent?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension QBusinessClientTypes.ActionExecutionEvent {

    static func write(value: QBusinessClientTypes.ActionExecutionEvent?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["payload"].writeMap(value.payload, valueWritingClosure: QBusinessClientTypes.ActionExecutionPayloadField.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["payloadFieldNameSeparator"].write(value.payloadFieldNameSeparator)
        try writer["pluginId"].write(value.pluginId)
    }
}

extension QBusinessClientTypes.AttachmentInputEvent {

    static func write(value: QBusinessClientTypes.AttachmentInputEvent?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attachment"].write(value.attachment, with: QBusinessClientTypes.AttachmentInput.write(value:to:))
    }
}

extension QBusinessClientTypes.AttachmentInput {

    static func write(value: QBusinessClientTypes.AttachmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["data"].write(value.data)
        try writer["name"].write(value.name)
    }
}

extension QBusinessClientTypes.TextInputEvent {

    static func write(value: QBusinessClientTypes.TextInputEvent?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["userMessage"].write(value.userMessage)
    }
}

extension QBusinessClientTypes.ConfigurationEvent {

    static func write(value: QBusinessClientTypes.ConfigurationEvent?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributeFilter"].write(value.attributeFilter, with: QBusinessClientTypes.AttributeFilter.write(value:to:))
        try writer["chatMode"].write(value.chatMode)
        try writer["chatModeConfiguration"].write(value.chatModeConfiguration, with: QBusinessClientTypes.ChatModeConfiguration.write(value:to:))
    }
}

extension QBusinessClientTypes.AttributeFilter {

    static func write(value: QBusinessClientTypes.AttributeFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["andAllFilters"].writeList(value.andAllFilters, memberWritingClosure: QBusinessClientTypes.AttributeFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["containsAll"].write(value.containsAll, with: QBusinessClientTypes.DocumentAttribute.write(value:to:))
        try writer["containsAny"].write(value.containsAny, with: QBusinessClientTypes.DocumentAttribute.write(value:to:))
        try writer["equalsTo"].write(value.equalsTo, with: QBusinessClientTypes.DocumentAttribute.write(value:to:))
        try writer["greaterThan"].write(value.greaterThan, with: QBusinessClientTypes.DocumentAttribute.write(value:to:))
        try writer["greaterThanOrEquals"].write(value.greaterThanOrEquals, with: QBusinessClientTypes.DocumentAttribute.write(value:to:))
        try writer["lessThan"].write(value.lessThan, with: QBusinessClientTypes.DocumentAttribute.write(value:to:))
        try writer["lessThanOrEquals"].write(value.lessThanOrEquals, with: QBusinessClientTypes.DocumentAttribute.write(value:to:))
        try writer["notFilter"].write(value.notFilter, with: QBusinessClientTypes.AttributeFilter.write(value:to:))
        try writer["orAllFilters"].writeList(value.orAllFilters, memberWritingClosure: QBusinessClientTypes.AttributeFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension QBusinessClientTypes.ChatModeConfiguration {

    static func write(value: QBusinessClientTypes.ChatModeConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .pluginconfiguration(pluginconfiguration):
                try writer["pluginConfiguration"].write(pluginconfiguration, with: QBusinessClientTypes.PluginConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension QBusinessClientTypes.PluginConfiguration {

    static func write(value: QBusinessClientTypes.PluginConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["pluginId"].write(value.pluginId)
    }
}

extension QBusinessClientTypes.AuthChallengeResponse {

    static func write(value: QBusinessClientTypes.AuthChallengeResponse?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["responseMap"].writeMap(value.responseMap, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension QBusinessClientTypes.AttachmentsConfiguration {

    static func write(value: QBusinessClientTypes.AttachmentsConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attachmentsControlMode"].write(value.attachmentsControlMode)
    }
}

extension QBusinessClientTypes.MessageUsefulnessFeedback {

    static func write(value: QBusinessClientTypes.MessageUsefulnessFeedback?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["comment"].write(value.comment)
        try writer["reason"].write(value.reason)
        try writer["submittedAt"].writeTimestamp(value.submittedAt, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["usefulness"].write(value.usefulness)
    }
}

extension QBusinessClientTypes.GroupMembers {

    static func write(value: QBusinessClientTypes.GroupMembers?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["memberGroups"].writeList(value.memberGroups, memberWritingClosure: QBusinessClientTypes.MemberGroup.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["memberUsers"].writeList(value.memberUsers, memberWritingClosure: QBusinessClientTypes.MemberUser.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["s3PathForGroupMembers"].write(value.s3PathForGroupMembers, with: QBusinessClientTypes.S3.write(value:to:))
    }
}

extension QBusinessClientTypes.MemberUser {

    static func write(value: QBusinessClientTypes.MemberUser?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["type"].write(value.type)
        try writer["userId"].write(value.userId)
    }
}

extension QBusinessClientTypes.MemberGroup {

    static func write(value: QBusinessClientTypes.MemberGroup?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["groupName"].write(value.groupName)
        try writer["type"].write(value.type)
    }
}

extension QBusinessClientTypes.BlockedPhrasesConfigurationUpdate {

    static func write(value: QBusinessClientTypes.BlockedPhrasesConfigurationUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["blockedPhrasesToCreateOrUpdate"].writeList(value.blockedPhrasesToCreateOrUpdate, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["blockedPhrasesToDelete"].writeList(value.blockedPhrasesToDelete, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["systemMessageOverride"].write(value.systemMessageOverride)
    }
}

extension QBusinessClientTypes.CreatorModeConfiguration {

    static func write(value: QBusinessClientTypes.CreatorModeConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["creatorModeControl"].write(value.creatorModeControl)
    }
}

public enum QBusinessClientTypes {}
