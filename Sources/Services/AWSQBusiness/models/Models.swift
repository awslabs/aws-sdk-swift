// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension QBusinessClientTypes.AccessConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessControls
        case memberRelation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessControls = accessControls {
            var accessControlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accessControls)
            for accesscontrol0 in accessControls {
                try accessControlsContainer.encode(accesscontrol0)
            }
        }
        if let memberRelation = self.memberRelation {
            try encodeContainer.encode(memberRelation.rawValue, forKey: .memberRelation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessControlsContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.AccessControl?].self, forKey: .accessControls)
        var accessControlsDecoded0:[QBusinessClientTypes.AccessControl]? = nil
        if let accessControlsContainer = accessControlsContainer {
            accessControlsDecoded0 = [QBusinessClientTypes.AccessControl]()
            for structure0 in accessControlsContainer {
                if let structure0 = structure0 {
                    accessControlsDecoded0?.append(structure0)
                }
            }
        }
        accessControls = accessControlsDecoded0
        let memberRelationDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.MemberRelation.self, forKey: .memberRelation)
        memberRelation = memberRelationDecoded
    }
}

extension QBusinessClientTypes {
    /// Used to configure access permissions for a document.
    public struct AccessConfiguration: Swift.Equatable {
        /// A list of AccessControlList objects.
        /// This member is required.
        public var accessControls: [QBusinessClientTypes.AccessControl]?
        /// Describes the member relation within the AccessControlList object.
        public var memberRelation: QBusinessClientTypes.MemberRelation?

        public init(
            accessControls: [QBusinessClientTypes.AccessControl]? = nil,
            memberRelation: QBusinessClientTypes.MemberRelation? = nil
        )
        {
            self.accessControls = accessControls
            self.memberRelation = memberRelation
        }
    }

}

extension QBusinessClientTypes.AccessControl: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberRelation
        case principals
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberRelation = self.memberRelation {
            try encodeContainer.encode(memberRelation.rawValue, forKey: .memberRelation)
        }
        if let principals = principals {
            var principalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principals)
            for principal0 in principals {
                try principalsContainer.encode(principal0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalsContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.Principal?].self, forKey: .principals)
        var principalsDecoded0:[QBusinessClientTypes.Principal]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [QBusinessClientTypes.Principal]()
            for union0 in principalsContainer {
                if let union0 = union0 {
                    principalsDecoded0?.append(union0)
                }
            }
        }
        principals = principalsDecoded0
        let memberRelationDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.MemberRelation.self, forKey: .memberRelation)
        memberRelation = memberRelationDecoded
    }
}

extension QBusinessClientTypes {
    /// A list of principals. Each principal can be either a USER or a GROUP and can be designated document access permissions of either ALLOW or DENY.
    public struct AccessControl: Swift.Equatable {
        /// Describes the member relation within a principal list.
        public var memberRelation: QBusinessClientTypes.MemberRelation?
        /// Contains a list of principals, where a principal can be either a USER or a GROUP. Each principal can be have the following type of document access: ALLOW or DENY.
        /// This member is required.
        public var principals: [QBusinessClientTypes.Principal]?

        public init(
            memberRelation: QBusinessClientTypes.MemberRelation? = nil,
            principals: [QBusinessClientTypes.Principal]? = nil
        )
        {
            self.memberRelation = memberRelation
            self.principals = principals
        }
    }

}

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You don't have access to perform this action. Make sure you have the required permission policies and user accounts and try again.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension QBusinessClientTypes.ActionExecution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload
        case payloadFieldNameSeparator
        case pluginId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let payload = payload {
            var payloadContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .payload)
            for (dictKey0, actionExecutionPayload0) in payload {
                try payloadContainer.encode(actionExecutionPayload0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let payloadFieldNameSeparator = self.payloadFieldNameSeparator {
            try encodeContainer.encode(payloadFieldNameSeparator, forKey: .payloadFieldNameSeparator)
        }
        if let pluginId = self.pluginId {
            try encodeContainer.encode(pluginId, forKey: .pluginId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pluginIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pluginId)
        pluginId = pluginIdDecoded
        let payloadContainer = try containerValues.decodeIfPresent([Swift.String: QBusinessClientTypes.ActionExecutionPayloadField?].self, forKey: .payload)
        var payloadDecoded0: [Swift.String:QBusinessClientTypes.ActionExecutionPayloadField]? = nil
        if let payloadContainer = payloadContainer {
            payloadDecoded0 = [Swift.String:QBusinessClientTypes.ActionExecutionPayloadField]()
            for (key0, actionexecutionpayloadfield0) in payloadContainer {
                if let actionexecutionpayloadfield0 = actionexecutionpayloadfield0 {
                    payloadDecoded0?[key0] = actionexecutionpayloadfield0
                }
            }
        }
        payload = payloadDecoded0
        let payloadFieldNameSeparatorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .payloadFieldNameSeparator)
        payloadFieldNameSeparator = payloadFieldNameSeparatorDecoded
    }
}

extension QBusinessClientTypes {
    /// Performs an Amazon Q plugin action during a non-streaming chat conversation.
    public struct ActionExecution: Swift.Equatable {
        /// A mapping of field names to the field values in input that an end user provides to Amazon Q requests to perform their plugin action.
        /// This member is required.
        public var payload: [Swift.String:QBusinessClientTypes.ActionExecutionPayloadField]?
        /// A string used to retain information about the hierarchical contexts within an action execution event payload.
        /// This member is required.
        public var payloadFieldNameSeparator: Swift.String?
        /// The identifier of the plugin the action is attached to.
        /// This member is required.
        public var pluginId: Swift.String?

        public init(
            payload: [Swift.String:QBusinessClientTypes.ActionExecutionPayloadField]? = nil,
            payloadFieldNameSeparator: Swift.String? = nil,
            pluginId: Swift.String? = nil
        )
        {
            self.payload = payload
            self.payloadFieldNameSeparator = payloadFieldNameSeparator
            self.pluginId = pluginId
        }
    }

}

extension QBusinessClientTypes.ActionExecutionPayloadField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .value)
        value = valueDecoded
    }
}

extension QBusinessClientTypes {
    /// A user input field in an plugin action execution payload.
    public struct ActionExecutionPayloadField: Swift.Equatable {
        /// The content of a user input field in an plugin action execution payload.
        /// This member is required.
        public var value: ClientRuntime.Document?

        public init(
            value: ClientRuntime.Document? = nil
        )
        {
            self.value = value
        }
    }

}

extension QBusinessClientTypes {
    public enum ActionPayloadFieldType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case array
        case boolean
        case number
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionPayloadFieldType] {
            return [
                .array,
                .boolean,
                .number,
                .string,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .array: return "ARRAY"
            case .boolean: return "BOOLEAN"
            case .number: return "NUMBER"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActionPayloadFieldType(rawValue: rawValue) ?? ActionPayloadFieldType.sdkUnknown(rawValue)
        }
    }
}

extension QBusinessClientTypes.ActionReview: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload
        case payloadFieldNameSeparator
        case pluginId
        case pluginType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let payload = payload {
            var payloadContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .payload)
            for (dictKey0, actionReviewPayload0) in payload {
                try payloadContainer.encode(actionReviewPayload0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let payloadFieldNameSeparator = self.payloadFieldNameSeparator {
            try encodeContainer.encode(payloadFieldNameSeparator, forKey: .payloadFieldNameSeparator)
        }
        if let pluginId = self.pluginId {
            try encodeContainer.encode(pluginId, forKey: .pluginId)
        }
        if let pluginType = self.pluginType {
            try encodeContainer.encode(pluginType.rawValue, forKey: .pluginType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pluginIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pluginId)
        pluginId = pluginIdDecoded
        let pluginTypeDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.PluginType.self, forKey: .pluginType)
        pluginType = pluginTypeDecoded
        let payloadContainer = try containerValues.decodeIfPresent([Swift.String: QBusinessClientTypes.ActionReviewPayloadField?].self, forKey: .payload)
        var payloadDecoded0: [Swift.String:QBusinessClientTypes.ActionReviewPayloadField]? = nil
        if let payloadContainer = payloadContainer {
            payloadDecoded0 = [Swift.String:QBusinessClientTypes.ActionReviewPayloadField]()
            for (key0, actionreviewpayloadfield0) in payloadContainer {
                if let actionreviewpayloadfield0 = actionreviewpayloadfield0 {
                    payloadDecoded0?[key0] = actionreviewpayloadfield0
                }
            }
        }
        payload = payloadDecoded0
        let payloadFieldNameSeparatorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .payloadFieldNameSeparator)
        payloadFieldNameSeparator = payloadFieldNameSeparatorDecoded
    }
}

extension QBusinessClientTypes {
    /// An output event that Amazon Q returns to an user who wants to perform a plugin action during a non-streaming chat conversation. It contains information about the selected action with a list of possible user input fields, some pre-populated by Amazon Q.
    public struct ActionReview: Swift.Equatable {
        /// Field values that an end user needs to provide to Amazon Q for Amazon Q to perform the requested plugin action.
        public var payload: [Swift.String:QBusinessClientTypes.ActionReviewPayloadField]?
        /// A string used to retain information about the hierarchical contexts within an action review payload.
        public var payloadFieldNameSeparator: Swift.String?
        /// The identifier of the plugin associated with the action review.
        public var pluginId: Swift.String?
        /// The type of plugin.
        public var pluginType: QBusinessClientTypes.PluginType?

        public init(
            payload: [Swift.String:QBusinessClientTypes.ActionReviewPayloadField]? = nil,
            payloadFieldNameSeparator: Swift.String? = nil,
            pluginId: Swift.String? = nil,
            pluginType: QBusinessClientTypes.PluginType? = nil
        )
        {
            self.payload = payload
            self.payloadFieldNameSeparator = payloadFieldNameSeparator
            self.pluginId = pluginId
            self.pluginType = pluginType
        }
    }

}

extension QBusinessClientTypes.ActionReviewPayloadField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedValues
        case displayName
        case displayOrder
        case `required` = "required"
        case type
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedValues = allowedValues {
            var allowedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedValues)
            for actionreviewpayloadfieldallowedvalue0 in allowedValues {
                try allowedValuesContainer.encode(actionreviewpayloadfieldallowedvalue0)
            }
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let displayOrder = self.displayOrder {
            try encodeContainer.encode(displayOrder, forKey: .displayOrder)
        }
        if let `required` = self.`required` {
            try encodeContainer.encode(`required`, forKey: .`required`)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let displayOrderDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .displayOrder)
        displayOrder = displayOrderDecoded
        let typeDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.ActionPayloadFieldType.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .value)
        value = valueDecoded
        let allowedValuesContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.ActionReviewPayloadFieldAllowedValue?].self, forKey: .allowedValues)
        var allowedValuesDecoded0:[QBusinessClientTypes.ActionReviewPayloadFieldAllowedValue]? = nil
        if let allowedValuesContainer = allowedValuesContainer {
            allowedValuesDecoded0 = [QBusinessClientTypes.ActionReviewPayloadFieldAllowedValue]()
            for structure0 in allowedValuesContainer {
                if let structure0 = structure0 {
                    allowedValuesDecoded0?.append(structure0)
                }
            }
        }
        allowedValues = allowedValuesDecoded0
        let requiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .required)
        `required` = requiredDecoded
    }
}

extension QBusinessClientTypes {
    /// A user input field in an plugin action review payload.
    public struct ActionReviewPayloadField: Swift.Equatable {
        /// Information about the field values that an end user can use to provide to Amazon Q for Amazon Q to perform the requested plugin action.
        public var allowedValues: [QBusinessClientTypes.ActionReviewPayloadFieldAllowedValue]?
        /// The name of the field.
        public var displayName: Swift.String?
        /// The display order of fields in a payload.
        public var displayOrder: Swift.Int?
        /// Information about whether the field is required.
        public var `required`: Swift.Bool?
        /// The type of field.
        public var type: QBusinessClientTypes.ActionPayloadFieldType?
        /// The field value.
        public var value: ClientRuntime.Document?

        public init(
            allowedValues: [QBusinessClientTypes.ActionReviewPayloadFieldAllowedValue]? = nil,
            displayName: Swift.String? = nil,
            displayOrder: Swift.Int? = nil,
            `required`: Swift.Bool? = nil,
            type: QBusinessClientTypes.ActionPayloadFieldType? = nil,
            value: ClientRuntime.Document? = nil
        )
        {
            self.allowedValues = allowedValues
            self.displayName = displayName
            self.displayOrder = displayOrder
            self.`required` = `required`
            self.type = type
            self.value = value
        }
    }

}

extension QBusinessClientTypes.ActionReviewPayloadFieldAllowedValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayValue
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayValue = self.displayValue {
            try encodeContainer.encode(displayValue, forKey: .displayValue)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .value)
        value = valueDecoded
        let displayValueDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .displayValue)
        displayValue = displayValueDecoded
    }
}

extension QBusinessClientTypes {
    /// Information about the field values that an end user can use to provide to Amazon Q for Amazon Q to perform the requested plugin action.
    public struct ActionReviewPayloadFieldAllowedValue: Swift.Equatable {
        /// The name of the field.
        public var displayValue: ClientRuntime.Document?
        /// The field value.
        public var value: ClientRuntime.Document?

        public init(
            displayValue: ClientRuntime.Document? = nil,
            value: ClientRuntime.Document? = nil
        )
        {
            self.displayValue = displayValue
            self.value = value
        }
    }

}

extension QBusinessClientTypes.Application: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId
        case createdAt
        case displayName
        case status
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.ApplicationStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension QBusinessClientTypes {
    /// Summary information for an Amazon Q application.
    public struct Application: Swift.Equatable {
        /// The identifier for the Amazon Q application.
        public var applicationId: Swift.String?
        /// The Unix timestamp when the Amazon Q application was created.
        public var createdAt: ClientRuntime.Date?
        /// The name of the Amazon Q application.
        public var displayName: Swift.String?
        /// The status of the Amazon Q application. The application is ready to use when the status is ACTIVE.
        public var status: QBusinessClientTypes.ApplicationStatus?
        /// The Unix timestamp when the Amazon Q application was last updated.
        public var updatedAt: ClientRuntime.Date?

        public init(
            applicationId: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            displayName: Swift.String? = nil,
            status: QBusinessClientTypes.ApplicationStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.applicationId = applicationId
            self.createdAt = createdAt
            self.displayName = displayName
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension QBusinessClientTypes {
    public enum ApplicationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationStatus(rawValue: rawValue) ?? ApplicationStatus.sdkUnknown(rawValue)
        }
    }
}

extension QBusinessClientTypes.AppliedAttachmentsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentsControlMode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentsControlMode = self.attachmentsControlMode {
            try encodeContainer.encode(attachmentsControlMode.rawValue, forKey: .attachmentsControlMode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentsControlModeDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.AttachmentsControlMode.self, forKey: .attachmentsControlMode)
        attachmentsControlMode = attachmentsControlModeDecoded
    }
}

extension QBusinessClientTypes {
    /// Configuration information about the file upload during chat feature for your application.
    public struct AppliedAttachmentsConfiguration: Swift.Equatable {
        /// Information about whether file upload during chat functionality is activated for your application.
        public var attachmentsControlMode: QBusinessClientTypes.AttachmentsControlMode?

        public init(
            attachmentsControlMode: QBusinessClientTypes.AttachmentsControlMode? = nil
        )
        {
            self.attachmentsControlMode = attachmentsControlMode
        }
    }

}

extension QBusinessClientTypes.AttachmentInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case data
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = self.data {
            try encodeContainer.encode(data.base64EncodedString(), forKey: .data)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let dataDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .data)
        data = dataDecoded
    }
}

extension QBusinessClientTypes {
    /// A file directly uploaded into a web experience chat.
    public struct AttachmentInput: Swift.Equatable {
        /// The data contained within the uploaded file.
        /// This member is required.
        public var data: ClientRuntime.Data?
        /// The name of the file.
        /// This member is required.
        public var name: Swift.String?

        public init(
            data: ClientRuntime.Data? = nil,
            name: Swift.String? = nil
        )
        {
            self.data = data
            self.name = name
        }
    }

}

extension QBusinessClientTypes.AttachmentOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.AttachmentStatus.self, forKey: .status)
        status = statusDecoded
        let errorDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.ErrorDetail.self, forKey: .error)
        error = errorDecoded
    }
}

extension QBusinessClientTypes {
    /// The details of a file uploaded during chat.
    public struct AttachmentOutput: Swift.Equatable {
        /// An error associated with a file uploaded during chat.
        public var error: QBusinessClientTypes.ErrorDetail?
        /// The name of a file uploaded during chat.
        public var name: Swift.String?
        /// The status of a file uploaded during chat.
        public var status: QBusinessClientTypes.AttachmentStatus?

        public init(
            error: QBusinessClientTypes.ErrorDetail? = nil,
            name: Swift.String? = nil,
            status: QBusinessClientTypes.AttachmentStatus? = nil
        )
        {
            self.error = error
            self.name = name
            self.status = status
        }
    }

}

extension QBusinessClientTypes {
    public enum AttachmentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [AttachmentStatus] {
            return [
                .failed,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AttachmentStatus(rawValue: rawValue) ?? AttachmentStatus.sdkUnknown(rawValue)
        }
    }
}

extension QBusinessClientTypes.AttachmentsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentsControlMode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentsControlMode = self.attachmentsControlMode {
            try encodeContainer.encode(attachmentsControlMode.rawValue, forKey: .attachmentsControlMode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentsControlModeDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.AttachmentsControlMode.self, forKey: .attachmentsControlMode)
        attachmentsControlMode = attachmentsControlModeDecoded
    }
}

extension QBusinessClientTypes {
    /// Configuration information for the file upload during chat feature.
    public struct AttachmentsConfiguration: Swift.Equatable {
        /// Status information about whether file upload functionality is activated or deactivated for your end user.
        /// This member is required.
        public var attachmentsControlMode: QBusinessClientTypes.AttachmentsControlMode?

        public init(
            attachmentsControlMode: QBusinessClientTypes.AttachmentsControlMode? = nil
        )
        {
            self.attachmentsControlMode = attachmentsControlMode
        }
    }

}

extension QBusinessClientTypes {
    public enum AttachmentsControlMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AttachmentsControlMode] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AttachmentsControlMode(rawValue: rawValue) ?? AttachmentsControlMode.sdkUnknown(rawValue)
        }
    }
}

extension QBusinessClientTypes.AttributeFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case andAllFilters
        case containsAll
        case containsAny
        case equalsTo
        case greaterThan
        case greaterThanOrEquals
        case lessThan
        case lessThanOrEquals
        case notFilter
        case orAllFilters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let andAllFilters = andAllFilters {
            var andAllFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .andAllFilters)
            for attributefilter0 in andAllFilters {
                try andAllFiltersContainer.encode(attributefilter0)
            }
        }
        if let containsAll = self.containsAll {
            try encodeContainer.encode(containsAll, forKey: .containsAll)
        }
        if let containsAny = self.containsAny {
            try encodeContainer.encode(containsAny, forKey: .containsAny)
        }
        if let equalsTo = self.equalsTo {
            try encodeContainer.encode(equalsTo, forKey: .equalsTo)
        }
        if let greaterThan = self.greaterThan {
            try encodeContainer.encode(greaterThan, forKey: .greaterThan)
        }
        if let greaterThanOrEquals = self.greaterThanOrEquals {
            try encodeContainer.encode(greaterThanOrEquals, forKey: .greaterThanOrEquals)
        }
        if let lessThan = self.lessThan {
            try encodeContainer.encode(lessThan, forKey: .lessThan)
        }
        if let lessThanOrEquals = self.lessThanOrEquals {
            try encodeContainer.encode(lessThanOrEquals, forKey: .lessThanOrEquals)
        }
        if let notFilter = self.notFilter {
            try encodeContainer.encode(notFilter, forKey: .notFilter)
        }
        if let orAllFilters = orAllFilters {
            var orAllFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .orAllFilters)
            for attributefilter0 in orAllFilters {
                try orAllFiltersContainer.encode(attributefilter0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let andAllFiltersContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.AttributeFilter?].self, forKey: .andAllFilters)
        var andAllFiltersDecoded0:[QBusinessClientTypes.AttributeFilter]? = nil
        if let andAllFiltersContainer = andAllFiltersContainer {
            andAllFiltersDecoded0 = [QBusinessClientTypes.AttributeFilter]()
            for structure0 in andAllFiltersContainer {
                if let structure0 = structure0 {
                    andAllFiltersDecoded0?.append(structure0)
                }
            }
        }
        andAllFilters = andAllFiltersDecoded0
        let orAllFiltersContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.AttributeFilter?].self, forKey: .orAllFilters)
        var orAllFiltersDecoded0:[QBusinessClientTypes.AttributeFilter]? = nil
        if let orAllFiltersContainer = orAllFiltersContainer {
            orAllFiltersDecoded0 = [QBusinessClientTypes.AttributeFilter]()
            for structure0 in orAllFiltersContainer {
                if let structure0 = structure0 {
                    orAllFiltersDecoded0?.append(structure0)
                }
            }
        }
        orAllFilters = orAllFiltersDecoded0
        let notFilterDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.AttributeFilter.self, forKey: .notFilter)
        notFilter = notFilterDecoded
        let equalsToDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.DocumentAttribute.self, forKey: .equalsTo)
        equalsTo = equalsToDecoded
        let containsAllDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.DocumentAttribute.self, forKey: .containsAll)
        containsAll = containsAllDecoded
        let containsAnyDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.DocumentAttribute.self, forKey: .containsAny)
        containsAny = containsAnyDecoded
        let greaterThanDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.DocumentAttribute.self, forKey: .greaterThan)
        greaterThan = greaterThanDecoded
        let greaterThanOrEqualsDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.DocumentAttribute.self, forKey: .greaterThanOrEquals)
        greaterThanOrEquals = greaterThanOrEqualsDecoded
        let lessThanDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.DocumentAttribute.self, forKey: .lessThan)
        lessThan = lessThanDecoded
        let lessThanOrEqualsDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.DocumentAttribute.self, forKey: .lessThanOrEquals)
        lessThanOrEquals = lessThanOrEqualsDecoded
    }
}

extension QBusinessClientTypes {
    /// Enables filtering of Amazon Q web experience responses based on document attributes or metadata fields.
    public struct AttributeFilter: Swift.Equatable {
        /// Performs a logical AND operation on all supplied filters.
        public var andAllFilters: [QBusinessClientTypes.AttributeFilter]?
        /// Returns true when a document contains all the specified document attributes or metadata fields.
        public var containsAll: QBusinessClientTypes.DocumentAttribute?
        /// Returns true when a document contains any of the specified document attributes or metadata fields.
        public var containsAny: QBusinessClientTypes.DocumentAttribute?
        /// Performs an equals operation on two document attributes or metadata fields.
        public var equalsTo: QBusinessClientTypes.DocumentAttribute?
        /// Performs a greater than operation on two document attributes or metadata fields. Use with a document attribute of type Date or Long.
        public var greaterThan: QBusinessClientTypes.DocumentAttribute?
        /// Performs a greater or equals than operation on two document attributes or metadata fields. Use with a document attribute of type Date or Long.
        public var greaterThanOrEquals: QBusinessClientTypes.DocumentAttribute?
        /// Performs a less than operation on two document attributes or metadata fields. Use with a document attribute of type Date or Long.
        public var lessThan: QBusinessClientTypes.DocumentAttribute?
        /// Performs a less than or equals operation on two document attributes or metadata fields. Use with a document attribute of type Date or Long.
        public var lessThanOrEquals: QBusinessClientTypes.DocumentAttribute?
        /// Performs a logical NOT operation on all supplied filters.
        @Indirect public var notFilter: QBusinessClientTypes.AttributeFilter?
        /// Performs a logical OR operation on all supplied filters.
        public var orAllFilters: [QBusinessClientTypes.AttributeFilter]?

        public init(
            andAllFilters: [QBusinessClientTypes.AttributeFilter]? = nil,
            containsAll: QBusinessClientTypes.DocumentAttribute? = nil,
            containsAny: QBusinessClientTypes.DocumentAttribute? = nil,
            equalsTo: QBusinessClientTypes.DocumentAttribute? = nil,
            greaterThan: QBusinessClientTypes.DocumentAttribute? = nil,
            greaterThanOrEquals: QBusinessClientTypes.DocumentAttribute? = nil,
            lessThan: QBusinessClientTypes.DocumentAttribute? = nil,
            lessThanOrEquals: QBusinessClientTypes.DocumentAttribute? = nil,
            notFilter: QBusinessClientTypes.AttributeFilter? = nil,
            orAllFilters: [QBusinessClientTypes.AttributeFilter]? = nil
        )
        {
            self.andAllFilters = andAllFilters
            self.containsAll = containsAll
            self.containsAny = containsAny
            self.equalsTo = equalsTo
            self.greaterThan = greaterThan
            self.greaterThanOrEquals = greaterThanOrEquals
            self.lessThan = lessThan
            self.lessThanOrEquals = lessThanOrEquals
            self.notFilter = notFilter
            self.orAllFilters = orAllFilters
        }
    }

}

extension QBusinessClientTypes {
    public enum AttributeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case date
        case number
        case string
        case stringList
        case sdkUnknown(Swift.String)

        public static var allCases: [AttributeType] {
            return [
                .date,
                .number,
                .string,
                .stringList,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .date: return "DATE"
            case .number: return "NUMBER"
            case .string: return "STRING"
            case .stringList: return "STRING_LIST"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AttributeType(rawValue: rawValue) ?? AttributeType.sdkUnknown(rawValue)
        }
    }
}

extension QBusinessClientTypes {
    public enum AttributeValueOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case delete
        case sdkUnknown(Swift.String)

        public static var allCases: [AttributeValueOperator] {
            return [
                .delete,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .delete: return "DELETE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AttributeValueOperator(rawValue: rawValue) ?? AttributeValueOperator.sdkUnknown(rawValue)
        }
    }
}

extension QBusinessClientTypes.BasicAuthConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn
        case secretArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let secretArn = self.secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension QBusinessClientTypes {
    /// Information about the basic authentication credentials used to configure a plugin.
    public struct BasicAuthConfiguration: Swift.Equatable {
        /// The ARN of an IAM role used by Amazon Q to access the basic authentication credentials stored in a Secrets Manager secret.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The ARN of the Secrets Manager secret that stores the basic authentication credentials used for plugin configuration..
        /// This member is required.
        public var secretArn: Swift.String?

        public init(
            roleArn: Swift.String? = nil,
            secretArn: Swift.String? = nil
        )
        {
            self.roleArn = roleArn
            self.secretArn = secretArn
        }
    }

}

extension BatchDeleteDocumentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceSyncId
        case documents
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceSyncId = self.dataSourceSyncId {
            try encodeContainer.encode(dataSourceSyncId, forKey: .dataSourceSyncId)
        }
        if let documents = documents {
            var documentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .documents)
            for deletedocument0 in documents {
                try documentsContainer.encode(deletedocument0)
            }
        }
    }
}

extension BatchDeleteDocumentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let indexId = indexId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/indices/\(indexId.urlPercentEncoding())/documents/delete"
    }
}

public struct BatchDeleteDocumentInput: Swift.Equatable {
    /// The identifier of the Amazon Q application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the data source sync during which the documents were deleted.
    public var dataSourceSyncId: Swift.String?
    /// Documents deleted from the Amazon Q index.
    /// This member is required.
    public var documents: [QBusinessClientTypes.DeleteDocument]?
    /// The identifier of the Amazon Q index that contains the documents to delete.
    /// This member is required.
    public var indexId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        dataSourceSyncId: Swift.String? = nil,
        documents: [QBusinessClientTypes.DeleteDocument]? = nil,
        indexId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.dataSourceSyncId = dataSourceSyncId
        self.documents = documents
        self.indexId = indexId
    }
}

struct BatchDeleteDocumentInputBody: Swift.Equatable {
    let documents: [QBusinessClientTypes.DeleteDocument]?
    let dataSourceSyncId: Swift.String?
}

extension BatchDeleteDocumentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceSyncId
        case documents
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentsContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.DeleteDocument?].self, forKey: .documents)
        var documentsDecoded0:[QBusinessClientTypes.DeleteDocument]? = nil
        if let documentsContainer = documentsContainer {
            documentsDecoded0 = [QBusinessClientTypes.DeleteDocument]()
            for structure0 in documentsContainer {
                if let structure0 = structure0 {
                    documentsDecoded0?.append(structure0)
                }
            }
        }
        documents = documentsDecoded0
        let dataSourceSyncIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceSyncId)
        dataSourceSyncId = dataSourceSyncIdDecoded
    }
}

extension BatchDeleteDocumentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchDeleteDocumentOutputBody = try responseDecoder.decode(responseBody: data)
            self.failedDocuments = output.failedDocuments
        } else {
            self.failedDocuments = nil
        }
    }
}

public struct BatchDeleteDocumentOutput: Swift.Equatable {
    /// A list of documents that couldn't be removed from the Amazon Q index. Each entry contains an error message that indicates why the document couldn't be removed from the index.
    public var failedDocuments: [QBusinessClientTypes.FailedDocument]?

    public init(
        failedDocuments: [QBusinessClientTypes.FailedDocument]? = nil
    )
    {
        self.failedDocuments = failedDocuments
    }
}

struct BatchDeleteDocumentOutputBody: Swift.Equatable {
    let failedDocuments: [QBusinessClientTypes.FailedDocument]?
}

extension BatchDeleteDocumentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedDocuments
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedDocumentsContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.FailedDocument?].self, forKey: .failedDocuments)
        var failedDocumentsDecoded0:[QBusinessClientTypes.FailedDocument]? = nil
        if let failedDocumentsContainer = failedDocumentsContainer {
            failedDocumentsDecoded0 = [QBusinessClientTypes.FailedDocument]()
            for structure0 in failedDocumentsContainer {
                if let structure0 = structure0 {
                    failedDocumentsDecoded0?.append(structure0)
                }
            }
        }
        failedDocuments = failedDocumentsDecoded0
    }
}

enum BatchDeleteDocumentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchPutDocumentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceSyncId
        case documents
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceSyncId = self.dataSourceSyncId {
            try encodeContainer.encode(dataSourceSyncId, forKey: .dataSourceSyncId)
        }
        if let documents = documents {
            var documentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .documents)
            for document0 in documents {
                try documentsContainer.encode(document0)
            }
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

extension BatchPutDocumentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let indexId = indexId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/indices/\(indexId.urlPercentEncoding())/documents"
    }
}

public struct BatchPutDocumentInput: Swift.Equatable {
    /// The identifier of the Amazon Q application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the data source sync during which the documents were added.
    public var dataSourceSyncId: Swift.String?
    /// One or more documents to add to the index.
    /// This member is required.
    public var documents: [QBusinessClientTypes.Document]?
    /// The identifier of the Amazon Q index to add the documents to.
    /// This member is required.
    public var indexId: Swift.String?
    /// The Amazon Resource Name (ARN) of an IAM role with permission to access your S3 bucket.
    public var roleArn: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        dataSourceSyncId: Swift.String? = nil,
        documents: [QBusinessClientTypes.Document]? = nil,
        indexId: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.dataSourceSyncId = dataSourceSyncId
        self.documents = documents
        self.indexId = indexId
        self.roleArn = roleArn
    }
}

struct BatchPutDocumentInputBody: Swift.Equatable {
    let documents: [QBusinessClientTypes.Document]?
    let roleArn: Swift.String?
    let dataSourceSyncId: Swift.String?
}

extension BatchPutDocumentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceSyncId
        case documents
        case roleArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentsContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.Document?].self, forKey: .documents)
        var documentsDecoded0:[QBusinessClientTypes.Document]? = nil
        if let documentsContainer = documentsContainer {
            documentsDecoded0 = [QBusinessClientTypes.Document]()
            for structure0 in documentsContainer {
                if let structure0 = structure0 {
                    documentsDecoded0?.append(structure0)
                }
            }
        }
        documents = documentsDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let dataSourceSyncIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceSyncId)
        dataSourceSyncId = dataSourceSyncIdDecoded
    }
}

extension BatchPutDocumentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchPutDocumentOutputBody = try responseDecoder.decode(responseBody: data)
            self.failedDocuments = output.failedDocuments
        } else {
            self.failedDocuments = nil
        }
    }
}

public struct BatchPutDocumentOutput: Swift.Equatable {
    /// A list of documents that were not added to the Amazon Q index because the document failed a validation check. Each document contains an error message that indicates why the document couldn't be added to the index.
    public var failedDocuments: [QBusinessClientTypes.FailedDocument]?

    public init(
        failedDocuments: [QBusinessClientTypes.FailedDocument]? = nil
    )
    {
        self.failedDocuments = failedDocuments
    }
}

struct BatchPutDocumentOutputBody: Swift.Equatable {
    let failedDocuments: [QBusinessClientTypes.FailedDocument]?
}

extension BatchPutDocumentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedDocuments
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedDocumentsContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.FailedDocument?].self, forKey: .failedDocuments)
        var failedDocumentsDecoded0:[QBusinessClientTypes.FailedDocument]? = nil
        if let failedDocumentsContainer = failedDocumentsContainer {
            failedDocumentsDecoded0 = [QBusinessClientTypes.FailedDocument]()
            for structure0 in failedDocumentsContainer {
                if let structure0 = structure0 {
                    failedDocumentsDecoded0?.append(structure0)
                }
            }
        }
        failedDocuments = failedDocumentsDecoded0
    }
}

enum BatchPutDocumentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension QBusinessClientTypes.BlockedPhrasesConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockedPhrases
        case systemMessageOverride
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blockedPhrases = blockedPhrases {
            var blockedPhrasesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .blockedPhrases)
            for blockedphrase0 in blockedPhrases {
                try blockedPhrasesContainer.encode(blockedphrase0)
            }
        }
        if let systemMessageOverride = self.systemMessageOverride {
            try encodeContainer.encode(systemMessageOverride, forKey: .systemMessageOverride)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockedPhrasesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .blockedPhrases)
        var blockedPhrasesDecoded0:[Swift.String]? = nil
        if let blockedPhrasesContainer = blockedPhrasesContainer {
            blockedPhrasesDecoded0 = [Swift.String]()
            for string0 in blockedPhrasesContainer {
                if let string0 = string0 {
                    blockedPhrasesDecoded0?.append(string0)
                }
            }
        }
        blockedPhrases = blockedPhrasesDecoded0
        let systemMessageOverrideDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .systemMessageOverride)
        systemMessageOverride = systemMessageOverrideDecoded
    }
}

extension QBusinessClientTypes {
    /// Provides information about the phrases blocked from chat by your chat control configuration.
    public struct BlockedPhrasesConfiguration: Swift.Equatable {
        /// A list of phrases blocked from a Amazon Q web experience chat.
        public var blockedPhrases: [Swift.String]?
        /// The configured custom message displayed to an end user informing them that they've used a blocked phrase during chat.
        public var systemMessageOverride: Swift.String?

        public init(
            blockedPhrases: [Swift.String]? = nil,
            systemMessageOverride: Swift.String? = nil
        )
        {
            self.blockedPhrases = blockedPhrases
            self.systemMessageOverride = systemMessageOverride
        }
    }

}

extension QBusinessClientTypes.BlockedPhrasesConfigurationUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockedPhrasesToCreateOrUpdate
        case blockedPhrasesToDelete
        case systemMessageOverride
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blockedPhrasesToCreateOrUpdate = blockedPhrasesToCreateOrUpdate {
            var blockedPhrasesToCreateOrUpdateContainer = encodeContainer.nestedUnkeyedContainer(forKey: .blockedPhrasesToCreateOrUpdate)
            for blockedphrase0 in blockedPhrasesToCreateOrUpdate {
                try blockedPhrasesToCreateOrUpdateContainer.encode(blockedphrase0)
            }
        }
        if let blockedPhrasesToDelete = blockedPhrasesToDelete {
            var blockedPhrasesToDeleteContainer = encodeContainer.nestedUnkeyedContainer(forKey: .blockedPhrasesToDelete)
            for blockedphrase0 in blockedPhrasesToDelete {
                try blockedPhrasesToDeleteContainer.encode(blockedphrase0)
            }
        }
        if let systemMessageOverride = self.systemMessageOverride {
            try encodeContainer.encode(systemMessageOverride, forKey: .systemMessageOverride)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockedPhrasesToCreateOrUpdateContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .blockedPhrasesToCreateOrUpdate)
        var blockedPhrasesToCreateOrUpdateDecoded0:[Swift.String]? = nil
        if let blockedPhrasesToCreateOrUpdateContainer = blockedPhrasesToCreateOrUpdateContainer {
            blockedPhrasesToCreateOrUpdateDecoded0 = [Swift.String]()
            for string0 in blockedPhrasesToCreateOrUpdateContainer {
                if let string0 = string0 {
                    blockedPhrasesToCreateOrUpdateDecoded0?.append(string0)
                }
            }
        }
        blockedPhrasesToCreateOrUpdate = blockedPhrasesToCreateOrUpdateDecoded0
        let blockedPhrasesToDeleteContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .blockedPhrasesToDelete)
        var blockedPhrasesToDeleteDecoded0:[Swift.String]? = nil
        if let blockedPhrasesToDeleteContainer = blockedPhrasesToDeleteContainer {
            blockedPhrasesToDeleteDecoded0 = [Swift.String]()
            for string0 in blockedPhrasesToDeleteContainer {
                if let string0 = string0 {
                    blockedPhrasesToDeleteDecoded0?.append(string0)
                }
            }
        }
        blockedPhrasesToDelete = blockedPhrasesToDeleteDecoded0
        let systemMessageOverrideDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .systemMessageOverride)
        systemMessageOverride = systemMessageOverrideDecoded
    }
}

extension QBusinessClientTypes {
    /// Updates a blocked phrases configuration in your Amazon Q application.
    public struct BlockedPhrasesConfigurationUpdate: Swift.Equatable {
        /// Creates or updates a blocked phrases configuration in your Amazon Q application.
        public var blockedPhrasesToCreateOrUpdate: [Swift.String]?
        /// Deletes a blocked phrases configuration in your Amazon Q application.
        public var blockedPhrasesToDelete: [Swift.String]?
        /// The configured custom message displayed to your end user when they use blocked phrase during chat.
        public var systemMessageOverride: Swift.String?

        public init(
            blockedPhrasesToCreateOrUpdate: [Swift.String]? = nil,
            blockedPhrasesToDelete: [Swift.String]? = nil,
            systemMessageOverride: Swift.String? = nil
        )
        {
            self.blockedPhrasesToCreateOrUpdate = blockedPhrasesToCreateOrUpdate
            self.blockedPhrasesToDelete = blockedPhrasesToDelete
            self.systemMessageOverride = systemMessageOverride
        }
    }

}

extension ChatSyncInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionExecution
        case attachments
        case attributeFilter
        case clientToken
        case conversationId
        case parentMessageId
        case userMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionExecution = self.actionExecution {
            try encodeContainer.encode(actionExecution, forKey: .actionExecution)
        }
        if let attachments = attachments {
            var attachmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachments)
            for attachmentinput0 in attachments {
                try attachmentsContainer.encode(attachmentinput0)
            }
        }
        if let attributeFilter = self.attributeFilter {
            try encodeContainer.encode(attributeFilter, forKey: .attributeFilter)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let conversationId = self.conversationId {
            try encodeContainer.encode(conversationId, forKey: .conversationId)
        }
        if let parentMessageId = self.parentMessageId {
            try encodeContainer.encode(parentMessageId, forKey: .parentMessageId)
        }
        if let userMessage = self.userMessage {
            try encodeContainer.encode(userMessage, forKey: .userMessage)
        }
    }
}

extension ChatSyncInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "sync", value: nil))
            if let userGroups = userGroups {
                userGroups.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "userGroups".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            guard let userId = userId else {
                let message = "Creating a URL Query Item failed. userId is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let userIdQueryItem = ClientRuntime.URLQueryItem(name: "userId".urlPercentEncoding(), value: Swift.String(userId).urlPercentEncoding())
            items.append(userIdQueryItem)
            return items
        }
    }
}

extension ChatSyncInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/conversations"
    }
}

public struct ChatSyncInput: Swift.Equatable {
    /// A request from an end user to perform an Amazon Q plugin action.
    public var actionExecution: QBusinessClientTypes.ActionExecution?
    /// The identifier of the Amazon Q application linked to the Amazon Q conversation.
    /// This member is required.
    public var applicationId: Swift.String?
    /// A list of files uploaded directly during chat. You can upload a maximum of 5 files of upto 10 MB each.
    public var attachments: [QBusinessClientTypes.AttachmentInput]?
    /// Enables filtering of Amazon Q web experience responses based on document attributes or metadata fields.
    public var attributeFilter: QBusinessClientTypes.AttributeFilter?
    /// A token that you provide to identify a chat request.
    public var clientToken: Swift.String?
    /// The identifier of the Amazon Q conversation.
    public var conversationId: Swift.String?
    /// The identifier of the previous end user text input message in a conversation.
    public var parentMessageId: Swift.String?
    /// The groups that a user associated with the chat input belongs to.
    public var userGroups: [Swift.String]?
    /// The identifier of the user attached to the chat input.
    /// This member is required.
    public var userId: Swift.String?
    /// A end user message in a conversation.
    public var userMessage: Swift.String?

    public init(
        actionExecution: QBusinessClientTypes.ActionExecution? = nil,
        applicationId: Swift.String? = nil,
        attachments: [QBusinessClientTypes.AttachmentInput]? = nil,
        attributeFilter: QBusinessClientTypes.AttributeFilter? = nil,
        clientToken: Swift.String? = nil,
        conversationId: Swift.String? = nil,
        parentMessageId: Swift.String? = nil,
        userGroups: [Swift.String]? = nil,
        userId: Swift.String? = nil,
        userMessage: Swift.String? = nil
    )
    {
        self.actionExecution = actionExecution
        self.applicationId = applicationId
        self.attachments = attachments
        self.attributeFilter = attributeFilter
        self.clientToken = clientToken
        self.conversationId = conversationId
        self.parentMessageId = parentMessageId
        self.userGroups = userGroups
        self.userId = userId
        self.userMessage = userMessage
    }
}

struct ChatSyncInputBody: Swift.Equatable {
    let userMessage: Swift.String?
    let attachments: [QBusinessClientTypes.AttachmentInput]?
    let actionExecution: QBusinessClientTypes.ActionExecution?
    let conversationId: Swift.String?
    let parentMessageId: Swift.String?
    let attributeFilter: QBusinessClientTypes.AttributeFilter?
    let clientToken: Swift.String?
}

extension ChatSyncInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionExecution
        case attachments
        case attributeFilter
        case clientToken
        case conversationId
        case parentMessageId
        case userMessage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userMessage)
        userMessage = userMessageDecoded
        let attachmentsContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.AttachmentInput?].self, forKey: .attachments)
        var attachmentsDecoded0:[QBusinessClientTypes.AttachmentInput]? = nil
        if let attachmentsContainer = attachmentsContainer {
            attachmentsDecoded0 = [QBusinessClientTypes.AttachmentInput]()
            for structure0 in attachmentsContainer {
                if let structure0 = structure0 {
                    attachmentsDecoded0?.append(structure0)
                }
            }
        }
        attachments = attachmentsDecoded0
        let actionExecutionDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.ActionExecution.self, forKey: .actionExecution)
        actionExecution = actionExecutionDecoded
        let conversationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conversationId)
        conversationId = conversationIdDecoded
        let parentMessageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentMessageId)
        parentMessageId = parentMessageIdDecoded
        let attributeFilterDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.AttributeFilter.self, forKey: .attributeFilter)
        attributeFilter = attributeFilterDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension ChatSyncOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ChatSyncOutputBody = try responseDecoder.decode(responseBody: data)
            self.actionReview = output.actionReview
            self.conversationId = output.conversationId
            self.failedAttachments = output.failedAttachments
            self.sourceAttributions = output.sourceAttributions
            self.systemMessage = output.systemMessage
            self.systemMessageId = output.systemMessageId
            self.userMessageId = output.userMessageId
        } else {
            self.actionReview = nil
            self.conversationId = nil
            self.failedAttachments = nil
            self.sourceAttributions = nil
            self.systemMessage = nil
            self.systemMessageId = nil
            self.userMessageId = nil
        }
    }
}

public struct ChatSyncOutput: Swift.Equatable {
    /// A request from Amazon Q to the end user for information Amazon Q needs to successfully complete a requested plugin action.
    public var actionReview: QBusinessClientTypes.ActionReview?
    /// The identifier of the Amazon Q conversation.
    public var conversationId: Swift.String?
    /// A list of files which failed to upload during chat.
    public var failedAttachments: [QBusinessClientTypes.AttachmentOutput]?
    /// The source documents used to generate the conversation response.
    public var sourceAttributions: [QBusinessClientTypes.SourceAttribution?]?
    /// An AI-generated message in a conversation.
    public var systemMessage: Swift.String?
    /// The identifier of an Amazon Q AI generated message within the conversation.
    public var systemMessageId: Swift.String?
    /// The identifier of an Amazon Q end user text input message within the conversation.
    public var userMessageId: Swift.String?

    public init(
        actionReview: QBusinessClientTypes.ActionReview? = nil,
        conversationId: Swift.String? = nil,
        failedAttachments: [QBusinessClientTypes.AttachmentOutput]? = nil,
        sourceAttributions: [QBusinessClientTypes.SourceAttribution?]? = nil,
        systemMessage: Swift.String? = nil,
        systemMessageId: Swift.String? = nil,
        userMessageId: Swift.String? = nil
    )
    {
        self.actionReview = actionReview
        self.conversationId = conversationId
        self.failedAttachments = failedAttachments
        self.sourceAttributions = sourceAttributions
        self.systemMessage = systemMessage
        self.systemMessageId = systemMessageId
        self.userMessageId = userMessageId
    }
}

struct ChatSyncOutputBody: Swift.Equatable {
    let conversationId: Swift.String?
    let systemMessage: Swift.String?
    let systemMessageId: Swift.String?
    let userMessageId: Swift.String?
    let actionReview: QBusinessClientTypes.ActionReview?
    let sourceAttributions: [QBusinessClientTypes.SourceAttribution?]?
    let failedAttachments: [QBusinessClientTypes.AttachmentOutput]?
}

extension ChatSyncOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionReview
        case conversationId
        case failedAttachments
        case sourceAttributions
        case systemMessage
        case systemMessageId
        case userMessageId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conversationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conversationId)
        conversationId = conversationIdDecoded
        let systemMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .systemMessage)
        systemMessage = systemMessageDecoded
        let systemMessageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .systemMessageId)
        systemMessageId = systemMessageIdDecoded
        let userMessageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userMessageId)
        userMessageId = userMessageIdDecoded
        let actionReviewDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.ActionReview.self, forKey: .actionReview)
        actionReview = actionReviewDecoded
        let sourceAttributionsContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.SourceAttribution?].self, forKey: .sourceAttributions)
        var sourceAttributionsDecoded0:[QBusinessClientTypes.SourceAttribution?]? = nil
        if let sourceAttributionsContainer = sourceAttributionsContainer {
            sourceAttributionsDecoded0 = [QBusinessClientTypes.SourceAttribution?]()
            for structure0 in sourceAttributionsContainer {
                sourceAttributionsDecoded0?.append(structure0)
            }
        }
        sourceAttributions = sourceAttributionsDecoded0
        let failedAttachmentsContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.AttachmentOutput?].self, forKey: .failedAttachments)
        var failedAttachmentsDecoded0:[QBusinessClientTypes.AttachmentOutput]? = nil
        if let failedAttachmentsContainer = failedAttachmentsContainer {
            failedAttachmentsDecoded0 = [QBusinessClientTypes.AttachmentOutput]()
            for structure0 in failedAttachmentsContainer {
                if let structure0 = structure0 {
                    failedAttachmentsDecoded0?.append(structure0)
                }
            }
        }
        failedAttachments = failedAttachmentsDecoded0
    }
}

enum ChatSyncOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LicenseNotFoundException": return try await LicenseNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You are trying to perform an action that conflicts with the current status of your resource. Fix any inconsistences with your resources and try again.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message describing a ConflictException.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier of the resource affected.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource affected.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension QBusinessClientTypes.ContentBlockerRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case systemMessageOverride
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let systemMessageOverride = self.systemMessageOverride {
            try encodeContainer.encode(systemMessageOverride, forKey: .systemMessageOverride)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let systemMessageOverrideDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .systemMessageOverride)
        systemMessageOverride = systemMessageOverrideDecoded
    }
}

extension QBusinessClientTypes {
    /// A rule for configuring how Amazon Q responds when it encounters a a blocked topic. You can configure a custom message to inform your end users that they have asked about a restricted topic and suggest any next steps they should take.
    public struct ContentBlockerRule: Swift.Equatable {
        /// The configured custom message displayed to an end user informing them that they've used a blocked phrase during chat.
        public var systemMessageOverride: Swift.String?

        public init(
            systemMessageOverride: Swift.String? = nil
        )
        {
            self.systemMessageOverride = systemMessageOverride
        }
    }

}

extension QBusinessClientTypes.ContentRetrievalRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eligibleDataSources
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eligibleDataSources = eligibleDataSources {
            var eligibleDataSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eligibleDataSources)
            for eligibledatasource0 in eligibleDataSources {
                try eligibleDataSourcesContainer.encode(eligibledatasource0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eligibleDataSourcesContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.EligibleDataSource?].self, forKey: .eligibleDataSources)
        var eligibleDataSourcesDecoded0:[QBusinessClientTypes.EligibleDataSource]? = nil
        if let eligibleDataSourcesContainer = eligibleDataSourcesContainer {
            eligibleDataSourcesDecoded0 = [QBusinessClientTypes.EligibleDataSource]()
            for structure0 in eligibleDataSourcesContainer {
                if let structure0 = structure0 {
                    eligibleDataSourcesDecoded0?.append(structure0)
                }
            }
        }
        eligibleDataSources = eligibleDataSourcesDecoded0
    }
}

extension QBusinessClientTypes {
    /// Rules for retrieving content from data sources connected to a Amazon Q application for a specific topic control configuration.
    public struct ContentRetrievalRule: Swift.Equatable {
        /// Specifies data sources in a Amazon Q application to use for content generation.
        public var eligibleDataSources: [QBusinessClientTypes.EligibleDataSource]?

        public init(
            eligibleDataSources: [QBusinessClientTypes.EligibleDataSource]? = nil
        )
        {
            self.eligibleDataSources = eligibleDataSources
        }
    }

}

extension QBusinessClientTypes {
    public enum ContentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case html
        case json
        case md
        case msExcel
        case msWord
        case pdf
        case plainText
        case ppt
        case rtf
        case xml
        case xslt
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentType] {
            return [
                .csv,
                .html,
                .json,
                .md,
                .msExcel,
                .msWord,
                .pdf,
                .plainText,
                .ppt,
                .rtf,
                .xml,
                .xslt,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .html: return "HTML"
            case .json: return "JSON"
            case .md: return "MD"
            case .msExcel: return "MS_EXCEL"
            case .msWord: return "MS_WORD"
            case .pdf: return "PDF"
            case .plainText: return "PLAIN_TEXT"
            case .ppt: return "PPT"
            case .rtf: return "RTF"
            case .xml: return "XML"
            case .xslt: return "XSLT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContentType(rawValue: rawValue) ?? ContentType.sdkUnknown(rawValue)
        }
    }
}

extension QBusinessClientTypes.Conversation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conversationId
        case startTime
        case title
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conversationId = self.conversationId {
            try encodeContainer.encode(conversationId, forKey: .conversationId)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conversationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conversationId)
        conversationId = conversationIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
    }
}

extension QBusinessClientTypes {
    /// A conversation in an Amazon Q application.
    public struct Conversation: Swift.Equatable {
        /// The identifier of the Amazon Q conversation.
        public var conversationId: Swift.String?
        /// The start time of the conversation.
        public var startTime: ClientRuntime.Date?
        /// The title of the conversation.
        public var title: Swift.String?

        public init(
            conversationId: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            title: Swift.String? = nil
        )
        {
            self.conversationId = conversationId
            self.startTime = startTime
            self.title = title
        }
    }

}

extension CreateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentsConfiguration
        case clientToken
        case description
        case displayName
        case encryptionConfiguration
        case roleArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentsConfiguration = self.attachmentsConfiguration {
            try encodeContainer.encode(attachmentsConfiguration, forKey: .attachmentsConfiguration)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let encryptionConfiguration = self.encryptionConfiguration {
            try encodeContainer.encode(encryptionConfiguration, forKey: .encryptionConfiguration)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/applications"
    }
}

public struct CreateApplicationInput: Swift.Equatable {
    /// An option to allow end users to upload files directly during chat.
    public var attachmentsConfiguration: QBusinessClientTypes.AttachmentsConfiguration?
    /// A token that you provide to identify the request to create your Amazon Q application.
    public var clientToken: Swift.String?
    /// A description for the Amazon Q application.
    public var description: Swift.String?
    /// A name for the Amazon Q application.
    /// This member is required.
    public var displayName: Swift.String?
    /// The identifier of the KMS key that is used to encrypt your data. Amazon Q doesn't support asymmetric keys.
    public var encryptionConfiguration: QBusinessClientTypes.EncryptionConfiguration?
    /// The Amazon Resource Name (ARN) of an IAM role with permissions to access your Amazon CloudWatch logs and metrics.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A list of key-value pairs that identify or categorize your Amazon Q application. You can also use tags to help control access to the application. Tag keys and values can consist of Unicode letters, digits, white space, and any of the following symbols: _ . : / = + - @.
    public var tags: [QBusinessClientTypes.Tag]?

    public init(
        attachmentsConfiguration: QBusinessClientTypes.AttachmentsConfiguration? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        encryptionConfiguration: QBusinessClientTypes.EncryptionConfiguration? = nil,
        roleArn: Swift.String? = nil,
        tags: [QBusinessClientTypes.Tag]? = nil
    )
    {
        self.attachmentsConfiguration = attachmentsConfiguration
        self.clientToken = clientToken
        self.description = description
        self.displayName = displayName
        self.encryptionConfiguration = encryptionConfiguration
        self.roleArn = roleArn
        self.tags = tags
    }
}

struct CreateApplicationInputBody: Swift.Equatable {
    let displayName: Swift.String?
    let roleArn: Swift.String?
    let description: Swift.String?
    let encryptionConfiguration: QBusinessClientTypes.EncryptionConfiguration?
    let tags: [QBusinessClientTypes.Tag]?
    let clientToken: Swift.String?
    let attachmentsConfiguration: QBusinessClientTypes.AttachmentsConfiguration?
}

extension CreateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentsConfiguration
        case clientToken
        case description
        case displayName
        case encryptionConfiguration
        case roleArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.EncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[QBusinessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [QBusinessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let attachmentsConfigurationDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.AttachmentsConfiguration.self, forKey: .attachmentsConfiguration)
        attachmentsConfiguration = attachmentsConfigurationDecoded
    }
}

extension CreateApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationArn = output.applicationArn
            self.applicationId = output.applicationId
        } else {
            self.applicationArn = nil
            self.applicationId = nil
        }
    }
}

public struct CreateApplicationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Amazon Q application.
    public var applicationArn: Swift.String?
    /// The identifier of the Amazon Q application.
    public var applicationId: Swift.String?

    public init(
        applicationArn: Swift.String? = nil,
        applicationId: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
        self.applicationId = applicationId
    }
}

struct CreateApplicationOutputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let applicationArn: Swift.String?
}

extension CreateApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn
        case applicationId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
    }
}

enum CreateApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDataSourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case configuration
        case description
        case displayName
        case documentEnrichmentConfiguration
        case roleArn
        case syncSchedule
        case tags
        case vpcConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let documentEnrichmentConfiguration = self.documentEnrichmentConfiguration {
            try encodeContainer.encode(documentEnrichmentConfiguration, forKey: .documentEnrichmentConfiguration)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let syncSchedule = self.syncSchedule {
            try encodeContainer.encode(syncSchedule, forKey: .syncSchedule)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let vpcConfiguration = self.vpcConfiguration {
            try encodeContainer.encode(vpcConfiguration, forKey: .vpcConfiguration)
        }
    }
}

extension CreateDataSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let indexId = indexId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/indices/\(indexId.urlPercentEncoding())/datasources"
    }
}

public struct CreateDataSourceInput: Swift.Equatable {
    /// The identifier of the Amazon Q application the data source will be attached to.
    /// This member is required.
    public var applicationId: Swift.String?
    /// A token you provide to identify a request to create a data source connector. Multiple calls to the CreateDataSource API with the same client token will create only one data source connector.
    public var clientToken: Swift.String?
    /// Configuration information to connect to your data source repository. For configuration templates for your specific data source, see [Supported connectors](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/connectors-list.html.html).
    /// This member is required.
    public var configuration: ClientRuntime.Document?
    /// A description for the data source connector.
    public var description: Swift.String?
    /// A name for the data source connector.
    /// This member is required.
    public var displayName: Swift.String?
    /// Provides the configuration information for altering document metadata and content during the document ingestion process. For more information, see [Custom document enrichment](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/custom-document-enrichment.html).
    public var documentEnrichmentConfiguration: QBusinessClientTypes.DocumentEnrichmentConfiguration?
    /// The identifier of the index that you want to use with the data source connector.
    /// This member is required.
    public var indexId: Swift.String?
    /// The Amazon Resource Name (ARN) of an IAM role with permission to access the data source and required resources.
    public var roleArn: Swift.String?
    /// Sets the frequency for Amazon Q to check the documents in your data source repository and update your index. If you don't set a schedule, Amazon Q won't periodically update the index. Specify a cron- format schedule string or an empty string to indicate that the index is updated on demand. You can't specify the Schedule parameter when the Type parameter is set to CUSTOM. If you do, you receive a ValidationException exception.
    public var syncSchedule: Swift.String?
    /// A list of key-value pairs that identify or categorize the data source connector. You can also use tags to help control access to the data source connector. Tag keys and values can consist of Unicode letters, digits, white space, and any of the following symbols: _ . : / = + - @.
    public var tags: [QBusinessClientTypes.Tag]?
    /// Configuration information for an Amazon VPC (Virtual Private Cloud) to connect to your data source. For more information, see [Using Amazon VPC with Amazon Q connectors](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/connector-vpc.html).
    public var vpcConfiguration: QBusinessClientTypes.DataSourceVpcConfiguration?

    public init(
        applicationId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        configuration: ClientRuntime.Document? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        documentEnrichmentConfiguration: QBusinessClientTypes.DocumentEnrichmentConfiguration? = nil,
        indexId: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        syncSchedule: Swift.String? = nil,
        tags: [QBusinessClientTypes.Tag]? = nil,
        vpcConfiguration: QBusinessClientTypes.DataSourceVpcConfiguration? = nil
    )
    {
        self.applicationId = applicationId
        self.clientToken = clientToken
        self.configuration = configuration
        self.description = description
        self.displayName = displayName
        self.documentEnrichmentConfiguration = documentEnrichmentConfiguration
        self.indexId = indexId
        self.roleArn = roleArn
        self.syncSchedule = syncSchedule
        self.tags = tags
        self.vpcConfiguration = vpcConfiguration
    }
}

struct CreateDataSourceInputBody: Swift.Equatable {
    let displayName: Swift.String?
    let configuration: ClientRuntime.Document?
    let vpcConfiguration: QBusinessClientTypes.DataSourceVpcConfiguration?
    let description: Swift.String?
    let tags: [QBusinessClientTypes.Tag]?
    let syncSchedule: Swift.String?
    let roleArn: Swift.String?
    let clientToken: Swift.String?
    let documentEnrichmentConfiguration: QBusinessClientTypes.DocumentEnrichmentConfiguration?
}

extension CreateDataSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case configuration
        case description
        case displayName
        case documentEnrichmentConfiguration
        case roleArn
        case syncSchedule
        case tags
        case vpcConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .configuration)
        configuration = configurationDecoded
        let vpcConfigurationDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.DataSourceVpcConfiguration.self, forKey: .vpcConfiguration)
        vpcConfiguration = vpcConfigurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[QBusinessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [QBusinessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let syncScheduleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncSchedule)
        syncSchedule = syncScheduleDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let documentEnrichmentConfigurationDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.DocumentEnrichmentConfiguration.self, forKey: .documentEnrichmentConfiguration)
        documentEnrichmentConfiguration = documentEnrichmentConfigurationDecoded
    }
}

extension CreateDataSourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDataSourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataSourceArn = output.dataSourceArn
            self.dataSourceId = output.dataSourceId
        } else {
            self.dataSourceArn = nil
            self.dataSourceId = nil
        }
    }
}

public struct CreateDataSourceOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of a data source in an Amazon Q application.
    public var dataSourceArn: Swift.String?
    /// The identifier of the data source connector.
    public var dataSourceId: Swift.String?

    public init(
        dataSourceArn: Swift.String? = nil,
        dataSourceId: Swift.String? = nil
    )
    {
        self.dataSourceArn = dataSourceArn
        self.dataSourceId = dataSourceId
    }
}

struct CreateDataSourceOutputBody: Swift.Equatable {
    let dataSourceId: Swift.String?
    let dataSourceArn: Swift.String?
}

extension CreateDataSourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceArn
        case dataSourceId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let dataSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceArn)
        dataSourceArn = dataSourceArnDecoded
    }
}

enum CreateDataSourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateIndexInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacityConfiguration
        case clientToken
        case description
        case displayName
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capacityConfiguration = self.capacityConfiguration {
            try encodeContainer.encode(capacityConfiguration, forKey: .capacityConfiguration)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateIndexInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/indices"
    }
}

public struct CreateIndexInput: Swift.Equatable {
    /// The identifier of the Amazon Q application using the index.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The capacity units you want to provision for your index. You can add and remove capacity to fit your usage needs.
    public var capacityConfiguration: QBusinessClientTypes.IndexCapacityConfiguration?
    /// A token that you provide to identify the request to create an index. Multiple calls to the CreateIndex API with the same client token will create only one index.
    public var clientToken: Swift.String?
    /// A description for the Amazon Q index.
    public var description: Swift.String?
    /// A name for the Amazon Q index.
    /// This member is required.
    public var displayName: Swift.String?
    /// A list of key-value pairs that identify or categorize the index. You can also use tags to help control access to the index. Tag keys and values can consist of Unicode letters, digits, white space, and any of the following symbols: _ . : / = + - @.
    public var tags: [QBusinessClientTypes.Tag]?

    public init(
        applicationId: Swift.String? = nil,
        capacityConfiguration: QBusinessClientTypes.IndexCapacityConfiguration? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        tags: [QBusinessClientTypes.Tag]? = nil
    )
    {
        self.applicationId = applicationId
        self.capacityConfiguration = capacityConfiguration
        self.clientToken = clientToken
        self.description = description
        self.displayName = displayName
        self.tags = tags
    }
}

struct CreateIndexInputBody: Swift.Equatable {
    let displayName: Swift.String?
    let description: Swift.String?
    let tags: [QBusinessClientTypes.Tag]?
    let capacityConfiguration: QBusinessClientTypes.IndexCapacityConfiguration?
    let clientToken: Swift.String?
}

extension CreateIndexInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacityConfiguration
        case clientToken
        case description
        case displayName
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[QBusinessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [QBusinessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let capacityConfigurationDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.IndexCapacityConfiguration.self, forKey: .capacityConfiguration)
        capacityConfiguration = capacityConfigurationDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateIndexOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateIndexOutputBody = try responseDecoder.decode(responseBody: data)
            self.indexArn = output.indexArn
            self.indexId = output.indexId
        } else {
            self.indexArn = nil
            self.indexId = nil
        }
    }
}

public struct CreateIndexOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of an Amazon Q index.
    public var indexArn: Swift.String?
    /// The identifier for the Amazon Q index.
    public var indexId: Swift.String?

    public init(
        indexArn: Swift.String? = nil,
        indexId: Swift.String? = nil
    )
    {
        self.indexArn = indexArn
        self.indexId = indexId
    }
}

struct CreateIndexOutputBody: Swift.Equatable {
    let indexId: Swift.String?
    let indexArn: Swift.String?
}

extension CreateIndexOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexArn
        case indexId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let indexArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexArn)
        indexArn = indexArnDecoded
    }
}

enum CreateIndexOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePluginInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authConfiguration
        case clientToken
        case displayName
        case serverUrl
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authConfiguration = self.authConfiguration {
            try encodeContainer.encode(authConfiguration, forKey: .authConfiguration)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let serverUrl = self.serverUrl {
            try encodeContainer.encode(serverUrl, forKey: .serverUrl)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreatePluginInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/plugins"
    }
}

public struct CreatePluginInput: Swift.Equatable {
    /// The identifier of the application that will contain the plugin.
    /// This member is required.
    public var applicationId: Swift.String?
    /// Authentication configuration information for an Amazon Q plugin.
    /// This member is required.
    public var authConfiguration: QBusinessClientTypes.PluginAuthConfiguration?
    /// A token that you provide to identify the request to create your Amazon Q plugin.
    public var clientToken: Swift.String?
    /// A the name for your plugin.
    /// This member is required.
    public var displayName: Swift.String?
    /// The source URL used for plugin configuration.
    /// This member is required.
    public var serverUrl: Swift.String?
    /// A list of key-value pairs that identify or categorize the data source connector. You can also use tags to help control access to the data source connector. Tag keys and values can consist of Unicode letters, digits, white space, and any of the following symbols: _ . : / = + - @.
    public var tags: [QBusinessClientTypes.Tag]?
    /// The type of plugin you want to create.
    /// This member is required.
    public var type: QBusinessClientTypes.PluginType?

    public init(
        applicationId: Swift.String? = nil,
        authConfiguration: QBusinessClientTypes.PluginAuthConfiguration? = nil,
        clientToken: Swift.String? = nil,
        displayName: Swift.String? = nil,
        serverUrl: Swift.String? = nil,
        tags: [QBusinessClientTypes.Tag]? = nil,
        type: QBusinessClientTypes.PluginType? = nil
    )
    {
        self.applicationId = applicationId
        self.authConfiguration = authConfiguration
        self.clientToken = clientToken
        self.displayName = displayName
        self.serverUrl = serverUrl
        self.tags = tags
        self.type = type
    }
}

struct CreatePluginInputBody: Swift.Equatable {
    let displayName: Swift.String?
    let type: QBusinessClientTypes.PluginType?
    let serverUrl: Swift.String?
    let authConfiguration: QBusinessClientTypes.PluginAuthConfiguration?
    let tags: [QBusinessClientTypes.Tag]?
    let clientToken: Swift.String?
}

extension CreatePluginInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authConfiguration
        case clientToken
        case displayName
        case serverUrl
        case tags
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.PluginType.self, forKey: .type)
        type = typeDecoded
        let serverUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverUrl)
        serverUrl = serverUrlDecoded
        let authConfigurationDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.PluginAuthConfiguration.self, forKey: .authConfiguration)
        authConfiguration = authConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[QBusinessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [QBusinessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreatePluginOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePluginOutputBody = try responseDecoder.decode(responseBody: data)
            self.pluginArn = output.pluginArn
            self.pluginId = output.pluginId
        } else {
            self.pluginArn = nil
            self.pluginId = nil
        }
    }
}

public struct CreatePluginOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of a plugin.
    public var pluginArn: Swift.String?
    /// The identifier of the plugin created.
    public var pluginId: Swift.String?

    public init(
        pluginArn: Swift.String? = nil,
        pluginId: Swift.String? = nil
    )
    {
        self.pluginArn = pluginArn
        self.pluginId = pluginId
    }
}

struct CreatePluginOutputBody: Swift.Equatable {
    let pluginId: Swift.String?
    let pluginArn: Swift.String?
}

extension CreatePluginOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pluginArn
        case pluginId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pluginIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pluginId)
        pluginId = pluginIdDecoded
        let pluginArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pluginArn)
        pluginArn = pluginArnDecoded
    }
}

enum CreatePluginOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateRetrieverInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case configuration
        case displayName
        case roleArn
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateRetrieverInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/retrievers"
    }
}

public struct CreateRetrieverInput: Swift.Equatable {
    /// The identifier of your Amazon Q application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// A token that you provide to identify the request to create your Amazon Q application retriever.
    public var clientToken: Swift.String?
    /// Provides information on how the retriever used for your Amazon Q application is configured.
    /// This member is required.
    public var configuration: QBusinessClientTypes.RetrieverConfiguration?
    /// The name of your retriever.
    /// This member is required.
    public var displayName: Swift.String?
    /// The ARN of an IAM role used by Amazon Q to access the basic authentication credentials stored in a Secrets Manager secret.
    public var roleArn: Swift.String?
    /// A list of key-value pairs that identify or categorize the retriever. You can also use tags to help control access to the retriever. Tag keys and values can consist of Unicode letters, digits, white space, and any of the following symbols: _ . : / = + - @.
    public var tags: [QBusinessClientTypes.Tag]?
    /// The type of retriever you are using.
    /// This member is required.
    public var type: QBusinessClientTypes.RetrieverType?

    public init(
        applicationId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        configuration: QBusinessClientTypes.RetrieverConfiguration? = nil,
        displayName: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        tags: [QBusinessClientTypes.Tag]? = nil,
        type: QBusinessClientTypes.RetrieverType? = nil
    )
    {
        self.applicationId = applicationId
        self.clientToken = clientToken
        self.configuration = configuration
        self.displayName = displayName
        self.roleArn = roleArn
        self.tags = tags
        self.type = type
    }
}

struct CreateRetrieverInputBody: Swift.Equatable {
    let type: QBusinessClientTypes.RetrieverType?
    let displayName: Swift.String?
    let configuration: QBusinessClientTypes.RetrieverConfiguration?
    let roleArn: Swift.String?
    let clientToken: Swift.String?
    let tags: [QBusinessClientTypes.Tag]?
}

extension CreateRetrieverInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case configuration
        case displayName
        case roleArn
        case tags
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.RetrieverType.self, forKey: .type)
        type = typeDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.RetrieverConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[QBusinessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [QBusinessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRetrieverOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRetrieverOutputBody = try responseDecoder.decode(responseBody: data)
            self.retrieverArn = output.retrieverArn
            self.retrieverId = output.retrieverId
        } else {
            self.retrieverArn = nil
            self.retrieverId = nil
        }
    }
}

public struct CreateRetrieverOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of an IAM role associated with a retriever.
    public var retrieverArn: Swift.String?
    /// The identifier of the retriever you are using.
    public var retrieverId: Swift.String?

    public init(
        retrieverArn: Swift.String? = nil,
        retrieverId: Swift.String? = nil
    )
    {
        self.retrieverArn = retrieverArn
        self.retrieverId = retrieverId
    }
}

struct CreateRetrieverOutputBody: Swift.Equatable {
    let retrieverId: Swift.String?
    let retrieverArn: Swift.String?
}

extension CreateRetrieverOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case retrieverArn
        case retrieverId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retrieverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .retrieverId)
        retrieverId = retrieverIdDecoded
        let retrieverArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .retrieverArn)
        retrieverArn = retrieverArnDecoded
    }
}

enum CreateRetrieverOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case userAliases
        case userId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let userAliases = userAliases {
            var userAliasesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userAliases)
            for useralias0 in userAliases {
                try userAliasesContainer.encode(useralias0)
            }
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension CreateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/users"
    }
}

public struct CreateUserInput: Swift.Equatable {
    /// The identifier of the application for which the user mapping will be created.
    /// This member is required.
    public var applicationId: Swift.String?
    /// A token that you provide to identify the request to create your Amazon Q user mapping.
    public var clientToken: Swift.String?
    /// The list of user aliases in the mapping.
    public var userAliases: [QBusinessClientTypes.UserAlias]?
    /// The user emails attached to a user mapping.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        userAliases: [QBusinessClientTypes.UserAlias]? = nil,
        userId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.clientToken = clientToken
        self.userAliases = userAliases
        self.userId = userId
    }
}

struct CreateUserInputBody: Swift.Equatable {
    let userId: Swift.String?
    let userAliases: [QBusinessClientTypes.UserAlias]?
    let clientToken: Swift.String?
}

extension CreateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case userAliases
        case userId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let userAliasesContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.UserAlias?].self, forKey: .userAliases)
        var userAliasesDecoded0:[QBusinessClientTypes.UserAlias]? = nil
        if let userAliasesContainer = userAliasesContainer {
            userAliasesDecoded0 = [QBusinessClientTypes.UserAlias]()
            for structure0 in userAliasesContainer {
                if let structure0 = structure0 {
                    userAliasesDecoded0?.append(structure0)
                }
            }
        }
        userAliases = userAliasesDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateUserOutput: Swift.Equatable {

    public init() { }
}

enum CreateUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateWebExperienceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case samplePromptsControlMode
        case subtitle
        case tags
        case title
        case welcomeMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let samplePromptsControlMode = self.samplePromptsControlMode {
            try encodeContainer.encode(samplePromptsControlMode.rawValue, forKey: .samplePromptsControlMode)
        }
        if let subtitle = self.subtitle {
            try encodeContainer.encode(subtitle, forKey: .subtitle)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let welcomeMessage = self.welcomeMessage {
            try encodeContainer.encode(welcomeMessage, forKey: .welcomeMessage)
        }
    }
}

extension CreateWebExperienceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/experiences"
    }
}

public struct CreateWebExperienceInput: Swift.Equatable {
    /// The identifier of the Amazon Q web experience.
    /// This member is required.
    public var applicationId: Swift.String?
    /// A token you provide to identify a request to create an Amazon Q web experience.
    public var clientToken: Swift.String?
    /// Determines whether sample prompts are enabled in the web experience for an end user.
    public var samplePromptsControlMode: QBusinessClientTypes.WebExperienceSamplePromptsControlMode?
    /// A subtitle to personalize your Amazon Q web experience.
    public var subtitle: Swift.String?
    /// A list of key-value pairs that identify or categorize your Amazon Q web experience. You can also use tags to help control access to the web experience. Tag keys and values can consist of Unicode letters, digits, white space, and any of the following symbols: _ . : / = + - @.
    public var tags: [QBusinessClientTypes.Tag]?
    /// The title for your Amazon Q web experience.
    public var title: Swift.String?
    /// The customized welcome message for end users of an Amazon Q web experience.
    public var welcomeMessage: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        samplePromptsControlMode: QBusinessClientTypes.WebExperienceSamplePromptsControlMode? = nil,
        subtitle: Swift.String? = nil,
        tags: [QBusinessClientTypes.Tag]? = nil,
        title: Swift.String? = nil,
        welcomeMessage: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.clientToken = clientToken
        self.samplePromptsControlMode = samplePromptsControlMode
        self.subtitle = subtitle
        self.tags = tags
        self.title = title
        self.welcomeMessage = welcomeMessage
    }
}

struct CreateWebExperienceInputBody: Swift.Equatable {
    let title: Swift.String?
    let subtitle: Swift.String?
    let welcomeMessage: Swift.String?
    let samplePromptsControlMode: QBusinessClientTypes.WebExperienceSamplePromptsControlMode?
    let tags: [QBusinessClientTypes.Tag]?
    let clientToken: Swift.String?
}

extension CreateWebExperienceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case samplePromptsControlMode
        case subtitle
        case tags
        case title
        case welcomeMessage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let subtitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subtitle)
        subtitle = subtitleDecoded
        let welcomeMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .welcomeMessage)
        welcomeMessage = welcomeMessageDecoded
        let samplePromptsControlModeDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.WebExperienceSamplePromptsControlMode.self, forKey: .samplePromptsControlMode)
        samplePromptsControlMode = samplePromptsControlModeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[QBusinessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [QBusinessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateWebExperienceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateWebExperienceOutputBody = try responseDecoder.decode(responseBody: data)
            self.webExperienceArn = output.webExperienceArn
            self.webExperienceId = output.webExperienceId
        } else {
            self.webExperienceArn = nil
            self.webExperienceId = nil
        }
    }
}

public struct CreateWebExperienceOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of an Amazon Q web experience.
    public var webExperienceArn: Swift.String?
    /// The identifier of the Amazon Q web experience.
    public var webExperienceId: Swift.String?

    public init(
        webExperienceArn: Swift.String? = nil,
        webExperienceId: Swift.String? = nil
    )
    {
        self.webExperienceArn = webExperienceArn
        self.webExperienceId = webExperienceId
    }
}

struct CreateWebExperienceOutputBody: Swift.Equatable {
    let webExperienceId: Swift.String?
    let webExperienceArn: Swift.String?
}

extension CreateWebExperienceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case webExperienceArn
        case webExperienceId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webExperienceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webExperienceId)
        webExperienceId = webExperienceIdDecoded
        let webExperienceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webExperienceArn)
        webExperienceArn = webExperienceArnDecoded
    }
}

enum CreateWebExperienceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension QBusinessClientTypes.DataSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case dataSourceId
        case displayName
        case status
        case type
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let dataSourceId = self.dataSourceId {
            try encodeContainer.encode(dataSourceId, forKey: .dataSourceId)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.DataSourceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension QBusinessClientTypes {
    /// A data source in an Amazon Q application.
    public struct DataSource: Swift.Equatable {
        /// The Unix timestamp when the Amazon Q data source was created.
        public var createdAt: ClientRuntime.Date?
        /// The identifier of the Amazon Q data source.
        public var dataSourceId: Swift.String?
        /// The name of the Amazon Q data source.
        public var displayName: Swift.String?
        /// The status of the Amazon Q data source.
        public var status: QBusinessClientTypes.DataSourceStatus?
        /// The type of the Amazon Q data source.
        public var type: Swift.String?
        /// The Unix timestamp when the Amazon Q data source was last updated.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            dataSourceId: Swift.String? = nil,
            displayName: Swift.String? = nil,
            status: QBusinessClientTypes.DataSourceStatus? = nil,
            type: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.dataSourceId = dataSourceId
            self.displayName = displayName
            self.status = status
            self.type = type
            self.updatedAt = updatedAt
        }
    }

}

extension QBusinessClientTypes {
    public enum DataSourceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case pendingCreation
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .pendingCreation,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .pendingCreation: return "PENDING_CREATION"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataSourceStatus(rawValue: rawValue) ?? DataSourceStatus.sdkUnknown(rawValue)
        }
    }
}

extension QBusinessClientTypes.DataSourceSyncJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceErrorCode
        case endTime
        case error
        case executionId
        case metrics
        case startTime
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceErrorCode = self.dataSourceErrorCode {
            try encodeContainer.encode(dataSourceErrorCode, forKey: .dataSourceErrorCode)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let executionId = self.executionId {
            try encodeContainer.encode(executionId, forKey: .executionId)
        }
        if let metrics = self.metrics {
            try encodeContainer.encode(metrics, forKey: .metrics)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.DataSourceSyncJobStatus.self, forKey: .status)
        status = statusDecoded
        let errorDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.ErrorDetail.self, forKey: .error)
        error = errorDecoded
        let dataSourceErrorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceErrorCode)
        dataSourceErrorCode = dataSourceErrorCodeDecoded
        let metricsDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.DataSourceSyncJobMetrics.self, forKey: .metrics)
        metrics = metricsDecoded
    }
}

extension QBusinessClientTypes {
    /// Provides information about an Amazon Q data source connector synchronization job.
    public struct DataSourceSyncJob: Swift.Equatable {
        /// If the reason that the synchronization failed is due to an error with the underlying data source, this field contains a code that identifies the error.
        public var dataSourceErrorCode: Swift.String?
        /// The Unix timestamp when the synchronization job completed.
        public var endTime: ClientRuntime.Date?
        /// If the Status field is set to FAILED, the ErrorCode field indicates the reason the synchronization failed.
        public var error: QBusinessClientTypes.ErrorDetail?
        /// The identifier of a data source synchronization job.
        public var executionId: Swift.String?
        /// Maps a batch delete document request to a specific data source sync job. This is optional and should only be supplied when documents are deleted by a data source connector.
        public var metrics: QBusinessClientTypes.DataSourceSyncJobMetrics?
        /// The Unix time stamp when the data source synchronization job started.
        public var startTime: ClientRuntime.Date?
        /// The status of the synchronization job. When the Status field is set to SUCCEEDED, the synchronization job is done. If the status code is FAILED, the ErrorCode and ErrorMessage fields give you the reason for the failure.
        public var status: QBusinessClientTypes.DataSourceSyncJobStatus?

        public init(
            dataSourceErrorCode: Swift.String? = nil,
            endTime: ClientRuntime.Date? = nil,
            error: QBusinessClientTypes.ErrorDetail? = nil,
            executionId: Swift.String? = nil,
            metrics: QBusinessClientTypes.DataSourceSyncJobMetrics? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: QBusinessClientTypes.DataSourceSyncJobStatus? = nil
        )
        {
            self.dataSourceErrorCode = dataSourceErrorCode
            self.endTime = endTime
            self.error = error
            self.executionId = executionId
            self.metrics = metrics
            self.startTime = startTime
            self.status = status
        }
    }

}

extension QBusinessClientTypes.DataSourceSyncJobMetrics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentsAdded
        case documentsDeleted
        case documentsFailed
        case documentsModified
        case documentsScanned
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentsAdded = self.documentsAdded {
            try encodeContainer.encode(documentsAdded, forKey: .documentsAdded)
        }
        if let documentsDeleted = self.documentsDeleted {
            try encodeContainer.encode(documentsDeleted, forKey: .documentsDeleted)
        }
        if let documentsFailed = self.documentsFailed {
            try encodeContainer.encode(documentsFailed, forKey: .documentsFailed)
        }
        if let documentsModified = self.documentsModified {
            try encodeContainer.encode(documentsModified, forKey: .documentsModified)
        }
        if let documentsScanned = self.documentsScanned {
            try encodeContainer.encode(documentsScanned, forKey: .documentsScanned)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentsAddedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentsAdded)
        documentsAdded = documentsAddedDecoded
        let documentsModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentsModified)
        documentsModified = documentsModifiedDecoded
        let documentsDeletedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentsDeleted)
        documentsDeleted = documentsDeletedDecoded
        let documentsFailedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentsFailed)
        documentsFailed = documentsFailedDecoded
        let documentsScannedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentsScanned)
        documentsScanned = documentsScannedDecoded
    }
}

extension QBusinessClientTypes {
    /// Maps a batch delete document request to a specific Amazon Q data source connector sync job.
    public struct DataSourceSyncJobMetrics: Swift.Equatable {
        /// The current count of documents added from the data source during the data source sync.
        public var documentsAdded: Swift.String?
        /// The current count of documents deleted from the data source during the data source sync.
        public var documentsDeleted: Swift.String?
        /// The current count of documents that failed to sync from the data source during the data source sync.
        public var documentsFailed: Swift.String?
        /// The current count of documents modified in the data source during the data source sync.
        public var documentsModified: Swift.String?
        /// The current count of documents crawled by the ongoing sync job in the data source.
        public var documentsScanned: Swift.String?

        public init(
            documentsAdded: Swift.String? = nil,
            documentsDeleted: Swift.String? = nil,
            documentsFailed: Swift.String? = nil,
            documentsModified: Swift.String? = nil,
            documentsScanned: Swift.String? = nil
        )
        {
            self.documentsAdded = documentsAdded
            self.documentsDeleted = documentsDeleted
            self.documentsFailed = documentsFailed
            self.documentsModified = documentsModified
            self.documentsScanned = documentsScanned
        }
    }

}

extension QBusinessClientTypes {
    public enum DataSourceSyncJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aborted
        case failed
        case incomplete
        case stopping
        case succeeded
        case syncing
        case syncingIndexing
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceSyncJobStatus] {
            return [
                .aborted,
                .failed,
                .incomplete,
                .stopping,
                .succeeded,
                .syncing,
                .syncingIndexing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aborted: return "ABORTED"
            case .failed: return "FAILED"
            case .incomplete: return "INCOMPLETE"
            case .stopping: return "STOPPING"
            case .succeeded: return "SUCCEEDED"
            case .syncing: return "SYNCING"
            case .syncingIndexing: return "SYNCING_INDEXING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataSourceSyncJobStatus(rawValue: rawValue) ?? DataSourceSyncJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension QBusinessClientTypes.DataSourceVpcConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds
        case subnetIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension QBusinessClientTypes {
    /// Provides configuration information needed to connect to an Amazon VPC (Virtual Private Cloud).
    public struct DataSourceVpcConfiguration: Swift.Equatable {
        /// A list of identifiers of security groups within your Amazon VPC. The security groups should enable Amazon Q to connect to the data source.
        /// This member is required.
        public var securityGroupIds: [Swift.String]?
        /// A list of identifiers for subnets within your Amazon VPC. The subnets should be able to connect to each other in the VPC, and they should have outgoing access to the Internet through a NAT device.
        /// This member is required.
        public var subnetIds: [Swift.String]?

        public init(
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }

}

extension DeleteApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())"
    }
}

public struct DeleteApplicationInput: Swift.Equatable {
    /// The identifier of the Amazon Q application.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct DeleteApplicationInputBody: Swift.Equatable {
}

extension DeleteApplicationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteApplicationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteChatControlsConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/chatcontrols"
    }
}

public struct DeleteChatControlsConfigurationInput: Swift.Equatable {
    /// The identifier of the application the chat controls have been configured for.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct DeleteChatControlsConfigurationInputBody: Swift.Equatable {
}

extension DeleteChatControlsConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChatControlsConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteChatControlsConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteChatControlsConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteConversationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let userId = userId else {
                let message = "Creating a URL Query Item failed. userId is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let userIdQueryItem = ClientRuntime.URLQueryItem(name: "userId".urlPercentEncoding(), value: Swift.String(userId).urlPercentEncoding())
            items.append(userIdQueryItem)
            return items
        }
    }
}

extension DeleteConversationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let conversationId = conversationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/conversations/\(conversationId.urlPercentEncoding())"
    }
}

public struct DeleteConversationInput: Swift.Equatable {
    /// The identifier of the Amazon Q application associated with the conversation.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the Amazon Q web experience conversation being deleted.
    /// This member is required.
    public var conversationId: Swift.String?
    /// The identifier of the user who is deleting the conversation.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        conversationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.conversationId = conversationId
        self.userId = userId
    }
}

struct DeleteConversationInputBody: Swift.Equatable {
}

extension DeleteConversationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteConversationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteConversationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteConversationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LicenseNotFoundException": return try await LicenseNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDataSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let indexId = indexId else {
            return nil
        }
        guard let dataSourceId = dataSourceId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/indices/\(indexId.urlPercentEncoding())/datasources/\(dataSourceId.urlPercentEncoding())"
    }
}

public struct DeleteDataSourceInput: Swift.Equatable {
    /// The identifier of the Amazon Q application used with the data source connector.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the data source connector that you want to delete.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// The identifier of the index used with the data source connector.
    /// This member is required.
    public var indexId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        indexId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.dataSourceId = dataSourceId
        self.indexId = indexId
    }
}

struct DeleteDataSourceInputBody: Swift.Equatable {
}

extension DeleteDataSourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDataSourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDataSourceOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDataSourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension QBusinessClientTypes.DeleteDocument: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentId = self.documentId {
            try encodeContainer.encode(documentId, forKey: .documentId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentId)
        documentId = documentIdDecoded
    }
}

extension QBusinessClientTypes {
    /// A document deleted from an Amazon Q data source connector.
    public struct DeleteDocument: Swift.Equatable {
        /// The identifier of the deleted document.
        /// This member is required.
        public var documentId: Swift.String?

        public init(
            documentId: Swift.String? = nil
        )
        {
            self.documentId = documentId
        }
    }

}

extension DeleteGroupInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let dataSourceId = dataSourceId {
                let dataSourceIdQueryItem = ClientRuntime.URLQueryItem(name: "dataSourceId".urlPercentEncoding(), value: Swift.String(dataSourceId).urlPercentEncoding())
                items.append(dataSourceIdQueryItem)
            }
            return items
        }
    }
}

extension DeleteGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let indexId = indexId else {
            return nil
        }
        guard let groupName = groupName else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/indices/\(indexId.urlPercentEncoding())/groups/\(groupName.urlPercentEncoding())"
    }
}

public struct DeleteGroupInput: Swift.Equatable {
    /// The identifier of the application in which the group mapping belongs.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the data source linked to the group A group can be tied to multiple data sources. You can delete a group from accessing documents in a certain data source. For example, the groups "Research", "Engineering", and "Sales and Marketing" are all tied to the company's documents stored in the data sources Confluence and Salesforce. You want to delete "Research" and "Engineering" groups from Salesforce, so that these groups cannot access customer-related documents stored in Salesforce. Only "Sales and Marketing" should access documents in the Salesforce data source.
    public var dataSourceId: Swift.String?
    /// The name of the group you want to delete.
    /// This member is required.
    public var groupName: Swift.String?
    /// The identifier of the index you want to delete the group from.
    /// This member is required.
    public var indexId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        groupName: Swift.String? = nil,
        indexId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.dataSourceId = dataSourceId
        self.groupName = groupName
        self.indexId = indexId
    }
}

struct DeleteGroupInputBody: Swift.Equatable {
}

extension DeleteGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteGroupOutput: Swift.Equatable {

    public init() { }
}

enum DeleteGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteIndexInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let indexId = indexId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/indices/\(indexId.urlPercentEncoding())"
    }
}

public struct DeleteIndexInput: Swift.Equatable {
    /// The identifier of the Amazon Q application the Amazon Q index is linked to.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the Amazon Q index.
    /// This member is required.
    public var indexId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        indexId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.indexId = indexId
    }
}

struct DeleteIndexInputBody: Swift.Equatable {
}

extension DeleteIndexInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteIndexOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteIndexOutput: Swift.Equatable {

    public init() { }
}

enum DeleteIndexOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePluginInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let pluginId = pluginId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/plugins/\(pluginId.urlPercentEncoding())"
    }
}

public struct DeletePluginInput: Swift.Equatable {
    /// The identifier the application attached to the Amazon Q plugin.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the plugin being deleted.
    /// This member is required.
    public var pluginId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        pluginId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.pluginId = pluginId
    }
}

struct DeletePluginInputBody: Swift.Equatable {
}

extension DeletePluginInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeletePluginOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeletePluginOutput: Swift.Equatable {

    public init() { }
}

enum DeletePluginOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRetrieverInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let retrieverId = retrieverId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/retrievers/\(retrieverId.urlPercentEncoding())"
    }
}

public struct DeleteRetrieverInput: Swift.Equatable {
    /// The identifier of the Amazon Q application using the retriever.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the retriever being deleted.
    /// This member is required.
    public var retrieverId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        retrieverId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.retrieverId = retrieverId
    }
}

struct DeleteRetrieverInputBody: Swift.Equatable {
}

extension DeleteRetrieverInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRetrieverOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteRetrieverOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRetrieverOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let userId = userId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/users/\(userId.urlPercentEncoding())"
    }
}

public struct DeleteUserInput: Swift.Equatable {
    /// The identifier of the application from which the user is being deleted.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The user email being deleted.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.userId = userId
    }
}

struct DeleteUserInputBody: Swift.Equatable {
}

extension DeleteUserInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteUserOutput: Swift.Equatable {

    public init() { }
}

enum DeleteUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteWebExperienceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let webExperienceId = webExperienceId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/experiences/\(webExperienceId.urlPercentEncoding())"
    }
}

public struct DeleteWebExperienceInput: Swift.Equatable {
    /// The identifier of the Amazon Q application linked to the Amazon Q web experience.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the Amazon Q web experience being deleted.
    /// This member is required.
    public var webExperienceId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        webExperienceId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.webExperienceId = webExperienceId
    }
}

struct DeleteWebExperienceInputBody: Swift.Equatable {
}

extension DeleteWebExperienceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWebExperienceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteWebExperienceOutput: Swift.Equatable {

    public init() { }
}

enum DeleteWebExperienceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension QBusinessClientTypes.Document: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessConfiguration
        case attributes
        case content
        case contentType
        case documentEnrichmentConfiguration
        case id
        case title
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessConfiguration = self.accessConfiguration {
            try encodeContainer.encode(accessConfiguration, forKey: .accessConfiguration)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for documentattribute0 in attributes {
                try attributesContainer.encode(documentattribute0)
            }
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType.rawValue, forKey: .contentType)
        }
        if let documentEnrichmentConfiguration = self.documentEnrichmentConfiguration {
            try encodeContainer.encode(documentEnrichmentConfiguration, forKey: .documentEnrichmentConfiguration)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let attributesContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.DocumentAttribute?].self, forKey: .attributes)
        var attributesDecoded0:[QBusinessClientTypes.DocumentAttribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [QBusinessClientTypes.DocumentAttribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let contentDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.DocumentContent.self, forKey: .content)
        content = contentDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.ContentType.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let accessConfigurationDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.AccessConfiguration.self, forKey: .accessConfiguration)
        accessConfiguration = accessConfigurationDecoded
        let documentEnrichmentConfigurationDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.DocumentEnrichmentConfiguration.self, forKey: .documentEnrichmentConfiguration)
        documentEnrichmentConfiguration = documentEnrichmentConfigurationDecoded
    }
}

extension QBusinessClientTypes {
    /// A document in an Amazon Q application.
    public struct Document: Swift.Equatable {
        /// Configuration information for access permission to a document.
        public var accessConfiguration: QBusinessClientTypes.AccessConfiguration?
        /// Custom attributes to apply to the document for refining Amazon Q web experience responses.
        public var attributes: [QBusinessClientTypes.DocumentAttribute]?
        /// The contents of the document.
        public var content: QBusinessClientTypes.DocumentContent?
        /// The file type of the document in the Blob field. If you want to index snippets or subsets of HTML documents instead of the entirety of the HTML documents, you add the HTML start and closing tags (<HTML>content</HTML>) around the content.
        public var contentType: QBusinessClientTypes.ContentType?
        /// The configuration information for altering document metadata and content during the document ingestion process.
        public var documentEnrichmentConfiguration: QBusinessClientTypes.DocumentEnrichmentConfiguration?
        /// The identifier of the document.
        /// This member is required.
        public var id: Swift.String?
        /// The title of the document.
        public var title: Swift.String?

        public init(
            accessConfiguration: QBusinessClientTypes.AccessConfiguration? = nil,
            attributes: [QBusinessClientTypes.DocumentAttribute]? = nil,
            content: QBusinessClientTypes.DocumentContent? = nil,
            contentType: QBusinessClientTypes.ContentType? = nil,
            documentEnrichmentConfiguration: QBusinessClientTypes.DocumentEnrichmentConfiguration? = nil,
            id: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.accessConfiguration = accessConfiguration
            self.attributes = attributes
            self.content = content
            self.contentType = contentType
            self.documentEnrichmentConfiguration = documentEnrichmentConfiguration
            self.id = id
            self.title = title
        }
    }

}

extension QBusinessClientTypes.DocumentAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.DocumentAttributeValue.self, forKey: .value)
        value = valueDecoded
    }
}

extension QBusinessClientTypes {
    /// A document attribute or metadata field.
    public struct DocumentAttribute: Swift.Equatable {
        /// The identifier for the attribute.
        /// This member is required.
        public var name: Swift.String?
        /// The value of the attribute.
        /// This member is required.
        public var value: QBusinessClientTypes.DocumentAttributeValue?

        public init(
            name: Swift.String? = nil,
            value: QBusinessClientTypes.DocumentAttributeValue? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension QBusinessClientTypes.DocumentAttributeCondition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case `operator` = "operator"
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.DocumentEnrichmentConditionOperator.self, forKey: .operator)
        `operator` = operatorDecoded
        let valueDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.DocumentAttributeValue.self, forKey: .value)
        value = valueDecoded
    }
}

extension QBusinessClientTypes {
    /// The condition used for the target document attribute or metadata field when ingesting documents into Amazon Q. You use this with [DocumentAttributeTarget](https://docs.aws.amazon.com/enterpriseq/latest/APIReference/API_DocumentAttributeTarget.html) to apply the condition. For example, you can create the 'Department' target field and have it prefill department names associated with the documents based on information in the 'Source_URI' field. Set the condition that if the 'Source_URI' field contains 'financial' in its URI value, then prefill the target field 'Department' with the target value 'Finance' for the document. Amazon Q can't create a target field if it has not already been created as an index field. After you create your index field, you can create a document metadata field using DocumentAttributeTarget. Amazon Q then will map your newly created metadata field to your index field.
    public struct DocumentAttributeCondition: Swift.Equatable {
        /// The identifier of the document attribute used for the condition. For example, 'Source_URI' could be an identifier for the attribute or metadata field that contains source URIs associated with the documents. Amazon Q currently doesn't support _document_body as an attribute key used for the condition.
        /// This member is required.
        public var key: Swift.String?
        /// The identifier of the document attribute used for the condition. For example, 'Source_URI' could be an identifier for the attribute or metadata field that contains source URIs associated with the documents. Amazon Kendra currently does not support _document_body as an attribute key used for the condition.
        /// This member is required.
        public var `operator`: QBusinessClientTypes.DocumentEnrichmentConditionOperator?
        /// The value of a document attribute. You can only provide one value for a document attribute.
        public var value: QBusinessClientTypes.DocumentAttributeValue?

        public init(
            key: Swift.String? = nil,
            `operator`: QBusinessClientTypes.DocumentEnrichmentConditionOperator? = nil,
            value: QBusinessClientTypes.DocumentAttributeValue? = nil
        )
        {
            self.key = key
            self.`operator` = `operator`
            self.value = value
        }
    }

}

extension QBusinessClientTypes.DocumentAttributeConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case search
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let search = self.search {
            try encodeContainer.encode(search.rawValue, forKey: .search)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.AttributeType.self, forKey: .type)
        type = typeDecoded
        let searchDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.Status.self, forKey: .search)
        search = searchDecoded
    }
}

extension QBusinessClientTypes {
    /// Configuration information for document attributes. Document attributes are metadata or fields associated with your documents. For example, the company department name associated with each document. For more information, see [Understanding document attributes](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/doc-attributes.html).
    public struct DocumentAttributeConfiguration: Swift.Equatable {
        /// The name of the document attribute.
        public var name: Swift.String?
        /// Information about whether the document attribute can be used by an end user to search for information on their web experience.
        public var search: QBusinessClientTypes.Status?
        /// The type of document attribute.
        public var type: QBusinessClientTypes.AttributeType?

        public init(
            name: Swift.String? = nil,
            search: QBusinessClientTypes.Status? = nil,
            type: QBusinessClientTypes.AttributeType? = nil
        )
        {
            self.name = name
            self.search = search
            self.type = type
        }
    }

}

extension QBusinessClientTypes.DocumentAttributeTarget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeValueOperator
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeValueOperator = self.attributeValueOperator {
            try encodeContainer.encode(attributeValueOperator.rawValue, forKey: .attributeValueOperator)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.DocumentAttributeValue.self, forKey: .value)
        value = valueDecoded
        let attributeValueOperatorDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.AttributeValueOperator.self, forKey: .attributeValueOperator)
        attributeValueOperator = attributeValueOperatorDecoded
    }
}

extension QBusinessClientTypes {
    /// The target document attribute or metadata field you want to alter when ingesting documents into Amazon Q. For example, you can delete all customer identification numbers associated with the documents, stored in the document metadata field called 'Customer_ID' by setting the target key as 'Customer_ID' and the deletion flag to TRUE. This removes all customer ID values in the field 'Customer_ID'. This would scrub personally identifiable information from each document's metadata. Amazon Q can't create a target field if it has not already been created as an index field. After you create your index field, you can create a document metadata field using [DocumentAttributeTarget](https://docs.aws.amazon.com/enterpriseq/latest/APIReference/API_DocumentAttributeTarget.html). Amazon Q will then map your newly created document attribute to your index field. You can also use this with [DocumentAttributeCondition](https://docs.aws.amazon.com/enterpriseq/latest/APIReference/API_DocumentAttributeCondition.html).
    public struct DocumentAttributeTarget: Swift.Equatable {
        /// TRUE to delete the existing target value for your specified target attribute key. You cannot create a target value and set this to TRUE.
        public var attributeValueOperator: QBusinessClientTypes.AttributeValueOperator?
        /// The identifier of the target document attribute or metadata field. For example, 'Department' could be an identifier for the target attribute or metadata field that includes the department names associated with the documents.
        /// This member is required.
        public var key: Swift.String?
        /// The value of a document attribute. You can only provide one value for a document attribute.
        public var value: QBusinessClientTypes.DocumentAttributeValue?

        public init(
            attributeValueOperator: QBusinessClientTypes.AttributeValueOperator? = nil,
            key: Swift.String? = nil,
            value: QBusinessClientTypes.DocumentAttributeValue? = nil
        )
        {
            self.attributeValueOperator = attributeValueOperator
            self.key = key
            self.value = value
        }
    }

}

extension QBusinessClientTypes.DocumentAttributeValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datevalue = "dateValue"
        case longvalue = "longValue"
        case sdkUnknown
        case stringlistvalue = "stringListValue"
        case stringvalue = "stringValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .datevalue(datevalue):
                try container.encodeTimestamp(datevalue, format: .epochSeconds, forKey: .datevalue)
            case let .longvalue(longvalue):
                try container.encode(longvalue, forKey: .longvalue)
            case let .stringlistvalue(stringlistvalue):
                var stringlistvalueContainer = container.nestedUnkeyedContainer(forKey: .stringlistvalue)
                for string0 in stringlistvalue {
                    try stringlistvalueContainer.encode(string0)
                }
            case let .stringvalue(stringvalue):
                try container.encode(stringvalue, forKey: .stringvalue)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let stringvalueDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .stringvalue)
        if let stringvalue = stringvalueDecoded {
            self = .stringvalue(stringvalue)
            return
        }
        let stringlistvalueContainer = try values.decodeIfPresent([Swift.String?].self, forKey: .stringlistvalue)
        var stringlistvalueDecoded0:[Swift.String]? = nil
        if let stringlistvalueContainer = stringlistvalueContainer {
            stringlistvalueDecoded0 = [Swift.String]()
            for string0 in stringlistvalueContainer {
                if let string0 = string0 {
                    stringlistvalueDecoded0?.append(string0)
                }
            }
        }
        if let stringlistvalue = stringlistvalueDecoded0 {
            self = .stringlistvalue(stringlistvalue)
            return
        }
        let longvalueDecoded = try values.decodeIfPresent(Swift.Int.self, forKey: .longvalue)
        if let longvalue = longvalueDecoded {
            self = .longvalue(longvalue)
            return
        }
        let datevalueDecoded = try values.decodeTimestampIfPresent(.epochSeconds, forKey: .datevalue)
        if let datevalue = datevalueDecoded {
            self = .datevalue(datevalue)
            return
        }
        self = .sdkUnknown("")
    }
}

extension QBusinessClientTypes {
    /// The value of a document attribute. You can only provide one value for a document attribute.
    public enum DocumentAttributeValue: Swift.Equatable {
        /// A string.
        case stringvalue(Swift.String)
        /// A list of strings.
        case stringlistvalue([Swift.String])
        /// A long integer value.
        case longvalue(Swift.Int)
        /// A date expressed as an ISO 8601 string. It's important for the time zone to be included in the ISO 8601 date-time format. For example, 2012-03-25T12:30:10+01:00 is the ISO 8601 date-time format for March 25th 2012 at 12:30PM (plus 10 seconds) in Central European Time.
        case datevalue(ClientRuntime.Date)
        case sdkUnknown(Swift.String)
    }

}

extension QBusinessClientTypes.DocumentContent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blob
        case s3
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .blob(blob):
                try container.encode(blob.base64EncodedString(), forKey: .blob)
            case let .s3(s3):
                try container.encode(s3, forKey: .s3)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let blobDecoded = try values.decodeIfPresent(ClientRuntime.Data.self, forKey: .blob)
        if let blob = blobDecoded {
            self = .blob(blob)
            return
        }
        let s3Decoded = try values.decodeIfPresent(QBusinessClientTypes.S3.self, forKey: .s3)
        if let s3 = s3Decoded {
            self = .s3(s3)
            return
        }
        self = .sdkUnknown("")
    }
}

extension QBusinessClientTypes {
    /// The contents of a document.
    public enum DocumentContent: Swift.Equatable {
        /// The contents of the document. Documents passed to the blob parameter must be base64 encoded. Your code might not need to encode the document file bytes if you're using an Amazon Web Services SDK to call Amazon Q APIs. If you are calling the Amazon Q endpoint directly using REST, you must base64 encode the contents before sending.
        case blob(ClientRuntime.Data)
        /// The path to the document in an Amazon S3 bucket.
        case s3(QBusinessClientTypes.S3)
        case sdkUnknown(Swift.String)
    }

}

extension QBusinessClientTypes {
    public enum DocumentContentOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case delete
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentContentOperator] {
            return [
                .delete,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .delete: return "DELETE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DocumentContentOperator(rawValue: rawValue) ?? DocumentContentOperator.sdkUnknown(rawValue)
        }
    }
}

extension QBusinessClientTypes.DocumentDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case documentId
        case error
        case status
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let documentId = self.documentId {
            try encodeContainer.encode(documentId, forKey: .documentId)
        }
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentId)
        documentId = documentIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.DocumentStatus.self, forKey: .status)
        status = statusDecoded
        let errorDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.ErrorDetail.self, forKey: .error)
        error = errorDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension QBusinessClientTypes {
    /// The details of a document within an Amazon Q index.
    public struct DocumentDetails: Swift.Equatable {
        /// The timestamp for when the document was created.
        public var createdAt: ClientRuntime.Date?
        /// The identifier of the document.
        public var documentId: Swift.String?
        /// An error message associated with the document.
        public var error: QBusinessClientTypes.ErrorDetail?
        /// The current status of the document.
        public var status: QBusinessClientTypes.DocumentStatus?
        /// The timestamp for when the document was last updated.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            documentId: Swift.String? = nil,
            error: QBusinessClientTypes.ErrorDetail? = nil,
            status: QBusinessClientTypes.DocumentStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.documentId = documentId
            self.error = error
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension QBusinessClientTypes {
    public enum DocumentEnrichmentConditionOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case beginsWith
        case contains
        case equals
        case exists
        case greaterThan
        case greaterThanOrEquals
        case lessThan
        case lessThanOrEquals
        case notContains
        case notEquals
        case notExists
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentEnrichmentConditionOperator] {
            return [
                .beginsWith,
                .contains,
                .equals,
                .exists,
                .greaterThan,
                .greaterThanOrEquals,
                .lessThan,
                .lessThanOrEquals,
                .notContains,
                .notEquals,
                .notExists,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .beginsWith: return "BEGINS_WITH"
            case .contains: return "CONTAINS"
            case .equals: return "EQUALS"
            case .exists: return "EXISTS"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEquals: return "GREATER_THAN_OR_EQUALS"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEquals: return "LESS_THAN_OR_EQUALS"
            case .notContains: return "NOT_CONTAINS"
            case .notEquals: return "NOT_EQUALS"
            case .notExists: return "NOT_EXISTS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DocumentEnrichmentConditionOperator(rawValue: rawValue) ?? DocumentEnrichmentConditionOperator.sdkUnknown(rawValue)
        }
    }
}

extension QBusinessClientTypes.DocumentEnrichmentConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inlineConfigurations
        case postExtractionHookConfiguration
        case preExtractionHookConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inlineConfigurations = inlineConfigurations {
            var inlineConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inlineConfigurations)
            for inlinedocumentenrichmentconfiguration0 in inlineConfigurations {
                try inlineConfigurationsContainer.encode(inlinedocumentenrichmentconfiguration0)
            }
        }
        if let postExtractionHookConfiguration = self.postExtractionHookConfiguration {
            try encodeContainer.encode(postExtractionHookConfiguration, forKey: .postExtractionHookConfiguration)
        }
        if let preExtractionHookConfiguration = self.preExtractionHookConfiguration {
            try encodeContainer.encode(preExtractionHookConfiguration, forKey: .preExtractionHookConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inlineConfigurationsContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.InlineDocumentEnrichmentConfiguration?].self, forKey: .inlineConfigurations)
        var inlineConfigurationsDecoded0:[QBusinessClientTypes.InlineDocumentEnrichmentConfiguration]? = nil
        if let inlineConfigurationsContainer = inlineConfigurationsContainer {
            inlineConfigurationsDecoded0 = [QBusinessClientTypes.InlineDocumentEnrichmentConfiguration]()
            for structure0 in inlineConfigurationsContainer {
                if let structure0 = structure0 {
                    inlineConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        inlineConfigurations = inlineConfigurationsDecoded0
        let preExtractionHookConfigurationDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.HookConfiguration.self, forKey: .preExtractionHookConfiguration)
        preExtractionHookConfiguration = preExtractionHookConfigurationDecoded
        let postExtractionHookConfigurationDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.HookConfiguration.self, forKey: .postExtractionHookConfiguration)
        postExtractionHookConfiguration = postExtractionHookConfigurationDecoded
    }
}

extension QBusinessClientTypes {
    /// Provides the configuration information for altering document metadata and content during the document ingestion process. For more information, see [Custom document enrichment](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/custom-document-enrichment.html).
    public struct DocumentEnrichmentConfiguration: Swift.Equatable {
        /// Configuration information to alter document attributes or metadata fields and content when ingesting documents into Amazon Q.
        public var inlineConfigurations: [QBusinessClientTypes.InlineDocumentEnrichmentConfiguration]?
        /// Provides the configuration information for invoking a Lambda function in Lambda to alter document metadata and content when ingesting documents into Amazon Q. You can configure your Lambda function using [PreExtractionHookConfiguration](https://docs.aws.amazon.com/enterpriseq/latest/APIReference/API_CustomDocumentEnrichmentConfiguration.html) if you want to apply advanced alterations on the original or raw documents. If you want to apply advanced alterations on the Amazon Q structured documents, you must configure your Lambda function using [PostExtractionHookConfiguration](https://docs.aws.amazon.com/enterpriseq/latest/APIReference/API_CustomDocumentEnrichmentConfiguration.html). You can only invoke one Lambda function. However, this function can invoke other functions it requires. For more information, see [Custom document enrichment](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/custom-document-enrichment.html).
        public var postExtractionHookConfiguration: QBusinessClientTypes.HookConfiguration?
        /// Provides the configuration information for invoking a Lambda function in Lambda to alter document metadata and content when ingesting documents into Amazon Q. You can configure your Lambda function using [PreExtractionHookConfiguration](https://docs.aws.amazon.com/enterpriseq/latest/APIReference/API_CustomDocumentEnrichmentConfiguration.html) if you want to apply advanced alterations on the original or raw documents. If you want to apply advanced alterations on the Amazon Q structured documents, you must configure your Lambda function using [PostExtractionHookConfiguration](https://docs.aws.amazon.com/enterpriseq/latest/APIReference/API_CustomDocumentEnrichmentConfiguration.html). You can only invoke one Lambda function. However, this function can invoke other functions it requires. For more information, see [Custom document enrichment](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/custom-document-enrichment.html).
        public var preExtractionHookConfiguration: QBusinessClientTypes.HookConfiguration?

        public init(
            inlineConfigurations: [QBusinessClientTypes.InlineDocumentEnrichmentConfiguration]? = nil,
            postExtractionHookConfiguration: QBusinessClientTypes.HookConfiguration? = nil,
            preExtractionHookConfiguration: QBusinessClientTypes.HookConfiguration? = nil
        )
        {
            self.inlineConfigurations = inlineConfigurations
            self.postExtractionHookConfiguration = postExtractionHookConfiguration
            self.preExtractionHookConfiguration = preExtractionHookConfiguration
        }
    }

}

extension QBusinessClientTypes {
    public enum DocumentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleted
        case deleting
        case documentFailedToIndex
        case failed
        case indexed
        case processing
        case received
        case updated
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentStatus] {
            return [
                .deleted,
                .deleting,
                .documentFailedToIndex,
                .failed,
                .indexed,
                .processing,
                .received,
                .updated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .documentFailedToIndex: return "DOCUMENT_FAILED_TO_INDEX"
            case .failed: return "FAILED"
            case .indexed: return "INDEXED"
            case .processing: return "PROCESSING"
            case .received: return "RECEIVED"
            case .updated: return "UPDATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DocumentStatus(rawValue: rawValue) ?? DocumentStatus.sdkUnknown(rawValue)
        }
    }
}

extension QBusinessClientTypes.EligibleDataSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceId
        case indexId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceId = self.dataSourceId {
            try encodeContainer.encode(dataSourceId, forKey: .dataSourceId)
        }
        if let indexId = self.indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
    }
}

extension QBusinessClientTypes {
    /// The identifier of the data source Amazon Q will generate responses from.
    public struct EligibleDataSource: Swift.Equatable {
        /// The identifier of the data source.
        public var dataSourceId: Swift.String?
        /// The identifier of the index the data source is attached to.
        public var indexId: Swift.String?

        public init(
            dataSourceId: Swift.String? = nil,
            indexId: Swift.String? = nil
        )
        {
            self.dataSourceId = dataSourceId
            self.indexId = indexId
        }
    }

}

extension QBusinessClientTypes.EncryptionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension QBusinessClientTypes.EncryptionConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EncryptionConfiguration(kmsKeyId: \"CONTENT_REDACTED\")"}
}

extension QBusinessClientTypes {
    /// Provides the identifier of the KMS key used to encrypt data indexed by Amazon Q. Amazon Q doesn't support asymmetric keys.
    public struct EncryptionConfiguration: Swift.Equatable {
        /// The identifier of the KMS key. Amazon Q doesn't support asymmetric keys.
        public var kmsKeyId: Swift.String?

        public init(
            kmsKeyId: Swift.String? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
        }
    }

}

extension QBusinessClientTypes {
    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internalError
        case invalidRequest
        case resourceInactive
        case resourceNotFound
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .internalError,
                .invalidRequest,
                .resourceInactive,
                .resourceNotFound,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internalError: return "InternalError"
            case .invalidRequest: return "InvalidRequest"
            case .resourceInactive: return "ResourceInactive"
            case .resourceNotFound: return "ResourceNotFound"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension QBusinessClientTypes.ErrorDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
    }
}

extension QBusinessClientTypes {
    /// Provides information about a data source sync error.
    public struct ErrorDetail: Swift.Equatable {
        /// The code associated with the data source sync error.
        public var errorCode: QBusinessClientTypes.ErrorCode?
        /// The message explaining the data source sync error.
        public var errorMessage: Swift.String?

        public init(
            errorCode: QBusinessClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension QBusinessClientTypes.FailedDocument: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceId
        case error
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceId = self.dataSourceId {
            try encodeContainer.encode(dataSourceId, forKey: .dataSourceId)
        }
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let errorDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.ErrorDetail.self, forKey: .error)
        error = errorDecoded
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
    }
}

extension QBusinessClientTypes {
    /// A list of documents that could not be removed from an Amazon Q index. Each entry contains an error message that indicates why the document couldn't be removed from the index.
    public struct FailedDocument: Swift.Equatable {
        /// The identifier of the Amazon Q data source connector that contains the failed document.
        public var dataSourceId: Swift.String?
        /// An explanation for why the document couldn't be removed from the index.
        public var error: QBusinessClientTypes.ErrorDetail?
        /// The identifier of the document that couldn't be removed from the Amazon Q index.
        public var id: Swift.String?

        public init(
            dataSourceId: Swift.String? = nil,
            error: QBusinessClientTypes.ErrorDetail? = nil,
            id: Swift.String? = nil
        )
        {
            self.dataSourceId = dataSourceId
            self.error = error
            self.id = id
        }
    }

}

extension GetApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())"
    }
}

public struct GetApplicationInput: Swift.Equatable {
    /// The identifier of the Amazon Q application.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct GetApplicationInputBody: Swift.Equatable {
}

extension GetApplicationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationArn = output.applicationArn
            self.applicationId = output.applicationId
            self.attachmentsConfiguration = output.attachmentsConfiguration
            self.createdAt = output.createdAt
            self.description = output.description
            self.displayName = output.displayName
            self.encryptionConfiguration = output.encryptionConfiguration
            self.error = output.error
            self.roleArn = output.roleArn
            self.status = output.status
            self.updatedAt = output.updatedAt
        } else {
            self.applicationArn = nil
            self.applicationId = nil
            self.attachmentsConfiguration = nil
            self.createdAt = nil
            self.description = nil
            self.displayName = nil
            self.encryptionConfiguration = nil
            self.error = nil
            self.roleArn = nil
            self.status = nil
            self.updatedAt = nil
        }
    }
}

public struct GetApplicationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Amazon Q application.
    public var applicationArn: Swift.String?
    /// The identifier of the Amazon Q application.
    public var applicationId: Swift.String?
    /// Settings for whether end users can upload files directly during chat.
    public var attachmentsConfiguration: QBusinessClientTypes.AppliedAttachmentsConfiguration?
    /// The Unix timestamp when the Amazon Q application was last updated.
    public var createdAt: ClientRuntime.Date?
    /// A description for the Amazon Q application.
    public var description: Swift.String?
    /// The name of the Amazon Q application.
    public var displayName: Swift.String?
    /// The identifier of the Amazon Web Services KMS key that is used to encrypt your data. Amazon Q doesn't support asymmetric keys.
    public var encryptionConfiguration: QBusinessClientTypes.EncryptionConfiguration?
    /// If the Status field is set to ERROR, the ErrorMessage field contains a description of the error that caused the synchronization to fail.
    public var error: QBusinessClientTypes.ErrorDetail?
    /// The Amazon Resource Name (ARN) of the IAM with permissions to access your CloudWatch logs and metrics.
    public var roleArn: Swift.String?
    /// The status of the Amazon Q application.
    public var status: QBusinessClientTypes.ApplicationStatus?
    /// The Unix timestamp when the Amazon Q application was last updated.
    public var updatedAt: ClientRuntime.Date?

    public init(
        applicationArn: Swift.String? = nil,
        applicationId: Swift.String? = nil,
        attachmentsConfiguration: QBusinessClientTypes.AppliedAttachmentsConfiguration? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        encryptionConfiguration: QBusinessClientTypes.EncryptionConfiguration? = nil,
        error: QBusinessClientTypes.ErrorDetail? = nil,
        roleArn: Swift.String? = nil,
        status: QBusinessClientTypes.ApplicationStatus? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.applicationArn = applicationArn
        self.applicationId = applicationId
        self.attachmentsConfiguration = attachmentsConfiguration
        self.createdAt = createdAt
        self.description = description
        self.displayName = displayName
        self.encryptionConfiguration = encryptionConfiguration
        self.error = error
        self.roleArn = roleArn
        self.status = status
        self.updatedAt = updatedAt
    }
}

struct GetApplicationOutputBody: Swift.Equatable {
    let displayName: Swift.String?
    let applicationId: Swift.String?
    let applicationArn: Swift.String?
    let roleArn: Swift.String?
    let status: QBusinessClientTypes.ApplicationStatus?
    let description: Swift.String?
    let encryptionConfiguration: QBusinessClientTypes.EncryptionConfiguration?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let error: QBusinessClientTypes.ErrorDetail?
    let attachmentsConfiguration: QBusinessClientTypes.AppliedAttachmentsConfiguration?
}

extension GetApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn
        case applicationId
        case attachmentsConfiguration
        case createdAt
        case description
        case displayName
        case encryptionConfiguration
        case error
        case roleArn
        case status
        case updatedAt
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.ApplicationStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.EncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let errorDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.ErrorDetail.self, forKey: .error)
        error = errorDecoded
        let attachmentsConfigurationDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.AppliedAttachmentsConfiguration.self, forKey: .attachmentsConfiguration)
        attachmentsConfiguration = attachmentsConfigurationDecoded
    }
}

enum GetApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetChatControlsConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension GetChatControlsConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/chatcontrols"
    }
}

public struct GetChatControlsConfigurationInput: Swift.Equatable {
    /// The identifier of the application for which the chat controls are configured.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The maximum number of configured chat controls to return.
    public var maxResults: Swift.Int?
    /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q returns a pagination token in the response. You can use this pagination token to retrieve the next set of Amazon Q chat controls configured.
    public var nextToken: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetChatControlsConfigurationInputBody: Swift.Equatable {
}

extension GetChatControlsConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetChatControlsConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetChatControlsConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.blockedPhrases = output.blockedPhrases
            self.nextToken = output.nextToken
            self.responseScope = output.responseScope
            self.topicConfigurations = output.topicConfigurations
        } else {
            self.blockedPhrases = nil
            self.nextToken = nil
            self.responseScope = nil
            self.topicConfigurations = nil
        }
    }
}

public struct GetChatControlsConfigurationOutput: Swift.Equatable {
    /// The phrases blocked from chat by your chat control configuration.
    public var blockedPhrases: QBusinessClientTypes.BlockedPhrasesConfiguration?
    /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q returns a pagination token in the response. You can use this pagination token to retrieve the next set of Amazon Q chat controls configured.
    public var nextToken: Swift.String?
    /// The response scope configured for a Amazon Q application. This determines whether your application uses its retrieval augmented generation (RAG) system to generate answers only from your enterprise data, or also uses the large language models (LLM) knowledge to respons to end user questions in chat.
    public var responseScope: QBusinessClientTypes.ResponseScope?
    /// The topic specific controls configured for a Amazon Q application.
    public var topicConfigurations: [QBusinessClientTypes.TopicConfiguration]?

    public init(
        blockedPhrases: QBusinessClientTypes.BlockedPhrasesConfiguration? = nil,
        nextToken: Swift.String? = nil,
        responseScope: QBusinessClientTypes.ResponseScope? = nil,
        topicConfigurations: [QBusinessClientTypes.TopicConfiguration]? = nil
    )
    {
        self.blockedPhrases = blockedPhrases
        self.nextToken = nextToken
        self.responseScope = responseScope
        self.topicConfigurations = topicConfigurations
    }
}

struct GetChatControlsConfigurationOutputBody: Swift.Equatable {
    let responseScope: QBusinessClientTypes.ResponseScope?
    let blockedPhrases: QBusinessClientTypes.BlockedPhrasesConfiguration?
    let topicConfigurations: [QBusinessClientTypes.TopicConfiguration]?
    let nextToken: Swift.String?
}

extension GetChatControlsConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockedPhrases
        case nextToken
        case responseScope
        case topicConfigurations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseScopeDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.ResponseScope.self, forKey: .responseScope)
        responseScope = responseScopeDecoded
        let blockedPhrasesDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.BlockedPhrasesConfiguration.self, forKey: .blockedPhrases)
        blockedPhrases = blockedPhrasesDecoded
        let topicConfigurationsContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.TopicConfiguration?].self, forKey: .topicConfigurations)
        var topicConfigurationsDecoded0:[QBusinessClientTypes.TopicConfiguration]? = nil
        if let topicConfigurationsContainer = topicConfigurationsContainer {
            topicConfigurationsDecoded0 = [QBusinessClientTypes.TopicConfiguration]()
            for structure0 in topicConfigurationsContainer {
                if let structure0 = structure0 {
                    topicConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        topicConfigurations = topicConfigurationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetChatControlsConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDataSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let indexId = indexId else {
            return nil
        }
        guard let dataSourceId = dataSourceId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/indices/\(indexId.urlPercentEncoding())/datasources/\(dataSourceId.urlPercentEncoding())"
    }
}

public struct GetDataSourceInput: Swift.Equatable {
    /// The identifier of the Amazon Q application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the data source connector.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// The identfier of the index used with the data source connector.
    /// This member is required.
    public var indexId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        indexId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.dataSourceId = dataSourceId
        self.indexId = indexId
    }
}

struct GetDataSourceInputBody: Swift.Equatable {
}

extension GetDataSourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDataSourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDataSourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.configuration = output.configuration
            self.createdAt = output.createdAt
            self.dataSourceArn = output.dataSourceArn
            self.dataSourceId = output.dataSourceId
            self.description = output.description
            self.displayName = output.displayName
            self.documentEnrichmentConfiguration = output.documentEnrichmentConfiguration
            self.error = output.error
            self.indexId = output.indexId
            self.roleArn = output.roleArn
            self.status = output.status
            self.syncSchedule = output.syncSchedule
            self.type = output.type
            self.updatedAt = output.updatedAt
            self.vpcConfiguration = output.vpcConfiguration
        } else {
            self.applicationId = nil
            self.configuration = nil
            self.createdAt = nil
            self.dataSourceArn = nil
            self.dataSourceId = nil
            self.description = nil
            self.displayName = nil
            self.documentEnrichmentConfiguration = nil
            self.error = nil
            self.indexId = nil
            self.roleArn = nil
            self.status = nil
            self.syncSchedule = nil
            self.type = nil
            self.updatedAt = nil
            self.vpcConfiguration = nil
        }
    }
}

public struct GetDataSourceOutput: Swift.Equatable {
    /// The identifier of the Amazon Q application.
    public var applicationId: Swift.String?
    /// The details of how the data source connector is configured.
    public var configuration: ClientRuntime.Document?
    /// The Unix timestamp when the data source connector was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the data source.
    public var dataSourceArn: Swift.String?
    /// The identifier of the data source connector.
    public var dataSourceId: Swift.String?
    /// The description for the data source connector.
    public var description: Swift.String?
    /// The name for the data source connector.
    public var displayName: Swift.String?
    /// Provides the configuration information for altering document metadata and content during the document ingestion process. For more information, see [Custom document enrichment](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/custom-document-enrichment.html).
    public var documentEnrichmentConfiguration: QBusinessClientTypes.DocumentEnrichmentConfiguration?
    /// When the Status field value is FAILED, the ErrorMessage field contains a description of the error that caused the data source connector to fail.
    public var error: QBusinessClientTypes.ErrorDetail?
    /// The identifier of the index linked to the data source connector.
    public var indexId: Swift.String?
    /// The Amazon Resource Name (ARN) of the role with permission to access the data source and required resources.
    public var roleArn: Swift.String?
    /// The current status of the data source connector. When the Status field value is FAILED, the ErrorMessage field contains a description of the error that caused the data source connector to fail.
    public var status: QBusinessClientTypes.DataSourceStatus?
    /// The schedule for Amazon Q to update the index.
    public var syncSchedule: Swift.String?
    /// The type of the data source connector. For example, S3.
    public var type: Swift.String?
    /// The Unix timestamp when the data source connector was last updated.
    public var updatedAt: ClientRuntime.Date?
    /// Configuration information for an Amazon VPC (Virtual Private Cloud) to connect to your data source.
    public var vpcConfiguration: QBusinessClientTypes.DataSourceVpcConfiguration?

    public init(
        applicationId: Swift.String? = nil,
        configuration: ClientRuntime.Document? = nil,
        createdAt: ClientRuntime.Date? = nil,
        dataSourceArn: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        documentEnrichmentConfiguration: QBusinessClientTypes.DocumentEnrichmentConfiguration? = nil,
        error: QBusinessClientTypes.ErrorDetail? = nil,
        indexId: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        status: QBusinessClientTypes.DataSourceStatus? = nil,
        syncSchedule: Swift.String? = nil,
        type: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        vpcConfiguration: QBusinessClientTypes.DataSourceVpcConfiguration? = nil
    )
    {
        self.applicationId = applicationId
        self.configuration = configuration
        self.createdAt = createdAt
        self.dataSourceArn = dataSourceArn
        self.dataSourceId = dataSourceId
        self.description = description
        self.displayName = displayName
        self.documentEnrichmentConfiguration = documentEnrichmentConfiguration
        self.error = error
        self.indexId = indexId
        self.roleArn = roleArn
        self.status = status
        self.syncSchedule = syncSchedule
        self.type = type
        self.updatedAt = updatedAt
        self.vpcConfiguration = vpcConfiguration
    }
}

struct GetDataSourceOutputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let indexId: Swift.String?
    let dataSourceId: Swift.String?
    let dataSourceArn: Swift.String?
    let displayName: Swift.String?
    let type: Swift.String?
    let configuration: ClientRuntime.Document?
    let vpcConfiguration: QBusinessClientTypes.DataSourceVpcConfiguration?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let description: Swift.String?
    let status: QBusinessClientTypes.DataSourceStatus?
    let syncSchedule: Swift.String?
    let roleArn: Swift.String?
    let error: QBusinessClientTypes.ErrorDetail?
    let documentEnrichmentConfiguration: QBusinessClientTypes.DocumentEnrichmentConfiguration?
}

extension GetDataSourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId
        case configuration
        case createdAt
        case dataSourceArn
        case dataSourceId
        case description
        case displayName
        case documentEnrichmentConfiguration
        case error
        case indexId
        case roleArn
        case status
        case syncSchedule
        case type
        case updatedAt
        case vpcConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let dataSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceArn)
        dataSourceArn = dataSourceArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .configuration)
        configuration = configurationDecoded
        let vpcConfigurationDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.DataSourceVpcConfiguration.self, forKey: .vpcConfiguration)
        vpcConfiguration = vpcConfigurationDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.DataSourceStatus.self, forKey: .status)
        status = statusDecoded
        let syncScheduleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncSchedule)
        syncSchedule = syncScheduleDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let errorDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.ErrorDetail.self, forKey: .error)
        error = errorDecoded
        let documentEnrichmentConfigurationDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.DocumentEnrichmentConfiguration.self, forKey: .documentEnrichmentConfiguration)
        documentEnrichmentConfiguration = documentEnrichmentConfigurationDecoded
    }
}

enum GetDataSourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetGroupInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let dataSourceId = dataSourceId {
                let dataSourceIdQueryItem = ClientRuntime.URLQueryItem(name: "dataSourceId".urlPercentEncoding(), value: Swift.String(dataSourceId).urlPercentEncoding())
                items.append(dataSourceIdQueryItem)
            }
            return items
        }
    }
}

extension GetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let indexId = indexId else {
            return nil
        }
        guard let groupName = groupName else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/indices/\(indexId.urlPercentEncoding())/groups/\(groupName.urlPercentEncoding())"
    }
}

public struct GetGroupInput: Swift.Equatable {
    /// The identifier of the application id the group is attached to.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the data source the group is attached to.
    public var dataSourceId: Swift.String?
    /// The name of the group.
    /// This member is required.
    public var groupName: Swift.String?
    /// The identifier of the index the group is attached to.
    /// This member is required.
    public var indexId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        groupName: Swift.String? = nil,
        indexId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.dataSourceId = dataSourceId
        self.groupName = groupName
        self.indexId = indexId
    }
}

struct GetGroupInputBody: Swift.Equatable {
}

extension GetGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
            self.statusHistory = output.statusHistory
        } else {
            self.status = nil
            self.statusHistory = nil
        }
    }
}

public struct GetGroupOutput: Swift.Equatable {
    /// The current status of the group.
    public var status: QBusinessClientTypes.GroupStatusDetail?
    /// The status history of the group.
    public var statusHistory: [QBusinessClientTypes.GroupStatusDetail]?

    public init(
        status: QBusinessClientTypes.GroupStatusDetail? = nil,
        statusHistory: [QBusinessClientTypes.GroupStatusDetail]? = nil
    )
    {
        self.status = status
        self.statusHistory = statusHistory
    }
}

struct GetGroupOutputBody: Swift.Equatable {
    let status: QBusinessClientTypes.GroupStatusDetail?
    let statusHistory: [QBusinessClientTypes.GroupStatusDetail]?
}

extension GetGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
        case statusHistory
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.GroupStatusDetail.self, forKey: .status)
        status = statusDecoded
        let statusHistoryContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.GroupStatusDetail?].self, forKey: .statusHistory)
        var statusHistoryDecoded0:[QBusinessClientTypes.GroupStatusDetail]? = nil
        if let statusHistoryContainer = statusHistoryContainer {
            statusHistoryDecoded0 = [QBusinessClientTypes.GroupStatusDetail]()
            for structure0 in statusHistoryContainer {
                if let structure0 = structure0 {
                    statusHistoryDecoded0?.append(structure0)
                }
            }
        }
        statusHistory = statusHistoryDecoded0
    }
}

enum GetGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetIndexInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let indexId = indexId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/indices/\(indexId.urlPercentEncoding())"
    }
}

public struct GetIndexInput: Swift.Equatable {
    /// The identifier of the Amazon Q application connected to the index.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the Amazon Q index you want information on.
    /// This member is required.
    public var indexId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        indexId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.indexId = indexId
    }
}

struct GetIndexInputBody: Swift.Equatable {
}

extension GetIndexInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetIndexOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetIndexOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.capacityConfiguration = output.capacityConfiguration
            self.createdAt = output.createdAt
            self.description = output.description
            self.displayName = output.displayName
            self.documentAttributeConfigurations = output.documentAttributeConfigurations
            self.error = output.error
            self.indexArn = output.indexArn
            self.indexId = output.indexId
            self.indexStatistics = output.indexStatistics
            self.status = output.status
            self.updatedAt = output.updatedAt
        } else {
            self.applicationId = nil
            self.capacityConfiguration = nil
            self.createdAt = nil
            self.description = nil
            self.displayName = nil
            self.documentAttributeConfigurations = nil
            self.error = nil
            self.indexArn = nil
            self.indexId = nil
            self.indexStatistics = nil
            self.status = nil
            self.updatedAt = nil
        }
    }
}

public struct GetIndexOutput: Swift.Equatable {
    /// The identifier of the Amazon Q application associated with the index.
    public var applicationId: Swift.String?
    /// The storage capacity units chosen for your Amazon Q index.
    public var capacityConfiguration: QBusinessClientTypes.IndexCapacityConfiguration?
    /// The Unix timestamp when the Amazon Q index was created.
    public var createdAt: ClientRuntime.Date?
    /// The description for the Amazon Q index.
    public var description: Swift.String?
    /// The name of the Amazon Q index.
    public var displayName: Swift.String?
    /// Configuration information for document attributes or metadata. Document metadata are fields associated with your documents. For example, the company department name associated with each document. For more information, see [Understanding document attributes](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/doc-attributes-types.html#doc-attributes).
    public var documentAttributeConfigurations: [QBusinessClientTypes.DocumentAttributeConfiguration]?
    /// When the Status field value is FAILED, the ErrorMessage field contains a message that explains why.
    public var error: QBusinessClientTypes.ErrorDetail?
    /// The Amazon Resource Name (ARN) of the Amazon Q index.
    public var indexArn: Swift.String?
    /// The identifier of the Amazon Q index.
    public var indexId: Swift.String?
    /// Provides information about the number of documents indexed.
    public var indexStatistics: QBusinessClientTypes.IndexStatistics?
    /// The current status of the index. When the value is ACTIVE, the index is ready for use. If the Status field value is FAILED, the ErrorMessage field contains a message that explains why.
    public var status: QBusinessClientTypes.IndexStatus?
    /// The Unix timestamp when the Amazon Q index was last updated.
    public var updatedAt: ClientRuntime.Date?

    public init(
        applicationId: Swift.String? = nil,
        capacityConfiguration: QBusinessClientTypes.IndexCapacityConfiguration? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        documentAttributeConfigurations: [QBusinessClientTypes.DocumentAttributeConfiguration]? = nil,
        error: QBusinessClientTypes.ErrorDetail? = nil,
        indexArn: Swift.String? = nil,
        indexId: Swift.String? = nil,
        indexStatistics: QBusinessClientTypes.IndexStatistics? = nil,
        status: QBusinessClientTypes.IndexStatus? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.applicationId = applicationId
        self.capacityConfiguration = capacityConfiguration
        self.createdAt = createdAt
        self.description = description
        self.displayName = displayName
        self.documentAttributeConfigurations = documentAttributeConfigurations
        self.error = error
        self.indexArn = indexArn
        self.indexId = indexId
        self.indexStatistics = indexStatistics
        self.status = status
        self.updatedAt = updatedAt
    }
}

struct GetIndexOutputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let indexId: Swift.String?
    let displayName: Swift.String?
    let indexArn: Swift.String?
    let status: QBusinessClientTypes.IndexStatus?
    let description: Swift.String?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let capacityConfiguration: QBusinessClientTypes.IndexCapacityConfiguration?
    let documentAttributeConfigurations: [QBusinessClientTypes.DocumentAttributeConfiguration]?
    let error: QBusinessClientTypes.ErrorDetail?
    let indexStatistics: QBusinessClientTypes.IndexStatistics?
}

extension GetIndexOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId
        case capacityConfiguration
        case createdAt
        case description
        case displayName
        case documentAttributeConfigurations
        case error
        case indexArn
        case indexId
        case indexStatistics
        case status
        case updatedAt
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let indexArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexArn)
        indexArn = indexArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.IndexStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let capacityConfigurationDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.IndexCapacityConfiguration.self, forKey: .capacityConfiguration)
        capacityConfiguration = capacityConfigurationDecoded
        let documentAttributeConfigurationsContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.DocumentAttributeConfiguration?].self, forKey: .documentAttributeConfigurations)
        var documentAttributeConfigurationsDecoded0:[QBusinessClientTypes.DocumentAttributeConfiguration]? = nil
        if let documentAttributeConfigurationsContainer = documentAttributeConfigurationsContainer {
            documentAttributeConfigurationsDecoded0 = [QBusinessClientTypes.DocumentAttributeConfiguration]()
            for structure0 in documentAttributeConfigurationsContainer {
                if let structure0 = structure0 {
                    documentAttributeConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        documentAttributeConfigurations = documentAttributeConfigurationsDecoded0
        let errorDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.ErrorDetail.self, forKey: .error)
        error = errorDecoded
        let indexStatisticsDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.IndexStatistics.self, forKey: .indexStatistics)
        indexStatistics = indexStatisticsDecoded
    }
}

enum GetIndexOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPluginInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let pluginId = pluginId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/plugins/\(pluginId.urlPercentEncoding())"
    }
}

public struct GetPluginInput: Swift.Equatable {
    /// The identifier of the application which contains the plugin.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the plugin.
    /// This member is required.
    public var pluginId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        pluginId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.pluginId = pluginId
    }
}

struct GetPluginInputBody: Swift.Equatable {
}

extension GetPluginInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPluginOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPluginOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.authConfiguration = output.authConfiguration
            self.createdAt = output.createdAt
            self.displayName = output.displayName
            self.pluginArn = output.pluginArn
            self.pluginId = output.pluginId
            self.serverUrl = output.serverUrl
            self.state = output.state
            self.type = output.type
            self.updatedAt = output.updatedAt
        } else {
            self.applicationId = nil
            self.authConfiguration = nil
            self.createdAt = nil
            self.displayName = nil
            self.pluginArn = nil
            self.pluginId = nil
            self.serverUrl = nil
            self.state = nil
            self.type = nil
            self.updatedAt = nil
        }
    }
}

public struct GetPluginOutput: Swift.Equatable {
    /// The identifier of the application which contains the plugin.
    public var applicationId: Swift.String?
    /// Authentication configuration information for an Amazon Q plugin.
    public var authConfiguration: QBusinessClientTypes.PluginAuthConfiguration?
    /// The timestamp for when the plugin was created.
    public var createdAt: ClientRuntime.Date?
    /// The name of the plugin.
    public var displayName: Swift.String?
    /// The Amazon Resource Name (ARN) of the role with permission to access resources needed to create the plugin.
    public var pluginArn: Swift.String?
    /// The identifier of the plugin.
    public var pluginId: Swift.String?
    /// The source URL used for plugin configuration.
    public var serverUrl: Swift.String?
    /// The current state of the plugin.
    public var state: QBusinessClientTypes.PluginState?
    /// The type of the plugin.
    public var type: QBusinessClientTypes.PluginType?
    /// The timestamp for when the plugin was last updated.
    public var updatedAt: ClientRuntime.Date?

    public init(
        applicationId: Swift.String? = nil,
        authConfiguration: QBusinessClientTypes.PluginAuthConfiguration? = nil,
        createdAt: ClientRuntime.Date? = nil,
        displayName: Swift.String? = nil,
        pluginArn: Swift.String? = nil,
        pluginId: Swift.String? = nil,
        serverUrl: Swift.String? = nil,
        state: QBusinessClientTypes.PluginState? = nil,
        type: QBusinessClientTypes.PluginType? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.applicationId = applicationId
        self.authConfiguration = authConfiguration
        self.createdAt = createdAt
        self.displayName = displayName
        self.pluginArn = pluginArn
        self.pluginId = pluginId
        self.serverUrl = serverUrl
        self.state = state
        self.type = type
        self.updatedAt = updatedAt
    }
}

struct GetPluginOutputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let pluginId: Swift.String?
    let displayName: Swift.String?
    let type: QBusinessClientTypes.PluginType?
    let serverUrl: Swift.String?
    let authConfiguration: QBusinessClientTypes.PluginAuthConfiguration?
    let pluginArn: Swift.String?
    let state: QBusinessClientTypes.PluginState?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
}

extension GetPluginOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId
        case authConfiguration
        case createdAt
        case displayName
        case pluginArn
        case pluginId
        case serverUrl
        case state
        case type
        case updatedAt
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let pluginIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pluginId)
        pluginId = pluginIdDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.PluginType.self, forKey: .type)
        type = typeDecoded
        let serverUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverUrl)
        serverUrl = serverUrlDecoded
        let authConfigurationDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.PluginAuthConfiguration.self, forKey: .authConfiguration)
        authConfiguration = authConfigurationDecoded
        let pluginArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pluginArn)
        pluginArn = pluginArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.PluginState.self, forKey: .state)
        state = stateDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

enum GetPluginOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRetrieverInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let retrieverId = retrieverId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/retrievers/\(retrieverId.urlPercentEncoding())"
    }
}

public struct GetRetrieverInput: Swift.Equatable {
    /// The identifier of the Amazon Q application using the retriever.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the retriever.
    /// This member is required.
    public var retrieverId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        retrieverId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.retrieverId = retrieverId
    }
}

struct GetRetrieverInputBody: Swift.Equatable {
}

extension GetRetrieverInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetRetrieverOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRetrieverOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.configuration = output.configuration
            self.createdAt = output.createdAt
            self.displayName = output.displayName
            self.retrieverArn = output.retrieverArn
            self.retrieverId = output.retrieverId
            self.roleArn = output.roleArn
            self.status = output.status
            self.type = output.type
            self.updatedAt = output.updatedAt
        } else {
            self.applicationId = nil
            self.configuration = nil
            self.createdAt = nil
            self.displayName = nil
            self.retrieverArn = nil
            self.retrieverId = nil
            self.roleArn = nil
            self.status = nil
            self.type = nil
            self.updatedAt = nil
        }
    }
}

public struct GetRetrieverOutput: Swift.Equatable {
    /// The identifier of the Amazon Q application using the retriever.
    public var applicationId: Swift.String?
    /// Provides information on how the retriever used for your Amazon Q application is configured.
    public var configuration: QBusinessClientTypes.RetrieverConfiguration?
    /// The Unix timestamp when the retriever was created.
    public var createdAt: ClientRuntime.Date?
    /// The name of the retriever.
    public var displayName: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role associated with the retriever.
    public var retrieverArn: Swift.String?
    /// The identifier of the retriever.
    public var retrieverId: Swift.String?
    /// The Amazon Resource Name (ARN) of the role with the permission to access the retriever and required resources.
    public var roleArn: Swift.String?
    /// The status of the retriever.
    public var status: QBusinessClientTypes.RetrieverStatus?
    /// The type of the retriever.
    public var type: QBusinessClientTypes.RetrieverType?
    /// The Unix timestamp when the retriever was last updated.
    public var updatedAt: ClientRuntime.Date?

    public init(
        applicationId: Swift.String? = nil,
        configuration: QBusinessClientTypes.RetrieverConfiguration? = nil,
        createdAt: ClientRuntime.Date? = nil,
        displayName: Swift.String? = nil,
        retrieverArn: Swift.String? = nil,
        retrieverId: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        status: QBusinessClientTypes.RetrieverStatus? = nil,
        type: QBusinessClientTypes.RetrieverType? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.applicationId = applicationId
        self.configuration = configuration
        self.createdAt = createdAt
        self.displayName = displayName
        self.retrieverArn = retrieverArn
        self.retrieverId = retrieverId
        self.roleArn = roleArn
        self.status = status
        self.type = type
        self.updatedAt = updatedAt
    }
}

struct GetRetrieverOutputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let retrieverId: Swift.String?
    let retrieverArn: Swift.String?
    let type: QBusinessClientTypes.RetrieverType?
    let status: QBusinessClientTypes.RetrieverStatus?
    let displayName: Swift.String?
    let configuration: QBusinessClientTypes.RetrieverConfiguration?
    let roleArn: Swift.String?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
}

extension GetRetrieverOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId
        case configuration
        case createdAt
        case displayName
        case retrieverArn
        case retrieverId
        case roleArn
        case status
        case type
        case updatedAt
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let retrieverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .retrieverId)
        retrieverId = retrieverIdDecoded
        let retrieverArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .retrieverArn)
        retrieverArn = retrieverArnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.RetrieverType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.RetrieverStatus.self, forKey: .status)
        status = statusDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.RetrieverConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

enum GetRetrieverOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let userId = userId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/users/\(userId.urlPercentEncoding())"
    }
}

public struct GetUserInput: Swift.Equatable {
    /// The identifier of the application connected to the user.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The user email address attached to the user.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.userId = userId
    }
}

struct GetUserInputBody: Swift.Equatable {
}

extension GetUserInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.userAliases = output.userAliases
        } else {
            self.userAliases = nil
        }
    }
}

public struct GetUserOutput: Swift.Equatable {
    /// A list of user aliases attached to a user.
    public var userAliases: [QBusinessClientTypes.UserAlias]?

    public init(
        userAliases: [QBusinessClientTypes.UserAlias]? = nil
    )
    {
        self.userAliases = userAliases
    }
}

struct GetUserOutputBody: Swift.Equatable {
    let userAliases: [QBusinessClientTypes.UserAlias]?
}

extension GetUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userAliases
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userAliasesContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.UserAlias?].self, forKey: .userAliases)
        var userAliasesDecoded0:[QBusinessClientTypes.UserAlias]? = nil
        if let userAliasesContainer = userAliasesContainer {
            userAliasesDecoded0 = [QBusinessClientTypes.UserAlias]()
            for structure0 in userAliasesContainer {
                if let structure0 = structure0 {
                    userAliasesDecoded0?.append(structure0)
                }
            }
        }
        userAliases = userAliasesDecoded0
    }
}

enum GetUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetWebExperienceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let webExperienceId = webExperienceId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/experiences/\(webExperienceId.urlPercentEncoding())"
    }
}

public struct GetWebExperienceInput: Swift.Equatable {
    /// The identifier of the Amazon Q application linked to the web experience.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the Amazon Q web experience.
    /// This member is required.
    public var webExperienceId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        webExperienceId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.webExperienceId = webExperienceId
    }
}

struct GetWebExperienceInputBody: Swift.Equatable {
}

extension GetWebExperienceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetWebExperienceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetWebExperienceOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.authenticationConfiguration = output.authenticationConfiguration
            self.createdAt = output.createdAt
            self.defaultEndpoint = output.defaultEndpoint
            self.error = output.error
            self.samplePromptsControlMode = output.samplePromptsControlMode
            self.status = output.status
            self.subtitle = output.subtitle
            self.title = output.title
            self.updatedAt = output.updatedAt
            self.webExperienceArn = output.webExperienceArn
            self.webExperienceId = output.webExperienceId
            self.welcomeMessage = output.welcomeMessage
        } else {
            self.applicationId = nil
            self.authenticationConfiguration = nil
            self.createdAt = nil
            self.defaultEndpoint = nil
            self.error = nil
            self.samplePromptsControlMode = nil
            self.status = nil
            self.subtitle = nil
            self.title = nil
            self.updatedAt = nil
            self.webExperienceArn = nil
            self.webExperienceId = nil
            self.welcomeMessage = nil
        }
    }
}

public struct GetWebExperienceOutput: Swift.Equatable {
    /// The identifier of the Amazon Q application linked to the web experience.
    public var applicationId: Swift.String?
    /// The authentication configuration information for your Amazon Q web experience.
    public var authenticationConfiguration: QBusinessClientTypes.WebExperienceAuthConfiguration?
    /// The Unix timestamp when the retriever was created.
    public var createdAt: ClientRuntime.Date?
    /// The endpoint of your Amazon Q web experience.
    public var defaultEndpoint: Swift.String?
    /// When the Status field value is FAILED, the ErrorMessage field contains a description of the error that caused the data source connector to fail.
    public var error: QBusinessClientTypes.ErrorDetail?
    /// Determines whether sample prompts are enabled in the web experience for an end user.
    public var samplePromptsControlMode: QBusinessClientTypes.WebExperienceSamplePromptsControlMode?
    /// The current status of the Amazon Q web experience. When the Status field value is FAILED, the ErrorMessage field contains a description of the error that caused the data source connector to fail.
    public var status: QBusinessClientTypes.WebExperienceStatus?
    /// The subtitle for your Amazon Q web experience.
    public var subtitle: Swift.String?
    /// The title for your Amazon Q web experience.
    public var title: Swift.String?
    /// The Unix timestamp when the data source connector was last updated.
    public var updatedAt: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the role with the permission to access the Amazon Q web experience and required resources.
    public var webExperienceArn: Swift.String?
    /// The identifier of the Amazon Q web experience.
    public var webExperienceId: Swift.String?
    /// The customized welcome message for end users of an Amazon Q web experience.
    public var welcomeMessage: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        authenticationConfiguration: QBusinessClientTypes.WebExperienceAuthConfiguration? = nil,
        createdAt: ClientRuntime.Date? = nil,
        defaultEndpoint: Swift.String? = nil,
        error: QBusinessClientTypes.ErrorDetail? = nil,
        samplePromptsControlMode: QBusinessClientTypes.WebExperienceSamplePromptsControlMode? = nil,
        status: QBusinessClientTypes.WebExperienceStatus? = nil,
        subtitle: Swift.String? = nil,
        title: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        webExperienceArn: Swift.String? = nil,
        webExperienceId: Swift.String? = nil,
        welcomeMessage: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.authenticationConfiguration = authenticationConfiguration
        self.createdAt = createdAt
        self.defaultEndpoint = defaultEndpoint
        self.error = error
        self.samplePromptsControlMode = samplePromptsControlMode
        self.status = status
        self.subtitle = subtitle
        self.title = title
        self.updatedAt = updatedAt
        self.webExperienceArn = webExperienceArn
        self.webExperienceId = webExperienceId
        self.welcomeMessage = welcomeMessage
    }
}

struct GetWebExperienceOutputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let webExperienceId: Swift.String?
    let webExperienceArn: Swift.String?
    let defaultEndpoint: Swift.String?
    let status: QBusinessClientTypes.WebExperienceStatus?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let title: Swift.String?
    let subtitle: Swift.String?
    let welcomeMessage: Swift.String?
    let samplePromptsControlMode: QBusinessClientTypes.WebExperienceSamplePromptsControlMode?
    let authenticationConfiguration: QBusinessClientTypes.WebExperienceAuthConfiguration?
    let error: QBusinessClientTypes.ErrorDetail?
}

extension GetWebExperienceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId
        case authenticationConfiguration
        case createdAt
        case defaultEndpoint
        case error
        case samplePromptsControlMode
        case status
        case subtitle
        case title
        case updatedAt
        case webExperienceArn
        case webExperienceId
        case welcomeMessage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let webExperienceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webExperienceId)
        webExperienceId = webExperienceIdDecoded
        let webExperienceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webExperienceArn)
        webExperienceArn = webExperienceArnDecoded
        let defaultEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultEndpoint)
        defaultEndpoint = defaultEndpointDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.WebExperienceStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let subtitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subtitle)
        subtitle = subtitleDecoded
        let welcomeMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .welcomeMessage)
        welcomeMessage = welcomeMessageDecoded
        let samplePromptsControlModeDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.WebExperienceSamplePromptsControlMode.self, forKey: .samplePromptsControlMode)
        samplePromptsControlMode = samplePromptsControlModeDecoded
        let authenticationConfigurationDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.WebExperienceAuthConfiguration.self, forKey: .authenticationConfiguration)
        authenticationConfiguration = authenticationConfigurationDecoded
        let errorDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.ErrorDetail.self, forKey: .error)
        error = errorDecoded
    }
}

enum GetWebExperienceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension QBusinessClientTypes.GroupMembers: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberGroups
        case memberUsers
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberGroups = memberGroups {
            var memberGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .memberGroups)
            for membergroup0 in memberGroups {
                try memberGroupsContainer.encode(membergroup0)
            }
        }
        if let memberUsers = memberUsers {
            var memberUsersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .memberUsers)
            for memberuser0 in memberUsers {
                try memberUsersContainer.encode(memberuser0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberGroupsContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.MemberGroup?].self, forKey: .memberGroups)
        var memberGroupsDecoded0:[QBusinessClientTypes.MemberGroup]? = nil
        if let memberGroupsContainer = memberGroupsContainer {
            memberGroupsDecoded0 = [QBusinessClientTypes.MemberGroup]()
            for structure0 in memberGroupsContainer {
                if let structure0 = structure0 {
                    memberGroupsDecoded0?.append(structure0)
                }
            }
        }
        memberGroups = memberGroupsDecoded0
        let memberUsersContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.MemberUser?].self, forKey: .memberUsers)
        var memberUsersDecoded0:[QBusinessClientTypes.MemberUser]? = nil
        if let memberUsersContainer = memberUsersContainer {
            memberUsersDecoded0 = [QBusinessClientTypes.MemberUser]()
            for structure0 in memberUsersContainer {
                if let structure0 = structure0 {
                    memberUsersDecoded0?.append(structure0)
                }
            }
        }
        memberUsers = memberUsersDecoded0
    }
}

extension QBusinessClientTypes {
    /// A list of users or sub groups that belong to a group. This is for generating Amazon Q chat results only from document a user has access to.
    public struct GroupMembers: Swift.Equatable {
        /// A list of sub groups that belong to a group. For example, the sub groups "Research", "Engineering", and "Sales and Marketing" all belong to the group "Company".
        public var memberGroups: [QBusinessClientTypes.MemberGroup]?
        /// A list of users that belong to a group. For example, a list of interns all belong to the "Interns" group.
        public var memberUsers: [QBusinessClientTypes.MemberUser]?

        public init(
            memberGroups: [QBusinessClientTypes.MemberGroup]? = nil,
            memberUsers: [QBusinessClientTypes.MemberUser]? = nil
        )
        {
            self.memberGroups = memberGroups
            self.memberUsers = memberUsers
        }
    }

}

extension QBusinessClientTypes {
    public enum GroupStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleted
        case deleting
        case failed
        case processing
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [GroupStatus] {
            return [
                .deleted,
                .deleting,
                .failed,
                .processing,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .processing: return "PROCESSING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GroupStatus(rawValue: rawValue) ?? GroupStatus.sdkUnknown(rawValue)
        }
    }
}

extension QBusinessClientTypes.GroupStatusDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorDetail
        case lastUpdatedAt
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorDetail = self.errorDetail {
            try encodeContainer.encode(errorDetail, forKey: .errorDetail)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.GroupStatus.self, forKey: .status)
        status = statusDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let errorDetailDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.ErrorDetail.self, forKey: .errorDetail)
        errorDetail = errorDetailDecoded
    }
}

extension QBusinessClientTypes {
    /// Provides the details of a group's status.
    public struct GroupStatusDetail: Swift.Equatable {
        /// The details of an error associated a group status.
        public var errorDetail: QBusinessClientTypes.ErrorDetail?
        /// The Unix timestamp when the Amazon Q application was last updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The status of a group.
        public var status: QBusinessClientTypes.GroupStatus?

        public init(
            errorDetail: QBusinessClientTypes.ErrorDetail? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            status: QBusinessClientTypes.GroupStatus? = nil
        )
        {
            self.errorDetail = errorDetail
            self.lastUpdatedAt = lastUpdatedAt
            self.status = status
        }
    }

}

extension QBusinessClientTypes.GroupSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
    }
}

extension QBusinessClientTypes {
    /// Summary information for groups.
    public struct GroupSummary: Swift.Equatable {
        /// The name of the group the summary information is for.
        public var groupName: Swift.String?

        public init(
            groupName: Swift.String? = nil
        )
        {
            self.groupName = groupName
        }
    }

}

extension QBusinessClientTypes.HookConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invocationCondition
        case lambdaArn
        case roleArn
        case s3BucketName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let invocationCondition = self.invocationCondition {
            try encodeContainer.encode(invocationCondition, forKey: .invocationCondition)
        }
        if let lambdaArn = self.lambdaArn {
            try encodeContainer.encode(lambdaArn, forKey: .lambdaArn)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invocationConditionDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.DocumentAttributeCondition.self, forKey: .invocationCondition)
        invocationCondition = invocationConditionDecoded
        let lambdaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lambdaArn)
        lambdaArn = lambdaArnDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension QBusinessClientTypes {
    /// Provides the configuration information for invoking a Lambda function in Lambda to alter document metadata and content when ingesting documents into Amazon Q. You can configure your Lambda function using [PreExtractionHookConfiguration](https://docs.aws.amazon.com/enterpriseq/latest/APIReference/API_CustomDocumentEnrichmentConfiguration.html) if you want to apply advanced alterations on the original or raw documents. If you want to apply advanced alterations on the Amazon Q structured documents, you must configure your Lambda function using [PostExtractionHookConfiguration](https://docs.aws.amazon.com/enterpriseq/latest/APIReference/API_CustomDocumentEnrichmentConfiguration.html). You can only invoke one Lambda function. However, this function can invoke other functions it requires. For more information, see [Custom document enrichment](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/custom-document-enrichment.html).
    public struct HookConfiguration: Swift.Equatable {
        /// The condition used for when a Lambda function should be invoked. For example, you can specify a condition that if there are empty date-time values, then Amazon Q should invoke a function that inserts the current date-time.
        public var invocationCondition: QBusinessClientTypes.DocumentAttributeCondition?
        /// The Amazon Resource Name (ARN) of a role with permission to run a Lambda function during ingestion. For more information, see [IAM roles for Custom Document Enrichment (CDE)](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/iam-roles.html#cde-iam-role).
        public var lambdaArn: Swift.String?
        /// The Amazon Resource Name (ARN) of a role with permission to run PreExtractionHookConfiguration and PostExtractionHookConfiguration for altering document metadata and content during the document ingestion process.
        public var roleArn: Swift.String?
        /// Stores the original, raw documents or the structured, parsed documents before and after altering them. For more information, see [Data contracts for Lambda functions](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/cde-lambda-operations.html#cde-lambda-operations-data-contracts).
        public var s3BucketName: Swift.String?

        public init(
            invocationCondition: QBusinessClientTypes.DocumentAttributeCondition? = nil,
            lambdaArn: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            s3BucketName: Swift.String? = nil
        )
        {
            self.invocationCondition = invocationCondition
            self.lambdaArn = lambdaArn
            self.roleArn = roleArn
            self.s3BucketName = s3BucketName
        }
    }

}

extension QBusinessClientTypes.Index: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case displayName
        case indexId
        case status
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let indexId = self.indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.IndexStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension QBusinessClientTypes {
    /// Summary information for your Amazon Q index.
    public struct Index: Swift.Equatable {
        /// The Unix timestamp when the index was created.
        public var createdAt: ClientRuntime.Date?
        /// The name of the index.
        public var displayName: Swift.String?
        /// The identifier for the index.
        public var indexId: Swift.String?
        /// The current status of the index. When the status is ACTIVE, the index is ready.
        public var status: QBusinessClientTypes.IndexStatus?
        /// The Unix timestamp when the index was last updated.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            displayName: Swift.String? = nil,
            indexId: Swift.String? = nil,
            status: QBusinessClientTypes.IndexStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.displayName = displayName
            self.indexId = indexId
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension QBusinessClientTypes.IndexCapacityConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case units
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let units = self.units {
            try encodeContainer.encode(units, forKey: .units)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .units)
        units = unitsDecoded
    }
}

extension QBusinessClientTypes {
    /// Provides information about index capacity configuration.
    public struct IndexCapacityConfiguration: Swift.Equatable {
        /// The number of storage units configured for an Amazon Q index.
        public var units: Swift.Int?

        public init(
            units: Swift.Int? = nil
        )
        {
            self.units = units
        }
    }

}

extension QBusinessClientTypes.IndexStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case textDocumentStatistics
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let textDocumentStatistics = self.textDocumentStatistics {
            try encodeContainer.encode(textDocumentStatistics, forKey: .textDocumentStatistics)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDocumentStatisticsDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.TextDocumentStatistics.self, forKey: .textDocumentStatistics)
        textDocumentStatistics = textDocumentStatisticsDecoded
    }
}

extension QBusinessClientTypes {
    /// Provides information about the number of documents in an index.
    public struct IndexStatistics: Swift.Equatable {
        /// The number of documents indexed.
        public var textDocumentStatistics: QBusinessClientTypes.TextDocumentStatistics?

        public init(
            textDocumentStatistics: QBusinessClientTypes.TextDocumentStatistics? = nil
        )
        {
            self.textDocumentStatistics = textDocumentStatistics
        }
    }

}

extension QBusinessClientTypes {
    public enum IndexStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [IndexStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IndexStatus(rawValue: rawValue) ?? IndexStatus.sdkUnknown(rawValue)
        }
    }
}

extension QBusinessClientTypes.InlineDocumentEnrichmentConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case condition
        case documentContentOperator
        case target
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let condition = self.condition {
            try encodeContainer.encode(condition, forKey: .condition)
        }
        if let documentContentOperator = self.documentContentOperator {
            try encodeContainer.encode(documentContentOperator.rawValue, forKey: .documentContentOperator)
        }
        if let target = self.target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conditionDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.DocumentAttributeCondition.self, forKey: .condition)
        condition = conditionDecoded
        let targetDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.DocumentAttributeTarget.self, forKey: .target)
        target = targetDecoded
        let documentContentOperatorDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.DocumentContentOperator.self, forKey: .documentContentOperator)
        documentContentOperator = documentContentOperatorDecoded
    }
}

extension QBusinessClientTypes {
    /// Provides the configuration information for applying basic logic to alter document metadata and content when ingesting documents into Amazon Q. To apply advanced logic, to go beyond what you can do with basic logic, see [HookConfiguration](https://docs.aws.amazon.com/enterpriseq/latest/APIReference/API_HookConfiguration.html). For more information, see [Custom document enrichment](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/custom-document-enrichment.html).
    public struct InlineDocumentEnrichmentConfiguration: Swift.Equatable {
        /// The condition used for the target document attribute or metadata field when ingesting documents into Amazon Q. You use this with [DocumentAttributeTarget](https://docs.aws.amazon.com/enterpriseq/latest/APIReference/API_DocumentAttributeTarget.html) to apply the condition. For example, you can create the 'Department' target field and have it prefill department names associated with the documents based on information in the 'Source_URI' field. Set the condition that if the 'Source_URI' field contains 'financial' in its URI value, then prefill the target field 'Department' with the target value 'Finance' for the document. Amazon Q can't create a target field if it has not already been created as an index field. After you create your index field, you can create a document metadata field using DocumentAttributeTarget. Amazon Q then will map your newly created metadata field to your index field.
        public var condition: QBusinessClientTypes.DocumentAttributeCondition?
        /// TRUE to delete content if the condition used for the target attribute is met.
        public var documentContentOperator: QBusinessClientTypes.DocumentContentOperator?
        /// The target document attribute or metadata field you want to alter when ingesting documents into Amazon Q. For example, you can delete all customer identification numbers associated with the documents, stored in the document metadata field called 'Customer_ID' by setting the target key as 'Customer_ID' and the deletion flag to TRUE. This removes all customer ID values in the field 'Customer_ID'. This would scrub personally identifiable information from each document's metadata. Amazon Q can't create a target field if it has not already been created as an index field. After you create your index field, you can create a document metadata field using [DocumentAttributeTarget](https://docs.aws.amazon.com/enterpriseq/latest/APIReference/API_DocumentAttributeTarget.html). Amazon Q will then map your newly created document attribute to your index field. You can also use this with [DocumentAttributeCondition](https://docs.aws.amazon.com/enterpriseq/latest/APIReference/API_DocumentAttributeCondition.html).
        public var target: QBusinessClientTypes.DocumentAttributeTarget?

        public init(
            condition: QBusinessClientTypes.DocumentAttributeCondition? = nil,
            documentContentOperator: QBusinessClientTypes.DocumentContentOperator? = nil,
            target: QBusinessClientTypes.DocumentAttributeTarget? = nil
        )
        {
            self.condition = condition
            self.documentContentOperator = documentContentOperator
            self.target = target
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An issue occurred with the internal server used for your Amazon Q service. Wait some minutes and try again, or contact [Support](http://aws.amazon.com/contact-us/) for help.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension QBusinessClientTypes.KendraIndexConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexId = self.indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
    }
}

extension QBusinessClientTypes {
    /// Stores an Amazon Kendra index as a retriever.
    public struct KendraIndexConfiguration: Swift.Equatable {
        /// The identifier of the Amazon Kendra index.
        /// This member is required.
        public var indexId: Swift.String?

        public init(
            indexId: Swift.String? = nil
        )
        {
            self.indexId = indexId
        }
    }

}

extension LicenseNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LicenseNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You don't have permissions to perform the action because your license is inactive. Ask your admin to activate your license and try again after your licence is active.
public struct LicenseNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LicenseNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LicenseNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LicenseNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListApplicationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListApplicationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/applications"
    }
}

public struct ListApplicationsInput: Swift.Equatable {
    /// The maximum number of Amazon Q applications to return.
    public var maxResults: Swift.Int?
    /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q returns a pagination token in the response. You can use this pagination token to retrieve the next set of Amazon Q applications.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApplicationsInputBody: Swift.Equatable {
}

extension ListApplicationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListApplicationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListApplicationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.applications = output.applications
            self.nextToken = output.nextToken
        } else {
            self.applications = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationsOutput: Swift.Equatable {
    /// An array of summary information on the configuration of one or more Amazon Q applications.
    public var applications: [QBusinessClientTypes.Application]?
    /// If the response is truncated, Amazon Q returns this token. You can use this token in a subsequent request to retrieve the next set of applications.
    public var nextToken: Swift.String?

    public init(
        applications: [QBusinessClientTypes.Application]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applications = applications
        self.nextToken = nextToken
    }
}

struct ListApplicationsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let applications: [QBusinessClientTypes.Application]?
}

extension ListApplicationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applications
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let applicationsContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.Application?].self, forKey: .applications)
        var applicationsDecoded0:[QBusinessClientTypes.Application]? = nil
        if let applicationsContainer = applicationsContainer {
            applicationsDecoded0 = [QBusinessClientTypes.Application]()
            for structure0 in applicationsContainer {
                if let structure0 = structure0 {
                    applicationsDecoded0?.append(structure0)
                }
            }
        }
        applications = applicationsDecoded0
    }
}

enum ListApplicationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListConversationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            guard let userId = userId else {
                let message = "Creating a URL Query Item failed. userId is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let userIdQueryItem = ClientRuntime.URLQueryItem(name: "userId".urlPercentEncoding(), value: Swift.String(userId).urlPercentEncoding())
            items.append(userIdQueryItem)
            return items
        }
    }
}

extension ListConversationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/conversations"
    }
}

public struct ListConversationsInput: Swift.Equatable {
    /// The identifier of the Amazon Q application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The maximum number of Amazon Q conversations to return.
    public var maxResults: Swift.Int?
    /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q returns a pagination token in the response. You can use this pagination token to retrieve the next set of Amazon Q conversations.
    public var nextToken: Swift.String?
    /// The identifier of the user involved in the Amazon Q web experience conversation.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.userId = userId
    }
}

struct ListConversationsInputBody: Swift.Equatable {
}

extension ListConversationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListConversationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListConversationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.conversations = output.conversations
            self.nextToken = output.nextToken
        } else {
            self.conversations = nil
            self.nextToken = nil
        }
    }
}

public struct ListConversationsOutput: Swift.Equatable {
    /// An array of summary information on the configuration of one or more Amazon Q web experiences.
    public var conversations: [QBusinessClientTypes.Conversation]?
    /// If the response is truncated, Amazon Q returns this token, which you can use in a later request to list the next set of messages.
    public var nextToken: Swift.String?

    public init(
        conversations: [QBusinessClientTypes.Conversation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.conversations = conversations
        self.nextToken = nextToken
    }
}

struct ListConversationsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let conversations: [QBusinessClientTypes.Conversation]?
}

extension ListConversationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conversations
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let conversationsContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.Conversation?].self, forKey: .conversations)
        var conversationsDecoded0:[QBusinessClientTypes.Conversation]? = nil
        if let conversationsContainer = conversationsContainer {
            conversationsDecoded0 = [QBusinessClientTypes.Conversation]()
            for structure0 in conversationsContainer {
                if let structure0 = structure0 {
                    conversationsDecoded0?.append(structure0)
                }
            }
        }
        conversations = conversationsDecoded0
    }
}

enum ListConversationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LicenseNotFoundException": return try await LicenseNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDataSourceSyncJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let statusFilter = statusFilter {
                let statusFilterQueryItem = ClientRuntime.URLQueryItem(name: "syncStatus".urlPercentEncoding(), value: Swift.String(statusFilter.rawValue).urlPercentEncoding())
                items.append(statusFilterQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let startTime = startTime {
                let startTimeQueryItem = ClientRuntime.URLQueryItem(name: "startTime".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: startTime)).urlPercentEncoding())
                items.append(startTimeQueryItem)
            }
            if let endTime = endTime {
                let endTimeQueryItem = ClientRuntime.URLQueryItem(name: "endTime".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: endTime)).urlPercentEncoding())
                items.append(endTimeQueryItem)
            }
            return items
        }
    }
}

extension ListDataSourceSyncJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let indexId = indexId else {
            return nil
        }
        guard let dataSourceId = dataSourceId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/indices/\(indexId.urlPercentEncoding())/datasources/\(dataSourceId.urlPercentEncoding())/syncjobs"
    }
}

public struct ListDataSourceSyncJobsInput: Swift.Equatable {
    /// The identifier of the Amazon Q application connected to the data source.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the data source connector.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// The end time of the data source connector sync.
    public var endTime: ClientRuntime.Date?
    /// The identifier of the index used with the Amazon Q data source connector.
    /// This member is required.
    public var indexId: Swift.String?
    /// The maximum number of synchronization jobs to return in the response.
    public var maxResults: Swift.Int?
    /// If the maxResults response was incpmplete because there is more data to retriever, Amazon Q returns a pagination token in the response. You can use this pagination token to retrieve the next set of responses.
    public var nextToken: Swift.String?
    /// The start time of the data source connector sync.
    public var startTime: ClientRuntime.Date?
    /// Only returns synchronization jobs with the Status field equal to the specified status.
    public var statusFilter: QBusinessClientTypes.DataSourceSyncJobStatus?

    public init(
        applicationId: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        endTime: ClientRuntime.Date? = nil,
        indexId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        statusFilter: QBusinessClientTypes.DataSourceSyncJobStatus? = nil
    )
    {
        self.applicationId = applicationId
        self.dataSourceId = dataSourceId
        self.endTime = endTime
        self.indexId = indexId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTime = startTime
        self.statusFilter = statusFilter
    }
}

struct ListDataSourceSyncJobsInputBody: Swift.Equatable {
}

extension ListDataSourceSyncJobsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDataSourceSyncJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDataSourceSyncJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.history = output.history
            self.nextToken = output.nextToken
        } else {
            self.history = nil
            self.nextToken = nil
        }
    }
}

public struct ListDataSourceSyncJobsOutput: Swift.Equatable {
    /// A history of synchronization jobs for the data source connector.
    public var history: [QBusinessClientTypes.DataSourceSyncJob]?
    /// If the response is truncated, Amazon Q returns this token. You can use this token in any subsequent request to retrieve the next set of jobs.
    public var nextToken: Swift.String?

    public init(
        history: [QBusinessClientTypes.DataSourceSyncJob]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.history = history
        self.nextToken = nextToken
    }
}

struct ListDataSourceSyncJobsOutputBody: Swift.Equatable {
    let history: [QBusinessClientTypes.DataSourceSyncJob]?
    let nextToken: Swift.String?
}

extension ListDataSourceSyncJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case history
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let historyContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.DataSourceSyncJob?].self, forKey: .history)
        var historyDecoded0:[QBusinessClientTypes.DataSourceSyncJob]? = nil
        if let historyContainer = historyContainer {
            historyDecoded0 = [QBusinessClientTypes.DataSourceSyncJob]()
            for structure0 in historyContainer {
                if let structure0 = structure0 {
                    historyDecoded0?.append(structure0)
                }
            }
        }
        history = historyDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDataSourceSyncJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDataSourcesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListDataSourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let indexId = indexId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/indices/\(indexId.urlPercentEncoding())/datasources"
    }
}

public struct ListDataSourcesInput: Swift.Equatable {
    /// The identifier of the Amazon Q application linked to the data source connectors.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the index used with one or more data source connectors.
    /// This member is required.
    public var indexId: Swift.String?
    /// The maximum number of data source connectors to return.
    public var maxResults: Swift.Int?
    /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q returns a pagination token in the response. You can use this pagination token to retrieve the next set of Amazon Q data source connectors.
    public var nextToken: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        indexId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.indexId = indexId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDataSourcesInputBody: Swift.Equatable {
}

extension ListDataSourcesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDataSourcesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDataSourcesOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataSources = output.dataSources
            self.nextToken = output.nextToken
        } else {
            self.dataSources = nil
            self.nextToken = nil
        }
    }
}

public struct ListDataSourcesOutput: Swift.Equatable {
    /// An array of summary information for one or more data source connector.
    public var dataSources: [QBusinessClientTypes.DataSource]?
    /// If the response is truncated, Amazon Q returns this token. You can use this token in a subsequent request to retrieve the next set of data source connectors.
    public var nextToken: Swift.String?

    public init(
        dataSources: [QBusinessClientTypes.DataSource]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataSources = dataSources
        self.nextToken = nextToken
    }
}

struct ListDataSourcesOutputBody: Swift.Equatable {
    let dataSources: [QBusinessClientTypes.DataSource]?
    let nextToken: Swift.String?
}

extension ListDataSourcesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSources
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourcesContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.DataSource?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[QBusinessClientTypes.DataSource]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [QBusinessClientTypes.DataSource]()
            for structure0 in dataSourcesContainer {
                if let structure0 = structure0 {
                    dataSourcesDecoded0?.append(structure0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDataSourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDocumentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let dataSourceIds = dataSourceIds {
                dataSourceIds.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "dataSourceIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension ListDocumentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let indexId = indexId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/index/\(indexId.urlPercentEncoding())/documents"
    }
}

public struct ListDocumentsInput: Swift.Equatable {
    /// The identifier of the application id the documents are attached to.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the data sources the documents are attached to.
    public var dataSourceIds: [Swift.String]?
    /// The identifier of the index the documents are attached to.
    /// This member is required.
    public var indexId: Swift.String?
    /// The maximum number of documents to return.
    public var maxResults: Swift.Int?
    /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q returns a pagination token in the response. You can use this pagination token to retrieve the next set of documents.
    public var nextToken: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        dataSourceIds: [Swift.String]? = nil,
        indexId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.dataSourceIds = dataSourceIds
        self.indexId = indexId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDocumentsInputBody: Swift.Equatable {
}

extension ListDocumentsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDocumentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDocumentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.documentDetailList = output.documentDetailList
            self.nextToken = output.nextToken
        } else {
            self.documentDetailList = nil
            self.nextToken = nil
        }
    }
}

public struct ListDocumentsOutput: Swift.Equatable {
    /// A list of document details.
    public var documentDetailList: [QBusinessClientTypes.DocumentDetails]?
    /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q returns a pagination token in the response. You can use this pagination token to retrieve the next set of documents.
    public var nextToken: Swift.String?

    public init(
        documentDetailList: [QBusinessClientTypes.DocumentDetails]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.documentDetailList = documentDetailList
        self.nextToken = nextToken
    }
}

struct ListDocumentsOutputBody: Swift.Equatable {
    let documentDetailList: [QBusinessClientTypes.DocumentDetails]?
    let nextToken: Swift.String?
}

extension ListDocumentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentDetailList
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentDetailListContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.DocumentDetails?].self, forKey: .documentDetailList)
        var documentDetailListDecoded0:[QBusinessClientTypes.DocumentDetails]? = nil
        if let documentDetailListContainer = documentDetailListContainer {
            documentDetailListDecoded0 = [QBusinessClientTypes.DocumentDetails]()
            for structure0 in documentDetailListContainer {
                if let structure0 = structure0 {
                    documentDetailListDecoded0?.append(structure0)
                }
            }
        }
        documentDetailList = documentDetailListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDocumentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let updatedEarlierThan = updatedEarlierThan else {
                let message = "Creating a URL Query Item failed. updatedEarlierThan is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let updatedEarlierThanQueryItem = ClientRuntime.URLQueryItem(name: "updatedEarlierThan".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: updatedEarlierThan)).urlPercentEncoding())
            items.append(updatedEarlierThanQueryItem)
            if let dataSourceId = dataSourceId {
                let dataSourceIdQueryItem = ClientRuntime.URLQueryItem(name: "dataSourceId".urlPercentEncoding(), value: Swift.String(dataSourceId).urlPercentEncoding())
                items.append(dataSourceIdQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let indexId = indexId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/indices/\(indexId.urlPercentEncoding())/groups"
    }
}

public struct ListGroupsInput: Swift.Equatable {
    /// The identifier of the application for getting a list of groups mapped to users.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the data source for getting a list of groups mapped to users.
    public var dataSourceId: Swift.String?
    /// The identifier of the index for getting a list of groups mapped to users.
    /// This member is required.
    public var indexId: Swift.String?
    /// The maximum number of returned groups that are mapped to users.
    public var maxResults: Swift.Int?
    /// If the previous response was incomplete (because there is more data to retrieve), Amazon Q returns a pagination token in the response. You can use this pagination token to retrieve the next set of groups that are mapped to users.
    public var nextToken: Swift.String?
    /// The timestamp identifier used for the latest PUT or DELETE action for mapping users to their groups.
    /// This member is required.
    public var updatedEarlierThan: ClientRuntime.Date?

    public init(
        applicationId: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        indexId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        updatedEarlierThan: ClientRuntime.Date? = nil
    )
    {
        self.applicationId = applicationId
        self.dataSourceId = dataSourceId
        self.indexId = indexId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.updatedEarlierThan = updatedEarlierThan
    }
}

struct ListGroupsInputBody: Swift.Equatable {
}

extension ListGroupsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListGroupsOutput: Swift.Equatable {
    /// Summary information for list of groups that are mapped to users.
    public var items: [QBusinessClientTypes.GroupSummary]?
    /// If the response is truncated, Amazon Q returns this token that you can use in the subsequent request to retrieve the next set of groups that are mapped to users.
    public var nextToken: Swift.String?

    public init(
        items: [QBusinessClientTypes.GroupSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListGroupsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let items: [QBusinessClientTypes.GroupSummary]?
}

extension ListGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let itemsContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.GroupSummary?].self, forKey: .items)
        var itemsDecoded0:[QBusinessClientTypes.GroupSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [QBusinessClientTypes.GroupSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

enum ListGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListIndicesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListIndicesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/indices"
    }
}

public struct ListIndicesInput: Swift.Equatable {
    /// The identifier of the Amazon Q application connected to the index.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The maximum number of indices to return.
    public var maxResults: Swift.Int?
    /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q returns a pagination token in the response. You can use this pagination token to retrieve the next set of Amazon Q indices.
    public var nextToken: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIndicesInputBody: Swift.Equatable {
}

extension ListIndicesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListIndicesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListIndicesOutputBody = try responseDecoder.decode(responseBody: data)
            self.indices = output.indices
            self.nextToken = output.nextToken
        } else {
            self.indices = nil
            self.nextToken = nil
        }
    }
}

public struct ListIndicesOutput: Swift.Equatable {
    /// An array of information on the items in one or more indexes.
    public var indices: [QBusinessClientTypes.Index]?
    /// If the response is truncated, Amazon Q returns this token that you can use in the subsequent request to retrieve the next set of indexes.
    public var nextToken: Swift.String?

    public init(
        indices: [QBusinessClientTypes.Index]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.indices = indices
        self.nextToken = nextToken
    }
}

struct ListIndicesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let indices: [QBusinessClientTypes.Index]?
}

extension ListIndicesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indices
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let indicesContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.Index?].self, forKey: .indices)
        var indicesDecoded0:[QBusinessClientTypes.Index]? = nil
        if let indicesContainer = indicesContainer {
            indicesDecoded0 = [QBusinessClientTypes.Index]()
            for structure0 in indicesContainer {
                if let structure0 = structure0 {
                    indicesDecoded0?.append(structure0)
                }
            }
        }
        indices = indicesDecoded0
    }
}

enum ListIndicesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMessagesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            guard let userId = userId else {
                let message = "Creating a URL Query Item failed. userId is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let userIdQueryItem = ClientRuntime.URLQueryItem(name: "userId".urlPercentEncoding(), value: Swift.String(userId).urlPercentEncoding())
            items.append(userIdQueryItem)
            return items
        }
    }
}

extension ListMessagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let conversationId = conversationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/conversations/\(conversationId.urlPercentEncoding())"
    }
}

public struct ListMessagesInput: Swift.Equatable {
    /// The identifier for the Amazon Q application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the Amazon Q web experience conversation.
    /// This member is required.
    public var conversationId: Swift.String?
    /// The maximum number of messages to return.
    public var maxResults: Swift.Int?
    /// If the number of retrievers returned exceeds maxResults, Amazon Q returns a next token as a pagination token to retrieve the next set of messages.
    public var nextToken: Swift.String?
    /// The identifier of the user involved in the Amazon Q web experience conversation.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        conversationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.conversationId = conversationId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.userId = userId
    }
}

struct ListMessagesInputBody: Swift.Equatable {
}

extension ListMessagesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListMessagesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMessagesOutputBody = try responseDecoder.decode(responseBody: data)
            self.messages = output.messages
            self.nextToken = output.nextToken
        } else {
            self.messages = nil
            self.nextToken = nil
        }
    }
}

public struct ListMessagesOutput: Swift.Equatable {
    /// An array of information on one or more messages.
    public var messages: [QBusinessClientTypes.Message]?
    /// If the response is truncated, Amazon Q returns this token, which you can use in a later request to list the next set of messages.
    public var nextToken: Swift.String?

    public init(
        messages: [QBusinessClientTypes.Message]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.messages = messages
        self.nextToken = nextToken
    }
}

struct ListMessagesOutputBody: Swift.Equatable {
    let messages: [QBusinessClientTypes.Message]?
    let nextToken: Swift.String?
}

extension ListMessagesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messages
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messagesContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.Message?].self, forKey: .messages)
        var messagesDecoded0:[QBusinessClientTypes.Message]? = nil
        if let messagesContainer = messagesContainer {
            messagesDecoded0 = [QBusinessClientTypes.Message]()
            for structure0 in messagesContainer {
                if let structure0 = structure0 {
                    messagesDecoded0?.append(structure0)
                }
            }
        }
        messages = messagesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListMessagesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LicenseNotFoundException": return try await LicenseNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPluginsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListPluginsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/plugins"
    }
}

public struct ListPluginsInput: Swift.Equatable {
    /// The identifier of the application the plugin is attached to.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The maximum number of documents to return.
    public var maxResults: Swift.Int?
    /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q returns a pagination token in the response. You can use this pagination token to retrieve the next set of plugins.
    public var nextToken: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPluginsInputBody: Swift.Equatable {
}

extension ListPluginsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListPluginsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPluginsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.plugins = output.plugins
        } else {
            self.nextToken = nil
            self.plugins = nil
        }
    }
}

public struct ListPluginsOutput: Swift.Equatable {
    /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q returns a pagination token in the response. You can use this pagination token to retrieve the next set of plugins.
    public var nextToken: Swift.String?
    /// Information about a configured plugin.
    public var plugins: [QBusinessClientTypes.Plugin]?

    public init(
        nextToken: Swift.String? = nil,
        plugins: [QBusinessClientTypes.Plugin]? = nil
    )
    {
        self.nextToken = nextToken
        self.plugins = plugins
    }
}

struct ListPluginsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let plugins: [QBusinessClientTypes.Plugin]?
}

extension ListPluginsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case plugins
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let pluginsContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.Plugin?].self, forKey: .plugins)
        var pluginsDecoded0:[QBusinessClientTypes.Plugin]? = nil
        if let pluginsContainer = pluginsContainer {
            pluginsDecoded0 = [QBusinessClientTypes.Plugin]()
            for structure0 in pluginsContainer {
                if let structure0 = structure0 {
                    pluginsDecoded0?.append(structure0)
                }
            }
        }
        plugins = pluginsDecoded0
    }
}

enum ListPluginsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRetrieversInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListRetrieversInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/retrievers"
    }
}

public struct ListRetrieversInput: Swift.Equatable {
    /// The identifier of the Amazon Q application using the retriever.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The maximum number of retrievers returned.
    public var maxResults: Swift.Int?
    /// If the number of retrievers returned exceeds maxResults, Amazon Q returns a next token as a pagination token to retrieve the next set of retrievers.
    public var nextToken: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRetrieversInputBody: Swift.Equatable {
}

extension ListRetrieversInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListRetrieversOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRetrieversOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.retrievers = output.retrievers
        } else {
            self.nextToken = nil
            self.retrievers = nil
        }
    }
}

public struct ListRetrieversOutput: Swift.Equatable {
    /// If the response is truncated, Amazon Q returns this token, which you can use in a later request to list the next set of retrievers.
    public var nextToken: Swift.String?
    /// An array of summary information for one or more retrievers.
    public var retrievers: [QBusinessClientTypes.Retriever]?

    public init(
        nextToken: Swift.String? = nil,
        retrievers: [QBusinessClientTypes.Retriever]? = nil
    )
    {
        self.nextToken = nextToken
        self.retrievers = retrievers
    }
}

struct ListRetrieversOutputBody: Swift.Equatable {
    let retrievers: [QBusinessClientTypes.Retriever]?
    let nextToken: Swift.String?
}

extension ListRetrieversOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case retrievers
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retrieversContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.Retriever?].self, forKey: .retrievers)
        var retrieversDecoded0:[QBusinessClientTypes.Retriever]? = nil
        if let retrieversContainer = retrieversContainer {
            retrieversDecoded0 = [QBusinessClientTypes.Retriever]()
            for structure0 in retrieversContainer {
                if let structure0 = structure0 {
                    retrieversDecoded0?.append(structure0)
                }
            }
        }
        retrievers = retrieversDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRetrieversOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceARN = resourceARN else {
            return nil
        }
        return "/v1/tags/\(resourceARN.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Amazon Q application or data source to get a list of tags for.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// A list of tags associated with the Amazon Q application or data source.
    public var tags: [QBusinessClientTypes.Tag]?

    public init(
        tags: [QBusinessClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [QBusinessClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[QBusinessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [QBusinessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListWebExperiencesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListWebExperiencesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/experiences"
    }
}

public struct ListWebExperiencesInput: Swift.Equatable {
    /// The identifier of the Amazon Q application linked to the listed web experiences.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The maximum number of Amazon Q Web Experiences to return.
    public var maxResults: Swift.Int?
    /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q returns a pagination token in the response. You can use this pagination token to retrieve the next set of Amazon Q conversations.
    public var nextToken: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWebExperiencesInputBody: Swift.Equatable {
}

extension ListWebExperiencesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListWebExperiencesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListWebExperiencesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.webExperiences = output.webExperiences
        } else {
            self.nextToken = nil
            self.webExperiences = nil
        }
    }
}

public struct ListWebExperiencesOutput: Swift.Equatable {
    /// If the response is truncated, Amazon Q returns this token, which you can use in a later request to list the next set of messages.
    public var nextToken: Swift.String?
    /// An array of summary information for one or more Amazon Q experiences.
    public var webExperiences: [QBusinessClientTypes.WebExperience]?

    public init(
        nextToken: Swift.String? = nil,
        webExperiences: [QBusinessClientTypes.WebExperience]? = nil
    )
    {
        self.nextToken = nextToken
        self.webExperiences = webExperiences
    }
}

struct ListWebExperiencesOutputBody: Swift.Equatable {
    let webExperiences: [QBusinessClientTypes.WebExperience]?
    let nextToken: Swift.String?
}

extension ListWebExperiencesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case webExperiences
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webExperiencesContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.WebExperience?].self, forKey: .webExperiences)
        var webExperiencesDecoded0:[QBusinessClientTypes.WebExperience]? = nil
        if let webExperiencesContainer = webExperiencesContainer {
            webExperiencesDecoded0 = [QBusinessClientTypes.WebExperience]()
            for structure0 in webExperiencesContainer {
                if let structure0 = structure0 {
                    webExperiencesDecoded0?.append(structure0)
                }
            }
        }
        webExperiences = webExperiencesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListWebExperiencesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension QBusinessClientTypes.MemberGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.MembershipType.self, forKey: .type)
        type = typeDecoded
    }
}

extension QBusinessClientTypes {
    /// The sub groups that belong to a group.
    public struct MemberGroup: Swift.Equatable {
        /// The name of the sub group.
        /// This member is required.
        public var groupName: Swift.String?
        /// The type of the sub group.
        public var type: QBusinessClientTypes.MembershipType?

        public init(
            groupName: Swift.String? = nil,
            type: QBusinessClientTypes.MembershipType? = nil
        )
        {
            self.groupName = groupName
            self.type = type
        }
    }

}

extension QBusinessClientTypes {
    public enum MemberRelation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case and
        case or
        case sdkUnknown(Swift.String)

        public static var allCases: [MemberRelation] {
            return [
                .and,
                .or,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .and: return "AND"
            case .or: return "OR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MemberRelation(rawValue: rawValue) ?? MemberRelation.sdkUnknown(rawValue)
        }
    }
}

extension QBusinessClientTypes.MemberUser: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type
        case userId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.MembershipType.self, forKey: .type)
        type = typeDecoded
    }
}

extension QBusinessClientTypes {
    /// The users that belong to a group.
    public struct MemberUser: Swift.Equatable {
        /// The type of the user.
        public var type: QBusinessClientTypes.MembershipType?
        /// The identifier of the user you want to map to a group.
        /// This member is required.
        public var userId: Swift.String?

        public init(
            type: QBusinessClientTypes.MembershipType? = nil,
            userId: Swift.String? = nil
        )
        {
            self.type = type
            self.userId = userId
        }
    }

}

extension QBusinessClientTypes {
    public enum MembershipType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case datasource
        case index
        case sdkUnknown(Swift.String)

        public static var allCases: [MembershipType] {
            return [
                .datasource,
                .index,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .datasource: return "DATASOURCE"
            case .index: return "INDEX"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MembershipType(rawValue: rawValue) ?? MembershipType.sdkUnknown(rawValue)
        }
    }
}

extension QBusinessClientTypes.Message: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionExecution
        case actionReview
        case attachments
        case body
        case messageId
        case sourceAttribution
        case time
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionExecution = self.actionExecution {
            try encodeContainer.encode(actionExecution, forKey: .actionExecution)
        }
        if let actionReview = self.actionReview {
            try encodeContainer.encode(actionReview, forKey: .actionReview)
        }
        if let attachments = attachments {
            var attachmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachments)
            for attachmentoutput0 in attachments {
                try attachmentsContainer.encode(attachmentoutput0)
            }
        }
        if let body = self.body {
            try encodeContainer.encode(body, forKey: .body)
        }
        if let messageId = self.messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
        if let sourceAttribution = sourceAttribution {
            var sourceAttributionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceAttribution)
            for sourceattribution0 in sourceAttribution {
                guard let sourceattribution0 = sourceattribution0 else {
                    try sourceAttributionContainer.encodeNil()
                    continue
                }
                try sourceAttributionContainer.encode(sourceattribution0)
            }
        }
        if let time = self.time {
            try encodeContainer.encodeTimestamp(time, format: .epochSeconds, forKey: .time)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let bodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .body)
        body = bodyDecoded
        let timeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .time)
        time = timeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.MessageType.self, forKey: .type)
        type = typeDecoded
        let attachmentsContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.AttachmentOutput?].self, forKey: .attachments)
        var attachmentsDecoded0:[QBusinessClientTypes.AttachmentOutput]? = nil
        if let attachmentsContainer = attachmentsContainer {
            attachmentsDecoded0 = [QBusinessClientTypes.AttachmentOutput]()
            for structure0 in attachmentsContainer {
                if let structure0 = structure0 {
                    attachmentsDecoded0?.append(structure0)
                }
            }
        }
        attachments = attachmentsDecoded0
        let sourceAttributionContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.SourceAttribution?].self, forKey: .sourceAttribution)
        var sourceAttributionDecoded0:[QBusinessClientTypes.SourceAttribution?]? = nil
        if let sourceAttributionContainer = sourceAttributionContainer {
            sourceAttributionDecoded0 = [QBusinessClientTypes.SourceAttribution?]()
            for structure0 in sourceAttributionContainer {
                sourceAttributionDecoded0?.append(structure0)
            }
        }
        sourceAttribution = sourceAttributionDecoded0
        let actionReviewDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.ActionReview.self, forKey: .actionReview)
        actionReview = actionReviewDecoded
        let actionExecutionDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.ActionExecution.self, forKey: .actionExecution)
        actionExecution = actionExecutionDecoded
    }
}

extension QBusinessClientTypes {
    /// A message in an Amazon Q web experience.
    public struct Message: Swift.Equatable {
        /// Performs an Amazon Q plugin action during a non-streaming chat conversation.
        public var actionExecution: QBusinessClientTypes.ActionExecution?
        /// An output event that Amazon Q returns to an user who wants to perform a plugin action during a non-streaming chat conversation. It contains information about the selected action with a list of possible user input fields, some pre-populated by Amazon Q.
        public var actionReview: QBusinessClientTypes.ActionReview?
        /// A file directly uploaded into an Amazon Q web experience chat.
        public var attachments: [QBusinessClientTypes.AttachmentOutput]?
        /// The content of the Amazon Q web experience message.
        public var body: Swift.String?
        /// The identifier of the Amazon Q web experience message.
        public var messageId: Swift.String?
        /// The source documents used to generate Amazon Q web experience message.
        public var sourceAttribution: [QBusinessClientTypes.SourceAttribution?]?
        /// The timestamp of the first Amazon Q web experience message.
        public var time: ClientRuntime.Date?
        /// The type of Amazon Q message, whether HUMAN or AI generated.
        public var type: QBusinessClientTypes.MessageType?

        public init(
            actionExecution: QBusinessClientTypes.ActionExecution? = nil,
            actionReview: QBusinessClientTypes.ActionReview? = nil,
            attachments: [QBusinessClientTypes.AttachmentOutput]? = nil,
            body: Swift.String? = nil,
            messageId: Swift.String? = nil,
            sourceAttribution: [QBusinessClientTypes.SourceAttribution?]? = nil,
            time: ClientRuntime.Date? = nil,
            type: QBusinessClientTypes.MessageType? = nil
        )
        {
            self.actionExecution = actionExecution
            self.actionReview = actionReview
            self.attachments = attachments
            self.body = body
            self.messageId = messageId
            self.sourceAttribution = sourceAttribution
            self.time = time
            self.type = type
        }
    }

}

extension QBusinessClientTypes {
    public enum MessageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case system
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [MessageType] {
            return [
                .system,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .system: return "SYSTEM"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MessageType(rawValue: rawValue) ?? MessageType.sdkUnknown(rawValue)
        }
    }
}

extension QBusinessClientTypes {
    public enum MessageUsefulness: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case notUseful
        case useful
        case sdkUnknown(Swift.String)

        public static var allCases: [MessageUsefulness] {
            return [
                .notUseful,
                .useful,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .notUseful: return "NOT_USEFUL"
            case .useful: return "USEFUL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MessageUsefulness(rawValue: rawValue) ?? MessageUsefulness.sdkUnknown(rawValue)
        }
    }
}

extension QBusinessClientTypes.MessageUsefulnessFeedback: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
        case reason
        case submittedAt
        case usefulness
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comment = self.comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason.rawValue, forKey: .reason)
        }
        if let submittedAt = self.submittedAt {
            try encodeContainer.encodeTimestamp(submittedAt, format: .epochSeconds, forKey: .submittedAt)
        }
        if let usefulness = self.usefulness {
            try encodeContainer.encode(usefulness.rawValue, forKey: .usefulness)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usefulnessDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.MessageUsefulness.self, forKey: .usefulness)
        usefulness = usefulnessDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.MessageUsefulnessReason.self, forKey: .reason)
        reason = reasonDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let submittedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .submittedAt)
        submittedAt = submittedAtDecoded
    }
}

extension QBusinessClientTypes {
    /// End user feedback on an AI-generated web experience chat message usefulness.
    public struct MessageUsefulnessFeedback: Swift.Equatable {
        /// A comment given by an end user on the usefulness of an AI-generated chat message.
        public var comment: Swift.String?
        /// The reason for a usefulness rating.
        public var reason: QBusinessClientTypes.MessageUsefulnessReason?
        /// The timestamp for when the feedback was submitted.
        /// This member is required.
        public var submittedAt: ClientRuntime.Date?
        /// The usefulness value assigned by an end user to a message.
        /// This member is required.
        public var usefulness: QBusinessClientTypes.MessageUsefulness?

        public init(
            comment: Swift.String? = nil,
            reason: QBusinessClientTypes.MessageUsefulnessReason? = nil,
            submittedAt: ClientRuntime.Date? = nil,
            usefulness: QBusinessClientTypes.MessageUsefulness? = nil
        )
        {
            self.comment = comment
            self.reason = reason
            self.submittedAt = submittedAt
            self.usefulness = usefulness
        }
    }

}

extension QBusinessClientTypes {
    public enum MessageUsefulnessReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case factuallyCorrect
        case harmfulOrUnsafe
        case helpful
        case incorrectOrMissingSources
        case notFactuallyCorrect
        case notHelpful
        case relevantSources
        case sdkUnknown(Swift.String)

        public static var allCases: [MessageUsefulnessReason] {
            return [
                .complete,
                .factuallyCorrect,
                .harmfulOrUnsafe,
                .helpful,
                .incorrectOrMissingSources,
                .notFactuallyCorrect,
                .notHelpful,
                .relevantSources,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .factuallyCorrect: return "FACTUALLY_CORRECT"
            case .harmfulOrUnsafe: return "HARMFUL_OR_UNSAFE"
            case .helpful: return "HELPFUL"
            case .incorrectOrMissingSources: return "INCORRECT_OR_MISSING_SOURCES"
            case .notFactuallyCorrect: return "NOT_FACTUALLY_CORRECT"
            case .notHelpful: return "NOT_HELPFUL"
            case .relevantSources: return "RELEVANT_SOURCES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MessageUsefulnessReason(rawValue: rawValue) ?? MessageUsefulnessReason.sdkUnknown(rawValue)
        }
    }
}

extension QBusinessClientTypes.NativeIndexConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexId = self.indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
    }
}

extension QBusinessClientTypes {
    /// Configuration information for an Amazon Q index.
    public struct NativeIndexConfiguration: Swift.Equatable {
        /// The identifier for the Amazon Q index.
        /// This member is required.
        public var indexId: Swift.String?

        public init(
            indexId: Swift.String? = nil
        )
        {
            self.indexId = indexId
        }
    }

}

extension QBusinessClientTypes.OAuth2ClientCredentialConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn
        case secretArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let secretArn = self.secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension QBusinessClientTypes {
    /// Information about the OAuth 2.0 authentication credential/token used to configure a plugin.
    public struct OAuth2ClientCredentialConfiguration: Swift.Equatable {
        /// The ARN of an IAM role used by Amazon Q to access the OAuth 2.0 authentication credentials stored in a Secrets Manager secret.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The ARN of the Secrets Manager secret that stores the OAuth 2.0 credentials/token used for plugin configuration.
        /// This member is required.
        public var secretArn: Swift.String?

        public init(
            roleArn: Swift.String? = nil,
            secretArn: Swift.String? = nil
        )
        {
            self.roleArn = roleArn
            self.secretArn = secretArn
        }
    }

}

extension QBusinessClientTypes.Plugin: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case displayName
        case pluginId
        case serverUrl
        case state
        case type
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let pluginId = self.pluginId {
            try encodeContainer.encode(pluginId, forKey: .pluginId)
        }
        if let serverUrl = self.serverUrl {
            try encodeContainer.encode(serverUrl, forKey: .serverUrl)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pluginIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pluginId)
        pluginId = pluginIdDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.PluginType.self, forKey: .type)
        type = typeDecoded
        let serverUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverUrl)
        serverUrl = serverUrlDecoded
        let stateDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.PluginState.self, forKey: .state)
        state = stateDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension QBusinessClientTypes {
    /// Information about an Amazon Q plugin and its configuration.
    public struct Plugin: Swift.Equatable {
        /// The timestamp for when the plugin was created.
        public var createdAt: ClientRuntime.Date?
        /// The name of the plugin.
        public var displayName: Swift.String?
        /// The identifier of the plugin.
        public var pluginId: Swift.String?
        /// The plugin server URL used for configuration.
        public var serverUrl: Swift.String?
        /// The current status of the plugin.
        public var state: QBusinessClientTypes.PluginState?
        /// The type of the plugin.
        public var type: QBusinessClientTypes.PluginType?
        /// The timestamp for when the plugin was last updated.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            displayName: Swift.String? = nil,
            pluginId: Swift.String? = nil,
            serverUrl: Swift.String? = nil,
            state: QBusinessClientTypes.PluginState? = nil,
            type: QBusinessClientTypes.PluginType? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.displayName = displayName
            self.pluginId = pluginId
            self.serverUrl = serverUrl
            self.state = state
            self.type = type
            self.updatedAt = updatedAt
        }
    }

}

extension QBusinessClientTypes.PluginAuthConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case basicauthconfiguration = "basicAuthConfiguration"
        case oauth2clientcredentialconfiguration = "oAuth2ClientCredentialConfiguration"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .basicauthconfiguration(basicauthconfiguration):
                try container.encode(basicauthconfiguration, forKey: .basicauthconfiguration)
            case let .oauth2clientcredentialconfiguration(oauth2clientcredentialconfiguration):
                try container.encode(oauth2clientcredentialconfiguration, forKey: .oauth2clientcredentialconfiguration)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let basicauthconfigurationDecoded = try values.decodeIfPresent(QBusinessClientTypes.BasicAuthConfiguration.self, forKey: .basicauthconfiguration)
        if let basicauthconfiguration = basicauthconfigurationDecoded {
            self = .basicauthconfiguration(basicauthconfiguration)
            return
        }
        let oauth2clientcredentialconfigurationDecoded = try values.decodeIfPresent(QBusinessClientTypes.OAuth2ClientCredentialConfiguration.self, forKey: .oauth2clientcredentialconfiguration)
        if let oauth2clientcredentialconfiguration = oauth2clientcredentialconfigurationDecoded {
            self = .oauth2clientcredentialconfiguration(oauth2clientcredentialconfiguration)
            return
        }
        self = .sdkUnknown("")
    }
}

extension QBusinessClientTypes {
    /// Authentication configuration information for an Amazon Q plugin.
    public enum PluginAuthConfiguration: Swift.Equatable {
        /// Information about the basic authentication credentials used to configure a plugin.
        case basicauthconfiguration(QBusinessClientTypes.BasicAuthConfiguration)
        /// Information about the OAuth 2.0 authentication credential/token used to configure a plugin.
        case oauth2clientcredentialconfiguration(QBusinessClientTypes.OAuth2ClientCredentialConfiguration)
        case sdkUnknown(Swift.String)
    }

}

extension QBusinessClientTypes {
    public enum PluginState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [PluginState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PluginState(rawValue: rawValue) ?? PluginState.sdkUnknown(rawValue)
        }
    }
}

extension QBusinessClientTypes {
    public enum PluginType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case jira
        case salesforce
        case serviceNow
        case zendesk
        case sdkUnknown(Swift.String)

        public static var allCases: [PluginType] {
            return [
                .jira,
                .salesforce,
                .serviceNow,
                .zendesk,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .jira: return "JIRA"
            case .salesforce: return "SALESFORCE"
            case .serviceNow: return "SERVICE_NOW"
            case .zendesk: return "ZENDESK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PluginType(rawValue: rawValue) ?? PluginType.sdkUnknown(rawValue)
        }
    }
}

extension QBusinessClientTypes.Principal: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case group
        case sdkUnknown
        case user
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .group(group):
                try container.encode(group, forKey: .group)
            case let .user(user):
                try container.encode(user, forKey: .user)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try values.decodeIfPresent(QBusinessClientTypes.PrincipalUser.self, forKey: .user)
        if let user = userDecoded {
            self = .user(user)
            return
        }
        let groupDecoded = try values.decodeIfPresent(QBusinessClientTypes.PrincipalGroup.self, forKey: .group)
        if let group = groupDecoded {
            self = .group(group)
            return
        }
        self = .sdkUnknown("")
    }
}

extension QBusinessClientTypes {
    /// Provides user and group information used for filtering documents to use for generating Amazon Q conversation responses.
    public enum Principal: Swift.Equatable {
        /// The user associated with the principal.
        case user(QBusinessClientTypes.PrincipalUser)
        /// The group associated with the principal.
        case group(QBusinessClientTypes.PrincipalGroup)
        case sdkUnknown(Swift.String)
    }

}

extension QBusinessClientTypes.PrincipalGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case access
        case membershipType
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let access = self.access {
            try encodeContainer.encode(access.rawValue, forKey: .access)
        }
        if let membershipType = self.membershipType {
            try encodeContainer.encode(membershipType.rawValue, forKey: .membershipType)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let accessDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.ReadAccessType.self, forKey: .access)
        access = accessDecoded
        let membershipTypeDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.MembershipType.self, forKey: .membershipType)
        membershipType = membershipTypeDecoded
    }
}

extension QBusinessClientTypes {
    /// Provides information about a group associated with the principal.
    public struct PrincipalGroup: Swift.Equatable {
        /// Provides information about whether to allow or deny access to the principal.
        /// This member is required.
        public var access: QBusinessClientTypes.ReadAccessType?
        /// The type of group.
        public var membershipType: QBusinessClientTypes.MembershipType?
        /// The name of the group.
        public var name: Swift.String?

        public init(
            access: QBusinessClientTypes.ReadAccessType? = nil,
            membershipType: QBusinessClientTypes.MembershipType? = nil,
            name: Swift.String? = nil
        )
        {
            self.access = access
            self.membershipType = membershipType
            self.name = name
        }
    }

}

extension QBusinessClientTypes.PrincipalUser: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case access
        case id
        case membershipType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let access = self.access {
            try encodeContainer.encode(access.rawValue, forKey: .access)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let membershipType = self.membershipType {
            try encodeContainer.encode(membershipType.rawValue, forKey: .membershipType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let accessDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.ReadAccessType.self, forKey: .access)
        access = accessDecoded
        let membershipTypeDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.MembershipType.self, forKey: .membershipType)
        membershipType = membershipTypeDecoded
    }
}

extension QBusinessClientTypes {
    /// Provides information about a user associated with a principal.
    public struct PrincipalUser: Swift.Equatable {
        /// Provides information about whether to allow or deny access to the principal.
        /// This member is required.
        public var access: QBusinessClientTypes.ReadAccessType?
        /// The identifier of the user.
        public var id: Swift.String?
        /// The type of group.
        public var membershipType: QBusinessClientTypes.MembershipType?

        public init(
            access: QBusinessClientTypes.ReadAccessType? = nil,
            id: Swift.String? = nil,
            membershipType: QBusinessClientTypes.MembershipType? = nil
        )
        {
            self.access = access
            self.id = id
            self.membershipType = membershipType
        }
    }

}

extension PutFeedbackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messageCopiedAt
        case messageUsefulness
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let messageCopiedAt = self.messageCopiedAt {
            try encodeContainer.encodeTimestamp(messageCopiedAt, format: .epochSeconds, forKey: .messageCopiedAt)
        }
        if let messageUsefulness = self.messageUsefulness {
            try encodeContainer.encode(messageUsefulness, forKey: .messageUsefulness)
        }
    }
}

extension PutFeedbackInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let userId = userId else {
                let message = "Creating a URL Query Item failed. userId is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let userIdQueryItem = ClientRuntime.URLQueryItem(name: "userId".urlPercentEncoding(), value: Swift.String(userId).urlPercentEncoding())
            items.append(userIdQueryItem)
            return items
        }
    }
}

extension PutFeedbackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let conversationId = conversationId else {
            return nil
        }
        guard let messageId = messageId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/conversations/\(conversationId.urlPercentEncoding())/messages/\(messageId.urlPercentEncoding())/feedback"
    }
}

public struct PutFeedbackInput: Swift.Equatable {
    /// The identifier of the application associated with the feedback.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the conversation the feedback is attached to.
    /// This member is required.
    public var conversationId: Swift.String?
    /// The timestamp for when the feedback was recorded.
    public var messageCopiedAt: ClientRuntime.Date?
    /// The identifier of the chat message that the feedback was given for.
    /// This member is required.
    public var messageId: Swift.String?
    /// The feedback usefulness value given by the user to the chat message.
    public var messageUsefulness: QBusinessClientTypes.MessageUsefulnessFeedback?
    /// The identifier of the user giving the feedback.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        conversationId: Swift.String? = nil,
        messageCopiedAt: ClientRuntime.Date? = nil,
        messageId: Swift.String? = nil,
        messageUsefulness: QBusinessClientTypes.MessageUsefulnessFeedback? = nil,
        userId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.conversationId = conversationId
        self.messageCopiedAt = messageCopiedAt
        self.messageId = messageId
        self.messageUsefulness = messageUsefulness
        self.userId = userId
    }
}

struct PutFeedbackInputBody: Swift.Equatable {
    let messageCopiedAt: ClientRuntime.Date?
    let messageUsefulness: QBusinessClientTypes.MessageUsefulnessFeedback?
}

extension PutFeedbackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messageCopiedAt
        case messageUsefulness
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageCopiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .messageCopiedAt)
        messageCopiedAt = messageCopiedAtDecoded
        let messageUsefulnessDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.MessageUsefulnessFeedback.self, forKey: .messageUsefulness)
        messageUsefulness = messageUsefulnessDecoded
    }
}

extension PutFeedbackOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutFeedbackOutput: Swift.Equatable {

    public init() { }
}

enum PutFeedbackOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceId
        case groupMembers
        case groupName
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceId = self.dataSourceId {
            try encodeContainer.encode(dataSourceId, forKey: .dataSourceId)
        }
        if let groupMembers = self.groupMembers {
            try encodeContainer.encode(groupMembers, forKey: .groupMembers)
        }
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension PutGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let indexId = indexId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/indices/\(indexId.urlPercentEncoding())/groups"
    }
}

public struct PutGroupInput: Swift.Equatable {
    /// The identifier of the application in which the user and group mapping belongs.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the data source for which you want to map users to their groups. This is useful if a group is tied to multiple data sources, but you only want the group to access documents of a certain data source. For example, the groups "Research", "Engineering", and "Sales and Marketing" are all tied to the company's documents stored in the data sources Confluence and Salesforce. However, "Sales and Marketing" team only needs access to customer-related documents stored in Salesforce.
    public var dataSourceId: Swift.String?
    /// A list of users or sub groups that belong to a group. This is for generating Amazon Q chat results only from document a user has access to.
    /// This member is required.
    public var groupMembers: QBusinessClientTypes.GroupMembers?
    /// The list that contains your users or sub groups that belong the same group. For example, the group "Company" includes the user "CEO" and the sub groups "Research", "Engineering", and "Sales and Marketing". If you have more than 1000 users and/or sub groups for a single group, you need to provide the path to the S3 file that lists your users and sub groups for a group. Your sub groups can contain more than 1000 users, but the list of sub groups that belong to a group (and/or users) must be no more than 1000.
    /// This member is required.
    public var groupName: Swift.String?
    /// The identifier of the index in which you want to map users to their groups.
    /// This member is required.
    public var indexId: Swift.String?
    /// The type of the group.
    /// This member is required.
    public var type: QBusinessClientTypes.MembershipType?

    public init(
        applicationId: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        groupMembers: QBusinessClientTypes.GroupMembers? = nil,
        groupName: Swift.String? = nil,
        indexId: Swift.String? = nil,
        type: QBusinessClientTypes.MembershipType? = nil
    )
    {
        self.applicationId = applicationId
        self.dataSourceId = dataSourceId
        self.groupMembers = groupMembers
        self.groupName = groupName
        self.indexId = indexId
        self.type = type
    }
}

struct PutGroupInputBody: Swift.Equatable {
    let groupName: Swift.String?
    let dataSourceId: Swift.String?
    let type: QBusinessClientTypes.MembershipType?
    let groupMembers: QBusinessClientTypes.GroupMembers?
}

extension PutGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceId
        case groupMembers
        case groupName
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.MembershipType.self, forKey: .type)
        type = typeDecoded
        let groupMembersDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.GroupMembers.self, forKey: .groupMembers)
        groupMembers = groupMembersDecoded
    }
}

extension PutGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutGroupOutput: Swift.Equatable {

    public init() { }
}

enum PutGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension QBusinessClientTypes {
    public enum ReadAccessType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [ReadAccessType] {
            return [
                .allow,
                .deny,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allow: return "ALLOW"
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReadAccessType(rawValue: rawValue) ?? ReadAccessType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource you want to use doesn’t exist. Make sure you have provided the correct resource and try again.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message describing a ResourceNotFoundException.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier of the resource affected.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource affected.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension QBusinessClientTypes {
    public enum ResponseScope: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enterpriseContentOnly
        case extendedKnowledgeEnabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ResponseScope] {
            return [
                .enterpriseContentOnly,
                .extendedKnowledgeEnabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enterpriseContentOnly: return "ENTERPRISE_CONTENT_ONLY"
            case .extendedKnowledgeEnabled: return "EXTENDED_KNOWLEDGE_ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResponseScope(rawValue: rawValue) ?? ResponseScope.sdkUnknown(rawValue)
        }
    }
}

extension QBusinessClientTypes.Retriever: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId
        case displayName
        case retrieverId
        case status
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let retrieverId = self.retrieverId {
            try encodeContainer.encode(retrieverId, forKey: .retrieverId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let retrieverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .retrieverId)
        retrieverId = retrieverIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.RetrieverType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.RetrieverStatus.self, forKey: .status)
        status = statusDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension QBusinessClientTypes {
    /// Summary information for the retriever used for your Amazon Q application.
    public struct Retriever: Swift.Equatable {
        /// The identifier of the Amazon Q application using the retriever.
        public var applicationId: Swift.String?
        /// The name of your retriever.
        public var displayName: Swift.String?
        /// The identifier of the retriever used by your Amazon Q application.
        public var retrieverId: Swift.String?
        /// The status of your retriever.
        public var status: QBusinessClientTypes.RetrieverStatus?
        /// The type of your retriever.
        public var type: QBusinessClientTypes.RetrieverType?

        public init(
            applicationId: Swift.String? = nil,
            displayName: Swift.String? = nil,
            retrieverId: Swift.String? = nil,
            status: QBusinessClientTypes.RetrieverStatus? = nil,
            type: QBusinessClientTypes.RetrieverType? = nil
        )
        {
            self.applicationId = applicationId
            self.displayName = displayName
            self.retrieverId = retrieverId
            self.status = status
            self.type = type
        }
    }

}

extension QBusinessClientTypes.RetrieverConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kendraindexconfiguration = "kendraIndexConfiguration"
        case nativeindexconfiguration = "nativeIndexConfiguration"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .kendraindexconfiguration(kendraindexconfiguration):
                try container.encode(kendraindexconfiguration, forKey: .kendraindexconfiguration)
            case let .nativeindexconfiguration(nativeindexconfiguration):
                try container.encode(nativeindexconfiguration, forKey: .nativeindexconfiguration)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let nativeindexconfigurationDecoded = try values.decodeIfPresent(QBusinessClientTypes.NativeIndexConfiguration.self, forKey: .nativeindexconfiguration)
        if let nativeindexconfiguration = nativeindexconfigurationDecoded {
            self = .nativeindexconfiguration(nativeindexconfiguration)
            return
        }
        let kendraindexconfigurationDecoded = try values.decodeIfPresent(QBusinessClientTypes.KendraIndexConfiguration.self, forKey: .kendraindexconfiguration)
        if let kendraindexconfiguration = kendraindexconfigurationDecoded {
            self = .kendraindexconfiguration(kendraindexconfiguration)
            return
        }
        self = .sdkUnknown("")
    }
}

extension QBusinessClientTypes {
    /// Provides information on how the retriever used for your Amazon Q application is configured.
    public enum RetrieverConfiguration: Swift.Equatable {
        /// Provides information on how a Amazon Q index used as a retriever for your Amazon Q application is configured.
        case nativeindexconfiguration(QBusinessClientTypes.NativeIndexConfiguration)
        /// Provides information on how the Amazon Kendra index used as a retriever for your Amazon Q application is configured.
        case kendraindexconfiguration(QBusinessClientTypes.KendraIndexConfiguration)
        case sdkUnknown(Swift.String)
    }

}

extension QBusinessClientTypes {
    public enum RetrieverStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [RetrieverStatus] {
            return [
                .active,
                .creating,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RetrieverStatus(rawValue: rawValue) ?? RetrieverStatus.sdkUnknown(rawValue)
        }
    }
}

extension QBusinessClientTypes {
    public enum RetrieverType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case kendraIndex
        case nativeIndex
        case sdkUnknown(Swift.String)

        public static var allCases: [RetrieverType] {
            return [
                .kendraIndex,
                .nativeIndex,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .kendraIndex: return "KENDRA_INDEX"
            case .nativeIndex: return "NATIVE_INDEX"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RetrieverType(rawValue: rawValue) ?? RetrieverType.sdkUnknown(rawValue)
        }
    }
}

extension QBusinessClientTypes.Rule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case excludedUsersAndGroups
        case includedUsersAndGroups
        case ruleConfiguration
        case ruleType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let excludedUsersAndGroups = self.excludedUsersAndGroups {
            try encodeContainer.encode(excludedUsersAndGroups, forKey: .excludedUsersAndGroups)
        }
        if let includedUsersAndGroups = self.includedUsersAndGroups {
            try encodeContainer.encode(includedUsersAndGroups, forKey: .includedUsersAndGroups)
        }
        if let ruleConfiguration = self.ruleConfiguration {
            try encodeContainer.encode(ruleConfiguration, forKey: .ruleConfiguration)
        }
        if let ruleType = self.ruleType {
            try encodeContainer.encode(ruleType.rawValue, forKey: .ruleType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let includedUsersAndGroupsDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.UsersAndGroups.self, forKey: .includedUsersAndGroups)
        includedUsersAndGroups = includedUsersAndGroupsDecoded
        let excludedUsersAndGroupsDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.UsersAndGroups.self, forKey: .excludedUsersAndGroups)
        excludedUsersAndGroups = excludedUsersAndGroupsDecoded
        let ruleTypeDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.RuleType.self, forKey: .ruleType)
        ruleType = ruleTypeDecoded
        let ruleConfigurationDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.RuleConfiguration.self, forKey: .ruleConfiguration)
        ruleConfiguration = ruleConfigurationDecoded
    }
}

extension QBusinessClientTypes {
    /// Guardrail rules for an Amazon Q application. Amazon Q supports only one rule at a time.
    public struct Rule: Swift.Equatable {
        /// Users and groups to be excluded from a rule.
        public var excludedUsersAndGroups: QBusinessClientTypes.UsersAndGroups?
        /// Users and groups to be included in a rule.
        public var includedUsersAndGroups: QBusinessClientTypes.UsersAndGroups?
        /// The configuration information for a rule.
        public var ruleConfiguration: QBusinessClientTypes.RuleConfiguration?
        /// The type fo rule.
        /// This member is required.
        public var ruleType: QBusinessClientTypes.RuleType?

        public init(
            excludedUsersAndGroups: QBusinessClientTypes.UsersAndGroups? = nil,
            includedUsersAndGroups: QBusinessClientTypes.UsersAndGroups? = nil,
            ruleConfiguration: QBusinessClientTypes.RuleConfiguration? = nil,
            ruleType: QBusinessClientTypes.RuleType? = nil
        )
        {
            self.excludedUsersAndGroups = excludedUsersAndGroups
            self.includedUsersAndGroups = includedUsersAndGroups
            self.ruleConfiguration = ruleConfiguration
            self.ruleType = ruleType
        }
    }

}

extension QBusinessClientTypes.RuleConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentblockerrule = "contentBlockerRule"
        case contentretrievalrule = "contentRetrievalRule"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .contentblockerrule(contentblockerrule):
                try container.encode(contentblockerrule, forKey: .contentblockerrule)
            case let .contentretrievalrule(contentretrievalrule):
                try container.encode(contentretrievalrule, forKey: .contentretrievalrule)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let contentblockerruleDecoded = try values.decodeIfPresent(QBusinessClientTypes.ContentBlockerRule.self, forKey: .contentblockerrule)
        if let contentblockerrule = contentblockerruleDecoded {
            self = .contentblockerrule(contentblockerrule)
            return
        }
        let contentretrievalruleDecoded = try values.decodeIfPresent(QBusinessClientTypes.ContentRetrievalRule.self, forKey: .contentretrievalrule)
        if let contentretrievalrule = contentretrievalruleDecoded {
            self = .contentretrievalrule(contentretrievalrule)
            return
        }
        self = .sdkUnknown("")
    }
}

extension QBusinessClientTypes {
    /// Provides configuration information about a rule.
    public enum RuleConfiguration: Swift.Equatable {
        /// A rule for configuring how Amazon Q responds when it encounters a a blocked topic.
        case contentblockerrule(QBusinessClientTypes.ContentBlockerRule)
        /// Rules for retrieving content from data sources connected to a Amazon Q application for a specific topic control configuration.
        case contentretrievalrule(QBusinessClientTypes.ContentRetrievalRule)
        case sdkUnknown(Swift.String)
    }

}

extension QBusinessClientTypes {
    public enum RuleType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case contentBlockerRule
        case contentRetrievalRule
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleType] {
            return [
                .contentBlockerRule,
                .contentRetrievalRule,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .contentBlockerRule: return "CONTENT_BLOCKER_RULE"
            case .contentRetrievalRule: return "CONTENT_RETRIEVAL_RULE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RuleType(rawValue: rawValue) ?? RuleType.sdkUnknown(rawValue)
        }
    }
}

extension QBusinessClientTypes.S3: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case key
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
    }
}

extension QBusinessClientTypes {
    /// Information required for Amazon Q to find a specific file in an Amazon S3 bucket.
    public struct S3: Swift.Equatable {
        /// The name of the S3 bucket that contains the file.
        /// This member is required.
        public var bucket: Swift.String?
        /// The name of the file.
        /// This member is required.
        public var key: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.key = key
        }
    }

}

extension QBusinessClientTypes.SamlConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadataXML
        case roleArn
        case userGroupAttribute
        case userIdAttribute
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadataXML = self.metadataXML {
            try encodeContainer.encode(metadataXML, forKey: .metadataXML)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let userGroupAttribute = self.userGroupAttribute {
            try encodeContainer.encode(userGroupAttribute, forKey: .userGroupAttribute)
        }
        if let userIdAttribute = self.userIdAttribute {
            try encodeContainer.encode(userIdAttribute, forKey: .userIdAttribute)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataXMLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadataXML)
        metadataXML = metadataXMLDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let userIdAttributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userIdAttribute)
        userIdAttribute = userIdAttributeDecoded
        let userGroupAttributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userGroupAttribute)
        userGroupAttribute = userGroupAttributeDecoded
    }
}

extension QBusinessClientTypes {
    /// Provides the SAML 2.0 compliant identity provider (IdP) configuration information Amazon Q needs to deploy a Amazon Q web experience.
    public struct SamlConfiguration: Swift.Equatable {
        /// The metadata XML that your IdP generated.
        /// This member is required.
        public var metadataXML: Swift.String?
        /// The Amazon Resource Name (ARN) of an IAM role assumed by users when they authenticate into their Amazon Q web experience, containing the relevant Amazon Q permissions for conversing with Amazon Q.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The group attribute name in your IdP that maps to user groups.
        public var userGroupAttribute: Swift.String?
        /// The user attribute name in your IdP that maps to the user email.
        /// This member is required.
        public var userIdAttribute: Swift.String?

        public init(
            metadataXML: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            userGroupAttribute: Swift.String? = nil,
            userIdAttribute: Swift.String? = nil
        )
        {
            self.metadataXML = metadataXML
            self.roleArn = roleArn
            self.userGroupAttribute = userGroupAttribute
            self.userIdAttribute = userIdAttribute
        }
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You have exceeded the set limits for your Amazon Q service.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message describing a ServiceQuotaExceededException.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier of the resource affected.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource affected.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension QBusinessClientTypes.SourceAttribution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case citationNumber
        case snippet
        case textMessageSegments
        case title
        case updatedAt
        case url
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let citationNumber = self.citationNumber {
            try encodeContainer.encode(citationNumber, forKey: .citationNumber)
        }
        if let snippet = self.snippet {
            try encodeContainer.encode(snippet, forKey: .snippet)
        }
        if let textMessageSegments = textMessageSegments {
            var textMessageSegmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .textMessageSegments)
            for textsegment0 in textMessageSegments {
                try textMessageSegmentsContainer.encode(textsegment0)
            }
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let snippetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snippet)
        snippet = snippetDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let citationNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .citationNumber)
        citationNumber = citationNumberDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let textMessageSegmentsContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.TextSegment?].self, forKey: .textMessageSegments)
        var textMessageSegmentsDecoded0:[QBusinessClientTypes.TextSegment]? = nil
        if let textMessageSegmentsContainer = textMessageSegmentsContainer {
            textMessageSegmentsDecoded0 = [QBusinessClientTypes.TextSegment]()
            for structure0 in textMessageSegmentsContainer {
                if let structure0 = structure0 {
                    textMessageSegmentsDecoded0?.append(structure0)
                }
            }
        }
        textMessageSegments = textMessageSegmentsDecoded0
    }
}

extension QBusinessClientTypes {
    /// The documents used to generate an Amazon Q web experience response.
    public struct SourceAttribution: Swift.Equatable {
        /// The number attached to a citation in an Amazon Q generated response.
        public var citationNumber: Swift.Int?
        /// The content extract from the document on which the generated response is based.
        public var snippet: Swift.String?
        /// A text extract from a source document that is used for source attribution.
        public var textMessageSegments: [QBusinessClientTypes.TextSegment]?
        /// The title of the document which is the source for the Amazon Q generated response.
        public var title: Swift.String?
        /// The Unix timestamp when the Amazon Q application was last updated.
        public var updatedAt: ClientRuntime.Date?
        /// The URL of the document which is the source for the Amazon Q generated response.
        public var url: Swift.String?

        public init(
            citationNumber: Swift.Int? = nil,
            snippet: Swift.String? = nil,
            textMessageSegments: [QBusinessClientTypes.TextSegment]? = nil,
            title: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            url: Swift.String? = nil
        )
        {
            self.citationNumber = citationNumber
            self.snippet = snippet
            self.textMessageSegments = textMessageSegments
            self.title = title
            self.updatedAt = updatedAt
            self.url = url
        }
    }

}

extension StartDataSourceSyncJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let indexId = indexId else {
            return nil
        }
        guard let dataSourceId = dataSourceId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/indices/\(indexId.urlPercentEncoding())/datasources/\(dataSourceId.urlPercentEncoding())/startsync"
    }
}

public struct StartDataSourceSyncJobInput: Swift.Equatable {
    /// The identifier of Amazon Q application the data source is connected to.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the data source connector.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// The identifier of the index used with the data source connector.
    /// This member is required.
    public var indexId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        indexId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.dataSourceId = dataSourceId
        self.indexId = indexId
    }
}

struct StartDataSourceSyncJobInputBody: Swift.Equatable {
}

extension StartDataSourceSyncJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StartDataSourceSyncJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartDataSourceSyncJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.executionId = output.executionId
        } else {
            self.executionId = nil
        }
    }
}

public struct StartDataSourceSyncJobOutput: Swift.Equatable {
    /// The identifier for a particular synchronization job.
    public var executionId: Swift.String?

    public init(
        executionId: Swift.String? = nil
    )
    {
        self.executionId = executionId
    }
}

struct StartDataSourceSyncJobOutputBody: Swift.Equatable {
    let executionId: Swift.String?
}

extension StartDataSourceSyncJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
    }
}

enum StartDataSourceSyncJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension QBusinessClientTypes {
    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
        }
    }
}

extension StopDataSourceSyncJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let indexId = indexId else {
            return nil
        }
        guard let dataSourceId = dataSourceId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/indices/\(indexId.urlPercentEncoding())/datasources/\(dataSourceId.urlPercentEncoding())/stopsync"
    }
}

public struct StopDataSourceSyncJobInput: Swift.Equatable {
    /// The identifier of the Amazon Q application that the data source is connected to.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the data source connector.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// The identifier of the index used with the Amazon Q data source connector.
    /// This member is required.
    public var indexId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        indexId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.dataSourceId = dataSourceId
        self.indexId = indexId
    }
}

struct StopDataSourceSyncJobInputBody: Swift.Equatable {
}

extension StopDataSourceSyncJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StopDataSourceSyncJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopDataSourceSyncJobOutput: Swift.Equatable {

    public init() { }
}

enum StopDataSourceSyncJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension QBusinessClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension QBusinessClientTypes {
    /// A list of key/value pairs that identify an index, FAQ, or data source. Tag keys and values can consist of Unicode letters, digits, white space, and any of the following symbols: _ . : / = + - @.
    public struct Tag: Swift.Equatable {
        /// The key for the tag. Keys are not case sensitive and must be unique for the Amazon Q application or data source.
        /// This member is required.
        public var key: Swift.String?
        /// The value associated with the tag. The value may be an empty string but it can't be null.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceARN = resourceARN else {
            return nil
        }
        return "/v1/tags/\(resourceARN.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Amazon Q application or data source to tag.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of tag keys to add to the Amazon Q application or data source. If a tag already exists, the existing value is replaced with the new value.
    /// This member is required.
    public var tags: [QBusinessClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [QBusinessClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [QBusinessClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[QBusinessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [QBusinessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension QBusinessClientTypes.TextDocumentStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexedTextBytes
        case indexedTextDocumentCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexedTextBytes = self.indexedTextBytes {
            try encodeContainer.encode(indexedTextBytes, forKey: .indexedTextBytes)
        }
        if let indexedTextDocumentCount = self.indexedTextDocumentCount {
            try encodeContainer.encode(indexedTextDocumentCount, forKey: .indexedTextDocumentCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexedTextBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .indexedTextBytes)
        indexedTextBytes = indexedTextBytesDecoded
        let indexedTextDocumentCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .indexedTextDocumentCount)
        indexedTextDocumentCount = indexedTextDocumentCountDecoded
    }
}

extension QBusinessClientTypes {
    /// Provides information about text documents in an index.
    public struct TextDocumentStatistics: Swift.Equatable {
        /// The total size, in bytes, of the indexed documents.
        public var indexedTextBytes: Swift.Int?
        /// The number of text documents indexed.
        public var indexedTextDocumentCount: Swift.Int?

        public init(
            indexedTextBytes: Swift.Int? = nil,
            indexedTextDocumentCount: Swift.Int? = nil
        )
        {
            self.indexedTextBytes = indexedTextBytes
            self.indexedTextDocumentCount = indexedTextDocumentCount
        }
    }

}

extension QBusinessClientTypes.TextSegment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beginOffset
        case endOffset
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beginOffset = self.beginOffset {
            try encodeContainer.encode(beginOffset, forKey: .beginOffset)
        }
        if let endOffset = self.endOffset {
            try encodeContainer.encode(endOffset, forKey: .endOffset)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let beginOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .beginOffset)
        beginOffset = beginOffsetDecoded
        let endOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endOffset)
        endOffset = endOffsetDecoded
    }
}

extension QBusinessClientTypes {
    /// Provides information about a text extract in a chat response that can be attributed to a source document.
    public struct TextSegment: Swift.Equatable {
        /// The zero-based location in the response string where the source attribution starts.
        public var beginOffset: Swift.Int?
        /// The zero-based location in the response string where the source attribution ends.
        public var endOffset: Swift.Int?

        public init(
            beginOffset: Swift.Int? = nil,
            endOffset: Swift.Int? = nil
        )
        {
            self.beginOffset = beginOffset
            self.endOffset = endOffset
        }
    }

}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to throttling. Reduce the number of requests and try again.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension QBusinessClientTypes.TopicConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case exampleChatMessages
        case name
        case rules
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let exampleChatMessages = exampleChatMessages {
            var exampleChatMessagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exampleChatMessages)
            for examplechatmessage0 in exampleChatMessages {
                try exampleChatMessagesContainer.encode(examplechatmessage0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for rule0 in rules {
                try rulesContainer.encode(rule0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let exampleChatMessagesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .exampleChatMessages)
        var exampleChatMessagesDecoded0:[Swift.String]? = nil
        if let exampleChatMessagesContainer = exampleChatMessagesContainer {
            exampleChatMessagesDecoded0 = [Swift.String]()
            for string0 in exampleChatMessagesContainer {
                if let string0 = string0 {
                    exampleChatMessagesDecoded0?.append(string0)
                }
            }
        }
        exampleChatMessages = exampleChatMessagesDecoded0
        let rulesContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.Rule?].self, forKey: .rules)
        var rulesDecoded0:[QBusinessClientTypes.Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [QBusinessClientTypes.Rule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

extension QBusinessClientTypes {
    /// The topic specific controls configured for an Amazon Q application.
    public struct TopicConfiguration: Swift.Equatable {
        /// A description for your topic control configuration. Use this outline how the large language model (LLM) should use this topic control configuration.
        public var description: Swift.String?
        /// A list of example phrases that you expect the end user to use in relation to the topic.
        public var exampleChatMessages: [Swift.String]?
        /// A name for your topic control configuration.
        /// This member is required.
        public var name: Swift.String?
        /// Rules defined for a topic configuration.
        /// This member is required.
        public var rules: [QBusinessClientTypes.Rule]?

        public init(
            description: Swift.String? = nil,
            exampleChatMessages: [Swift.String]? = nil,
            name: Swift.String? = nil,
            rules: [QBusinessClientTypes.Rule]? = nil
        )
        {
            self.description = description
            self.exampleChatMessages = exampleChatMessages
            self.name = name
            self.rules = rules
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceARN = resourceARN else {
            return nil
        }
        return "/v1/tags/\(resourceARN.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Amazon Q application, or data source to remove the tag from.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of tag keys to remove from the Amazon Q application or data source. If a tag key does not exist on the resource, it is ignored.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentsConfiguration
        case description
        case displayName
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentsConfiguration = self.attachmentsConfiguration {
            try encodeContainer.encode(attachmentsConfiguration, forKey: .attachmentsConfiguration)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

extension UpdateApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())"
    }
}

public struct UpdateApplicationInput: Swift.Equatable {
    /// The identifier of the Amazon Q application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// An option to allow end users to upload files directly during chat.
    public var attachmentsConfiguration: QBusinessClientTypes.AttachmentsConfiguration?
    /// A description for the Amazon Q application.
    public var description: Swift.String?
    /// A name for the Amazon Q application.
    public var displayName: Swift.String?
    /// An Amazon Web Services Identity and Access Management (IAM) role that gives Amazon Q permission to access Amazon CloudWatch logs and metrics.
    public var roleArn: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        attachmentsConfiguration: QBusinessClientTypes.AttachmentsConfiguration? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.attachmentsConfiguration = attachmentsConfiguration
        self.description = description
        self.displayName = displayName
        self.roleArn = roleArn
    }
}

struct UpdateApplicationInputBody: Swift.Equatable {
    let displayName: Swift.String?
    let description: Swift.String?
    let roleArn: Swift.String?
    let attachmentsConfiguration: QBusinessClientTypes.AttachmentsConfiguration?
}

extension UpdateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentsConfiguration
        case description
        case displayName
        case roleArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let attachmentsConfigurationDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.AttachmentsConfiguration.self, forKey: .attachmentsConfiguration)
        attachmentsConfiguration = attachmentsConfigurationDecoded
    }
}

extension UpdateApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateApplicationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateChatControlsConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockedPhrasesConfigurationUpdate
        case clientToken
        case responseScope
        case topicConfigurationsToCreateOrUpdate
        case topicConfigurationsToDelete
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blockedPhrasesConfigurationUpdate = self.blockedPhrasesConfigurationUpdate {
            try encodeContainer.encode(blockedPhrasesConfigurationUpdate, forKey: .blockedPhrasesConfigurationUpdate)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let responseScope = self.responseScope {
            try encodeContainer.encode(responseScope.rawValue, forKey: .responseScope)
        }
        if let topicConfigurationsToCreateOrUpdate = topicConfigurationsToCreateOrUpdate {
            var topicConfigurationsToCreateOrUpdateContainer = encodeContainer.nestedUnkeyedContainer(forKey: .topicConfigurationsToCreateOrUpdate)
            for topicconfiguration0 in topicConfigurationsToCreateOrUpdate {
                try topicConfigurationsToCreateOrUpdateContainer.encode(topicconfiguration0)
            }
        }
        if let topicConfigurationsToDelete = topicConfigurationsToDelete {
            var topicConfigurationsToDeleteContainer = encodeContainer.nestedUnkeyedContainer(forKey: .topicConfigurationsToDelete)
            for topicconfiguration0 in topicConfigurationsToDelete {
                try topicConfigurationsToDeleteContainer.encode(topicconfiguration0)
            }
        }
    }
}

extension UpdateChatControlsConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/chatcontrols"
    }
}

public struct UpdateChatControlsConfigurationInput: Swift.Equatable {
    /// The identifier of the application for which the chat controls are configured.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The phrases blocked from chat by your chat control configuration.
    public var blockedPhrasesConfigurationUpdate: QBusinessClientTypes.BlockedPhrasesConfigurationUpdate?
    /// A token that you provide to identify the request to update a Amazon Q application chat configuration.
    public var clientToken: Swift.String?
    /// The response scope configured for your application. This determines whether your application uses its retrieval augmented generation (RAG) system to generate answers only from your enterprise data, or also uses the large language models (LLM) knowledge to respons to end user questions in chat.
    public var responseScope: QBusinessClientTypes.ResponseScope?
    /// The configured topic specific chat controls you want to update.
    public var topicConfigurationsToCreateOrUpdate: [QBusinessClientTypes.TopicConfiguration]?
    /// The configured topic specific chat controls you want to delete.
    public var topicConfigurationsToDelete: [QBusinessClientTypes.TopicConfiguration]?

    public init(
        applicationId: Swift.String? = nil,
        blockedPhrasesConfigurationUpdate: QBusinessClientTypes.BlockedPhrasesConfigurationUpdate? = nil,
        clientToken: Swift.String? = nil,
        responseScope: QBusinessClientTypes.ResponseScope? = nil,
        topicConfigurationsToCreateOrUpdate: [QBusinessClientTypes.TopicConfiguration]? = nil,
        topicConfigurationsToDelete: [QBusinessClientTypes.TopicConfiguration]? = nil
    )
    {
        self.applicationId = applicationId
        self.blockedPhrasesConfigurationUpdate = blockedPhrasesConfigurationUpdate
        self.clientToken = clientToken
        self.responseScope = responseScope
        self.topicConfigurationsToCreateOrUpdate = topicConfigurationsToCreateOrUpdate
        self.topicConfigurationsToDelete = topicConfigurationsToDelete
    }
}

struct UpdateChatControlsConfigurationInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let responseScope: QBusinessClientTypes.ResponseScope?
    let blockedPhrasesConfigurationUpdate: QBusinessClientTypes.BlockedPhrasesConfigurationUpdate?
    let topicConfigurationsToCreateOrUpdate: [QBusinessClientTypes.TopicConfiguration]?
    let topicConfigurationsToDelete: [QBusinessClientTypes.TopicConfiguration]?
}

extension UpdateChatControlsConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockedPhrasesConfigurationUpdate
        case clientToken
        case responseScope
        case topicConfigurationsToCreateOrUpdate
        case topicConfigurationsToDelete
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let responseScopeDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.ResponseScope.self, forKey: .responseScope)
        responseScope = responseScopeDecoded
        let blockedPhrasesConfigurationUpdateDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.BlockedPhrasesConfigurationUpdate.self, forKey: .blockedPhrasesConfigurationUpdate)
        blockedPhrasesConfigurationUpdate = blockedPhrasesConfigurationUpdateDecoded
        let topicConfigurationsToCreateOrUpdateContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.TopicConfiguration?].self, forKey: .topicConfigurationsToCreateOrUpdate)
        var topicConfigurationsToCreateOrUpdateDecoded0:[QBusinessClientTypes.TopicConfiguration]? = nil
        if let topicConfigurationsToCreateOrUpdateContainer = topicConfigurationsToCreateOrUpdateContainer {
            topicConfigurationsToCreateOrUpdateDecoded0 = [QBusinessClientTypes.TopicConfiguration]()
            for structure0 in topicConfigurationsToCreateOrUpdateContainer {
                if let structure0 = structure0 {
                    topicConfigurationsToCreateOrUpdateDecoded0?.append(structure0)
                }
            }
        }
        topicConfigurationsToCreateOrUpdate = topicConfigurationsToCreateOrUpdateDecoded0
        let topicConfigurationsToDeleteContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.TopicConfiguration?].self, forKey: .topicConfigurationsToDelete)
        var topicConfigurationsToDeleteDecoded0:[QBusinessClientTypes.TopicConfiguration]? = nil
        if let topicConfigurationsToDeleteContainer = topicConfigurationsToDeleteContainer {
            topicConfigurationsToDeleteDecoded0 = [QBusinessClientTypes.TopicConfiguration]()
            for structure0 in topicConfigurationsToDeleteContainer {
                if let structure0 = structure0 {
                    topicConfigurationsToDeleteDecoded0?.append(structure0)
                }
            }
        }
        topicConfigurationsToDelete = topicConfigurationsToDeleteDecoded0
    }
}

extension UpdateChatControlsConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateChatControlsConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateChatControlsConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDataSourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case description
        case displayName
        case documentEnrichmentConfiguration
        case roleArn
        case syncSchedule
        case vpcConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let documentEnrichmentConfiguration = self.documentEnrichmentConfiguration {
            try encodeContainer.encode(documentEnrichmentConfiguration, forKey: .documentEnrichmentConfiguration)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let syncSchedule = self.syncSchedule {
            try encodeContainer.encode(syncSchedule, forKey: .syncSchedule)
        }
        if let vpcConfiguration = self.vpcConfiguration {
            try encodeContainer.encode(vpcConfiguration, forKey: .vpcConfiguration)
        }
    }
}

extension UpdateDataSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let indexId = indexId else {
            return nil
        }
        guard let dataSourceId = dataSourceId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/indices/\(indexId.urlPercentEncoding())/datasources/\(dataSourceId.urlPercentEncoding())"
    }
}

public struct UpdateDataSourceInput: Swift.Equatable {
    /// The identifier of the Amazon Q application the data source is attached to.
    /// This member is required.
    public var applicationId: Swift.String?
    /// Provides the configuration information for an Amazon Q data source.
    public var configuration: ClientRuntime.Document?
    /// The identifier of the data source connector.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// The description of the data source connector.
    public var description: Swift.String?
    /// A name of the data source connector.
    public var displayName: Swift.String?
    /// Provides the configuration information for altering document metadata and content during the document ingestion process. For more information, see [Custom document enrichment](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/custom-document-enrichment.html).
    public var documentEnrichmentConfiguration: QBusinessClientTypes.DocumentEnrichmentConfiguration?
    /// The identifier of the index attached to the data source connector.
    /// This member is required.
    public var indexId: Swift.String?
    /// The Amazon Resource Name (ARN) of an IAM role with permission to access the data source and required resources.
    public var roleArn: Swift.String?
    /// The chosen update frequency for your data source.
    public var syncSchedule: Swift.String?
    /// Provides configuration information needed to connect to an Amazon VPC (Virtual Private Cloud).
    public var vpcConfiguration: QBusinessClientTypes.DataSourceVpcConfiguration?

    public init(
        applicationId: Swift.String? = nil,
        configuration: ClientRuntime.Document? = nil,
        dataSourceId: Swift.String? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        documentEnrichmentConfiguration: QBusinessClientTypes.DocumentEnrichmentConfiguration? = nil,
        indexId: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        syncSchedule: Swift.String? = nil,
        vpcConfiguration: QBusinessClientTypes.DataSourceVpcConfiguration? = nil
    )
    {
        self.applicationId = applicationId
        self.configuration = configuration
        self.dataSourceId = dataSourceId
        self.description = description
        self.displayName = displayName
        self.documentEnrichmentConfiguration = documentEnrichmentConfiguration
        self.indexId = indexId
        self.roleArn = roleArn
        self.syncSchedule = syncSchedule
        self.vpcConfiguration = vpcConfiguration
    }
}

struct UpdateDataSourceInputBody: Swift.Equatable {
    let displayName: Swift.String?
    let configuration: ClientRuntime.Document?
    let vpcConfiguration: QBusinessClientTypes.DataSourceVpcConfiguration?
    let description: Swift.String?
    let syncSchedule: Swift.String?
    let roleArn: Swift.String?
    let documentEnrichmentConfiguration: QBusinessClientTypes.DocumentEnrichmentConfiguration?
}

extension UpdateDataSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case description
        case displayName
        case documentEnrichmentConfiguration
        case roleArn
        case syncSchedule
        case vpcConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .configuration)
        configuration = configurationDecoded
        let vpcConfigurationDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.DataSourceVpcConfiguration.self, forKey: .vpcConfiguration)
        vpcConfiguration = vpcConfigurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let syncScheduleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncSchedule)
        syncSchedule = syncScheduleDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let documentEnrichmentConfigurationDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.DocumentEnrichmentConfiguration.self, forKey: .documentEnrichmentConfiguration)
        documentEnrichmentConfiguration = documentEnrichmentConfigurationDecoded
    }
}

extension UpdateDataSourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateDataSourceOutput: Swift.Equatable {

    public init() { }
}

enum UpdateDataSourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateIndexInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacityConfiguration
        case description
        case displayName
        case documentAttributeConfigurations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capacityConfiguration = self.capacityConfiguration {
            try encodeContainer.encode(capacityConfiguration, forKey: .capacityConfiguration)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let documentAttributeConfigurations = documentAttributeConfigurations {
            var documentAttributeConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .documentAttributeConfigurations)
            for documentattributeconfiguration0 in documentAttributeConfigurations {
                try documentAttributeConfigurationsContainer.encode(documentattributeconfiguration0)
            }
        }
    }
}

extension UpdateIndexInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let indexId = indexId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/indices/\(indexId.urlPercentEncoding())"
    }
}

public struct UpdateIndexInput: Swift.Equatable {
    /// The identifier of the Amazon Q application connected to the index.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The storage capacity units you want to provision for your Amazon Q index. You can add and remove capacity to fit your usage needs.
    public var capacityConfiguration: QBusinessClientTypes.IndexCapacityConfiguration?
    /// The description of the Amazon Q index.
    public var description: Swift.String?
    /// The name of the Amazon Q index.
    public var displayName: Swift.String?
    /// Configuration information for document metadata or fields. Document metadata are fields or attributes associated with your documents. For example, the company department name associated with each document. For more information, see [Understanding document attributes](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/doc-attributes-types.html#doc-attributes).
    public var documentAttributeConfigurations: [QBusinessClientTypes.DocumentAttributeConfiguration]?
    /// The identifier of the Amazon Q index.
    /// This member is required.
    public var indexId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        capacityConfiguration: QBusinessClientTypes.IndexCapacityConfiguration? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        documentAttributeConfigurations: [QBusinessClientTypes.DocumentAttributeConfiguration]? = nil,
        indexId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.capacityConfiguration = capacityConfiguration
        self.description = description
        self.displayName = displayName
        self.documentAttributeConfigurations = documentAttributeConfigurations
        self.indexId = indexId
    }
}

struct UpdateIndexInputBody: Swift.Equatable {
    let displayName: Swift.String?
    let description: Swift.String?
    let capacityConfiguration: QBusinessClientTypes.IndexCapacityConfiguration?
    let documentAttributeConfigurations: [QBusinessClientTypes.DocumentAttributeConfiguration]?
}

extension UpdateIndexInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacityConfiguration
        case description
        case displayName
        case documentAttributeConfigurations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let capacityConfigurationDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.IndexCapacityConfiguration.self, forKey: .capacityConfiguration)
        capacityConfiguration = capacityConfigurationDecoded
        let documentAttributeConfigurationsContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.DocumentAttributeConfiguration?].self, forKey: .documentAttributeConfigurations)
        var documentAttributeConfigurationsDecoded0:[QBusinessClientTypes.DocumentAttributeConfiguration]? = nil
        if let documentAttributeConfigurationsContainer = documentAttributeConfigurationsContainer {
            documentAttributeConfigurationsDecoded0 = [QBusinessClientTypes.DocumentAttributeConfiguration]()
            for structure0 in documentAttributeConfigurationsContainer {
                if let structure0 = structure0 {
                    documentAttributeConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        documentAttributeConfigurations = documentAttributeConfigurationsDecoded0
    }
}

extension UpdateIndexOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateIndexOutput: Swift.Equatable {

    public init() { }
}

enum UpdateIndexOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePluginInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authConfiguration
        case displayName
        case serverUrl
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authConfiguration = self.authConfiguration {
            try encodeContainer.encode(authConfiguration, forKey: .authConfiguration)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let serverUrl = self.serverUrl {
            try encodeContainer.encode(serverUrl, forKey: .serverUrl)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }
}

extension UpdatePluginInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let pluginId = pluginId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/plugins/\(pluginId.urlPercentEncoding())"
    }
}

public struct UpdatePluginInput: Swift.Equatable {
    /// The identifier of the application the plugin is attached to.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The authentication configuration the plugin is using.
    public var authConfiguration: QBusinessClientTypes.PluginAuthConfiguration?
    /// The name of the plugin.
    public var displayName: Swift.String?
    /// The identifier of the plugin.
    /// This member is required.
    public var pluginId: Swift.String?
    /// The source URL used for plugin configuration.
    public var serverUrl: Swift.String?
    /// The status of the plugin.
    public var state: QBusinessClientTypes.PluginState?

    public init(
        applicationId: Swift.String? = nil,
        authConfiguration: QBusinessClientTypes.PluginAuthConfiguration? = nil,
        displayName: Swift.String? = nil,
        pluginId: Swift.String? = nil,
        serverUrl: Swift.String? = nil,
        state: QBusinessClientTypes.PluginState? = nil
    )
    {
        self.applicationId = applicationId
        self.authConfiguration = authConfiguration
        self.displayName = displayName
        self.pluginId = pluginId
        self.serverUrl = serverUrl
        self.state = state
    }
}

struct UpdatePluginInputBody: Swift.Equatable {
    let displayName: Swift.String?
    let state: QBusinessClientTypes.PluginState?
    let serverUrl: Swift.String?
    let authConfiguration: QBusinessClientTypes.PluginAuthConfiguration?
}

extension UpdatePluginInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authConfiguration
        case displayName
        case serverUrl
        case state
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.PluginState.self, forKey: .state)
        state = stateDecoded
        let serverUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverUrl)
        serverUrl = serverUrlDecoded
        let authConfigurationDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.PluginAuthConfiguration.self, forKey: .authConfiguration)
        authConfiguration = authConfigurationDecoded
    }
}

extension UpdatePluginOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdatePluginOutput: Swift.Equatable {

    public init() { }
}

enum UpdatePluginOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateRetrieverInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case displayName
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

extension UpdateRetrieverInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let retrieverId = retrieverId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/retrievers/\(retrieverId.urlPercentEncoding())"
    }
}

public struct UpdateRetrieverInput: Swift.Equatable {
    /// The identifier of your Amazon Q application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// Provides information on how the retriever used for your Amazon Q application is configured.
    public var configuration: QBusinessClientTypes.RetrieverConfiguration?
    /// The name of your retriever.
    public var displayName: Swift.String?
    /// The identifier of your retriever.
    /// This member is required.
    public var retrieverId: Swift.String?
    /// The Amazon Resource Name (ARN) of an IAM role with permission to access the retriever and required resources.
    public var roleArn: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        configuration: QBusinessClientTypes.RetrieverConfiguration? = nil,
        displayName: Swift.String? = nil,
        retrieverId: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.configuration = configuration
        self.displayName = displayName
        self.retrieverId = retrieverId
        self.roleArn = roleArn
    }
}

struct UpdateRetrieverInputBody: Swift.Equatable {
    let configuration: QBusinessClientTypes.RetrieverConfiguration?
    let displayName: Swift.String?
    let roleArn: Swift.String?
}

extension UpdateRetrieverInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case displayName
        case roleArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.RetrieverConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension UpdateRetrieverOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateRetrieverOutput: Swift.Equatable {

    public init() { }
}

enum UpdateRetrieverOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userAliasesToDelete
        case userAliasesToUpdate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userAliasesToDelete = userAliasesToDelete {
            var userAliasesToDeleteContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userAliasesToDelete)
            for useralias0 in userAliasesToDelete {
                try userAliasesToDeleteContainer.encode(useralias0)
            }
        }
        if let userAliasesToUpdate = userAliasesToUpdate {
            var userAliasesToUpdateContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userAliasesToUpdate)
            for useralias0 in userAliasesToUpdate {
                try userAliasesToUpdateContainer.encode(useralias0)
            }
        }
    }
}

extension UpdateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let userId = userId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/users/\(userId.urlPercentEncoding())"
    }
}

public struct UpdateUserInput: Swift.Equatable {
    /// The identifier of the application the user is attached to.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The user aliases attached to the user id that are to be deleted.
    public var userAliasesToDelete: [QBusinessClientTypes.UserAlias]?
    /// The user aliases attached to the user id that are to be updated.
    public var userAliasesToUpdate: [QBusinessClientTypes.UserAlias]?
    /// The email id attached to the user.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        userAliasesToDelete: [QBusinessClientTypes.UserAlias]? = nil,
        userAliasesToUpdate: [QBusinessClientTypes.UserAlias]? = nil,
        userId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.userAliasesToDelete = userAliasesToDelete
        self.userAliasesToUpdate = userAliasesToUpdate
        self.userId = userId
    }
}

struct UpdateUserInputBody: Swift.Equatable {
    let userAliasesToUpdate: [QBusinessClientTypes.UserAlias]?
    let userAliasesToDelete: [QBusinessClientTypes.UserAlias]?
}

extension UpdateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userAliasesToDelete
        case userAliasesToUpdate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userAliasesToUpdateContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.UserAlias?].self, forKey: .userAliasesToUpdate)
        var userAliasesToUpdateDecoded0:[QBusinessClientTypes.UserAlias]? = nil
        if let userAliasesToUpdateContainer = userAliasesToUpdateContainer {
            userAliasesToUpdateDecoded0 = [QBusinessClientTypes.UserAlias]()
            for structure0 in userAliasesToUpdateContainer {
                if let structure0 = structure0 {
                    userAliasesToUpdateDecoded0?.append(structure0)
                }
            }
        }
        userAliasesToUpdate = userAliasesToUpdateDecoded0
        let userAliasesToDeleteContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.UserAlias?].self, forKey: .userAliasesToDelete)
        var userAliasesToDeleteDecoded0:[QBusinessClientTypes.UserAlias]? = nil
        if let userAliasesToDeleteContainer = userAliasesToDeleteContainer {
            userAliasesToDeleteDecoded0 = [QBusinessClientTypes.UserAlias]()
            for structure0 in userAliasesToDeleteContainer {
                if let structure0 = structure0 {
                    userAliasesToDeleteDecoded0?.append(structure0)
                }
            }
        }
        userAliasesToDelete = userAliasesToDeleteDecoded0
    }
}

extension UpdateUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.userAliasesAdded = output.userAliasesAdded
            self.userAliasesDeleted = output.userAliasesDeleted
            self.userAliasesUpdated = output.userAliasesUpdated
        } else {
            self.userAliasesAdded = nil
            self.userAliasesDeleted = nil
            self.userAliasesUpdated = nil
        }
    }
}

public struct UpdateUserOutput: Swift.Equatable {
    /// The user aliases that have been to be added to a user id.
    public var userAliasesAdded: [QBusinessClientTypes.UserAlias]?
    /// The user aliases that have been deleted from a user id.
    public var userAliasesDeleted: [QBusinessClientTypes.UserAlias]?
    /// The user aliases attached to a user id that have been updated.
    public var userAliasesUpdated: [QBusinessClientTypes.UserAlias]?

    public init(
        userAliasesAdded: [QBusinessClientTypes.UserAlias]? = nil,
        userAliasesDeleted: [QBusinessClientTypes.UserAlias]? = nil,
        userAliasesUpdated: [QBusinessClientTypes.UserAlias]? = nil
    )
    {
        self.userAliasesAdded = userAliasesAdded
        self.userAliasesDeleted = userAliasesDeleted
        self.userAliasesUpdated = userAliasesUpdated
    }
}

struct UpdateUserOutputBody: Swift.Equatable {
    let userAliasesAdded: [QBusinessClientTypes.UserAlias]?
    let userAliasesUpdated: [QBusinessClientTypes.UserAlias]?
    let userAliasesDeleted: [QBusinessClientTypes.UserAlias]?
}

extension UpdateUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userAliasesAdded
        case userAliasesDeleted
        case userAliasesUpdated
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userAliasesAddedContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.UserAlias?].self, forKey: .userAliasesAdded)
        var userAliasesAddedDecoded0:[QBusinessClientTypes.UserAlias]? = nil
        if let userAliasesAddedContainer = userAliasesAddedContainer {
            userAliasesAddedDecoded0 = [QBusinessClientTypes.UserAlias]()
            for structure0 in userAliasesAddedContainer {
                if let structure0 = structure0 {
                    userAliasesAddedDecoded0?.append(structure0)
                }
            }
        }
        userAliasesAdded = userAliasesAddedDecoded0
        let userAliasesUpdatedContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.UserAlias?].self, forKey: .userAliasesUpdated)
        var userAliasesUpdatedDecoded0:[QBusinessClientTypes.UserAlias]? = nil
        if let userAliasesUpdatedContainer = userAliasesUpdatedContainer {
            userAliasesUpdatedDecoded0 = [QBusinessClientTypes.UserAlias]()
            for structure0 in userAliasesUpdatedContainer {
                if let structure0 = structure0 {
                    userAliasesUpdatedDecoded0?.append(structure0)
                }
            }
        }
        userAliasesUpdated = userAliasesUpdatedDecoded0
        let userAliasesDeletedContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.UserAlias?].self, forKey: .userAliasesDeleted)
        var userAliasesDeletedDecoded0:[QBusinessClientTypes.UserAlias]? = nil
        if let userAliasesDeletedContainer = userAliasesDeletedContainer {
            userAliasesDeletedDecoded0 = [QBusinessClientTypes.UserAlias]()
            for structure0 in userAliasesDeletedContainer {
                if let structure0 = structure0 {
                    userAliasesDeletedDecoded0?.append(structure0)
                }
            }
        }
        userAliasesDeleted = userAliasesDeletedDecoded0
    }
}

enum UpdateUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateWebExperienceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationConfiguration
        case samplePromptsControlMode
        case subtitle
        case title
        case welcomeMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationConfiguration = self.authenticationConfiguration {
            try encodeContainer.encode(authenticationConfiguration, forKey: .authenticationConfiguration)
        }
        if let samplePromptsControlMode = self.samplePromptsControlMode {
            try encodeContainer.encode(samplePromptsControlMode.rawValue, forKey: .samplePromptsControlMode)
        }
        if let subtitle = self.subtitle {
            try encodeContainer.encode(subtitle, forKey: .subtitle)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let welcomeMessage = self.welcomeMessage {
            try encodeContainer.encode(welcomeMessage, forKey: .welcomeMessage)
        }
    }
}

extension UpdateWebExperienceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let webExperienceId = webExperienceId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/experiences/\(webExperienceId.urlPercentEncoding())"
    }
}

public struct UpdateWebExperienceInput: Swift.Equatable {
    /// The identifier of the Amazon Q application attached to the web experience.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The authentication configuration of the Amazon Q web experience.
    public var authenticationConfiguration: QBusinessClientTypes.WebExperienceAuthConfiguration?
    /// Determines whether sample prompts are enabled in the web experience for an end user.
    public var samplePromptsControlMode: QBusinessClientTypes.WebExperienceSamplePromptsControlMode?
    /// The subtitle of the Amazon Q web experience.
    public var subtitle: Swift.String?
    /// The title of the Amazon Q web experience.
    public var title: Swift.String?
    /// The identifier of the Amazon Q web experience.
    /// This member is required.
    public var webExperienceId: Swift.String?
    /// A customized welcome message for an end user in an Amazon Q web experience.
    public var welcomeMessage: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        authenticationConfiguration: QBusinessClientTypes.WebExperienceAuthConfiguration? = nil,
        samplePromptsControlMode: QBusinessClientTypes.WebExperienceSamplePromptsControlMode? = nil,
        subtitle: Swift.String? = nil,
        title: Swift.String? = nil,
        webExperienceId: Swift.String? = nil,
        welcomeMessage: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.authenticationConfiguration = authenticationConfiguration
        self.samplePromptsControlMode = samplePromptsControlMode
        self.subtitle = subtitle
        self.title = title
        self.webExperienceId = webExperienceId
        self.welcomeMessage = welcomeMessage
    }
}

struct UpdateWebExperienceInputBody: Swift.Equatable {
    let authenticationConfiguration: QBusinessClientTypes.WebExperienceAuthConfiguration?
    let title: Swift.String?
    let subtitle: Swift.String?
    let welcomeMessage: Swift.String?
    let samplePromptsControlMode: QBusinessClientTypes.WebExperienceSamplePromptsControlMode?
}

extension UpdateWebExperienceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationConfiguration
        case samplePromptsControlMode
        case subtitle
        case title
        case welcomeMessage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationConfigurationDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.WebExperienceAuthConfiguration.self, forKey: .authenticationConfiguration)
        authenticationConfiguration = authenticationConfigurationDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let subtitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subtitle)
        subtitle = subtitleDecoded
        let welcomeMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .welcomeMessage)
        welcomeMessage = welcomeMessageDecoded
        let samplePromptsControlModeDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.WebExperienceSamplePromptsControlMode.self, forKey: .samplePromptsControlMode)
        samplePromptsControlMode = samplePromptsControlModeDecoded
    }
}

extension UpdateWebExperienceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateWebExperienceOutput: Swift.Equatable {

    public init() { }
}

enum UpdateWebExperienceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension QBusinessClientTypes.UserAlias: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceId
        case indexId
        case userId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceId = self.dataSourceId {
            try encodeContainer.encode(dataSourceId, forKey: .dataSourceId)
        }
        if let indexId = self.indexId {
            try encodeContainer.encode(indexId, forKey: .indexId)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexId)
        indexId = indexIdDecoded
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

extension QBusinessClientTypes {
    /// Aliases attached to a user id within an Amazon Q application.
    public struct UserAlias: Swift.Equatable {
        /// The identifier of the data source that the user aliases are associated with.
        public var dataSourceId: Swift.String?
        /// The identifier of the index that the user aliases are associated with.
        public var indexId: Swift.String?
        /// The identifier of the user id associated with the user aliases.
        /// This member is required.
        public var userId: Swift.String?

        public init(
            dataSourceId: Swift.String? = nil,
            indexId: Swift.String? = nil,
            userId: Swift.String? = nil
        )
        {
            self.dataSourceId = dataSourceId
            self.indexId = indexId
            self.userId = userId
        }
    }

}

extension QBusinessClientTypes.UsersAndGroups: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userGroups
        case userIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userGroups = userGroups {
            var userGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userGroups)
            for string0 in userGroups {
                try userGroupsContainer.encode(string0)
            }
        }
        if let userIds = userIds {
            var userIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userIds)
            for string0 in userIds {
                try userIdsContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .userIds)
        var userIdsDecoded0:[Swift.String]? = nil
        if let userIdsContainer = userIdsContainer {
            userIdsDecoded0 = [Swift.String]()
            for string0 in userIdsContainer {
                if let string0 = string0 {
                    userIdsDecoded0?.append(string0)
                }
            }
        }
        userIds = userIdsDecoded0
        let userGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .userGroups)
        var userGroupsDecoded0:[Swift.String]? = nil
        if let userGroupsContainer = userGroupsContainer {
            userGroupsDecoded0 = [Swift.String]()
            for string0 in userGroupsContainer {
                if let string0 = string0 {
                    userGroupsDecoded0?.append(string0)
                }
            }
        }
        userGroups = userGroupsDecoded0
    }
}

extension QBusinessClientTypes {
    /// Provides information about users and groups associated with a topic control rule.
    public struct UsersAndGroups: Swift.Equatable {
        /// The user groups associated with a topic control rule.
        public var userGroups: [Swift.String]?
        /// The user ids associated with a topic control rule.
        public var userIds: [Swift.String]?

        public init(
            userGroups: [Swift.String]? = nil,
            userIds: [Swift.String]? = nil
        )
        {
            self.userGroups = userGroups
            self.userIds = userIds
        }
    }

}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.fields = output.fields
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.fields = nil
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input doesn't meet the constraints set by the Amazon Q service. Provide the correct input and try again.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The input field(s) that failed validation.
        public internal(set) var fields: [QBusinessClientTypes.ValidationExceptionField]? = nil
        /// The message describing the ValidationException.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason for the ValidationException.
        /// This member is required.
        public internal(set) var reason: QBusinessClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fields: [QBusinessClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: QBusinessClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fields = fields
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: QBusinessClientTypes.ValidationExceptionReason?
    let fields: [QBusinessClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([QBusinessClientTypes.ValidationExceptionField?].self, forKey: .fields)
        var fieldsDecoded0:[QBusinessClientTypes.ValidationExceptionField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [QBusinessClientTypes.ValidationExceptionField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension QBusinessClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension QBusinessClientTypes {
    /// The input failed to meet the constraints specified by Amazon Q in a specified field.
    public struct ValidationExceptionField: Swift.Equatable {
        /// A message about the validation exception.
        /// This member is required.
        public var message: Swift.String?
        /// The field name where the invalid entry was detected.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension QBusinessClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CANNOT_PARSE"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension QBusinessClientTypes.WebExperience: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case defaultEndpoint
        case status
        case updatedAt
        case webExperienceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let defaultEndpoint = self.defaultEndpoint {
            try encodeContainer.encode(defaultEndpoint, forKey: .defaultEndpoint)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
        if let webExperienceId = self.webExperienceId {
            try encodeContainer.encode(webExperienceId, forKey: .webExperienceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webExperienceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webExperienceId)
        webExperienceId = webExperienceIdDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let defaultEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultEndpoint)
        defaultEndpoint = defaultEndpointDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QBusinessClientTypes.WebExperienceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension QBusinessClientTypes {
    /// Provides information for an Amazon Q web experience.
    public struct WebExperience: Swift.Equatable {
        /// The Unix timestamp when the Amazon Q application was last updated.
        public var createdAt: ClientRuntime.Date?
        /// The endpoint URLs for your Amazon Q web experience. The URLs are unique and fully hosted by Amazon Web Services.
        public var defaultEndpoint: Swift.String?
        /// The status of your Amazon Q web experience.
        public var status: QBusinessClientTypes.WebExperienceStatus?
        /// The Unix timestamp when your Amazon Q web experience was updated.
        public var updatedAt: ClientRuntime.Date?
        /// The identifier of your Amazon Q web experience.
        public var webExperienceId: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            defaultEndpoint: Swift.String? = nil,
            status: QBusinessClientTypes.WebExperienceStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            webExperienceId: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.defaultEndpoint = defaultEndpoint
            self.status = status
            self.updatedAt = updatedAt
            self.webExperienceId = webExperienceId
        }
    }

}

extension QBusinessClientTypes.WebExperienceAuthConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case samlconfiguration = "samlConfiguration"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .samlconfiguration(samlconfiguration):
                try container.encode(samlconfiguration, forKey: .samlconfiguration)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let samlconfigurationDecoded = try values.decodeIfPresent(QBusinessClientTypes.SamlConfiguration.self, forKey: .samlconfiguration)
        if let samlconfiguration = samlconfigurationDecoded {
            self = .samlconfiguration(samlconfiguration)
            return
        }
        self = .sdkUnknown("")
    }
}

extension QBusinessClientTypes {
    /// Provides the authorization configuration information needed to deploy a Amazon Q web experience to end users.
    public enum WebExperienceAuthConfiguration: Swift.Equatable {
        /// Provides the SAML 2.0 compliant identity provider (IdP) configuration information Amazon Q needs to deploy a Amazon Q web experience.
        case samlconfiguration(QBusinessClientTypes.SamlConfiguration)
        case sdkUnknown(Swift.String)
    }

}

extension QBusinessClientTypes {
    public enum WebExperienceSamplePromptsControlMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [WebExperienceSamplePromptsControlMode] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WebExperienceSamplePromptsControlMode(rawValue: rawValue) ?? WebExperienceSamplePromptsControlMode.sdkUnknown(rawValue)
        }
    }
}

extension QBusinessClientTypes {
    public enum WebExperienceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case pendingAuthConfig
        case sdkUnknown(Swift.String)

        public static var allCases: [WebExperienceStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .pendingAuthConfig,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .pendingAuthConfig: return "PENDING_AUTH_CONFIG"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WebExperienceStatus(rawValue: rawValue) ?? WebExperienceStatus.sdkUnknown(rawValue)
        }
    }
}
