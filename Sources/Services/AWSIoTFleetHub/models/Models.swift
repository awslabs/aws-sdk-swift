// Code generated by smithy-swift-codegen. DO NOT EDIT!
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import AWSClientRuntime
import ClientRuntime
import SmithyJSON
import SmithyReadWrite

extension IoTFleetHubClientTypes {

    public enum ApplicationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case createFailed
        case creating
        case deleteFailed
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationState] {
            return [
                .active,
                .createFailed,
                .creating,
                .deleteFailed,
                .deleting
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTFleetHubClientTypes.ApplicationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetHubClientTypes.ApplicationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetHubClientTypes.ApplicationSummary()
        value.applicationId = try reader["applicationId"].readIfPresent()
        value.applicationName = try reader["applicationName"].readIfPresent()
        value.applicationDescription = try reader["applicationDescription"].readIfPresent()
        value.applicationUrl = try reader["applicationUrl"].readIfPresent()
        value.applicationCreationDate = try reader["applicationCreationDate"].readIfPresent() ?? 0
        value.applicationLastUpdateDate = try reader["applicationLastUpdateDate"].readIfPresent() ?? 0
        value.applicationState = try reader["applicationState"].readIfPresent()
        return value
    }
}

extension IoTFleetHubClientTypes {
    /// A summary of information about a Fleet Hub for IoT Device Management web application.
    public struct ApplicationSummary {
        /// The date (in Unix epoch time) when the web application was created.
        public var applicationCreationDate: Swift.Int
        /// An optional description of the web application.
        public var applicationDescription: Swift.String?
        /// The unique Id of the web application.
        /// This member is required.
        public var applicationId: Swift.String?
        /// The date (in Unix epoch time) when the web application was last updated.
        public var applicationLastUpdateDate: Swift.Int
        /// The name of the web application.
        /// This member is required.
        public var applicationName: Swift.String?
        /// The current state of the web application.
        public var applicationState: IoTFleetHubClientTypes.ApplicationState?
        /// The URL of the web application.
        /// This member is required.
        public var applicationUrl: Swift.String?

        public init(
            applicationCreationDate: Swift.Int = 0,
            applicationDescription: Swift.String? = nil,
            applicationId: Swift.String? = nil,
            applicationLastUpdateDate: Swift.Int = 0,
            applicationName: Swift.String? = nil,
            applicationState: IoTFleetHubClientTypes.ApplicationState? = nil,
            applicationUrl: Swift.String? = nil
        )
        {
            self.applicationCreationDate = applicationCreationDate
            self.applicationDescription = applicationDescription
            self.applicationId = applicationId
            self.applicationLastUpdateDate = applicationLastUpdateDate
            self.applicationName = applicationName
            self.applicationState = applicationState
            self.applicationUrl = applicationUrl
        }
    }

}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The request conflicts with the current state of the resource.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CreateApplicationInput {

    static func urlPathProvider(_ value: CreateApplicationInput) -> Swift.String? {
        return "/applications"
    }
}

extension CreateApplicationInput {

    static func write(value: CreateApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["applicationDescription"].write(value.applicationDescription)
        try writer["applicationName"].write(value.applicationName)
        try writer["clientToken"].write(value.clientToken)
        try writer["roleArn"].write(value.roleArn)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct CreateApplicationInput {
    /// An optional description of the web application.
    public var applicationDescription: Swift.String?
    /// The name of the web application.
    /// This member is required.
    public var applicationName: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ARN of the role that the web application assumes when it interacts with Amazon Web Services IoT Core. The name of the role must be in the form AWSIotFleetHub_random_string .
    /// This member is required.
    public var roleArn: Swift.String?
    /// A set of key/value pairs that you can use to manage the web application resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        applicationDescription: Swift.String? = nil,
        applicationName: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.applicationDescription = applicationDescription
        self.applicationName = applicationName
        self.clientToken = clientToken
        self.roleArn = roleArn
        self.tags = tags
    }
}

extension CreateApplicationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateApplicationOutput()
        value.applicationArn = try reader["applicationArn"].readIfPresent()
        value.applicationId = try reader["applicationId"].readIfPresent()
        return value
    }
}

public struct CreateApplicationOutput {
    /// The ARN of the web application.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// The unique Id of the web application.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationArn: Swift.String? = nil,
        applicationId: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
        self.applicationId = applicationId
    }
}

enum CreateApplicationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteApplicationInput {

    static func queryItemProvider(_ value: DeleteApplicationInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension DeleteApplicationInput {

    static func urlPathProvider(_ value: DeleteApplicationInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())"
    }
}

public struct DeleteApplicationInput {
    /// The unique Id of the web application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        clientToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.clientToken = clientToken
    }
}

extension DeleteApplicationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteApplicationOutput {
        return DeleteApplicationOutput()
    }
}

public struct DeleteApplicationOutput {

    public init() { }
}

enum DeleteApplicationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DescribeApplicationInput {

    static func urlPathProvider(_ value: DescribeApplicationInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())"
    }
}

public struct DescribeApplicationInput {
    /// The unique Id of the web application.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

extension DescribeApplicationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DescribeApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeApplicationOutput()
        value.applicationArn = try reader["applicationArn"].readIfPresent()
        value.applicationCreationDate = try reader["applicationCreationDate"].readIfPresent() ?? 0
        value.applicationDescription = try reader["applicationDescription"].readIfPresent()
        value.applicationId = try reader["applicationId"].readIfPresent()
        value.applicationLastUpdateDate = try reader["applicationLastUpdateDate"].readIfPresent() ?? 0
        value.applicationName = try reader["applicationName"].readIfPresent()
        value.applicationState = try reader["applicationState"].readIfPresent()
        value.applicationUrl = try reader["applicationUrl"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.ssoClientId = try reader["ssoClientId"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct DescribeApplicationOutput {
    /// The ARN of the web application.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// The date (in Unix epoch time) when the application was created.
    /// This member is required.
    public var applicationCreationDate: Swift.Int
    /// An optional description of the web application.
    public var applicationDescription: Swift.String?
    /// The unique Id of the web application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The date (in Unix epoch time) when the application was last updated.
    /// This member is required.
    public var applicationLastUpdateDate: Swift.Int
    /// The name of the web application.
    /// This member is required.
    public var applicationName: Swift.String?
    /// The current state of the web application.
    /// This member is required.
    public var applicationState: IoTFleetHubClientTypes.ApplicationState?
    /// The URL of the web application.
    /// This member is required.
    public var applicationUrl: Swift.String?
    /// A message that explains any failures included in the applicationState response field. This message explains failures in the CreateApplication and DeleteApplication actions.
    public var errorMessage: Swift.String?
    /// The ARN of the role that the web application assumes when it interacts with Amazon Web Services IoT Core.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The Id of the single sign-on client that you use to authenticate and authorize users on the web application.
    public var ssoClientId: Swift.String?
    /// A set of key/value pairs that you can use to manage the web application resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        applicationArn: Swift.String? = nil,
        applicationCreationDate: Swift.Int = 0,
        applicationDescription: Swift.String? = nil,
        applicationId: Swift.String? = nil,
        applicationLastUpdateDate: Swift.Int = 0,
        applicationName: Swift.String? = nil,
        applicationState: IoTFleetHubClientTypes.ApplicationState? = nil,
        applicationUrl: Swift.String? = nil,
        errorMessage: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        ssoClientId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.applicationArn = applicationArn
        self.applicationCreationDate = applicationCreationDate
        self.applicationDescription = applicationDescription
        self.applicationId = applicationId
        self.applicationLastUpdateDate = applicationLastUpdateDate
        self.applicationName = applicationName
        self.applicationState = applicationState
        self.applicationUrl = applicationUrl
        self.errorMessage = errorMessage
        self.roleArn = roleArn
        self.ssoClientId = ssoClientId
        self.tags = tags
    }
}

enum DescribeApplicationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InternalFailureException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalFailureException {
        let reader = baseError.errorBodyReader
        var value = InternalFailureException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// An unexpected error has occurred.
public struct InternalFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalFailureException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidRequestException {
        let reader = baseError.errorBodyReader
        var value = InvalidRequestException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The request is not valid.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public enum IoTFleetHubClientTypes {}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// A limit has been exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ListApplicationsInput {

    static func queryItemProvider(_ value: ListApplicationsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListApplicationsInput {

    static func urlPathProvider(_ value: ListApplicationsInput) -> Swift.String? {
        return "/applications"
    }
}

public struct ListApplicationsInput {
    /// A token used to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

extension ListApplicationsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListApplicationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListApplicationsOutput()
        value.applicationSummaries = try reader["applicationSummaries"].readListIfPresent(memberReadingClosure: IoTFleetHubClientTypes.ApplicationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListApplicationsOutput {
    /// An array of objects that provide summaries of information about the web applications in the list.
    public var applicationSummaries: [IoTFleetHubClientTypes.ApplicationSummary]?
    /// A token used to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        applicationSummaries: [IoTFleetHubClientTypes.ApplicationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationSummaries = applicationSummaries
        self.nextToken = nextToken
    }
}

enum ListApplicationsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct ListTagsForResourceOutput {
    /// The list of tags assigned to the resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The specified resource does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct TagResourceInput {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The new or modified tags for the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

public struct TagResourceOutput {

    public init() { }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The rate exceeds the limit.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of the keys of the tags to be removed from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

public struct UntagResourceOutput {

    public init() { }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateApplicationInput {

    static func urlPathProvider(_ value: UpdateApplicationInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())"
    }
}

extension UpdateApplicationInput {

    static func write(value: UpdateApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["applicationDescription"].write(value.applicationDescription)
        try writer["applicationName"].write(value.applicationName)
        try writer["clientToken"].write(value.clientToken)
    }
}

public struct UpdateApplicationInput {
    /// An optional description of the web application.
    public var applicationDescription: Swift.String?
    /// The unique Id of the web application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The name of the web application.
    public var applicationName: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?

    public init(
        applicationDescription: Swift.String? = nil,
        applicationId: Swift.String? = nil,
        applicationName: Swift.String? = nil,
        clientToken: Swift.String? = nil
    )
    {
        self.applicationDescription = applicationDescription
        self.applicationId = applicationId
        self.applicationName = applicationName
        self.clientToken = clientToken
    }
}

extension UpdateApplicationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateApplicationOutput {
        return UpdateApplicationOutput()
    }
}

public struct UpdateApplicationOutput {

    public init() { }
}

enum UpdateApplicationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}
