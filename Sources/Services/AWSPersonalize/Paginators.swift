// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension PersonalizeClient {
    /// Paginate over `[ListBatchInferenceJobsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBatchInferenceJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBatchInferenceJobsOutputResponse`
    public func listBatchInferenceJobsPaginated(input: ListBatchInferenceJobsInput) -> ClientRuntime.PaginatorSequence<ListBatchInferenceJobsInput, ListBatchInferenceJobsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListBatchInferenceJobsInput, ListBatchInferenceJobsOutputResponse>(input: input, inputKey: \ListBatchInferenceJobsInput.nextToken, outputKey: \ListBatchInferenceJobsOutputResponse.nextToken, paginationFunction: self.listBatchInferenceJobs(input:))
    }
}

extension ListBatchInferenceJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBatchInferenceJobsInput {
        return ListBatchInferenceJobsInput(
            maxResults: self.maxResults,
            nextToken: token,
            solutionVersionArn: self.solutionVersionArn
        )}
}

extension PaginatorSequence where Input == ListBatchInferenceJobsInput, Output == ListBatchInferenceJobsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listBatchInferenceJobsPaginated`
    /// to access the nested member `[PersonalizeClientTypes.BatchInferenceJobSummary]`
    /// - Returns: `[PersonalizeClientTypes.BatchInferenceJobSummary]`
    public func batchInferenceJobs() async throws -> [PersonalizeClientTypes.BatchInferenceJobSummary] {
        return try await self.asyncCompactMap { item in item.batchInferenceJobs }
    }
}
extension PersonalizeClient {
    /// Paginate over `[ListBatchSegmentJobsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBatchSegmentJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBatchSegmentJobsOutputResponse`
    public func listBatchSegmentJobsPaginated(input: ListBatchSegmentJobsInput) -> ClientRuntime.PaginatorSequence<ListBatchSegmentJobsInput, ListBatchSegmentJobsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListBatchSegmentJobsInput, ListBatchSegmentJobsOutputResponse>(input: input, inputKey: \ListBatchSegmentJobsInput.nextToken, outputKey: \ListBatchSegmentJobsOutputResponse.nextToken, paginationFunction: self.listBatchSegmentJobs(input:))
    }
}

extension ListBatchSegmentJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBatchSegmentJobsInput {
        return ListBatchSegmentJobsInput(
            maxResults: self.maxResults,
            nextToken: token,
            solutionVersionArn: self.solutionVersionArn
        )}
}

extension PaginatorSequence where Input == ListBatchSegmentJobsInput, Output == ListBatchSegmentJobsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listBatchSegmentJobsPaginated`
    /// to access the nested member `[PersonalizeClientTypes.BatchSegmentJobSummary]`
    /// - Returns: `[PersonalizeClientTypes.BatchSegmentJobSummary]`
    public func batchSegmentJobs() async throws -> [PersonalizeClientTypes.BatchSegmentJobSummary] {
        return try await self.asyncCompactMap { item in item.batchSegmentJobs }
    }
}
extension PersonalizeClient {
    /// Paginate over `[ListCampaignsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListCampaignsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListCampaignsOutputResponse`
    public func listCampaignsPaginated(input: ListCampaignsInput) -> ClientRuntime.PaginatorSequence<ListCampaignsInput, ListCampaignsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListCampaignsInput, ListCampaignsOutputResponse>(input: input, inputKey: \ListCampaignsInput.nextToken, outputKey: \ListCampaignsOutputResponse.nextToken, paginationFunction: self.listCampaigns(input:))
    }
}

extension ListCampaignsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCampaignsInput {
        return ListCampaignsInput(
            maxResults: self.maxResults,
            nextToken: token,
            solutionArn: self.solutionArn
        )}
}

extension PaginatorSequence where Input == ListCampaignsInput, Output == ListCampaignsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listCampaignsPaginated`
    /// to access the nested member `[PersonalizeClientTypes.CampaignSummary]`
    /// - Returns: `[PersonalizeClientTypes.CampaignSummary]`
    public func campaigns() async throws -> [PersonalizeClientTypes.CampaignSummary] {
        return try await self.asyncCompactMap { item in item.campaigns }
    }
}
extension PersonalizeClient {
    /// Paginate over `[ListDatasetExportJobsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDatasetExportJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDatasetExportJobsOutputResponse`
    public func listDatasetExportJobsPaginated(input: ListDatasetExportJobsInput) -> ClientRuntime.PaginatorSequence<ListDatasetExportJobsInput, ListDatasetExportJobsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDatasetExportJobsInput, ListDatasetExportJobsOutputResponse>(input: input, inputKey: \ListDatasetExportJobsInput.nextToken, outputKey: \ListDatasetExportJobsOutputResponse.nextToken, paginationFunction: self.listDatasetExportJobs(input:))
    }
}

extension ListDatasetExportJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDatasetExportJobsInput {
        return ListDatasetExportJobsInput(
            datasetArn: self.datasetArn,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListDatasetExportJobsInput, Output == ListDatasetExportJobsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listDatasetExportJobsPaginated`
    /// to access the nested member `[PersonalizeClientTypes.DatasetExportJobSummary]`
    /// - Returns: `[PersonalizeClientTypes.DatasetExportJobSummary]`
    public func datasetExportJobs() async throws -> [PersonalizeClientTypes.DatasetExportJobSummary] {
        return try await self.asyncCompactMap { item in item.datasetExportJobs }
    }
}
extension PersonalizeClient {
    /// Paginate over `[ListDatasetGroupsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDatasetGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDatasetGroupsOutputResponse`
    public func listDatasetGroupsPaginated(input: ListDatasetGroupsInput) -> ClientRuntime.PaginatorSequence<ListDatasetGroupsInput, ListDatasetGroupsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDatasetGroupsInput, ListDatasetGroupsOutputResponse>(input: input, inputKey: \ListDatasetGroupsInput.nextToken, outputKey: \ListDatasetGroupsOutputResponse.nextToken, paginationFunction: self.listDatasetGroups(input:))
    }
}

extension ListDatasetGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDatasetGroupsInput {
        return ListDatasetGroupsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListDatasetGroupsInput, Output == ListDatasetGroupsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listDatasetGroupsPaginated`
    /// to access the nested member `[PersonalizeClientTypes.DatasetGroupSummary]`
    /// - Returns: `[PersonalizeClientTypes.DatasetGroupSummary]`
    public func datasetGroups() async throws -> [PersonalizeClientTypes.DatasetGroupSummary] {
        return try await self.asyncCompactMap { item in item.datasetGroups }
    }
}
extension PersonalizeClient {
    /// Paginate over `[ListDatasetImportJobsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDatasetImportJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDatasetImportJobsOutputResponse`
    public func listDatasetImportJobsPaginated(input: ListDatasetImportJobsInput) -> ClientRuntime.PaginatorSequence<ListDatasetImportJobsInput, ListDatasetImportJobsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDatasetImportJobsInput, ListDatasetImportJobsOutputResponse>(input: input, inputKey: \ListDatasetImportJobsInput.nextToken, outputKey: \ListDatasetImportJobsOutputResponse.nextToken, paginationFunction: self.listDatasetImportJobs(input:))
    }
}

extension ListDatasetImportJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDatasetImportJobsInput {
        return ListDatasetImportJobsInput(
            datasetArn: self.datasetArn,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListDatasetImportJobsInput, Output == ListDatasetImportJobsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listDatasetImportJobsPaginated`
    /// to access the nested member `[PersonalizeClientTypes.DatasetImportJobSummary]`
    /// - Returns: `[PersonalizeClientTypes.DatasetImportJobSummary]`
    public func datasetImportJobs() async throws -> [PersonalizeClientTypes.DatasetImportJobSummary] {
        return try await self.asyncCompactMap { item in item.datasetImportJobs }
    }
}
extension PersonalizeClient {
    /// Paginate over `[ListDatasetsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDatasetsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDatasetsOutputResponse`
    public func listDatasetsPaginated(input: ListDatasetsInput) -> ClientRuntime.PaginatorSequence<ListDatasetsInput, ListDatasetsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDatasetsInput, ListDatasetsOutputResponse>(input: input, inputKey: \ListDatasetsInput.nextToken, outputKey: \ListDatasetsOutputResponse.nextToken, paginationFunction: self.listDatasets(input:))
    }
}

extension ListDatasetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDatasetsInput {
        return ListDatasetsInput(
            datasetGroupArn: self.datasetGroupArn,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListDatasetsInput, Output == ListDatasetsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listDatasetsPaginated`
    /// to access the nested member `[PersonalizeClientTypes.DatasetSummary]`
    /// - Returns: `[PersonalizeClientTypes.DatasetSummary]`
    public func datasets() async throws -> [PersonalizeClientTypes.DatasetSummary] {
        return try await self.asyncCompactMap { item in item.datasets }
    }
}
extension PersonalizeClient {
    /// Paginate over `[ListEventTrackersOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListEventTrackersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListEventTrackersOutputResponse`
    public func listEventTrackersPaginated(input: ListEventTrackersInput) -> ClientRuntime.PaginatorSequence<ListEventTrackersInput, ListEventTrackersOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListEventTrackersInput, ListEventTrackersOutputResponse>(input: input, inputKey: \ListEventTrackersInput.nextToken, outputKey: \ListEventTrackersOutputResponse.nextToken, paginationFunction: self.listEventTrackers(input:))
    }
}

extension ListEventTrackersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListEventTrackersInput {
        return ListEventTrackersInput(
            datasetGroupArn: self.datasetGroupArn,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListEventTrackersInput, Output == ListEventTrackersOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listEventTrackersPaginated`
    /// to access the nested member `[PersonalizeClientTypes.EventTrackerSummary]`
    /// - Returns: `[PersonalizeClientTypes.EventTrackerSummary]`
    public func eventTrackers() async throws -> [PersonalizeClientTypes.EventTrackerSummary] {
        return try await self.asyncCompactMap { item in item.eventTrackers }
    }
}
extension PersonalizeClient {
    /// Paginate over `[ListFiltersOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFiltersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFiltersOutputResponse`
    public func listFiltersPaginated(input: ListFiltersInput) -> ClientRuntime.PaginatorSequence<ListFiltersInput, ListFiltersOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListFiltersInput, ListFiltersOutputResponse>(input: input, inputKey: \ListFiltersInput.nextToken, outputKey: \ListFiltersOutputResponse.nextToken, paginationFunction: self.listFilters(input:))
    }
}

extension ListFiltersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFiltersInput {
        return ListFiltersInput(
            datasetGroupArn: self.datasetGroupArn,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListFiltersInput, Output == ListFiltersOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listFiltersPaginated`
    /// to access the nested member `[PersonalizeClientTypes.FilterSummary]`
    /// - Returns: `[PersonalizeClientTypes.FilterSummary]`
    public func filters() async throws -> [PersonalizeClientTypes.FilterSummary] {
        return try await self.asyncCompactMap { item in item.filters }
    }
}
extension PersonalizeClient {
    /// Paginate over `[ListMetricAttributionMetricsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListMetricAttributionMetricsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListMetricAttributionMetricsOutputResponse`
    public func listMetricAttributionMetricsPaginated(input: ListMetricAttributionMetricsInput) -> ClientRuntime.PaginatorSequence<ListMetricAttributionMetricsInput, ListMetricAttributionMetricsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListMetricAttributionMetricsInput, ListMetricAttributionMetricsOutputResponse>(input: input, inputKey: \ListMetricAttributionMetricsInput.nextToken, outputKey: \ListMetricAttributionMetricsOutputResponse.nextToken, paginationFunction: self.listMetricAttributionMetrics(input:))
    }
}

extension ListMetricAttributionMetricsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMetricAttributionMetricsInput {
        return ListMetricAttributionMetricsInput(
            maxResults: self.maxResults,
            metricAttributionArn: self.metricAttributionArn,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListMetricAttributionMetricsInput, Output == ListMetricAttributionMetricsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listMetricAttributionMetricsPaginated`
    /// to access the nested member `[PersonalizeClientTypes.MetricAttribute]`
    /// - Returns: `[PersonalizeClientTypes.MetricAttribute]`
    public func metrics() async throws -> [PersonalizeClientTypes.MetricAttribute] {
        return try await self.asyncCompactMap { item in item.metrics }
    }
}
extension PersonalizeClient {
    /// Paginate over `[ListMetricAttributionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListMetricAttributionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListMetricAttributionsOutputResponse`
    public func listMetricAttributionsPaginated(input: ListMetricAttributionsInput) -> ClientRuntime.PaginatorSequence<ListMetricAttributionsInput, ListMetricAttributionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListMetricAttributionsInput, ListMetricAttributionsOutputResponse>(input: input, inputKey: \ListMetricAttributionsInput.nextToken, outputKey: \ListMetricAttributionsOutputResponse.nextToken, paginationFunction: self.listMetricAttributions(input:))
    }
}

extension ListMetricAttributionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMetricAttributionsInput {
        return ListMetricAttributionsInput(
            datasetGroupArn: self.datasetGroupArn,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListMetricAttributionsInput, Output == ListMetricAttributionsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listMetricAttributionsPaginated`
    /// to access the nested member `[PersonalizeClientTypes.MetricAttributionSummary]`
    /// - Returns: `[PersonalizeClientTypes.MetricAttributionSummary]`
    public func metricAttributions() async throws -> [PersonalizeClientTypes.MetricAttributionSummary] {
        return try await self.asyncCompactMap { item in item.metricAttributions }
    }
}
extension PersonalizeClient {
    /// Paginate over `[ListRecipesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRecipesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRecipesOutputResponse`
    public func listRecipesPaginated(input: ListRecipesInput) -> ClientRuntime.PaginatorSequence<ListRecipesInput, ListRecipesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListRecipesInput, ListRecipesOutputResponse>(input: input, inputKey: \ListRecipesInput.nextToken, outputKey: \ListRecipesOutputResponse.nextToken, paginationFunction: self.listRecipes(input:))
    }
}

extension ListRecipesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRecipesInput {
        return ListRecipesInput(
            domain: self.domain,
            maxResults: self.maxResults,
            nextToken: token,
            recipeProvider: self.recipeProvider
        )}
}

extension PaginatorSequence where Input == ListRecipesInput, Output == ListRecipesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listRecipesPaginated`
    /// to access the nested member `[PersonalizeClientTypes.RecipeSummary]`
    /// - Returns: `[PersonalizeClientTypes.RecipeSummary]`
    public func recipes() async throws -> [PersonalizeClientTypes.RecipeSummary] {
        return try await self.asyncCompactMap { item in item.recipes }
    }
}
extension PersonalizeClient {
    /// Paginate over `[ListRecommendersOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRecommendersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRecommendersOutputResponse`
    public func listRecommendersPaginated(input: ListRecommendersInput) -> ClientRuntime.PaginatorSequence<ListRecommendersInput, ListRecommendersOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListRecommendersInput, ListRecommendersOutputResponse>(input: input, inputKey: \ListRecommendersInput.nextToken, outputKey: \ListRecommendersOutputResponse.nextToken, paginationFunction: self.listRecommenders(input:))
    }
}

extension ListRecommendersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRecommendersInput {
        return ListRecommendersInput(
            datasetGroupArn: self.datasetGroupArn,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListRecommendersInput, Output == ListRecommendersOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listRecommendersPaginated`
    /// to access the nested member `[PersonalizeClientTypes.RecommenderSummary]`
    /// - Returns: `[PersonalizeClientTypes.RecommenderSummary]`
    public func recommenders() async throws -> [PersonalizeClientTypes.RecommenderSummary] {
        return try await self.asyncCompactMap { item in item.recommenders }
    }
}
extension PersonalizeClient {
    /// Paginate over `[ListSchemasOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSchemasInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSchemasOutputResponse`
    public func listSchemasPaginated(input: ListSchemasInput) -> ClientRuntime.PaginatorSequence<ListSchemasInput, ListSchemasOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListSchemasInput, ListSchemasOutputResponse>(input: input, inputKey: \ListSchemasInput.nextToken, outputKey: \ListSchemasOutputResponse.nextToken, paginationFunction: self.listSchemas(input:))
    }
}

extension ListSchemasInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSchemasInput {
        return ListSchemasInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListSchemasInput, Output == ListSchemasOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listSchemasPaginated`
    /// to access the nested member `[PersonalizeClientTypes.DatasetSchemaSummary]`
    /// - Returns: `[PersonalizeClientTypes.DatasetSchemaSummary]`
    public func schemas() async throws -> [PersonalizeClientTypes.DatasetSchemaSummary] {
        return try await self.asyncCompactMap { item in item.schemas }
    }
}
extension PersonalizeClient {
    /// Paginate over `[ListSolutionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSolutionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSolutionsOutputResponse`
    public func listSolutionsPaginated(input: ListSolutionsInput) -> ClientRuntime.PaginatorSequence<ListSolutionsInput, ListSolutionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListSolutionsInput, ListSolutionsOutputResponse>(input: input, inputKey: \ListSolutionsInput.nextToken, outputKey: \ListSolutionsOutputResponse.nextToken, paginationFunction: self.listSolutions(input:))
    }
}

extension ListSolutionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSolutionsInput {
        return ListSolutionsInput(
            datasetGroupArn: self.datasetGroupArn,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListSolutionsInput, Output == ListSolutionsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listSolutionsPaginated`
    /// to access the nested member `[PersonalizeClientTypes.SolutionSummary]`
    /// - Returns: `[PersonalizeClientTypes.SolutionSummary]`
    public func solutions() async throws -> [PersonalizeClientTypes.SolutionSummary] {
        return try await self.asyncCompactMap { item in item.solutions }
    }
}
extension PersonalizeClient {
    /// Paginate over `[ListSolutionVersionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSolutionVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSolutionVersionsOutputResponse`
    public func listSolutionVersionsPaginated(input: ListSolutionVersionsInput) -> ClientRuntime.PaginatorSequence<ListSolutionVersionsInput, ListSolutionVersionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListSolutionVersionsInput, ListSolutionVersionsOutputResponse>(input: input, inputKey: \ListSolutionVersionsInput.nextToken, outputKey: \ListSolutionVersionsOutputResponse.nextToken, paginationFunction: self.listSolutionVersions(input:))
    }
}

extension ListSolutionVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSolutionVersionsInput {
        return ListSolutionVersionsInput(
            maxResults: self.maxResults,
            nextToken: token,
            solutionArn: self.solutionArn
        )}
}

extension PaginatorSequence where Input == ListSolutionVersionsInput, Output == ListSolutionVersionsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listSolutionVersionsPaginated`
    /// to access the nested member `[PersonalizeClientTypes.SolutionVersionSummary]`
    /// - Returns: `[PersonalizeClientTypes.SolutionVersionSummary]`
    public func solutionVersions() async throws -> [PersonalizeClientTypes.SolutionVersionSummary] {
        return try await self.asyncCompactMap { item in item.solutionVersions }
    }
}
