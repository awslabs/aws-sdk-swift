// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension PersonalizeClientTypes.Algorithm: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmArn
        case algorithmImage
        case creationDateTime
        case defaultHyperParameterRanges
        case defaultHyperParameters
        case defaultResourceConfig
        case lastUpdatedDateTime
        case name
        case roleArn
        case trainingInputMode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmArn = self.algorithmArn {
            try encodeContainer.encode(algorithmArn, forKey: .algorithmArn)
        }
        if let algorithmImage = self.algorithmImage {
            try encodeContainer.encode(algorithmImage, forKey: .algorithmImage)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let defaultHyperParameterRanges = self.defaultHyperParameterRanges {
            try encodeContainer.encode(defaultHyperParameterRanges, forKey: .defaultHyperParameterRanges)
        }
        if let defaultHyperParameters = defaultHyperParameters {
            var defaultHyperParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .defaultHyperParameters)
            for (dictKey0, hyperParameters0) in defaultHyperParameters {
                try defaultHyperParametersContainer.encode(hyperParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let defaultResourceConfig = defaultResourceConfig {
            var defaultResourceConfigContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .defaultResourceConfig)
            for (dictKey0, resourceConfig0) in defaultResourceConfig {
                try defaultResourceConfigContainer.encode(resourceConfig0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let trainingInputMode = self.trainingInputMode {
            try encodeContainer.encode(trainingInputMode, forKey: .trainingInputMode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let algorithmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .algorithmArn)
        algorithmArn = algorithmArnDecoded
        let algorithmImageDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.AlgorithmImage.self, forKey: .algorithmImage)
        algorithmImage = algorithmImageDecoded
        let defaultHyperParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .defaultHyperParameters)
        var defaultHyperParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let defaultHyperParametersContainer = defaultHyperParametersContainer {
            defaultHyperParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in defaultHyperParametersContainer {
                if let parametervalue0 = parametervalue0 {
                    defaultHyperParametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        defaultHyperParameters = defaultHyperParametersDecoded0
        let defaultHyperParameterRangesDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.DefaultHyperParameterRanges.self, forKey: .defaultHyperParameterRanges)
        defaultHyperParameterRanges = defaultHyperParameterRangesDecoded
        let defaultResourceConfigContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .defaultResourceConfig)
        var defaultResourceConfigDecoded0: [Swift.String:Swift.String]? = nil
        if let defaultResourceConfigContainer = defaultResourceConfigContainer {
            defaultResourceConfigDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in defaultResourceConfigContainer {
                if let parametervalue0 = parametervalue0 {
                    defaultResourceConfigDecoded0?[key0] = parametervalue0
                }
            }
        }
        defaultResourceConfig = defaultResourceConfigDecoded0
        let trainingInputModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trainingInputMode)
        trainingInputMode = trainingInputModeDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension PersonalizeClientTypes {
    /// Describes a custom algorithm.
    public struct Algorithm: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the algorithm.
        public var algorithmArn: Swift.String?
        /// The URI of the Docker container for the algorithm image.
        public var algorithmImage: PersonalizeClientTypes.AlgorithmImage?
        /// The date and time (in Unix time) that the algorithm was created.
        public var creationDateTime: ClientRuntime.Date?
        /// Specifies the default hyperparameters, their ranges, and whether they are tunable. A tunable hyperparameter can have its value determined during hyperparameter optimization (HPO).
        public var defaultHyperParameterRanges: PersonalizeClientTypes.DefaultHyperParameterRanges?
        /// Specifies the default hyperparameters.
        public var defaultHyperParameters: [Swift.String:Swift.String]?
        /// Specifies the default maximum number of training jobs and parallel training jobs.
        public var defaultResourceConfig: [Swift.String:Swift.String]?
        /// The date and time (in Unix time) that the algorithm was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the algorithm.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the role.
        public var roleArn: Swift.String?
        /// The training input mode.
        public var trainingInputMode: Swift.String?

        public init (
            algorithmArn: Swift.String? = nil,
            algorithmImage: PersonalizeClientTypes.AlgorithmImage? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            defaultHyperParameterRanges: PersonalizeClientTypes.DefaultHyperParameterRanges? = nil,
            defaultHyperParameters: [Swift.String:Swift.String]? = nil,
            defaultResourceConfig: [Swift.String:Swift.String]? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            trainingInputMode: Swift.String? = nil
        )
        {
            self.algorithmArn = algorithmArn
            self.algorithmImage = algorithmImage
            self.creationDateTime = creationDateTime
            self.defaultHyperParameterRanges = defaultHyperParameterRanges
            self.defaultHyperParameters = defaultHyperParameters
            self.defaultResourceConfig = defaultResourceConfig
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.roleArn = roleArn
            self.trainingInputMode = trainingInputMode
        }
    }

}

extension PersonalizeClientTypes.AlgorithmImage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dockerURI
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dockerURI = self.dockerURI {
            try encodeContainer.encode(dockerURI, forKey: .dockerURI)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let dockerURIDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dockerURI)
        dockerURI = dockerURIDecoded
    }
}

extension PersonalizeClientTypes {
    /// Describes an algorithm image.
    public struct AlgorithmImage: Swift.Equatable {
        /// The URI of the Docker container for the algorithm image.
        /// This member is required.
        public var dockerURI: Swift.String?
        /// The name of the algorithm image.
        public var name: Swift.String?

        public init (
            dockerURI: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.dockerURI = dockerURI
            self.name = name
        }
    }

}

extension PersonalizeClientTypes.AutoMLConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricName
        case recipeList
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricName = self.metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let recipeList = recipeList {
            var recipeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recipeList)
            for arn0 in recipeList {
                try recipeListContainer.encode(arn0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let recipeListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .recipeList)
        var recipeListDecoded0:[Swift.String]? = nil
        if let recipeListContainer = recipeListContainer {
            recipeListDecoded0 = [Swift.String]()
            for string0 in recipeListContainer {
                if let string0 = string0 {
                    recipeListDecoded0?.append(string0)
                }
            }
        }
        recipeList = recipeListDecoded0
    }
}

extension PersonalizeClientTypes {
    /// When the solution performs AutoML (performAutoML is true in [CreateSolution](https://docs.aws.amazon.com/personalize/latest/dg/API_CreateSolution.html)), Amazon Personalize determines which recipe, from the specified list, optimizes the given metric. Amazon Personalize then uses that recipe for the solution.
    public struct AutoMLConfig: Swift.Equatable {
        /// The metric to optimize.
        public var metricName: Swift.String?
        /// The list of candidate recipes.
        public var recipeList: [Swift.String]?

        public init (
            metricName: Swift.String? = nil,
            recipeList: [Swift.String]? = nil
        )
        {
            self.metricName = metricName
            self.recipeList = recipeList
        }
    }

}

extension PersonalizeClientTypes.AutoMLResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bestRecipeArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bestRecipeArn = self.bestRecipeArn {
            try encodeContainer.encode(bestRecipeArn, forKey: .bestRecipeArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bestRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bestRecipeArn)
        bestRecipeArn = bestRecipeArnDecoded
    }
}

extension PersonalizeClientTypes {
    /// When the solution performs AutoML (performAutoML is true in [CreateSolution](https://docs.aws.amazon.com/personalize/latest/dg/API_CreateSolution.html)), specifies the recipe that best optimized the specified metric.
    public struct AutoMLResult: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the best recipe.
        public var bestRecipeArn: Swift.String?

        public init (
            bestRecipeArn: Swift.String? = nil
        )
        {
            self.bestRecipeArn = bestRecipeArn
        }
    }

}

extension PersonalizeClientTypes.BatchInferenceJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchInferenceJobArn
        case batchInferenceJobConfig
        case creationDateTime
        case failureReason
        case filterArn
        case jobInput
        case jobName
        case jobOutput
        case lastUpdatedDateTime
        case numResults
        case roleArn
        case solutionVersionArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchInferenceJobArn = self.batchInferenceJobArn {
            try encodeContainer.encode(batchInferenceJobArn, forKey: .batchInferenceJobArn)
        }
        if let batchInferenceJobConfig = self.batchInferenceJobConfig {
            try encodeContainer.encode(batchInferenceJobConfig, forKey: .batchInferenceJobConfig)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let filterArn = self.filterArn {
            try encodeContainer.encode(filterArn, forKey: .filterArn)
        }
        if let jobInput = self.jobInput {
            try encodeContainer.encode(jobInput, forKey: .jobInput)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobOutput = self.jobOutput {
            try encodeContainer.encode(jobOutput, forKey: .jobOutput)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let numResults = self.numResults {
            try encodeContainer.encode(numResults, forKey: .numResults)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let solutionVersionArn = self.solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let batchInferenceJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .batchInferenceJobArn)
        batchInferenceJobArn = batchInferenceJobArnDecoded
        let filterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let numResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numResults)
        numResults = numResultsDecoded
        let jobInputDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.BatchInferenceJobInput.self, forKey: .jobInput)
        jobInput = jobInputDecoded
        let jobOutputDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.BatchInferenceJobOutput.self, forKey: .jobOutput)
        jobOutput = jobOutputDecoded
        let batchInferenceJobConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.BatchInferenceJobConfig.self, forKey: .batchInferenceJobConfig)
        batchInferenceJobConfig = batchInferenceJobConfigDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension PersonalizeClientTypes {
    /// Contains information on a batch inference job.
    public struct BatchInferenceJob: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the batch inference job.
        public var batchInferenceJobArn: Swift.String?
        /// A string to string map of the configuration details of a batch inference job.
        public var batchInferenceJobConfig: PersonalizeClientTypes.BatchInferenceJobConfig?
        /// The time at which the batch inference job was created.
        public var creationDateTime: ClientRuntime.Date?
        /// If the batch inference job failed, the reason for the failure.
        public var failureReason: Swift.String?
        /// The ARN of the filter used on the batch inference job.
        public var filterArn: Swift.String?
        /// The Amazon S3 path that leads to the input data used to generate the batch inference job.
        public var jobInput: PersonalizeClientTypes.BatchInferenceJobInput?
        /// The name of the batch inference job.
        public var jobName: Swift.String?
        /// The Amazon S3 bucket that contains the output data generated by the batch inference job.
        public var jobOutput: PersonalizeClientTypes.BatchInferenceJobOutput?
        /// The time at which the batch inference job was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The number of recommendations generated by the batch inference job. This number includes the error messages generated for failed input records.
        public var numResults: Swift.Int?
        /// The ARN of the Amazon Identity and Access Management (IAM) role that requested the batch inference job.
        public var roleArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the solution version from which the batch inference job was created.
        public var solutionVersionArn: Swift.String?
        /// The status of the batch inference job. The status is one of the following values:
        ///
        /// * PENDING
        ///
        /// * IN PROGRESS
        ///
        /// * ACTIVE
        ///
        /// * CREATE FAILED
        public var status: Swift.String?

        public init (
            batchInferenceJobArn: Swift.String? = nil,
            batchInferenceJobConfig: PersonalizeClientTypes.BatchInferenceJobConfig? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            filterArn: Swift.String? = nil,
            jobInput: PersonalizeClientTypes.BatchInferenceJobInput? = nil,
            jobName: Swift.String? = nil,
            jobOutput: PersonalizeClientTypes.BatchInferenceJobOutput? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            numResults: Swift.Int? = nil,
            roleArn: Swift.String? = nil,
            solutionVersionArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.batchInferenceJobArn = batchInferenceJobArn
            self.batchInferenceJobConfig = batchInferenceJobConfig
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.filterArn = filterArn
            self.jobInput = jobInput
            self.jobName = jobName
            self.jobOutput = jobOutput
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.numResults = numResults
            self.roleArn = roleArn
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.BatchInferenceJobConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case itemExplorationConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let itemExplorationConfig = itemExplorationConfig {
            var itemExplorationConfigContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .itemExplorationConfig)
            for (dictKey0, hyperParameters0) in itemExplorationConfig {
                try itemExplorationConfigContainer.encode(hyperParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemExplorationConfigContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .itemExplorationConfig)
        var itemExplorationConfigDecoded0: [Swift.String:Swift.String]? = nil
        if let itemExplorationConfigContainer = itemExplorationConfigContainer {
            itemExplorationConfigDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in itemExplorationConfigContainer {
                if let parametervalue0 = parametervalue0 {
                    itemExplorationConfigDecoded0?[key0] = parametervalue0
                }
            }
        }
        itemExplorationConfig = itemExplorationConfigDecoded0
    }
}

extension PersonalizeClientTypes {
    /// The configuration details of a batch inference job.
    public struct BatchInferenceJobConfig: Swift.Equatable {
        /// A string to string map specifying the exploration configuration hyperparameters, including explorationWeight and explorationItemAgeCutOff, you want to use to configure the amount of item exploration Amazon Personalize uses when recommending items. See [User-Personalization](https://docs.aws.amazon.com/personalize/latest/dg/native-recipe-new-item-USER_PERSONALIZATION.html).
        public var itemExplorationConfig: [Swift.String:Swift.String]?

        public init (
            itemExplorationConfig: [Swift.String:Swift.String]? = nil
        )
        {
            self.itemExplorationConfig = itemExplorationConfig
        }
    }

}

extension PersonalizeClientTypes.BatchInferenceJobInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3DataSource
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3DataSource = self.s3DataSource {
            try encodeContainer.encode(s3DataSource, forKey: .s3DataSource)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3DataSourceDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.S3DataConfig.self, forKey: .s3DataSource)
        s3DataSource = s3DataSourceDecoded
    }
}

extension PersonalizeClientTypes {
    /// The input configuration of a batch inference job.
    public struct BatchInferenceJobInput: Swift.Equatable {
        /// The URI of the Amazon S3 location that contains your input data. The Amazon S3 bucket must be in the same region as the API endpoint you are calling.
        /// This member is required.
        public var s3DataSource: PersonalizeClientTypes.S3DataConfig?

        public init (
            s3DataSource: PersonalizeClientTypes.S3DataConfig? = nil
        )
        {
            self.s3DataSource = s3DataSource
        }
    }

}

extension PersonalizeClientTypes.BatchInferenceJobOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3DataDestination
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3DataDestination = self.s3DataDestination {
            try encodeContainer.encode(s3DataDestination, forKey: .s3DataDestination)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3DataDestinationDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.S3DataConfig.self, forKey: .s3DataDestination)
        s3DataDestination = s3DataDestinationDecoded
    }
}

extension PersonalizeClientTypes {
    /// The output configuration parameters of a batch inference job.
    public struct BatchInferenceJobOutput: Swift.Equatable {
        /// Information on the Amazon S3 bucket in which the batch inference job's output is stored.
        /// This member is required.
        public var s3DataDestination: PersonalizeClientTypes.S3DataConfig?

        public init (
            s3DataDestination: PersonalizeClientTypes.S3DataConfig? = nil
        )
        {
            self.s3DataDestination = s3DataDestination
        }
    }

}

extension PersonalizeClientTypes.BatchInferenceJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchInferenceJobArn
        case creationDateTime
        case failureReason
        case jobName
        case lastUpdatedDateTime
        case solutionVersionArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchInferenceJobArn = self.batchInferenceJobArn {
            try encodeContainer.encode(batchInferenceJobArn, forKey: .batchInferenceJobArn)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let solutionVersionArn = self.solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchInferenceJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .batchInferenceJobArn)
        batchInferenceJobArn = batchInferenceJobArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
    }
}

extension PersonalizeClientTypes {
    /// A truncated version of the [BatchInferenceJob](https://docs.aws.amazon.com/personalize/latest/dg/API_BatchInferenceJob.html). The [ListBatchInferenceJobs](https://docs.aws.amazon.com/personalize/latest/dg/API_ListBatchInferenceJobs.html) operation returns a list of batch inference job summaries.
    public struct BatchInferenceJobSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the batch inference job.
        public var batchInferenceJobArn: Swift.String?
        /// The time at which the batch inference job was created.
        public var creationDateTime: ClientRuntime.Date?
        /// If the batch inference job failed, the reason for the failure.
        public var failureReason: Swift.String?
        /// The name of the batch inference job.
        public var jobName: Swift.String?
        /// The time at which the batch inference job was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The ARN of the solution version used by the batch inference job.
        public var solutionVersionArn: Swift.String?
        /// The status of the batch inference job. The status is one of the following values:
        ///
        /// * PENDING
        ///
        /// * IN PROGRESS
        ///
        /// * ACTIVE
        ///
        /// * CREATE FAILED
        public var status: Swift.String?

        public init (
            batchInferenceJobArn: Swift.String? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            jobName: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            solutionVersionArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.batchInferenceJobArn = batchInferenceJobArn
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.jobName = jobName
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.BatchSegmentJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchSegmentJobArn
        case creationDateTime
        case failureReason
        case filterArn
        case jobInput
        case jobName
        case jobOutput
        case lastUpdatedDateTime
        case numResults
        case roleArn
        case solutionVersionArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchSegmentJobArn = self.batchSegmentJobArn {
            try encodeContainer.encode(batchSegmentJobArn, forKey: .batchSegmentJobArn)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let filterArn = self.filterArn {
            try encodeContainer.encode(filterArn, forKey: .filterArn)
        }
        if let jobInput = self.jobInput {
            try encodeContainer.encode(jobInput, forKey: .jobInput)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobOutput = self.jobOutput {
            try encodeContainer.encode(jobOutput, forKey: .jobOutput)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let numResults = self.numResults {
            try encodeContainer.encode(numResults, forKey: .numResults)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let solutionVersionArn = self.solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let batchSegmentJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .batchSegmentJobArn)
        batchSegmentJobArn = batchSegmentJobArnDecoded
        let filterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let numResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numResults)
        numResults = numResultsDecoded
        let jobInputDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.BatchSegmentJobInput.self, forKey: .jobInput)
        jobInput = jobInputDecoded
        let jobOutputDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.BatchSegmentJobOutput.self, forKey: .jobOutput)
        jobOutput = jobOutputDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension PersonalizeClientTypes {
    /// Contains information on a batch segment job.
    public struct BatchSegmentJob: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the batch segment job.
        public var batchSegmentJobArn: Swift.String?
        /// The time at which the batch segment job was created.
        public var creationDateTime: ClientRuntime.Date?
        /// If the batch segment job failed, the reason for the failure.
        public var failureReason: Swift.String?
        /// The ARN of the filter used on the batch segment job.
        public var filterArn: Swift.String?
        /// The Amazon S3 path that leads to the input data used to generate the batch segment job.
        public var jobInput: PersonalizeClientTypes.BatchSegmentJobInput?
        /// The name of the batch segment job.
        public var jobName: Swift.String?
        /// The Amazon S3 bucket that contains the output data generated by the batch segment job.
        public var jobOutput: PersonalizeClientTypes.BatchSegmentJobOutput?
        /// The time at which the batch segment job last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The number of predicted users generated by the batch segment job for each line of input data.
        public var numResults: Swift.Int?
        /// The ARN of the Amazon Identity and Access Management (IAM) role that requested the batch segment job.
        public var roleArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the solution version used by the batch segment job to generate batch segments.
        public var solutionVersionArn: Swift.String?
        /// The status of the batch segment job. The status is one of the following values:
        ///
        /// * PENDING
        ///
        /// * IN PROGRESS
        ///
        /// * ACTIVE
        ///
        /// * CREATE FAILED
        public var status: Swift.String?

        public init (
            batchSegmentJobArn: Swift.String? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            filterArn: Swift.String? = nil,
            jobInput: PersonalizeClientTypes.BatchSegmentJobInput? = nil,
            jobName: Swift.String? = nil,
            jobOutput: PersonalizeClientTypes.BatchSegmentJobOutput? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            numResults: Swift.Int? = nil,
            roleArn: Swift.String? = nil,
            solutionVersionArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.batchSegmentJobArn = batchSegmentJobArn
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.filterArn = filterArn
            self.jobInput = jobInput
            self.jobName = jobName
            self.jobOutput = jobOutput
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.numResults = numResults
            self.roleArn = roleArn
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.BatchSegmentJobInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3DataSource
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3DataSource = self.s3DataSource {
            try encodeContainer.encode(s3DataSource, forKey: .s3DataSource)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3DataSourceDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.S3DataConfig.self, forKey: .s3DataSource)
        s3DataSource = s3DataSourceDecoded
    }
}

extension PersonalizeClientTypes {
    /// The input configuration of a batch segment job.
    public struct BatchSegmentJobInput: Swift.Equatable {
        /// The configuration details of an Amazon S3 input or output bucket.
        /// This member is required.
        public var s3DataSource: PersonalizeClientTypes.S3DataConfig?

        public init (
            s3DataSource: PersonalizeClientTypes.S3DataConfig? = nil
        )
        {
            self.s3DataSource = s3DataSource
        }
    }

}

extension PersonalizeClientTypes.BatchSegmentJobOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3DataDestination
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3DataDestination = self.s3DataDestination {
            try encodeContainer.encode(s3DataDestination, forKey: .s3DataDestination)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3DataDestinationDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.S3DataConfig.self, forKey: .s3DataDestination)
        s3DataDestination = s3DataDestinationDecoded
    }
}

extension PersonalizeClientTypes {
    /// The output configuration parameters of a batch segment job.
    public struct BatchSegmentJobOutput: Swift.Equatable {
        /// The configuration details of an Amazon S3 input or output bucket.
        /// This member is required.
        public var s3DataDestination: PersonalizeClientTypes.S3DataConfig?

        public init (
            s3DataDestination: PersonalizeClientTypes.S3DataConfig? = nil
        )
        {
            self.s3DataDestination = s3DataDestination
        }
    }

}

extension PersonalizeClientTypes.BatchSegmentJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchSegmentJobArn
        case creationDateTime
        case failureReason
        case jobName
        case lastUpdatedDateTime
        case solutionVersionArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchSegmentJobArn = self.batchSegmentJobArn {
            try encodeContainer.encode(batchSegmentJobArn, forKey: .batchSegmentJobArn)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let solutionVersionArn = self.solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchSegmentJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .batchSegmentJobArn)
        batchSegmentJobArn = batchSegmentJobArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
    }
}

extension PersonalizeClientTypes {
    /// A truncated version of the [BatchSegmentJob](https://docs.aws.amazon.com/personalize/latest/dg/API_BatchSegmentJob.html) datatype. [ListBatchSegmentJobs](https://docs.aws.amazon.com/personalize/latest/dg/API_ListBatchSegmentJobs.html) operation returns a list of batch segment job summaries.
    public struct BatchSegmentJobSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the batch segment job.
        public var batchSegmentJobArn: Swift.String?
        /// The time at which the batch segment job was created.
        public var creationDateTime: ClientRuntime.Date?
        /// If the batch segment job failed, the reason for the failure.
        public var failureReason: Swift.String?
        /// The name of the batch segment job.
        public var jobName: Swift.String?
        /// The time at which the batch segment job was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the solution version used by the batch segment job to generate batch segments.
        public var solutionVersionArn: Swift.String?
        /// The status of the batch segment job. The status is one of the following values:
        ///
        /// * PENDING
        ///
        /// * IN PROGRESS
        ///
        /// * ACTIVE
        ///
        /// * CREATE FAILED
        public var status: Swift.String?

        public init (
            batchSegmentJobArn: Swift.String? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            jobName: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            solutionVersionArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.batchSegmentJobArn = batchSegmentJobArn
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.jobName = jobName
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.Campaign: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignArn
        case campaignConfig
        case creationDateTime
        case failureReason
        case lastUpdatedDateTime
        case latestCampaignUpdate
        case minProvisionedTPS
        case name
        case solutionVersionArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignArn = self.campaignArn {
            try encodeContainer.encode(campaignArn, forKey: .campaignArn)
        }
        if let campaignConfig = self.campaignConfig {
            try encodeContainer.encode(campaignConfig, forKey: .campaignConfig)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let latestCampaignUpdate = self.latestCampaignUpdate {
            try encodeContainer.encode(latestCampaignUpdate, forKey: .latestCampaignUpdate)
        }
        if let minProvisionedTPS = self.minProvisionedTPS {
            try encodeContainer.encode(minProvisionedTPS, forKey: .minProvisionedTPS)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let solutionVersionArn = self.solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let campaignArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .campaignArn)
        campaignArn = campaignArnDecoded
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let minProvisionedTPSDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minProvisionedTPS)
        minProvisionedTPS = minProvisionedTPSDecoded
        let campaignConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.CampaignConfig.self, forKey: .campaignConfig)
        campaignConfig = campaignConfigDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let latestCampaignUpdateDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.CampaignUpdateSummary.self, forKey: .latestCampaignUpdate)
        latestCampaignUpdate = latestCampaignUpdateDecoded
    }
}

extension PersonalizeClientTypes {
    /// An object that describes the deployment of a solution version. For more information on campaigns, see [CreateCampaign](https://docs.aws.amazon.com/personalize/latest/dg/API_CreateCampaign.html).
    public struct Campaign: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the campaign.
        public var campaignArn: Swift.String?
        /// The configuration details of a campaign.
        public var campaignConfig: PersonalizeClientTypes.CampaignConfig?
        /// The date and time (in Unix format) that the campaign was created.
        public var creationDateTime: ClientRuntime.Date?
        /// If a campaign fails, the reason behind the failure.
        public var failureReason: Swift.String?
        /// The date and time (in Unix format) that the campaign was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// Provides a summary of the properties of a campaign update. For a complete listing, call the [DescribeCampaign](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeCampaign.html) API.
        public var latestCampaignUpdate: PersonalizeClientTypes.CampaignUpdateSummary?
        /// Specifies the requested minimum provisioned transactions (recommendations) per second.
        public var minProvisionedTPS: Swift.Int?
        /// The name of the campaign.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of a specific version of the solution.
        public var solutionVersionArn: Swift.String?
        /// The status of the campaign. A campaign can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        /// * DELETE PENDING > DELETE IN_PROGRESS
        public var status: Swift.String?

        public init (
            campaignArn: Swift.String? = nil,
            campaignConfig: PersonalizeClientTypes.CampaignConfig? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            latestCampaignUpdate: PersonalizeClientTypes.CampaignUpdateSummary? = nil,
            minProvisionedTPS: Swift.Int? = nil,
            name: Swift.String? = nil,
            solutionVersionArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.campaignArn = campaignArn
            self.campaignConfig = campaignConfig
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.latestCampaignUpdate = latestCampaignUpdate
            self.minProvisionedTPS = minProvisionedTPS
            self.name = name
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.CampaignConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case itemExplorationConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let itemExplorationConfig = itemExplorationConfig {
            var itemExplorationConfigContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .itemExplorationConfig)
            for (dictKey0, hyperParameters0) in itemExplorationConfig {
                try itemExplorationConfigContainer.encode(hyperParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemExplorationConfigContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .itemExplorationConfig)
        var itemExplorationConfigDecoded0: [Swift.String:Swift.String]? = nil
        if let itemExplorationConfigContainer = itemExplorationConfigContainer {
            itemExplorationConfigDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in itemExplorationConfigContainer {
                if let parametervalue0 = parametervalue0 {
                    itemExplorationConfigDecoded0?[key0] = parametervalue0
                }
            }
        }
        itemExplorationConfig = itemExplorationConfigDecoded0
    }
}

extension PersonalizeClientTypes {
    /// The configuration details of a campaign.
    public struct CampaignConfig: Swift.Equatable {
        /// Specifies the exploration configuration hyperparameters, including explorationWeight and explorationItemAgeCutOff, you want to use to configure the amount of item exploration Amazon Personalize uses when recommending items. Provide itemExplorationConfig data only if your solution uses the [User-Personalization](https://docs.aws.amazon.com/personalize/latest/dg/native-recipe-new-item-USER_PERSONALIZATION.html) recipe.
        public var itemExplorationConfig: [Swift.String:Swift.String]?

        public init (
            itemExplorationConfig: [Swift.String:Swift.String]? = nil
        )
        {
            self.itemExplorationConfig = itemExplorationConfig
        }
    }

}

extension PersonalizeClientTypes.CampaignSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignArn
        case creationDateTime
        case failureReason
        case lastUpdatedDateTime
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignArn = self.campaignArn {
            try encodeContainer.encode(campaignArn, forKey: .campaignArn)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let campaignArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .campaignArn)
        campaignArn = campaignArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides a summary of the properties of a campaign. For a complete listing, call the [DescribeCampaign](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeCampaign.html) API.
    public struct CampaignSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the campaign.
        public var campaignArn: Swift.String?
        /// The date and time (in Unix time) that the campaign was created.
        public var creationDateTime: ClientRuntime.Date?
        /// If a campaign fails, the reason behind the failure.
        public var failureReason: Swift.String?
        /// The date and time (in Unix time) that the campaign was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the campaign.
        public var name: Swift.String?
        /// The status of the campaign. A campaign can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        /// * DELETE PENDING > DELETE IN_PROGRESS
        public var status: Swift.String?

        public init (
            campaignArn: Swift.String? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.campaignArn = campaignArn
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.CampaignUpdateSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignConfig
        case creationDateTime
        case failureReason
        case lastUpdatedDateTime
        case minProvisionedTPS
        case solutionVersionArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignConfig = self.campaignConfig {
            try encodeContainer.encode(campaignConfig, forKey: .campaignConfig)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let minProvisionedTPS = self.minProvisionedTPS {
            try encodeContainer.encode(minProvisionedTPS, forKey: .minProvisionedTPS)
        }
        if let solutionVersionArn = self.solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let minProvisionedTPSDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minProvisionedTPS)
        minProvisionedTPS = minProvisionedTPSDecoded
        let campaignConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.CampaignConfig.self, forKey: .campaignConfig)
        campaignConfig = campaignConfigDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides a summary of the properties of a campaign update. For a complete listing, call the [DescribeCampaign](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeCampaign.html) API.
    public struct CampaignUpdateSummary: Swift.Equatable {
        /// The configuration details of a campaign.
        public var campaignConfig: PersonalizeClientTypes.CampaignConfig?
        /// The date and time (in Unix time) that the campaign update was created.
        public var creationDateTime: ClientRuntime.Date?
        /// If a campaign update fails, the reason behind the failure.
        public var failureReason: Swift.String?
        /// The date and time (in Unix time) that the campaign update was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// Specifies the requested minimum provisioned transactions (recommendations) per second that Amazon Personalize will support.
        public var minProvisionedTPS: Swift.Int?
        /// The Amazon Resource Name (ARN) of the deployed solution version.
        public var solutionVersionArn: Swift.String?
        /// The status of the campaign update. A campaign update can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        /// * DELETE PENDING > DELETE IN_PROGRESS
        public var status: Swift.String?

        public init (
            campaignConfig: PersonalizeClientTypes.CampaignConfig? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            minProvisionedTPS: Swift.Int? = nil,
            solutionVersionArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.campaignConfig = campaignConfig
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.minProvisionedTPS = minProvisionedTPS
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.CategoricalHyperParameterRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for categoricalvalue0 in values {
                try valuesContainer.encode(categoricalvalue0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension PersonalizeClientTypes {
    /// Provides the name and range of a categorical hyperparameter.
    public struct CategoricalHyperParameterRange: Swift.Equatable {
        /// The name of the hyperparameter.
        public var name: Swift.String?
        /// A list of the categories for the hyperparameter.
        public var values: [Swift.String]?

        public init (
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension PersonalizeClientTypes.ContinuousHyperParameterRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxValue
        case minValue
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxValue != 0.0 {
            try encodeContainer.encode(maxValue, forKey: .maxValue)
        }
        if minValue != 0.0 {
            try encodeContainer.encode(minValue, forKey: .minValue)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let minValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .minValue) ?? 0.0
        minValue = minValueDecoded
        let maxValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .maxValue) ?? 0.0
        maxValue = maxValueDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides the name and range of a continuous hyperparameter.
    public struct ContinuousHyperParameterRange: Swift.Equatable {
        /// The maximum allowable value for the hyperparameter.
        public var maxValue: Swift.Double
        /// The minimum allowable value for the hyperparameter.
        public var minValue: Swift.Double
        /// The name of the hyperparameter.
        public var name: Swift.String?

        public init (
            maxValue: Swift.Double = 0.0,
            minValue: Swift.Double = 0.0,
            name: Swift.String? = nil
        )
        {
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
        }
    }

}

extension CreateBatchInferenceJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchInferenceJobConfig
        case filterArn
        case jobInput
        case jobName
        case jobOutput
        case numResults
        case roleArn
        case solutionVersionArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchInferenceJobConfig = self.batchInferenceJobConfig {
            try encodeContainer.encode(batchInferenceJobConfig, forKey: .batchInferenceJobConfig)
        }
        if let filterArn = self.filterArn {
            try encodeContainer.encode(filterArn, forKey: .filterArn)
        }
        if let jobInput = self.jobInput {
            try encodeContainer.encode(jobInput, forKey: .jobInput)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobOutput = self.jobOutput {
            try encodeContainer.encode(jobOutput, forKey: .jobOutput)
        }
        if let numResults = self.numResults {
            try encodeContainer.encode(numResults, forKey: .numResults)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let solutionVersionArn = self.solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateBatchInferenceJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateBatchInferenceJobInput: Swift.Equatable {
    /// The configuration details of a batch inference job.
    public var batchInferenceJobConfig: PersonalizeClientTypes.BatchInferenceJobConfig?
    /// The ARN of the filter to apply to the batch inference job. For more information on using filters, see [Filtering batch recommendations](https://docs.aws.amazon.com/personalize/latest/dg/filter-batch.html).
    public var filterArn: Swift.String?
    /// The Amazon S3 path that leads to the input file to base your recommendations on. The input material must be in JSON format.
    /// This member is required.
    public var jobInput: PersonalizeClientTypes.BatchInferenceJobInput?
    /// The name of the batch inference job to create.
    /// This member is required.
    public var jobName: Swift.String?
    /// The path to the Amazon S3 bucket where the job's output will be stored.
    /// This member is required.
    public var jobOutput: PersonalizeClientTypes.BatchInferenceJobOutput?
    /// The number of recommendations to retrieve.
    public var numResults: Swift.Int?
    /// The ARN of the Amazon Identity and Access Management role that has permissions to read and write to your input and output Amazon S3 buckets respectively.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the solution version that will be used to generate the batch inference recommendations.
    /// This member is required.
    public var solutionVersionArn: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/personalize/latest/dev/tagging-resources.html) to apply to the batch inference job.
    public var tags: [PersonalizeClientTypes.Tag]?

    public init (
        batchInferenceJobConfig: PersonalizeClientTypes.BatchInferenceJobConfig? = nil,
        filterArn: Swift.String? = nil,
        jobInput: PersonalizeClientTypes.BatchInferenceJobInput? = nil,
        jobName: Swift.String? = nil,
        jobOutput: PersonalizeClientTypes.BatchInferenceJobOutput? = nil,
        numResults: Swift.Int? = nil,
        roleArn: Swift.String? = nil,
        solutionVersionArn: Swift.String? = nil,
        tags: [PersonalizeClientTypes.Tag]? = nil
    )
    {
        self.batchInferenceJobConfig = batchInferenceJobConfig
        self.filterArn = filterArn
        self.jobInput = jobInput
        self.jobName = jobName
        self.jobOutput = jobOutput
        self.numResults = numResults
        self.roleArn = roleArn
        self.solutionVersionArn = solutionVersionArn
        self.tags = tags
    }
}

struct CreateBatchInferenceJobInputBody: Swift.Equatable {
    let jobName: Swift.String?
    let solutionVersionArn: Swift.String?
    let filterArn: Swift.String?
    let numResults: Swift.Int?
    let jobInput: PersonalizeClientTypes.BatchInferenceJobInput?
    let jobOutput: PersonalizeClientTypes.BatchInferenceJobOutput?
    let roleArn: Swift.String?
    let batchInferenceJobConfig: PersonalizeClientTypes.BatchInferenceJobConfig?
    let tags: [PersonalizeClientTypes.Tag]?
}

extension CreateBatchInferenceJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchInferenceJobConfig
        case filterArn
        case jobInput
        case jobName
        case jobOutput
        case numResults
        case roleArn
        case solutionVersionArn
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let filterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
        let numResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numResults)
        numResults = numResultsDecoded
        let jobInputDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.BatchInferenceJobInput.self, forKey: .jobInput)
        jobInput = jobInputDecoded
        let jobOutputDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.BatchInferenceJobOutput.self, forKey: .jobOutput)
        jobOutput = jobOutputDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let batchInferenceJobConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.BatchInferenceJobConfig.self, forKey: .batchInferenceJobConfig)
        batchInferenceJobConfig = batchInferenceJobConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PersonalizeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PersonalizeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateBatchInferenceJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBatchInferenceJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateBatchInferenceJobOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBatchInferenceJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateBatchInferenceJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.batchInferenceJobArn = output.batchInferenceJobArn
        } else {
            self.batchInferenceJobArn = nil
        }
    }
}

public struct CreateBatchInferenceJobOutputResponse: Swift.Equatable {
    /// The ARN of the batch inference job.
    public var batchInferenceJobArn: Swift.String?

    public init (
        batchInferenceJobArn: Swift.String? = nil
    )
    {
        self.batchInferenceJobArn = batchInferenceJobArn
    }
}

struct CreateBatchInferenceJobOutputResponseBody: Swift.Equatable {
    let batchInferenceJobArn: Swift.String?
}

extension CreateBatchInferenceJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchInferenceJobArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchInferenceJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .batchInferenceJobArn)
        batchInferenceJobArn = batchInferenceJobArnDecoded
    }
}

extension CreateBatchSegmentJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterArn
        case jobInput
        case jobName
        case jobOutput
        case numResults
        case roleArn
        case solutionVersionArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterArn = self.filterArn {
            try encodeContainer.encode(filterArn, forKey: .filterArn)
        }
        if let jobInput = self.jobInput {
            try encodeContainer.encode(jobInput, forKey: .jobInput)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobOutput = self.jobOutput {
            try encodeContainer.encode(jobOutput, forKey: .jobOutput)
        }
        if let numResults = self.numResults {
            try encodeContainer.encode(numResults, forKey: .numResults)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let solutionVersionArn = self.solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateBatchSegmentJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateBatchSegmentJobInput: Swift.Equatable {
    /// The ARN of the filter to apply to the batch segment job. For more information on using filters, see [Filtering batch recommendations](https://docs.aws.amazon.com/personalize/latest/dg/filter-batch.html).
    public var filterArn: Swift.String?
    /// The Amazon S3 path for the input data used to generate the batch segment job.
    /// This member is required.
    public var jobInput: PersonalizeClientTypes.BatchSegmentJobInput?
    /// The name of the batch segment job to create.
    /// This member is required.
    public var jobName: Swift.String?
    /// The Amazon S3 path for the bucket where the job's output will be stored.
    /// This member is required.
    public var jobOutput: PersonalizeClientTypes.BatchSegmentJobOutput?
    /// The number of predicted users generated by the batch segment job for each line of input data.
    public var numResults: Swift.Int?
    /// The ARN of the Amazon Identity and Access Management role that has permissions to read and write to your input and output Amazon S3 buckets respectively.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the solution version you want the batch segment job to use to generate batch segments.
    /// This member is required.
    public var solutionVersionArn: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/personalize/latest/dev/tagging-resources.html) to apply to the batch segment job.
    public var tags: [PersonalizeClientTypes.Tag]?

    public init (
        filterArn: Swift.String? = nil,
        jobInput: PersonalizeClientTypes.BatchSegmentJobInput? = nil,
        jobName: Swift.String? = nil,
        jobOutput: PersonalizeClientTypes.BatchSegmentJobOutput? = nil,
        numResults: Swift.Int? = nil,
        roleArn: Swift.String? = nil,
        solutionVersionArn: Swift.String? = nil,
        tags: [PersonalizeClientTypes.Tag]? = nil
    )
    {
        self.filterArn = filterArn
        self.jobInput = jobInput
        self.jobName = jobName
        self.jobOutput = jobOutput
        self.numResults = numResults
        self.roleArn = roleArn
        self.solutionVersionArn = solutionVersionArn
        self.tags = tags
    }
}

struct CreateBatchSegmentJobInputBody: Swift.Equatable {
    let jobName: Swift.String?
    let solutionVersionArn: Swift.String?
    let filterArn: Swift.String?
    let numResults: Swift.Int?
    let jobInput: PersonalizeClientTypes.BatchSegmentJobInput?
    let jobOutput: PersonalizeClientTypes.BatchSegmentJobOutput?
    let roleArn: Swift.String?
    let tags: [PersonalizeClientTypes.Tag]?
}

extension CreateBatchSegmentJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterArn
        case jobInput
        case jobName
        case jobOutput
        case numResults
        case roleArn
        case solutionVersionArn
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let filterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
        let numResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numResults)
        numResults = numResultsDecoded
        let jobInputDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.BatchSegmentJobInput.self, forKey: .jobInput)
        jobInput = jobInputDecoded
        let jobOutputDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.BatchSegmentJobOutput.self, forKey: .jobOutput)
        jobOutput = jobOutputDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PersonalizeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PersonalizeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateBatchSegmentJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBatchSegmentJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateBatchSegmentJobOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBatchSegmentJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateBatchSegmentJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.batchSegmentJobArn = output.batchSegmentJobArn
        } else {
            self.batchSegmentJobArn = nil
        }
    }
}

public struct CreateBatchSegmentJobOutputResponse: Swift.Equatable {
    /// The ARN of the batch segment job.
    public var batchSegmentJobArn: Swift.String?

    public init (
        batchSegmentJobArn: Swift.String? = nil
    )
    {
        self.batchSegmentJobArn = batchSegmentJobArn
    }
}

struct CreateBatchSegmentJobOutputResponseBody: Swift.Equatable {
    let batchSegmentJobArn: Swift.String?
}

extension CreateBatchSegmentJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchSegmentJobArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchSegmentJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .batchSegmentJobArn)
        batchSegmentJobArn = batchSegmentJobArnDecoded
    }
}

extension CreateCampaignInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignConfig
        case minProvisionedTPS
        case name
        case solutionVersionArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignConfig = self.campaignConfig {
            try encodeContainer.encode(campaignConfig, forKey: .campaignConfig)
        }
        if let minProvisionedTPS = self.minProvisionedTPS {
            try encodeContainer.encode(minProvisionedTPS, forKey: .minProvisionedTPS)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let solutionVersionArn = self.solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateCampaignInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateCampaignInput: Swift.Equatable {
    /// The configuration details of a campaign.
    public var campaignConfig: PersonalizeClientTypes.CampaignConfig?
    /// Specifies the requested minimum provisioned transactions (recommendations) per second that Amazon Personalize will support.
    public var minProvisionedTPS: Swift.Int?
    /// A name for the new campaign. The campaign name must be unique within your account.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the solution version to deploy.
    /// This member is required.
    public var solutionVersionArn: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/personalize/latest/dev/tagging-resources.html) to apply to the campaign.
    public var tags: [PersonalizeClientTypes.Tag]?

    public init (
        campaignConfig: PersonalizeClientTypes.CampaignConfig? = nil,
        minProvisionedTPS: Swift.Int? = nil,
        name: Swift.String? = nil,
        solutionVersionArn: Swift.String? = nil,
        tags: [PersonalizeClientTypes.Tag]? = nil
    )
    {
        self.campaignConfig = campaignConfig
        self.minProvisionedTPS = minProvisionedTPS
        self.name = name
        self.solutionVersionArn = solutionVersionArn
        self.tags = tags
    }
}

struct CreateCampaignInputBody: Swift.Equatable {
    let name: Swift.String?
    let solutionVersionArn: Swift.String?
    let minProvisionedTPS: Swift.Int?
    let campaignConfig: PersonalizeClientTypes.CampaignConfig?
    let tags: [PersonalizeClientTypes.Tag]?
}

extension CreateCampaignInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignConfig
        case minProvisionedTPS
        case name
        case solutionVersionArn
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let minProvisionedTPSDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minProvisionedTPS)
        minProvisionedTPS = minProvisionedTPSDecoded
        let campaignConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.CampaignConfig.self, forKey: .campaignConfig)
        campaignConfig = campaignConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PersonalizeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PersonalizeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateCampaignOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCampaignOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateCampaignOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCampaignOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateCampaignOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.campaignArn = output.campaignArn
        } else {
            self.campaignArn = nil
        }
    }
}

public struct CreateCampaignOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the campaign.
    public var campaignArn: Swift.String?

    public init (
        campaignArn: Swift.String? = nil
    )
    {
        self.campaignArn = campaignArn
    }
}

struct CreateCampaignOutputResponseBody: Swift.Equatable {
    let campaignArn: Swift.String?
}

extension CreateCampaignOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .campaignArn)
        campaignArn = campaignArnDecoded
    }
}

extension CreateDatasetExportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn
        case ingestionMode
        case jobName
        case jobOutput
        case roleArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArn = self.datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let ingestionMode = self.ingestionMode {
            try encodeContainer.encode(ingestionMode.rawValue, forKey: .ingestionMode)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobOutput = self.jobOutput {
            try encodeContainer.encode(jobOutput, forKey: .jobOutput)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateDatasetExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateDatasetExportJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset that contains the data to export.
    /// This member is required.
    public var datasetArn: Swift.String?
    /// The data to export, based on how you imported the data. You can choose to export only BULK data that you imported using a dataset import job, only PUT data that you imported incrementally (using the console, PutEvents, PutUsers and PutItems operations), or ALL for both types. The default value is PUT.
    public var ingestionMode: PersonalizeClientTypes.IngestionMode?
    /// The name for the dataset export job.
    /// This member is required.
    public var jobName: Swift.String?
    /// The path to the Amazon S3 bucket where the job's output is stored.
    /// This member is required.
    public var jobOutput: PersonalizeClientTypes.DatasetExportJobOutput?
    /// The Amazon Resource Name (ARN) of the IAM service role that has permissions to add data to your output Amazon S3 bucket.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/personalize/latest/dev/tagging-resources.html) to apply to the dataset export job.
    public var tags: [PersonalizeClientTypes.Tag]?

    public init (
        datasetArn: Swift.String? = nil,
        ingestionMode: PersonalizeClientTypes.IngestionMode? = nil,
        jobName: Swift.String? = nil,
        jobOutput: PersonalizeClientTypes.DatasetExportJobOutput? = nil,
        roleArn: Swift.String? = nil,
        tags: [PersonalizeClientTypes.Tag]? = nil
    )
    {
        self.datasetArn = datasetArn
        self.ingestionMode = ingestionMode
        self.jobName = jobName
        self.jobOutput = jobOutput
        self.roleArn = roleArn
        self.tags = tags
    }
}

struct CreateDatasetExportJobInputBody: Swift.Equatable {
    let jobName: Swift.String?
    let datasetArn: Swift.String?
    let ingestionMode: PersonalizeClientTypes.IngestionMode?
    let roleArn: Swift.String?
    let jobOutput: PersonalizeClientTypes.DatasetExportJobOutput?
    let tags: [PersonalizeClientTypes.Tag]?
}

extension CreateDatasetExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn
        case ingestionMode
        case jobName
        case jobOutput
        case roleArn
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let ingestionModeDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.IngestionMode.self, forKey: .ingestionMode)
        ingestionMode = ingestionModeDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let jobOutputDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.DatasetExportJobOutput.self, forKey: .jobOutput)
        jobOutput = jobOutputDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PersonalizeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PersonalizeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDatasetExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatasetExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDatasetExportJobOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatasetExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateDatasetExportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetExportJobArn = output.datasetExportJobArn
        } else {
            self.datasetExportJobArn = nil
        }
    }
}

public struct CreateDatasetExportJobOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset export job.
    public var datasetExportJobArn: Swift.String?

    public init (
        datasetExportJobArn: Swift.String? = nil
    )
    {
        self.datasetExportJobArn = datasetExportJobArn
    }
}

struct CreateDatasetExportJobOutputResponseBody: Swift.Equatable {
    let datasetExportJobArn: Swift.String?
}

extension CreateDatasetExportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetExportJobArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetExportJobArn)
        datasetExportJobArn = datasetExportJobArnDecoded
    }
}

extension CreateDatasetGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain
        case kmsKeyArn
        case name
        case roleArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = self.domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateDatasetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateDatasetGroupInput: Swift.Equatable {
    /// The domain of the dataset group. Specify a domain to create a Domain dataset group. The domain you specify determines the default schemas for datasets and the use cases available for recommenders. If you don't specify a domain, you create a Custom dataset group with solution versions that you deploy with a campaign.
    public var domain: PersonalizeClientTypes.Domain?
    /// The Amazon Resource Name (ARN) of a Key Management Service (KMS) key used to encrypt the datasets.
    public var kmsKeyArn: Swift.String?
    /// The name for the new dataset group.
    /// This member is required.
    public var name: Swift.String?
    /// The ARN of the Identity and Access Management (IAM) role that has permissions to access the Key Management Service (KMS) key. Supplying an IAM role is only valid when also specifying a KMS key.
    public var roleArn: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/personalize/latest/dev/tagging-resources.html) to apply to the dataset group.
    public var tags: [PersonalizeClientTypes.Tag]?

    public init (
        domain: PersonalizeClientTypes.Domain? = nil,
        kmsKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        tags: [PersonalizeClientTypes.Tag]? = nil
    )
    {
        self.domain = domain
        self.kmsKeyArn = kmsKeyArn
        self.name = name
        self.roleArn = roleArn
        self.tags = tags
    }
}

struct CreateDatasetGroupInputBody: Swift.Equatable {
    let name: Swift.String?
    let roleArn: Swift.String?
    let kmsKeyArn: Swift.String?
    let domain: PersonalizeClientTypes.Domain?
    let tags: [PersonalizeClientTypes.Tag]?
}

extension CreateDatasetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain
        case kmsKeyArn
        case name
        case roleArn
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let domainDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PersonalizeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PersonalizeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDatasetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatasetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDatasetGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatasetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateDatasetGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetGroupArn = output.datasetGroupArn
            self.domain = output.domain
        } else {
            self.datasetGroupArn = nil
            self.domain = nil
        }
    }
}

public struct CreateDatasetGroupOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the new dataset group.
    public var datasetGroupArn: Swift.String?
    /// The domain for the new Domain dataset group.
    public var domain: PersonalizeClientTypes.Domain?

    public init (
        datasetGroupArn: Swift.String? = nil,
        domain: PersonalizeClientTypes.Domain? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.domain = domain
    }
}

struct CreateDatasetGroupOutputResponseBody: Swift.Equatable {
    let datasetGroupArn: Swift.String?
    let domain: PersonalizeClientTypes.Domain?
}

extension CreateDatasetGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case domain
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let domainDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension CreateDatasetImportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource
        case datasetArn
        case importMode
        case jobName
        case publishAttributionMetricsToS3
        case roleArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let datasetArn = self.datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let importMode = self.importMode {
            try encodeContainer.encode(importMode.rawValue, forKey: .importMode)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let publishAttributionMetricsToS3 = self.publishAttributionMetricsToS3 {
            try encodeContainer.encode(publishAttributionMetricsToS3, forKey: .publishAttributionMetricsToS3)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateDatasetImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateDatasetImportJobInput: Swift.Equatable {
    /// The Amazon S3 bucket that contains the training data to import.
    /// This member is required.
    public var dataSource: PersonalizeClientTypes.DataSource?
    /// The ARN of the dataset that receives the imported data.
    /// This member is required.
    public var datasetArn: Swift.String?
    /// Specify how to add the new records to an existing dataset. The default import mode is FULL. If you haven't imported bulk records into the dataset previously, you can only specify FULL.
    ///
    /// * Specify FULL to overwrite all existing bulk data in your dataset. Data you imported individually is not replaced.
    ///
    /// * Specify INCREMENTAL to append the new records to the existing data in your dataset. Amazon Personalize replaces any record with the same ID with the new one.
    public var importMode: PersonalizeClientTypes.ImportMode?
    /// The name for the dataset import job.
    /// This member is required.
    public var jobName: Swift.String?
    /// If you created a metric attribution, specify whether to publish metrics for this import job to Amazon S3
    public var publishAttributionMetricsToS3: Swift.Bool?
    /// The ARN of the IAM role that has permissions to read from the Amazon S3 data source.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/personalize/latest/dev/tagging-resources.html) to apply to the dataset import job.
    public var tags: [PersonalizeClientTypes.Tag]?

    public init (
        dataSource: PersonalizeClientTypes.DataSource? = nil,
        datasetArn: Swift.String? = nil,
        importMode: PersonalizeClientTypes.ImportMode? = nil,
        jobName: Swift.String? = nil,
        publishAttributionMetricsToS3: Swift.Bool? = nil,
        roleArn: Swift.String? = nil,
        tags: [PersonalizeClientTypes.Tag]? = nil
    )
    {
        self.dataSource = dataSource
        self.datasetArn = datasetArn
        self.importMode = importMode
        self.jobName = jobName
        self.publishAttributionMetricsToS3 = publishAttributionMetricsToS3
        self.roleArn = roleArn
        self.tags = tags
    }
}

struct CreateDatasetImportJobInputBody: Swift.Equatable {
    let jobName: Swift.String?
    let datasetArn: Swift.String?
    let dataSource: PersonalizeClientTypes.DataSource?
    let roleArn: Swift.String?
    let tags: [PersonalizeClientTypes.Tag]?
    let importMode: PersonalizeClientTypes.ImportMode?
    let publishAttributionMetricsToS3: Swift.Bool?
}

extension CreateDatasetImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource
        case datasetArn
        case importMode
        case jobName
        case publishAttributionMetricsToS3
        case roleArn
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PersonalizeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PersonalizeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let importModeDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.ImportMode.self, forKey: .importMode)
        importMode = importModeDecoded
        let publishAttributionMetricsToS3Decoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publishAttributionMetricsToS3)
        publishAttributionMetricsToS3 = publishAttributionMetricsToS3Decoded
    }
}

extension CreateDatasetImportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatasetImportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDatasetImportJobOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatasetImportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateDatasetImportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetImportJobArn = output.datasetImportJobArn
        } else {
            self.datasetImportJobArn = nil
        }
    }
}

public struct CreateDatasetImportJobOutputResponse: Swift.Equatable {
    /// The ARN of the dataset import job.
    public var datasetImportJobArn: Swift.String?

    public init (
        datasetImportJobArn: Swift.String? = nil
    )
    {
        self.datasetImportJobArn = datasetImportJobArn
    }
}

struct CreateDatasetImportJobOutputResponseBody: Swift.Equatable {
    let datasetImportJobArn: Swift.String?
}

extension CreateDatasetImportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetImportJobArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
    }
}

extension CreateDatasetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case datasetType
        case name
        case schemaArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let datasetType = self.datasetType {
            try encodeContainer.encode(datasetType, forKey: .datasetType)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schemaArn = self.schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateDatasetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateDatasetInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset group to add the dataset to.
    /// This member is required.
    public var datasetGroupArn: Swift.String?
    /// The type of dataset. One of the following (case insensitive) values:
    ///
    /// * Interactions
    ///
    /// * Items
    ///
    /// * Users
    /// This member is required.
    public var datasetType: Swift.String?
    /// The name for the dataset.
    /// This member is required.
    public var name: Swift.String?
    /// The ARN of the schema to associate with the dataset. The schema defines the dataset fields.
    /// This member is required.
    public var schemaArn: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/personalize/latest/dev/tagging-resources.html) to apply to the dataset.
    public var tags: [PersonalizeClientTypes.Tag]?

    public init (
        datasetGroupArn: Swift.String? = nil,
        datasetType: Swift.String? = nil,
        name: Swift.String? = nil,
        schemaArn: Swift.String? = nil,
        tags: [PersonalizeClientTypes.Tag]? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.datasetType = datasetType
        self.name = name
        self.schemaArn = schemaArn
        self.tags = tags
    }
}

struct CreateDatasetInputBody: Swift.Equatable {
    let name: Swift.String?
    let schemaArn: Swift.String?
    let datasetGroupArn: Swift.String?
    let datasetType: Swift.String?
    let tags: [PersonalizeClientTypes.Tag]?
}

extension CreateDatasetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case datasetType
        case name
        case schemaArn
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let datasetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetType)
        datasetType = datasetTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PersonalizeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PersonalizeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDatasetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatasetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDatasetOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatasetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateDatasetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetArn = output.datasetArn
        } else {
            self.datasetArn = nil
        }
    }
}

public struct CreateDatasetOutputResponse: Swift.Equatable {
    /// The ARN of the dataset.
    public var datasetArn: Swift.String?

    public init (
        datasetArn: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
    }
}

struct CreateDatasetOutputResponseBody: Swift.Equatable {
    let datasetArn: Swift.String?
}

extension CreateDatasetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
    }
}

extension CreateEventTrackerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateEventTrackerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateEventTrackerInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset group that receives the event data.
    /// This member is required.
    public var datasetGroupArn: Swift.String?
    /// The name for the event tracker.
    /// This member is required.
    public var name: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/personalize/latest/dev/tagging-resources.html) to apply to the event tracker.
    public var tags: [PersonalizeClientTypes.Tag]?

    public init (
        datasetGroupArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [PersonalizeClientTypes.Tag]? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.name = name
        self.tags = tags
    }
}

struct CreateEventTrackerInputBody: Swift.Equatable {
    let name: Swift.String?
    let datasetGroupArn: Swift.String?
    let tags: [PersonalizeClientTypes.Tag]?
}

extension CreateEventTrackerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PersonalizeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PersonalizeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateEventTrackerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEventTrackerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateEventTrackerOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEventTrackerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateEventTrackerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventTrackerArn = output.eventTrackerArn
            self.trackingId = output.trackingId
        } else {
            self.eventTrackerArn = nil
            self.trackingId = nil
        }
    }
}

public struct CreateEventTrackerOutputResponse: Swift.Equatable {
    /// The ARN of the event tracker.
    public var eventTrackerArn: Swift.String?
    /// The ID of the event tracker. Include this ID in requests to the [PutEvents](https://docs.aws.amazon.com/personalize/latest/dg/API_UBS_PutEvents.html) API.
    public var trackingId: Swift.String?

    public init (
        eventTrackerArn: Swift.String? = nil,
        trackingId: Swift.String? = nil
    )
    {
        self.eventTrackerArn = eventTrackerArn
        self.trackingId = trackingId
    }
}

struct CreateEventTrackerOutputResponseBody: Swift.Equatable {
    let eventTrackerArn: Swift.String?
    let trackingId: Swift.String?
}

extension CreateEventTrackerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTrackerArn
        case trackingId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTrackerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTrackerArn)
        eventTrackerArn = eventTrackerArnDecoded
        let trackingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackingId)
        trackingId = trackingIdDecoded
    }
}

extension CreateFilterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFilterInput(datasetGroupArn: \(Swift.String(describing: datasetGroupArn)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)), filterExpression: \"CONTENT_REDACTED\")"}
}

extension CreateFilterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case filterExpression
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let filterExpression = self.filterExpression {
            try encodeContainer.encode(filterExpression, forKey: .filterExpression)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateFilterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateFilterInput: Swift.Equatable {
    /// The ARN of the dataset group that the filter will belong to.
    /// This member is required.
    public var datasetGroupArn: Swift.String?
    /// The filter expression defines which items are included or excluded from recommendations. Filter expression must follow specific format rules. For information about filter expression structure and syntax, see [Filter expressions](https://docs.aws.amazon.com/personalize/latest/dg/filter-expressions.html).
    /// This member is required.
    public var filterExpression: Swift.String?
    /// The name of the filter to create.
    /// This member is required.
    public var name: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/personalize/latest/dev/tagging-resources.html) to apply to the filter.
    public var tags: [PersonalizeClientTypes.Tag]?

    public init (
        datasetGroupArn: Swift.String? = nil,
        filterExpression: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [PersonalizeClientTypes.Tag]? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.filterExpression = filterExpression
        self.name = name
        self.tags = tags
    }
}

struct CreateFilterInputBody: Swift.Equatable {
    let name: Swift.String?
    let datasetGroupArn: Swift.String?
    let filterExpression: Swift.String?
    let tags: [PersonalizeClientTypes.Tag]?
}

extension CreateFilterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case filterExpression
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let filterExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterExpression)
        filterExpression = filterExpressionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PersonalizeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PersonalizeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFilterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFilterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateFilterOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFilterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateFilterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.filterArn = output.filterArn
        } else {
            self.filterArn = nil
        }
    }
}

public struct CreateFilterOutputResponse: Swift.Equatable {
    /// The ARN of the new filter.
    public var filterArn: Swift.String?

    public init (
        filterArn: Swift.String? = nil
    )
    {
        self.filterArn = filterArn
    }
}

struct CreateFilterOutputResponseBody: Swift.Equatable {
    let filterArn: Swift.String?
}

extension CreateFilterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
    }
}

extension CreateMetricAttributionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case metrics
        case metricsOutputConfig
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let metrics = metrics {
            var metricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metrics)
            for metricattribute0 in metrics {
                try metricsContainer.encode(metricattribute0)
            }
        }
        if let metricsOutputConfig = self.metricsOutputConfig {
            try encodeContainer.encode(metricsOutputConfig, forKey: .metricsOutputConfig)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension CreateMetricAttributionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateMetricAttributionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the destination dataset group for the metric attribution.
    /// This member is required.
    public var datasetGroupArn: Swift.String?
    /// A list of metric attributes for the metric attribution. Each metric attribute specifies an event type to track and a function. Available functions are SUM() or SAMPLECOUNT(). For SUM() functions, provide the dataset type (either Interactions or Items) and column to sum as a parameter. For example SUM(Items.PRICE).
    /// This member is required.
    public var metrics: [PersonalizeClientTypes.MetricAttribute]?
    /// The output configuration details for the metric attribution.
    /// This member is required.
    public var metricsOutputConfig: PersonalizeClientTypes.MetricAttributionOutput?
    /// A name for the metric attribution.
    /// This member is required.
    public var name: Swift.String?

    public init (
        datasetGroupArn: Swift.String? = nil,
        metrics: [PersonalizeClientTypes.MetricAttribute]? = nil,
        metricsOutputConfig: PersonalizeClientTypes.MetricAttributionOutput? = nil,
        name: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.metrics = metrics
        self.metricsOutputConfig = metricsOutputConfig
        self.name = name
    }
}

struct CreateMetricAttributionInputBody: Swift.Equatable {
    let name: Swift.String?
    let datasetGroupArn: Swift.String?
    let metrics: [PersonalizeClientTypes.MetricAttribute]?
    let metricsOutputConfig: PersonalizeClientTypes.MetricAttributionOutput?
}

extension CreateMetricAttributionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case metrics
        case metricsOutputConfig
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let metricsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.MetricAttribute?].self, forKey: .metrics)
        var metricsDecoded0:[PersonalizeClientTypes.MetricAttribute]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [PersonalizeClientTypes.MetricAttribute]()
            for structure0 in metricsContainer {
                if let structure0 = structure0 {
                    metricsDecoded0?.append(structure0)
                }
            }
        }
        metrics = metricsDecoded0
        let metricsOutputConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.MetricAttributionOutput.self, forKey: .metricsOutputConfig)
        metricsOutputConfig = metricsOutputConfigDecoded
    }
}

extension CreateMetricAttributionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMetricAttributionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateMetricAttributionOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMetricAttributionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateMetricAttributionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.metricAttributionArn = output.metricAttributionArn
        } else {
            self.metricAttributionArn = nil
        }
    }
}

public struct CreateMetricAttributionOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the new metric attribution.
    public var metricAttributionArn: Swift.String?

    public init (
        metricAttributionArn: Swift.String? = nil
    )
    {
        self.metricAttributionArn = metricAttributionArn
    }
}

struct CreateMetricAttributionOutputResponseBody: Swift.Equatable {
    let metricAttributionArn: Swift.String?
}

extension CreateMetricAttributionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricAttributionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricAttributionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricAttributionArn)
        metricAttributionArn = metricAttributionArnDecoded
    }
}

extension CreateRecommenderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case name
        case recipeArn
        case recommenderConfig
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recipeArn = self.recipeArn {
            try encodeContainer.encode(recipeArn, forKey: .recipeArn)
        }
        if let recommenderConfig = self.recommenderConfig {
            try encodeContainer.encode(recommenderConfig, forKey: .recommenderConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateRecommenderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateRecommenderInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the destination domain dataset group for the recommender.
    /// This member is required.
    public var datasetGroupArn: Swift.String?
    /// The name of the recommender.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the recipe that the recommender will use. For a recommender, a recipe is a Domain dataset group use case. Only Domain dataset group use cases can be used to create a recommender. For information about use cases see [Choosing recommender use cases](https://docs.aws.amazon.com/personalize/latest/dg/domain-use-cases.html).
    /// This member is required.
    public var recipeArn: Swift.String?
    /// The configuration details of the recommender.
    public var recommenderConfig: PersonalizeClientTypes.RecommenderConfig?
    /// A list of [tags](https://docs.aws.amazon.com/personalize/latest/dev/tagging-resources.html) to apply to the recommender.
    public var tags: [PersonalizeClientTypes.Tag]?

    public init (
        datasetGroupArn: Swift.String? = nil,
        name: Swift.String? = nil,
        recipeArn: Swift.String? = nil,
        recommenderConfig: PersonalizeClientTypes.RecommenderConfig? = nil,
        tags: [PersonalizeClientTypes.Tag]? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.name = name
        self.recipeArn = recipeArn
        self.recommenderConfig = recommenderConfig
        self.tags = tags
    }
}

struct CreateRecommenderInputBody: Swift.Equatable {
    let name: Swift.String?
    let datasetGroupArn: Swift.String?
    let recipeArn: Swift.String?
    let recommenderConfig: PersonalizeClientTypes.RecommenderConfig?
    let tags: [PersonalizeClientTypes.Tag]?
}

extension CreateRecommenderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case name
        case recipeArn
        case recommenderConfig
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let recipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipeArn)
        recipeArn = recipeArnDecoded
        let recommenderConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.RecommenderConfig.self, forKey: .recommenderConfig)
        recommenderConfig = recommenderConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PersonalizeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PersonalizeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRecommenderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRecommenderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateRecommenderOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRecommenderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateRecommenderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.recommenderArn = output.recommenderArn
        } else {
            self.recommenderArn = nil
        }
    }
}

public struct CreateRecommenderOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the recommender.
    public var recommenderArn: Swift.String?

    public init (
        recommenderArn: Swift.String? = nil
    )
    {
        self.recommenderArn = recommenderArn
    }
}

struct CreateRecommenderOutputResponseBody: Swift.Equatable {
    let recommenderArn: Swift.String?
}

extension CreateRecommenderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommenderArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommenderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommenderArn)
        recommenderArn = recommenderArnDecoded
    }
}

extension CreateSchemaInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain
        case name
        case schema
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = self.domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schema = self.schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
    }
}

extension CreateSchemaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateSchemaInput: Swift.Equatable {
    /// The domain for the schema. If you are creating a schema for a dataset in a Domain dataset group, specify the domain you chose when you created the Domain dataset group.
    public var domain: PersonalizeClientTypes.Domain?
    /// The name for the schema.
    /// This member is required.
    public var name: Swift.String?
    /// A schema in Avro JSON format.
    /// This member is required.
    public var schema: Swift.String?

    public init (
        domain: PersonalizeClientTypes.Domain? = nil,
        name: Swift.String? = nil,
        schema: Swift.String? = nil
    )
    {
        self.domain = domain
        self.name = name
        self.schema = schema
    }
}

struct CreateSchemaInputBody: Swift.Equatable {
    let name: Swift.String?
    let schema: Swift.String?
    let domain: PersonalizeClientTypes.Domain?
}

extension CreateSchemaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain
        case name
        case schema
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
        let domainDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension CreateSchemaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSchemaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSchemaOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSchemaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateSchemaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.schemaArn = output.schemaArn
        } else {
            self.schemaArn = nil
        }
    }
}

public struct CreateSchemaOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the created schema.
    public var schemaArn: Swift.String?

    public init (
        schemaArn: Swift.String? = nil
    )
    {
        self.schemaArn = schemaArn
    }
}

struct CreateSchemaOutputResponseBody: Swift.Equatable {
    let schemaArn: Swift.String?
}

extension CreateSchemaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schemaArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
    }
}

extension CreateSolutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case eventType
        case name
        case performAutoML
        case performHPO
        case recipeArn
        case solutionConfig
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let eventType = self.eventType {
            try encodeContainer.encode(eventType, forKey: .eventType)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if performAutoML != false {
            try encodeContainer.encode(performAutoML, forKey: .performAutoML)
        }
        if let performHPO = self.performHPO {
            try encodeContainer.encode(performHPO, forKey: .performHPO)
        }
        if let recipeArn = self.recipeArn {
            try encodeContainer.encode(recipeArn, forKey: .recipeArn)
        }
        if let solutionConfig = self.solutionConfig {
            try encodeContainer.encode(solutionConfig, forKey: .solutionConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateSolutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateSolutionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset group that provides the training data.
    /// This member is required.
    public var datasetGroupArn: Swift.String?
    /// When your have multiple event types (using an EVENT_TYPE schema field), this parameter specifies which event type (for example, 'click' or 'like') is used for training the model. If you do not provide an eventType, Amazon Personalize will use all interactions for training with equal weight regardless of type.
    public var eventType: Swift.String?
    /// The name for the solution.
    /// This member is required.
    public var name: Swift.String?
    /// Whether to perform automated machine learning (AutoML). The default is false. For this case, you must specify recipeArn. When set to true, Amazon Personalize analyzes your training data and selects the optimal USER_PERSONALIZATION recipe and hyperparameters. In this case, you must omit recipeArn. Amazon Personalize determines the optimal recipe by running tests with different values for the hyperparameters. AutoML lengthens the training process as compared to selecting a specific recipe.
    public var performAutoML: Swift.Bool
    /// Whether to perform hyperparameter optimization (HPO) on the specified or selected recipe. The default is false. When performing AutoML, this parameter is always true and you should not set it to false.
    public var performHPO: Swift.Bool?
    /// The ARN of the recipe to use for model training. Only specified when performAutoML is false.
    public var recipeArn: Swift.String?
    /// The configuration to use with the solution. When performAutoML is set to true, Amazon Personalize only evaluates the autoMLConfig section of the solution configuration. Amazon Personalize doesn't support configuring the hpoObjective at this time.
    public var solutionConfig: PersonalizeClientTypes.SolutionConfig?
    /// A list of [tags](https://docs.aws.amazon.com/personalize/latest/dev/tagging-resources.html) to apply to the solution.
    public var tags: [PersonalizeClientTypes.Tag]?

    public init (
        datasetGroupArn: Swift.String? = nil,
        eventType: Swift.String? = nil,
        name: Swift.String? = nil,
        performAutoML: Swift.Bool = false,
        performHPO: Swift.Bool? = nil,
        recipeArn: Swift.String? = nil,
        solutionConfig: PersonalizeClientTypes.SolutionConfig? = nil,
        tags: [PersonalizeClientTypes.Tag]? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.eventType = eventType
        self.name = name
        self.performAutoML = performAutoML
        self.performHPO = performHPO
        self.recipeArn = recipeArn
        self.solutionConfig = solutionConfig
        self.tags = tags
    }
}

struct CreateSolutionInputBody: Swift.Equatable {
    let name: Swift.String?
    let performHPO: Swift.Bool?
    let performAutoML: Swift.Bool
    let recipeArn: Swift.String?
    let datasetGroupArn: Swift.String?
    let eventType: Swift.String?
    let solutionConfig: PersonalizeClientTypes.SolutionConfig?
    let tags: [PersonalizeClientTypes.Tag]?
}

extension CreateSolutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case eventType
        case name
        case performAutoML
        case performHPO
        case recipeArn
        case solutionConfig
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let performHPODecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .performHPO)
        performHPO = performHPODecoded
        let performAutoMLDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .performAutoML) ?? false
        performAutoML = performAutoMLDecoded
        let recipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipeArn)
        recipeArn = recipeArnDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let solutionConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.SolutionConfig.self, forKey: .solutionConfig)
        solutionConfig = solutionConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PersonalizeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PersonalizeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSolutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSolutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSolutionOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSolutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateSolutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.solutionArn = output.solutionArn
        } else {
            self.solutionArn = nil
        }
    }
}

public struct CreateSolutionOutputResponse: Swift.Equatable {
    /// The ARN of the solution.
    public var solutionArn: Swift.String?

    public init (
        solutionArn: Swift.String? = nil
    )
    {
        self.solutionArn = solutionArn
    }
}

struct CreateSolutionOutputResponseBody: Swift.Equatable {
    let solutionArn: Swift.String?
}

extension CreateSolutionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solutionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionArn)
        solutionArn = solutionArnDecoded
    }
}

extension CreateSolutionVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case solutionArn
        case tags
        case trainingMode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let solutionArn = self.solutionArn {
            try encodeContainer.encode(solutionArn, forKey: .solutionArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let trainingMode = self.trainingMode {
            try encodeContainer.encode(trainingMode.rawValue, forKey: .trainingMode)
        }
    }
}

extension CreateSolutionVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateSolutionVersionInput: Swift.Equatable {
    /// The name of the solution version.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the solution containing the training configuration information.
    /// This member is required.
    public var solutionArn: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/personalize/latest/dev/tagging-resources.html) to apply to the solution version.
    public var tags: [PersonalizeClientTypes.Tag]?
    /// The scope of training to be performed when creating the solution version. The FULL option trains the solution version based on the entirety of the input solution's training data, while the UPDATE option processes only the data that has changed in comparison to the input solution. Choose UPDATE when you want to incrementally update your solution version instead of creating an entirely new one. The UPDATE option can only be used when you already have an active solution version created from the input solution using the FULL option and the input solution was trained with the [User-Personalization](https://docs.aws.amazon.com/personalize/latest/dg/native-recipe-new-item-USER_PERSONALIZATION.html) recipe or the [HRNN-Coldstart](https://docs.aws.amazon.com/personalize/latest/dg/native-recipe-hrnn-coldstart.html) recipe.
    public var trainingMode: PersonalizeClientTypes.TrainingMode?

    public init (
        name: Swift.String? = nil,
        solutionArn: Swift.String? = nil,
        tags: [PersonalizeClientTypes.Tag]? = nil,
        trainingMode: PersonalizeClientTypes.TrainingMode? = nil
    )
    {
        self.name = name
        self.solutionArn = solutionArn
        self.tags = tags
        self.trainingMode = trainingMode
    }
}

struct CreateSolutionVersionInputBody: Swift.Equatable {
    let name: Swift.String?
    let solutionArn: Swift.String?
    let trainingMode: PersonalizeClientTypes.TrainingMode?
    let tags: [PersonalizeClientTypes.Tag]?
}

extension CreateSolutionVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case solutionArn
        case tags
        case trainingMode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let solutionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionArn)
        solutionArn = solutionArnDecoded
        let trainingModeDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.TrainingMode.self, forKey: .trainingMode)
        trainingMode = trainingModeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PersonalizeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PersonalizeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSolutionVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSolutionVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSolutionVersionOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSolutionVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateSolutionVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.solutionVersionArn = output.solutionVersionArn
        } else {
            self.solutionVersionArn = nil
        }
    }
}

public struct CreateSolutionVersionOutputResponse: Swift.Equatable {
    /// The ARN of the new solution version.
    public var solutionVersionArn: Swift.String?

    public init (
        solutionVersionArn: Swift.String? = nil
    )
    {
        self.solutionVersionArn = solutionVersionArn
    }
}

struct CreateSolutionVersionOutputResponseBody: Swift.Equatable {
    let solutionVersionArn: Swift.String?
}

extension CreateSolutionVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solutionVersionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
    }
}

extension PersonalizeClientTypes.DataSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataLocation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataLocation = self.dataLocation {
            try encodeContainer.encode(dataLocation, forKey: .dataLocation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataLocation)
        dataLocation = dataLocationDecoded
    }
}

extension PersonalizeClientTypes {
    /// Describes the data source that contains the data to upload to a dataset.
    public struct DataSource: Swift.Equatable {
        /// The path to the Amazon S3 bucket where the data that you want to upload to your dataset is stored. For example: s3://bucket-name/folder-name/
        public var dataLocation: Swift.String?

        public init (
            dataLocation: Swift.String? = nil
        )
        {
            self.dataLocation = dataLocation
        }
    }

}

extension PersonalizeClientTypes.Dataset: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case datasetArn
        case datasetGroupArn
        case datasetType
        case lastUpdatedDateTime
        case name
        case schemaArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let datasetArn = self.datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let datasetType = self.datasetType {
            try encodeContainer.encode(datasetType, forKey: .datasetType)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schemaArn = self.schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let datasetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetType)
        datasetType = datasetTypeDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides metadata for a dataset.
    public struct Dataset: Swift.Equatable {
        /// The creation date and time (in Unix time) of the dataset.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset that you want metadata for.
        public var datasetArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the dataset group.
        public var datasetGroupArn: Swift.String?
        /// One of the following values:
        ///
        /// * Interactions
        ///
        /// * Items
        ///
        /// * Users
        public var datasetType: Swift.String?
        /// A time stamp that shows when the dataset was updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the dataset.
        public var name: Swift.String?
        /// The ARN of the associated schema.
        public var schemaArn: Swift.String?
        /// The status of the dataset. A dataset can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        /// * DELETE PENDING > DELETE IN_PROGRESS
        public var status: Swift.String?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            datasetArn: Swift.String? = nil,
            datasetGroupArn: Swift.String? = nil,
            datasetType: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            schemaArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetArn = datasetArn
            self.datasetGroupArn = datasetGroupArn
            self.datasetType = datasetType
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.schemaArn = schemaArn
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.DatasetExportJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case datasetArn
        case datasetExportJobArn
        case failureReason
        case ingestionMode
        case jobName
        case jobOutput
        case lastUpdatedDateTime
        case roleArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let datasetArn = self.datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let datasetExportJobArn = self.datasetExportJobArn {
            try encodeContainer.encode(datasetExportJobArn, forKey: .datasetExportJobArn)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let ingestionMode = self.ingestionMode {
            try encodeContainer.encode(ingestionMode.rawValue, forKey: .ingestionMode)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobOutput = self.jobOutput {
            try encodeContainer.encode(jobOutput, forKey: .jobOutput)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let datasetExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetExportJobArn)
        datasetExportJobArn = datasetExportJobArnDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let ingestionModeDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.IngestionMode.self, forKey: .ingestionMode)
        ingestionMode = ingestionModeDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let jobOutputDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.DatasetExportJobOutput.self, forKey: .jobOutput)
        jobOutput = jobOutputDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension PersonalizeClientTypes {
    /// Describes a job that exports a dataset to an Amazon S3 bucket. For more information, see [CreateDatasetExportJob](https://docs.aws.amazon.com/personalize/latest/dg/API_CreateDatasetExportJob.html). A dataset export job can be in one of the following states:
    ///
    /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
    public struct DatasetExportJob: Swift.Equatable {
        /// The creation date and time (in Unix time) of the dataset export job.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset to export.
        public var datasetArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the dataset export job.
        public var datasetExportJobArn: Swift.String?
        /// If a dataset export job fails, provides the reason why.
        public var failureReason: Swift.String?
        /// The data to export, based on how you imported the data. You can choose to export BULK data that you imported using a dataset import job, PUT data that you imported incrementally (using the console, PutEvents, PutUsers and PutItems operations), or ALL for both types. The default value is PUT.
        public var ingestionMode: PersonalizeClientTypes.IngestionMode?
        /// The name of the export job.
        public var jobName: Swift.String?
        /// The path to the Amazon S3 bucket where the job's output is stored. For example: s3://bucket-name/folder-name/
        public var jobOutput: PersonalizeClientTypes.DatasetExportJobOutput?
        /// The date and time (in Unix time) the status of the dataset export job was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the IAM service role that has permissions to add data to your output Amazon S3 bucket.
        public var roleArn: Swift.String?
        /// The status of the dataset export job. A dataset export job can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        public var status: Swift.String?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            datasetArn: Swift.String? = nil,
            datasetExportJobArn: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            ingestionMode: PersonalizeClientTypes.IngestionMode? = nil,
            jobName: Swift.String? = nil,
            jobOutput: PersonalizeClientTypes.DatasetExportJobOutput? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            roleArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetArn = datasetArn
            self.datasetExportJobArn = datasetExportJobArn
            self.failureReason = failureReason
            self.ingestionMode = ingestionMode
            self.jobName = jobName
            self.jobOutput = jobOutput
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.roleArn = roleArn
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.DatasetExportJobOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3DataDestination
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3DataDestination = self.s3DataDestination {
            try encodeContainer.encode(s3DataDestination, forKey: .s3DataDestination)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3DataDestinationDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.S3DataConfig.self, forKey: .s3DataDestination)
        s3DataDestination = s3DataDestinationDecoded
    }
}

extension PersonalizeClientTypes {
    /// The output configuration parameters of a dataset export job.
    public struct DatasetExportJobOutput: Swift.Equatable {
        /// The configuration details of an Amazon S3 input or output bucket.
        /// This member is required.
        public var s3DataDestination: PersonalizeClientTypes.S3DataConfig?

        public init (
            s3DataDestination: PersonalizeClientTypes.S3DataConfig? = nil
        )
        {
            self.s3DataDestination = s3DataDestination
        }
    }

}

extension PersonalizeClientTypes.DatasetExportJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case datasetExportJobArn
        case failureReason
        case jobName
        case lastUpdatedDateTime
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let datasetExportJobArn = self.datasetExportJobArn {
            try encodeContainer.encode(datasetExportJobArn, forKey: .datasetExportJobArn)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetExportJobArn)
        datasetExportJobArn = datasetExportJobArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides a summary of the properties of a dataset export job. For a complete listing, call the [DescribeDatasetExportJob](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeDatasetExportJob.html) API.
    public struct DatasetExportJobSummary: Swift.Equatable {
        /// The date and time (in Unix time) that the dataset export job was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset export job.
        public var datasetExportJobArn: Swift.String?
        /// If a dataset export job fails, the reason behind the failure.
        public var failureReason: Swift.String?
        /// The name of the dataset export job.
        public var jobName: Swift.String?
        /// The date and time (in Unix time) that the dataset export job status was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The status of the dataset export job. A dataset export job can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        public var status: Swift.String?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            datasetExportJobArn: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            jobName: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetExportJobArn = datasetExportJobArn
            self.failureReason = failureReason
            self.jobName = jobName
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.DatasetGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case datasetGroupArn
        case domain
        case failureReason
        case kmsKeyArn
        case lastUpdatedDateTime
        case name
        case roleArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let domain = self.domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let domainDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension PersonalizeClientTypes {
    /// A dataset group is a collection of related datasets (Interactions, User, and Item). You create a dataset group by calling [CreateDatasetGroup](https://docs.aws.amazon.com/personalize/latest/dg/API_CreateDatasetGroup.html). You then create a dataset and add it to a dataset group by calling [CreateDataset](https://docs.aws.amazon.com/personalize/latest/dg/API_CreateDataset.html). The dataset group is used to create and train a solution by calling [CreateSolution](https://docs.aws.amazon.com/personalize/latest/dg/API_CreateSolution.html). A dataset group can contain only one of each type of dataset. You can specify an Key Management Service (KMS) key to encrypt the datasets in the group.
    public struct DatasetGroup: Swift.Equatable {
        /// The creation date and time (in Unix time) of the dataset group.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset group.
        public var datasetGroupArn: Swift.String?
        /// The domain of a Domain dataset group.
        public var domain: PersonalizeClientTypes.Domain?
        /// If creating a dataset group fails, provides the reason why.
        public var failureReason: Swift.String?
        /// The Amazon Resource Name (ARN) of the Key Management Service (KMS) key used to encrypt the datasets.
        public var kmsKeyArn: Swift.String?
        /// The last update date and time (in Unix time) of the dataset group.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the dataset group.
        public var name: Swift.String?
        /// The ARN of the IAM role that has permissions to create the dataset group.
        public var roleArn: Swift.String?
        /// The current status of the dataset group. A dataset group can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        /// * DELETE PENDING
        public var status: Swift.String?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            domain: PersonalizeClientTypes.Domain? = nil,
            failureReason: Swift.String? = nil,
            kmsKeyArn: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.domain = domain
            self.failureReason = failureReason
            self.kmsKeyArn = kmsKeyArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.roleArn = roleArn
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.DatasetGroupSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case datasetGroupArn
        case domain
        case failureReason
        case lastUpdatedDateTime
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let domain = self.domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let domainDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides a summary of the properties of a dataset group. For a complete listing, call the [DescribeDatasetGroup](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeDatasetGroup.html) API.
    public struct DatasetGroupSummary: Swift.Equatable {
        /// The date and time (in Unix time) that the dataset group was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset group.
        public var datasetGroupArn: Swift.String?
        /// The domain of a Domain dataset group.
        public var domain: PersonalizeClientTypes.Domain?
        /// If creating a dataset group fails, the reason behind the failure.
        public var failureReason: Swift.String?
        /// The date and time (in Unix time) that the dataset group was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the dataset group.
        public var name: Swift.String?
        /// The status of the dataset group. A dataset group can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        /// * DELETE PENDING
        public var status: Swift.String?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            domain: PersonalizeClientTypes.Domain? = nil,
            failureReason: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.domain = domain
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.DatasetImportJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case dataSource
        case datasetArn
        case datasetImportJobArn
        case failureReason
        case importMode
        case jobName
        case lastUpdatedDateTime
        case publishAttributionMetricsToS3
        case roleArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let datasetArn = self.datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let datasetImportJobArn = self.datasetImportJobArn {
            try encodeContainer.encode(datasetImportJobArn, forKey: .datasetImportJobArn)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let importMode = self.importMode {
            try encodeContainer.encode(importMode.rawValue, forKey: .importMode)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let publishAttributionMetricsToS3 = self.publishAttributionMetricsToS3 {
            try encodeContainer.encode(publishAttributionMetricsToS3, forKey: .publishAttributionMetricsToS3)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let importModeDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.ImportMode.self, forKey: .importMode)
        importMode = importModeDecoded
        let publishAttributionMetricsToS3Decoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publishAttributionMetricsToS3)
        publishAttributionMetricsToS3 = publishAttributionMetricsToS3Decoded
    }
}

extension PersonalizeClientTypes {
    /// Describes a job that imports training data from a data source (Amazon S3 bucket) to an Amazon Personalize dataset. For more information, see [CreateDatasetImportJob](https://docs.aws.amazon.com/personalize/latest/dg/API_CreateDatasetImportJob.html). A dataset import job can be in one of the following states:
    ///
    /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
    public struct DatasetImportJob: Swift.Equatable {
        /// The creation date and time (in Unix time) of the dataset import job.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon S3 bucket that contains the training data to import.
        public var dataSource: PersonalizeClientTypes.DataSource?
        /// The Amazon Resource Name (ARN) of the dataset that receives the imported data.
        public var datasetArn: Swift.String?
        /// The ARN of the dataset import job.
        public var datasetImportJobArn: Swift.String?
        /// If a dataset import job fails, provides the reason why.
        public var failureReason: Swift.String?
        /// The import mode used by the dataset import job to import new records.
        public var importMode: PersonalizeClientTypes.ImportMode?
        /// The name of the import job.
        public var jobName: Swift.String?
        /// The date and time (in Unix time) the dataset was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// Whether the job publishes metrics to Amazon S3 for a metric attribution.
        public var publishAttributionMetricsToS3: Swift.Bool?
        /// The ARN of the IAM role that has permissions to read from the Amazon S3 data source.
        public var roleArn: Swift.String?
        /// The status of the dataset import job. A dataset import job can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        public var status: Swift.String?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            dataSource: PersonalizeClientTypes.DataSource? = nil,
            datasetArn: Swift.String? = nil,
            datasetImportJobArn: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            importMode: PersonalizeClientTypes.ImportMode? = nil,
            jobName: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            publishAttributionMetricsToS3: Swift.Bool? = nil,
            roleArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.dataSource = dataSource
            self.datasetArn = datasetArn
            self.datasetImportJobArn = datasetImportJobArn
            self.failureReason = failureReason
            self.importMode = importMode
            self.jobName = jobName
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.publishAttributionMetricsToS3 = publishAttributionMetricsToS3
            self.roleArn = roleArn
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.DatasetImportJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case datasetImportJobArn
        case failureReason
        case importMode
        case jobName
        case lastUpdatedDateTime
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let datasetImportJobArn = self.datasetImportJobArn {
            try encodeContainer.encode(datasetImportJobArn, forKey: .datasetImportJobArn)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let importMode = self.importMode {
            try encodeContainer.encode(importMode.rawValue, forKey: .importMode)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let importModeDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.ImportMode.self, forKey: .importMode)
        importMode = importModeDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides a summary of the properties of a dataset import job. For a complete listing, call the [DescribeDatasetImportJob](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeDatasetImportJob.html) API.
    public struct DatasetImportJobSummary: Swift.Equatable {
        /// The date and time (in Unix time) that the dataset import job was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset import job.
        public var datasetImportJobArn: Swift.String?
        /// If a dataset import job fails, the reason behind the failure.
        public var failureReason: Swift.String?
        /// The import mode the dataset import job used to update the data in the dataset. For more information see [Updating existing bulk data](https://docs.aws.amazon.com/personalize/latest/dg/updating-existing-bulk-data.html).
        public var importMode: PersonalizeClientTypes.ImportMode?
        /// The name of the dataset import job.
        public var jobName: Swift.String?
        /// The date and time (in Unix time) that the dataset import job status was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The status of the dataset import job. A dataset import job can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        public var status: Swift.String?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            datasetImportJobArn: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            importMode: PersonalizeClientTypes.ImportMode? = nil,
            jobName: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetImportJobArn = datasetImportJobArn
            self.failureReason = failureReason
            self.importMode = importMode
            self.jobName = jobName
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.DatasetSchema: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case domain
        case lastUpdatedDateTime
        case name
        case schema
        case schemaArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let domain = self.domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schema = self.schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let schemaArn = self.schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let domainDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension PersonalizeClientTypes {
    /// Describes the schema for a dataset. For more information on schemas, see [CreateSchema](https://docs.aws.amazon.com/personalize/latest/dg/API_CreateSchema.html).
    public struct DatasetSchema: Swift.Equatable {
        /// The date and time (in Unix time) that the schema was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The domain of a schema that you created for a dataset in a Domain dataset group.
        public var domain: PersonalizeClientTypes.Domain?
        /// The date and time (in Unix time) that the schema was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the schema.
        public var name: Swift.String?
        /// The schema.
        public var schema: Swift.String?
        /// The Amazon Resource Name (ARN) of the schema.
        public var schemaArn: Swift.String?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            domain: PersonalizeClientTypes.Domain? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            schema: Swift.String? = nil,
            schemaArn: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.domain = domain
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.schema = schema
            self.schemaArn = schemaArn
        }
    }

}

extension PersonalizeClientTypes.DatasetSchemaSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case domain
        case lastUpdatedDateTime
        case name
        case schemaArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let domain = self.domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schemaArn = self.schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let domainDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides a summary of the properties of a dataset schema. For a complete listing, call the [DescribeSchema](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeSchema.html) API.
    public struct DatasetSchemaSummary: Swift.Equatable {
        /// The date and time (in Unix time) that the schema was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The domain of a schema that you created for a dataset in a Domain dataset group.
        public var domain: PersonalizeClientTypes.Domain?
        /// The date and time (in Unix time) that the schema was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the schema.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the schema.
        public var schemaArn: Swift.String?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            domain: PersonalizeClientTypes.Domain? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            schemaArn: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.domain = domain
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.schemaArn = schemaArn
        }
    }

}

extension PersonalizeClientTypes.DatasetSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case datasetArn
        case datasetType
        case lastUpdatedDateTime
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let datasetArn = self.datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let datasetType = self.datasetType {
            try encodeContainer.encode(datasetType, forKey: .datasetType)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let datasetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetType)
        datasetType = datasetTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides a summary of the properties of a dataset. For a complete listing, call the [DescribeDataset](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeDataset.html) API.
    public struct DatasetSummary: Swift.Equatable {
        /// The date and time (in Unix time) that the dataset was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset.
        public var datasetArn: Swift.String?
        /// The dataset type. One of the following values:
        ///
        /// * Interactions
        ///
        /// * Items
        ///
        /// * Users
        ///
        /// * Event-Interactions
        public var datasetType: Swift.String?
        /// The date and time (in Unix time) that the dataset was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the dataset.
        public var name: Swift.String?
        /// The status of the dataset. A dataset can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        /// * DELETE PENDING > DELETE IN_PROGRESS
        public var status: Swift.String?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            datasetArn: Swift.String? = nil,
            datasetType: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetArn = datasetArn
            self.datasetType = datasetType
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.DefaultCategoricalHyperParameterRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTunable
        case name
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isTunable != false {
            try encodeContainer.encode(isTunable, forKey: .isTunable)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for categoricalvalue0 in values {
                try valuesContainer.encode(categoricalvalue0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let isTunableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTunable) ?? false
        isTunable = isTunableDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides the name and default range of a categorical hyperparameter and whether the hyperparameter is tunable. A tunable hyperparameter can have its value determined during hyperparameter optimization (HPO).
    public struct DefaultCategoricalHyperParameterRange: Swift.Equatable {
        /// Whether the hyperparameter is tunable.
        public var isTunable: Swift.Bool
        /// The name of the hyperparameter.
        public var name: Swift.String?
        /// A list of the categories for the hyperparameter.
        public var values: [Swift.String]?

        public init (
            isTunable: Swift.Bool = false,
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.isTunable = isTunable
            self.name = name
            self.values = values
        }
    }

}

extension PersonalizeClientTypes.DefaultContinuousHyperParameterRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTunable
        case maxValue
        case minValue
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isTunable != false {
            try encodeContainer.encode(isTunable, forKey: .isTunable)
        }
        if maxValue != 0.0 {
            try encodeContainer.encode(maxValue, forKey: .maxValue)
        }
        if minValue != 0.0 {
            try encodeContainer.encode(minValue, forKey: .minValue)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let minValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .minValue) ?? 0.0
        minValue = minValueDecoded
        let maxValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .maxValue) ?? 0.0
        maxValue = maxValueDecoded
        let isTunableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTunable) ?? false
        isTunable = isTunableDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides the name and default range of a continuous hyperparameter and whether the hyperparameter is tunable. A tunable hyperparameter can have its value determined during hyperparameter optimization (HPO).
    public struct DefaultContinuousHyperParameterRange: Swift.Equatable {
        /// Whether the hyperparameter is tunable.
        public var isTunable: Swift.Bool
        /// The maximum allowable value for the hyperparameter.
        public var maxValue: Swift.Double
        /// The minimum allowable value for the hyperparameter.
        public var minValue: Swift.Double
        /// The name of the hyperparameter.
        public var name: Swift.String?

        public init (
            isTunable: Swift.Bool = false,
            maxValue: Swift.Double = 0.0,
            minValue: Swift.Double = 0.0,
            name: Swift.String? = nil
        )
        {
            self.isTunable = isTunable
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
        }
    }

}

extension PersonalizeClientTypes.DefaultHyperParameterRanges: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoricalHyperParameterRanges
        case continuousHyperParameterRanges
        case integerHyperParameterRanges
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoricalHyperParameterRanges = categoricalHyperParameterRanges {
            var categoricalHyperParameterRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .categoricalHyperParameterRanges)
            for defaultcategoricalhyperparameterrange0 in categoricalHyperParameterRanges {
                try categoricalHyperParameterRangesContainer.encode(defaultcategoricalhyperparameterrange0)
            }
        }
        if let continuousHyperParameterRanges = continuousHyperParameterRanges {
            var continuousHyperParameterRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .continuousHyperParameterRanges)
            for defaultcontinuoushyperparameterrange0 in continuousHyperParameterRanges {
                try continuousHyperParameterRangesContainer.encode(defaultcontinuoushyperparameterrange0)
            }
        }
        if let integerHyperParameterRanges = integerHyperParameterRanges {
            var integerHyperParameterRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .integerHyperParameterRanges)
            for defaultintegerhyperparameterrange0 in integerHyperParameterRanges {
                try integerHyperParameterRangesContainer.encode(defaultintegerhyperparameterrange0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let integerHyperParameterRangesContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.DefaultIntegerHyperParameterRange?].self, forKey: .integerHyperParameterRanges)
        var integerHyperParameterRangesDecoded0:[PersonalizeClientTypes.DefaultIntegerHyperParameterRange]? = nil
        if let integerHyperParameterRangesContainer = integerHyperParameterRangesContainer {
            integerHyperParameterRangesDecoded0 = [PersonalizeClientTypes.DefaultIntegerHyperParameterRange]()
            for structure0 in integerHyperParameterRangesContainer {
                if let structure0 = structure0 {
                    integerHyperParameterRangesDecoded0?.append(structure0)
                }
            }
        }
        integerHyperParameterRanges = integerHyperParameterRangesDecoded0
        let continuousHyperParameterRangesContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.DefaultContinuousHyperParameterRange?].self, forKey: .continuousHyperParameterRanges)
        var continuousHyperParameterRangesDecoded0:[PersonalizeClientTypes.DefaultContinuousHyperParameterRange]? = nil
        if let continuousHyperParameterRangesContainer = continuousHyperParameterRangesContainer {
            continuousHyperParameterRangesDecoded0 = [PersonalizeClientTypes.DefaultContinuousHyperParameterRange]()
            for structure0 in continuousHyperParameterRangesContainer {
                if let structure0 = structure0 {
                    continuousHyperParameterRangesDecoded0?.append(structure0)
                }
            }
        }
        continuousHyperParameterRanges = continuousHyperParameterRangesDecoded0
        let categoricalHyperParameterRangesContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.DefaultCategoricalHyperParameterRange?].self, forKey: .categoricalHyperParameterRanges)
        var categoricalHyperParameterRangesDecoded0:[PersonalizeClientTypes.DefaultCategoricalHyperParameterRange]? = nil
        if let categoricalHyperParameterRangesContainer = categoricalHyperParameterRangesContainer {
            categoricalHyperParameterRangesDecoded0 = [PersonalizeClientTypes.DefaultCategoricalHyperParameterRange]()
            for structure0 in categoricalHyperParameterRangesContainer {
                if let structure0 = structure0 {
                    categoricalHyperParameterRangesDecoded0?.append(structure0)
                }
            }
        }
        categoricalHyperParameterRanges = categoricalHyperParameterRangesDecoded0
    }
}

extension PersonalizeClientTypes {
    /// Specifies the hyperparameters and their default ranges. Hyperparameters can be categorical, continuous, or integer-valued.
    public struct DefaultHyperParameterRanges: Swift.Equatable {
        /// The categorical hyperparameters and their default ranges.
        public var categoricalHyperParameterRanges: [PersonalizeClientTypes.DefaultCategoricalHyperParameterRange]?
        /// The continuous hyperparameters and their default ranges.
        public var continuousHyperParameterRanges: [PersonalizeClientTypes.DefaultContinuousHyperParameterRange]?
        /// The integer-valued hyperparameters and their default ranges.
        public var integerHyperParameterRanges: [PersonalizeClientTypes.DefaultIntegerHyperParameterRange]?

        public init (
            categoricalHyperParameterRanges: [PersonalizeClientTypes.DefaultCategoricalHyperParameterRange]? = nil,
            continuousHyperParameterRanges: [PersonalizeClientTypes.DefaultContinuousHyperParameterRange]? = nil,
            integerHyperParameterRanges: [PersonalizeClientTypes.DefaultIntegerHyperParameterRange]? = nil
        )
        {
            self.categoricalHyperParameterRanges = categoricalHyperParameterRanges
            self.continuousHyperParameterRanges = continuousHyperParameterRanges
            self.integerHyperParameterRanges = integerHyperParameterRanges
        }
    }

}

extension PersonalizeClientTypes.DefaultIntegerHyperParameterRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTunable
        case maxValue
        case minValue
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isTunable != false {
            try encodeContainer.encode(isTunable, forKey: .isTunable)
        }
        if maxValue != 0 {
            try encodeContainer.encode(maxValue, forKey: .maxValue)
        }
        if minValue != 0 {
            try encodeContainer.encode(minValue, forKey: .minValue)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let minValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minValue) ?? 0
        minValue = minValueDecoded
        let maxValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxValue) ?? 0
        maxValue = maxValueDecoded
        let isTunableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTunable) ?? false
        isTunable = isTunableDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides the name and default range of a integer-valued hyperparameter and whether the hyperparameter is tunable. A tunable hyperparameter can have its value determined during hyperparameter optimization (HPO).
    public struct DefaultIntegerHyperParameterRange: Swift.Equatable {
        /// Indicates whether the hyperparameter is tunable.
        public var isTunable: Swift.Bool
        /// The maximum allowable value for the hyperparameter.
        public var maxValue: Swift.Int
        /// The minimum allowable value for the hyperparameter.
        public var minValue: Swift.Int
        /// The name of the hyperparameter.
        public var name: Swift.String?

        public init (
            isTunable: Swift.Bool = false,
            maxValue: Swift.Int = 0,
            minValue: Swift.Int = 0,
            name: Swift.String? = nil
        )
        {
            self.isTunable = isTunable
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
        }
    }

}

extension DeleteCampaignInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignArn = self.campaignArn {
            try encodeContainer.encode(campaignArn, forKey: .campaignArn)
        }
    }
}

extension DeleteCampaignInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteCampaignInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the campaign to delete.
    /// This member is required.
    public var campaignArn: Swift.String?

    public init (
        campaignArn: Swift.String? = nil
    )
    {
        self.campaignArn = campaignArn
    }
}

struct DeleteCampaignInputBody: Swift.Equatable {
    let campaignArn: Swift.String?
}

extension DeleteCampaignInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .campaignArn)
        campaignArn = campaignArnDecoded
    }
}

extension DeleteCampaignOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCampaignOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteCampaignOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCampaignOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCampaignOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteDatasetGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
    }
}

extension DeleteDatasetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDatasetGroupInput: Swift.Equatable {
    /// The ARN of the dataset group to delete.
    /// This member is required.
    public var datasetGroupArn: Swift.String?

    public init (
        datasetGroupArn: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
    }
}

struct DeleteDatasetGroupInputBody: Swift.Equatable {
    let datasetGroupArn: Swift.String?
}

extension DeleteDatasetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
    }
}

extension DeleteDatasetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDatasetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteDatasetGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDatasetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDatasetGroupOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteDatasetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArn = self.datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
    }
}

extension DeleteDatasetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDatasetInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset to delete.
    /// This member is required.
    public var datasetArn: Swift.String?

    public init (
        datasetArn: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
    }
}

struct DeleteDatasetInputBody: Swift.Equatable {
    let datasetArn: Swift.String?
}

extension DeleteDatasetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
    }
}

extension DeleteDatasetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDatasetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteDatasetOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDatasetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDatasetOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteEventTrackerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTrackerArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventTrackerArn = self.eventTrackerArn {
            try encodeContainer.encode(eventTrackerArn, forKey: .eventTrackerArn)
        }
    }
}

extension DeleteEventTrackerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteEventTrackerInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the event tracker to delete.
    /// This member is required.
    public var eventTrackerArn: Swift.String?

    public init (
        eventTrackerArn: Swift.String? = nil
    )
    {
        self.eventTrackerArn = eventTrackerArn
    }
}

struct DeleteEventTrackerInputBody: Swift.Equatable {
    let eventTrackerArn: Swift.String?
}

extension DeleteEventTrackerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTrackerArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTrackerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTrackerArn)
        eventTrackerArn = eventTrackerArnDecoded
    }
}

extension DeleteEventTrackerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEventTrackerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteEventTrackerOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEventTrackerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteEventTrackerOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteFilterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterArn = self.filterArn {
            try encodeContainer.encode(filterArn, forKey: .filterArn)
        }
    }
}

extension DeleteFilterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteFilterInput: Swift.Equatable {
    /// The ARN of the filter to delete.
    /// This member is required.
    public var filterArn: Swift.String?

    public init (
        filterArn: Swift.String? = nil
    )
    {
        self.filterArn = filterArn
    }
}

struct DeleteFilterInputBody: Swift.Equatable {
    let filterArn: Swift.String?
}

extension DeleteFilterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
    }
}

extension DeleteFilterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFilterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteFilterOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFilterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFilterOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteMetricAttributionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricAttributionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricAttributionArn = self.metricAttributionArn {
            try encodeContainer.encode(metricAttributionArn, forKey: .metricAttributionArn)
        }
    }
}

extension DeleteMetricAttributionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteMetricAttributionInput: Swift.Equatable {
    /// The metric attribution's Amazon Resource Name (ARN).
    /// This member is required.
    public var metricAttributionArn: Swift.String?

    public init (
        metricAttributionArn: Swift.String? = nil
    )
    {
        self.metricAttributionArn = metricAttributionArn
    }
}

struct DeleteMetricAttributionInputBody: Swift.Equatable {
    let metricAttributionArn: Swift.String?
}

extension DeleteMetricAttributionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricAttributionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricAttributionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricAttributionArn)
        metricAttributionArn = metricAttributionArnDecoded
    }
}

extension DeleteMetricAttributionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMetricAttributionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteMetricAttributionOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMetricAttributionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteMetricAttributionOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteRecommenderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommenderArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recommenderArn = self.recommenderArn {
            try encodeContainer.encode(recommenderArn, forKey: .recommenderArn)
        }
    }
}

extension DeleteRecommenderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteRecommenderInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the recommender to delete.
    /// This member is required.
    public var recommenderArn: Swift.String?

    public init (
        recommenderArn: Swift.String? = nil
    )
    {
        self.recommenderArn = recommenderArn
    }
}

struct DeleteRecommenderInputBody: Swift.Equatable {
    let recommenderArn: Swift.String?
}

extension DeleteRecommenderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommenderArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommenderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommenderArn)
        recommenderArn = recommenderArnDecoded
    }
}

extension DeleteRecommenderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRecommenderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteRecommenderOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRecommenderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRecommenderOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteSchemaInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schemaArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let schemaArn = self.schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
    }
}

extension DeleteSchemaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteSchemaInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the schema to delete.
    /// This member is required.
    public var schemaArn: Swift.String?

    public init (
        schemaArn: Swift.String? = nil
    )
    {
        self.schemaArn = schemaArn
    }
}

struct DeleteSchemaInputBody: Swift.Equatable {
    let schemaArn: Swift.String?
}

extension DeleteSchemaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schemaArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
    }
}

extension DeleteSchemaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSchemaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSchemaOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSchemaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSchemaOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteSolutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solutionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let solutionArn = self.solutionArn {
            try encodeContainer.encode(solutionArn, forKey: .solutionArn)
        }
    }
}

extension DeleteSolutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteSolutionInput: Swift.Equatable {
    /// The ARN of the solution to delete.
    /// This member is required.
    public var solutionArn: Swift.String?

    public init (
        solutionArn: Swift.String? = nil
    )
    {
        self.solutionArn = solutionArn
    }
}

struct DeleteSolutionInputBody: Swift.Equatable {
    let solutionArn: Swift.String?
}

extension DeleteSolutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solutionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionArn)
        solutionArn = solutionArnDecoded
    }
}

extension DeleteSolutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSolutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSolutionOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSolutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSolutionOutputResponse: Swift.Equatable {

    public init () { }
}

extension DescribeAlgorithmInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmArn = self.algorithmArn {
            try encodeContainer.encode(algorithmArn, forKey: .algorithmArn)
        }
    }
}

extension DescribeAlgorithmInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAlgorithmInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the algorithm to describe.
    /// This member is required.
    public var algorithmArn: Swift.String?

    public init (
        algorithmArn: Swift.String? = nil
    )
    {
        self.algorithmArn = algorithmArn
    }
}

struct DescribeAlgorithmInputBody: Swift.Equatable {
    let algorithmArn: Swift.String?
}

extension DescribeAlgorithmInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let algorithmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .algorithmArn)
        algorithmArn = algorithmArnDecoded
    }
}

extension DescribeAlgorithmOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAlgorithmOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeAlgorithmOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAlgorithmOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeAlgorithmOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.algorithm = output.algorithm
        } else {
            self.algorithm = nil
        }
    }
}

public struct DescribeAlgorithmOutputResponse: Swift.Equatable {
    /// A listing of the properties of the algorithm.
    public var algorithm: PersonalizeClientTypes.Algorithm?

    public init (
        algorithm: PersonalizeClientTypes.Algorithm? = nil
    )
    {
        self.algorithm = algorithm
    }
}

struct DescribeAlgorithmOutputResponseBody: Swift.Equatable {
    let algorithm: PersonalizeClientTypes.Algorithm?
}

extension DescribeAlgorithmOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithm
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let algorithmDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.Algorithm.self, forKey: .algorithm)
        algorithm = algorithmDecoded
    }
}

extension DescribeBatchInferenceJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchInferenceJobArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchInferenceJobArn = self.batchInferenceJobArn {
            try encodeContainer.encode(batchInferenceJobArn, forKey: .batchInferenceJobArn)
        }
    }
}

extension DescribeBatchInferenceJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeBatchInferenceJobInput: Swift.Equatable {
    /// The ARN of the batch inference job to describe.
    /// This member is required.
    public var batchInferenceJobArn: Swift.String?

    public init (
        batchInferenceJobArn: Swift.String? = nil
    )
    {
        self.batchInferenceJobArn = batchInferenceJobArn
    }
}

struct DescribeBatchInferenceJobInputBody: Swift.Equatable {
    let batchInferenceJobArn: Swift.String?
}

extension DescribeBatchInferenceJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchInferenceJobArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchInferenceJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .batchInferenceJobArn)
        batchInferenceJobArn = batchInferenceJobArnDecoded
    }
}

extension DescribeBatchInferenceJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBatchInferenceJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeBatchInferenceJobOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBatchInferenceJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeBatchInferenceJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.batchInferenceJob = output.batchInferenceJob
        } else {
            self.batchInferenceJob = nil
        }
    }
}

public struct DescribeBatchInferenceJobOutputResponse: Swift.Equatable {
    /// Information on the specified batch inference job.
    public var batchInferenceJob: PersonalizeClientTypes.BatchInferenceJob?

    public init (
        batchInferenceJob: PersonalizeClientTypes.BatchInferenceJob? = nil
    )
    {
        self.batchInferenceJob = batchInferenceJob
    }
}

struct DescribeBatchInferenceJobOutputResponseBody: Swift.Equatable {
    let batchInferenceJob: PersonalizeClientTypes.BatchInferenceJob?
}

extension DescribeBatchInferenceJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchInferenceJob
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchInferenceJobDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.BatchInferenceJob.self, forKey: .batchInferenceJob)
        batchInferenceJob = batchInferenceJobDecoded
    }
}

extension DescribeBatchSegmentJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchSegmentJobArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchSegmentJobArn = self.batchSegmentJobArn {
            try encodeContainer.encode(batchSegmentJobArn, forKey: .batchSegmentJobArn)
        }
    }
}

extension DescribeBatchSegmentJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeBatchSegmentJobInput: Swift.Equatable {
    /// The ARN of the batch segment job to describe.
    /// This member is required.
    public var batchSegmentJobArn: Swift.String?

    public init (
        batchSegmentJobArn: Swift.String? = nil
    )
    {
        self.batchSegmentJobArn = batchSegmentJobArn
    }
}

struct DescribeBatchSegmentJobInputBody: Swift.Equatable {
    let batchSegmentJobArn: Swift.String?
}

extension DescribeBatchSegmentJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchSegmentJobArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchSegmentJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .batchSegmentJobArn)
        batchSegmentJobArn = batchSegmentJobArnDecoded
    }
}

extension DescribeBatchSegmentJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBatchSegmentJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeBatchSegmentJobOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBatchSegmentJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeBatchSegmentJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.batchSegmentJob = output.batchSegmentJob
        } else {
            self.batchSegmentJob = nil
        }
    }
}

public struct DescribeBatchSegmentJobOutputResponse: Swift.Equatable {
    /// Information on the specified batch segment job.
    public var batchSegmentJob: PersonalizeClientTypes.BatchSegmentJob?

    public init (
        batchSegmentJob: PersonalizeClientTypes.BatchSegmentJob? = nil
    )
    {
        self.batchSegmentJob = batchSegmentJob
    }
}

struct DescribeBatchSegmentJobOutputResponseBody: Swift.Equatable {
    let batchSegmentJob: PersonalizeClientTypes.BatchSegmentJob?
}

extension DescribeBatchSegmentJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchSegmentJob
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchSegmentJobDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.BatchSegmentJob.self, forKey: .batchSegmentJob)
        batchSegmentJob = batchSegmentJobDecoded
    }
}

extension DescribeCampaignInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignArn = self.campaignArn {
            try encodeContainer.encode(campaignArn, forKey: .campaignArn)
        }
    }
}

extension DescribeCampaignInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeCampaignInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the campaign.
    /// This member is required.
    public var campaignArn: Swift.String?

    public init (
        campaignArn: Swift.String? = nil
    )
    {
        self.campaignArn = campaignArn
    }
}

struct DescribeCampaignInputBody: Swift.Equatable {
    let campaignArn: Swift.String?
}

extension DescribeCampaignInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .campaignArn)
        campaignArn = campaignArnDecoded
    }
}

extension DescribeCampaignOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCampaignOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeCampaignOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCampaignOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeCampaignOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.campaign = output.campaign
        } else {
            self.campaign = nil
        }
    }
}

public struct DescribeCampaignOutputResponse: Swift.Equatable {
    /// The properties of the campaign.
    public var campaign: PersonalizeClientTypes.Campaign?

    public init (
        campaign: PersonalizeClientTypes.Campaign? = nil
    )
    {
        self.campaign = campaign
    }
}

struct DescribeCampaignOutputResponseBody: Swift.Equatable {
    let campaign: PersonalizeClientTypes.Campaign?
}

extension DescribeCampaignOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaign
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.Campaign.self, forKey: .campaign)
        campaign = campaignDecoded
    }
}

extension DescribeDatasetExportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetExportJobArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetExportJobArn = self.datasetExportJobArn {
            try encodeContainer.encode(datasetExportJobArn, forKey: .datasetExportJobArn)
        }
    }
}

extension DescribeDatasetExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDatasetExportJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset export job to describe.
    /// This member is required.
    public var datasetExportJobArn: Swift.String?

    public init (
        datasetExportJobArn: Swift.String? = nil
    )
    {
        self.datasetExportJobArn = datasetExportJobArn
    }
}

struct DescribeDatasetExportJobInputBody: Swift.Equatable {
    let datasetExportJobArn: Swift.String?
}

extension DescribeDatasetExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetExportJobArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetExportJobArn)
        datasetExportJobArn = datasetExportJobArnDecoded
    }
}

extension DescribeDatasetExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDatasetExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeDatasetExportJobOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDatasetExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeDatasetExportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetExportJob = output.datasetExportJob
        } else {
            self.datasetExportJob = nil
        }
    }
}

public struct DescribeDatasetExportJobOutputResponse: Swift.Equatable {
    /// Information about the dataset export job, including the status. The status is one of the following values:
    ///
    /// * CREATE PENDING
    ///
    /// * CREATE IN_PROGRESS
    ///
    /// * ACTIVE
    ///
    /// * CREATE FAILED
    public var datasetExportJob: PersonalizeClientTypes.DatasetExportJob?

    public init (
        datasetExportJob: PersonalizeClientTypes.DatasetExportJob? = nil
    )
    {
        self.datasetExportJob = datasetExportJob
    }
}

struct DescribeDatasetExportJobOutputResponseBody: Swift.Equatable {
    let datasetExportJob: PersonalizeClientTypes.DatasetExportJob?
}

extension DescribeDatasetExportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetExportJob
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetExportJobDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.DatasetExportJob.self, forKey: .datasetExportJob)
        datasetExportJob = datasetExportJobDecoded
    }
}

extension DescribeDatasetGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
    }
}

extension DescribeDatasetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDatasetGroupInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset group to describe.
    /// This member is required.
    public var datasetGroupArn: Swift.String?

    public init (
        datasetGroupArn: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
    }
}

struct DescribeDatasetGroupInputBody: Swift.Equatable {
    let datasetGroupArn: Swift.String?
}

extension DescribeDatasetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
    }
}

extension DescribeDatasetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDatasetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeDatasetGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDatasetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeDatasetGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetGroup = output.datasetGroup
        } else {
            self.datasetGroup = nil
        }
    }
}

public struct DescribeDatasetGroupOutputResponse: Swift.Equatable {
    /// A listing of the dataset group's properties.
    public var datasetGroup: PersonalizeClientTypes.DatasetGroup?

    public init (
        datasetGroup: PersonalizeClientTypes.DatasetGroup? = nil
    )
    {
        self.datasetGroup = datasetGroup
    }
}

struct DescribeDatasetGroupOutputResponseBody: Swift.Equatable {
    let datasetGroup: PersonalizeClientTypes.DatasetGroup?
}

extension DescribeDatasetGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroup
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.DatasetGroup.self, forKey: .datasetGroup)
        datasetGroup = datasetGroupDecoded
    }
}

extension DescribeDatasetImportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetImportJobArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetImportJobArn = self.datasetImportJobArn {
            try encodeContainer.encode(datasetImportJobArn, forKey: .datasetImportJobArn)
        }
    }
}

extension DescribeDatasetImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDatasetImportJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset import job to describe.
    /// This member is required.
    public var datasetImportJobArn: Swift.String?

    public init (
        datasetImportJobArn: Swift.String? = nil
    )
    {
        self.datasetImportJobArn = datasetImportJobArn
    }
}

struct DescribeDatasetImportJobInputBody: Swift.Equatable {
    let datasetImportJobArn: Swift.String?
}

extension DescribeDatasetImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetImportJobArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
    }
}

extension DescribeDatasetImportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDatasetImportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeDatasetImportJobOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDatasetImportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeDatasetImportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetImportJob = output.datasetImportJob
        } else {
            self.datasetImportJob = nil
        }
    }
}

public struct DescribeDatasetImportJobOutputResponse: Swift.Equatable {
    /// Information about the dataset import job, including the status. The status is one of the following values:
    ///
    /// * CREATE PENDING
    ///
    /// * CREATE IN_PROGRESS
    ///
    /// * ACTIVE
    ///
    /// * CREATE FAILED
    public var datasetImportJob: PersonalizeClientTypes.DatasetImportJob?

    public init (
        datasetImportJob: PersonalizeClientTypes.DatasetImportJob? = nil
    )
    {
        self.datasetImportJob = datasetImportJob
    }
}

struct DescribeDatasetImportJobOutputResponseBody: Swift.Equatable {
    let datasetImportJob: PersonalizeClientTypes.DatasetImportJob?
}

extension DescribeDatasetImportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetImportJob
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.DatasetImportJob.self, forKey: .datasetImportJob)
        datasetImportJob = datasetImportJobDecoded
    }
}

extension DescribeDatasetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArn = self.datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
    }
}

extension DescribeDatasetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDatasetInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset to describe.
    /// This member is required.
    public var datasetArn: Swift.String?

    public init (
        datasetArn: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
    }
}

struct DescribeDatasetInputBody: Swift.Equatable {
    let datasetArn: Swift.String?
}

extension DescribeDatasetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
    }
}

extension DescribeDatasetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDatasetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeDatasetOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDatasetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeDatasetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataset = output.dataset
        } else {
            self.dataset = nil
        }
    }
}

public struct DescribeDatasetOutputResponse: Swift.Equatable {
    /// A listing of the dataset's properties.
    public var dataset: PersonalizeClientTypes.Dataset?

    public init (
        dataset: PersonalizeClientTypes.Dataset? = nil
    )
    {
        self.dataset = dataset
    }
}

struct DescribeDatasetOutputResponseBody: Swift.Equatable {
    let dataset: PersonalizeClientTypes.Dataset?
}

extension DescribeDatasetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataset
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.Dataset.self, forKey: .dataset)
        dataset = datasetDecoded
    }
}

extension DescribeEventTrackerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTrackerArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventTrackerArn = self.eventTrackerArn {
            try encodeContainer.encode(eventTrackerArn, forKey: .eventTrackerArn)
        }
    }
}

extension DescribeEventTrackerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEventTrackerInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the event tracker to describe.
    /// This member is required.
    public var eventTrackerArn: Swift.String?

    public init (
        eventTrackerArn: Swift.String? = nil
    )
    {
        self.eventTrackerArn = eventTrackerArn
    }
}

struct DescribeEventTrackerInputBody: Swift.Equatable {
    let eventTrackerArn: Swift.String?
}

extension DescribeEventTrackerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTrackerArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTrackerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTrackerArn)
        eventTrackerArn = eventTrackerArnDecoded
    }
}

extension DescribeEventTrackerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEventTrackerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeEventTrackerOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventTrackerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeEventTrackerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventTracker = output.eventTracker
        } else {
            self.eventTracker = nil
        }
    }
}

public struct DescribeEventTrackerOutputResponse: Swift.Equatable {
    /// An object that describes the event tracker.
    public var eventTracker: PersonalizeClientTypes.EventTracker?

    public init (
        eventTracker: PersonalizeClientTypes.EventTracker? = nil
    )
    {
        self.eventTracker = eventTracker
    }
}

struct DescribeEventTrackerOutputResponseBody: Swift.Equatable {
    let eventTracker: PersonalizeClientTypes.EventTracker?
}

extension DescribeEventTrackerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTracker
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTrackerDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.EventTracker.self, forKey: .eventTracker)
        eventTracker = eventTrackerDecoded
    }
}

extension DescribeFeatureTransformationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case featureTransformationArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let featureTransformationArn = self.featureTransformationArn {
            try encodeContainer.encode(featureTransformationArn, forKey: .featureTransformationArn)
        }
    }
}

extension DescribeFeatureTransformationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeFeatureTransformationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the feature transformation to describe.
    /// This member is required.
    public var featureTransformationArn: Swift.String?

    public init (
        featureTransformationArn: Swift.String? = nil
    )
    {
        self.featureTransformationArn = featureTransformationArn
    }
}

struct DescribeFeatureTransformationInputBody: Swift.Equatable {
    let featureTransformationArn: Swift.String?
}

extension DescribeFeatureTransformationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case featureTransformationArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featureTransformationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .featureTransformationArn)
        featureTransformationArn = featureTransformationArnDecoded
    }
}

extension DescribeFeatureTransformationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFeatureTransformationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeFeatureTransformationOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFeatureTransformationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeFeatureTransformationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.featureTransformation = output.featureTransformation
        } else {
            self.featureTransformation = nil
        }
    }
}

public struct DescribeFeatureTransformationOutputResponse: Swift.Equatable {
    /// A listing of the FeatureTransformation properties.
    public var featureTransformation: PersonalizeClientTypes.FeatureTransformation?

    public init (
        featureTransformation: PersonalizeClientTypes.FeatureTransformation? = nil
    )
    {
        self.featureTransformation = featureTransformation
    }
}

struct DescribeFeatureTransformationOutputResponseBody: Swift.Equatable {
    let featureTransformation: PersonalizeClientTypes.FeatureTransformation?
}

extension DescribeFeatureTransformationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case featureTransformation
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featureTransformationDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.FeatureTransformation.self, forKey: .featureTransformation)
        featureTransformation = featureTransformationDecoded
    }
}

extension DescribeFilterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterArn = self.filterArn {
            try encodeContainer.encode(filterArn, forKey: .filterArn)
        }
    }
}

extension DescribeFilterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeFilterInput: Swift.Equatable {
    /// The ARN of the filter to describe.
    /// This member is required.
    public var filterArn: Swift.String?

    public init (
        filterArn: Swift.String? = nil
    )
    {
        self.filterArn = filterArn
    }
}

struct DescribeFilterInputBody: Swift.Equatable {
    let filterArn: Swift.String?
}

extension DescribeFilterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
    }
}

extension DescribeFilterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFilterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeFilterOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFilterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeFilterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.filter = output.filter
        } else {
            self.filter = nil
        }
    }
}

public struct DescribeFilterOutputResponse: Swift.Equatable {
    /// The filter's details.
    public var filter: PersonalizeClientTypes.Filter?

    public init (
        filter: PersonalizeClientTypes.Filter? = nil
    )
    {
        self.filter = filter
    }
}

struct DescribeFilterOutputResponseBody: Swift.Equatable {
    let filter: PersonalizeClientTypes.Filter?
}

extension DescribeFilterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.Filter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension DescribeMetricAttributionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricAttributionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricAttributionArn = self.metricAttributionArn {
            try encodeContainer.encode(metricAttributionArn, forKey: .metricAttributionArn)
        }
    }
}

extension DescribeMetricAttributionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeMetricAttributionInput: Swift.Equatable {
    /// The metric attribution's Amazon Resource Name (ARN).
    /// This member is required.
    public var metricAttributionArn: Swift.String?

    public init (
        metricAttributionArn: Swift.String? = nil
    )
    {
        self.metricAttributionArn = metricAttributionArn
    }
}

struct DescribeMetricAttributionInputBody: Swift.Equatable {
    let metricAttributionArn: Swift.String?
}

extension DescribeMetricAttributionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricAttributionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricAttributionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricAttributionArn)
        metricAttributionArn = metricAttributionArnDecoded
    }
}

extension DescribeMetricAttributionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMetricAttributionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeMetricAttributionOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMetricAttributionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeMetricAttributionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.metricAttribution = output.metricAttribution
        } else {
            self.metricAttribution = nil
        }
    }
}

public struct DescribeMetricAttributionOutputResponse: Swift.Equatable {
    /// The details of the metric attribution.
    public var metricAttribution: PersonalizeClientTypes.MetricAttribution?

    public init (
        metricAttribution: PersonalizeClientTypes.MetricAttribution? = nil
    )
    {
        self.metricAttribution = metricAttribution
    }
}

struct DescribeMetricAttributionOutputResponseBody: Swift.Equatable {
    let metricAttribution: PersonalizeClientTypes.MetricAttribution?
}

extension DescribeMetricAttributionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricAttribution
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricAttributionDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.MetricAttribution.self, forKey: .metricAttribution)
        metricAttribution = metricAttributionDecoded
    }
}

extension DescribeRecipeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recipeArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recipeArn = self.recipeArn {
            try encodeContainer.encode(recipeArn, forKey: .recipeArn)
        }
    }
}

extension DescribeRecipeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeRecipeInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the recipe to describe.
    /// This member is required.
    public var recipeArn: Swift.String?

    public init (
        recipeArn: Swift.String? = nil
    )
    {
        self.recipeArn = recipeArn
    }
}

struct DescribeRecipeInputBody: Swift.Equatable {
    let recipeArn: Swift.String?
}

extension DescribeRecipeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recipeArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipeArn)
        recipeArn = recipeArnDecoded
    }
}

extension DescribeRecipeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRecipeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeRecipeOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRecipeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeRecipeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.recipe = output.recipe
        } else {
            self.recipe = nil
        }
    }
}

public struct DescribeRecipeOutputResponse: Swift.Equatable {
    /// An object that describes the recipe.
    public var recipe: PersonalizeClientTypes.Recipe?

    public init (
        recipe: PersonalizeClientTypes.Recipe? = nil
    )
    {
        self.recipe = recipe
    }
}

struct DescribeRecipeOutputResponseBody: Swift.Equatable {
    let recipe: PersonalizeClientTypes.Recipe?
}

extension DescribeRecipeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recipe
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recipeDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.Recipe.self, forKey: .recipe)
        recipe = recipeDecoded
    }
}

extension DescribeRecommenderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommenderArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recommenderArn = self.recommenderArn {
            try encodeContainer.encode(recommenderArn, forKey: .recommenderArn)
        }
    }
}

extension DescribeRecommenderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeRecommenderInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the recommender to describe.
    /// This member is required.
    public var recommenderArn: Swift.String?

    public init (
        recommenderArn: Swift.String? = nil
    )
    {
        self.recommenderArn = recommenderArn
    }
}

struct DescribeRecommenderInputBody: Swift.Equatable {
    let recommenderArn: Swift.String?
}

extension DescribeRecommenderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommenderArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommenderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommenderArn)
        recommenderArn = recommenderArnDecoded
    }
}

extension DescribeRecommenderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRecommenderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeRecommenderOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRecommenderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeRecommenderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.recommender = output.recommender
        } else {
            self.recommender = nil
        }
    }
}

public struct DescribeRecommenderOutputResponse: Swift.Equatable {
    /// The properties of the recommender.
    public var recommender: PersonalizeClientTypes.Recommender?

    public init (
        recommender: PersonalizeClientTypes.Recommender? = nil
    )
    {
        self.recommender = recommender
    }
}

struct DescribeRecommenderOutputResponseBody: Swift.Equatable {
    let recommender: PersonalizeClientTypes.Recommender?
}

extension DescribeRecommenderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommender
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommenderDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.Recommender.self, forKey: .recommender)
        recommender = recommenderDecoded
    }
}

extension DescribeSchemaInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schemaArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let schemaArn = self.schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
    }
}

extension DescribeSchemaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeSchemaInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the schema to retrieve.
    /// This member is required.
    public var schemaArn: Swift.String?

    public init (
        schemaArn: Swift.String? = nil
    )
    {
        self.schemaArn = schemaArn
    }
}

struct DescribeSchemaInputBody: Swift.Equatable {
    let schemaArn: Swift.String?
}

extension DescribeSchemaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schemaArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
    }
}

extension DescribeSchemaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSchemaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeSchemaOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSchemaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeSchemaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.schema = output.schema
        } else {
            self.schema = nil
        }
    }
}

public struct DescribeSchemaOutputResponse: Swift.Equatable {
    /// The requested schema.
    public var schema: PersonalizeClientTypes.DatasetSchema?

    public init (
        schema: PersonalizeClientTypes.DatasetSchema? = nil
    )
    {
        self.schema = schema
    }
}

struct DescribeSchemaOutputResponseBody: Swift.Equatable {
    let schema: PersonalizeClientTypes.DatasetSchema?
}

extension DescribeSchemaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schema
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.DatasetSchema.self, forKey: .schema)
        schema = schemaDecoded
    }
}

extension DescribeSolutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solutionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let solutionArn = self.solutionArn {
            try encodeContainer.encode(solutionArn, forKey: .solutionArn)
        }
    }
}

extension DescribeSolutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeSolutionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the solution to describe.
    /// This member is required.
    public var solutionArn: Swift.String?

    public init (
        solutionArn: Swift.String? = nil
    )
    {
        self.solutionArn = solutionArn
    }
}

struct DescribeSolutionInputBody: Swift.Equatable {
    let solutionArn: Swift.String?
}

extension DescribeSolutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solutionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionArn)
        solutionArn = solutionArnDecoded
    }
}

extension DescribeSolutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSolutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeSolutionOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSolutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeSolutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.solution = output.solution
        } else {
            self.solution = nil
        }
    }
}

public struct DescribeSolutionOutputResponse: Swift.Equatable {
    /// An object that describes the solution.
    public var solution: PersonalizeClientTypes.Solution?

    public init (
        solution: PersonalizeClientTypes.Solution? = nil
    )
    {
        self.solution = solution
    }
}

struct DescribeSolutionOutputResponseBody: Swift.Equatable {
    let solution: PersonalizeClientTypes.Solution?
}

extension DescribeSolutionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solution
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.Solution.self, forKey: .solution)
        solution = solutionDecoded
    }
}

extension DescribeSolutionVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solutionVersionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let solutionVersionArn = self.solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
    }
}

extension DescribeSolutionVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeSolutionVersionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the solution version.
    /// This member is required.
    public var solutionVersionArn: Swift.String?

    public init (
        solutionVersionArn: Swift.String? = nil
    )
    {
        self.solutionVersionArn = solutionVersionArn
    }
}

struct DescribeSolutionVersionInputBody: Swift.Equatable {
    let solutionVersionArn: Swift.String?
}

extension DescribeSolutionVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solutionVersionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
    }
}

extension DescribeSolutionVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSolutionVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeSolutionVersionOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSolutionVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeSolutionVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.solutionVersion = output.solutionVersion
        } else {
            self.solutionVersion = nil
        }
    }
}

public struct DescribeSolutionVersionOutputResponse: Swift.Equatable {
    /// The solution version.
    public var solutionVersion: PersonalizeClientTypes.SolutionVersion?

    public init (
        solutionVersion: PersonalizeClientTypes.SolutionVersion? = nil
    )
    {
        self.solutionVersion = solutionVersion
    }
}

struct DescribeSolutionVersionOutputResponseBody: Swift.Equatable {
    let solutionVersion: PersonalizeClientTypes.SolutionVersion?
}

extension DescribeSolutionVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solutionVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.SolutionVersion.self, forKey: .solutionVersion)
        solutionVersion = solutionVersionDecoded
    }
}

extension PersonalizeClientTypes {
    public enum Domain: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ecommerce
        case videoOnDemand
        case sdkUnknown(Swift.String)

        public static var allCases: [Domain] {
            return [
                .ecommerce,
                .videoOnDemand,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ecommerce: return "ECOMMERCE"
            case .videoOnDemand: return "VIDEO_ON_DEMAND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Domain(rawValue: rawValue) ?? Domain.sdkUnknown(rawValue)
        }
    }
}

extension PersonalizeClientTypes.EventTracker: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case creationDateTime
        case datasetGroupArn
        case eventTrackerArn
        case lastUpdatedDateTime
        case name
        case status
        case trackingId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let eventTrackerArn = self.eventTrackerArn {
            try encodeContainer.encode(eventTrackerArn, forKey: .eventTrackerArn)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let trackingId = self.trackingId {
            try encodeContainer.encode(trackingId, forKey: .trackingId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let eventTrackerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTrackerArn)
        eventTrackerArn = eventTrackerArnDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let trackingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackingId)
        trackingId = trackingIdDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides information about an event tracker.
    public struct EventTracker: Swift.Equatable {
        /// The Amazon Web Services account that owns the event tracker.
        public var accountId: Swift.String?
        /// The date and time (in Unix format) that the event tracker was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset group that receives the event data.
        public var datasetGroupArn: Swift.String?
        /// The ARN of the event tracker.
        public var eventTrackerArn: Swift.String?
        /// The date and time (in Unix time) that the event tracker was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the event tracker.
        public var name: Swift.String?
        /// The status of the event tracker. An event tracker can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        /// * DELETE PENDING > DELETE IN_PROGRESS
        public var status: Swift.String?
        /// The ID of the event tracker. Include this ID in requests to the [PutEvents](https://docs.aws.amazon.com/personalize/latest/dg/API_UBS_PutEvents.html) API.
        public var trackingId: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            eventTrackerArn: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil,
            trackingId: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.eventTrackerArn = eventTrackerArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
            self.trackingId = trackingId
        }
    }

}

extension PersonalizeClientTypes.EventTrackerSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case eventTrackerArn
        case lastUpdatedDateTime
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let eventTrackerArn = self.eventTrackerArn {
            try encodeContainer.encode(eventTrackerArn, forKey: .eventTrackerArn)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let eventTrackerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTrackerArn)
        eventTrackerArn = eventTrackerArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides a summary of the properties of an event tracker. For a complete listing, call the [DescribeEventTracker](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeEventTracker.html) API.
    public struct EventTrackerSummary: Swift.Equatable {
        /// The date and time (in Unix time) that the event tracker was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the event tracker.
        public var eventTrackerArn: Swift.String?
        /// The date and time (in Unix time) that the event tracker was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the event tracker.
        public var name: Swift.String?
        /// The status of the event tracker. An event tracker can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        /// * DELETE PENDING > DELETE IN_PROGRESS
        public var status: Swift.String?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            eventTrackerArn: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.eventTrackerArn = eventTrackerArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.FeatureTransformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case defaultParameters
        case featureTransformationArn
        case lastUpdatedDateTime
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let defaultParameters = defaultParameters {
            var defaultParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .defaultParameters)
            for (dictKey0, featurizationParameters0) in defaultParameters {
                try defaultParametersContainer.encode(featurizationParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let featureTransformationArn = self.featureTransformationArn {
            try encodeContainer.encode(featureTransformationArn, forKey: .featureTransformationArn)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let featureTransformationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .featureTransformationArn)
        featureTransformationArn = featureTransformationArnDecoded
        let defaultParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .defaultParameters)
        var defaultParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let defaultParametersContainer = defaultParametersContainer {
            defaultParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in defaultParametersContainer {
                if let parametervalue0 = parametervalue0 {
                    defaultParametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        defaultParameters = defaultParametersDecoded0
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides feature transformation information. Feature transformation is the process of modifying raw input data into a form more suitable for model training.
    public struct FeatureTransformation: Swift.Equatable {
        /// The creation date and time (in Unix time) of the feature transformation.
        public var creationDateTime: ClientRuntime.Date?
        /// Provides the default parameters for feature transformation.
        public var defaultParameters: [Swift.String:Swift.String]?
        /// The Amazon Resource Name (ARN) of the FeatureTransformation object.
        public var featureTransformationArn: Swift.String?
        /// The last update date and time (in Unix time) of the feature transformation.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the feature transformation.
        public var name: Swift.String?
        /// The status of the feature transformation. A feature transformation can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        public var status: Swift.String?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            defaultParameters: [Swift.String:Swift.String]? = nil,
            featureTransformationArn: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.defaultParameters = defaultParameters
            self.featureTransformationArn = featureTransformationArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case datasetGroupArn
        case failureReason
        case filterArn
        case filterExpression
        case lastUpdatedDateTime
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let filterArn = self.filterArn {
            try encodeContainer.encode(filterArn, forKey: .filterArn)
        }
        if let filterExpression = self.filterExpression {
            try encodeContainer.encode(filterExpression, forKey: .filterExpression)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let filterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let filterExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterExpression)
        filterExpression = filterExpressionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension PersonalizeClientTypes.Filter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Filter(creationDateTime: \(Swift.String(describing: creationDateTime)), datasetGroupArn: \(Swift.String(describing: datasetGroupArn)), failureReason: \(Swift.String(describing: failureReason)), filterArn: \(Swift.String(describing: filterArn)), lastUpdatedDateTime: \(Swift.String(describing: lastUpdatedDateTime)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), filterExpression: \"CONTENT_REDACTED\")"}
}

extension PersonalizeClientTypes {
    /// Contains information on a recommendation filter, including its ARN, status, and filter expression.
    public struct Filter: Swift.Equatable {
        /// The time at which the filter was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The ARN of the dataset group to which the filter belongs.
        public var datasetGroupArn: Swift.String?
        /// If the filter failed, the reason for its failure.
        public var failureReason: Swift.String?
        /// The ARN of the filter.
        public var filterArn: Swift.String?
        /// Specifies the type of item interactions to filter out of recommendation results. The filter expression must follow specific format rules. For information about filter expression structure and syntax, see [Filter expressions](https://docs.aws.amazon.com/personalize/latest/dg/filter-expressions.html).
        public var filterExpression: Swift.String?
        /// The time at which the filter was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the filter.
        public var name: Swift.String?
        /// The status of the filter.
        public var status: Swift.String?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            filterArn: Swift.String? = nil,
            filterExpression: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.failureReason = failureReason
            self.filterArn = filterArn
            self.filterExpression = filterExpression
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.FilterSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case datasetGroupArn
        case failureReason
        case filterArn
        case lastUpdatedDateTime
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let filterArn = self.filterArn {
            try encodeContainer.encode(filterArn, forKey: .filterArn)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let filterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension PersonalizeClientTypes {
    /// A short summary of a filter's attributes.
    public struct FilterSummary: Swift.Equatable {
        /// The time at which the filter was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The ARN of the dataset group to which the filter belongs.
        public var datasetGroupArn: Swift.String?
        /// If the filter failed, the reason for the failure.
        public var failureReason: Swift.String?
        /// The ARN of the filter.
        public var filterArn: Swift.String?
        /// The time at which the filter was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the filter.
        public var name: Swift.String?
        /// The status of the filter.
        public var status: Swift.String?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            filterArn: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.failureReason = failureReason
            self.filterArn = filterArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }
    }

}

extension GetSolutionMetricsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solutionVersionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let solutionVersionArn = self.solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
    }
}

extension GetSolutionMetricsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSolutionMetricsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the solution version for which to get metrics.
    /// This member is required.
    public var solutionVersionArn: Swift.String?

    public init (
        solutionVersionArn: Swift.String? = nil
    )
    {
        self.solutionVersionArn = solutionVersionArn
    }
}

struct GetSolutionMetricsInputBody: Swift.Equatable {
    let solutionVersionArn: Swift.String?
}

extension GetSolutionMetricsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solutionVersionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
    }
}

extension GetSolutionMetricsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSolutionMetricsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSolutionMetricsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSolutionMetricsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSolutionMetricsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.metrics = output.metrics
            self.solutionVersionArn = output.solutionVersionArn
        } else {
            self.metrics = nil
            self.solutionVersionArn = nil
        }
    }
}

public struct GetSolutionMetricsOutputResponse: Swift.Equatable {
    /// The metrics for the solution version. For more information, see [ Evaluating a solution version with metrics ](https://docs.aws.amazon.com/personalize/latest/dg/working-with-training-metrics.html).
    public var metrics: [Swift.String:Swift.Double]?
    /// The same solution version ARN as specified in the request.
    public var solutionVersionArn: Swift.String?

    public init (
        metrics: [Swift.String:Swift.Double]? = nil,
        solutionVersionArn: Swift.String? = nil
    )
    {
        self.metrics = metrics
        self.solutionVersionArn = solutionVersionArn
    }
}

struct GetSolutionMetricsOutputResponseBody: Swift.Equatable {
    let solutionVersionArn: Swift.String?
    let metrics: [Swift.String:Swift.Double]?
}

extension GetSolutionMetricsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metrics
        case solutionVersionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let metricsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Double?].self, forKey: .metrics)
        var metricsDecoded0: [Swift.String:Swift.Double]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [Swift.String:Swift.Double]()
            for (key0, metricvalue0) in metricsContainer {
                if let metricvalue0 = metricvalue0 {
                    metricsDecoded0?[key0] = metricvalue0
                }
            }
        }
        metrics = metricsDecoded0
    }
}

extension PersonalizeClientTypes.HPOConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmHyperParameterRanges
        case hpoObjective
        case hpoResourceConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmHyperParameterRanges = self.algorithmHyperParameterRanges {
            try encodeContainer.encode(algorithmHyperParameterRanges, forKey: .algorithmHyperParameterRanges)
        }
        if let hpoObjective = self.hpoObjective {
            try encodeContainer.encode(hpoObjective, forKey: .hpoObjective)
        }
        if let hpoResourceConfig = self.hpoResourceConfig {
            try encodeContainer.encode(hpoResourceConfig, forKey: .hpoResourceConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hpoObjectiveDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.HPOObjective.self, forKey: .hpoObjective)
        hpoObjective = hpoObjectiveDecoded
        let hpoResourceConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.HPOResourceConfig.self, forKey: .hpoResourceConfig)
        hpoResourceConfig = hpoResourceConfigDecoded
        let algorithmHyperParameterRangesDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.HyperParameterRanges.self, forKey: .algorithmHyperParameterRanges)
        algorithmHyperParameterRanges = algorithmHyperParameterRangesDecoded
    }
}

extension PersonalizeClientTypes {
    /// Describes the properties for hyperparameter optimization (HPO).
    public struct HPOConfig: Swift.Equatable {
        /// The hyperparameters and their allowable ranges.
        public var algorithmHyperParameterRanges: PersonalizeClientTypes.HyperParameterRanges?
        /// The metric to optimize during HPO. Amazon Personalize doesn't support configuring the hpoObjective at this time.
        public var hpoObjective: PersonalizeClientTypes.HPOObjective?
        /// Describes the resource configuration for HPO.
        public var hpoResourceConfig: PersonalizeClientTypes.HPOResourceConfig?

        public init (
            algorithmHyperParameterRanges: PersonalizeClientTypes.HyperParameterRanges? = nil,
            hpoObjective: PersonalizeClientTypes.HPOObjective? = nil,
            hpoResourceConfig: PersonalizeClientTypes.HPOResourceConfig? = nil
        )
        {
            self.algorithmHyperParameterRanges = algorithmHyperParameterRanges
            self.hpoObjective = hpoObjective
            self.hpoResourceConfig = hpoResourceConfig
        }
    }

}

extension PersonalizeClientTypes.HPOObjective: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricName
        case metricRegex
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricName = self.metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let metricRegex = self.metricRegex {
            try encodeContainer.encode(metricRegex, forKey: .metricRegex)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let metricRegexDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricRegex)
        metricRegex = metricRegexDecoded
    }
}

extension PersonalizeClientTypes {
    /// The metric to optimize during hyperparameter optimization (HPO). Amazon Personalize doesn't support configuring the hpoObjective at this time.
    public struct HPOObjective: Swift.Equatable {
        /// The name of the metric.
        public var metricName: Swift.String?
        /// A regular expression for finding the metric in the training job logs.
        public var metricRegex: Swift.String?
        /// The type of the metric. Valid values are Maximize and Minimize.
        public var type: Swift.String?

        public init (
            metricName: Swift.String? = nil,
            metricRegex: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.metricName = metricName
            self.metricRegex = metricRegex
            self.type = type
        }
    }

}

extension PersonalizeClientTypes.HPOResourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxNumberOfTrainingJobs
        case maxParallelTrainingJobs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxNumberOfTrainingJobs = self.maxNumberOfTrainingJobs {
            try encodeContainer.encode(maxNumberOfTrainingJobs, forKey: .maxNumberOfTrainingJobs)
        }
        if let maxParallelTrainingJobs = self.maxParallelTrainingJobs {
            try encodeContainer.encode(maxParallelTrainingJobs, forKey: .maxParallelTrainingJobs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxNumberOfTrainingJobsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxNumberOfTrainingJobs)
        maxNumberOfTrainingJobs = maxNumberOfTrainingJobsDecoded
        let maxParallelTrainingJobsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxParallelTrainingJobs)
        maxParallelTrainingJobs = maxParallelTrainingJobsDecoded
    }
}

extension PersonalizeClientTypes {
    /// Describes the resource configuration for hyperparameter optimization (HPO).
    public struct HPOResourceConfig: Swift.Equatable {
        /// The maximum number of training jobs when you create a solution version. The maximum value for maxNumberOfTrainingJobs is 40.
        public var maxNumberOfTrainingJobs: Swift.String?
        /// The maximum number of parallel training jobs when you create a solution version. The maximum value for maxParallelTrainingJobs is 10.
        public var maxParallelTrainingJobs: Swift.String?

        public init (
            maxNumberOfTrainingJobs: Swift.String? = nil,
            maxParallelTrainingJobs: Swift.String? = nil
        )
        {
            self.maxNumberOfTrainingJobs = maxNumberOfTrainingJobs
            self.maxParallelTrainingJobs = maxParallelTrainingJobs
        }
    }

}

extension PersonalizeClientTypes.HyperParameterRanges: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoricalHyperParameterRanges
        case continuousHyperParameterRanges
        case integerHyperParameterRanges
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoricalHyperParameterRanges = categoricalHyperParameterRanges {
            var categoricalHyperParameterRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .categoricalHyperParameterRanges)
            for categoricalhyperparameterrange0 in categoricalHyperParameterRanges {
                try categoricalHyperParameterRangesContainer.encode(categoricalhyperparameterrange0)
            }
        }
        if let continuousHyperParameterRanges = continuousHyperParameterRanges {
            var continuousHyperParameterRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .continuousHyperParameterRanges)
            for continuoushyperparameterrange0 in continuousHyperParameterRanges {
                try continuousHyperParameterRangesContainer.encode(continuoushyperparameterrange0)
            }
        }
        if let integerHyperParameterRanges = integerHyperParameterRanges {
            var integerHyperParameterRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .integerHyperParameterRanges)
            for integerhyperparameterrange0 in integerHyperParameterRanges {
                try integerHyperParameterRangesContainer.encode(integerhyperparameterrange0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let integerHyperParameterRangesContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.IntegerHyperParameterRange?].self, forKey: .integerHyperParameterRanges)
        var integerHyperParameterRangesDecoded0:[PersonalizeClientTypes.IntegerHyperParameterRange]? = nil
        if let integerHyperParameterRangesContainer = integerHyperParameterRangesContainer {
            integerHyperParameterRangesDecoded0 = [PersonalizeClientTypes.IntegerHyperParameterRange]()
            for structure0 in integerHyperParameterRangesContainer {
                if let structure0 = structure0 {
                    integerHyperParameterRangesDecoded0?.append(structure0)
                }
            }
        }
        integerHyperParameterRanges = integerHyperParameterRangesDecoded0
        let continuousHyperParameterRangesContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.ContinuousHyperParameterRange?].self, forKey: .continuousHyperParameterRanges)
        var continuousHyperParameterRangesDecoded0:[PersonalizeClientTypes.ContinuousHyperParameterRange]? = nil
        if let continuousHyperParameterRangesContainer = continuousHyperParameterRangesContainer {
            continuousHyperParameterRangesDecoded0 = [PersonalizeClientTypes.ContinuousHyperParameterRange]()
            for structure0 in continuousHyperParameterRangesContainer {
                if let structure0 = structure0 {
                    continuousHyperParameterRangesDecoded0?.append(structure0)
                }
            }
        }
        continuousHyperParameterRanges = continuousHyperParameterRangesDecoded0
        let categoricalHyperParameterRangesContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.CategoricalHyperParameterRange?].self, forKey: .categoricalHyperParameterRanges)
        var categoricalHyperParameterRangesDecoded0:[PersonalizeClientTypes.CategoricalHyperParameterRange]? = nil
        if let categoricalHyperParameterRangesContainer = categoricalHyperParameterRangesContainer {
            categoricalHyperParameterRangesDecoded0 = [PersonalizeClientTypes.CategoricalHyperParameterRange]()
            for structure0 in categoricalHyperParameterRangesContainer {
                if let structure0 = structure0 {
                    categoricalHyperParameterRangesDecoded0?.append(structure0)
                }
            }
        }
        categoricalHyperParameterRanges = categoricalHyperParameterRangesDecoded0
    }
}

extension PersonalizeClientTypes {
    /// Specifies the hyperparameters and their ranges. Hyperparameters can be categorical, continuous, or integer-valued.
    public struct HyperParameterRanges: Swift.Equatable {
        /// The categorical hyperparameters and their ranges.
        public var categoricalHyperParameterRanges: [PersonalizeClientTypes.CategoricalHyperParameterRange]?
        /// The continuous hyperparameters and their ranges.
        public var continuousHyperParameterRanges: [PersonalizeClientTypes.ContinuousHyperParameterRange]?
        /// The integer-valued hyperparameters and their ranges.
        public var integerHyperParameterRanges: [PersonalizeClientTypes.IntegerHyperParameterRange]?

        public init (
            categoricalHyperParameterRanges: [PersonalizeClientTypes.CategoricalHyperParameterRange]? = nil,
            continuousHyperParameterRanges: [PersonalizeClientTypes.ContinuousHyperParameterRange]? = nil,
            integerHyperParameterRanges: [PersonalizeClientTypes.IntegerHyperParameterRange]? = nil
        )
        {
            self.categoricalHyperParameterRanges = categoricalHyperParameterRanges
            self.continuousHyperParameterRanges = continuousHyperParameterRanges
            self.integerHyperParameterRanges = integerHyperParameterRanges
        }
    }

}

extension PersonalizeClientTypes {
    public enum ImportMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case full
        case incremental
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportMode] {
            return [
                .full,
                .incremental,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .full: return "FULL"
            case .incremental: return "INCREMENTAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImportMode(rawValue: rawValue) ?? ImportMode.sdkUnknown(rawValue)
        }
    }
}

extension PersonalizeClientTypes {
    public enum IngestionMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case bulk
        case put
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionMode] {
            return [
                .all,
                .bulk,
                .put,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .bulk: return "BULK"
            case .put: return "PUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IngestionMode(rawValue: rawValue) ?? IngestionMode.sdkUnknown(rawValue)
        }
    }
}

extension PersonalizeClientTypes.IntegerHyperParameterRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxValue
        case minValue
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxValue != 0 {
            try encodeContainer.encode(maxValue, forKey: .maxValue)
        }
        if minValue != 0 {
            try encodeContainer.encode(minValue, forKey: .minValue)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let minValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minValue) ?? 0
        minValue = minValueDecoded
        let maxValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxValue) ?? 0
        maxValue = maxValueDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides the name and range of an integer-valued hyperparameter.
    public struct IntegerHyperParameterRange: Swift.Equatable {
        /// The maximum allowable value for the hyperparameter.
        public var maxValue: Swift.Int
        /// The minimum allowable value for the hyperparameter.
        public var minValue: Swift.Int
        /// The name of the hyperparameter.
        public var name: Swift.String?

        public init (
            maxValue: Swift.Int = 0,
            minValue: Swift.Int = 0,
            name: Swift.String? = nil
        )
        {
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
        }
    }

}

extension InvalidInputException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidInputExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Provide a valid value for the field or parameter.
public struct InvalidInputException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInputExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidInputExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The token is not valid.
public struct InvalidNextTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The limit on the number of requests per second has been exceeded.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListBatchInferenceJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case solutionVersionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let solutionVersionArn = self.solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
    }
}

extension ListBatchInferenceJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListBatchInferenceJobsInput: Swift.Equatable {
    /// The maximum number of batch inference job results to return in each page. The default value is 100.
    public var maxResults: Swift.Int?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the solution version from which the batch inference jobs were created.
    public var solutionVersionArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        solutionVersionArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.solutionVersionArn = solutionVersionArn
    }
}

struct ListBatchInferenceJobsInputBody: Swift.Equatable {
    let solutionVersionArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListBatchInferenceJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case solutionVersionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListBatchInferenceJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBatchInferenceJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListBatchInferenceJobsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBatchInferenceJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListBatchInferenceJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.batchInferenceJobs = output.batchInferenceJobs
            self.nextToken = output.nextToken
        } else {
            self.batchInferenceJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListBatchInferenceJobsOutputResponse: Swift.Equatable {
    /// A list containing information on each job that is returned.
    public var batchInferenceJobs: [PersonalizeClientTypes.BatchInferenceJobSummary]?
    /// The token to use to retrieve the next page of results. The value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        batchInferenceJobs: [PersonalizeClientTypes.BatchInferenceJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.batchInferenceJobs = batchInferenceJobs
        self.nextToken = nextToken
    }
}

struct ListBatchInferenceJobsOutputResponseBody: Swift.Equatable {
    let batchInferenceJobs: [PersonalizeClientTypes.BatchInferenceJobSummary]?
    let nextToken: Swift.String?
}

extension ListBatchInferenceJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchInferenceJobs
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchInferenceJobsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.BatchInferenceJobSummary?].self, forKey: .batchInferenceJobs)
        var batchInferenceJobsDecoded0:[PersonalizeClientTypes.BatchInferenceJobSummary]? = nil
        if let batchInferenceJobsContainer = batchInferenceJobsContainer {
            batchInferenceJobsDecoded0 = [PersonalizeClientTypes.BatchInferenceJobSummary]()
            for structure0 in batchInferenceJobsContainer {
                if let structure0 = structure0 {
                    batchInferenceJobsDecoded0?.append(structure0)
                }
            }
        }
        batchInferenceJobs = batchInferenceJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListBatchSegmentJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case solutionVersionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let solutionVersionArn = self.solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
    }
}

extension ListBatchSegmentJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListBatchSegmentJobsInput: Swift.Equatable {
    /// The maximum number of batch segment job results to return in each page. The default value is 100.
    public var maxResults: Swift.Int?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the solution version that the batch segment jobs used to generate batch segments.
    public var solutionVersionArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        solutionVersionArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.solutionVersionArn = solutionVersionArn
    }
}

struct ListBatchSegmentJobsInputBody: Swift.Equatable {
    let solutionVersionArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListBatchSegmentJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case solutionVersionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListBatchSegmentJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBatchSegmentJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListBatchSegmentJobsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBatchSegmentJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListBatchSegmentJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.batchSegmentJobs = output.batchSegmentJobs
            self.nextToken = output.nextToken
        } else {
            self.batchSegmentJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListBatchSegmentJobsOutputResponse: Swift.Equatable {
    /// A list containing information on each job that is returned.
    public var batchSegmentJobs: [PersonalizeClientTypes.BatchSegmentJobSummary]?
    /// The token to use to retrieve the next page of results. The value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        batchSegmentJobs: [PersonalizeClientTypes.BatchSegmentJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.batchSegmentJobs = batchSegmentJobs
        self.nextToken = nextToken
    }
}

struct ListBatchSegmentJobsOutputResponseBody: Swift.Equatable {
    let batchSegmentJobs: [PersonalizeClientTypes.BatchSegmentJobSummary]?
    let nextToken: Swift.String?
}

extension ListBatchSegmentJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchSegmentJobs
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchSegmentJobsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.BatchSegmentJobSummary?].self, forKey: .batchSegmentJobs)
        var batchSegmentJobsDecoded0:[PersonalizeClientTypes.BatchSegmentJobSummary]? = nil
        if let batchSegmentJobsContainer = batchSegmentJobsContainer {
            batchSegmentJobsDecoded0 = [PersonalizeClientTypes.BatchSegmentJobSummary]()
            for structure0 in batchSegmentJobsContainer {
                if let structure0 = structure0 {
                    batchSegmentJobsDecoded0?.append(structure0)
                }
            }
        }
        batchSegmentJobs = batchSegmentJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCampaignsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case solutionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let solutionArn = self.solutionArn {
            try encodeContainer.encode(solutionArn, forKey: .solutionArn)
        }
    }
}

extension ListCampaignsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListCampaignsInput: Swift.Equatable {
    /// The maximum number of campaigns to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to [ListCampaigns](https://docs.aws.amazon.com/personalize/latest/dg/API_ListCampaigns.html) for getting the next set of campaigns (if they exist).
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the solution to list the campaigns for. When a solution is not specified, all the campaigns associated with the account are listed.
    public var solutionArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        solutionArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.solutionArn = solutionArn
    }
}

struct ListCampaignsInputBody: Swift.Equatable {
    let solutionArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListCampaignsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case solutionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionArn)
        solutionArn = solutionArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListCampaignsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCampaignsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListCampaignsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCampaignsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListCampaignsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.campaigns = output.campaigns
            self.nextToken = output.nextToken
        } else {
            self.campaigns = nil
            self.nextToken = nil
        }
    }
}

public struct ListCampaignsOutputResponse: Swift.Equatable {
    /// A list of the campaigns.
    public var campaigns: [PersonalizeClientTypes.CampaignSummary]?
    /// A token for getting the next set of campaigns (if they exist).
    public var nextToken: Swift.String?

    public init (
        campaigns: [PersonalizeClientTypes.CampaignSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.campaigns = campaigns
        self.nextToken = nextToken
    }
}

struct ListCampaignsOutputResponseBody: Swift.Equatable {
    let campaigns: [PersonalizeClientTypes.CampaignSummary]?
    let nextToken: Swift.String?
}

extension ListCampaignsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaigns
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.CampaignSummary?].self, forKey: .campaigns)
        var campaignsDecoded0:[PersonalizeClientTypes.CampaignSummary]? = nil
        if let campaignsContainer = campaignsContainer {
            campaignsDecoded0 = [PersonalizeClientTypes.CampaignSummary]()
            for structure0 in campaignsContainer {
                if let structure0 = structure0 {
                    campaignsDecoded0?.append(structure0)
                }
            }
        }
        campaigns = campaignsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDatasetExportJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArn = self.datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDatasetExportJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDatasetExportJobsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset to list the dataset export jobs for.
    public var datasetArn: Swift.String?
    /// The maximum number of dataset export jobs to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListDatasetExportJobs for getting the next set of dataset export jobs (if they exist).
    public var nextToken: Swift.String?

    public init (
        datasetArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetExportJobsInputBody: Swift.Equatable {
    let datasetArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDatasetExportJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDatasetExportJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatasetExportJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDatasetExportJobsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatasetExportJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDatasetExportJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetExportJobs = output.datasetExportJobs
            self.nextToken = output.nextToken
        } else {
            self.datasetExportJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasetExportJobsOutputResponse: Swift.Equatable {
    /// The list of dataset export jobs.
    public var datasetExportJobs: [PersonalizeClientTypes.DatasetExportJobSummary]?
    /// A token for getting the next set of dataset export jobs (if they exist).
    public var nextToken: Swift.String?

    public init (
        datasetExportJobs: [PersonalizeClientTypes.DatasetExportJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetExportJobs = datasetExportJobs
        self.nextToken = nextToken
    }
}

struct ListDatasetExportJobsOutputResponseBody: Swift.Equatable {
    let datasetExportJobs: [PersonalizeClientTypes.DatasetExportJobSummary]?
    let nextToken: Swift.String?
}

extension ListDatasetExportJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetExportJobs
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetExportJobsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.DatasetExportJobSummary?].self, forKey: .datasetExportJobs)
        var datasetExportJobsDecoded0:[PersonalizeClientTypes.DatasetExportJobSummary]? = nil
        if let datasetExportJobsContainer = datasetExportJobsContainer {
            datasetExportJobsDecoded0 = [PersonalizeClientTypes.DatasetExportJobSummary]()
            for structure0 in datasetExportJobsContainer {
                if let structure0 = structure0 {
                    datasetExportJobsDecoded0?.append(structure0)
                }
            }
        }
        datasetExportJobs = datasetExportJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDatasetGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDatasetGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDatasetGroupsInput: Swift.Equatable {
    /// The maximum number of dataset groups to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListDatasetGroups for getting the next set of dataset groups (if they exist).
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetGroupsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDatasetGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDatasetGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatasetGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDatasetGroupsOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatasetGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDatasetGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetGroups = output.datasetGroups
            self.nextToken = output.nextToken
        } else {
            self.datasetGroups = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasetGroupsOutputResponse: Swift.Equatable {
    /// The list of your dataset groups.
    public var datasetGroups: [PersonalizeClientTypes.DatasetGroupSummary]?
    /// A token for getting the next set of dataset groups (if they exist).
    public var nextToken: Swift.String?

    public init (
        datasetGroups: [PersonalizeClientTypes.DatasetGroupSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetGroups = datasetGroups
        self.nextToken = nextToken
    }
}

struct ListDatasetGroupsOutputResponseBody: Swift.Equatable {
    let datasetGroups: [PersonalizeClientTypes.DatasetGroupSummary]?
    let nextToken: Swift.String?
}

extension ListDatasetGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroups
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.DatasetGroupSummary?].self, forKey: .datasetGroups)
        var datasetGroupsDecoded0:[PersonalizeClientTypes.DatasetGroupSummary]? = nil
        if let datasetGroupsContainer = datasetGroupsContainer {
            datasetGroupsDecoded0 = [PersonalizeClientTypes.DatasetGroupSummary]()
            for structure0 in datasetGroupsContainer {
                if let structure0 = structure0 {
                    datasetGroupsDecoded0?.append(structure0)
                }
            }
        }
        datasetGroups = datasetGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDatasetImportJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArn = self.datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDatasetImportJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDatasetImportJobsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset to list the dataset import jobs for.
    public var datasetArn: Swift.String?
    /// The maximum number of dataset import jobs to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListDatasetImportJobs for getting the next set of dataset import jobs (if they exist).
    public var nextToken: Swift.String?

    public init (
        datasetArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetImportJobsInputBody: Swift.Equatable {
    let datasetArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDatasetImportJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDatasetImportJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatasetImportJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDatasetImportJobsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatasetImportJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDatasetImportJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetImportJobs = output.datasetImportJobs
            self.nextToken = output.nextToken
        } else {
            self.datasetImportJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasetImportJobsOutputResponse: Swift.Equatable {
    /// The list of dataset import jobs.
    public var datasetImportJobs: [PersonalizeClientTypes.DatasetImportJobSummary]?
    /// A token for getting the next set of dataset import jobs (if they exist).
    public var nextToken: Swift.String?

    public init (
        datasetImportJobs: [PersonalizeClientTypes.DatasetImportJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetImportJobs = datasetImportJobs
        self.nextToken = nextToken
    }
}

struct ListDatasetImportJobsOutputResponseBody: Swift.Equatable {
    let datasetImportJobs: [PersonalizeClientTypes.DatasetImportJobSummary]?
    let nextToken: Swift.String?
}

extension ListDatasetImportJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetImportJobs
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.DatasetImportJobSummary?].self, forKey: .datasetImportJobs)
        var datasetImportJobsDecoded0:[PersonalizeClientTypes.DatasetImportJobSummary]? = nil
        if let datasetImportJobsContainer = datasetImportJobsContainer {
            datasetImportJobsDecoded0 = [PersonalizeClientTypes.DatasetImportJobSummary]()
            for structure0 in datasetImportJobsContainer {
                if let structure0 = structure0 {
                    datasetImportJobsDecoded0?.append(structure0)
                }
            }
        }
        datasetImportJobs = datasetImportJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDatasetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDatasetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDatasetsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset group that contains the datasets to list.
    public var datasetGroupArn: Swift.String?
    /// The maximum number of datasets to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListDatasetImportJobs for getting the next set of dataset import jobs (if they exist).
    public var nextToken: Swift.String?

    public init (
        datasetGroupArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetsInputBody: Swift.Equatable {
    let datasetGroupArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDatasetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDatasetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatasetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDatasetsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatasetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDatasetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasets = output.datasets
            self.nextToken = output.nextToken
        } else {
            self.datasets = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasetsOutputResponse: Swift.Equatable {
    /// An array of Dataset objects. Each object provides metadata information.
    public var datasets: [PersonalizeClientTypes.DatasetSummary]?
    /// A token for getting the next set of datasets (if they exist).
    public var nextToken: Swift.String?

    public init (
        datasets: [PersonalizeClientTypes.DatasetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasets = datasets
        self.nextToken = nextToken
    }
}

struct ListDatasetsOutputResponseBody: Swift.Equatable {
    let datasets: [PersonalizeClientTypes.DatasetSummary]?
    let nextToken: Swift.String?
}

extension ListDatasetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasets
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.DatasetSummary?].self, forKey: .datasets)
        var datasetsDecoded0:[PersonalizeClientTypes.DatasetSummary]? = nil
        if let datasetsContainer = datasetsContainer {
            datasetsDecoded0 = [PersonalizeClientTypes.DatasetSummary]()
            for structure0 in datasetsContainer {
                if let structure0 = structure0 {
                    datasetsDecoded0?.append(structure0)
                }
            }
        }
        datasets = datasetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListEventTrackersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListEventTrackersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListEventTrackersInput: Swift.Equatable {
    /// The ARN of a dataset group used to filter the response.
    public var datasetGroupArn: Swift.String?
    /// The maximum number of event trackers to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListEventTrackers for getting the next set of event trackers (if they exist).
    public var nextToken: Swift.String?

    public init (
        datasetGroupArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEventTrackersInputBody: Swift.Equatable {
    let datasetGroupArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListEventTrackersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEventTrackersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEventTrackersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListEventTrackersOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEventTrackersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListEventTrackersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventTrackers = output.eventTrackers
            self.nextToken = output.nextToken
        } else {
            self.eventTrackers = nil
            self.nextToken = nil
        }
    }
}

public struct ListEventTrackersOutputResponse: Swift.Equatable {
    /// A list of event trackers.
    public var eventTrackers: [PersonalizeClientTypes.EventTrackerSummary]?
    /// A token for getting the next set of event trackers (if they exist).
    public var nextToken: Swift.String?

    public init (
        eventTrackers: [PersonalizeClientTypes.EventTrackerSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventTrackers = eventTrackers
        self.nextToken = nextToken
    }
}

struct ListEventTrackersOutputResponseBody: Swift.Equatable {
    let eventTrackers: [PersonalizeClientTypes.EventTrackerSummary]?
    let nextToken: Swift.String?
}

extension ListEventTrackersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTrackers
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTrackersContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.EventTrackerSummary?].self, forKey: .eventTrackers)
        var eventTrackersDecoded0:[PersonalizeClientTypes.EventTrackerSummary]? = nil
        if let eventTrackersContainer = eventTrackersContainer {
            eventTrackersDecoded0 = [PersonalizeClientTypes.EventTrackerSummary]()
            for structure0 in eventTrackersContainer {
                if let structure0 = structure0 {
                    eventTrackersDecoded0?.append(structure0)
                }
            }
        }
        eventTrackers = eventTrackersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFiltersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListFiltersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListFiltersInput: Swift.Equatable {
    /// The ARN of the dataset group that contains the filters.
    public var datasetGroupArn: Swift.String?
    /// The maximum number of filters to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListFilters for getting the next set of filters (if they exist).
    public var nextToken: Swift.String?

    public init (
        datasetGroupArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFiltersInputBody: Swift.Equatable {
    let datasetGroupArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListFiltersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListFiltersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFiltersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListFiltersOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFiltersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListFiltersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.filters = output.filters
            self.nextToken = output.nextToken
        } else {
            self.filters = nil
            self.nextToken = nil
        }
    }
}

public struct ListFiltersOutputResponse: Swift.Equatable {
    /// A list of returned filters.
    public var filters: [PersonalizeClientTypes.FilterSummary]?
    /// A token for getting the next set of filters (if they exist).
    public var nextToken: Swift.String?

    public init (
        filters: [PersonalizeClientTypes.FilterSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.nextToken = nextToken
    }
}

struct ListFiltersOutputResponseBody: Swift.Equatable {
    let filters: [PersonalizeClientTypes.FilterSummary]?
    let nextToken: Swift.String?
}

extension ListFiltersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.FilterSummary?].self, forKey: .filters)
        var filtersDecoded0:[PersonalizeClientTypes.FilterSummary]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [PersonalizeClientTypes.FilterSummary]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListMetricAttributionMetricsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case metricAttributionArn
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let metricAttributionArn = self.metricAttributionArn {
            try encodeContainer.encode(metricAttributionArn, forKey: .metricAttributionArn)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListMetricAttributionMetricsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListMetricAttributionMetricsInput: Swift.Equatable {
    /// The maximum number of metrics to return in one page of results.
    public var maxResults: Swift.Int?
    /// The Amazon Resource Name (ARN) of the metric attribution to retrieve attributes for.
    public var metricAttributionArn: Swift.String?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        metricAttributionArn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.metricAttributionArn = metricAttributionArn
        self.nextToken = nextToken
    }
}

struct ListMetricAttributionMetricsInputBody: Swift.Equatable {
    let metricAttributionArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListMetricAttributionMetricsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case metricAttributionArn
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricAttributionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricAttributionArn)
        metricAttributionArn = metricAttributionArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListMetricAttributionMetricsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMetricAttributionMetricsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListMetricAttributionMetricsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMetricAttributionMetricsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListMetricAttributionMetricsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.metrics = output.metrics
            self.nextToken = output.nextToken
        } else {
            self.metrics = nil
            self.nextToken = nil
        }
    }
}

public struct ListMetricAttributionMetricsOutputResponse: Swift.Equatable {
    /// The metrics for the specified metric attribution.
    public var metrics: [PersonalizeClientTypes.MetricAttribute]?
    /// Specify the pagination token from a previous ListMetricAttributionMetricsResponse request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        metrics: [PersonalizeClientTypes.MetricAttribute]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.metrics = metrics
        self.nextToken = nextToken
    }
}

struct ListMetricAttributionMetricsOutputResponseBody: Swift.Equatable {
    let metrics: [PersonalizeClientTypes.MetricAttribute]?
    let nextToken: Swift.String?
}

extension ListMetricAttributionMetricsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metrics
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.MetricAttribute?].self, forKey: .metrics)
        var metricsDecoded0:[PersonalizeClientTypes.MetricAttribute]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [PersonalizeClientTypes.MetricAttribute]()
            for structure0 in metricsContainer {
                if let structure0 = structure0 {
                    metricsDecoded0?.append(structure0)
                }
            }
        }
        metrics = metricsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListMetricAttributionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListMetricAttributionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListMetricAttributionsInput: Swift.Equatable {
    /// The metric attributions' dataset group Amazon Resource Name (ARN).
    public var datasetGroupArn: Swift.String?
    /// The maximum number of metric attributions to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        datasetGroupArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMetricAttributionsInputBody: Swift.Equatable {
    let datasetGroupArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListMetricAttributionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListMetricAttributionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMetricAttributionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListMetricAttributionsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMetricAttributionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListMetricAttributionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.metricAttributions = output.metricAttributions
            self.nextToken = output.nextToken
        } else {
            self.metricAttributions = nil
            self.nextToken = nil
        }
    }
}

public struct ListMetricAttributionsOutputResponse: Swift.Equatable {
    /// The list of metric attributions.
    public var metricAttributions: [PersonalizeClientTypes.MetricAttributionSummary]?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        metricAttributions: [PersonalizeClientTypes.MetricAttributionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.metricAttributions = metricAttributions
        self.nextToken = nextToken
    }
}

struct ListMetricAttributionsOutputResponseBody: Swift.Equatable {
    let metricAttributions: [PersonalizeClientTypes.MetricAttributionSummary]?
    let nextToken: Swift.String?
}

extension ListMetricAttributionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricAttributions
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricAttributionsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.MetricAttributionSummary?].self, forKey: .metricAttributions)
        var metricAttributionsDecoded0:[PersonalizeClientTypes.MetricAttributionSummary]? = nil
        if let metricAttributionsContainer = metricAttributionsContainer {
            metricAttributionsDecoded0 = [PersonalizeClientTypes.MetricAttributionSummary]()
            for structure0 in metricAttributionsContainer {
                if let structure0 = structure0 {
                    metricAttributionsDecoded0?.append(structure0)
                }
            }
        }
        metricAttributions = metricAttributionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRecipesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain
        case maxResults
        case nextToken
        case recipeProvider
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = self.domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let recipeProvider = self.recipeProvider {
            try encodeContainer.encode(recipeProvider.rawValue, forKey: .recipeProvider)
        }
    }
}

extension ListRecipesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListRecipesInput: Swift.Equatable {
    /// Filters returned recipes by domain for a Domain dataset group. Only recipes (Domain dataset group use cases) for this domain are included in the response. If you don't specify a domain, all recipes are returned.
    public var domain: PersonalizeClientTypes.Domain?
    /// The maximum number of recipes to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListRecipes for getting the next set of recipes (if they exist).
    public var nextToken: Swift.String?
    /// The default is SERVICE.
    public var recipeProvider: PersonalizeClientTypes.RecipeProvider?

    public init (
        domain: PersonalizeClientTypes.Domain? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        recipeProvider: PersonalizeClientTypes.RecipeProvider? = nil
    )
    {
        self.domain = domain
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.recipeProvider = recipeProvider
    }
}

struct ListRecipesInputBody: Swift.Equatable {
    let recipeProvider: PersonalizeClientTypes.RecipeProvider?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let domain: PersonalizeClientTypes.Domain?
}

extension ListRecipesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain
        case maxResults
        case nextToken
        case recipeProvider
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recipeProviderDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.RecipeProvider.self, forKey: .recipeProvider)
        recipeProvider = recipeProviderDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let domainDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension ListRecipesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRecipesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListRecipesOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRecipesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListRecipesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.recipes = output.recipes
        } else {
            self.nextToken = nil
            self.recipes = nil
        }
    }
}

public struct ListRecipesOutputResponse: Swift.Equatable {
    /// A token for getting the next set of recipes.
    public var nextToken: Swift.String?
    /// The list of available recipes.
    public var recipes: [PersonalizeClientTypes.RecipeSummary]?

    public init (
        nextToken: Swift.String? = nil,
        recipes: [PersonalizeClientTypes.RecipeSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.recipes = recipes
    }
}

struct ListRecipesOutputResponseBody: Swift.Equatable {
    let recipes: [PersonalizeClientTypes.RecipeSummary]?
    let nextToken: Swift.String?
}

extension ListRecipesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case recipes
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recipesContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.RecipeSummary?].self, forKey: .recipes)
        var recipesDecoded0:[PersonalizeClientTypes.RecipeSummary]? = nil
        if let recipesContainer = recipesContainer {
            recipesDecoded0 = [PersonalizeClientTypes.RecipeSummary]()
            for structure0 in recipesContainer {
                if let structure0 = structure0 {
                    recipesDecoded0?.append(structure0)
                }
            }
        }
        recipes = recipesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRecommendersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListRecommendersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListRecommendersInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Domain dataset group to list the recommenders for. When a Domain dataset group is not specified, all the recommenders associated with the account are listed.
    public var datasetGroupArn: Swift.String?
    /// The maximum number of recommenders to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListRecommenders for getting the next set of recommenders (if they exist).
    public var nextToken: Swift.String?

    public init (
        datasetGroupArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRecommendersInputBody: Swift.Equatable {
    let datasetGroupArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListRecommendersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListRecommendersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRecommendersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListRecommendersOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRecommendersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListRecommendersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.recommenders = output.recommenders
        } else {
            self.nextToken = nil
            self.recommenders = nil
        }
    }
}

public struct ListRecommendersOutputResponse: Swift.Equatable {
    /// A token for getting the next set of recommenders (if they exist).
    public var nextToken: Swift.String?
    /// A list of the recommenders.
    public var recommenders: [PersonalizeClientTypes.RecommenderSummary]?

    public init (
        nextToken: Swift.String? = nil,
        recommenders: [PersonalizeClientTypes.RecommenderSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.recommenders = recommenders
    }
}

struct ListRecommendersOutputResponseBody: Swift.Equatable {
    let recommenders: [PersonalizeClientTypes.RecommenderSummary]?
    let nextToken: Swift.String?
}

extension ListRecommendersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case recommenders
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendersContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.RecommenderSummary?].self, forKey: .recommenders)
        var recommendersDecoded0:[PersonalizeClientTypes.RecommenderSummary]? = nil
        if let recommendersContainer = recommendersContainer {
            recommendersDecoded0 = [PersonalizeClientTypes.RecommenderSummary]()
            for structure0 in recommendersContainer {
                if let structure0 = structure0 {
                    recommendersDecoded0?.append(structure0)
                }
            }
        }
        recommenders = recommendersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSchemasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSchemasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSchemasInput: Swift.Equatable {
    /// The maximum number of schemas to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListSchemas for getting the next set of schemas (if they exist).
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSchemasInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListSchemasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListSchemasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSchemasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSchemasOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSchemasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSchemasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.schemas = output.schemas
        } else {
            self.nextToken = nil
            self.schemas = nil
        }
    }
}

public struct ListSchemasOutputResponse: Swift.Equatable {
    /// A token used to get the next set of schemas (if they exist).
    public var nextToken: Swift.String?
    /// A list of schemas.
    public var schemas: [PersonalizeClientTypes.DatasetSchemaSummary]?

    public init (
        nextToken: Swift.String? = nil,
        schemas: [PersonalizeClientTypes.DatasetSchemaSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemas = schemas
    }
}

struct ListSchemasOutputResponseBody: Swift.Equatable {
    let schemas: [PersonalizeClientTypes.DatasetSchemaSummary]?
    let nextToken: Swift.String?
}

extension ListSchemasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case schemas
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemasContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.DatasetSchemaSummary?].self, forKey: .schemas)
        var schemasDecoded0:[PersonalizeClientTypes.DatasetSchemaSummary]? = nil
        if let schemasContainer = schemasContainer {
            schemasDecoded0 = [PersonalizeClientTypes.DatasetSchemaSummary]()
            for structure0 in schemasContainer {
                if let structure0 = structure0 {
                    schemasDecoded0?.append(structure0)
                }
            }
        }
        schemas = schemasDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSolutionVersionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case solutionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let solutionArn = self.solutionArn {
            try encodeContainer.encode(solutionArn, forKey: .solutionArn)
        }
    }
}

extension ListSolutionVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSolutionVersionsInput: Swift.Equatable {
    /// The maximum number of solution versions to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListSolutionVersions for getting the next set of solution versions (if they exist).
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the solution.
    public var solutionArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        solutionArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.solutionArn = solutionArn
    }
}

struct ListSolutionVersionsInputBody: Swift.Equatable {
    let solutionArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListSolutionVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case solutionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionArn)
        solutionArn = solutionArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListSolutionVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSolutionVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSolutionVersionsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSolutionVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSolutionVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.solutionVersions = output.solutionVersions
        } else {
            self.nextToken = nil
            self.solutionVersions = nil
        }
    }
}

public struct ListSolutionVersionsOutputResponse: Swift.Equatable {
    /// A token for getting the next set of solution versions (if they exist).
    public var nextToken: Swift.String?
    /// A list of solution versions describing the version properties.
    public var solutionVersions: [PersonalizeClientTypes.SolutionVersionSummary]?

    public init (
        nextToken: Swift.String? = nil,
        solutionVersions: [PersonalizeClientTypes.SolutionVersionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.solutionVersions = solutionVersions
    }
}

struct ListSolutionVersionsOutputResponseBody: Swift.Equatable {
    let solutionVersions: [PersonalizeClientTypes.SolutionVersionSummary]?
    let nextToken: Swift.String?
}

extension ListSolutionVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case solutionVersions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.SolutionVersionSummary?].self, forKey: .solutionVersions)
        var solutionVersionsDecoded0:[PersonalizeClientTypes.SolutionVersionSummary]? = nil
        if let solutionVersionsContainer = solutionVersionsContainer {
            solutionVersionsDecoded0 = [PersonalizeClientTypes.SolutionVersionSummary]()
            for structure0 in solutionVersionsContainer {
                if let structure0 = structure0 {
                    solutionVersionsDecoded0?.append(structure0)
                }
            }
        }
        solutionVersions = solutionVersionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSolutionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSolutionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSolutionsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset group.
    public var datasetGroupArn: Swift.String?
    /// The maximum number of solutions to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListSolutions for getting the next set of solutions (if they exist).
    public var nextToken: Swift.String?

    public init (
        datasetGroupArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSolutionsInputBody: Swift.Equatable {
    let datasetGroupArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListSolutionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListSolutionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSolutionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSolutionsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSolutionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSolutionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.solutions = output.solutions
        } else {
            self.nextToken = nil
            self.solutions = nil
        }
    }
}

public struct ListSolutionsOutputResponse: Swift.Equatable {
    /// A token for getting the next set of solutions (if they exist).
    public var nextToken: Swift.String?
    /// A list of the current solutions.
    public var solutions: [PersonalizeClientTypes.SolutionSummary]?

    public init (
        nextToken: Swift.String? = nil,
        solutions: [PersonalizeClientTypes.SolutionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.solutions = solutions
    }
}

struct ListSolutionsOutputResponseBody: Swift.Equatable {
    let solutions: [PersonalizeClientTypes.SolutionSummary]?
    let nextToken: Swift.String?
}

extension ListSolutionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case solutions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.SolutionSummary?].self, forKey: .solutions)
        var solutionsDecoded0:[PersonalizeClientTypes.SolutionSummary]? = nil
        if let solutionsContainer = solutionsContainer {
            solutionsDecoded0 = [PersonalizeClientTypes.SolutionSummary]()
            for structure0 in solutionsContainer {
                if let structure0 = structure0 {
                    solutionsDecoded0?.append(structure0)
                }
            }
        }
        solutions = solutionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The resource's Amazon Resource Name.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The resource's tags.
    public var tags: [PersonalizeClientTypes.Tag]?

    public init (
        tags: [PersonalizeClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [PersonalizeClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PersonalizeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PersonalizeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PersonalizeClientTypes.MetricAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventType
        case expression
        case metricName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventType = self.eventType {
            try encodeContainer.encode(eventType, forKey: .eventType)
        }
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let metricName = self.metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
    }
}

extension PersonalizeClientTypes {
    /// Contains information on a metric that a metric attribution reports on. For more information, see [Measuring impact of recommendations](https://docs.aws.amazon.com/personalize/latest/dg/measuring-recommendation-impact.html).
    public struct MetricAttribute: Swift.Equatable {
        /// The metric's event type.
        /// This member is required.
        public var eventType: Swift.String?
        /// The attribute's expression. Available functions are SUM() or SAMPLECOUNT(). For SUM() functions, provide the dataset type (either Interactions or Items) and column to sum as a parameter. For example SUM(Items.PRICE).
        /// This member is required.
        public var expression: Swift.String?
        /// The metric's name. The name helps you identify the metric in Amazon CloudWatch or Amazon S3.
        /// This member is required.
        public var metricName: Swift.String?

        public init (
            eventType: Swift.String? = nil,
            expression: Swift.String? = nil,
            metricName: Swift.String? = nil
        )
        {
            self.eventType = eventType
            self.expression = expression
            self.metricName = metricName
        }
    }

}

extension PersonalizeClientTypes.MetricAttribution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case datasetGroupArn
        case failureReason
        case lastUpdatedDateTime
        case metricAttributionArn
        case metricsOutputConfig
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let metricAttributionArn = self.metricAttributionArn {
            try encodeContainer.encode(metricAttributionArn, forKey: .metricAttributionArn)
        }
        if let metricsOutputConfig = self.metricsOutputConfig {
            try encodeContainer.encode(metricsOutputConfig, forKey: .metricsOutputConfig)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metricAttributionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricAttributionArn)
        metricAttributionArn = metricAttributionArnDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let metricsOutputConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.MetricAttributionOutput.self, forKey: .metricsOutputConfig)
        metricsOutputConfig = metricsOutputConfigDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension PersonalizeClientTypes {
    /// Contains information on a metric attribution. A metric attribution creates reports on the data that you import into Amazon Personalize. Depending on how you import the data, you can view reports in Amazon CloudWatch or Amazon S3. For more information, see [Measuring impact of recommendations](https://docs.aws.amazon.com/personalize/latest/dg/measuring-recommendation-impact.html).
    public struct MetricAttribution: Swift.Equatable {
        /// The metric attribution's creation date time.
        public var creationDateTime: ClientRuntime.Date?
        /// The metric attribution's dataset group Amazon Resource Name (ARN).
        public var datasetGroupArn: Swift.String?
        /// The metric attribution's failure reason.
        public var failureReason: Swift.String?
        /// The metric attribution's last updated date time.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The metric attribution's Amazon Resource Name (ARN).
        public var metricAttributionArn: Swift.String?
        /// The metric attribution's output configuration.
        public var metricsOutputConfig: PersonalizeClientTypes.MetricAttributionOutput?
        /// The metric attribution's name.
        public var name: Swift.String?
        /// The metric attribution's status.
        public var status: Swift.String?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            metricAttributionArn: Swift.String? = nil,
            metricsOutputConfig: PersonalizeClientTypes.MetricAttributionOutput? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.metricAttributionArn = metricAttributionArn
            self.metricsOutputConfig = metricsOutputConfig
            self.name = name
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.MetricAttributionOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn
        case s3DataDestination
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let s3DataDestination = self.s3DataDestination {
            try encodeContainer.encode(s3DataDestination, forKey: .s3DataDestination)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3DataDestinationDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.S3DataConfig.self, forKey: .s3DataDestination)
        s3DataDestination = s3DataDestinationDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension PersonalizeClientTypes {
    /// The output configuration details for a metric attribution.
    public struct MetricAttributionOutput: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the IAM service role that has permissions to add data to your output Amazon S3 bucket and add metrics to Amazon CloudWatch. For more information, see [Measuring impact of recommendations](https://docs.aws.amazon.com/personalize/latest/dg/measuring-recommendation-impact.html).
        /// This member is required.
        public var roleArn: Swift.String?
        /// The configuration details of an Amazon S3 input or output bucket.
        public var s3DataDestination: PersonalizeClientTypes.S3DataConfig?

        public init (
            roleArn: Swift.String? = nil,
            s3DataDestination: PersonalizeClientTypes.S3DataConfig? = nil
        )
        {
            self.roleArn = roleArn
            self.s3DataDestination = s3DataDestination
        }
    }

}

extension PersonalizeClientTypes.MetricAttributionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case failureReason
        case lastUpdatedDateTime
        case metricAttributionArn
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let metricAttributionArn = self.metricAttributionArn {
            try encodeContainer.encode(metricAttributionArn, forKey: .metricAttributionArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metricAttributionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricAttributionArn)
        metricAttributionArn = metricAttributionArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides a summary of the properties of a metric attribution. For a complete listing, call the [DescribeMetricAttribution](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeMetricAttribution.html).
    public struct MetricAttributionSummary: Swift.Equatable {
        /// The metric attribution's creation date time.
        public var creationDateTime: ClientRuntime.Date?
        /// The metric attribution's failure reason.
        public var failureReason: Swift.String?
        /// The metric attribution's last updated date time.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The metric attribution's Amazon Resource Name (ARN).
        public var metricAttributionArn: Swift.String?
        /// The name of the metric attribution.
        public var name: Swift.String?
        /// The metric attribution's status.
        public var status: Swift.String?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            metricAttributionArn: Swift.String? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.metricAttributionArn = metricAttributionArn
            self.name = name
            self.status = status
        }
    }

}

extension PersonalizeClientTypes {
    public enum ObjectiveSensitivity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case low
        case medium
        case off
        case sdkUnknown(Swift.String)

        public static var allCases: [ObjectiveSensitivity] {
            return [
                .high,
                .low,
                .medium,
                .off,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case .off: return "OFF"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ObjectiveSensitivity(rawValue: rawValue) ?? ObjectiveSensitivity.sdkUnknown(rawValue)
        }
    }
}

extension PersonalizeClientTypes.OptimizationObjective: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case itemAttribute
        case objectiveSensitivity
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let itemAttribute = self.itemAttribute {
            try encodeContainer.encode(itemAttribute, forKey: .itemAttribute)
        }
        if let objectiveSensitivity = self.objectiveSensitivity {
            try encodeContainer.encode(objectiveSensitivity.rawValue, forKey: .objectiveSensitivity)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemAttributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .itemAttribute)
        itemAttribute = itemAttributeDecoded
        let objectiveSensitivityDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.ObjectiveSensitivity.self, forKey: .objectiveSensitivity)
        objectiveSensitivity = objectiveSensitivityDecoded
    }
}

extension PersonalizeClientTypes {
    /// Describes the additional objective for the solution, such as maximizing streaming minutes or increasing revenue. For more information see [Optimizing a solution](https://docs.aws.amazon.com/personalize/latest/dg/optimizing-solution-for-objective.html).
    public struct OptimizationObjective: Swift.Equatable {
        /// The numerical metadata column in an Items dataset related to the optimization objective. For example, VIDEO_LENGTH (to maximize streaming minutes), or PRICE (to maximize revenue).
        public var itemAttribute: Swift.String?
        /// Specifies how Amazon Personalize balances the importance of your optimization objective versus relevance.
        public var objectiveSensitivity: PersonalizeClientTypes.ObjectiveSensitivity?

        public init (
            itemAttribute: Swift.String? = nil,
            objectiveSensitivity: PersonalizeClientTypes.ObjectiveSensitivity? = nil
        )
        {
            self.itemAttribute = itemAttribute
            self.objectiveSensitivity = objectiveSensitivity
        }
    }

}

extension PersonalizeClientTypes.Recipe: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmArn
        case creationDateTime
        case description
        case featureTransformationArn
        case lastUpdatedDateTime
        case name
        case recipeArn
        case recipeType
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmArn = self.algorithmArn {
            try encodeContainer.encode(algorithmArn, forKey: .algorithmArn)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let featureTransformationArn = self.featureTransformationArn {
            try encodeContainer.encode(featureTransformationArn, forKey: .featureTransformationArn)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recipeArn = self.recipeArn {
            try encodeContainer.encode(recipeArn, forKey: .recipeArn)
        }
        if let recipeType = self.recipeType {
            try encodeContainer.encode(recipeType, forKey: .recipeType)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let recipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipeArn)
        recipeArn = recipeArnDecoded
        let algorithmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .algorithmArn)
        algorithmArn = algorithmArnDecoded
        let featureTransformationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .featureTransformationArn)
        featureTransformationArn = featureTransformationArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let recipeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipeType)
        recipeType = recipeTypeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides information about a recipe. Each recipe provides an algorithm that Amazon Personalize uses in model training when you use the [CreateSolution](https://docs.aws.amazon.com/personalize/latest/dg/API_CreateSolution.html) operation.
    public struct Recipe: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the algorithm that Amazon Personalize uses to train the model.
        public var algorithmArn: Swift.String?
        /// The date and time (in Unix format) that the recipe was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The description of the recipe.
        public var description: Swift.String?
        /// The ARN of the FeatureTransformation object.
        public var featureTransformationArn: Swift.String?
        /// The date and time (in Unix format) that the recipe was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the recipe.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the recipe.
        public var recipeArn: Swift.String?
        /// One of the following values:
        ///
        /// * PERSONALIZED_RANKING
        ///
        /// * RELATED_ITEMS
        ///
        /// * USER_PERSONALIZATION
        public var recipeType: Swift.String?
        /// The status of the recipe.
        public var status: Swift.String?

        public init (
            algorithmArn: Swift.String? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            featureTransformationArn: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            recipeArn: Swift.String? = nil,
            recipeType: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.algorithmArn = algorithmArn
            self.creationDateTime = creationDateTime
            self.description = description
            self.featureTransformationArn = featureTransformationArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.recipeArn = recipeArn
            self.recipeType = recipeType
            self.status = status
        }
    }

}

extension PersonalizeClientTypes {
    public enum RecipeProvider: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case service
        case sdkUnknown(Swift.String)

        public static var allCases: [RecipeProvider] {
            return [
                .service,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .service: return "SERVICE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecipeProvider(rawValue: rawValue) ?? RecipeProvider.sdkUnknown(rawValue)
        }
    }
}

extension PersonalizeClientTypes.RecipeSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case domain
        case lastUpdatedDateTime
        case name
        case recipeArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let domain = self.domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recipeArn = self.recipeArn {
            try encodeContainer.encode(recipeArn, forKey: .recipeArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let recipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipeArn)
        recipeArn = recipeArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let domainDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides a summary of the properties of a recipe. For a complete listing, call the [DescribeRecipe](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeRecipe.html) API.
    public struct RecipeSummary: Swift.Equatable {
        /// The date and time (in Unix time) that the recipe was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The domain of the recipe (if the recipe is a Domain dataset group use case).
        public var domain: PersonalizeClientTypes.Domain?
        /// The date and time (in Unix time) that the recipe was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the recipe.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the recipe.
        public var recipeArn: Swift.String?
        /// The status of the recipe.
        public var status: Swift.String?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            domain: PersonalizeClientTypes.Domain? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            recipeArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.domain = domain
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.recipeArn = recipeArn
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.Recommender: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case datasetGroupArn
        case failureReason
        case lastUpdatedDateTime
        case latestRecommenderUpdate
        case modelMetrics
        case name
        case recipeArn
        case recommenderArn
        case recommenderConfig
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let latestRecommenderUpdate = self.latestRecommenderUpdate {
            try encodeContainer.encode(latestRecommenderUpdate, forKey: .latestRecommenderUpdate)
        }
        if let modelMetrics = modelMetrics {
            var modelMetricsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .modelMetrics)
            for (dictKey0, metrics0) in modelMetrics {
                try modelMetricsContainer.encode(metrics0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recipeArn = self.recipeArn {
            try encodeContainer.encode(recipeArn, forKey: .recipeArn)
        }
        if let recommenderArn = self.recommenderArn {
            try encodeContainer.encode(recommenderArn, forKey: .recommenderArn)
        }
        if let recommenderConfig = self.recommenderConfig {
            try encodeContainer.encode(recommenderConfig, forKey: .recommenderConfig)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommenderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommenderArn)
        recommenderArn = recommenderArnDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let recipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipeArn)
        recipeArn = recipeArnDecoded
        let recommenderConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.RecommenderConfig.self, forKey: .recommenderConfig)
        recommenderConfig = recommenderConfigDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let latestRecommenderUpdateDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.RecommenderUpdateSummary.self, forKey: .latestRecommenderUpdate)
        latestRecommenderUpdate = latestRecommenderUpdateDecoded
        let modelMetricsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Double?].self, forKey: .modelMetrics)
        var modelMetricsDecoded0: [Swift.String:Swift.Double]? = nil
        if let modelMetricsContainer = modelMetricsContainer {
            modelMetricsDecoded0 = [Swift.String:Swift.Double]()
            for (key0, metricvalue0) in modelMetricsContainer {
                if let metricvalue0 = metricvalue0 {
                    modelMetricsDecoded0?[key0] = metricvalue0
                }
            }
        }
        modelMetrics = modelMetricsDecoded0
    }
}

extension PersonalizeClientTypes {
    /// Describes a recommendation generator for a Domain dataset group. You create a recommender in a Domain dataset group for a specific domain use case (domain recipe), and specify the recommender in a [GetRecommendations](https://docs.aws.amazon.com/personalize/latest/dg/API_RS_GetRecommendations.html) request.
    public struct Recommender: Swift.Equatable {
        /// The date and time (in Unix format) that the recommender was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the Domain dataset group that contains the recommender.
        public var datasetGroupArn: Swift.String?
        /// If a recommender fails, the reason behind the failure.
        public var failureReason: Swift.String?
        /// The date and time (in Unix format) that the recommender was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// Provides a summary of the latest updates to the recommender.
        public var latestRecommenderUpdate: PersonalizeClientTypes.RecommenderUpdateSummary?
        /// Provides evaluation metrics that help you determine the performance of a recommender. For more information, see [ Evaluating a recommender](https://docs.aws.amazon.com/personalize/latest/dg/evaluating-recommenders.html).
        public var modelMetrics: [Swift.String:Swift.Double]?
        /// The name of the recommender.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the recipe (Domain dataset group use case) that the recommender was created for.
        public var recipeArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the recommender.
        public var recommenderArn: Swift.String?
        /// The configuration details of the recommender.
        public var recommenderConfig: PersonalizeClientTypes.RecommenderConfig?
        /// The status of the recommender. A recommender can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        /// * STOP PENDING > STOP IN_PROGRESS > INACTIVE > START PENDING > START IN_PROGRESS > ACTIVE
        ///
        /// * DELETE PENDING > DELETE IN_PROGRESS
        public var status: Swift.String?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            latestRecommenderUpdate: PersonalizeClientTypes.RecommenderUpdateSummary? = nil,
            modelMetrics: [Swift.String:Swift.Double]? = nil,
            name: Swift.String? = nil,
            recipeArn: Swift.String? = nil,
            recommenderArn: Swift.String? = nil,
            recommenderConfig: PersonalizeClientTypes.RecommenderConfig? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.latestRecommenderUpdate = latestRecommenderUpdate
            self.modelMetrics = modelMetrics
            self.name = name
            self.recipeArn = recipeArn
            self.recommenderArn = recommenderArn
            self.recommenderConfig = recommenderConfig
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.RecommenderConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case itemExplorationConfig
        case minRecommendationRequestsPerSecond
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let itemExplorationConfig = itemExplorationConfig {
            var itemExplorationConfigContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .itemExplorationConfig)
            for (dictKey0, hyperParameters0) in itemExplorationConfig {
                try itemExplorationConfigContainer.encode(hyperParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let minRecommendationRequestsPerSecond = self.minRecommendationRequestsPerSecond {
            try encodeContainer.encode(minRecommendationRequestsPerSecond, forKey: .minRecommendationRequestsPerSecond)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemExplorationConfigContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .itemExplorationConfig)
        var itemExplorationConfigDecoded0: [Swift.String:Swift.String]? = nil
        if let itemExplorationConfigContainer = itemExplorationConfigContainer {
            itemExplorationConfigDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in itemExplorationConfigContainer {
                if let parametervalue0 = parametervalue0 {
                    itemExplorationConfigDecoded0?[key0] = parametervalue0
                }
            }
        }
        itemExplorationConfig = itemExplorationConfigDecoded0
        let minRecommendationRequestsPerSecondDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minRecommendationRequestsPerSecond)
        minRecommendationRequestsPerSecond = minRecommendationRequestsPerSecondDecoded
    }
}

extension PersonalizeClientTypes {
    /// The configuration details of the recommender.
    public struct RecommenderConfig: Swift.Equatable {
        /// Specifies the exploration configuration hyperparameters, including explorationWeight and explorationItemAgeCutOff, you want to use to configure the amount of item exploration Amazon Personalize uses when recommending items. Provide itemExplorationConfig data only if your recommenders generate personalized recommendations for a user (not popular items or similar items).
        public var itemExplorationConfig: [Swift.String:Swift.String]?
        /// Specifies the requested minimum provisioned recommendation requests per second that Amazon Personalize will support.
        public var minRecommendationRequestsPerSecond: Swift.Int?

        public init (
            itemExplorationConfig: [Swift.String:Swift.String]? = nil,
            minRecommendationRequestsPerSecond: Swift.Int? = nil
        )
        {
            self.itemExplorationConfig = itemExplorationConfig
            self.minRecommendationRequestsPerSecond = minRecommendationRequestsPerSecond
        }
    }

}

extension PersonalizeClientTypes.RecommenderSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case datasetGroupArn
        case lastUpdatedDateTime
        case name
        case recipeArn
        case recommenderArn
        case recommenderConfig
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recipeArn = self.recipeArn {
            try encodeContainer.encode(recipeArn, forKey: .recipeArn)
        }
        if let recommenderArn = self.recommenderArn {
            try encodeContainer.encode(recommenderArn, forKey: .recommenderArn)
        }
        if let recommenderConfig = self.recommenderConfig {
            try encodeContainer.encode(recommenderConfig, forKey: .recommenderConfig)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let recommenderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommenderArn)
        recommenderArn = recommenderArnDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let recipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipeArn)
        recipeArn = recipeArnDecoded
        let recommenderConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.RecommenderConfig.self, forKey: .recommenderConfig)
        recommenderConfig = recommenderConfigDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides a summary of the properties of the recommender.
    public struct RecommenderSummary: Swift.Equatable {
        /// The date and time (in Unix format) that the recommender was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the Domain dataset group that contains the recommender.
        public var datasetGroupArn: Swift.String?
        /// The date and time (in Unix format) that the recommender was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the recommender.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the recipe (Domain dataset group use case) that the recommender was created for.
        public var recipeArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the recommender.
        public var recommenderArn: Swift.String?
        /// The configuration details of the recommender.
        public var recommenderConfig: PersonalizeClientTypes.RecommenderConfig?
        /// The status of the recommender. A recommender can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        /// * STOP PENDING > STOP IN_PROGRESS > INACTIVE > START PENDING > START IN_PROGRESS > ACTIVE
        ///
        /// * DELETE PENDING > DELETE IN_PROGRESS
        public var status: Swift.String?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            recipeArn: Swift.String? = nil,
            recommenderArn: Swift.String? = nil,
            recommenderConfig: PersonalizeClientTypes.RecommenderConfig? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.recipeArn = recipeArn
            self.recommenderArn = recommenderArn
            self.recommenderConfig = recommenderConfig
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.RecommenderUpdateSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case failureReason
        case lastUpdatedDateTime
        case recommenderConfig
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let recommenderConfig = self.recommenderConfig {
            try encodeContainer.encode(recommenderConfig, forKey: .recommenderConfig)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommenderConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.RecommenderConfig.self, forKey: .recommenderConfig)
        recommenderConfig = recommenderConfigDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides a summary of the properties of a recommender update. For a complete listing, call the [DescribeRecommender](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeRecommender.html) API.
    public struct RecommenderUpdateSummary: Swift.Equatable {
        /// The date and time (in Unix format) that the recommender update was created.
        public var creationDateTime: ClientRuntime.Date?
        /// If a recommender update fails, the reason behind the failure.
        public var failureReason: Swift.String?
        /// The date and time (in Unix time) that the recommender update was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The configuration details of the recommender update.
        public var recommenderConfig: PersonalizeClientTypes.RecommenderConfig?
        /// The status of the recommender update. A recommender can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        /// * STOP PENDING > STOP IN_PROGRESS > INACTIVE > START PENDING > START IN_PROGRESS > ACTIVE
        ///
        /// * DELETE PENDING > DELETE IN_PROGRESS
        public var status: Swift.String?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            recommenderConfig: PersonalizeClientTypes.RecommenderConfig? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.recommenderConfig = recommenderConfig
            self.status = status
        }
    }

}

extension ResourceAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource already exists.
public struct ResourceAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource is in use.
public struct ResourceInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Could not find the specified resource.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PersonalizeClientTypes.S3DataConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyArn
        case path
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension PersonalizeClientTypes {
    /// The configuration details of an Amazon S3 input or output bucket.
    public struct S3DataConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Key Management Service (KMS) key that Amazon Personalize uses to encrypt or decrypt the input and output files.
        public var kmsKeyArn: Swift.String?
        /// The file path of the Amazon S3 bucket.
        /// This member is required.
        public var path: Swift.String?

        public init (
            kmsKeyArn: Swift.String? = nil,
            path: Swift.String? = nil
        )
        {
            self.kmsKeyArn = kmsKeyArn
            self.path = path
        }
    }

}

extension PersonalizeClientTypes.Solution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoMLResult
        case creationDateTime
        case datasetGroupArn
        case eventType
        case lastUpdatedDateTime
        case latestSolutionVersion
        case name
        case performAutoML
        case performHPO
        case recipeArn
        case solutionArn
        case solutionConfig
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoMLResult = self.autoMLResult {
            try encodeContainer.encode(autoMLResult, forKey: .autoMLResult)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let eventType = self.eventType {
            try encodeContainer.encode(eventType, forKey: .eventType)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let latestSolutionVersion = self.latestSolutionVersion {
            try encodeContainer.encode(latestSolutionVersion, forKey: .latestSolutionVersion)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if performAutoML != false {
            try encodeContainer.encode(performAutoML, forKey: .performAutoML)
        }
        if performHPO != false {
            try encodeContainer.encode(performHPO, forKey: .performHPO)
        }
        if let recipeArn = self.recipeArn {
            try encodeContainer.encode(recipeArn, forKey: .recipeArn)
        }
        if let solutionArn = self.solutionArn {
            try encodeContainer.encode(solutionArn, forKey: .solutionArn)
        }
        if let solutionConfig = self.solutionConfig {
            try encodeContainer.encode(solutionConfig, forKey: .solutionConfig)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let solutionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionArn)
        solutionArn = solutionArnDecoded
        let performHPODecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .performHPO) ?? false
        performHPO = performHPODecoded
        let performAutoMLDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .performAutoML) ?? false
        performAutoML = performAutoMLDecoded
        let recipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipeArn)
        recipeArn = recipeArnDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let solutionConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.SolutionConfig.self, forKey: .solutionConfig)
        solutionConfig = solutionConfigDecoded
        let autoMLResultDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.AutoMLResult.self, forKey: .autoMLResult)
        autoMLResult = autoMLResultDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let latestSolutionVersionDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.SolutionVersionSummary.self, forKey: .latestSolutionVersion)
        latestSolutionVersion = latestSolutionVersionDecoded
    }
}

extension PersonalizeClientTypes {
    /// An object that provides information about a solution. A solution is a trained model that can be deployed as a campaign.
    public struct Solution: Swift.Equatable {
        /// When performAutoML is true, specifies the best recipe found.
        public var autoMLResult: PersonalizeClientTypes.AutoMLResult?
        /// The creation date and time (in Unix time) of the solution.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset group that provides the training data.
        public var datasetGroupArn: Swift.String?
        /// The event type (for example, 'click' or 'like') that is used for training the model. If no eventType is provided, Amazon Personalize uses all interactions for training with equal weight regardless of type.
        public var eventType: Swift.String?
        /// The date and time (in Unix time) that the solution was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// Describes the latest version of the solution, including the status and the ARN.
        public var latestSolutionVersion: PersonalizeClientTypes.SolutionVersionSummary?
        /// The name of the solution.
        public var name: Swift.String?
        /// When true, Amazon Personalize performs a search for the best USER_PERSONALIZATION recipe from the list specified in the solution configuration (recipeArn must not be specified). When false (the default), Amazon Personalize uses recipeArn for training.
        public var performAutoML: Swift.Bool
        /// Whether to perform hyperparameter optimization (HPO) on the chosen recipe. The default is false.
        public var performHPO: Swift.Bool
        /// The ARN of the recipe used to create the solution.
        public var recipeArn: Swift.String?
        /// The ARN of the solution.
        public var solutionArn: Swift.String?
        /// Describes the configuration properties for the solution.
        public var solutionConfig: PersonalizeClientTypes.SolutionConfig?
        /// The status of the solution. A solution can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        /// * DELETE PENDING > DELETE IN_PROGRESS
        public var status: Swift.String?

        public init (
            autoMLResult: PersonalizeClientTypes.AutoMLResult? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            eventType: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            latestSolutionVersion: PersonalizeClientTypes.SolutionVersionSummary? = nil,
            name: Swift.String? = nil,
            performAutoML: Swift.Bool = false,
            performHPO: Swift.Bool = false,
            recipeArn: Swift.String? = nil,
            solutionArn: Swift.String? = nil,
            solutionConfig: PersonalizeClientTypes.SolutionConfig? = nil,
            status: Swift.String? = nil
        )
        {
            self.autoMLResult = autoMLResult
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.eventType = eventType
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.latestSolutionVersion = latestSolutionVersion
            self.name = name
            self.performAutoML = performAutoML
            self.performHPO = performHPO
            self.recipeArn = recipeArn
            self.solutionArn = solutionArn
            self.solutionConfig = solutionConfig
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.SolutionConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmHyperParameters
        case autoMLConfig
        case eventValueThreshold
        case featureTransformationParameters
        case hpoConfig
        case optimizationObjective
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmHyperParameters = algorithmHyperParameters {
            var algorithmHyperParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .algorithmHyperParameters)
            for (dictKey0, hyperParameters0) in algorithmHyperParameters {
                try algorithmHyperParametersContainer.encode(hyperParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let autoMLConfig = self.autoMLConfig {
            try encodeContainer.encode(autoMLConfig, forKey: .autoMLConfig)
        }
        if let eventValueThreshold = self.eventValueThreshold {
            try encodeContainer.encode(eventValueThreshold, forKey: .eventValueThreshold)
        }
        if let featureTransformationParameters = featureTransformationParameters {
            var featureTransformationParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .featureTransformationParameters)
            for (dictKey0, featureTransformationParameters0) in featureTransformationParameters {
                try featureTransformationParametersContainer.encode(featureTransformationParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let hpoConfig = self.hpoConfig {
            try encodeContainer.encode(hpoConfig, forKey: .hpoConfig)
        }
        if let optimizationObjective = self.optimizationObjective {
            try encodeContainer.encode(optimizationObjective, forKey: .optimizationObjective)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventValueThresholdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventValueThreshold)
        eventValueThreshold = eventValueThresholdDecoded
        let hpoConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.HPOConfig.self, forKey: .hpoConfig)
        hpoConfig = hpoConfigDecoded
        let algorithmHyperParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .algorithmHyperParameters)
        var algorithmHyperParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let algorithmHyperParametersContainer = algorithmHyperParametersContainer {
            algorithmHyperParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in algorithmHyperParametersContainer {
                if let parametervalue0 = parametervalue0 {
                    algorithmHyperParametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        algorithmHyperParameters = algorithmHyperParametersDecoded0
        let featureTransformationParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .featureTransformationParameters)
        var featureTransformationParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let featureTransformationParametersContainer = featureTransformationParametersContainer {
            featureTransformationParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in featureTransformationParametersContainer {
                if let parametervalue0 = parametervalue0 {
                    featureTransformationParametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        featureTransformationParameters = featureTransformationParametersDecoded0
        let autoMLConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.AutoMLConfig.self, forKey: .autoMLConfig)
        autoMLConfig = autoMLConfigDecoded
        let optimizationObjectiveDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.OptimizationObjective.self, forKey: .optimizationObjective)
        optimizationObjective = optimizationObjectiveDecoded
    }
}

extension PersonalizeClientTypes {
    /// Describes the configuration properties for the solution.
    public struct SolutionConfig: Swift.Equatable {
        /// Lists the hyperparameter names and ranges.
        public var algorithmHyperParameters: [Swift.String:Swift.String]?
        /// The [AutoMLConfig](https://docs.aws.amazon.com/personalize/latest/dg/API_AutoMLConfig.html) object containing a list of recipes to search when AutoML is performed.
        public var autoMLConfig: PersonalizeClientTypes.AutoMLConfig?
        /// Only events with a value greater than or equal to this threshold are used for training a model.
        public var eventValueThreshold: Swift.String?
        /// Lists the feature transformation parameters.
        public var featureTransformationParameters: [Swift.String:Swift.String]?
        /// Describes the properties for hyperparameter optimization (HPO).
        public var hpoConfig: PersonalizeClientTypes.HPOConfig?
        /// Describes the additional objective for the solution, such as maximizing streaming minutes or increasing revenue. For more information see [Optimizing a solution](https://docs.aws.amazon.com/personalize/latest/dg/optimizing-solution-for-objective.html).
        public var optimizationObjective: PersonalizeClientTypes.OptimizationObjective?

        public init (
            algorithmHyperParameters: [Swift.String:Swift.String]? = nil,
            autoMLConfig: PersonalizeClientTypes.AutoMLConfig? = nil,
            eventValueThreshold: Swift.String? = nil,
            featureTransformationParameters: [Swift.String:Swift.String]? = nil,
            hpoConfig: PersonalizeClientTypes.HPOConfig? = nil,
            optimizationObjective: PersonalizeClientTypes.OptimizationObjective? = nil
        )
        {
            self.algorithmHyperParameters = algorithmHyperParameters
            self.autoMLConfig = autoMLConfig
            self.eventValueThreshold = eventValueThreshold
            self.featureTransformationParameters = featureTransformationParameters
            self.hpoConfig = hpoConfig
            self.optimizationObjective = optimizationObjective
        }
    }

}

extension PersonalizeClientTypes.SolutionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case lastUpdatedDateTime
        case name
        case recipeArn
        case solutionArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recipeArn = self.recipeArn {
            try encodeContainer.encode(recipeArn, forKey: .recipeArn)
        }
        if let solutionArn = self.solutionArn {
            try encodeContainer.encode(solutionArn, forKey: .solutionArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let solutionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionArn)
        solutionArn = solutionArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let recipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipeArn)
        recipeArn = recipeArnDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides a summary of the properties of a solution. For a complete listing, call the [DescribeSolution](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeSolution.html) API.
    public struct SolutionSummary: Swift.Equatable {
        /// The date and time (in Unix time) that the solution was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The date and time (in Unix time) that the solution was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the solution.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the recipe used by the solution.
        public var recipeArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the solution.
        public var solutionArn: Swift.String?
        /// The status of the solution. A solution can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        /// * DELETE PENDING > DELETE IN_PROGRESS
        public var status: Swift.String?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            recipeArn: Swift.String? = nil,
            solutionArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.recipeArn = recipeArn
            self.solutionArn = solutionArn
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.SolutionVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case datasetGroupArn
        case eventType
        case failureReason
        case lastUpdatedDateTime
        case name
        case performAutoML
        case performHPO
        case recipeArn
        case solutionArn
        case solutionConfig
        case solutionVersionArn
        case status
        case trainingHours
        case trainingMode
        case tunedHPOParams
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let eventType = self.eventType {
            try encodeContainer.encode(eventType, forKey: .eventType)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if performAutoML != false {
            try encodeContainer.encode(performAutoML, forKey: .performAutoML)
        }
        if performHPO != false {
            try encodeContainer.encode(performHPO, forKey: .performHPO)
        }
        if let recipeArn = self.recipeArn {
            try encodeContainer.encode(recipeArn, forKey: .recipeArn)
        }
        if let solutionArn = self.solutionArn {
            try encodeContainer.encode(solutionArn, forKey: .solutionArn)
        }
        if let solutionConfig = self.solutionConfig {
            try encodeContainer.encode(solutionConfig, forKey: .solutionConfig)
        }
        if let solutionVersionArn = self.solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let trainingHours = self.trainingHours {
            try encodeContainer.encode(trainingHours, forKey: .trainingHours)
        }
        if let trainingMode = self.trainingMode {
            try encodeContainer.encode(trainingMode.rawValue, forKey: .trainingMode)
        }
        if let tunedHPOParams = self.tunedHPOParams {
            try encodeContainer.encode(tunedHPOParams, forKey: .tunedHPOParams)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let solutionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionArn)
        solutionArn = solutionArnDecoded
        let performHPODecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .performHPO) ?? false
        performHPO = performHPODecoded
        let performAutoMLDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .performAutoML) ?? false
        performAutoML = performAutoMLDecoded
        let recipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipeArn)
        recipeArn = recipeArnDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let solutionConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.SolutionConfig.self, forKey: .solutionConfig)
        solutionConfig = solutionConfigDecoded
        let trainingHoursDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .trainingHours)
        trainingHours = trainingHoursDecoded
        let trainingModeDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.TrainingMode.self, forKey: .trainingMode)
        trainingMode = trainingModeDecoded
        let tunedHPOParamsDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.TunedHPOParams.self, forKey: .tunedHPOParams)
        tunedHPOParams = tunedHPOParamsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension PersonalizeClientTypes {
    /// An object that provides information about a specific version of a [Solution](https://docs.aws.amazon.com/personalize/latest/dg/API_Solution.html) in a Custom dataset group.
    public struct SolutionVersion: Swift.Equatable {
        /// The date and time (in Unix time) that this version of the solution was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset group providing the training data.
        public var datasetGroupArn: Swift.String?
        /// The event type (for example, 'click' or 'like') that is used for training the model.
        public var eventType: Swift.String?
        /// If training a solution version fails, the reason for the failure.
        public var failureReason: Swift.String?
        /// The date and time (in Unix time) that the solution was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the solution version.
        public var name: Swift.String?
        /// When true, Amazon Personalize searches for the most optimal recipe according to the solution configuration. When false (the default), Amazon Personalize uses recipeArn.
        public var performAutoML: Swift.Bool
        /// Whether to perform hyperparameter optimization (HPO) on the chosen recipe. The default is false.
        public var performHPO: Swift.Bool
        /// The ARN of the recipe used in the solution.
        public var recipeArn: Swift.String?
        /// The ARN of the solution.
        public var solutionArn: Swift.String?
        /// Describes the configuration properties for the solution.
        public var solutionConfig: PersonalizeClientTypes.SolutionConfig?
        /// The ARN of the solution version.
        public var solutionVersionArn: Swift.String?
        /// The status of the solution version. A solution version can be in one of the following states:
        ///
        /// * CREATE PENDING
        ///
        /// * CREATE IN_PROGRESS
        ///
        /// * ACTIVE
        ///
        /// * CREATE FAILED
        ///
        /// * CREATE STOPPING
        ///
        /// * CREATE STOPPED
        public var status: Swift.String?
        /// The time used to train the model. You are billed for the time it takes to train a model. This field is visible only after Amazon Personalize successfully trains a model.
        public var trainingHours: Swift.Double?
        /// The scope of training to be performed when creating the solution version. The FULL option trains the solution version based on the entirety of the input solution's training data, while the UPDATE option processes only the data that has changed in comparison to the input solution. Choose UPDATE when you want to incrementally update your solution version instead of creating an entirely new one. The UPDATE option can only be used when you already have an active solution version created from the input solution using the FULL option and the input solution was trained with the [User-Personalization](https://docs.aws.amazon.com/personalize/latest/dg/native-recipe-new-item-USER_PERSONALIZATION.html) recipe or the [HRNN-Coldstart](https://docs.aws.amazon.com/personalize/latest/dg/native-recipe-hrnn-coldstart.html) recipe.
        public var trainingMode: PersonalizeClientTypes.TrainingMode?
        /// If hyperparameter optimization was performed, contains the hyperparameter values of the best performing model.
        public var tunedHPOParams: PersonalizeClientTypes.TunedHPOParams?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            eventType: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            performAutoML: Swift.Bool = false,
            performHPO: Swift.Bool = false,
            recipeArn: Swift.String? = nil,
            solutionArn: Swift.String? = nil,
            solutionConfig: PersonalizeClientTypes.SolutionConfig? = nil,
            solutionVersionArn: Swift.String? = nil,
            status: Swift.String? = nil,
            trainingHours: Swift.Double? = nil,
            trainingMode: PersonalizeClientTypes.TrainingMode? = nil,
            tunedHPOParams: PersonalizeClientTypes.TunedHPOParams? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.eventType = eventType
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.performAutoML = performAutoML
            self.performHPO = performHPO
            self.recipeArn = recipeArn
            self.solutionArn = solutionArn
            self.solutionConfig = solutionConfig
            self.solutionVersionArn = solutionVersionArn
            self.status = status
            self.trainingHours = trainingHours
            self.trainingMode = trainingMode
            self.tunedHPOParams = tunedHPOParams
        }
    }

}

extension PersonalizeClientTypes.SolutionVersionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case failureReason
        case lastUpdatedDateTime
        case solutionVersionArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let solutionVersionArn = self.solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides a summary of the properties of a solution version. For a complete listing, call the [DescribeSolutionVersion](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeSolutionVersion.html) API.
    public struct SolutionVersionSummary: Swift.Equatable {
        /// The date and time (in Unix time) that this version of a solution was created.
        public var creationDateTime: ClientRuntime.Date?
        /// If a solution version fails, the reason behind the failure.
        public var failureReason: Swift.String?
        /// The date and time (in Unix time) that the solution version was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the solution version.
        public var solutionVersionArn: Swift.String?
        /// The status of the solution version. A solution version can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        public var status: Swift.String?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            solutionVersionArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }
    }

}

extension StartRecommenderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommenderArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recommenderArn = self.recommenderArn {
            try encodeContainer.encode(recommenderArn, forKey: .recommenderArn)
        }
    }
}

extension StartRecommenderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartRecommenderInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the recommender to start.
    /// This member is required.
    public var recommenderArn: Swift.String?

    public init (
        recommenderArn: Swift.String? = nil
    )
    {
        self.recommenderArn = recommenderArn
    }
}

struct StartRecommenderInputBody: Swift.Equatable {
    let recommenderArn: Swift.String?
}

extension StartRecommenderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommenderArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommenderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommenderArn)
        recommenderArn = recommenderArnDecoded
    }
}

extension StartRecommenderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartRecommenderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartRecommenderOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartRecommenderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartRecommenderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.recommenderArn = output.recommenderArn
        } else {
            self.recommenderArn = nil
        }
    }
}

public struct StartRecommenderOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the recommender you started.
    public var recommenderArn: Swift.String?

    public init (
        recommenderArn: Swift.String? = nil
    )
    {
        self.recommenderArn = recommenderArn
    }
}

struct StartRecommenderOutputResponseBody: Swift.Equatable {
    let recommenderArn: Swift.String?
}

extension StartRecommenderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommenderArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommenderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommenderArn)
        recommenderArn = recommenderArnDecoded
    }
}

extension StopRecommenderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommenderArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recommenderArn = self.recommenderArn {
            try encodeContainer.encode(recommenderArn, forKey: .recommenderArn)
        }
    }
}

extension StopRecommenderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopRecommenderInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the recommender to stop.
    /// This member is required.
    public var recommenderArn: Swift.String?

    public init (
        recommenderArn: Swift.String? = nil
    )
    {
        self.recommenderArn = recommenderArn
    }
}

struct StopRecommenderInputBody: Swift.Equatable {
    let recommenderArn: Swift.String?
}

extension StopRecommenderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommenderArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommenderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommenderArn)
        recommenderArn = recommenderArnDecoded
    }
}

extension StopRecommenderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopRecommenderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StopRecommenderOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopRecommenderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StopRecommenderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.recommenderArn = output.recommenderArn
        } else {
            self.recommenderArn = nil
        }
    }
}

public struct StopRecommenderOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the recommender you stopped.
    public var recommenderArn: Swift.String?

    public init (
        recommenderArn: Swift.String? = nil
    )
    {
        self.recommenderArn = recommenderArn
    }
}

struct StopRecommenderOutputResponseBody: Swift.Equatable {
    let recommenderArn: Swift.String?
}

extension StopRecommenderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommenderArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommenderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommenderArn)
        recommenderArn = recommenderArnDecoded
    }
}

extension StopSolutionVersionCreationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solutionVersionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let solutionVersionArn = self.solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
    }
}

extension StopSolutionVersionCreationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopSolutionVersionCreationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the solution version you want to stop creating.
    /// This member is required.
    public var solutionVersionArn: Swift.String?

    public init (
        solutionVersionArn: Swift.String? = nil
    )
    {
        self.solutionVersionArn = solutionVersionArn
    }
}

struct StopSolutionVersionCreationInputBody: Swift.Equatable {
    let solutionVersionArn: Swift.String?
}

extension StopSolutionVersionCreationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solutionVersionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
    }
}

extension StopSolutionVersionCreationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopSolutionVersionCreationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StopSolutionVersionCreationOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopSolutionVersionCreationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopSolutionVersionCreationOutputResponse: Swift.Equatable {

    public init () { }
}

extension PersonalizeClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKey
        case tagValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagKey = self.tagKey {
            try encodeContainer.encode(tagKey, forKey: .tagKey)
        }
        if let tagValue = self.tagValue {
            try encodeContainer.encode(tagValue, forKey: .tagValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagKey)
        tagKey = tagKeyDecoded
        let tagValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagValue)
        tagValue = tagValueDecoded
    }
}

extension PersonalizeClientTypes {
    /// The optional metadata that you apply to resources to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. For more information see [Tagging Personalize resources](https://docs.aws.amazon.com/personalize/latest/dev/tagging-resources.html).
    public struct Tag: Swift.Equatable {
        /// One part of a key-value pair that makes up a tag. A key is a general label that acts like a category for more specific tag values.
        /// This member is required.
        public var tagKey: Swift.String?
        /// The optional part of a key-value pair that makes up a tag. A value acts as a descriptor within a tag category (key).
        /// This member is required.
        public var tagValue: Swift.String?

        public init (
            tagKey: Swift.String? = nil,
            tagValue: Swift.String? = nil
        )
        {
            self.tagKey = tagKey
            self.tagValue = tagValue
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The resource's Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tags to apply to the resource. For more information see [Tagging Personalize resources](https://docs.aws.amazon.com/personalize/latest/dev/tagging-resources.html).
    /// This member is required.
    public var tags: [PersonalizeClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [PersonalizeClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [PersonalizeClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PersonalizeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PersonalizeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension TooManyTagKeysException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TooManyTagKeysExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request contains more tag keys than can be associated with a resource (50 tag keys per resource).
public struct TooManyTagKeysException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTagKeysExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyTagKeysExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyTagsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have exceeded the maximum number of tags you can apply to this resource.
public struct TooManyTagsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PersonalizeClientTypes {
    public enum TrainingMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case full
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [TrainingMode] {
            return [
                .full,
                .update,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .full: return "FULL"
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TrainingMode(rawValue: rawValue) ?? TrainingMode.sdkUnknown(rawValue)
        }
    }
}

extension PersonalizeClientTypes.TunedHPOParams: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmHyperParameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmHyperParameters = algorithmHyperParameters {
            var algorithmHyperParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .algorithmHyperParameters)
            for (dictKey0, hyperParameters0) in algorithmHyperParameters {
                try algorithmHyperParametersContainer.encode(hyperParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let algorithmHyperParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .algorithmHyperParameters)
        var algorithmHyperParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let algorithmHyperParametersContainer = algorithmHyperParametersContainer {
            algorithmHyperParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in algorithmHyperParametersContainer {
                if let parametervalue0 = parametervalue0 {
                    algorithmHyperParametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        algorithmHyperParameters = algorithmHyperParametersDecoded0
    }
}

extension PersonalizeClientTypes {
    /// If hyperparameter optimization (HPO) was performed, contains the hyperparameter values of the best performing model.
    public struct TunedHPOParams: Swift.Equatable {
        /// A list of the hyperparameter values of the best performing model.
        public var algorithmHyperParameters: [Swift.String:Swift.String]?

        public init (
            algorithmHyperParameters: [Swift.String:Swift.String]? = nil
        )
        {
            self.algorithmHyperParameters = algorithmHyperParameters
        }
    }

}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The resource's Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Keys to remove from the resource's tags.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagKeysException" : self = .tooManyTagKeysException(try TooManyTagKeysException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagKeysException(TooManyTagKeysException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateCampaignInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignArn
        case campaignConfig
        case minProvisionedTPS
        case solutionVersionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignArn = self.campaignArn {
            try encodeContainer.encode(campaignArn, forKey: .campaignArn)
        }
        if let campaignConfig = self.campaignConfig {
            try encodeContainer.encode(campaignConfig, forKey: .campaignConfig)
        }
        if let minProvisionedTPS = self.minProvisionedTPS {
            try encodeContainer.encode(minProvisionedTPS, forKey: .minProvisionedTPS)
        }
        if let solutionVersionArn = self.solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
    }
}

extension UpdateCampaignInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateCampaignInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the campaign.
    /// This member is required.
    public var campaignArn: Swift.String?
    /// The configuration details of a campaign.
    public var campaignConfig: PersonalizeClientTypes.CampaignConfig?
    /// Specifies the requested minimum provisioned transactions (recommendations) per second that Amazon Personalize will support.
    public var minProvisionedTPS: Swift.Int?
    /// The ARN of a new solution version to deploy.
    public var solutionVersionArn: Swift.String?

    public init (
        campaignArn: Swift.String? = nil,
        campaignConfig: PersonalizeClientTypes.CampaignConfig? = nil,
        minProvisionedTPS: Swift.Int? = nil,
        solutionVersionArn: Swift.String? = nil
    )
    {
        self.campaignArn = campaignArn
        self.campaignConfig = campaignConfig
        self.minProvisionedTPS = minProvisionedTPS
        self.solutionVersionArn = solutionVersionArn
    }
}

struct UpdateCampaignInputBody: Swift.Equatable {
    let campaignArn: Swift.String?
    let solutionVersionArn: Swift.String?
    let minProvisionedTPS: Swift.Int?
    let campaignConfig: PersonalizeClientTypes.CampaignConfig?
}

extension UpdateCampaignInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignArn
        case campaignConfig
        case minProvisionedTPS
        case solutionVersionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .campaignArn)
        campaignArn = campaignArnDecoded
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let minProvisionedTPSDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minProvisionedTPS)
        minProvisionedTPS = minProvisionedTPSDecoded
        let campaignConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.CampaignConfig.self, forKey: .campaignConfig)
        campaignConfig = campaignConfigDecoded
    }
}

extension UpdateCampaignOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCampaignOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateCampaignOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCampaignOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateCampaignOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.campaignArn = output.campaignArn
        } else {
            self.campaignArn = nil
        }
    }
}

public struct UpdateCampaignOutputResponse: Swift.Equatable {
    /// The same campaign ARN as given in the request.
    public var campaignArn: Swift.String?

    public init (
        campaignArn: Swift.String? = nil
    )
    {
        self.campaignArn = campaignArn
    }
}

struct UpdateCampaignOutputResponseBody: Swift.Equatable {
    let campaignArn: Swift.String?
}

extension UpdateCampaignOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .campaignArn)
        campaignArn = campaignArnDecoded
    }
}

extension UpdateMetricAttributionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addMetrics
        case metricAttributionArn
        case metricsOutputConfig
        case removeMetrics
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addMetrics = addMetrics {
            var addMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addMetrics)
            for metricattribute0 in addMetrics {
                try addMetricsContainer.encode(metricattribute0)
            }
        }
        if let metricAttributionArn = self.metricAttributionArn {
            try encodeContainer.encode(metricAttributionArn, forKey: .metricAttributionArn)
        }
        if let metricsOutputConfig = self.metricsOutputConfig {
            try encodeContainer.encode(metricsOutputConfig, forKey: .metricsOutputConfig)
        }
        if let removeMetrics = removeMetrics {
            var removeMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .removeMetrics)
            for metricname0 in removeMetrics {
                try removeMetricsContainer.encode(metricname0)
            }
        }
    }
}

extension UpdateMetricAttributionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateMetricAttributionInput: Swift.Equatable {
    /// Add new metric attributes to the metric attribution.
    public var addMetrics: [PersonalizeClientTypes.MetricAttribute]?
    /// The Amazon Resource Name (ARN) for the metric attribution to update.
    public var metricAttributionArn: Swift.String?
    /// An output config for the metric attribution.
    public var metricsOutputConfig: PersonalizeClientTypes.MetricAttributionOutput?
    /// Remove metric attributes from the metric attribution.
    public var removeMetrics: [Swift.String]?

    public init (
        addMetrics: [PersonalizeClientTypes.MetricAttribute]? = nil,
        metricAttributionArn: Swift.String? = nil,
        metricsOutputConfig: PersonalizeClientTypes.MetricAttributionOutput? = nil,
        removeMetrics: [Swift.String]? = nil
    )
    {
        self.addMetrics = addMetrics
        self.metricAttributionArn = metricAttributionArn
        self.metricsOutputConfig = metricsOutputConfig
        self.removeMetrics = removeMetrics
    }
}

struct UpdateMetricAttributionInputBody: Swift.Equatable {
    let addMetrics: [PersonalizeClientTypes.MetricAttribute]?
    let removeMetrics: [Swift.String]?
    let metricsOutputConfig: PersonalizeClientTypes.MetricAttributionOutput?
    let metricAttributionArn: Swift.String?
}

extension UpdateMetricAttributionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addMetrics
        case metricAttributionArn
        case metricsOutputConfig
        case removeMetrics
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addMetricsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.MetricAttribute?].self, forKey: .addMetrics)
        var addMetricsDecoded0:[PersonalizeClientTypes.MetricAttribute]? = nil
        if let addMetricsContainer = addMetricsContainer {
            addMetricsDecoded0 = [PersonalizeClientTypes.MetricAttribute]()
            for structure0 in addMetricsContainer {
                if let structure0 = structure0 {
                    addMetricsDecoded0?.append(structure0)
                }
            }
        }
        addMetrics = addMetricsDecoded0
        let removeMetricsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .removeMetrics)
        var removeMetricsDecoded0:[Swift.String]? = nil
        if let removeMetricsContainer = removeMetricsContainer {
            removeMetricsDecoded0 = [Swift.String]()
            for string0 in removeMetricsContainer {
                if let string0 = string0 {
                    removeMetricsDecoded0?.append(string0)
                }
            }
        }
        removeMetrics = removeMetricsDecoded0
        let metricsOutputConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.MetricAttributionOutput.self, forKey: .metricsOutputConfig)
        metricsOutputConfig = metricsOutputConfigDecoded
        let metricAttributionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricAttributionArn)
        metricAttributionArn = metricAttributionArnDecoded
    }
}

extension UpdateMetricAttributionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMetricAttributionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateMetricAttributionOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMetricAttributionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateMetricAttributionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.metricAttributionArn = output.metricAttributionArn
        } else {
            self.metricAttributionArn = nil
        }
    }
}

public struct UpdateMetricAttributionOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the metric attribution that you updated.
    public var metricAttributionArn: Swift.String?

    public init (
        metricAttributionArn: Swift.String? = nil
    )
    {
        self.metricAttributionArn = metricAttributionArn
    }
}

struct UpdateMetricAttributionOutputResponseBody: Swift.Equatable {
    let metricAttributionArn: Swift.String?
}

extension UpdateMetricAttributionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricAttributionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricAttributionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricAttributionArn)
        metricAttributionArn = metricAttributionArnDecoded
    }
}

extension UpdateRecommenderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommenderArn
        case recommenderConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recommenderArn = self.recommenderArn {
            try encodeContainer.encode(recommenderArn, forKey: .recommenderArn)
        }
        if let recommenderConfig = self.recommenderConfig {
            try encodeContainer.encode(recommenderConfig, forKey: .recommenderConfig)
        }
    }
}

extension UpdateRecommenderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateRecommenderInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the recommender to modify.
    /// This member is required.
    public var recommenderArn: Swift.String?
    /// The configuration details of the recommender.
    /// This member is required.
    public var recommenderConfig: PersonalizeClientTypes.RecommenderConfig?

    public init (
        recommenderArn: Swift.String? = nil,
        recommenderConfig: PersonalizeClientTypes.RecommenderConfig? = nil
    )
    {
        self.recommenderArn = recommenderArn
        self.recommenderConfig = recommenderConfig
    }
}

struct UpdateRecommenderInputBody: Swift.Equatable {
    let recommenderArn: Swift.String?
    let recommenderConfig: PersonalizeClientTypes.RecommenderConfig?
}

extension UpdateRecommenderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommenderArn
        case recommenderConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommenderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommenderArn)
        recommenderArn = recommenderArnDecoded
        let recommenderConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.RecommenderConfig.self, forKey: .recommenderConfig)
        recommenderConfig = recommenderConfigDecoded
    }
}

extension UpdateRecommenderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRecommenderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateRecommenderOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRecommenderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateRecommenderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.recommenderArn = output.recommenderArn
        } else {
            self.recommenderArn = nil
        }
    }
}

public struct UpdateRecommenderOutputResponse: Swift.Equatable {
    /// The same recommender Amazon Resource Name (ARN) as given in the request.
    public var recommenderArn: Swift.String?

    public init (
        recommenderArn: Swift.String? = nil
    )
    {
        self.recommenderArn = recommenderArn
    }
}

struct UpdateRecommenderOutputResponseBody: Swift.Equatable {
    let recommenderArn: Swift.String?
}

extension UpdateRecommenderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommenderArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommenderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommenderArn)
        recommenderArn = recommenderArnDecoded
    }
}
